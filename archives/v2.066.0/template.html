
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Templates - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run-main-website.js" type="text/javascript"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
    var links = document.getElementById("navigation").getElementsByTagName("a");
    for (var i = 0; i < links.length; i++)
    {
        var url = "/" + links[i].getAttribute("href");
        if (window.location.href.match(url + "\x24") == url)
        {
            var cls = links[i].getAttribute("class");
            links[i].setAttribute("class", cls ? cls + " active" : "active");
            break;
        }
    }
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
    <div id="search-box">
        <form method="get" action="http://google.com/search">
            <img src="images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="images/search-button.gif" />
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <div id="search-dropdown">
                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </div>
        </form>
    </div>
    <div id="header">
        <a id="d-language" href="/">
        <img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png">
        D Programming Language</a>
    </div>
</div>

<!--Generated by Ddoc from template.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D 2.066.0</a></h2>
<ul>    <li><a href="overview.html" title="D language overview">Overview</a></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://ddili.org/ders/d.en/index.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a>

    <div class="navblock">
<ul>    <li><a href="intro.html">Introduction</a></li>
    <li><a href="lex.html">Lexical</a></li>
    <li><a href="grammar.html">Grammar</a></li>
    <li><a href="module.html">Modules</a></li>
    <li><a href="declaration.html">Declarations</a></li>
    <li><a href="type.html">Types</a></li>
    <li><a href="property.html">Properties</a></li>
    <li><a href="attribute.html">Attributes</a></li>
    <li><a href="pragma.html">Pragmas</a></li>
    <li><a href="expression.html">Expressions</a></li>
    <li><a href="statement.html">Statements</a></li>
    <li><a href="arrays.html">Arrays</a></li>
    <li><a href="hash-map.html">Associative Arrays</a></li>
    <li><a href="struct.html">Structs &amp; Unions</a></li>
    <li><a href="class.html">Classes</a></li>
    <li><a href="interface.html">Interfaces</a></li>
    <li><a href="enum.html">Enums</a></li>
    <li><a href="const3.html">Const and Immutable</a></li>
    <li><a href="function.html">Functions</a></li>
    <li><a href="operatoroverloading.html">Operator Overloading</a></li>
    <li><a href="template.html">Templates</a></li>
    <li><a href="template-mixin.html">Template Mixins</a></li>
    <li><a href="contracts.html">Contracts</a></li>
    <li><a href="version.html">Conditional Compilation</a></li>
    <li><a href="traits.html">Traits</a></li>
    <li><a href="errors.html">Handling errors</a></li>
    <li><a href="unittest.html">Unit Tests</a></li>
    <li><a href="garbage.html">Garbage Collection</a></li>
    <li><a href="float.html">Floating Point</a></li>
    <li><a href="iasm.html">Inline Assembler</a></li>
    <li><a href="ddoc.html">Documentation Comments</a></li>
    <li><a href="interfaceToC.html">Interfacing To C</a></li>
    <li><a href="cpp_interface.html">Interfacing To C++</a></li>
    <li><a href="portability.html">Portability Guide</a></li>
    <li><a href="entity.html">Named Character Entities</a></li>
    <li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
    <li><a href="abi.html">Application Binary Interface</a></li>
    <li><a href="simd.html">Vector Extensions</a></li>
    </ul>
</div></li>
    <li><a href="phobos/index.html">Library Reference</a></li>
    <li><a href="library/index.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a></li>
</ul>
    </div>

<div class="navblock">
<h2><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></h2>
<ul></ul>
    </div>

<div class="navblock">
<h2>Community</h2>
<ul>    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
    
</ul>
    </div>
  
<div id="translate" class="tool">Translate this page:
    <div id="google_translate_element"></div><script type="text/javascript">
    function googleTranslateElementInit() {
      new google.translate.TranslateElement({
        pageLanguage: 'en',
        autoDisplay: false,
        layout: google.translate.TranslateElement.InlineLayout.SIMPLE
      }, 'google_translate_element');
    }
    </script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>
</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
    <!--span id="lastupdate">Last update (no date time)</span-->
    <span class="tip">
        <a href="https://github.com/D-Programming-Language/dlang.org/edit/master/template.dd" class="button">Improve this page</a>
        <span>
            Quickly fork, edit online, and submit a pull request for this page.
            Requires a signed-in GitHub account. This works well for small changes.
            If you'd like to make larger changes you may want to consider using
            local clone.
        </span>
    </span>
    <span class="tip">
        <a href="http://wiki.dlang.org/DocComments/Template" class="button">Page wiki</a>
        <span>
            View or edit the community-maintained wiki page associated with this page.
        </span>
    </span>
</div>
  <h1>Templates</h1>
  
<blockquote><p></p><cite>I think that I can safely say that nobody understands C++ template mechanics. -- Richard Deyman
</cite></blockquote>

    <p>Templates are D's approach to generic programming.
        Templates are defined with a <i>TemplateDeclaration</i>:
    </p>

<pre class="bnf"><span class="notranslate"><a name="TemplateDeclaration"><i>TemplateDeclaration</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">template</span></span> <i>Identifier</i> <a href="#TemplateParameters"><i>TemplateParameters</i></a> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">{</span></span> <a href="module.html#DeclDefs"><i>DeclDefs</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">}</span></span>

<a name="TemplateParameters"><i>TemplateParameters</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#TemplateParameterList"><i>TemplateParameterList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>

<a name="TemplateParameterList"><i>TemplateParameterList</i></a>:
    <a href="#TemplateParameter"><i>TemplateParameter</i></a>
    <a href="#TemplateParameter"><i>TemplateParameter</i></a> ,
    <a href="#TemplateParameter"><i>TemplateParameter</i></a> , <i>TemplateParameterList</i>

<a name="TemplateParameter"><i>TemplateParameter</i></a>:
    <a href="#TemplateTypeParameter"><i>TemplateTypeParameter</i></a>
    <a href="#TemplateValueParameter"><i>TemplateValueParameter</i></a>
    <a href="#TemplateAliasParameter"><i>TemplateAliasParameter</i></a>
    <a href="#TemplateTupleParameter"><i>TemplateTupleParameter</i></a>
    <a href="#TemplateThisParameter"><i>TemplateThisParameter</i></a>
</span></pre>

    <p>The body of the <i>TemplateDeclaration</i> must be syntactically correct
        even if never instantiated. Semantic analysis is not done until
        instantiated. A template forms its own scope, and the template
        body can contain classes, structs, types, enums, variables,
        functions, and other templates.
    </p>

    <p>Template parameters can be types, values, symbols, or tuples.
        Types can be any type.
        Value parameters must be of an integral type, floating point
        type, or string type and
        specializations for them must resolve to an integral constant,
        floating point constant, null, or a string literal.
        Symbols can be any non-local symbol.
        Tuples are a sequence of 0 or more types, values or symbols.
    </p>

    <p>Template parameter specializations
        constrain the values or types the <i>TemplateParameter</i> can
        accept.
    </p>
    <p>Template parameter defaults are the value or type to use for the
        <i>TemplateParameter</i> in case one is not supplied.
    </p>

<h2>Explicit Template Instantiation</h2>

    <p>Templates are explicitly instantiated with:
    </p>

<pre class="bnf"><span class="notranslate"><a name="TemplateInstance"><i>TemplateInstance</i></a>:
    <i>Identifier</i> <a href="#TemplateArguments"><i>TemplateArguments</i></a>

<a name="TemplateArguments"><i>TemplateArguments</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">! (</span></span> <a href="#TemplateArgumentList"><i>TemplateArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">!</span></span> <a href="#TemplateSingleArgument"><i>TemplateSingleArgument</i></a>

<a name="TemplateArgumentList"><i>TemplateArgumentList</i></a>:
    <a href="#TemplateArgument"><i>TemplateArgument</i></a>
    <a href="#TemplateArgument"><i>TemplateArgument</i></a> ,
    <a href="#TemplateArgument"><i>TemplateArgument</i></a> , <i>TemplateArgumentList</i>

<a name="TemplateArgument"><i>TemplateArgument</i></a>:
    <a href="declaration.html#Type"><i>Type</i></a>
    <a href="expression.html#AssignExpression"><i>AssignExpression</i></a>
    <a href="#Symbol"><i>Symbol</i></a>

<a name="Symbol"><i>Symbol</i></a>:
    <a href="#SymbolTail"><i>SymbolTail</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <a href="#SymbolTail"><i>SymbolTail</i></a>

<a name="SymbolTail"><i>SymbolTail</i></a>:
    <i>Identifier</i>
    <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <i>SymbolTail</i>
    <a href="#TemplateInstance"><i>TemplateInstance</i></a>
    <a href="#TemplateInstance"><i>TemplateInstance</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <i>SymbolTail</i>

<a name="TemplateSingleArgument"><i>TemplateSingleArgument</i></a>:
    <i>Identifier</i>
    <a href="declaration.html#BasicTypeX"><i>BasicTypeX</i></a>
    <a href="lex.html#CharacterLiteral"><i>CharacterLiteral</i></a>
    <a href="lex.html#StringLiteral"><i>StringLiteral</i></a>
    <a href="lex.html#IntegerLiteral"><i>IntegerLiteral</i></a>
    <a href="lex.html#FloatLiteral"><i>FloatLiteral</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">true</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">false</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span>
    <a href="traits.html#SpecialKeyword"><i>SpecialKeyword</i></a>
</span></pre>

    <p>Once instantiated, the declarations inside the template, called
        the template members, are in the scope
        of the <i>TemplateInstance</i>:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">alias</span> t = T*; }
...
TFoo!(<span class="d_keyword">int</span>).t x; <span class="d_comment">// declare x to be of type int*
</span></span></pre>
    </p>

    <p>If the <a href="#TemplateArgument"><i>TemplateArgument</i></a> is one token long, the parentheses can be omitted:

<pre class="d_code"><span class="notranslate">TFoo!<span class="d_keyword">int</span>.t x;   <span class="d_comment">// same as TFoo!(int).t x;
</span></span></pre>
        </p>

    <p>A template instantiation can be aliased:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">alias</span> t = T*; }
<span class="d_keyword">alias</span> abc = TFoo!(<span class="d_keyword">int</span>);
abc.t x;        <span class="d_comment">// declare x to be of type int*
</span></span></pre>
    </p>

    <p>Multiple instantiations of a <i>TemplateDeclaration</i> with the same
        <i>TemplateArgumentList</i> all will refer to the same instantiation.
        For example:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TFoo(T) { T f; }
<span class="d_keyword">alias</span> a = TFoo!(<span class="d_keyword">int</span>);
<span class="d_keyword">alias</span> b = TFoo!(<span class="d_keyword">int</span>);
...
a.f = 3;
<span class="d_keyword">assert</span>(b.f == 3);  <span class="d_comment">// a and b refer to the same instance of TFoo
</span></span></pre>
    </p>

    <p>This is true even if the <i>TemplateInstance</i>s are done in
        different modules.
    </p>

    <p>Even if template arguments are implicitly converted to the same
        template parameter type, they still refer to same instance:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> TFoo(<span class="d_keyword">int</span> x) { }

<span class="d_comment">// 3 and 2+1 are both 3 of type int
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(TFoo!(3) == TFoo!(2 + 1)));

<span class="d_comment">// 3u is implicitly converted to 3 to match int parameter,
</span><span class="d_comment">// and refers exactly same instance with TFoo!(3).
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(TFoo!(3) == TFoo!(3u)));
</span></pre>
    </p>

    <p>If multiple templates with the same <i>Identifier</i> are
        declared, they are distinct if they have a different number of
        arguments or are differently specialized.
    </p>

    <p>For example, a simple generic copy template would be:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TCopy(T) {
  <span class="d_keyword">void</span> copy(<span class="d_keyword">out</span> T to, T from) {
    to = from;
  }
}
</span></pre>
    </p>

    <p>To use the template, it must first be instantiated with a specific
        type:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> i;
TCopy!(<span class="d_keyword">int</span>).copy(i, 3);
</span></pre>
    </p>

<h2>Instantiation Scope</h2>

    <p><i>TemplateInstantance</i>s are always performed in the scope of where
        the <i>TemplateDeclaration</i> is declared, with the addition of the
        template parameters being declared as aliases for their deduced types.
    </p>
    <p>For example:

        <br><br>
        <u>module a</u>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">void</span> bar() { func(); } }
</span></pre>

        <u>module b</u>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> a;

<span class="d_keyword">void</span> func() { }
<span class="d_keyword">alias</span> f = TFoo!(<span class="d_keyword">int</span>); <span class="d_comment">// error: func not defined in module a
</span></span></pre>
    </p>

    <p>and:

        <br><br>
        <u>module a</u>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">void</span> bar() { func(1); } }
<span class="d_keyword">void</span> func(<span class="d_keyword">double</span> d) { }
</span></pre>

        <u>module b</u>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> a;

<span class="d_keyword">void</span> func(<span class="d_keyword">int</span> i) { }
<span class="d_keyword">alias</span> f = TFoo!(<span class="d_keyword">int</span>);
...
f.bar();  <span class="d_comment">// will call a.func(double)
</span></span></pre>
    </p>

    <p><i>TemplateParameter</i> specializations and default
        values are evaluated in the scope of the <i>TemplateDeclaration</i>.
    </p>

<h2>Argument Deduction</h2>

    <p>The types of template parameters are deduced for a particular
        template instantiation by comparing the template argument with
        the corresponding template parameter.
    </p>

    <p>For each template parameter, the following rules are applied in
        order until a type is deduced for each parameter:
    </p>

    <ol>        <li>If there is no type specialization for the parameter,
        the type of the parameter is set to the template argument.</li>

        <li>If the type specialization is dependent on a type parameter,
        the type of that parameter is set to be the corresponding part
        of the type argument.</li>

        <li>If after all the type arguments are examined there are any
        type parameters left with no type assigned, they are assigned
        types corresponding to the template argument in the same position
        in the <i>TemplateArgumentList</i>.</li>

        <li>If applying the above rules does not result in exactly one
        type for each template parameter, then it is an error.</li>
    </ol>

    <p>For example:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TFoo(T) { }
<span class="d_keyword">alias</span> Foo1 = TFoo!(<span class="d_keyword">int</span>);     <span class="d_comment">// (1) T is deduced to be int
</span><span class="d_keyword">alias</span> Foo2 = TFoo!(<span class="d_keyword">char</span>*);   <span class="d_comment">// (1) T is deduced to be char*
</span>
<span class="d_keyword">template</span> TBar(T : T*) { }
<span class="d_keyword">alias</span> Foo3 = TBar!(<span class="d_keyword">char</span>*);   <span class="d_comment">// (2) T is deduced to be char
</span>
<span class="d_keyword">template</span> TAbc(D, U : D[]) { }
<span class="d_keyword">alias</span> Bar1 = TAbc!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>[]);  <span class="d_comment">// (2) D is deduced to be int, U is int[]
</span><span class="d_keyword">alias</span> Bar2 = TAbc!(<span class="d_keyword">char</span>, <span class="d_keyword">int</span>[]); <span class="d_comment">// (4) error, D is both char and int
</span>
<span class="d_keyword">template</span> TDef(D : E*, E) { }
<span class="d_keyword">alias</span> Bar3 = TDef!(<span class="d_keyword">int</span>*, <span class="d_keyword">int</span>); <span class="d_comment">// (1) E is int
</span>                               <span class="d_comment">// (3) D is int*
</span></span></pre>
    </p>

    <p>Deduction from a specialization can provide values
        for more than one parameter:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(T: T[U], U) {
  ...
}

Foo!(<span class="d_keyword">int</span>[<span class="d_keyword">long</span>])  <span class="d_comment">// instantiates Foo with T set to int, U set to long
</span></span></pre>
    </p>

    <p>When considering matches, a class is
        considered to be a match for any super classes or interfaces:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">template</span> TFoo(T : A) { }
<span class="d_keyword">alias</span> Foo4 = TFoo!(B);     <span class="d_comment">// (3) T is B
</span>
<span class="d_keyword">template</span> TBar(T : U*, U : A) { }
<span class="d_keyword">alias</span> Foo5 = TBar!(B*, B); <span class="d_comment">// (2) T is B*
</span>                           <span class="d_comment">// (3) U is B
</span></span></pre>
    </p>

<h2>Template Type Parameters</h2>

<pre class="bnf"><span class="notranslate"><a name="TemplateTypeParameter"><i>TemplateTypeParameter</i></a>:
    <i>Identifier</i>
    <i>Identifier</i> <a href="#TemplateTypeParameterSpecialization"><i>TemplateTypeParameterSpecialization</i></a>
    <i>Identifier</i> <a href="#TemplateTypeParameterDefault"><i>TemplateTypeParameterDefault</i></a>
    <i>Identifier</i> <a href="#TemplateTypeParameterSpecialization"><i>TemplateTypeParameterSpecialization</i></a> <a href="#TemplateTypeParameterDefault"><i>TemplateTypeParameterDefault</i></a>

<a name="TemplateTypeParameterSpecialization"><i>TemplateTypeParameterSpecialization</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="declaration.html#Type"><i>Type</i></a>

<a name="TemplateTypeParameterDefault"><i>TemplateTypeParameterDefault</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="declaration.html#Type"><i>Type</i></a>
</span></pre>

<h3>Specialization</h3>

    <p>Templates may be specialized for particular types of arguments
        by following the template parameter identifier with a : and the
        specialized type.
        For example:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> TFoo(T)        { ... } <span class="d_comment">// #1
</span><span class="d_keyword">template</span> TFoo(T : T[])  { ... } <span class="d_comment">// #2
</span><span class="d_keyword">template</span> TFoo(T : <span class="d_keyword">char</span>) { ... } <span class="d_comment">// #3
</span><span class="d_keyword">template</span> TFoo(T, U, V)  { ... } <span class="d_comment">// #4
</span>
<span class="d_keyword">alias</span> foo1 = TFoo!(<span class="d_keyword">int</span>);            <span class="d_comment">// instantiates #1
</span><span class="d_keyword">alias</span> foo2 = TFoo!(<span class="d_keyword">double</span>[]);       <span class="d_comment">// instantiates #2 with T being double
</span><span class="d_keyword">alias</span> foo3 = TFoo!(<span class="d_keyword">char</span>);           <span class="d_comment">// instantiates #3
</span><span class="d_keyword">alias</span> fooe = TFoo!(<span class="d_keyword">char</span>, <span class="d_keyword">int</span>);      <span class="d_comment">// error, number of arguments mismatch
</span><span class="d_keyword">alias</span> foo4 = TFoo!(<span class="d_keyword">char</span>, <span class="d_keyword">int</span>, <span class="d_keyword">int</span>); <span class="d_comment">// instantiates #4
</span></span></pre>
    </p>

    <p>The template picked to instantiate is the one that is most specialized
        that fits the types of the <i>TemplateArgumentList</i>.
        Determine which is more specialized is done the same way as the
        C++ partial ordering rules.
        If the result is ambiguous, it is an error.
    </p>


<h2>Template This Parameters</h2>

<pre class="bnf"><span class="notranslate"><a name="TemplateThisParameter"><i>TemplateThisParameter</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> <i>TemplateTypeParameter</i>
</span></pre>

    <p><i>TemplateThisParameter</i>s are used in member function templates
        to pick up the type of the <i>this</i> reference.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">const</span> <span class="d_keyword">void</span> foo(<span class="d_keyword">this</span> T)(<span class="d_keyword">int</span> i) {
    writeln(<span class="d_keyword">typeid</span>(T));
  }
}

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">const</span>(S) s;
  (&amp;s).foo(1);
  S s2;
  s2.foo(2);
  <span class="d_keyword">immutable</span>(S) s3;
  s3.foo(3);
}
</span></pre>
    </p>

    <p>Prints:

<pre class="console"><span class="notranslate">const(S)
S
immutable(S)
</span></pre>
    </p>

    <p>This is especially useful when used with inheritance. For example,
        you might want to implement a final base method which returns a derived
        class type. Typically you would return a base type, but this won't allow
        you to call or access derived properties of the type:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">interface</span> Addable(T)
{
    <span class="d_keyword">final</span> <span class="d_keyword">auto</span> add(T t)
    {
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}

<span class="d_keyword">class</span> List(T) : Addable!T
{
    List remove(T t)
    {
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> list = <span class="d_keyword">new</span> List!<span class="d_keyword">int</span>;
    list.add(1).remove(1);  <span class="d_comment">// error: no 'remove' method for Addable!int
</span>}
</span></pre>
    </p>

    <p>Here the method <span class="notranslate"><span class="d_inlinecode donthyphenate">add</span></span> returns the base type, which doesn't implement the
        <span class="notranslate"><span class="d_inlinecode donthyphenate">remove</span></span> method. The <span class="notranslate"><span class="d_inlinecode donthyphenate">template this</span></span> parameter can be used for this purpose:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">interface</span> Addable(T)
{
    <span class="d_keyword">final</span> R add(<span class="d_keyword">this</span> R)(T t)
    {
        <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(R)<span class="d_keyword">this</span>;  <span class="d_comment">// cast is necessary, but safe
</span>    }
}

<span class="d_keyword">class</span> List(T) : Addable!T
{
    List remove(T t)
    {
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> list = <span class="d_keyword">new</span> List!<span class="d_keyword">int</span>;
    list.add(1).remove(1);  <span class="d_comment">// ok
</span>}
</span></pre>
    </p>

<h2>Template Value Parameters</h2>

<pre class="bnf"><span class="notranslate"><a name="TemplateValueParameter"><i>TemplateValueParameter</i></a>:
    <a href="declaration.html#BasicType"><i>BasicType</i></a> <a href="declaration.html#Declarator"><i>Declarator</i></a>
    <a href="declaration.html#BasicType"><i>BasicType</i></a> <a href="declaration.html#Declarator"><i>Declarator</i></a> <a href="#TemplateValueParameterSpecialization"><i>TemplateValueParameterSpecialization</i></a>
    <a href="declaration.html#BasicType"><i>BasicType</i></a> <a href="declaration.html#Declarator"><i>Declarator</i></a> <a href="#TemplateValueParameterDefault"><i>TemplateValueParameterDefault</i></a>
    <a href="declaration.html#BasicType"><i>BasicType</i></a> <a href="declaration.html#Declarator"><i>Declarator</i></a> <a href="#TemplateValueParameterSpecialization"><i>TemplateValueParameterSpecialization</i></a> <a href="#TemplateValueParameterDefault"><i>TemplateValueParameterDefault</i></a>

<a name="TemplateValueParameterSpecialization"><i>TemplateValueParameterSpecialization</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="expression.html#ConditionalExpression"><i>ConditionalExpression</i></a>

<a name="TemplateValueParameterDefault"><i>TemplateValueParameterDefault</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="expression.html#AssignExpression"><i>AssignExpression</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="traits.html#SpecialKeyword"><i>SpecialKeyword</i></a>
</span></pre>

    <p>Template value parameter types can be any type which can
        be statically initialized at compile time.
        Template value arguments can be integer values, floating point values,
        nulls, string values, array literals of template value arguments,
        associative array literals of template value arguments,
        or struct literals of template value arguments.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> foo(string s) {
  string bar() { <span class="d_keyword">return</span> s ~ <span class="d_string">" betty"</span>; }
}

<span class="d_keyword">void</span> main() {
  writefln(<span class="d_string">"%s"</span>, foo!(<span class="d_string">"hello"</span>).bar()); <span class="d_comment">// prints: hello betty
</span>}
</span></pre>
    </p>

    <p>This example of template foo has a value parameter that
        is specialized for 10:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> foo(U : <span class="d_keyword">int</span>, <span class="d_keyword">int</span> T : 10) {
  U x = T;
}

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">assert</span>(foo!(<span class="d_keyword">int</span>, 10).x == 10);
}
</span></pre>
    </p>


<h2><a name="aliasparameters">Template Alias Parameters</a></h2>

<pre class="bnf"><span class="notranslate"><a name="TemplateAliasParameter"><i>TemplateAliasParameter</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">alias</span></span> <i>Identifier</i> <a href="#TemplateAliasParameterSpecialization"><i>TemplateAliasParameterSpecialization</i></a><sub>opt</sub> <a href="#TemplateAliasParameterDefault"><i>TemplateAliasParameterDefault</i></a><sub>opt</sub>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">alias</span></span> <a href="declaration.html#BasicType"><i>BasicType</i></a> <a href="declaration.html#Declarator"><i>Declarator</i></a> <a href="#TemplateAliasParameterSpecialization"><i>TemplateAliasParameterSpecialization</i></a><sub>opt</sub> <a href="#TemplateAliasParameterDefault"><i>TemplateAliasParameterDefault</i></a><sub>opt</sub>

<a name="TemplateAliasParameterSpecialization"><i>TemplateAliasParameterSpecialization</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="declaration.html#Type"><i>Type</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="expression.html#ConditionalExpression"><i>ConditionalExpression</i></a>

<a name="TemplateAliasParameterDefault"><i>TemplateAliasParameterDefault</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="declaration.html#Type"><i>Type</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="expression.html#ConditionalExpression"><i>ConditionalExpression</i></a>
</span></pre>

    <p>Alias parameters enable templates to be parameterized with
        any type of D symbol, including global names, local names,
        module names, template names, and template instance names.
        Literals can also be used as arguments to alias parameters.
    </p>

    <ul>        <li>Global names

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> x;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X) {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span>* p = &amp;X;
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">alias</span> bar = Foo!(x);
  *bar.p = 3;       <span class="d_comment">// set x to 3
</span>  <span class="d_keyword">static</span> <span class="d_keyword">int</span> y;
  <span class="d_keyword">alias</span> abc = Foo!(y);
  *abc.p = 3;       <span class="d_comment">// set y to 3
</span>}
</span></pre>
        </li>

        <li>Type names

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> p;
}

<span class="d_keyword">template</span> Bar(<span class="d_keyword">alias</span> T) {
  <span class="d_keyword">alias</span> q = T.p;
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">alias</span> bar = Bar!(Foo);
  bar.q = 3;  <span class="d_comment">// sets Foo.p to 3
</span>}
</span></pre>
        </li>

        <li>Module names

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.string;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X) {
  <span class="d_keyword">alias</span> y = X.toString;
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">alias</span> bar = Foo!(std.string);
  bar.y(3);   <span class="d_comment">// calls std.string.toString(3)
</span>}
</span></pre>
        </li>

        <li>Template names

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> x;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X) {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span>* p = &amp;X;
}

<span class="d_keyword">template</span> Bar(<span class="d_keyword">alias</span> T) {
  <span class="d_keyword">alias</span> abc = T!(x);
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">alias</span> bar = Bar!(Foo);
  *bar.abc.p = 3;  <span class="d_comment">// sets x to 3
</span>}
</span></pre>
        </li>

        <li>Template alias names

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> x;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X) {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span>* p = &amp;X;
}

<span class="d_keyword">template</span> Bar(<span class="d_keyword">alias</span> T) {
  <span class="d_keyword">alias</span> q = T.p;
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">alias</span> foo = Foo!(x);
  <span class="d_keyword">alias</span> bar = Bar!(foo);
  *bar.q = 3;  <span class="d_comment">// sets x to 3
</span>}
</span></pre>
        </li>

        <li>Literals

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X, <span class="d_keyword">alias</span> Y) {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> i = X;
  <span class="d_keyword">static</span> string s = Y;
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">alias</span> foo = Foo!(3, <span class="d_string">"bar"</span>);
  writeln(foo.i, foo.s);  <span class="d_comment">// prints 3bar
</span>}
</span></pre>
        </li>
    </ul>

<h3>Typed alias parameters</h3>

    <p>Alias parameters can also be typed.
        These parameters will accept symbols of that type:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> <span class="d_keyword">int</span> x) { }
<span class="d_keyword">int</span> x;
<span class="d_keyword">float</span> f;

Foo!x;  <span class="d_comment">// ok
</span>Foo!f;  <span class="d_comment">// fails to instantiate
</span></span></pre>
    </p>

<h3>Specialization</h3>

    <p>Alias parameters can accept both literals and user-defined type symbols,
        but they are less specialized than the matches to type parameters and
        value parameters:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(T)         { ... }  <span class="d_comment">// #1
</span><span class="d_keyword">template</span> Foo(<span class="d_keyword">int</span> n)     { ... }  <span class="d_comment">// #2
</span><span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> sym) { ... }  <span class="d_comment">// #3
</span>
<span class="d_keyword">struct</span> S {}
<span class="d_keyword">int</span> var;

<span class="d_keyword">alias</span> foo1  = Foo!(S);      <span class="d_comment">// instantiates #1
</span><span class="d_keyword">alias</span> foo2  = Foo!(1);      <span class="d_comment">// instantiates #2
</span><span class="d_keyword">alias</span> foo3a = Foo!([1,2]);  <span class="d_comment">// instantiates #3
</span><span class="d_keyword">alias</span> foo3b = Foo!(var);    <span class="d_comment">// instantiates #3
</span></span></pre>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Bar(<span class="d_keyword">alias</span> A) { ... }                 <span class="d_comment">// #4
</span><span class="d_keyword">template</span> Bar(T : U!V, <span class="d_keyword">alias</span> U, V...) { ... }  <span class="d_comment">// #5
</span>
<span class="d_keyword">class</span> C(T) {}
<span class="d_keyword">alias</span> bar = Bar!(C!<span class="d_keyword">int</span>);    <span class="d_comment">// instantiates #5
</span></span></pre>
    </p>

<h2><a name="variadic-templates">Template Tuple Parameters</a></h2>

<pre class="bnf"><span class="notranslate"><a name="TemplateTupleParameter"><i>TemplateTupleParameter</i></a>:
    <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">...</span></span>
</span></pre>

    <p>If the last template parameter in the <i>TemplateParameterList</i>
        is declared as a <i>TemplateTupleParameter</i>,
        it is a match with any trailing template arguments.
        The sequence of arguments form a <i>Tuple</i>.
        A <i>Tuple</i> is not a type, an expression, or a symbol.
        It is a sequence of any mix of types, expressions or symbols.
    </p>

    <p>A <i>Tuple</i> whose elements consist entirely of types is
        called a <i>TypeTuple</i>.
        A <i>Tuple</i> whose elements consist entirely of expressions is
        called an <i>ExpressionTuple</i>.
    </p>

    <p>A <i>Tuple</i> can be used as an argument list to instantiate
        another template, or as the list of parameters for a function.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Print(A ...) {
  <span class="d_keyword">void</span> print() {
    writefln(<span class="d_string">"args are "</span>, A);
  }
}

<span class="d_keyword">template</span> Write(A ...) {
  <span class="d_keyword">void</span> write(A a) <span class="d_comment">// A is a TypeTuple
</span>                  <span class="d_comment">// a is an ExpressionTuple
</span>  {
    writefln(<span class="d_string">"args are "</span>, a);
  }
}

<span class="d_keyword">void</span> main() {
  Print!(1,'a',6.8).print();                    <span class="d_comment">// prints: args are 1a6.8
</span>  Write!(<span class="d_keyword">int</span>, <span class="d_keyword">char</span>, <span class="d_keyword">double</span>).write(1, 'a', 6.8); <span class="d_comment">// prints: args are 1a6.8
</span>}
</span></pre>
    </p>

    <p>Template tuples can be deduced from the types of
        the trailing parameters
        of an implicitly instantiated function template:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(T, R...) {
  <span class="d_keyword">void</span> Foo(T t, R r) {
    writeln(t);
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (r.length) <span class="d_comment">// if more arguments
</span>      Foo(r);            <span class="d_comment">// do the rest of the arguments
</span>  }
}

<span class="d_keyword">void</span> main() {
  Foo(1, 'a', 6.8);
}
</span></pre>
    </p>

    <p>prints:

<pre class="console"><span class="notranslate">1
a
6.8
</span></pre>
    </p>

    <p>The tuple can also be deduced from the type of a delegate
        or function parameter list passed as a function argument:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_comment">/* R is return type
 * A is first argument type
 * U is TypeTuple of rest of argument types
 */</span>
R <span class="d_keyword">delegate</span>(U) Curry(R, A, U...)(R <span class="d_keyword">delegate</span>(A, U) dg, A arg)
{
  <span class="d_keyword">struct</span> Foo
  {
    <span class="d_keyword">typeof</span>(dg) dg_m;
    <span class="d_keyword">typeof</span>(arg) arg_m;

    R bar(U u)
    {
      <span class="d_keyword">return</span> dg_m(arg_m, u);
    }
  }

  Foo* f = <span class="d_keyword">new</span> Foo;
  f.dg_m = dg;
  f.arg_m = arg;
  <span class="d_keyword">return</span> &amp;f.bar;
}

<span class="d_keyword">void</span> main()
{
  <span class="d_keyword">int</span> plus(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, <span class="d_keyword">int</span> z)
  {
    <span class="d_keyword">return</span> x + y + z;
  }

  <span class="d_keyword">auto</span> plus_two = Curry(&amp;plus, 2);
  writefln(<span class="d_string">"%d"</span>, plus_two(6, 8)); <span class="d_comment">// prints 16
</span>}
</span></pre>
    </p>

    <p>The number of elements in a <i>Tuple</i> can be retrieved with
        the <span class="notranslate"><span class="d_inlinecode donthyphenate">.length</span></span> property. The <i>n</i>th element can be retrieved
        by indexing the <i>Tuple</i> with [<i>n</i>],
        and sub tuples can be created
        with the slicing syntax.
    </p>

    <p><i>Tuple</i>s are static compile time entities, there is no way
        to dynamically change, add, or remove elements.
    </p>

<h3>Specialization</h3>

    <p>If both a template with a tuple parameter and a template
        without a tuple parameter exactly match a template instantiation,
        the template without a <i>TemplateTupleParameter</i> is selected.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(T)         { <span class="d_keyword">pragma</span>(msg, <span class="d_string">"1"</span>); }   <span class="d_comment">// #1
</span><span class="d_keyword">template</span> Foo(<span class="d_keyword">int</span> n)     { <span class="d_keyword">pragma</span>(msg, <span class="d_string">"2"</span>); }   <span class="d_comment">// #2
</span><span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> sym) { <span class="d_keyword">pragma</span>(msg, <span class="d_string">"3"</span>); }   <span class="d_comment">// #3
</span><span class="d_keyword">template</span> Foo(A ...)     { <span class="d_keyword">pragma</span>(msg, <span class="d_string">"4"</span>); }   <span class="d_comment">// #4
</span>
<span class="d_keyword">import</span> std.stdio;

<span class="d_comment">// Any sole template argument will never match to #4
</span><span class="d_keyword">alias</span> foo1 = Foo!(<span class="d_keyword">int</span>);          <span class="d_comment">// instantiates #1
</span><span class="d_keyword">alias</span> foo2 = Foo!(3);            <span class="d_comment">// instantiates #2
</span><span class="d_keyword">alias</span> foo3 = Foo!(std);          <span class="d_comment">// instantiates #3
</span>
<span class="d_keyword">alias</span> foo4 = Foo!(<span class="d_keyword">int</span>, 3, std);  <span class="d_comment">// instantiates #4
</span></span></pre>
    </p>

<h2>Template Parameter Default Values</h2>

    <p>Trailing template parameters can be given default values:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(T, U = <span class="d_keyword">int</span>) { ... }
Foo!(<span class="d_keyword">uint</span>,<span class="d_keyword">long</span>); <span class="d_comment">// instantiate Foo with T as uint, and U as long
</span>Foo!(<span class="d_keyword">uint</span>);      <span class="d_comment">// instantiate Foo with T as uint, and U as int
</span>
<span class="d_keyword">template</span> Foo(T, U = T*) { ... }
Foo!(<span class="d_keyword">uint</span>);      <span class="d_comment">// instantiate Foo with T as uint, and U as uint*
</span></span></pre>
    </p>

<h2>Implicit Template Properties</h2>

    <p>If a template has exactly one member in it, and the name of that
        member is the same as the template name, that member is assumed
        to be referred to in a template instantiation:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> <b><i>Foo</i></b>(T) {
  T Foo; <span class="d_comment">// declare variable Foo of type T
</span>}

<span class="d_keyword">void</span> test() {
  Foo!(<span class="d_keyword">int</span>) = 6; <span class="d_comment">// instead of Foo!(int).Foo
</span>}
</span></pre>
    </p>

<h2>Template Constructors</h2>

<pre class="bnf"><span class="notranslate"><a name="ConstructorTemplate"><i>ConstructorTemplate</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> <a href="template.html#TemplateParameters"><i>TemplateParameters</i></a> <a href="declaration.html#Parameters"><i>Parameters</i></a> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> <a href="template.html#TemplateParameters"><i>TemplateParameters</i></a> <a href="declaration.html#Parameters"><i>Parameters</i></a> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

    <p>Templates can be used to form constructors for classes  and structs.
    </p>

<h2>Aggregate Templates</h2>

<pre class="bnf"><span class="notranslate"><a name="ClassTemplateDeclaration"><i>ClassTemplateDeclaration</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span> <i>Identifier</i> <a href="#TemplateParameters"><i>TemplateParameters</i></a> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <a href="class.html#BaseClassList"><i>BaseClassList</i></a><sub>opt</sub> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span> <i>Identifier</i> <a href="#TemplateParameters"><i>TemplateParameters</i></a> <a href="class.html#BaseClassList"><i>BaseClassList</i></a><sub>opt</sub> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>

<a name="InterfaceTemplateDeclaration"><i>InterfaceTemplateDeclaration</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">interface</span></span> <i>Identifier</i> <a href="#TemplateParameters"><i>TemplateParameters</i></a> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <a href="interface.html#BaseInterfaceList"><i>BaseInterfaceList</i></a><sub>opt</sub> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">interface</span></span> <i>Identifier</i> <a href="#TemplateParameters"><i>TemplateParameters</i></a> <a href="interface.html#BaseInterfaceList"><i>BaseInterfaceList</i></a> <a href="#Constraint"><i>Constraint</i></a> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>

<a name="StructTemplateDeclaration"><i>StructTemplateDeclaration</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">struct</span></span> <i>Identifier</i> <a href="#TemplateParameters"><i>TemplateParameters</i></a> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>

<a name="UnionTemplateDeclaration"><i>UnionTemplateDeclaration</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">union</span></span> <i>Identifier</i> <a href="#TemplateParameters"><i>TemplateParameters</i></a> <a href="#Constraint"><i>Constraint</i></a><sub>opt</sub> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>
</span></pre>

    <p>If a template declares exactly one member, and that member is a class
        with the same name as the template:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> <b><i>Bar</i></b>(T) {
  <span class="d_keyword">class</span> <b><i>Bar</i></b> {
    T member;
  }
}
</span></pre>

        then the semantic equivalent, called a <i>ClassTemplateDeclaration</i>
        can be written as:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Bar(T) {
  T member;
}
</span></pre>
    </p>

    <p>Analogously to class templates, struct, union and interfaces
        can be transformed into templates by supplying a template parameter list.
    </p>

<h2><a name="function-templates">Function Templates</a></h2>

    <p>If a template declares exactly one member, and that member is a function
        with the same name as the template, it is a function template declaration.
        Alternatively, a function template declaration is a function declaration
        with a <a href="#TemplateParameterList"><i>TemplateParameterList</i></a> immediately preceding the
        <a href="declaration.html#Parameters"><i>Parameters</i></a>.
    </p>

    <p>A function template to compute the square of type <i>T</i> is:

<pre class="d_code"><span class="notranslate">T <b><i>Square</i></b>(T)(T t) {
  <span class="d_keyword">return</span> t * t;
}
</span></pre>
    </p>

    <p>Function templates can be explicitly instantiated with a
        !(<i>TemplateArgumentList</i>):

<pre class="d_code"><span class="notranslate">writefln(<span class="d_string">"The square of %s is %s"</span>, 3, Square!(<span class="d_keyword">int</span>)(3));
</span></pre>
    </p>

    <p>or implicitly, where the <i>TemplateArgumentList</i> is deduced
        from the types of the function arguments:

<pre class="d_code"><span class="notranslate">writefln(<span class="d_string">"The square of %s is %s"</span>, 3, Square(3));  <span class="d_comment">// T is deduced to be int
</span></span></pre>
    </p>

    <p>If there are fewer arguments supplied in the <i>TemplateArgumentList</i>
        than parameters in the <i>TemplateParameterList</i>, the arguments fulfill
        parameters from left to right, and the rest of the parameters are then deduced
        from the function arguments.
    </p>

    <p>Function template type parameters that are to be implicitly
        deduced may not have specializations:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> <b><i>Foo</i></b>(T : T*)(T t) { ... }

<span class="d_keyword">int</span> x,y;
Foo!(<span class="d_keyword">int</span>*)(x);   <span class="d_comment">// ok, T is not deduced from function argument
</span>Foo(&amp;y);         <span class="d_comment">// error, T has specialization
</span></span></pre>
    </p>

    <p>Template arguments not implicitly deduced can have default values:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> <b><i>Foo</i></b>(T, U=T*)(T t) { U p; ... }

<span class="d_keyword">int</span> x;
Foo(x);    <span class="d_comment">// T is int, U is int*
</span></span></pre>
    </p>

    <p>The deduced type parameter for dynamic array and pointer arguments
        has an unqualified head:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo(T)(T arg) { <span class="d_keyword">pragma</span>(msg, T); }

<span class="d_keyword">int</span>[] marr;
<span class="d_keyword">const</span>(<span class="d_keyword">int</span>[]) carr;
<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>[]) iarr;
foo(marr);  <span class="d_comment">// T == int[]
</span>foo(carr);  <span class="d_comment">// T == const(int)[]
</span>foo(iarr);  <span class="d_comment">// T == immutable(int)[]
</span>
<span class="d_keyword">int</span>* mptr;
<span class="d_keyword">const</span>(<span class="d_keyword">int</span>*) cptr;
<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>*) iptr;
foo(mptr);  <span class="d_comment">// T == int*
</span>foo(cptr);  <span class="d_comment">// T == const(int)*
</span>foo(iptr);  <span class="d_comment">// T == immutable(int)*
</span></span></pre>
    </p>

    <p>Function templates can have their return types deduced based on the
        first <a href="statement.html#ReturnStatement"><i>ReturnStatement</i></a> in the function:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">auto</span> <b><i>Square</i></b>(T)(T t) {
  <span class="d_keyword">return</span> t * t;
}
</span></pre>
    </p>

    <p>If there is more than one return statement, then the
        types of the return statement expressions must match.
        If there are no return statements, then the return type of the
        function template is <span class="notranslate"><span class="d_inlinecode donthyphenate">void</span></span>.
    </p>

<h2><a name="variable-template">Variable Templates</a></h2>

    <p>Same as aggregates and functions, variable declarations with
        <a href="declaration.html#Initializer"><i>Initializer</i></a> can have optional template parameters:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">enum</span> string constant(TL...) = TL.stringof;
<span class="d_keyword">ubyte</span>[T.sizeof] storage(T) = 0;
<span class="d_keyword">auto</span> array(<span class="d_keyword">alias</span> a) = a;
</span></pre>
    </p>

    <p>These declarations are transformed into templates:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> constant(TL...) {
  <span class="d_keyword">enum</span> string constant = TL.stringof;
}
<span class="d_keyword">template</span> storage(T) {
  <span class="d_keyword">ubyte</span>[T.sizeof] storage = 0;
}
<span class="d_keyword">template</span> array(<span class="d_keyword">alias</span> a) {
  <span class="d_keyword">auto</span> array = a;
}
</span></pre>
    </p>

<h2><a name="alias-template">Alias Templates</a></h2>

    <p><a href="declaration.html#AliasDeclaration"><i>AliasDeclaration</i></a> can also have optional template
        parameters:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">alias</span> Sequence(TL...) = TL;
</span></pre>
    </p>

    <p>It is lowered to:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Sequence(TL...) {
  <span class="d_keyword">alias</span> Sequence = TL;
}
</span></pre>
    </p>

<h3><a name="auto-ref-parameters">Function Templates with Auto Ref Parameters</a></h3>

    <p>An auto ref function template parameter becomes a ref parameter
        if its corresponding argument is an lvalue, otherwise it becomes
        a value parameter:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo(T...)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> T x) {
  <span class="d_keyword">int</span> result;

  <span class="d_keyword">foreach</span> (i, v; x)
  {
    <span class="d_keyword">if</span> (v == 10)
      <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isRef, x[i]));
    <span class="d_keyword">else</span>
      <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isRef, x[i]));
    result += v;
  }
  <span class="d_keyword">return</span> result;
}

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">int</span> y = 10;
  <span class="d_keyword">int</span> r;
  r = foo(8);       <span class="d_comment">// returns 8
</span>  r = foo(y);       <span class="d_comment">// returns 10
</span>  r = foo(3, 4, y); <span class="d_comment">// returns 17
</span>  r = foo(4, 5, y); <span class="d_comment">// returns 19
</span>  r = foo(y, 6, y); <span class="d_comment">// returns 26
</span>}
</span></pre>
    </p>

    <p>Auto ref parameters can be combined with auto ref return
        attributes:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> min(T, U)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> T lhs, <span class="d_keyword">auto</span> <span class="d_keyword">ref</span> U rhs)
{
  <span class="d_keyword">return</span> lhs &gt; rhs ? rhs : lhs;
}

<span class="d_keyword">void</span> main()
{
  <span class="d_keyword">int</span> x = 7, y = 8;
  <span class="d_keyword">int</span> i;

  i = min(4, 3);     <span class="d_comment">// returns 3
</span>  i = min(x, y);     <span class="d_comment">// returns 7
</span>  min(x, y) = 10;    <span class="d_comment">// sets x to 10
</span>  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, min(3, y) = 10));
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, min(y, 3) = 10));
}
</span></pre>
    </p>

<h2><a name="nested-templates">Nested Templates</a></h2>

    <p>If a template is declared in aggregate or function local scope, the
        instantiated functions will implicitly capture the context of the
        enclosing scope.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> num;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) { num = n; }

    <span class="d_keyword">template</span> Foo()
    {
        <span class="d_comment">// 'foo' can access 'this' reference of class C object.
</span>        <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> n) { <span class="d_keyword">this</span>.num = n; }
    }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C(1);
    <span class="d_keyword">assert</span>(c.num == 1);

    c.Foo!().foo(5);
    <span class="d_keyword">assert</span>(c.num == 5);

    <span class="d_keyword">template</span> Bar()
    {
        <span class="d_comment">// 'bar' can access local variable of 'main' function.
</span>        <span class="d_keyword">void</span> bar(<span class="d_keyword">int</span> n) { c.num = n; }
    }
    Bar!().bar(10);
    <span class="d_keyword">assert</span>(c.num == 10);
}
</span></pre>
    </p>

    <p>Above, <span class="notranslate"><span class="d_inlinecode donthyphenate">Foo!().foo</span></span> will work just the same as a member function
        of class <span class="notranslate"><span class="d_inlinecode donthyphenate">C</span></span>, and <span class="notranslate"><span class="d_inlinecode donthyphenate">Bar!().bar</span></span> will work just the same as a nested
        function within function <span class="notranslate"><span class="d_inlinecode donthyphenate">main()</span></span>.</p>

    <p>If a template has a <a href="#aliasparameters">template alias parameter</a>,
        and is instantiated with a local symbol, the instantiated function will
        implicitly become nested in order to access runtime data of the given
        local symbol.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> sym)
{
    <span class="d_keyword">void</span> foo() { sym = 10; }
}

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> num;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) { num = n; }

    <span class="d_keyword">void</span> main()
    {
        <span class="d_keyword">assert</span>(<span class="d_keyword">this</span>.num == 1);

        <span class="d_keyword">alias</span> fooX = Foo!(C.num).foo;

        <span class="d_comment">// fooX will become member function implicitly, so &amp;fooX returns delegate object.
</span>        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(&amp;fooX) == <span class="d_keyword">delegate</span>));

        fooX(); <span class="d_comment">// called by using valid 'this' reference.
</span>        <span class="d_keyword">assert</span>(<span class="d_keyword">this</span>.num == 10);  <span class="d_comment">// OK
</span>    }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">new</span> C(1).main();

    <span class="d_keyword">int</span> num;
    <span class="d_keyword">alias</span> fooX = Foo!num.foo;

    <span class="d_comment">// fooX will become nested function implicitly, so &amp;fooX returns delegate object.
</span>    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(&amp;fooX) == <span class="d_keyword">delegate</span>));

    fooX();
    <span class="d_keyword">assert</span>(num == 10);  <span class="d_comment">// OK
</span>}
</span></pre>
    </p>

    <p>Not only functions, but also instantiated class and struct types can
        become nested via implicitly captured context.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> num;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) { num = n; }

    <span class="d_keyword">class</span> N(T)
    {
        <span class="d_comment">// instantiated class N!T can become nested in C
</span>        T foo() { <span class="d_keyword">return</span> num * 2; }
    }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C(10);
    <span class="d_keyword">auto</span> n = c.<span class="d_keyword">new</span> N!<span class="d_keyword">int</span>();
    <span class="d_keyword">assert</span>(n.foo() == 20);
}
</span></pre>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> num = 10;
    <span class="d_keyword">struct</span> S(T)
    {
        <span class="d_comment">// instantiated struct S!T can become nested in main()
</span>        T foo() { <span class="d_keyword">return</span> num * 2; }
    }
    S!<span class="d_keyword">int</span> s;
    <span class="d_keyword">assert</span>(s.foo() == 20);
}
</span></pre>
    </p>

    <p>A templated <span class="notranslate"><span class="d_inlinecode donthyphenate">struct</span></span> can become a nested <span class="notranslate"><span class="d_inlinecode donthyphenate">struct</span></span> if it
        is instantiated with a local symbol passed as an aliased argument:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> A(<span class="d_keyword">alias</span> F)
{
    <span class="d_keyword">int</span> fun(<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> F(i); }
}

A!F makeA(<span class="d_keyword">alias</span> F)() { <span class="d_keyword">return</span> A!F(); }

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> x = 40;
    <span class="d_keyword">int</span> fun(<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> x + i; }
    A!fun a = makeA!fun();
    <span class="d_keyword">assert</span>(a.fun(2) == 42);
}
</span></pre>
    </p>

    <h3>Limitation:</h3>

    <p>Currently nested templates can capture at most one context. As a typical
        example, non-static template member functions cannot take local symbol
        by using template alias parameter.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> num;
    <span class="d_keyword">void</span> foo(<span class="d_keyword">alias</span> sym)() { num = sym * 2; }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C();
    <span class="d_keyword">int</span> var = 10;
    c.foo!var();    <span class="d_comment">// NG, foo!var requires two contexts, 'this' and 'main()'
</span>}
</span></pre>
    </p>

    <p>But, if one context is indirectly accessible from other context, it is allowed.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> sum(<span class="d_keyword">alias</span> x, <span class="d_keyword">alias</span> y)() { <span class="d_keyword">return</span> x + y; }

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> a = 10;
    <span class="d_keyword">void</span> nested()
    {
        <span class="d_keyword">int</span> b = 20;
        <span class="d_keyword">assert</span>(sum!(a, b)() == 30);
    }
    nested();
}
</span></pre>

        Two local variables <span class="notranslate"><span class="d_inlinecode donthyphenate">a</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">b</span></span> are in different contexts, but
        outer context is indirectly accessible from innter context, so nested
        template instance <span class="notranslate"><span class="d_inlinecode donthyphenate">sum!(a, b)</span></span> will capture only
        inner context.
    </p>

<h2>Recursive Templates</h2>

    <p>Template features can be combined to produce some interesting
        effects, such as compile time evaluation of non-trivial functions.
        For example, a factorial template can be written:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n : 1) {
  <span class="d_keyword">enum</span> { factorial = 1 }
}

<span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n) {
  <span class="d_keyword">enum</span> { factorial = n* factorial!(n-1) }
}

<span class="d_keyword">void</span> test() {
  writefln(<span class="d_string">"%s"</span>, factorial!(4)); <span class="d_comment">// prints 24
</span>}
</span></pre>
    </p>

<h2>Template Constraints</h2>

<pre class="bnf"><span class="notranslate"><a name="Constraint"><i>Constraint</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">if</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
</span></pre>

    <p><i>Constraint</i>s are used to impose additional constraints
        on matching arguments to a template beyond what is possible
        in the <a href="#TemplateParameterList"><i>TemplateParameterList</i></a>.
        The <i>Expression</i> is computed at compile time
        and returns a result that is converted to a boolean value.
        If that value is true, then the template is matched,
        otherwise the template is not matched.
    </p>

    <p>For example, the following function template only
        matches with odd values of <span class="notranslate"><span class="d_inlinecode donthyphenate">N</span></span>:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> N)()
        <span class="d_keyword">if</span> (N &amp; 1)
{
  ...
}
...
foo!(3)();  <span class="d_comment">// ok, matches
</span>foo!(4)();  <span class="d_comment">// error, no match
</span></span></pre>
    </p>


<h2>Limitations</h2>

    <p>Templates cannot be used to add non-static members or
        virtual functions to classes.
        For example:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">template</span> TBar(T) {
    T xx;               <span class="d_comment">// becomes a static member of Foo
</span>    <span class="d_keyword">int</span> func(T) { ... } <span class="d_comment">// non-virtual
</span>
    <span class="d_keyword">static</span> T yy;                        <span class="d_comment">// Ok
</span>    <span class="d_keyword">static</span> <span class="d_keyword">int</span> func(T t, <span class="d_keyword">int</span> y) { ... } <span class="d_comment">// Ok
</span>  }
}
</span></pre>
    </p>

    <p>Templates cannot be declared inside functions.
    </p>

    <p>Templates cannot add functions to interfaces:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">interface</span> TestInterface { <span class="d_keyword">void</span> tpl(T)(); }   <span class="d_comment">// error
</span></span></pre>
    </p>

  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div><!--/content-->



<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/Template" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2017 by Digital Mars &reg;, All Rights Reserved |
Page generated by <a href="ddoc.html">Ddoc</a> on (no date time)
</div>
</body>
</html>

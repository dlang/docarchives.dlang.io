<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.random - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/random.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Phobos/StdRandom" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.random</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/random.d -->
Facilities for <a name="random"></a><span class="ddoc_psymbol">random</span> number generation.
<p></p>
The new-style generator objects hold their own state so they are
immune of threading issues. The generators feature a number of
well-known and well-documented methods of generating <a name="random"></a><span class="ddoc_psymbol">random</span>
numbers. An overall fast and reliable means to generate <a name="random"></a><span class="ddoc_psymbol">random</span> numbers
is the <span class="d_param">Mt19937</span> generator, which derives its name from
"<a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Mersenne Twister">Mersenne Twister</a> with a period of 2 to the power of
19937". In memory-constrained situations, <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=linear congruential">linear congruential</a>
generators such as <span class="d_inlinecode">MinstdRand0</span> and <span class="d_inlinecode">MinstdRand</span> might be
useful. The standard library provides an alias <span class="d_param">Random</span> for
whichever generator it considers the most fit for the target
environment.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Generate a uniformly-distributed integer in the range [0, 14]
</span><span class="d_keyword">auto</span> i = uniform(0, 15);
<span class="d_comment">// Generate a uniformly-distributed real in the range [0, 100$(RPAREN)
</span><span class="d_comment">// using a specific random generator
</span>Random gen;
<span class="d_keyword">auto</span> r = uniform(0.0L, 100.0L, gen);
</pre>
<p></p>

In addition to <a name="random"></a><span class="ddoc_psymbol">random</span> number generators, this module features
distributions, which skew a generator's output statistical
distribution in various ways. So far the uniform distribution for
integers and real numbers have been implemented.

<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/random.d">std/random.d</a>

<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br><a href="http://erdani.org">Andrei Alexandrescu</a>
           Masahiro Nakagawa (Xorshift randome generator)
           <a href="http://braingam.es">Joseph Rushton Wakeling</a> (Algorithm D for <a name="random"></a><span class="ddoc_psymbol">random</span> sampling)
<p></p>
<b>Credits:</b><br>
The entire <a name="random"></a><span class="ddoc_psymbol">random</span> number library architecture is derived from the
           excellent <a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">C++0X</a>
           <a name="random"></a><span class="ddoc_psymbol">random</span> number facility proposed by Jens Maurer and contributed to by
           researchers at the Fermi laboratory(excluding Xorshift).<p></p>

<dl><dt class="d_decl"><a name=".isUniformRNG"></a>template <a name="isUniformRNG"></a><span class="ddoc_psymbol">isUniformRNG</span>(Rng, ElementType)<br><a name=".isUniformRNG"></a>template <a name="isUniformRNG"></a><span class="ddoc_psymbol">isUniformRNG</span>(Rng)</dt>
<dd>Test if Rng is a random-number generator. The overload
 taking a ElementType also makes sure that the Rng generates
 values of that type.
<p></p>
A random-number generator has at least the following features:
 <ul>   <li>it's an InputRange</li>
   <li>it has a 'bool isUniformRandom' field readable in CTFE</li>
 </ul><p></p>

</dd>
<dt class="d_decl"><a name=".isSeedable"></a>template <a name="isSeedable"></a><span class="ddoc_psymbol">isSeedable</span>(Rng, SeedType)<br><a name=".isSeedable"></a>template <a name="isSeedable"></a><span class="ddoc_psymbol">isSeedable</span>(Rng)</dt>
<dd>Test if Rng is seedable. The overload
 taking a SeedType also makes sure that the Rng can be seeded with SeedType.
<p></p>
A seedable random-number generator has the following additional features:
 <ul>   <li>it has a 'seed(ElementType)' function</li>
 </ul><p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine"></a>struct <a name="LinearCongruentialEngine"></a><span class="ddoc_psymbol">LinearCongruentialEngine</span>(UIntType, UIntType a, UIntType c, UIntType m) if (isUnsigned!UIntType);
</dt>
<dd>Linear Congruential generator.<p></p>

<dl><dt class="d_decl"><a name=".LinearCongruentialEngine.isUniformRandom"></a>bool <a name="isUniformRandom"></a><span class="ddoc_psymbol">isUniformRandom</span>;
</dt>
<dd>Mark this as a Rng<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.hasFixedRange"></a>bool <a name="hasFixedRange"></a><span class="ddoc_psymbol">hasFixedRange</span>;
</dt>
<dd>Does this generator have a fixed range? (<span class="d_param"><b>true</b></span>).<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.min"></a>UIntType <a name="min"></a><span class="ddoc_psymbol">min</span>;
</dt>
<dd>Lowest generated value (<span class="d_inlinecode">1</span> if <span class="d_inlinecode">c == 0</span>, <span class="d_inlinecode">0</span> otherwise).<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.max"></a>UIntType <a name="max"></a><span class="ddoc_psymbol">max</span>;
</dt>
<dd>Highest generated value (<span class="d_inlinecode">modulus - 1</span>).<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.multiplier"></a>UIntType <a name="multiplier"></a><span class="ddoc_psymbol">multiplier</span>;
<br><a name=".LinearCongruentialEngine.increment"></a>UIntType <a name="increment"></a><span class="ddoc_psymbol">increment</span>;
<br><a name=".LinearCongruentialEngine.modulus"></a>UIntType <a name="modulus"></a><span class="ddoc_psymbol">modulus</span>;
</dt>
<dd>The parameters of this distribution. The random number is <span class="d_param">x
= (x * multipler + increment) % modulus</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.this"></a>pure @safe this(UIntType <i>x0</i>);
</dt>
<dd>Constructs a <span class="d_param">LinearCongruentialEngine</span> generator seeded with
<span class="d_inlinecode"><i>x0</i></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.seed"></a>pure @safe void <a name="seed"></a><span class="ddoc_psymbol">seed</span>(UIntType <i>x0</i> = 1);
</dt>
<dd>(Re)seeds the generator.<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.popFront"></a>pure nothrow @safe void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd>Advances the random sequence.<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.front"></a>const pure nothrow @property @safe UIntType <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Returns the current number in the random sequence.<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.save"></a>pure nothrow @property @safe typeof(this) <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>;
</dt>
<dd>Always <span class="d_inlinecode"><b>false</b></span> (random generators are infinite ranges).<p></p>

</dd>
<dt class="d_decl"><a name=".LinearCongruentialEngine.opEquals"></a>const pure nothrow @safe bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const LinearCongruentialEngine <i>rhs</i>);
</dt>
<dd>Compares against <span class="d_param"><i>rhs</i></span> for equality.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".MinstdRand0"></a>alias <a name="MinstdRand0"></a><span class="ddoc_psymbol">MinstdRand0</span> = LinearCongruentialEngine!(uint, 16807u, 0u, 2147483647u).LinearCongruentialEngine;
<br><a name=".MinstdRand"></a>alias <a name="MinstdRand"></a><span class="ddoc_psymbol">MinstdRand</span> = LinearCongruentialEngine!(uint, 48271u, 0u, 2147483647u).LinearCongruentialEngine;
</dt>
<dd>Define <span class="d_param">LinearCongruentialEngine</span> generators with well-chosen
parameters. <span class="d_inlinecode"><a name="MinstdRand0"></a><span class="ddoc_psymbol">MinstdRand0</span></span> implements Park and Miller's "minimal
standard" <a href="http://wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator">generator</a> that uses 16807 for the multiplier. <span class="d_inlinecode">MinstdRand</span>
implements a variant that has slightly better spectral behavior by
using the multiplier 48271. Both generators are rather simplistic.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// seed with a constant
</span><span class="d_keyword">auto</span> rnd0 = <span class="d_psymbol">MinstdRand0</span>(1);
<span class="d_keyword">auto</span> n = rnd0.front; <span class="d_comment">// same for each run
</span><span class="d_comment">// Seed with an unpredictable value
</span>rnd0.seed(unpredictableSeed);
n = rnd0.front; <span class="d_comment">// different across runs
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine"></a>struct <a name="MersenneTwisterEngine"></a><span class="ddoc_psymbol">MersenneTwisterEngine</span>(UIntType, size_t w, size_t n, size_t m, size_t r, UIntType a, size_t u, size_t s, UIntType b, size_t t, UIntType c, size_t l) if (isUnsigned!UIntType);
</dt>
<dd>The <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Mersenne Twister">Mersenne Twister</a> generator.<p></p>

<dl><dt class="d_decl"><a name=".MersenneTwisterEngine.isUniformRandom"></a>bool <a name="isUniformRandom"></a><span class="ddoc_psymbol">isUniformRandom</span>;
</dt>
<dd>Mark this as a Rng<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.wordSize"></a>size_t <a name="wordSize"></a><span class="ddoc_psymbol">wordSize</span>;
<br><a name=".MersenneTwisterEngine.stateSize"></a>size_t <a name="stateSize"></a><span class="ddoc_psymbol">stateSize</span>;
<br><a name=".MersenneTwisterEngine.shiftSize"></a>size_t <a name="shiftSize"></a><span class="ddoc_psymbol">shiftSize</span>;
<br><a name=".MersenneTwisterEngine.maskBits"></a>size_t <a name="maskBits"></a><span class="ddoc_psymbol">maskBits</span>;
<br><a name=".MersenneTwisterEngine.xorMask"></a>UIntType <a name="xorMask"></a><span class="ddoc_psymbol">xorMask</span>;
<br><a name=".MersenneTwisterEngine.temperingU"></a>UIntType <a name="temperingU"></a><span class="ddoc_psymbol">temperingU</span>;
<br><a name=".MersenneTwisterEngine.temperingS"></a>size_t <a name="temperingS"></a><span class="ddoc_psymbol">temperingS</span>;
<br><a name=".MersenneTwisterEngine.temperingB"></a>UIntType <a name="temperingB"></a><span class="ddoc_psymbol">temperingB</span>;
<br><a name=".MersenneTwisterEngine.temperingT"></a>size_t <a name="temperingT"></a><span class="ddoc_psymbol">temperingT</span>;
<br><a name=".MersenneTwisterEngine.temperingC"></a>UIntType <a name="temperingC"></a><span class="ddoc_psymbol">temperingC</span>;
<br><a name=".MersenneTwisterEngine.temperingL"></a>size_t <a name="temperingL"></a><span class="ddoc_psymbol">temperingL</span>;
</dt>
<dd>Parameters for the generator.<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.min"></a>UIntType <a name="min"></a><span class="ddoc_psymbol">min</span>;
</dt>
<dd>Smallest generated value (0).<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.max"></a>UIntType <a name="max"></a><span class="ddoc_psymbol">max</span>;
</dt>
<dd>Largest generated value.<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.defaultSeed"></a>UIntType <a name="defaultSeed"></a><span class="ddoc_psymbol">defaultSeed</span>;
</dt>
<dd>The default seed value.<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.this"></a>pure nothrow @safe this(UIntType <i>value</i>);
</dt>
<dd>Constructs a MersenneTwisterEngine object.<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.seed"></a>pure nothrow @safe void <a name="seed"></a><span class="ddoc_psymbol">seed</span>()(UIntType <i>value</i> = defaultSeed);
</dt>
<dd>Seeds a MersenneTwisterEngine object.
<p></p>
<b>Note:</b><br>
This <a name="seed"></a><span class="ddoc_psymbol">seed</span> function gives 2^32 starting points. To allow the RNG to be started in any one of its
   internal states use the <a name="seed"></a><span class="ddoc_psymbol">seed</span> overload taking an InputRange.<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.seed"></a>void <a name="seed"></a><span class="ddoc_psymbol">seed</span>(T)(T <i>range</i>) if (isInputRange!T &amp;&amp; is(Unqual!(ElementType!T) == UIntType));
</dt>
<dd>Seeds a MersenneTwisterEngine object using an InputRange.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">Exception</span> if the InputRange didn't provide enough elements to <a name="seed"></a><span class="ddoc_psymbol">seed</span> the generator.
   The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.

<p></p>
<b>Examples:</b><br><pre class="d_code">Mt19937 gen;
gen.<span class="d_psymbol">seed</span>(map!((a) =&gt; unpredictableSeed)(repeat(0)));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.popFront"></a>pure nothrow @safe void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd>Advances the generator.<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.front"></a>pure nothrow @property @safe UIntType <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Returns the current random value.<p></p>

</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.save"></a>pure nothrow @property @safe typeof(this) <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".MersenneTwisterEngine.empty"></a>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>;
</dt>
<dd>Always <span class="d_inlinecode"><b>false</b></span>.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Mt19937"></a>alias <a name="Mt19937"></a><span class="ddoc_psymbol">Mt19937</span> = MersenneTwisterEngine!(uint, 32LU, 624LU, 397LU, 31LU, 2567483615u, 11LU, 7LU, 2636928640u, 15LU, 4022730752u, 18LU).MersenneTwisterEngine;
</dt>
<dd>A <span class="d_inlinecode">MersenneTwisterEngine</span> instantiated with the parameters of the
original engine <a href="http://math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">MT19937</a>, generating uniformly-distributed 32-bit numbers with a
period of 2 to the power of 19937. Recommended for random number
generation unless memory is severely restricted, in which case a <span class="d_inlinecode">LinearCongruentialEngine</span> would be the generator of choice.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// seed with a constant
</span><span class="d_psymbol">Mt19937</span> gen;
<span class="d_keyword">auto</span> n = gen.front; <span class="d_comment">// same for each run
</span><span class="d_comment">// Seed with an unpredictable value
</span>gen.seed(unpredictableSeed);
n = gen.front; <span class="d_comment">// different across runs
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine"></a>struct <a name="XorshiftEngine"></a><span class="ddoc_psymbol">XorshiftEngine</span>(UIntType, UIntType bits, UIntType a, UIntType b, UIntType c) if (isUnsigned!UIntType);
</dt>
<dd>Xorshift generator using 32bit algorithm.
<p></p>
Implemented according to <a href="http://www.jstatsoft.org/v08/i14/paper">Xorshift RNGs</a>.
<p></p>

 <table cellspacing=0 cellpadding=5 class=book><caption></caption>  <tr><th>bits</th> <th>period</th></tr>
  <tr><td valign=top>32</td>   <td valign=top>2^32 - 1</td></tr>
  <tr><td valign=top>64</td>   <td valign=top>2^64 - 1</td></tr>
  <tr><td valign=top>96</td>   <td valign=top>2^96 - 1</td></tr>
  <tr><td valign=top>128</td>  <td valign=top>2^128 - 1</td></tr>
  <tr><td valign=top>160</td>  <td valign=top>2^160 - 1</td></tr>
  <tr><td valign=top>192</td>  <td valign=top>2^192 - 2^32</td></tr>
 </table><p></p>

<dl><dt class="d_decl"><a name=".XorshiftEngine.isUniformRandom"></a>bool <a name="isUniformRandom"></a><span class="ddoc_psymbol">isUniformRandom</span>;
</dt>
<dd>Mark this as a Rng<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.min"></a>UIntType <a name="min"></a><span class="ddoc_psymbol">min</span>;
</dt>
<dd>Smallest generated value.<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.max"></a>UIntType <a name="max"></a><span class="ddoc_psymbol">max</span>;
</dt>
<dd>Largest generated value.<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.this"></a>pure this(UIntType <i>x0</i>);
</dt>
<dd>Constructs a <span class="d_inlinecode">XorshiftEngine</span> generator seeded with <span class="d_param"><i>x0</i></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.seed"></a>pure nothrow @safe void <a name="seed"></a><span class="ddoc_psymbol">seed</span>(UIntType <i>x0</i>);
</dt>
<dd>(Re)seeds the generator.<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.front"></a>const pure nothrow @property @safe UIntType <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Returns the current number in the random sequence.<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.popFront"></a>pure nothrow @safe void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd>Advances the random sequence.<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.save"></a>pure nothrow @property @safe typeof(this) <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd>Captures a range state.<p></p>

</dd>
<dt class="d_decl"><a name=".XorshiftEngine.opEquals"></a>const pure nothrow @safe bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const XorshiftEngine <i>rhs</i>);
</dt>
<dd>Compares against <span class="d_param"><i>rhs</i></span> for equality.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Xorshift32"></a>alias <a name="Xorshift32"></a><span class="ddoc_psymbol">Xorshift32</span> = XorshiftEngine!(uint, 32u, 13u, 17u, 15u).XorshiftEngine;
<br><a name=".Xorshift64"></a>alias <a name="Xorshift64"></a><span class="ddoc_psymbol">Xorshift64</span> = XorshiftEngine!(uint, 64u, 10u, 13u, 10u).XorshiftEngine;
<br><a name=".Xorshift96"></a>alias <a name="Xorshift96"></a><span class="ddoc_psymbol">Xorshift96</span> = XorshiftEngine!(uint, 96u, 10u, 5u, 26u).XorshiftEngine;
<br><a name=".Xorshift128"></a>alias <a name="Xorshift128"></a><span class="ddoc_psymbol">Xorshift128</span> = XorshiftEngine!(uint, 128u, 11u, 8u, 19u).XorshiftEngine;
<br><a name=".Xorshift160"></a>alias <a name="Xorshift160"></a><span class="ddoc_psymbol">Xorshift160</span> = XorshiftEngine!(uint, 160u, 2u, 1u, 4u).XorshiftEngine;
<br><a name=".Xorshift192"></a>alias <a name="Xorshift192"></a><span class="ddoc_psymbol">Xorshift192</span> = XorshiftEngine!(uint, 192u, 2u, 1u, 4u).XorshiftEngine;
<br><a name=".Xorshift"></a>alias <a name="Xorshift"></a><span class="ddoc_psymbol">Xorshift</span> = XorshiftEngine!(uint, 128u, 11u, 8u, 19u).XorshiftEngine;
</dt>
<dd>Define <span class="d_inlinecode">XorshiftEngine</span> generators with well-chosen parameters. See each bits examples of "Xorshift RNGs".
 <span class="d_inlinecode">Xorshift</span> is a Xorshift128's alias because 128bits implementation is mostly used.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Seed with a constant
</span><span class="d_keyword">auto</span> rnd = Xorshift(1);
<span class="d_keyword">auto</span> num = rnd.front;  <span class="d_comment">// same for each run
</span>
<span class="d_comment">// Seed with an unpredictable value
</span>rnd.seed(unpredictableSeed());
num = rnd.front; <span class="d_comment">// different across runs
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".unpredictableSeed"></a>@property uint <a name="unpredictableSeed"></a><span class="ddoc_psymbol">unpredictableSeed</span>();
</dt>
<dd>A "good" seed for initializing random number engines. Initializing
with <span class="d_param"><a name="unpredictableSeed"></a><span class="ddoc_psymbol">unpredictableSeed</span></span> makes engines generate different
random number sequences every run.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> rnd = Random(<span class="d_psymbol">unpredictableSeed</span>);
<span class="d_keyword">auto</span> n = rnd.front;
...
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Random"></a>alias <a name="Random"></a><span class="ddoc_psymbol">Random</span> = MersenneTwisterEngine!(uint, 32LU, 624LU, 397LU, 31LU, 2567483615u, 11LU, 7LU, 2636928640u, 15LU, 4022730752u, 18LU).MersenneTwisterEngine;
</dt>
<dd>The "default", "favorite", "suggested" random number generator type on
the current platform. It is an alias for one of the previously-defined
generators. You may want to use it if (1) you need to generate some
nice random numbers, and (2) you don't care for the minutiae of the
method being used.<p></p>

</dd>
<dt class="d_decl"><a name=".rndGen"></a>@property ref Random <a name="rndGen"></a><span class="ddoc_psymbol">rndGen</span>();
</dt>
<dd>Global random number generator used by various functions in this
module whenever no generator is specified. It is allocated per-thread
and initialized to an unpredictable value for each thread.<p></p>

</dd>
<dt class="d_decl"><a name=".uniform"></a>auto <a name="uniform"></a><span class="ddoc_psymbol">uniform</span>(string boundaries = "[)", T1, T2)(T1 <i>a</i>, T2 <i>b</i>) if (!is(CommonType!(T1, T2) == void));
<br><a name=".uniform"></a>auto <a name="uniform"></a><span class="ddoc_psymbol">uniform</span>(string boundaries = "[)", T1, T2, UniformRandomNumberGenerator)(T1 <i>a</i>, T2 <i>b</i>, ref UniformRandomNumberGenerator <i>urng</i>) if (isFloatingPoint!(CommonType!(T1, T2)) &amp;&amp; isUniformRNG!UniformRandomNumberGenerator);
</dt>
<dd>Generates a number between <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>. The <span class="d_inlinecode">boundaries</span>
parameter controls the shape of the interval (open vs. closed on
either side). Valid values for <span class="d_inlinecode">boundaries</span> are <span class="d_inlinecode">"[]"</span>, <span class="d_inlinecode">"(]"</span>, <span class="d_inlinecode">"[)"</span>, and <span class="d_inlinecode">"()"</span>. The default interval
is closed to the left and open to the right. The version that does not
take <span class="d_inlinecode">urng</span> uses the default generator <span class="d_inlinecode">rndGen</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> gen = Random(unpredictableSeed);
<span class="d_comment">// Generate an integer in [0, 1023]
</span><span class="d_keyword">auto</span> a = <span class="d_psymbol">uniform</span>(0, 1024, gen);
<span class="d_comment">// Generate a float in [0, 1$(RPAREN)
</span><span class="d_keyword">auto</span> a = <span class="d_psymbol">uniform</span>(0.0f, 1.0f, gen);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".uniform"></a>auto <a name="uniform"></a><span class="ddoc_psymbol">uniform</span>(T, UniformRandomNumberGenerator)(ref UniformRandomNumberGenerator <i>urng</i>) if (!is(T == enum) &amp;&amp; (isIntegral!T || isSomeChar!T) &amp;&amp; isUniformRNG!UniformRandomNumberGenerator);
<br><a name=".uniform"></a>auto <a name="uniform"></a><span class="ddoc_psymbol">uniform</span>(T)() if (!is(T == enum) &amp;&amp; (isIntegral!T || isSomeChar!T));
</dt>
<dd>Generates a uniformly-distributed number in the range <span class="d_inlinecode">[T.min,
T.max]</span> for any integral type <span class="d_inlinecode">T</span>. If no random number generator is
passed, uses the default <span class="d_inlinecode">rndGen</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".uniform"></a>auto <a name="uniform"></a><span class="ddoc_psymbol">uniform</span>(E, UniformRandomNumberGenerator)(ref UniformRandomNumberGenerator <i>urng</i>) if (is(E == enum) &amp;&amp; isUniformRNG!UniformRandomNumberGenerator);
<br><a name=".uniform"></a>auto <a name="uniform"></a><span class="ddoc_psymbol">uniform</span>(E)() if (is(E == enum));
</dt>
<dd>Returns a uniformly selected member of enum <span class="d_inlinecode">E</span>. If no random number
generator is passed, uses the default <span class="d_inlinecode">rndGen</span>.<p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">enum</span> Fruit { apple, mango, pear }
<span class="d_keyword">auto</span> randFruit = <span class="d_psymbol">uniform</span>!Fruit();
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".uniform01"></a>T <a name="uniform01"></a><span class="ddoc_psymbol">uniform01</span>(T = double)() if (isFloatingPoint!T);
<br><a name=".uniform01"></a>T <a name="uniform01"></a><span class="ddoc_psymbol">uniform01</span>(T = double, UniformRNG)(ref UniformRNG <i>rng</i>) if (isFloatingPoint!T &amp;&amp; isUniformRNG!UniformRNG);
</dt>
<dd>Generates a uniformly-distributed floating point number of type
 <span class="d_inlinecode">T</span> in the range [0, 1).  If no random number generator is
 specified, the default RNG <span class="d_inlinecode">rndGen</span> will be used as the source
 of randomness.
<p></p>
<span class="d_inlinecode"><a name="uniform01"></a><span class="ddoc_psymbol">uniform01</span></span> offers a faster generation of random variates than
 the equivalent <span class="d_inlinecode">uniform!"[</span>"(0.0, 1.0)) and so may be preferred
 for some applications.<p></p>

</dd>
<dt class="d_decl"><a name=".uniformDistribution"></a>F[] <a name="uniformDistribution"></a><span class="ddoc_psymbol">uniformDistribution</span>(F = double)(size_t <i>n</i>, F[] <i>useThis</i> = null) if (isFloatingPoint!F);
</dt>
<dd>Generates a uniform probability distribution of size <span class="d_inlinecode">n</span>, i.e., an
array of size <span class="d_inlinecode">n</span> of positive numbers of type <span class="d_inlinecode">F</span> that sum to
<span class="d_inlinecode">1</span>. If <span class="d_inlinecode">useThis</span> is provided, it is used as storage.<p></p>

</dd>
<dt class="d_decl"><a name=".randomShuffle"></a>void <a name="randomShuffle"></a><span class="ddoc_psymbol">randomShuffle</span>(Range, RandomGen)(Range <i>r</i>, ref RandomGen <i>gen</i>) if (isRandomAccessRange!Range &amp;&amp; isUniformRNG!RandomGen);
<br><a name=".randomShuffle"></a>void <a name="randomShuffle"></a><span class="ddoc_psymbol">randomShuffle</span>(Range)(Range <i>r</i>) if (isRandomAccessRange!Range);
</dt>
<dd>Shuffles elements of <span class="d_inlinecode">r</span> using <span class="d_inlinecode">gen</span> as a shuffler. <span class="d_inlinecode">r</span> must be
a random-access range with length.  If no RNG is specified, <span class="d_inlinecode">rndGen</span>
will be used.<p></p>

</dd>
<dt class="d_decl"><a name=".partialShuffle"></a>void <a name="partialShuffle"></a><span class="ddoc_psymbol">partialShuffle</span>(Range, RandomGen)(Range <i>r</i>, in size_t <i>n</i>, ref RandomGen <i>gen</i>) if (isRandomAccessRange!Range &amp;&amp; isUniformRNG!RandomGen);
<br><a name=".partialShuffle"></a>void <a name="partialShuffle"></a><span class="ddoc_psymbol">partialShuffle</span>(Range)(Range <i>r</i>, in size_t <i>n</i>) if (isRandomAccessRange!Range);
</dt>
<dd>Partially shuffles the elements of <span class="d_inlinecode">r</span> such that upon returning <span class="d_inlinecode">r[0..n]</span>
is a random subset of <span class="d_inlinecode">r</span> and is randomly ordered.  <span class="d_inlinecode">r[n..r.length]</span>
will contain the elements not in <span class="d_inlinecode">r[0..n]</span>.  These will be in an undefined
order, but will not be random in the sense that their order after
<span class="d_inlinecode"><a name="partialShuffle"></a><span class="ddoc_psymbol">partialShuffle</span></span> returns will not be independent of their order before
<span class="d_inlinecode"><a name="partialShuffle"></a><span class="ddoc_psymbol">partialShuffle</span></span> was called.
<p></p>
<span class="d_inlinecode">r</span> must be a random-access range with length.  <span class="d_inlinecode">n</span> must be less than
or equal to <span class="d_inlinecode">r.length</span>.  If no RNG is specified, <span class="d_inlinecode">rndGen</span> will be used.<p></p>

</dd>
<dt class="d_decl"><a name=".dice"></a>size_t <a name="dice"></a><span class="ddoc_psymbol">dice</span>(Rng, Num)(ref Rng <i>rnd</i>, Num[] <i>proportions</i>...) if (isNumeric!Num &amp;&amp; isForwardRange!Rng);
<br><a name=".dice"></a>size_t <a name="dice"></a><span class="ddoc_psymbol">dice</span>(R, Range)(ref R <i>rnd</i>, Range <i>proportions</i>) if (isForwardRange!Range &amp;&amp; isNumeric!(ElementType!Range) &amp;&amp; !isArray!Range);
<br><a name=".dice"></a>size_t <a name="dice"></a><span class="ddoc_psymbol">dice</span>(Range)(Range <i>proportions</i>) if (isForwardRange!Range &amp;&amp; isNumeric!(ElementType!Range) &amp;&amp; !isArray!Range);
<br><a name=".dice"></a>size_t <a name="dice"></a><span class="ddoc_psymbol">dice</span>(Num)(Num[] <i>proportions</i>...) if (isNumeric!Num);
</dt>
<dd>Rolls a <a name="dice"></a><span class="ddoc_psymbol">dice</span> with relative probabilities stored in <span class="d_inlinecode">proportions</span>. Returns the index in <span class="d_inlinecode">proportions</span> that was chosen.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> x = <span class="d_psymbol">dice</span>(0.5, 0.5);   <span class="d_comment">// x is 0 or 1 in equal proportions
</span><span class="d_keyword">auto</span> y = <span class="d_psymbol">dice</span>(50, 50);     <span class="d_comment">// y is 0 or 1 in equal proportions
</span><span class="d_keyword">auto</span> z = <span class="d_psymbol">dice</span>(70, 20, 10); <span class="d_comment">// z is 0 70% of the time, 1 20% of the time,
</span>                           <span class="d_comment">// and 2 10% of the time
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".RandomCover"></a>struct <a name="RandomCover"></a><span class="ddoc_psymbol">RandomCover</span>(Range, UniformRNG = void) if (isRandomAccessRange!Range &amp;&amp; (isUniformRNG!UniformRNG || is(UniformRNG == void)));
<br><a name=".randomCover"></a>auto <a name="randomCover"></a><span class="ddoc_psymbol">randomCover</span>(Range, UniformRNG)(Range <i>r</i>, auto ref UniformRNG <i>rng</i>) if (isRandomAccessRange!Range &amp;&amp; isUniformRNG!UniformRNG);
<br><a name=".randomCover"></a>auto <a name="randomCover"></a><span class="ddoc_psymbol">randomCover</span>(Range)(Range <i>r</i>) if (isRandomAccessRange!Range);
</dt>
<dd>Covers a given range <span class="d_inlinecode">r</span> in a random manner, i.e. goes through each
element of <span class="d_inlinecode">r</span> once and only once, just in a random order. <span class="d_inlinecode">r</span>
must be a random-access range with length.
<p></p>
If no random number generator is passed to <span class="d_inlinecode">randomCover</span>, the
thread-global RNG rndGen will be used internally.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];
<span class="d_keyword">foreach</span> (e; randomCover(a))
{
    writeln(e);
}
</pre>
<p></p>

<b>WARNING:</b> If an alternative RNG is desired, it is essential for this
to be a <i>new</i> RNG seeded in an unpredictable manner. Passing it a RNG
used elsewhere in the program will result in unintended correlations,
due to the current implementation of RNGs as value types.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];
<span class="d_keyword">foreach</span> (e; randomCover(a, Random(unpredictableSeed)))  <span class="d_comment">// correct!
</span>{
    writeln(e);
}

<span class="d_keyword">foreach</span> (e; randomCover(a, rndGen))  <span class="d_comment">// DANGEROUS!! rndGen gets copied by value
</span>{
    writeln(e);
}

<span class="d_keyword">foreach</span> (e; randomCover(a, rndGen))  <span class="d_comment">// ... so this second random cover
</span>{                                    <span class="d_comment">// will output the same sequence as
</span>    writeln(e);                      <span class="d_comment">// the previous one.
</span>}
</pre>
<p></p>

These issues will be resolved in a second-generation std.random that
re-implements random number generators as reference types.<p></p>

</dd>
<dt class="d_decl"><a name=".RandomSample"></a>struct <a name="RandomSample"></a><span class="ddoc_psymbol">RandomSample</span>(Range, UniformRNG = void) if (isInputRange!Range &amp;&amp; (isUniformRNG!UniformRNG || is(UniformRNG == void)));
<br><a name=".randomSample"></a>auto <a name="randomSample"></a><span class="ddoc_psymbol">randomSample</span>(Range)(Range <i>r</i>, size_t <i>n</i>, size_t <i>total</i>) if (isInputRange!Range);
<br><a name=".randomSample"></a>auto <a name="randomSample"></a><span class="ddoc_psymbol">randomSample</span>(Range)(Range <i>r</i>, size_t <i>n</i>) if (isInputRange!Range &amp;&amp; hasLength!Range);
<br><a name=".randomSample"></a>auto <a name="randomSample"></a><span class="ddoc_psymbol">randomSample</span>(Range, UniformRNG)(Range <i>r</i>, size_t <i>n</i>, size_t <i>total</i>, auto ref UniformRNG <i>rng</i>) if (isInputRange!Range &amp;&amp; isUniformRNG!UniformRNG);
<br><a name=".randomSample"></a>auto <a name="randomSample"></a><span class="ddoc_psymbol">randomSample</span>(Range, UniformRNG)(Range <i>r</i>, size_t <i>n</i>, auto ref UniformRNG <i>rng</i>) if (isInputRange!Range &amp;&amp; hasLength!Range &amp;&amp; isUniformRNG!UniformRNG);
</dt>
<dd>Selects a random subsample out of <span class="d_inlinecode">r</span>, containing exactly <span class="d_inlinecode">n</span>
elements. The order of elements is the same as in the original
range. The total length of <span class="d_inlinecode">r</span> must be known. If <span class="d_inlinecode">total</span> is
passed in, the total number of sample is considered to be <span class="d_inlinecode">total</span>. Otherwise, <span class="d_inlinecode"><a name="RandomSample"></a><span class="ddoc_psymbol">RandomSample</span></span> uses <span class="d_inlinecode">r.length</span>.
<p></p>
<span class="d_inlinecode"><a name="RandomSample"></a><span class="ddoc_psymbol">RandomSample</span></span> implements Jeffrey Scott Vitter's Algorithm D
(see Vitter <a href="http://dx.doi.org/10.1145/358105.893">1984</a>, <a href="http://dx.doi.org/10.1145/23002.23003">1987</a>), which selects a sample
of size <span class="d_inlinecode">n</span> in O(n) steps and requiring O(n) random variates,
regardless of the size of the data being sampled.  The exception
to this is if traversing k elements on the input range is itself
an O(k) operation (e.g. when sampling lines from an input file),
in which case the sampling calculation will inevitably be of
O(total).
<p></p>

<a name="RandomSample"></a><span class="ddoc_psymbol">RandomSample</span> will throw an exception if <span class="d_inlinecode">total</span> is verifiably
less than the total number of elements available in the input,
or if <span class="d_inlinecode">n &gt; total</span>.
<p></p>

If no random number generator is passed to <span class="d_inlinecode">randomSample</span>, the
thread-global RNG rndGen will be used internally.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
<span class="d_comment">// Print 5 random elements picked off from a
</span><span class="d_keyword">foreach</span> (e; randomSample(a, 5))
{
    writeln(e);
}
</pre>
<p></p>

<b>WARNING:</b> If an alternative RNG is desired, it is essential for this
to be a <i>new</i> RNG seeded in an unpredictable manner. Passing it a RNG
used elsewhere in the program will result in unintended correlations,
due to the current implementation of RNGs as value types.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
<span class="d_keyword">foreach</span> (e; randomSample(a, 5, Random(unpredictableSeed)))  <span class="d_comment">// correct!
</span>{
    writeln(e);
}

<span class="d_keyword">foreach</span> (e; randomSample(a, 5, rndGen))  <span class="d_comment">// DANGEROUS!! rndGen gets
</span>{                                        <span class="d_comment">// copied by value
</span>    writeln(e);
}

<span class="d_keyword">foreach</span> (e; randomSample(a, 5, rndGen))  <span class="d_comment">// ... so this second random
</span>{                                        <span class="d_comment">// sample will select the same
</span>    writeln(e);                          <span class="d_comment">// values as the previous one.
</span>}
</pre>
<p></p>

These issues will be resolved in a second-generation std.random that
re-implements random number generators as reference types.<p></p>

<dl><dt class="d_decl"><a name=".RandomSample.empty"></a>const @property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".RandomSample.popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".RandomSample.save"></a>@property typeof(this) <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br><a name=".RandomSample.length"></a>@property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>Range primitives.<p></p>

</dd>
<dt class="d_decl"><a name=".RandomSample.index"></a>@property size_t <a name="index"></a><span class="ddoc_psymbol">index</span>();
</dt>
<dd>Returns the <a name="index"></a><span class="ddoc_psymbol">index</span> of the visited record.<p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Andrei Alexandrescu 2008 - 2009, Joseph Rushton Wakeling 2012.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>core.sync.rwmutex - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos </a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/druntime/edit/master/src/core/sync/rwmutex.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>core.sync.rwmutex</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from src/core/sync/rwmutex.d -->
The read/write mutex module provides a primitive for maintaining shared read
 access and mutually exclusive write access.
<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<p></p>
<b>Authors:</b><br>Sean Kelly
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/druntime/blob/master/src/core/sync/rwmutex.d">core/sync/rwmutex.d</a><p></p>

<dl><dt class="d_decl"><a name=".ReadWriteMutex"></a>class <a name="ReadWriteMutex"></a><span class="ddoc_psymbol">ReadWriteMutex</span>;
</dt>
<dd>This class represents a mutex that allows any number of readers to enter,
 but when a writer enters, all other readers and writers are blocked.
<p></p>
Please note that this mutex is not recursive and is intended to guard access
 to data only.  Also, no deadlock checking is in place because doing so would
 require dynamic memory allocation, which would reduce performance by an
 unacceptable amount.  As a result, any attempt to recursively acquire this
 mutex may well deadlock the caller, particularly if a write lock is acquired
 while holding a read lock, or vice-versa.  In practice, this should not be
 an issue however, because it is uncommon to call deeply into unknown code
 while holding a lock that simply protects data.<p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">import</span> core.atomic, core.thread, core.sync.semaphore;

<span class="d_keyword">static</span> <span class="d_keyword">void</span> runTest(<span class="d_psymbol">ReadWriteMutex</span>.Policy policy)
{
    <span class="d_keyword">scope</span> mutex = <span class="d_keyword">new</span> <span class="d_psymbol">ReadWriteMutex</span>(policy);
    <span class="d_keyword">scope</span> rdSemA = <span class="d_keyword">new</span> Semaphore, rdSemB = <span class="d_keyword">new</span> Semaphore,
          wrSemA = <span class="d_keyword">new</span> Semaphore, wrSemB = <span class="d_keyword">new</span> Semaphore;
    <span class="d_keyword">shared</span> size_t numReaders, numWriters;

    <span class="d_keyword">void</span> readerFn()
    {
        <span class="d_keyword">synchronized</span> (mutex.reader)
        {
            atomicOp!<span class="d_string">"+="</span>(numReaders, 1);
            rdSemA.notify();
            rdSemB.wait();
            atomicOp!<span class="d_string">"-="</span>(numReaders, 1);
        }
    }

    <span class="d_keyword">void</span> writerFn()
    {
        <span class="d_keyword">synchronized</span> (mutex.writer)
        {
            atomicOp!<span class="d_string">"+="</span>(numWriters, 1);
            wrSemA.notify();
            wrSemB.wait();
            atomicOp!<span class="d_string">"-="</span>(numWriters, 1);
        }
    }

    <span class="d_keyword">void</span> waitQueued(size_t queuedReaders, size_t queuedWriters)
    {
        <span class="d_keyword">for</span> (;;)
        {
            <span class="d_keyword">synchronized</span> (mutex.m_commonMutex)
            {
                <span class="d_keyword">if</span> (mutex.m_numQueuedReaders == queuedReaders &amp;&amp;
                    mutex.m_numQueuedWriters == queuedWriters)
                    <span class="d_keyword">break</span>;
            }
            Thread.yield();
        }
    }

    <span class="d_keyword">scope</span> group = <span class="d_keyword">new</span> ThreadGroup;

    <span class="d_comment">// 2 simultaneous readers
</span>    group.create(&amp;readerFn); group.create(&amp;readerFn);
    rdSemA.wait(); rdSemA.wait();
    <span class="d_keyword">assert</span>(numReaders == 2);
    rdSemB.notify(); rdSemB.notify();
    group.joinAll();
    <span class="d_keyword">assert</span>(numReaders == 0);
    <span class="d_keyword">foreach</span> (t; group) group.remove(t);

    <span class="d_comment">// 1 writer at a time
</span>    group.create(&amp;writerFn); group.create(&amp;writerFn);
    wrSemA.wait();
    <span class="d_keyword">assert</span>(!wrSemA.tryWait());
    <span class="d_keyword">assert</span>(numWriters == 1);
    wrSemB.notify();
    wrSemA.wait();
    <span class="d_keyword">assert</span>(numWriters == 1);
    wrSemB.notify();
    group.joinAll();
    <span class="d_keyword">assert</span>(numWriters == 0);
    <span class="d_keyword">foreach</span> (t; group) group.remove(t);

    <span class="d_comment">// reader and writer are mutually exclusive
</span>    group.create(&amp;readerFn);
    rdSemA.wait();
    group.create(&amp;writerFn);
    waitQueued(0, 1);
    <span class="d_keyword">assert</span>(!wrSemA.tryWait());
    <span class="d_keyword">assert</span>(numReaders == 1 &amp;&amp; numWriters == 0);
    rdSemB.notify();
    wrSemA.wait();
    <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 1);
    wrSemB.notify();
    group.joinAll();
    <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 0);
    <span class="d_keyword">foreach</span> (t; group) group.remove(t);

    <span class="d_comment">// writer and reader are mutually exclusive
</span>    group.create(&amp;writerFn);
    wrSemA.wait();
    group.create(&amp;readerFn);
    waitQueued(1, 0);
    <span class="d_keyword">assert</span>(!rdSemA.tryWait());
    <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 1);
    wrSemB.notify();
    rdSemA.wait();
    <span class="d_keyword">assert</span>(numReaders == 1 &amp;&amp; numWriters == 0);
    rdSemB.notify();
    group.joinAll();
    <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 0);
    <span class="d_keyword">foreach</span> (t; group) group.remove(t);

    <span class="d_comment">// policy determines whether queued reader or writers progress first
</span>    group.create(&amp;writerFn);
    wrSemA.wait();
    group.create(&amp;readerFn);
    group.create(&amp;writerFn);
    waitQueued(1, 1);
    <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 1);
    wrSemB.notify();

    <span class="d_keyword">if</span> (policy == <span class="d_psymbol">ReadWriteMutex</span>.Policy.PREFER_READERS)
    {
        rdSemA.wait();
        <span class="d_keyword">assert</span>(numReaders == 1 &amp;&amp; numWriters == 0);
        rdSemB.notify();
        wrSemA.wait();
        <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 1);
        wrSemB.notify();
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (policy == <span class="d_psymbol">ReadWriteMutex</span>.Policy.PREFER_WRITERS)
    {
        wrSemA.wait();
        <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 1);
        wrSemB.notify();
        rdSemA.wait();
        <span class="d_keyword">assert</span>(numReaders == 1 &amp;&amp; numWriters == 0);
        rdSemB.notify();
    }
    group.joinAll();
    <span class="d_keyword">assert</span>(numReaders == 0 &amp;&amp; numWriters == 0);
    <span class="d_keyword">foreach</span> (t; group) group.remove(t);
}
runTest(<span class="d_psymbol">ReadWriteMutex</span>.Policy.PREFER_READERS);
runTest(<span class="d_psymbol">ReadWriteMutex</span>.Policy.PREFER_WRITERS);
</pre>
<p></p>
<dl><dt class="d_decl"><a name=".ReadWriteMutex.Policy"></a>enum <a name="Policy"></a><span class="ddoc_psymbol">Policy</span>: int;
</dt>
<dd>Defines the policy used by this mutex.  Currently, two policies are
 defined.
<p></p>
The first will queue writers until no readers hold the mutex, then
 pass the writers through one at a time.  If a reader acquires the mutex
 while there are still writers queued, the reader will take precedence.
<p></p>

 The second will queue readers if there are any writers queued.  Writers
 are passed through one at a time, and once there are no writers present,
 all queued readers will be alerted.
<p></p>

 Future policies may offer a more even balance between reader and writer
 precedence.<p></p>

<dl><dt class="d_decl"><a name=".ReadWriteMutex.Policy.PREFER_READERS"></a><a name="PREFER_READERS"></a><span class="ddoc_psymbol">PREFER_READERS</span></dt>
<dd>Readers get preference.  This may starve writers.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Policy.PREFER_WRITERS"></a><a name="PREFER_WRITERS"></a><span class="ddoc_psymbol">PREFER_WRITERS</span></dt>
<dd>Writers get preference.  This may starve readers.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.this"></a>this(Policy <i>policy</i> = Policy.PREFER_WRITERS);
</dt>
<dd>Initializes a read/write mutex object with the supplied <i>policy</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Policy <i>policy</i></td>
<td valign=top>The <i>policy</i> to use.</td></tr>
</table><p></p>
<b>Throws:</b><br>SyncException on error.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.policy"></a>@property Policy <a name="policy"></a><span class="ddoc_psymbol">policy</span>();
</dt>
<dd>Gets the <a name="policy"></a><span class="ddoc_psymbol">policy</span> used by this mutex.
<p></p>
<b>Returns:</b><br>The <a name="policy"></a><span class="ddoc_psymbol">policy</span> used by this mutex.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.reader"></a>@property Reader <a name="reader"></a><span class="ddoc_psymbol">reader</span>();
</dt>
<dd>Gets an object representing the <a name="reader"></a><span class="ddoc_psymbol">reader</span> lock for the associated mutex.
<p></p>
<b>Returns:</b><br>A <a name="reader"></a><span class="ddoc_psymbol">reader</span> sub-mutex.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.writer"></a>@property Writer <a name="writer"></a><span class="ddoc_psymbol">writer</span>();
</dt>
<dd>Gets an object representing the <a name="writer"></a><span class="ddoc_psymbol">writer</span> lock for the associated mutex.
<p></p>
<b>Returns:</b><br>A <a name="writer"></a><span class="ddoc_psymbol">writer</span> sub-mutex.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Reader"></a>class <a name="Reader"></a><span class="ddoc_psymbol">Reader</span>: <u>object.Object.Monitor</u>;
</dt>
<dd>This class can be considered a mutex in its own right, and is used to
 negotiate a read lock for the enclosing mutex.<p></p>

<dl><dt class="d_decl"><a name=".ReadWriteMutex.Reader.this"></a>this();
</dt>
<dd>Initializes a read/write mutex reader proxy object.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Reader.lock"></a>@trusted void <a name="lock"></a><span class="ddoc_psymbol">lock</span>();
</dt>
<dd>Acquires a read <a name="lock"></a><span class="ddoc_psymbol">lock</span> on the enclosing mutex.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Reader.unlock"></a>@trusted void <a name="unlock"></a><span class="ddoc_psymbol">unlock</span>();
</dt>
<dd>Releases a read lock on the enclosing mutex.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Reader.tryLock"></a>bool <a name="tryLock"></a><span class="ddoc_psymbol">tryLock</span>();
</dt>
<dd>Attempts to acquire a read lock on the enclosing mutex.  If one can
 be obtained without blocking, the lock is acquired and <b>true</b> is
 returned.  If not, the lock is not acquired and <b>false</b> is returned.
<p></p>
<b>Returns:</b><br><b>true</b> if the lock was acquired and <b>false</b> if not.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Writer"></a>class <a name="Writer"></a><span class="ddoc_psymbol">Writer</span>: <u>object.Object.Monitor</u>;
</dt>
<dd>This class can be considered a mutex in its own right, and is used to
 negotiate a write lock for the enclosing mutex.<p></p>

<dl><dt class="d_decl"><a name=".ReadWriteMutex.Writer.this"></a>this();
</dt>
<dd>Initializes a read/write mutex writer proxy object.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Writer.lock"></a>@trusted void <a name="lock"></a><span class="ddoc_psymbol">lock</span>();
</dt>
<dd>Acquires a write <a name="lock"></a><span class="ddoc_psymbol">lock</span> on the enclosing mutex.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Writer.unlock"></a>@trusted void <a name="unlock"></a><span class="ddoc_psymbol">unlock</span>();
</dt>
<dd>Releases a write lock on the enclosing mutex.<p></p>

</dd>
<dt class="d_decl"><a name=".ReadWriteMutex.Writer.tryLock"></a>bool <a name="tryLock"></a><span class="ddoc_psymbol">tryLock</span>();
</dt>
<dd>Attempts to acquire a write lock on the enclosing mutex.  If one can
 be obtained without blocking, the lock is acquired and <b>true</b> is
 returned.  If not, the lock is not acquired and <b>false</b> is returned.
<p></p>
<b>Returns:</b><br><b>true</b> if the lock was acquired and <b>false</b> if not.<p></p>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Sean Kelly 2005 - 2009.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

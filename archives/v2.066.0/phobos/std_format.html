<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.format - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/format.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Phobos/StdFormat" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.format</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/format.d -->
This module implements the formatting functionality for strings and
   I/O. It's comparable to C99's <span class="d_inlinecode">vsprintf()</span> and uses a similar
   <a name="format"></a><span class="ddoc_psymbol">format</span> encoding scheme.
<p></p>
For an introductory look at <b>std.<a name="format"></a><span class="ddoc_psymbol">format</span></b>'s capabilities and how to use
   this module see the dedicated
   <a href="http://wiki.dlang.org/Defining_custom_print_format_specifiers">DWiki article</a>.

<p></p>
<b>License:</b><br><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

<p></p>
<b>Authors:</b><br><a href="http://walterbright.com">Walter Bright</a>, <a href="http://erdani.com">   Andrei Alexandrescu</a>, and Kenji Hara

<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/format.d">std/format.d</a><p></p>

<dl><dt class="d_decl"><a name=".FormatException"></a>class <a name="FormatException"></a><span class="ddoc_psymbol">FormatException</span>: <u>object.Exception</u>;
</dt>
<dd>Signals a mismatch between a format and its corresponding argument.<p></p>

</dd>
<dt class="d_decl"><a name=".formattedWrite"></a>uint <a name="formattedWrite"></a><span class="ddoc_psymbol">formattedWrite</span>(Writer, Char, A...)(Writer <i>w</i>, in Char[] <i>fmt</i>, A <i>args</i>);
</dt>
<dd>Interprets variadic argument list <span class="d_inlinecode">args</span>, formats them according
   to <span class="d_inlinecode">fmt</span>, and sends the resulting characters to <span class="d_inlinecode">w</span>. The
   encoding of the output is the same as <span class="d_inlinecode">Char</span>. The type <span class="d_inlinecode">Writer</span>
   must satisfy <a href="std_range.html#isOutputRange!(Writer, Char)"><span class="d_inlinecode">std.range.isOutputRange!(Writer, Char)</span></a>.
<p></p>
The variadic arguments are normally consumed in order. POSIX-style
   <a href="http://opengroup.org/onlinepubs/009695399/functions/printf.html">   positional parameter syntax</a> is also supported. Each argument is
   formatted into a sequence of chars according to the format
   specification, and the characters are passed to <span class="d_inlinecode">w</span>. As many
   arguments as specified in the format string are consumed and
   formatted. If there are fewer arguments than format specifiers, a
   <span class="d_inlinecode">FormatException</span> is thrown. If there are more remaining arguments
   than needed by the format specification, they are ignored but only
   if at least one argument was formatted.
<p></p>

   The format string supports the formatting of array and nested array elements
   via the grouping format specifiers <b>%&#40;</b> and <b>%&#41;</b>. Each
   matching pair of <b>%&#40;</b> and <b>%&#41;</b> corresponds with a single array
   argument. The enclosed sub-format string is applied to individual array
   elements.  The trailing portion of the sub-format string following the
   conversion specifier for the array element is interpreted as the array
   delimiter, and is therefore omitted following the last array element. The
   <b>%|</b> specifier may be used to explicitly indicate the start of the
   delimiter, so that the preceding portion of the string will be included
   following the last array element.  (See below for explicit examples.)

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Writer w</td>
<td valign=top>Output is sent to this writer. Typical output writers include
   <a href="std_array.html#Appender!string"><span class="d_inlinecode">std.array.Appender!string</span></a> and <a href="std_stdio.html#LockingTextWriter"><span class="d_inlinecode">std.stdio.LockingTextWriter</span></a>.</td></tr>
<tr><td valign=top>Char[] fmt</td>
<td valign=top>Format string.</td></tr>
<tr><td valign=top>A args</td>
<td valign=top>Variadic argument list.</td></tr>
</table><p></p>
<b>Returns:</b><br>Formatted number of arguments.

<p></p>
<b>Throws:</b><br>Mismatched arguments and formats result in a <span class="d_inlinecode">   FormatException</span> being thrown.

<p></p>
<b>Format String:</b><br>
<a name="format-string"><i>Format strings</i></a>
   consist of characters interspersed with <i>format
   specifications</i>. Characters are simply copied to the output (such
   as putc) after any necessary conversion to the corresponding UTF-8
   sequence.
<p></p>

   The format string has the following grammar:
<p></p>

<pre><i>FormatString</i>:
    <i>FormatStringItem</i>*
<i>FormatStringItem</i>:
    <b>'%%'</b>
    <b>'%'</b> <i>Position</i> <i>Flags</i> <i>Width</i> <i>Precision</i> <i>FormatChar</i>
    <b>'%('</b> <i>FormatString</i> <b>'%)'</b>
    <i>OtherCharacterExceptPercent</i>
<i>Position</i>:
    <i>empty</i>
    <i>Integer</i> <b>'$'</b>
<i>Flags</i>:
    <i>empty</i>
    <b>'-'</b> <i>Flags</i>
    <b>'+'</b> <i>Flags</i>
    <b>'#'</b> <i>Flags</i>
    <b>'0'</b> <i>Flags</i>
    <b>' '</b> <i>Flags</i>
<i>Width</i>:
    <i>empty</i>
    <i>Integer</i>
    <b>'*'</b>
<i>Precision</i>:
    <i>empty</i>
    <b>'.'</b>
    <b>'.'</b> <i>Integer</i>
    <b>'.*'</b>
<i>Integer</i>:
    <i>Digit</i>
    <i>Digit</i> <i>Integer</i>
<i>Digit</i>:
    <b>'0'</b>|<b>'1'</b>|<b>'2'</b>|<b>'3'</b>|<b>'4'</b>|<b>'5'</b>|<b>'6'</b>|<b>'7'</b>|<b>'8'</b>|<b>'9'</b>
<i>FormatChar</i>:
    <b>'s'</b>|<b>'c'</b>|<b>'b'</b>|<b>'d'</b>|<b>'o'</b>|<b>'x'</b>|<b>'X'</b>|<b>'e'</b>|<b>'E'</b>|<b>'f'</b>|<b>'F'</b>|<b>'g'</b>|<b>'G'</b>|<b>'a'</b>|<b>'A'</b>
</pre>
<p></p>

    <table cellspacing=0 cellpadding=5 class=book><caption>Flags affect formatting depending on the specifier as
    follows.</caption><tr><th>Flag</th> <th>Types&nbsp;affected</th> <th>Semantics</th></tr>
<p></p>

    <tr><td valign=top><b>'-'</b></td> <td valign=top>numeric</td> <td valign=top>Left justify the result in
        the field.  It overrides any <b>0</b> flag.</td></tr>
<p></p>

    <tr><td valign=top><b>'+'</b></td> <td valign=top>numeric</td> <td valign=top>Prefix positive numbers in
    a signed conversion with a <b>+</b>.  It overrides any <i>space</i>
    flag.</td></tr>
<p></p>

    <tr><td valign=top><b>'#'</b></td> <td valign=top>integral (<b>'o'</b>)</td> <td valign=top>Add to
    precision as necessary so that the first digit of the octal
    formatting is a '0', even if both the argument and the <i>    Precision</i> are zero.</td></tr>
<p></p>

    <tr><td valign=top><b>'#'</b></td> <td valign=top>integral (<b>'x'</b>, <b>'X'</b>)</td> <td valign=top>If
       non-zero, prefix result with <b>0x</b> (<b>0X</b>).</td></tr>
<p></p>

    <tr><td valign=top><b>'#'</b></td> <td valign=top>floating</td> <td valign=top>Always insert the decimal
       point and print trailing zeros.</td></tr>
<p></p>

    <tr><td valign=top><b>'0'</b></td> <td valign=top>numeric</td> <td valign=top>Use leading
    zeros to pad rather than spaces (except for the floating point
    values <span class="d_inlinecode">nan</span> and <span class="d_inlinecode">infinity</span>).  Ignore if there's a <i>    Precision</i>.</td></tr>
<p></p>

    <tr><td valign=top><b>' '</b></td> <td valign=top>numeric</td> <td valign=top>Prefix positive
    numbers in a signed conversion with a space.</td></tr></table>
<p></p>

    <dt><i>Width</i>
    <dd>
    Specifies the minimum field width.
    If the width is a <b>*</b>, an additional argument of type <b>int</b>,
    preceding the actual argument, is taken as the width.
    If the width is negative, it is as if the <b>-</b> was given
    as a <i>Flags</i> character.
<p></p>

    <dt><i>Precision</i>
    <dd> Gives the precision for numeric conversions.
    If the precision is a <b>*</b>, an additional argument of type <b>int</b>,
    preceding the actual argument, is taken as the precision.
    If it is negative, it is as if there was no <i>Precision</i> specifier.
<p></p>

    <dt><i>FormatChar</i>
    <dd>
    <dl>
        <dt><b>'s'</b>
        <dd>The corresponding argument is formatted in a manner consistent
        with its type:
        <dl>
            <dt><b>bool</b>
            <dd>The result is <tt>'<b>true</b>'</tt> or <tt>'<b>false</b>'</tt>.
            <dt>integral types
            <dd>The <b>%d</b> format is used.
            <dt>floating point types
            <dd>The <b>%g</b> format is used.
            <dt>string types
            <dd>The result is the string converted to UTF-8.
            A <i>Precision</i> specifies the maximum number of characters
            to use in the result.
            <dt>structs
            <dd>If the struct defines a <b>toString()</b> method the result is the
            string returned from this function. Otherwise the result is
            StructName(field<sub>0</sub>, field<sub>1</sub>, ...) where field<sub>n</sub>
            is the nth element formatted with the default format.
            <dt>classes derived from <b>Object</b>
            <dd>The result is the string returned from the class instance's
            <b>.toString()</b> method.
            A <i>Precision</i> specifies the maximum number of characters
            to use in the result.
            <dt>unions
            <dd>If the union defines a <b>toString()</b> method the result is the
            string returned from this function. Otherwise the result is
            the name of the union, without its contents.
            <dt>non-string static and dynamic arrays
            <dd>The result is [s<sub>0</sub>, s<sub>1</sub>, ...]
            where s<sub>n</sub> is the nth element
            formatted with the default format.
            <dt>associative arrays
            <dd>The result is the equivalent of what the initializer
            would look like for the contents of the associative array,
            e.g.: ["red" : 10, "blue" : 20].
        </dl>
<p></p>

        <dt><b>'c'</b>
        <dd>The corresponding argument must be a character type.
<p></p>

        <dt><b>'b','d','o','x','X'</b>
        <dd> The corresponding argument must be an integral type
        and is formatted as an integer. If the argument is a signed type
        and the <i>FormatChar</i> is <b>d</b> it is converted to
        a signed string of characters, otherwise it is treated as
        unsigned. An argument of type <b>bool</b> is formatted as '1'
        or '0'. The base used is binary for <b>b</b>, octal for <b>o</b>,
        decimal
        for <b>d</b>, and hexadecimal for <b>x</b> or <b>X</b>.
        <b>x</b> formats using lower case letters, <b>X</b> uppercase.
        If there are fewer resulting digits than the <i>Precision</i>,
        leading zeros are used as necessary.
        If the <i>Precision</i> is 0 and the number is 0, no digits
        result.
<p></p>

        <dt><b>'e','E'</b>
        <dd> A floating point number is formatted as one digit before
        the decimal point, <i>Precision</i> digits after, the <i>FormatChar</i>,
        &plusmn;, followed by at least a two digit exponent: <i>d.dddddd</i>e<i>&plusmn;dd</i>.
        If there is no <i>Precision</i>, six
        digits are generated after the decimal point.
        If the <i>Precision</i> is 0, no decimal point is generated.
<p></p>

        <dt><b>'f','F'</b>
        <dd> A floating point number is formatted in decimal notation.
        The <i>Precision</i> specifies the number of digits generated
        after the decimal point. It defaults to six. At least one digit
        is generated before the decimal point. If the <i>Precision</i>
        is zero, no decimal point is generated.
<p></p>

        <dt><b>'g','G'</b>
        <dd> A floating point number is formatted in either <b>e</b> or
        <b>f</b> format for <b>g</b>; <b>E</b> or <b>F</b> format for
        <b>G</b>.
        The <b>f</b> format is used if the exponent for an <b>e</b> format
        is greater than -5 and less than the <i>Precision</i>.
        The <i>Precision</i> specifies the number of significant
        digits, and defaults to six.
        Trailing zeros are elided after the decimal point, if the fractional
        part is zero then no decimal point is generated.
<p></p>

        <dt><b>'a','A'</b>
        <dd> A floating point number is formatted in hexadecimal
        exponential notation 0x<i>h.hhhhhh</i>p<i>&plusmn;d</i>.
        There is one hexadecimal digit before the decimal point, and as
        many after as specified by the <i>Precision</i>.
        If the <i>Precision</i> is zero, no decimal point is generated.
        If there is no <i>Precision</i>, as many hexadecimal digits as
        necessary to exactly represent the mantissa are generated.
        The exponent is written in as few digits as possible,
        but at least one, is in decimal, and represents a power of 2 as in
        <i>h.hhhhhh</i>*2<sup><i>&plusmn;d</i></sup>.
        The exponent for zero is zero.
        The hexadecimal digits, x and p are in upper case if the
        <i>FormatChar</i> is upper case.
    </dl>
<p></p>

    Floating point NaN's are formatted as <b>nan</b> if the
    <i>FormatChar</i> is lower case, or <b>NAN</b> if upper.
    Floating point infinities are formatted as <b>inf</b> or
    <b>infinity</b> if the
    <i>FormatChar</i> is lower case, or <b>INF</b> or <b>INFINITY</b> if upper.
    </dl>

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.c.stdio;
<span class="d_keyword">import</span> std.format;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> writer = appender!string();
    <span class="d_psymbol">formattedWrite</span>(writer, <span class="d_string">"%s is the ultimate %s."</span>, 42, <span class="d_string">"answer"</span>);
    <span class="d_keyword">assert</span>(writer.data == <span class="d_string">"42 is the ultimate answer."</span>);
    <span class="d_comment">// Clear the writer
</span>    writer = appender!string();
    <span class="d_psymbol">formattedWrite</span>(writer, <span class="d_string">"Date: %2$s %1$s"</span>, <span class="d_string">"October"</span>, 5);
    <span class="d_keyword">assert</span>(writer.data == <span class="d_string">"Date: 5 October"</span>);
}
</pre>
<p></p>

    The positional and non-positional styles can be mixed in the same
    format string. (POSIX leaves this behavior undefined.) The internal
    counter for non-positional parameters tracks the next parameter after
    the largest positional parameter already used.
<p></p>

    Example using array and nested array formatting:
<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_string">"My items are %(%s %)."</span>, [1,2,3]);
    writefln(<span class="d_string">"My items are %(%s, %)."</span>, [1,2,3]);
}
</pre>
    The output is:
<pre class=console>
My items are 1 2 3.
My items are 1, 2, 3.
</pre>
<p></p>

    The trailing end of the sub-format string following the specifier for each
    item is interpreted as the array delimiter, and is therefore omitted
    following the last array item. The <b>%|</b> delimiter specifier may be used
    to indicate where the delimiter begins, so that the portion of the format
    string prior to it will be retained in the last array element:
<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_string">"My items are %(-%s-%|, %)."</span>, [1,2,3]);
}
</pre>
    which gives the output:
<pre class=console>
My items are -1-, -2-, -3-.
</pre>
<p></p>

    These compound format specifiers may be nested in the case of a nested
    array argument:
<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">void</span> main() {
     <span class="d_keyword">auto</span> mat = [[1, 2, 3],
                 [4, 5, 6],
                 [7, 8, 9]];

     writefln(<span class="d_string">"%(%(%d %)\n%)"</span>, mat);
     writeln();

     writefln(<span class="d_string">"[%(%(%d %)\n %)]"</span>, mat);
     writeln();

     writefln(<span class="d_string">"[%([%(%d %)]%|\n %)]"</span>, mat);
     writeln();
}
</pre>
    The output is:
<pre class=console>
1 2 3
4 5 6
7 8 9
<p></p>

[1 2 3
 4 5 6
 7 8 9]
<p></p>

[[1 2 3]
 [4 5 6]
 [7 8 9]]
</pre>
<p></p>

    Inside a compound format specifier, strings and characters are escaped
    automatically. To avoid this behavior, add <b>'-'</b> flag to
    <span class="d_inlinecode">"%("</span>.
<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    writefln(<span class="d_string">"My friends are %s."</span>, [<span class="d_string">"John"</span>, <span class="d_string">"Nancy"</span>]);
    writefln(<span class="d_string">"My friends are %(%s, %)."</span>, [<span class="d_string">"John"</span>, <span class="d_string">"Nancy"</span>]);
    writefln(<span class="d_string">"My friends are %-(%s, %)."</span>, [<span class="d_string">"John"</span>, <span class="d_string">"Nancy"</span>]);
}
</pre>
   which gives the output:
<pre class=console>
My friends are ["John", "Nancy"].
My friends are "John", "Nancy".
My friends are John, Nancy.
</pre><p></p>

</dd>
<dt class="d_decl"><a name=".formattedRead"></a>uint <a name="formattedRead"></a><span class="ddoc_psymbol">formattedRead</span>(R, Char, S...)(ref R <i>r</i>, const(Char)[] <i>fmt</i>, S <i>args</i>);
</dt>
<dd>Reads characters from input range <span class="d_inlinecode">r</span>, converts them according
   to <span class="d_inlinecode">fmt</span>, and writes them to <span class="d_inlinecode">args</span>.
<p></p>
<b>Returns:</b><br>On success, the function returns the number of variables filled. This count
   can match the expected number of readings or fewer, even zero, if a
   matching failure happens.

<p></p>
<b>Example:</b><br>
<pre class="d_code">string s = <span class="d_string">"hello!124:34.5"</span>;
string a;
<span class="d_keyword">int</span> b;
<span class="d_keyword">double</span> c;
<span class="d_psymbol">formattedRead</span>(s, <span class="d_string">"%s!%s:%s"</span>, &amp;a, &amp;b, &amp;c);
<span class="d_keyword">assert</span>(a == <span class="d_string">"hello"</span> &amp;&amp; b == 124 &amp;&amp; c == 34.5);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec"></a>struct <a name="FormatSpec"></a><span class="ddoc_psymbol">FormatSpec</span>(Char) if (is(Unqual!Char == Char));
</dt>
<dd>A General handler for <span class="d_inlinecode">printf</span> style format specifiers. Used for building more
 specific formatting functions.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = appender!(string)();
<span class="d_keyword">auto</span> fmt = <span class="d_string">"Number: %2.4e\nString: %s"</span>;
<span class="d_keyword">auto</span> f = <span class="d_psymbol">FormatSpec</span>!<span class="d_keyword">char</span>(fmt);

f.writeUpToNextSpec(a);

<span class="d_keyword">assert</span>(a.data == <span class="d_string">"Number: "</span>);
<span class="d_keyword">assert</span>(f.trailing == <span class="d_string">"\nString: %s"</span>);
<span class="d_keyword">assert</span>(f.spec == 'e');
<span class="d_keyword">assert</span>(f.width == 2);
<span class="d_keyword">assert</span>(f.precision == 4);

f.writeUpToNextSpec(a);

<span class="d_keyword">assert</span>(a.data == <span class="d_string">"Number: \nString: "</span>);
<span class="d_keyword">assert</span>(f.trailing == <span class="d_string">""</span>);
<span class="d_keyword">assert</span>(f.spec == 's');
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".FormatSpec.width"></a>int <a name="width"></a><span class="ddoc_psymbol">width</span>;
</dt>
<dd>Minimum width, default <span class="d_inlinecode">0</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.precision"></a>int <a name="precision"></a><span class="ddoc_psymbol">precision</span>;
</dt>
<dd>Precision. Its semantics depends on the argument type. For
       floating point numbers, precision dictates the number of
       decimals printed.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.DYNAMIC"></a>int <a name="DYNAMIC"></a><span class="ddoc_psymbol">DYNAMIC</span>;
</dt>
<dd>Special value for width and precision. <span class="d_inlinecode"><a name="DYNAMIC"></a><span class="ddoc_psymbol">DYNAMIC</span></span> width or
       precision means that they were specified with <span class="d_inlinecode">'*'</span> in the
       format string and are passed at runtime through the varargs.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.UNSPECIFIED"></a>int <a name="UNSPECIFIED"></a><span class="ddoc_psymbol">UNSPECIFIED</span>;
</dt>
<dd>Special value for precision, meaning the format specifier
       contained no explicit precision.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.spec"></a>char <a name="spec"></a><span class="ddoc_psymbol">spec</span>;
</dt>
<dd>The actual format specifier, <span class="d_inlinecode">'s'</span> by default.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.indexStart"></a>ubyte <a name="indexStart"></a><span class="ddoc_psymbol">indexStart</span>;
</dt>
<dd>Index of the argument for positional parameters, from <span class="d_inlinecode">1</span> to
       <span class="d_inlinecode">ubyte.max</span>. (<span class="d_inlinecode">0</span> means not used).<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.indexEnd"></a>ubyte <a name="indexEnd"></a><span class="ddoc_psymbol">indexEnd</span>;
</dt>
<dd>Index of the last argument for positional parameter range, from
       <span class="d_inlinecode">1</span> to <span class="d_inlinecode">ubyte.max</span>. (<span class="d_inlinecode">0</span> means not used).<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.flDash"></a>bool <a name="flDash"></a><span class="ddoc_psymbol">flDash</span>;
</dt>
<dd>The format specifier contained a <span class="d_inlinecode">'-'</span> (<span class="d_inlinecode">printf</span>
         compatibility).<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.flZero"></a>bool <a name="flZero"></a><span class="ddoc_psymbol">flZero</span>;
</dt>
<dd>The format specifier contained a <span class="d_inlinecode">'0'</span> (<span class="d_inlinecode">printf</span>
         compatibility).<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.flSpace"></a>bool <a name="flSpace"></a><span class="ddoc_psymbol">flSpace</span>;
</dt>
<dd>The format specifier contained a <span class="d_inlinecode">' '</span> (<span class="d_inlinecode">printf</span>
         compatibility).<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.flPlus"></a>bool <a name="flPlus"></a><span class="ddoc_psymbol">flPlus</span>;
</dt>
<dd>The format specifier contained a <span class="d_inlinecode">'+'</span> (<span class="d_inlinecode">printf</span>
         compatibility).<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.flHash"></a>bool <a name="flHash"></a><span class="ddoc_psymbol">flHash</span>;
</dt>
<dd>The format specifier contained a <span class="d_inlinecode">'#'</span> (<span class="d_inlinecode">printf</span>
         compatibility).<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.nested"></a>const(Char)[] <a name="nested"></a><span class="ddoc_psymbol">nested</span>;
</dt>
<dd>In case of a compound format specifier starting with <span class="d_inlinecode">       "%("</span> and ending with <span class="d_inlinecode">"%)"</span>, <span class="d_inlinecode">nested</span>
       contains the string contained within the two separators.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.sep"></a>const(Char)[] <a name="sep"></a><span class="ddoc_psymbol">sep</span>;
</dt>
<dd>In case of a compound format specifier, <span class="d_inlinecode">sep</span> contains the
       string positioning after <span class="d_inlinecode">"%|"</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.trailing"></a>const(Char)[] <a name="trailing"></a><span class="ddoc_psymbol">trailing</span>;
</dt>
<dd><span class="d_inlinecode">trailing</span> contains the rest of the format string.<p></p>

</dd>
<dt class="d_decl"><a name=".FormatSpec.this"></a>pure @safe this(in Char[] <i>fmt</i>);
</dt>
<dd>Construct a new <span class="d_inlinecode">FormatSpec</span> using the format string <span class="d_inlinecode"><i>fmt</i></span>, no
       processing is done until needed.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".singleSpec"></a>FormatSpec!Char <a name="singleSpec"></a><span class="ddoc_psymbol">singleSpec</span>(Char)(Char[] <i>fmt</i>);
</dt>
<dd>Helper function that returns a <span class="d_inlinecode">FormatSpec</span> for a single specifier given
   in <span class="d_inlinecode">fmt</span>
<p></p>
Returns a <span class="d_inlinecode">FormatSpec</span> with the specifier parsed.
<p></p>

   Enforces giving only one specifier to the function.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(BooleanTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd><span class="d_inlinecode">bool</span>s are formatted as "<b>true</b>" or "<b>false</b>" with %s and as "1" or
   "0" with integral-specific format specs.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(Unqual!T == typeof(null)) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd><span class="d_inlinecode"><b>null</b></span> literal is formatted as <span class="d_inlinecode">"<b>null</b>"</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(IntegralTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Integrals are formatted like <span class="d_inlinecode">printf</span> does.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(FloatingPointTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Floating-point values are formatted like <span class="d_inlinecode">printf</span> does.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(CharTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Individual characters (<span class="d_inlinecode">char</span>, <span class="d_inlinecode">wchar</span>, or <span class="d_inlinecode">dchar</span>) are
   formatted as Unicode characters with %s and as integers with
   integral-specific format specs.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(StringTypeOf!T) &amp;&amp; !is(StaticArrayTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Strings are formatted like <span class="d_inlinecode">printf</span> does.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, auto ref T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(StaticArrayTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Static-size arrays are formatted as dynamic arrays.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(DynamicArrayTypeOf!T) &amp;&amp; !is(StringTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Dynamic arrays are formatted as input ranges.
<p></p>
<b>Specializations:</b><br>
<ul><li><span class="d_inlinecode">void[]</span> is formatted like <span class="d_inlinecode">ubyte[]</span>.</li>
          <li>Const array is converted to input range by removing its qualifier.</li></ul><p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>obj</i>, ref FormatSpec!Char <i>f</i>) if (is(AssocArrayTypeOf!T) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Associative arrays are formatted by using <span class="d_inlinecode">':'</span> and <span class="d_inlinecode">", "</span> as
   separators, and enclosed by <span class="d_inlinecode">'['</span> and <span class="d_inlinecode">']'</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>val</i>, ref FormatSpec!Char <i>f</i>) if (is(T == class) &amp;&amp; !is(T == enum));
<br><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>val</i>, ref FormatSpec!Char <i>f</i>) if (is(T == interface) &amp;&amp; (hasToString!(T, Char) || !is(BuiltinTypeOf!T)) &amp;&amp; !is(T == enum));
<br><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, auto ref T <i>val</i>, ref FormatSpec!Char <i>f</i>) if ((is(T == struct) || is(T == union)) &amp;&amp; (hasToString!(T, Char) || !is(BuiltinTypeOf!T)) &amp;&amp; !is(T == enum));
</dt>
<dd>Aggregates (<span class="d_inlinecode">struct</span>, <span class="d_inlinecode">union</span>, <span class="d_inlinecode">class</span>, and <span class="d_inlinecode">interface</span>) are
   basically formatted by calling <span class="d_inlinecode">toString</span>.
   <span class="d_inlinecode">toString</span> should have one of the following signatures:
<p></p>
<pre class="d_code"><span class="d_keyword">const</span> <span class="d_keyword">void</span> toString(<span class="d_keyword">scope</span> <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[]) sink, FormatSpec fmt);
<span class="d_keyword">const</span> <span class="d_keyword">void</span> toString(<span class="d_keyword">scope</span> <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[]) sink, string fmt);
<span class="d_keyword">const</span> <span class="d_keyword">void</span> toString(<span class="d_keyword">scope</span> <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[]) sink);
<span class="d_keyword">const</span> string toString();
</pre>
<p></p>

   For the class objects which have input range interface,
   <ul><li>If the instance <span class="d_inlinecode">toString</span> has overridden
             <span class="d_inlinecode">Object.toString</span>, it is used.</li>
        <li>Otherwise, the objects are formatted as input range.</li></ul>
<p></p>

   For the struct and union objects which does not have <span class="d_inlinecode">toString</span>,
   <ul><li>If they have range interface, formatted as input range.</li>
        <li>Otherwise, they are formatted like <span class="d_inlinecode">Type(field1, filed2, ...)</span>.</li></ul>
<p></p>

   Otherwise, are formatted just as their type name.<p></p>
<b>Examples:</b><br><span class="d_inlinecode"><a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span></span> allows to reuse existing format specifiers:
<pre class="d_code">
<span class="d_keyword">import</span> std.format;
<span class="d_keyword">import</span> std.string : format;

<span class="d_keyword">struct</span> Point
{
    <span class="d_keyword">int</span> x, y;

    <span class="d_keyword">void</span> toString(<span class="d_keyword">scope</span> <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[]) sink,
                  FormatSpec!<span class="d_keyword">char</span> fmt) <span class="d_keyword">const</span>
    {
        sink(<span class="d_string">"("</span>);
        sink.<span class="d_psymbol">formatValue</span>(x, fmt);
        sink(<span class="d_string">","</span>);
        sink.<span class="d_psymbol">formatValue</span>(y, fmt);
        sink(<span class="d_string">")"</span>);
    }
}

<span class="d_keyword">auto</span> p = Point(16,11);
<span class="d_keyword">assert</span>(format(<span class="d_string">"%03d"</span>, p) == <span class="d_string">"(016,011)"</span>);
<span class="d_keyword">assert</span>(format(<span class="d_string">"%02x"</span>, p) == <span class="d_string">"(10,0b)"</span>);
</pre>
<p></p><b>Examples:</b><br>The following code compares the use of <span class="d_inlinecode"><a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span></span> and <span class="d_inlinecode">formattedWrite</span>.
<pre class="d_code">
<span class="d_keyword">import</span> std.format;
<span class="d_keyword">import</span> std.array : appender;

<span class="d_keyword">auto</span> writer1 = appender!string();
writer1.formattedWrite(<span class="d_string">"%08b"</span>, 42);

<span class="d_keyword">auto</span> writer2 = appender!string();
<span class="d_keyword">auto</span> f = singleSpec(<span class="d_string">"%08b"</span>);
writer2.<span class="d_psymbol">formatValue</span>(42, f);

<span class="d_keyword">assert</span>(writer1.data == writer2.data &amp;&amp; writer1.data == <span class="d_string">"00101010"</span>);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>val</i>, ref FormatSpec!Char <i>f</i>) if (is(T == enum));
</dt>
<dd><span class="d_inlinecode">enum</span> is formatted like its base value.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>val</i>, ref FormatSpec!Char <i>f</i>) if (isPointer!T &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Pointers are formatted as hex integers.<p></p>

</dd>
<dt class="d_decl"><a name=".formatValue"></a>void <a name="formatValue"></a><span class="ddoc_psymbol">formatValue</span>(Writer, T, Char)(Writer <i>w</i>, T <i>val</i>, ref FormatSpec!Char <i>f</i>) if (is(T == delegate) &amp;&amp; !is(T == enum) &amp;&amp; !hasToString!(T, Char));
</dt>
<dd>Delegates are formatted by 'Attributes ReturnType delegate(Parameters)'<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isInputRange!Range &amp;&amp; is(Unqual!T == bool));
</dt>
<dd>Reads a boolean value and returns it.<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isInputRange!Range &amp;&amp; is(T == typeof(null)));
</dt>
<dd>Reads <b>null</b> literal and returns it.<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isInputRange!Range &amp;&amp; isIntegral!T &amp;&amp; !is(T == enum));
</dt>
<dd>Reads an integral value and returns it.<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isFloatingPoint!T &amp;&amp; !is(T == enum));
</dt>
<dd>Reads a floating-point value and returns it.<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isInputRange!Range &amp;&amp; isSomeChar!T &amp;&amp; !is(T == enum));
</dt>
<dd>Reads one character and returns it.<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isInputRange!Range &amp;&amp; is(StringTypeOf!T) &amp;&amp; !isAggregateType!T &amp;&amp; !is(T == enum));
</dt>
<dd>Reads a string and returns it.<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isInputRange!Range &amp;&amp; isArray!T &amp;&amp; !is(StringTypeOf!T) &amp;&amp; !isAggregateType!T &amp;&amp; !is(T == enum));
</dt>
<dd>Reads an array (except for string types) and returns it.<p></p>

</dd>
<dt class="d_decl"><a name=".unformatValue"></a>T <a name="unformatValue"></a><span class="ddoc_psymbol">unformatValue</span>(T, Range, Char)(ref Range <i>input</i>, ref FormatSpec!Char <i>spec</i>) if (isInputRange!Range &amp;&amp; isAssociativeArray!T &amp;&amp; !is(T == enum));
</dt>
<dd>Reads an associative array and returns it.<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Digital Mars 2000-2013.

 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

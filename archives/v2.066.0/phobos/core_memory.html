<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>core.memory - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos </a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/druntime/edit/master/src/core/memory.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>core.memory</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from src/core/memory.d -->
This module provides an interface to the garbage collector used by
 applications written in the D programming language. It allows the
 garbage collector in the runtime to be swapped without affecting
 binary compatibility of applications.
<p></p>
Using this module is not necessary in typical D code. It is mostly
 useful when doing low-level <a name="memory"></a><span class="ddoc_psymbol">memory</span> management.

<p></p>
<b>Notes to implementors:</b><br>
<ul> <li>On POSIX systems, the signals SIGUSR1 and SIGUSR2 are reserved
   by this module for use in the garbage collector implementation.
   Typically, they will be used to stop and resume other threads
   when performing a collection, but an implementation may choose
   not to use this mechanism (or not stop the world at all, in the
   case of concurrent garbage collectors).</li>
<p></p>

 <li>Registers, the stack, and any other <a name="memory"></a><span class="ddoc_psymbol">memory</span> locations added through
   the <span class="d_inlinecode">GC.<a href="#addRange"><span class="d_inlinecode">addRange</span></a></span> function are always scanned conservatively.
   This means that even if a variable is e.g. of type <span class="d_inlinecode">float</span>,
   it will still be scanned for possible GC pointers. And, if the
   word-interpreted representation of the variable matches a GC-managed
   <a name="memory"></a><span class="ddoc_psymbol">memory</span> block's address, that <a name="memory"></a><span class="ddoc_psymbol">memory</span> block is considered live.</li>
<p></p>

 <li>Implementations are free to scan the non-root heap in a precise
   manner, so that fields of types like <span class="d_inlinecode">float</span> will not be considered
   relevant when scanning the heap. Thus, casting a GC pointer to an
   integral type (e.g. <span class="d_inlinecode">size_t</span>) and storing it in a field of that
   type inside the GC heap may mean that it will not be recognized
   if the <a name="memory"></a><span class="ddoc_psymbol">memory</span> block was allocated with precise type info or with
   the <span class="d_inlinecode">GC.BlkAttr.<a href="#NO_SCAN"><span class="d_inlinecode">NO_SCAN</span></a></span> attribute.</li>
<p></p>

 <li>Destructors will always be executed while other threads are
   active; that is, an implementation that stops the world must not
   execute destructors until the world has been resumed.</li>
<p></p>

 <li>A destructor of an object must not access object references
   within the object. This means that an implementation is free to
   optimize based on this rule.</li>
<p></p>

 <li>An implementation is free to perform heap compaction and copying
   so long as no valid GC pointers are invalidated in the process.
   However, <a name="memory"></a><span class="ddoc_psymbol">memory</span> allocated with <span class="d_inlinecode">GC.BlkAttr.<a href="#NO_MOVE"><span class="d_inlinecode">NO_MOVE</span></a></span> must
   not be moved/copied.</li>
<p></p>

 <li>Implementations must support interior pointers. That is, if the
   only reference to a GC-managed <a name="memory"></a><span class="ddoc_psymbol">memory</span> block points into the
   middle of the block rather than the beginning (for example), the
   GC must consider the <a name="memory"></a><span class="ddoc_psymbol">memory</span> block live. The exception to this
   rule is when a <a name="memory"></a><span class="ddoc_psymbol">memory</span> block is allocated with the
   <span class="d_inlinecode">GC.BlkAttr.<a href="#NO_INTERIOR"><span class="d_inlinecode">NO_INTERIOR</span></a></span> attribute; it is the user's
   responsibility to make sure such <a name="memory"></a><span class="ddoc_psymbol">memory</span> blocks have a proper pointer
   to them when they should be considered live.</li>
<p></p>

 <li>It is acceptable for an implementation to store bit flags into
   pointer values and GC-managed <a name="memory"></a><span class="ddoc_psymbol">memory</span> blocks, so long as such a
   trick is not visible to the application. In practice, this means
   that only a stop-the-world collector can do this.</li>
<p></p>

 <li>Implementations are free to assume that GC pointers are only
   stored on word boundaries. Unaligned pointers may be ignored
   entirely.</li>
<p></p>

 <li>Implementations are free to run collections at any point. It is,
   however, recommendable to only do so when an allocation attempt
   happens and there is insufficient <a name="memory"></a><span class="ddoc_psymbol">memory</span> available.</li>
 </ul>

<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<p></p>
<b>Authors:</b><br>Sean Kelly, Alex Rønne Petersen
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/druntime/blob/master/src/core/memory.d">core/memory.d</a><p></p>

<dl><dt class="d_decl"><a name=".GC"></a>struct <a name="GC"></a><span class="ddoc_psymbol">GC</span>;
</dt>
<dd>This struct encapsulates all garbage collection functionality for the D
 programming language.<p></p>

<dl><dt class="d_decl"><a name=".GC.enable"></a>static nothrow void <a name="enable"></a><span class="ddoc_psymbol">enable</span>();
</dt>
<dd>Enables automatic garbage collection behavior if collections have
 previously been suspended by a call to disable.  This function is
 reentrant, and must be called once for every call to disable before
 automatic collections are enabled.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.disable"></a>static nothrow void <a name="disable"></a><span class="ddoc_psymbol">disable</span>();
</dt>
<dd>Disables automatic garbage collections performed to minimize the
 process footprint.  Collections may continue to occur in instances
 where the implementation deems necessary for correct program behavior,
 such as during an out of memory condition.  This function is reentrant,
 but enable must be called once for each call to <a name="disable"></a><span class="ddoc_psymbol">disable</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.collect"></a>static nothrow void <a name="collect"></a><span class="ddoc_psymbol">collect</span>();
</dt>
<dd>Begins a full collection.  While the meaning of this may change based
 on the garbage collector implementation, typical behavior is to scan
 all stack segments for roots, mark accessible memory blocks as alive,
 and then to reclaim free space.  This action may need to suspend all
 running threads for at least part of the collection process.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.minimize"></a>static nothrow void <a name="minimize"></a><span class="ddoc_psymbol">minimize</span>();
</dt>
<dd>Indicates that the managed memory space be minimized by returning free
 physical memory to the operating system.  The amount of free memory
 returned depends on the allocator design and on program behavior.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.BlkAttr"></a>enum <a name="BlkAttr"></a><span class="ddoc_psymbol">BlkAttr</span>: uint;
</dt>
<dd>Elements for a bit field representing memory block attributes.  These
 are manipulated via the getAttr, setAttr, clrAttr functions.<p></p>

<dl><dt class="d_decl"><a name=".GC.BlkAttr.NONE"></a><a name="NONE"></a><span class="ddoc_psymbol">NONE</span></dt>
<dd>No attributes set.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.BlkAttr.FINALIZE"></a><a name="FINALIZE"></a><span class="ddoc_psymbol">FINALIZE</span></dt>
<dd>Finalize the data in this block on collect.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.BlkAttr.NO_SCAN"></a><a name="NO_SCAN"></a><span class="ddoc_psymbol">NO_SCAN</span></dt>
<dd>Do not scan through this block on collect.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.BlkAttr.NO_MOVE"></a><a name="NO_MOVE"></a><span class="ddoc_psymbol">NO_MOVE</span></dt>
<dd>Do not move this memory block on collect.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.BlkAttr.APPENDABLE"></a><a name="APPENDABLE"></a><span class="ddoc_psymbol">APPENDABLE</span></dt>
<dd>This block contains the info to allow appending.
<p></p>
This can be used to manually allocate arrays. Initial slice size is 0.

<p></p>
<b>Note:</b><br>
The slice's useable size will not match the block size. Use
        <a href="#capacity"><span class="d_inlinecode">capacity</span></a> to retrieve actual useable capacity.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Allocate the underlying array.
</span><span class="d_keyword">int</span>*  pToArray = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)GC.malloc(10 * <span class="d_keyword">int</span>.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.<span class="d_psymbol">APPENDABLE</span>);
<span class="d_comment">// Bind a slice. Check the slice has capacity information.
</span><span class="d_keyword">int</span>[] slice = pToArray[0 .. 0];
<span class="d_keyword">assert</span>(capacity(slice) &gt; 0);
<span class="d_comment">// Appending to the slice will not relocate it.
</span>slice.length = 5;
slice ~= 1;
<span class="d_keyword">assert</span>(slice.ptr == p);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".GC.BlkAttr.NO_INTERIOR"></a><a name="NO_INTERIOR"></a><span class="ddoc_psymbol">NO_INTERIOR</span></dt>
<dd>This block is guaranteed to have a pointer to its base while it is
        alive.  Interior pointers can be safely ignored.  This attribute is
        useful for eliminating <b>false</b> pointers in very large data structures
        and is only implemented for data structures at least a page in size.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".GC.BlkInfo"></a>alias <a name="BlkInfo"></a><span class="ddoc_psymbol">BlkInfo</span> = .BlkInfo_;
</dt>
<dd>Contains aggregate information about a block of managed memory.  The
 purpose of this struct is to support a more efficient query style in
 instances where detailed information is needed.
<p></p>
base = A pointer to the base of the block in question.
 size = The size of the block, calculated from base.
 attr = Attribute bits set on the memory block.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.getAttr"></a>static nothrow uint <a name="getAttr"></a><span class="ddoc_psymbol">getAttr</span>(in void* <i>p</i>);
<br><a name=".GC.getAttr"></a>static pure nothrow uint <a name="getAttr"></a><span class="ddoc_psymbol">getAttr</span>(void* <i>p</i>);
</dt>
<dd>Returns a bit field representing all block attributes set for the memory
 referenced by <i>p</i>.  If <i>p</i> references memory not originally allocated by
 this garbage collector, points to the interior of a memory block, or if
 <i>p</i> is <b>null</b>, zero will be returned.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root of a valid memory block or to <b>null</b>.</td></tr>
</table><p></p>
<b>Returns:</b><br>A bit field containing any bits set for the memory block referenced by
  <i>p</i> or zero on error.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.setAttr"></a>static nothrow uint <a name="setAttr"></a><span class="ddoc_psymbol">setAttr</span>(in void* <i>p</i>, uint <i>a</i>);
<br><a name=".GC.setAttr"></a>static pure nothrow uint <a name="setAttr"></a><span class="ddoc_psymbol">setAttr</span>(void* <i>p</i>, uint <i>a</i>);
</dt>
<dd>Sets the specified bits for the memory references by <i>p</i>.  If <i>p</i> references
 memory not originally allocated by this garbage collector, points to the
 interior of <i>a</i> memory block, or if <i>p</i> is <b>null</b>, no action will be
 performed.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root of <i>a</i> valid memory block or to <b>null</b>.</td></tr>
<tr><td valign=top>uint <i>a</i></td>
<td valign=top>A bit field containing any bits to set for this memory block.</td></tr>
</table><p></p>
<b>Returns:</b><br>The result of <i>a</i> call to getAttr after the specified bits have been
  set.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.clrAttr"></a>static nothrow uint <a name="clrAttr"></a><span class="ddoc_psymbol">clrAttr</span>(in void* <i>p</i>, uint <i>a</i>);
<br><a name=".GC.clrAttr"></a>static pure nothrow uint <a name="clrAttr"></a><span class="ddoc_psymbol">clrAttr</span>(void* <i>p</i>, uint <i>a</i>);
</dt>
<dd>Clears the specified bits for the memory references by <i>p</i>.  If <i>p</i>
 references memory not originally allocated by this garbage collector,
 points to the interior of <i>a</i> memory block, or if <i>p</i> is <b>null</b>, no action
 will be performed.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root of <i>a</i> valid memory block or to <b>null</b>.</td></tr>
<tr><td valign=top>uint <i>a</i></td>
<td valign=top>A bit field containing any bits to clear for this memory block.</td></tr>
</table><p></p>
<b>Returns:</b><br>The result of <i>a</i> call to getAttr after the specified bits have been
  cleared.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.malloc"></a>static pure nothrow void* <a name="malloc"></a><span class="ddoc_psymbol">malloc</span>(size_t <i>sz</i>, uint <i>ba</i> = 0, const TypeInfo <i>ti</i> = null);
</dt>
<dd>Requests an aligned block of managed memory from the garbage collector.
 This memory may be deleted at will with a call to free, or it may be
 discarded and cleaned up automatically during a collection run.  If
 allocation fails, this function will call onOutOfMemory which is
 expected to throw an OutOfMemoryError.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The desired allocation size in bytes.</td></tr>
<tr><td valign=top>uint <i>ba</i></td>
<td valign=top>A bitmask of the attributes to set on this block.</td></tr>
<tr><td valign=top>TypeInfo <i>ti</i></td>
<td valign=top>TypeInfo to describe the memory. The GC might use this information
       to improve scanning for pointers or to call finalizers.</td></tr>
</table><p></p>
<b>Returns:</b><br>A reference to the allocated memory or <b>null</b> if insufficient memory
  is available.

<p></p>
<b>Throws:</b><br>OutOfMemoryError on allocation failure.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.qalloc"></a>static pure nothrow BlkInfo <a name="qalloc"></a><span class="ddoc_psymbol">qalloc</span>(size_t <i>sz</i>, uint <i>ba</i> = 0, const TypeInfo <i>ti</i> = null);
</dt>
<dd>Requests an aligned block of managed memory from the garbage collector.
 This memory may be deleted at will with a call to free, or it may be
 discarded and cleaned up automatically during a collection run.  If
 allocation fails, this function will call onOutOfMemory which is
 expected to throw an OutOfMemoryError.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The desired allocation size in bytes.</td></tr>
<tr><td valign=top>uint <i>ba</i></td>
<td valign=top>A bitmask of the attributes to set on this block.</td></tr>
<tr><td valign=top>TypeInfo <i>ti</i></td>
<td valign=top>TypeInfo to describe the memory. The GC might use this information
       to improve scanning for pointers or to call finalizers.</td></tr>
</table><p></p>
<b>Returns:</b><br>Information regarding the allocated memory block or BlkInfo.init on
  error.

<p></p>
<b>Throws:</b><br>OutOfMemoryError on allocation failure.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.calloc"></a>static pure nothrow void* <a name="calloc"></a><span class="ddoc_psymbol">calloc</span>(size_t <i>sz</i>, uint <i>ba</i> = 0, const TypeInfo <i>ti</i> = null);
</dt>
<dd>Requests an aligned block of managed memory from the garbage collector,
 which is initialized with all bits set to zero.  This memory may be
 deleted at will with a call to free, or it may be discarded and cleaned
 up automatically during a collection run.  If allocation fails, this
 function will call onOutOfMemory which is expected to throw an
 OutOfMemoryError.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The desired allocation size in bytes.</td></tr>
<tr><td valign=top>uint <i>ba</i></td>
<td valign=top>A bitmask of the attributes to set on this block.</td></tr>
<tr><td valign=top>TypeInfo <i>ti</i></td>
<td valign=top>TypeInfo to describe the memory. The GC might use this information
       to improve scanning for pointers or to call finalizers.</td></tr>
</table><p></p>
<b>Returns:</b><br>A reference to the allocated memory or <b>null</b> if insufficient memory
  is available.

<p></p>
<b>Throws:</b><br>OutOfMemoryError on allocation failure.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.realloc"></a>static pure nothrow void* <a name="realloc"></a><span class="ddoc_psymbol">realloc</span>(void* <i>p</i>, size_t <i>sz</i>, uint <i>ba</i> = 0, const TypeInfo <i>ti</i> = null);
</dt>
<dd>If <i>sz</i> is zero, the memory referenced by <i>p</i> will be deallocated as if
 by a call to free.  A new memory block of size <i>sz</i> will then be
 allocated as if by a call to malloc, or the implementation may instead
 resize the memory block in place.  The contents of the new memory block
 will be the same as the contents of the old memory block, up to the
 lesser of the new and old sizes.  Note that existing memory will only
 be freed by <a name="realloc"></a><span class="ddoc_psymbol">realloc</span> if <i>sz</i> is equal to zero.  The garbage collector is
 otherwise expected to later reclaim the memory block if it is unused.
 If allocation fails, this function will call onOutOfMemory which is
 expected to throw an OutOfMemoryError.  If <i>p</i> references memory not
 originally allocated by this garbage collector, or if it points to the
 interior of a memory block, no action will be taken.  If <i>ba</i> is zero
 (the default) and <i>p</i> references the head of a valid, known memory block
 then any bits set on the current block will be set on the new block if a
 reallocation is required.  If <i>ba</i> is not zero and <i>p</i> references the head
 of a valid, known memory block then the bits in <i>ba</i> will replace those on
 the current memory block and will also be set on the new block if a
 reallocation is required.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root of a valid memory block or to <b>null</b>.</td></tr>
<tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The desired allocation size in bytes.</td></tr>
<tr><td valign=top>uint <i>ba</i></td>
<td valign=top>A bitmask of the attributes to set on this block.</td></tr>
<tr><td valign=top>TypeInfo <i>ti</i></td>
<td valign=top>TypeInfo to describe the memory. The GC might use this information
       to improve scanning for pointers or to call finalizers.</td></tr>
</table><p></p>
<b>Returns:</b><br>A reference to the allocated memory on success or <b>null</b> if <i>sz</i> is
  zero.  On failure, the original value of <i>p</i> is returned.

<p></p>
<b>Throws:</b><br>OutOfMemoryError on allocation failure.<p></p>
<b>Examples:</b><br>Issue 13111
<pre class="d_code">
<span class="d_keyword">enum</span> size1 = 1 &lt;&lt; 11 + 1; <span class="d_comment">// page in large object pool
</span><span class="d_keyword">enum</span> size2 = 1 &lt;&lt; 22 + 1; <span class="d_comment">// larger than large object pool size
</span>
<span class="d_keyword">auto</span> data1 = <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>*)GC.calloc(size1);
<span class="d_keyword">auto</span> data2 = <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>*)GC.<span class="d_psymbol">realloc</span>(data1, size2);

BlkInfo info = query(data2);
<span class="d_keyword">assert</span>(info.size &gt;= size2);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".GC.extend"></a>static pure nothrow size_t <a name="extend"></a><span class="ddoc_psymbol">extend</span>(void* <i>p</i>, size_t <i>mx</i>, size_t <i>sz</i>, const TypeInfo <i>ti</i> = null);
</dt>
<dd>Requests that the managed memory block referenced by <i>p</i> be extended in
 place by at least <i>mx</i> bytes, with a desired extension of <i>sz</i> bytes.  If an
 extension of the required size is not possible or if <i>p</i> references memory
 not originally allocated by this garbage collector, no action will be
 taken.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root of a valid memory block or to <b>null</b>.</td></tr>
<tr><td valign=top>size_t <i>mx</i></td>
<td valign=top>The minimum extension size in bytes.</td></tr>
<tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The desired extension size in bytes.</td></tr>
<tr><td valign=top>TypeInfo <i>ti</i></td>
<td valign=top>TypeInfo to describe the full memory block. The GC might use
       this information to improve scanning for pointers or to
       call finalizers.</td></tr>
</table><p></p>
<b>Returns:</b><br>The size in bytes of the extended memory block referenced by <i>p</i> or zero
  if no extension occurred.

<p></p>
<b>Note:</b><br>
Extend may also be used to <a name="extend"></a><span class="ddoc_psymbol">extend</span> slices (or memory blocks with
  <a href="#APPENDABLE"><span class="d_inlinecode">APPENDABLE</span></a> info). However, use the return value only
  as an indicator of success. <a href="#capacity"><span class="d_inlinecode">capacity</span></a> should be used to
  retrieve actual useable slice capacity.<p></p>
<b>Examples:</b><br>Standard extending
<pre class="d_code">
size_t size = 1000;
<span class="d_keyword">int</span>* <span class="d_param">p</span> = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)GC.malloc(size * <span class="d_keyword">int</span>.sizeof, GC.BlkAttr.NO_SCAN);

<span class="d_comment">//Try to extend the allocated data by 1000 elements, preferred 2000.
</span>size_t u = GC.<span class="d_psymbol">extend</span>(<span class="d_param">p</span>, 1000 * <span class="d_keyword">int</span>.sizeof, 2000 * <span class="d_keyword">int</span>.sizeof);
<span class="d_keyword">if</span> (u != 0)
    size = u / <span class="d_keyword">int</span>.sizeof;
</pre>
<p></p><b>Examples:</b><br>slice extending
<pre class="d_code">
<span class="d_keyword">int</span>[] slice = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[](1000);
<span class="d_keyword">int</span>*  <span class="d_param">p</span>     = slice.ptr;

<span class="d_comment">//Check we have access to capacity before attempting the extend
</span><span class="d_keyword">if</span> (slice.capacity)
{
    <span class="d_comment">//Try to extend slice by 1000 elements, preferred 2000.
</span>    size_t u = GC.<span class="d_psymbol">extend</span>(<span class="d_param">p</span>, 1000 * <span class="d_keyword">int</span>.sizeof, 2000 * <span class="d_keyword">int</span>.sizeof);
    <span class="d_keyword">if</span> (u != 0)
    {
        slice.length = slice.capacity;
        <span class="d_keyword">assert</span>(slice.length &gt;= 2000);
    }
}
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".GC.reserve"></a>static nothrow size_t <a name="reserve"></a><span class="ddoc_psymbol">reserve</span>(size_t <i>sz</i>);
</dt>
<dd>Requests that at least <i>sz</i> bytes of memory be obtained from the operating
 system and marked as free.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The desired size in bytes.</td></tr>
</table><p></p>
<b>Returns:</b><br>The actual number of bytes reserved or zero on error.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.free"></a>static pure nothrow void <a name="free"></a><span class="ddoc_psymbol">free</span>(void* <i>p</i>);
</dt>
<dd>Deallocates the memory referenced by <i>p</i>.  If <i>p</i> is <b>null</b>, no action
 occurs.  If <i>p</i> references memory not originally allocated by this
 garbage collector, or if it points to the interior of a memory block,
 no action will be taken.  The block will not be finalized regardless
 of whether the FINALIZE attribute is set.  If finalization is desired,
 use delete instead.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root of a valid memory block or to <b>null</b>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".GC.addrOf"></a>static nothrow inout(void)* <a name="addrOf"></a><span class="ddoc_psymbol">addrOf</span>(inout(void)* <i>p</i>);
<br><a name=".GC.addrOf"></a>static pure nothrow void* <a name="addrOf"></a><span class="ddoc_psymbol">addrOf</span>(void* <i>p</i>);
</dt>
<dd>Returns the base address of the memory block containing <i>p</i>.  This value
 is useful to determine whether <i>p</i> is an interior pointer, and the result
 may be passed to routines such as sizeOf which may otherwise fail.  If <i>p</i>
 references memory not originally allocated by this garbage collector, if
 <i>p</i> is <b>null</b>, or if the garbage collector does not support this operation,
 <b>null</b> will be returned.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>inout(void)* <i>p</i></td>
<td valign=top>A pointer to the root or the interior of a valid memory block or to
      <b>null</b>.</td></tr>
</table><p></p>
<b>Returns:</b><br>The base address of the memory block referenced by <i>p</i> or <b>null</b> on error.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.sizeOf"></a>static nothrow size_t <a name="sizeOf"></a><span class="ddoc_psymbol">sizeOf</span>(in void* <i>p</i>);
<br><a name=".GC.sizeOf"></a>static pure nothrow size_t <a name="sizeOf"></a><span class="ddoc_psymbol">sizeOf</span>(void* <i>p</i>);
</dt>
<dd>Returns the <b>true</b> size of the memory block referenced by <i>p</i>.  This value
 represents the maximum number of bytes for which a call to realloc may
 resize the existing block in place.  If <i>p</i> references memory not
 originally allocated by this garbage collector, points to the interior
 of a memory block, or if <i>p</i> is <b>null</b>, zero will be returned.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root of a valid memory block or to <b>null</b>.</td></tr>
</table><p></p>
<b>Returns:</b><br>The size in bytes of the memory block referenced by <i>p</i> or zero on error.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.query"></a>static nothrow BlkInfo <a name="query"></a><span class="ddoc_psymbol">query</span>(in void* <i>p</i>);
<br><a name=".GC.query"></a>static pure nothrow BlkInfo <a name="query"></a><span class="ddoc_psymbol">query</span>(void* <i>p</i>);
</dt>
<dd>Returns aggregate information about the memory block containing <i>p</i>.  If <i>p</i>
 references memory not originally allocated by this garbage collector, if
 <i>p</i> is <b>null</b>, or if the garbage collector does not support this operation,
 BlkInfo.init will be returned.  Typically, support for this operation
 is dependent on support for addrOf.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to the root or the interior of a valid memory block or to
      <b>null</b>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Information regarding the memory block referenced by <i>p</i> or BlkInfo.init
  on error.<p></p>

</dd>
<dt class="d_decl"><a name=".GC.addRoot"></a>static nothrow void <a name="addRoot"></a><span class="ddoc_psymbol">addRoot</span>(in void* <i>p</i>);
</dt>
<dd>Adds an internal root pointing to the GC memory block referenced by <i>p</i>.
 As a result, the block referenced by <i>p</i> itself and any blocks accessible
 via it will be considered live until the root is removed again.
<p></p>
If <i>p</i> is <b>null</b>, no operation is performed.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer into a GC-managed memory block or <b>null</b>.</td></tr>
</table><p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Typical C-style callback mechanism; the passed function
</span><span class="d_comment">// is invoked with the user-supplied context pointer at a
</span><span class="d_comment">// later point.
</span><span class="d_keyword">extern</span>(C) <span class="d_keyword">void</span> addCallback(<span class="d_keyword">void</span> <span class="d_keyword">function</span>(<span class="d_keyword">void</span>*), <span class="d_keyword">void</span>*);

<span class="d_comment">// Allocate an object on the GC heap (this would usually be
</span><span class="d_comment">// some application-specific context data).
</span><span class="d_keyword">auto</span> context = <span class="d_keyword">new</span> Object;

<span class="d_comment">// Make sure that it is not collected even if it is no
</span><span class="d_comment">// longer referenced from D code (stack, GC heap, …).
</span>GC.<span class="d_psymbol">addRoot</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)context);

<span class="d_comment">// Also ensure that a moving collector does not relocate
</span><span class="d_comment">// the object.
</span>GC.setAttr(<span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)context, GC.BlkAttr.NO_MOVE);

<span class="d_comment">// Now context can be safely passed to the C library.
</span>addCallback(&amp;myHandler, <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)context);

<span class="d_keyword">extern</span>(C) <span class="d_keyword">void</span> myHandler(<span class="d_keyword">void</span>* ctx)
{
    <span class="d_comment">// Assuming that the callback is invoked only once, the
</span>    <span class="d_comment">// added root can be removed again now to allow the GC
</span>    <span class="d_comment">// to collect it later.
</span>    GC.removeRoot(ctx);
    GC.clrAttr(ctx, GC.BlkAttr.NO_MOVE);

    <span class="d_keyword">auto</span> context = <span class="d_keyword">cast</span>(Object)ctx;
    <span class="d_comment">// Use context here…
</span>}
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".GC.removeRoot"></a>static nothrow void <a name="removeRoot"></a><span class="ddoc_psymbol">removeRoot</span>(in void* <i>p</i>);
</dt>
<dd>Removes the memory block referenced by <i>p</i> from an internal list of roots
 to be scanned during a collection.  If <i>p</i> is <b>null</b> or is not a value
 previously passed to addRoot() then no operation is performed.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer into a GC-managed memory block or <b>null</b>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".GC.addRange"></a>static nothrow void <a name="addRange"></a><span class="ddoc_psymbol">addRange</span>(in void* <i>p</i>, size_t <i>sz</i>, const TypeInfo <i>ti</i> = null);
</dt>
<dd>Adds <span class="d_inlinecode"><i>p</i>[0 .. <i>sz</i>]</span> to the list of memory ranges to be scanned for
 pointers during a collection. If <i>p</i> is <b>null</b>, no operation is performed.
<p></p>
Note that <span class="d_inlinecode"><i>p</i>[0 .. <i>sz</i>]</span> is treated as an opaque range of memory assumed
 to be suitably managed by the caller. In particular, if <i>p</i> points into a
 GC-managed memory block, <a name="addRange"></a><span class="ddoc_psymbol">addRange</span> does <i>not</i> mark this block as live.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to a valid memory address or to <b>null</b>.</td></tr>
<tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The size in bytes of the block to add. If <i>sz</i> is zero then the
       no operation will occur. If <i>p</i> is <b>null</b> then <i>sz</i> must be zero.</td></tr>
<tr><td valign=top>TypeInfo <i>ti</i></td>
<td valign=top>TypeInfo to describe the memory. The GC might use this information
       to improve scanning for pointers or to call finalizers</td></tr>
</table><p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Allocate a piece of memory on the C heap.
</span><span class="d_keyword">enum</span> size = 1_000;
<span class="d_keyword">auto</span> rawMemory = core.stdc.stdlib.malloc(size);

<span class="d_comment">// Add it as a GC range.
</span>GC.<span class="d_psymbol">addRange</span>(rawMemory, size);

<span class="d_comment">// Now, pointers to GC-managed memory stored in
</span><span class="d_comment">// rawMemory will be recognized on collection.
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".GC.removeRange"></a>static nothrow void <a name="removeRange"></a><span class="ddoc_psymbol">removeRange</span>(in void* <i>p</i>);
</dt>
<dd>Removes the memory range starting at <i>p</i> from an internal list of ranges
 to be scanned during a collection. If <i>p</i> is <b>null</b> or does not represent
 a value previously passed to addRange() then no operation is
 performed.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void* <i>p</i></td>
<td valign=top>A pointer to a valid memory address or to <b>null</b>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".GC.runFinalizers"></a>static void <a name="runFinalizers"></a><span class="ddoc_psymbol">runFinalizers</span>(in void[] <i>segment</i>);
</dt>
<dd>Runs any finalizer that is located in address range of the
 given code <i>segment</i>.  This is used before unloading shared
 libraries.  All matching objects which have a finalizer in this
 code <i>segment</i> are assumed to be dead, using them while or after
 calling this method has undefined behavior.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void[] <i>segment</i></td>
<td valign=top>address range of a code <i>segment</i>.</td></tr>
</table><p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Sean Kelly 2005 - 2009.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.numeric - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/numeric.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Phobos/StdNumeric" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.numeric</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/numeric.d -->
This module is a port of a growing fragment of the <span class="d_param"><a name="numeric"></a><span class="ddoc_psymbol">numeric</span></span>
header in Alexander Stepanov's <a href="http://sgi.com/tech/stl">Standard Template Library</a>, with a few additions.
<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br><a href="http://erdani.org">Andrei Alexandrescu</a>,
                   Don Clugston, Robert Jacques
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/numeric.d">std/numeric.d</a><p></p>

<dl><dt class="d_decl"><a name=".CustomFloatFlags"></a>enum <a name="CustomFloatFlags"></a><span class="ddoc_psymbol">CustomFloatFlags</span>: int;
</dt>
<dd>Format flags for CustomFloat.<p></p>

<dl><dt class="d_decl"><a name=".CustomFloatFlags.signed"></a><a name="signed"></a><span class="ddoc_psymbol">signed</span></dt>
<dd>Adds a sign bit to allow for <a name="signed"></a><span class="ddoc_psymbol">signed</span> numbers.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.storeNormalized"></a><a name="storeNormalized"></a><span class="ddoc_psymbol">storeNormalized</span></dt>
<dd>Store values in normalized form by default. The actual precision of the
 significand is extended by 1 bit by assuming an implicit leading bit of 1
 instead of 0. i.e. <span class="d_inlinecode">1.nnnn</span> instead of <span class="d_inlinecode">0.nnnn</span>.
 True for all <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=IEE754">IEE754</a> types<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.allowDenorm"></a><a name="allowDenorm"></a><span class="ddoc_psymbol">allowDenorm</span></dt>
<dd>Stores the significand in <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=IEEE754 denormalized">IEEE754 denormalized</a> form when the
 exponent is 0. Required to express the value 0.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.infinity"></a><a name="infinity"></a><span class="ddoc_psymbol">infinity</span></dt>
<dd>Allows the storage of <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=IEEE754 infinity">IEEE754 infinity</a> values.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.nan"></a><a name="nan"></a><span class="ddoc_psymbol">nan</span></dt>
<dd>Allows the storage of <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=IEEE754 Not a Number">IEEE754 Not a Number</a> values.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.probability"></a><a name="probability"></a><span class="ddoc_psymbol">probability</span></dt>
<dd>If set, select an exponent bias such that max_exp = 1.
 i.e. so that the maximum value is &gt;= 1.0 and &lt; 2.0.
 Ignored if the exponent bias is manually specified.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.negativeUnsigned"></a><a name="negativeUnsigned"></a><span class="ddoc_psymbol">negativeUnsigned</span></dt>
<dd>If set, unsigned custom floats are assumed to be negative.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.allowDenormZeroOnly"></a><a name="allowDenormZeroOnly"></a><span class="ddoc_psymbol">allowDenormZeroOnly</span></dt>
<dd>If set, 0 is the only allowed <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=IEEE754 denormalized">IEEE754 denormalized</a> number.
 Requires allowDenorm and storeNormalized.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.ieee"></a><a name="ieee"></a><span class="ddoc_psymbol">ieee</span></dt>
<dd>Include all of the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=IEEE754">IEEE754</a> options.<p></p>

</dd>
<dt class="d_decl"><a name=".CustomFloatFlags.none"></a><a name="none"></a><span class="ddoc_psymbol">none</span></dt>
<dd>Include <a name="none"></a><span class="ddoc_psymbol">none</span> of the above options.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".CustomFloat"></a>template <a name="CustomFloat"></a><span class="ddoc_psymbol">CustomFloat</span>(uint bits) if (bits == 8 || bits == 16 || bits == 32 || bits == 64 || bits == 80)<br><a name=".CustomFloat"></a>template <a name="CustomFloat"></a><span class="ddoc_psymbol">CustomFloat</span>(uint precision, uint exponentWidth, CustomFloatFlags flags = CustomFloatFlags.ieee) if (((flags &amp; flags.signed) + precision + exponentWidth) % 8 == 0 &amp;&amp; precision + exponentWidth &gt; 0)<br><a name=".CustomFloat"></a>struct <a name="CustomFloat"></a><span class="ddoc_psymbol">CustomFloat</span>(uint precision, uint exponentWidth, CustomFloatFlags flags, uint bias) if (((flags &amp; flags.signed) + precision + exponentWidth) % 8 == 0 &amp;&amp; precision + exponentWidth &gt; 0);
</dt>
<dd>Allows user code to define custom floating-point formats. These formats are
 for storage only; all operations on them are performed by first implicitly
 extracting them to <span class="d_inlinecode">real</span> first. After the operation is completed the
 result can be stored in a custom floating-point value via assignment.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Define a 16-bit floating point values
</span><span class="d_psymbol">CustomFloat</span>!16                                x;     <span class="d_comment">// Using the number of bits
</span><span class="d_psymbol">CustomFloat</span>!(10, 5)                           y;     <span class="d_comment">// Using the precision and exponent width
</span><span class="d_psymbol">CustomFloat</span>!(10, 5,CustomFloatFlags.ieee)     z;     <span class="d_comment">// Using the precision, exponent width and format flags
</span><span class="d_psymbol">CustomFloat</span>!(10, 5,CustomFloatFlags.ieee, 15) w;     <span class="d_comment">// Using the precision, exponent width, format flags and exponent offset bias
</span>
<span class="d_comment">// Use the 16-bit floats mostly like normal numbers
</span>w = x*y - 1;
writeln(w);

<span class="d_comment">// Functions calls require conversion
</span>z = sin(+x)           + cos(+y);                     <span class="d_comment">// Use unary plus to concisely convert to a real
</span>z = sin(x.re)         + cos(y.re);                   <span class="d_comment">// Or use the .re property to convert to a real
</span>z = sin(x.get!<span class="d_keyword">float</span>)  + cos(y.get!<span class="d_keyword">float</span>);            <span class="d_comment">// Or use get!T
</span>z = sin(<span class="d_keyword">cast</span>(<span class="d_keyword">float</span>)x) + cos(<span class="d_keyword">cast</span>(<span class="d_keyword">float</span>)y);           <span class="d_comment">// Or use cast(T) to explicitly convert
</span>
<span class="d_comment">// Define a 8-bit custom float for storing probabilities
</span><span class="d_keyword">alias</span> Probability = <span class="d_psymbol">CustomFloat</span>!(4, 4, CustomFloatFlags.ieee^CustomFloatFlags.probability^CustomFloatFlags.signed );
<span class="d_keyword">auto</span> p = Probability(0.5);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".FPTemporary"></a>template <a name="FPTemporary"></a><span class="ddoc_psymbol">FPTemporary</span>(F) if (isFloatingPoint!F)</dt>
<dd>Defines the fastest type to use when storing temporaries of a
calculation intended to ultimately yield a result of type <span class="d_inlinecode">F</span>
(where <span class="d_inlinecode">F</span> must be one of <span class="d_inlinecode">float</span>, <span class="d_inlinecode">double</span>, or <span class="d_inlinecode">real</span>). When doing a multi-step computation, you may want to store
intermediate results as <span class="d_inlinecode"><a name="FPTemporary"></a><span class="ddoc_psymbol">FPTemporary</span>!F</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Average numbers in an array
</span><span class="d_keyword">double</span> avg(<span class="d_keyword">in</span> <span class="d_keyword">double</span>[] a)
{
    <span class="d_keyword">if</span> (a.length == 0) <span class="d_keyword">return</span> 0;
    <span class="d_psymbol">FPTemporary</span>!<span class="d_keyword">double</span> result = 0;
    <span class="d_keyword">foreach</span> (e; a) result += e;
    <span class="d_keyword">return</span> result / a.length;
}
</pre>
<p></p>

The necessity of <span class="d_inlinecode"><a name="FPTemporary"></a><span class="ddoc_psymbol">FPTemporary</span></span> stems from the optimized
floating-point operations and registers present in virtually all
processors. When adding numbers in the example above, the addition may
in fact be done in <span class="d_inlinecode">real</span> precision internally. In that case,
storing the intermediate <span class="d_inlinecode">result</span> in <span class="d_inlinecode">double format</span> is not only
less precise, it is also (surprisingly) slower, because a conversion
from <span class="d_inlinecode">real</span> to <span class="d_inlinecode">double</span> is performed every pass through the
loop. This being a lose-lose situation, <span class="d_inlinecode"><a name="FPTemporary"></a><span class="ddoc_psymbol">FPTemporary</span>!F</span> has been
defined as the <i>fastest</i> type to use for calculations at precision
<span class="d_inlinecode">F</span>. There is no need to define a type for the <i>most accurate</i>
calculations, as that is always <span class="d_inlinecode">real</span>.
<p></p>

Finally, there is no guarantee that using <span class="d_inlinecode"><a name="FPTemporary"></a><span class="ddoc_psymbol">FPTemporary</span>!F</span> will
always be fastest, as the speed of floating-point calculations depends
on very many factors.<p></p>

</dd>
<dt class="d_decl"><a name=".secantMethod"></a>template <a name="secantMethod"></a><span class="ddoc_psymbol">secantMethod</span>(alias fun)</dt>
<dd>Implements the <a href="http://tinyurl.com/2zb9yr">secant method</a> for finding a
root of the function <span class="d_inlinecode">fun</span> starting from points <span class="d_inlinecode">[xn_1, x_n]</span>
(ideally close to the root). <span class="d_inlinecode">Num</span> may be <span class="d_inlinecode">float</span>, <span class="d_inlinecode">double</span>,
or <span class="d_inlinecode">real</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">float</span> f(<span class="d_keyword">float</span> x) {
    <span class="d_keyword">return</span> cos(x) - x*x*x;
}
<span class="d_keyword">auto</span> x = <span class="d_psymbol">secantMethod</span>!(f)(0f, 1f);
<span class="d_keyword">assert</span>(approxEqual(x, 0.865474));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".findRoot"></a>T <a name="findRoot"></a><span class="ddoc_psymbol">findRoot</span>(T, R)(scope R delegate(T) <i>f</i>, T <i>a</i>, T <i>b</i>);
</dt>
<dd>Find a real root of a real function f(x) via bracketing.
<p></p>
Given a function <span class="d_inlinecode">f</span> and a range <span class="d_inlinecode">[a..b]</span> such that <span class="d_inlinecode">f(a)</span>
 and <span class="d_inlinecode">f(b)</span> have opposite signs, returns the value of <span class="d_inlinecode">x</span> in
 the range which is closest to a root of <span class="d_inlinecode">f(x)</span>.  If <span class="d_inlinecode">f(x)</span>
 has more than one root in the range, one will be chosen
 arbitrarily.  If <span class="d_inlinecode">f(x)</span> returns NaN, NaN will be returned;
 otherwise, this algorithm is guaranteed to succeed.
<p></p>

 Uses an algorithm based on TOMS748, which uses inverse cubic
 interpolation whenever possible, otherwise reverting to parabolic
 or secant interpolation. Compared to TOMS748, this implementation
 improves worst-case performance by a factor of more than 100, and
 typical performance by a factor of 2. For 80-bit reals, most
 problems require 8 to 15 calls to <span class="d_inlinecode">f(x)</span> to achieve full machine
 precision. The worst-case performance (pathological cases) is
 approximately twice the number of bits.

<p></p>
<b>References:</b><br>
"On Enclosing Simple Roots of Nonlinear Equations",
 G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,
 pp733-744 (1993).  Fortran code available from <a href="http:// www.netlib.org">www.netlib.org</a> as algorithm TOMS478.<p></p>

</dd>
<dt class="d_decl"><a name=".findRoot"></a>Tuple!(T, T, R, R) <a name="findRoot"></a><span class="ddoc_psymbol">findRoot</span>(T, R)(scope R delegate(T) <i>f</i>, T <i>ax</i>, T <i>bx</i>, R <i>fax</i>, R <i>fbx</i>, scope bool delegate(T lo, T hi) <i>tolerance</i>);
</dt>
<dd>Find root of a real function f(x) by bracketing, allowing the
 termination condition to be specified.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>R delegate(T) f</td>
<td valign=top>Function to be analyzed</td></tr>
<tr><td valign=top>T ax</td>
<td valign=top>Left bound of initial range of <span class="d_inlinecode">f</span> known to contain the
 root.</td></tr>
<tr><td valign=top>T bx</td>
<td valign=top>Right bound of initial range of <span class="d_inlinecode">f</span> known to contain the
 root.</td></tr>
<tr><td valign=top>R fax</td>
<td valign=top>Value of <span class="d_inlinecode">f(ax)</span>.</td></tr>
<tr><td valign=top>R fbx</td>
<td valign=top>Value of <span class="d_inlinecode">f(bx)</span>. (<span class="d_inlinecode">f(ax)</span> and <span class="d_inlinecode">f(bx)</span> are commonly
 known in advance.)</td></tr>
<tr><td valign=top>bool delegate(T lo, T hi) tolerance</td>
<td valign=top>Defines an early termination condition. Receives the
             current upper and lower bounds on the root. The
             delegate must return <span class="d_inlinecode"><b>true</b></span> when these bounds are
             acceptable. If this function always returns <span class="d_inlinecode"><b>false</b></span>,
             full machine precision will be achieved.</td></tr>
</table><p></p>
<b>Returns:</b><br>A tuple consisting of two ranges. The first two elements are the
 range (in <span class="d_inlinecode">x</span>) of the root, while the second pair of elements
 are the corresponding function values at those points. If an exact
 root was found, both of the first two elements will contain the
 root, and the second pair of elements will be 0.<p></p>

</dd>
<dt class="d_decl"><a name=".euclideanDistance"></a>CommonType!(ElementType!Range1, ElementType!Range2) <a name="euclideanDistance"></a><span class="ddoc_psymbol">euclideanDistance</span>(Range1, Range2)(Range1 <i>a</i>, Range2 <i>b</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2);
<br><a name=".euclideanDistance"></a>CommonType!(ElementType!Range1, ElementType!Range2) <a name="euclideanDistance"></a><span class="ddoc_psymbol">euclideanDistance</span>(Range1, Range2, F)(Range1 <i>a</i>, Range2 <i>b</i>, F <i>limit</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2);
</dt>
<dd>Computes <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Euclidean distance">Euclidean distance</a> between input ranges <span class="d_inlinecode">a</span> and
<span class="d_inlinecode">b</span>. The two ranges must have the same length. The three-parameter
version stops computation as soon as the distance is greater than or
equal to <span class="d_inlinecode">limit</span> (this is useful to save computation if a small
distance is sought).<p></p>

</dd>
<dt class="d_decl"><a name=".dotProduct"></a>CommonType!(ElementType!Range1, ElementType!Range2) <a name="dotProduct"></a><span class="ddoc_psymbol">dotProduct</span>(Range1, Range2)(Range1 <i>a</i>, Range2 <i>b</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; !(isArray!Range1 &amp;&amp; isArray!Range2));
<br><a name=".dotProduct"></a>Unqual!(CommonType!(F1, F2)) <a name="dotProduct"></a><span class="ddoc_psymbol">dotProduct</span>(F1, F2)(in F1[] <i>avector</i>, in F2[] <i>bvector</i>);
</dt>
<dd>Computes the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=dot product">dot product</a> of input ranges <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>. The two ranges must have the same length. If both ranges define
length, the check is done once; otherwise, it is done at each
iteration.<p></p>

</dd>
<dt class="d_decl"><a name=".cosineSimilarity"></a>CommonType!(ElementType!Range1, ElementType!Range2) <a name="cosineSimilarity"></a><span class="ddoc_psymbol">cosineSimilarity</span>(Range1, Range2)(Range1 <i>a</i>, Range2 <i>b</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2);
</dt>
<dd>Computes the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=cosine similarity">cosine similarity</a> of input ranges <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>. The two ranges must have the same length. If both ranges define
length, the check is done once; otherwise, it is done at each
iteration. If either range has all-zero elements, return 0.<p></p>

</dd>
<dt class="d_decl"><a name=".normalize"></a>bool <a name="normalize"></a><span class="ddoc_psymbol">normalize</span>(R)(R <i>range</i>, ElementType!R <i>sum</i> = 1) if (isForwardRange!R);
</dt>
<dd>Normalizes values in <span class="d_inlinecode">range</span> by multiplying each element with a
number chosen such that values sum up to <span class="d_inlinecode">sum</span>. If elements in <span class="d_inlinecode">range</span> sum to zero, assigns <span class="d_inlinecode">sum / range.length</span> to
all. Normalization makes sense only if all elements in <span class="d_inlinecode">range</span> are
positive. <span class="d_inlinecode"><a name="normalize"></a><span class="ddoc_psymbol">normalize</span></span> assumes that is the case without checking it.
<p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> if normalization completed normally, <span class="d_inlinecode"><b>false</b></span> if
all elements in <span class="d_inlinecode">range</span> were zero or if <span class="d_inlinecode">range</span> is empty.<p></p>

</dd>
<dt class="d_decl"><a name=".entropy"></a>ElementType!Range <a name="entropy"></a><span class="ddoc_psymbol">entropy</span>(Range)(Range <i>r</i>) if (isInputRange!Range);
<br><a name=".entropy"></a>ElementType!Range <a name="entropy"></a><span class="ddoc_psymbol">entropy</span>(Range, F)(Range <i>r</i>, F <i>max</i>) if (isInputRange!Range &amp;&amp; !is(CommonType!(ElementType!Range, F) == void));
</dt>
<dd>Computes <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=entropy">entropy</a> of input range <span class="d_inlinecode">r</span> in bits. This
function assumes (without checking) that the values in <span class="d_inlinecode">r</span> are all
in <span class="d_inlinecode">[0, 1]</span>. For the <a name="entropy"></a><span class="ddoc_psymbol">entropy</span> to be meaningful, often <span class="d_inlinecode">r</span> should
be normalized too (i.e., its values should sum to 1). The
two-parameter version stops evaluating as soon as the intermediate
result is greater than or equal to <span class="d_inlinecode">max</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".kullbackLeiblerDivergence"></a>CommonType!(ElementType!Range1, ElementType!Range2) <a name="kullbackLeiblerDivergence"></a><span class="ddoc_psymbol">kullbackLeiblerDivergence</span>(Range1, Range2)(Range1 <i>a</i>, Range2 <i>b</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2);
</dt>
<dd>Computes the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Kullback-Leibler divergence">Kullback-Leibler divergence</a> between input ranges
<span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>, which is the sum <span class="d_inlinecode">ai * log(ai / bi)</span>. The base
of logarithm is 2. The ranges are assumed to contain elements in <span class="d_inlinecode">[0, 1]</span>. Usually the ranges are normalized probability distributions,
but this is not required or checked by <span class="d_inlinecode"><a name="kullbackLeiblerDivergence"></a><span class="ddoc_psymbol">kullbackLeiblerDivergence</span></span>. If any element <span class="d_inlinecode">bi</span> is zero and the
corresponding element <span class="d_inlinecode">ai</span> nonzero, returns infinity. (Otherwise,
if <span class="d_inlinecode">ai == 0 &amp;&amp; bi == 0</span>, the term <span class="d_inlinecode">ai * log(ai / bi)</span> is
considered zero.) If the inputs are normalized, the result is
positive.<p></p>

</dd>
<dt class="d_decl"><a name=".jensenShannonDivergence"></a>CommonType!(ElementType!Range1, ElementType!Range2) <a name="jensenShannonDivergence"></a><span class="ddoc_psymbol">jensenShannonDivergence</span>(Range1, Range2)(Range1 <i>a</i>, Range2 <i>b</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(CommonType!(ElementType!Range1, ElementType!Range2)));
<br><a name=".jensenShannonDivergence"></a>CommonType!(ElementType!Range1, ElementType!Range2) <a name="jensenShannonDivergence"></a><span class="ddoc_psymbol">jensenShannonDivergence</span>(Range1, Range2, F)(Range1 <i>a</i>, Range2 <i>b</i>, F <i>limit</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(CommonType!(ElementType!Range1, ElementType!Range2).init &gt;= F.init) : bool));
</dt>
<dd>Computes the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Jensen-Shannon divergence">Jensen-Shannon divergence</a> between <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>, which is the sum <span class="d_inlinecode">(ai * log(2 * ai / (ai + bi)) + bi * log(2 *
bi / (ai + bi))) / 2</span>. The base of logarithm is 2. The ranges are
assumed to contain elements in <span class="d_inlinecode">[0, 1]</span>. Usually the ranges are
normalized probability distributions, but this is not required or
checked by <span class="d_inlinecode"><a name="jensenShannonDivergence"></a><span class="ddoc_psymbol">jensenShannonDivergence</span></span>. If the inputs are normalized,
the result is bounded within <span class="d_inlinecode">[0, 1]</span>. The three-parameter version
stops evaluations as soon as the intermediate result is greater than
or equal to <span class="d_inlinecode">limit</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".gapWeightedSimilarity"></a>F <a name="gapWeightedSimilarity"></a><span class="ddoc_psymbol">gapWeightedSimilarity</span>(alias comp = "a == b", R1, R2, F)(R1 <i>s</i>, R2 <i>t</i>, F <i>lambda</i>) if (isRandomAccessRange!R1 &amp;&amp; hasLength!R1 &amp;&amp; isRandomAccessRange!R2 &amp;&amp; hasLength!R2);
</dt>
<dd>The so-called "all-lengths gap-weighted string kernel" computes a
similarity measure between <span class="d_inlinecode">s</span> and <span class="d_inlinecode">t</span> based on all of their
common subsequences of all lengths. Gapped subsequences are also
included.
<p></p>
To understand what <span class="d_inlinecode"><a name="gapWeightedSimilarity"></a><span class="ddoc_psymbol">gapWeightedSimilarity</span>(s, t, lambda)</span> computes,
consider first the case <span class="d_inlinecode">lambda = 1</span> and the strings <span class="d_inlinecode">s =
["Hello", "brave", "new", "world"]</span> and <span class="d_inlinecode">t = ["Hello", "new",
"world"]</span>. In that case, <span class="d_inlinecode"><a name="gapWeightedSimilarity"></a><span class="ddoc_psymbol">gapWeightedSimilarity</span></span> counts the
following matches:
<p></p>

<ol><li>three matches of length 1, namely <span class="d_inlinecode">"Hello"</span>, <span class="d_inlinecode">"new"</span>,
and <span class="d_inlinecode">"world"</span>;</li> <li>three matches of length 2, namely (<span class="d_inlinecode">"Hello", "new"</span>), (<span class="d_inlinecode">"Hello", "world"</span>), and (<span class="d_inlinecode">"new", "world"</span>);</li>
<li>one match of length 3, namely (<span class="d_inlinecode">"Hello", "new", "world"</span>).</li></ol>
<p></p>

The call <span class="d_inlinecode"><a name="gapWeightedSimilarity"></a><span class="ddoc_psymbol">gapWeightedSimilarity</span>(s, t, 1)</span> simply counts all of
these matches and adds them up, returning 7.
<p></p>

<pre class="d_code">string[] s = [<span class="d_string">"Hello"</span>, <span class="d_string">"brave"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
string[] t = [<span class="d_string">"Hello"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
<span class="d_keyword">assert</span>(<span class="d_psymbol">gapWeightedSimilarity</span>(s, t, 1) == 7);
</pre>
<p></p>

Note how the gaps in matching are simply ignored, for example (<span class="d_inlinecode">"Hello", "new"</span>) is deemed as good a match as (<span class="d_inlinecode">"new",
"world"</span>). This may be too permissive for some applications. To
eliminate gapped matches entirely, use <span class="d_inlinecode">lambda = 0</span>:
<p></p>

<pre class="d_code">string[] s = [<span class="d_string">"Hello"</span>, <span class="d_string">"brave"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
string[] t = [<span class="d_string">"Hello"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
<span class="d_keyword">assert</span>(<span class="d_psymbol">gapWeightedSimilarity</span>(s, t, 0) == 4);
</pre>
<p></p>

The call above eliminated the gapped matches (<span class="d_inlinecode">"Hello", "new"</span>),
(<span class="d_inlinecode">"Hello", "world"</span>), and (<span class="d_inlinecode">"Hello", "new", "world"</span>) from the
tally. That leaves only 4 matches.
<p></p>

The most interesting case is when gapped matches still participate in
the result, but not as strongly as ungapped matches. The result will
be a smooth, fine-grained similarity measure between the input
strings. This is where values of <span class="d_inlinecode">lambda</span> between 0 and 1 enter
into play: gapped matches are <i>exponentially penalized with the
number of gaps</i> with base <span class="d_inlinecode">lambda</span>. This means that an ungapped
match adds 1 to the return value; a match with one gap in either
string adds <span class="d_inlinecode">lambda</span> to the return value; ...; a match with a total
of <span class="d_inlinecode">n</span> gaps in both strings adds <span class="d_inlinecode">pow(lambda, n)</span> to the return
value. In the example above, we have 4 matches without gaps, 2 matches
with one gap, and 1 match with three gaps. The latter match is (<span class="d_inlinecode">"Hello", "world"</span>), which has two gaps in the first string and one gap
in the second string, totaling to three gaps. Summing these up we get
<span class="d_inlinecode">4 + 2 * lambda + pow(lambda, 3)</span>.
<p></p>

<pre class="d_code">string[] s = [<span class="d_string">"Hello"</span>, <span class="d_string">"brave"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
string[] t = [<span class="d_string">"Hello"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
<span class="d_keyword">assert</span>(<span class="d_psymbol">gapWeightedSimilarity</span>(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);
</pre>
<p></p>

<span class="d_inlinecode"><a name="gapWeightedSimilarity"></a><span class="ddoc_psymbol">gapWeightedSimilarity</span></span> is useful wherever a smooth similarity
measure between sequences allowing for approximate matches is
needed. The examples above are given with words, but any sequences
with elements comparable for equality are allowed, e.g. characters or
numbers. <span class="d_inlinecode"><a name="gapWeightedSimilarity"></a><span class="ddoc_psymbol">gapWeightedSimilarity</span></span> uses a highly optimized dynamic
programming implementation that needs <span class="d_inlinecode">16 * min(s.length,
t.length)</span> extra bytes of memory and <b><i>&Omicron;</i>(</b><span class="d_inlinecode">s.length * t.length</span><b><i>)</i></b> time
to complete.<p></p>

</dd>
<dt class="d_decl"><a name=".gapWeightedSimilarityNormalized"></a>Select!(isFloatingPoint!F, F, double) <a name="gapWeightedSimilarityNormalized"></a><span class="ddoc_psymbol">gapWeightedSimilarityNormalized</span>(alias comp = "a == b", R1, R2, F)(R1 <i>s</i>, R2 <i>t</i>, F <i>lambda</i>, F <i>sSelfSim</i> = F.init, F <i>tSelfSim</i> = F.init) if (isRandomAccessRange!R1 &amp;&amp; hasLength!R1 &amp;&amp; isRandomAccessRange!R2 &amp;&amp; hasLength!R2);
</dt>
<dd>The similarity per <span class="d_inlinecode">gapWeightedSimilarity</span> has an issue in that it
grows with the lengths of the two strings, even though the strings are
not actually very similar. For example, the range <span class="d_inlinecode">["Hello",
"world"]</span> is increasingly similar with the range <span class="d_inlinecode">["Hello",
"world", "world", "world",...]</span> as more instances of <span class="d_inlinecode">"world"</span> are
appended. To prevent that, <span class="d_inlinecode"><a name="gapWeightedSimilarityNormalized"></a><span class="ddoc_psymbol">gapWeightedSimilarityNormalized</span></span>
computes a normalized version of the similarity that is computed as
<span class="d_inlinecode">gapWeightedSimilarity(s, t, lambda) /
sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,
lambda))</span>. The function <span class="d_inlinecode"><a name="gapWeightedSimilarityNormalized"></a><span class="ddoc_psymbol">gapWeightedSimilarityNormalized</span></span> (a
so-called normalized kernel) is bounded in <span class="d_inlinecode">[0, 1]</span>, reaches <span class="d_inlinecode">0</span>
only for ranges that don't match in any position, and <span class="d_inlinecode">1</span> only for
identical ranges.
<p></p>
<b>Example:</b><br>
<pre class="d_code">string[] s = [<span class="d_string">"Hello"</span>, <span class="d_string">"brave"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
string[] t = [<span class="d_string">"Hello"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
<span class="d_keyword">assert</span>(gapWeightedSimilarity(s, s, 1) == 15);
<span class="d_keyword">assert</span>(gapWeightedSimilarity(t, t, 1) == 7);
<span class="d_keyword">assert</span>(gapWeightedSimilarity(s, t, 1) == 7);
<span class="d_keyword">assert</span>(<span class="d_psymbol">gapWeightedSimilarityNormalized</span>(s, t, 1) == 7. / sqrt(15. * 7));
</pre>
<p></p>

The optional parameters <span class="d_inlinecode">sSelfSim</span> and <span class="d_inlinecode">tSelfSim</span> are meant for
avoiding duplicate computation. Many applications may have already
computed <span class="d_inlinecode">gapWeightedSimilarity(s, s, lambda)</span> and/or <span class="d_inlinecode">gapWeightedSimilarity(t, t, lambda)</span>. In that case, they can be passed
as <span class="d_inlinecode">sSelfSim</span> and <span class="d_inlinecode">tSelfSim</span>, respectively.<p></p>

</dd>
<dt class="d_decl"><a name=".GapWeightedSimilarityIncremental"></a>struct <a name="GapWeightedSimilarityIncremental"></a><span class="ddoc_psymbol">GapWeightedSimilarityIncremental</span>(Range, F = double) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range);
<br><a name=".gapWeightedSimilarityIncremental"></a>GapWeightedSimilarityIncremental!(R, F) <a name="gapWeightedSimilarityIncremental"></a><span class="ddoc_psymbol">gapWeightedSimilarityIncremental</span>(R, F)(R <i>r1</i>, R <i>r2</i>, F <i>penalty</i>);
</dt>
<dd>Similar to <span class="d_inlinecode">gapWeightedSimilarity</span>, just works in an incremental
manner by first revealing the matches of length 1, then gapped matches
of length 2, and so on. The memory requirement is <b><i>&Omicron;</i>(</b><span class="d_inlinecode">s.length *
t.length</span><b><i>)</i></b>. The time complexity is <b><i>&Omicron;</i>(</b><span class="d_inlinecode">s.length * t.length</span><b><i>)</i></b> time
for computing each step. Continuing on the previous example:
<p></p>
<pre class="d_code">string[] s = [<span class="d_string">"Hello"</span>, <span class="d_string">"brave"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
string[] t = [<span class="d_string">"Hello"</span>, <span class="d_string">"new"</span>, <span class="d_string">"world"</span>];
<span class="d_keyword">auto</span> simIter = gapWeightedSimilarityIncremental(s, t, 1);
<span class="d_keyword">assert</span>(simIter.front == 3); <span class="d_comment">// three 1-length matches
</span>simIter.popFront();
<span class="d_keyword">assert</span>(simIter.front == 3); <span class="d_comment">// three 2-length matches
</span>simIter.popFront();
<span class="d_keyword">assert</span>(simIter.front == 1); <span class="d_comment">// one 3-length match
</span>simIter.popFront();
<span class="d_keyword">assert</span>(simIter.empty);     <span class="d_comment">// no more match
</span></pre>
<p></p>

The implementation is based on the pseudocode in Fig. 4 of the paper
<a href="http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf">"Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets"</a>
by Rousu et al., with additional algorithmic and systems-level
optimizations.<p></p>

<dl><dt class="d_decl"><a name=".GapWeightedSimilarityIncremental.this"></a>this(Range <i>s</i>, Range <i>t</i>, F <i>lambda</i>);
</dt>
<dd>Constructs an object given two ranges <span class="d_inlinecode"><i>s</i></span> and <span class="d_inlinecode"><i>t</i></span> and a penalty
<span class="d_inlinecode"><i>lambda</i></span>. Constructor completes in <b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>s</i>.length * <i>t</i>.length</span><b><i>)</i></b>
time and computes all matches of length 1.<p></p>

</dd>
<dt class="d_decl"><a name=".GapWeightedSimilarityIncremental.opSlice"></a>ref GapWeightedSimilarityIncremental <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Returns <span class="d_inlinecode">this</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".GapWeightedSimilarityIncremental.popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd>Computes the match of the <a name="popFront"></a><span class="ddoc_psymbol">popFront</span> length. Completes in <b><i>&Omicron;</i>(</b><span class="d_inlinecode">s.length *
t.length</span><b><i>)</i></b> time.<p></p>

</dd>
<dt class="d_decl"><a name=".GapWeightedSimilarityIncremental.front"></a>@property F <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd>Returns the gapped similarity at the current match length (initially
1, grows with each call to <span class="d_inlinecode">popFront</span>).<p></p>

</dd>
<dt class="d_decl"><a name=".GapWeightedSimilarityIncremental.empty"></a>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Returns whether there are more matches.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".gcd"></a>T <a name="gcd"></a><span class="ddoc_psymbol">gcd</span>(T)(T <i>a</i>, T <i>b</i>);
</dt>
<dd>Computes the greatest common divisor of <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span> by using
Euclid's algorithm.<p></p>

</dd>
<dt class="d_decl"><a name=".Fft"></a>class <a name="Fft"></a><span class="ddoc_psymbol">Fft</span>;
</dt>
<dd>A class for performing fast Fourier transforms of power of two sizes.
 This class encapsulates a large amount of state that is reusable when
 performing multiple FFTs of sizes smaller than or equal to that specified
 in the constructor.  This results in substantial speedups when performing
 multiple FFTs with a known maximum size.  However,
 a free function API is provided for convenience if you need to perform a
 one-off FFT.
<p></p>
<b>References:</b><br>
<a href="http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm">en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm</a><p></p>

<dl><dt class="d_decl"><a name=".Fft.this"></a>this(size_t <i>size</i>);
</dt>
<dd>Create an <span class="d_inlinecode">Fft</span> object for computing fast Fourier transforms of
 power of two sizes of <span class="d_inlinecode"><i>size</i></span> or smaller.  <span class="d_inlinecode"><i>size</i></span> must be a
 power of two.<p></p>

</dd>
<dt class="d_decl"><a name=".Fft.fft"></a>const Complex!F[] <a name="fft"></a><span class="ddoc_psymbol">fft</span>(F = double, R)(R <i>range</i>) if (isFloatingPoint!F &amp;&amp; isRandomAccessRange!R);
</dt>
<dd>Compute the Fourier transform of range using the <b><i>&Omicron;</i>(</b><span class="d_inlinecode">N log N</span><b><i>)</i></b>
 Cooley-Tukey Algorithm.  <span class="d_inlinecode">range</span> must be a random-access range with
 slicing and a length equal to <span class="d_inlinecode">size</span> as provided at the construction of
 this object.  The contents of range can be either  numeric types,
 which will be interpreted as pure real values, or complex types with
 properties or members <span class="d_inlinecode">.re</span> and <span class="d_inlinecode">.im</span> that can be read.
<p></p>
<b>Note:</b><br>
Pure real FFTs are automatically detected and the relevant
        optimizations are performed.

<p></p>
<b>Returns:</b><br>An array of complex numbers representing the transformed data in
           the frequency domain.

<p></p>
<b>Conventions:</b><br>
The exponent is negative and the factor is one,
              i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].<p></p>

</dd>
<dt class="d_decl"><a name=".Fft.fft"></a>const void <a name="fft"></a><span class="ddoc_psymbol">fft</span>(Ret, R)(R <i>range</i>, Ret <i>buf</i>) if (isRandomAccessRange!Ret &amp;&amp; isComplexLike!(ElementType!Ret) &amp;&amp; hasSlicing!Ret);
</dt>
<dd>Same as the overload, but allows for the results to be stored in a user-
 provided buffer.  The buffer must be of the same length as range, must be
 a random-access range, must have slicing, and must contain elements that are
 complex-like.  This means that they must have a .re and a .im member or
 property that can be both read and written and are floating point numbers.<p></p>

</dd>
<dt class="d_decl"><a name=".Fft.inverseFft"></a>const Complex!F[] <a name="inverseFft"></a><span class="ddoc_psymbol">inverseFft</span>(F = double, R)(R <i>range</i>) if (isRandomAccessRange!R &amp;&amp; isComplexLike!(ElementType!R) &amp;&amp; isFloatingPoint!F);
</dt>
<dd>Computes the inverse Fourier transform of a range.  The range must be a
 random access range with slicing, have a length equal to the size
 provided at construction of this object, and contain elements that are
 either of type std.complex.Complex or have essentially
 the same compile-time interface.
<p></p>
<b>Returns:</b><br>The time-domain signal.

<p></p>
<b>Conventions:</b><br>
The exponent is positive and the factor is 1/N, i.e.,
              output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].<p></p>

</dd>
<dt class="d_decl"><a name=".Fft.inverseFft"></a>const void <a name="inverseFft"></a><span class="ddoc_psymbol">inverseFft</span>(Ret, R)(R <i>range</i>, Ret <i>buf</i>) if (isRandomAccessRange!Ret &amp;&amp; isComplexLike!(ElementType!Ret) &amp;&amp; hasSlicing!Ret);
</dt>
<dd>Inverse FFT that allows a user-supplied buffer to be provided.  The buffer
 must be a random access range with slicing, and its elements
 must be some complex-like type.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".fft"></a>Complex!F[] <a name="fft"></a><span class="ddoc_psymbol">fft</span>(F = double, R)(R <i>range</i>);
<br><a name=".fft"></a>void <a name="fft"></a><span class="ddoc_psymbol">fft</span>(Ret, R)(R <i>range</i>, Ret <i>buf</i>);
<br><a name=".inverseFft"></a>Complex!F[] <a name="inverseFft"></a><span class="ddoc_psymbol">inverseFft</span>(F = double, R)(R <i>range</i>);
<br><a name=".inverseFft"></a>void <a name="inverseFft"></a><span class="ddoc_psymbol">inverseFft</span>(Ret, R)(R <i>range</i>, Ret <i>buf</i>);
</dt>
<dd>Convenience functions that create an <span class="d_inlinecode">Fft</span> object, run the FFT or inverse
 FFT and return the result.  Useful for one-off FFTs.
<p></p>
<b>Note:</b><br>
In addition to convenience, these functions are slightly more
        efficient than manually creating an Fft object for a single use,
        as the Fft object is deterministically destroyed before these
        functions return.<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Andrei Alexandrescu 2008 - 2009.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.csv - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/csv.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.csv</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/csv.d -->
Implements functionality to read Comma Separated Values and its variants
 from a input range of <span class="d_inlinecode">dchar</span>.
<p></p>
Comma Separated Values provide a simple means to transfer and store
 tabular data. It has been common for programs to use their own
 variant of the CSV format. This parser will loosely follow the
 <a href="http://tools.ietf.org/html/rfc4180">RFC-4180</a>. CSV input should adhered
 to the following criteria, differences from RFC-4180 in parentheses.
<p></p>

 <ul>     <li>A record is separated by a new line (CRLF,LF,CR)</li>
     <li>A final record may end with a new line</li>
     <li>A header may be provided as the first record in input</li>
     <li>A record has fields separated by a comma (customizable)</li>
     <li>A field containing new lines, commas, or double quotes
          should be enclosed in double quotes (customizable)</li>
     <li>Double quotes in a field are escaped with a double quote</li>
     <li>Each record should contain the same number of fields</li>
   </ul>

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">import</span> std.algorithm;
<span class="d_keyword">import</span> std.array;
<span class="d_keyword">import</span> std.<span class="d_psymbol">csv</span>;
<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.typecons;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> text = <span class="d_string">"Joe,Carpenter,300000\nFred,Blacksmith,400000\r\n"</span>;

    <span class="d_keyword">foreach</span>(record; csvReader!(Tuple!(string,string,<span class="d_keyword">int</span>))(text))
    {
        writefln(<span class="d_string">"%s works as a %s and earns $%d per year"</span>,
                 record[0], record[1], record[2]);
    }
}
</pre>
<p></p>

 When an input contains a header the <span class="d_inlinecode">Contents</span> can be specified as an
 associative array. Passing <b>null</b> to signify that a header is present.
<p></p>

<pre class="d_code"><span class="d_keyword">auto</span> text = <span class="d_string">"Name,Occupation,Salary\r"</span>
    <span class="d_string">"Joe,Carpenter,300000\nFred,Blacksmith,400000\r\n"</span>;

<span class="d_keyword">foreach</span>(record; csvReader!(string[string])
        (text, <span class="d_keyword">null</span>))
{
    writefln(<span class="d_string">"%s works as a %s and earns $%s per year."</span>,
             record[<span class="d_string">"Name"</span>], record[<span class="d_string">"Occupation"</span>],
             record[<span class="d_string">"Salary"</span>]);
}
</pre>
<p></p>

 This module allows content to be iterated by record stored in a struct,
 class, associative array, or as a range of fields. Upon detection of an
 error an CSVException is thrown (can be disabled). csvNextToken has been
 made public to allow for attempted recovery.
<p></p>

 Disabling exceptions will lift many restrictions specified above. A quote
 can appear in a field if the field was not quoted. If in a quoted field any
 quote by itself, not at the end of a field, will end processing for that
 field. The field is ended when there is no input, even if the quote was not
 closed.

<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/Comma-separated_values">Wikipedia
      Comma-separated values</a>

<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br>Jesse Phillips
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/csv.d">std/csv.d</a><p></p>

<dl><dt class="d_decl"><a name=".CSVException"></a>class <a name="CSVException"></a><span class="ddoc_psymbol">CSVException</span>: <u>object.Exception</u>;
</dt>
<dd>Exception containing the row and column for when an exception was thrown.
<p></p>
Numbering of both row and col start at one and corresponds to the location
 in the file rather than any specified header. Special consideration should
 be made when there is failure to match the header see <a href="# HeaderMismatchException"><span class="d_inlinecode"> HeaderMismatchException</span></a> for details.
<p></p>

 When performing type conversions, <a href="std_ConvException.html#ConvException"><span class="d_inlinecode">std.ConvException.ConvException</span></a> is stored in the <span class="d_inlinecode"> next</span> field.<p></p>

<dl><dt class="d_decl"><a name=".CSVException.row"></a>size_t <a name="row"></a><span class="ddoc_psymbol">row</span>;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".CSVException.col"></a>size_t <a name="col"></a><span class="ddoc_psymbol">col</span>;
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".IncompleteCellException"></a>class <a name="IncompleteCellException"></a><span class="ddoc_psymbol">IncompleteCellException</span>: <u>std.csv.CSVException</u>;
</dt>
<dd>Exception thrown when a Token is identified to not be completed: a quote is
 found in an unquoted field, data continues after a closing quote, or the
 quoted field was not closed before data was empty.<p></p>

<dl><dt class="d_decl"><a name=".IncompleteCellException.partialData"></a>dstring <a name="partialData"></a><span class="ddoc_psymbol">partialData</span>;
</dt>
<dd>Data pulled from input before finding a problem
<p></p>
This field is populated when using <a href="#csvReader"><span class="d_inlinecode">csvReader</span></a>
<p></p>

but not by <a href="#csvNextToken"><span class="d_inlinecode">csvNextToken</span></a> as this data will have
<p></p>

already been fed to the output range.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".HeaderMismatchException"></a>class <a name="HeaderMismatchException"></a><span class="ddoc_psymbol">HeaderMismatchException</span>: <u>std.csv.CSVException</u>;
</dt>
<dd>Exception thrown under different conditions based on the type of <span class="d_inlinecode"> Contents</span>.
<p></p>
Structure, Class, and Associative Array
 <ul>     <li>When a header is provided but a matching column is not found</li>
  </ul>
<p></p>

 Other
 <ul>     <li>When a header is provided but a matching column is not found</li>
     <li>Order did not match that found in the input</li>
  </ul>
<p></p>

 Since a row and column is not meaningful when a column specified by the
 header is not found in the data, both row and col will be zero. Otherwise
 row is always one and col is the first instance found in header that
 occurred before the previous starting at one.<p></p>

</dd>
<dt class="d_decl"><a name=".Malformed"></a>enum <a name="Malformed"></a><span class="ddoc_psymbol">Malformed</span>: int;
</dt>
<dd>Determines the behavior for when an error is detected.
<p></p>
Disabling exception will follow these rules:
 <ul>     <li>A quote can appear in a field if the field was not quoted.</li>
     <li>If in a quoted field any quote by itself, not at the end of a
     field, will end processing for that field.</li>
     <li>The field is ended when there is no input, even if the quote was
     not closed.</li>
     <li>If the given header does not match the order in the input, the
     content will return as it is found in the input.</li>
     <li>If the given header contains columns not found in the input they
     will be ignored.</li>
  </ul><p></p>

<dl><dt class="d_decl"><a name=".Malformed.ignore"></a><a name="ignore"></a><span class="ddoc_psymbol">ignore</span></dt>
<dd>No exceptions are thrown due to incorrect CSV.<p></p>

</dd>
<dt class="d_decl"><a name=".Malformed.throwException"></a><a name="throwException"></a><span class="ddoc_psymbol">throwException</span></dt>
<dd>Use exceptions when input has incorrect CSV.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".csvReader"></a>auto <a name="csvReader"></a><span class="ddoc_psymbol">csvReader</span>(Contents = string, Malformed ErrorLevel = Malformed.throwException, Range, Separator = char)(Range <i>input</i>, Separator <i>delimiter</i> = ',', Separator <i>quote</i> = '"') if (isInputRange!Range &amp;&amp; is(ElementType!Range == dchar) &amp;&amp; isSomeChar!Separator &amp;&amp; !is(Contents T : T[U], U : string));
</dt>
<dd>Returns an input range for iterating over records found in <span class="d_inlinecode"> input</span>.
<p></p>
 The <span class="d_inlinecode">Contents</span> of the input can be provided if all the records are the
 same type such as all integer data:
<p></p>

<pre class="d_code">string str = <span class="d_string">`76,26,22`</span>;
<span class="d_keyword">int</span>[] ans = [76,26,22];
<span class="d_keyword">auto</span> records = <span class="d_psymbol">csvReader</span>!<span class="d_keyword">int</span>(str);

<span class="d_keyword">foreach</span>(record; records)
{
    <span class="d_keyword">assert</span>(equal(record, ans));
}
</pre>
<p></p>

 Example using a struct with modified delimiter:
<p></p>

<pre class="d_code">string str = <span class="d_string">"Hello;65;63.63\nWorld;123;3673.562"</span>;
<span class="d_keyword">struct</span> Layout
{
    string name;
    <span class="d_keyword">int</span> value;
    <span class="d_keyword">double</span> other;
}

<span class="d_keyword">auto</span> records = <span class="d_psymbol">csvReader</span>!Layout(str,';');

<span class="d_keyword">foreach</span>(record; records)
{
    writeln(record.name);
    writeln(record.value);
    writeln(record.other);
}
</pre>
<p></p>

 Specifying <span class="d_inlinecode">ErrorLevel</span> as Malformed.ignore will lift restrictions
 on the format. This example shows that an exception is not thrown when
 finding a quote in a field not quoted.
<p></p>

<pre class="d_code">string str = <span class="d_string">"A \" is now part of the data"</span>;
<span class="d_keyword">auto</span> records = <span class="d_psymbol">csvReader</span>!(string,Malformed.ignore)(str);
<span class="d_keyword">auto</span> record = records.front;

<span class="d_keyword">assert</span>(record.front == str);
</pre>

<p></p>
<b>Returns:</b><br>An input range R as defined by <a href="std_range.html#isInputRange"><span class="d_inlinecode">std.range.isInputRange</span></a>. When <span class="d_inlinecode">        Contents</span> is a struct, class, or an associative array, the element
        type of R is <span class="d_inlinecode">Contents</span>, otherwise the element type of R is itself
        a range with element type <span class="d_inlinecode">Contents</span>.

<p></p>
<b>Throws:</b><br><a href="#CSVException"><span class="d_inlinecode">CSVException</span></a> When a quote is found in an unquoted field,
       data continues after a closing quote, the quoted field was not
       closed before data was empty, a conversion failed, or when the row's
       length does not match the previous length.
<p></p>

       <a href="#HeaderMismatchException"><span class="d_inlinecode">HeaderMismatchException</span></a>  when a header is provided but a
       matching column is not found or the order did not match that found in
       the input. Read the exception documentation for specific details of
       when the exception is thrown for different types of <span class="d_inlinecode">Contents</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".csvReader"></a>auto <a name="csvReader"></a><span class="ddoc_psymbol">csvReader</span>(Contents = string, Malformed ErrorLevel = Malformed.throwException, Range, Header, Separator = char)(Range <i>input</i>, Header <i>header</i>, Separator <i>delimiter</i> = ',', Separator <i>quote</i> = '"') if (isInputRange!Range &amp;&amp; is(ElementType!Range == dchar) &amp;&amp; isSomeChar!Separator &amp;&amp; isForwardRange!Header &amp;&amp; isSomeString!(ElementType!Header));
</dt>
<dd>An optional <span class="d_inlinecode">header</span> can be provided. The first record will be read in
 as the header. If <span class="d_inlinecode">Contents</span> is a struct then the header provided is
 expected to correspond to the fields in the struct. When <span class="d_inlinecode">Contents</span> is
 not a type which can contain the entire record, the <span class="d_inlinecode">header</span> must be
 provided in the same order as the input or an exception is thrown.
<p></p>
 Read only column "b":
<p></p>

<pre class="d_code">string str = <span class="d_string">"a,b,c\nHello,65,63.63\nWorld,123,3673.562"</span>;
<span class="d_keyword">auto</span> records = <span class="d_psymbol">csvReader</span>!<span class="d_keyword">int</span>(str, [<span class="d_string">"b"</span>]);

<span class="d_keyword">auto</span> ans = [[65],[123]];
<span class="d_keyword">foreach</span>(record; records)
{
    <span class="d_keyword">assert</span>(equal(record, ans.front));
    ans.popFront();
}
</pre>
<p></p>

 Read from header of different order:
<p></p>

<pre class="d_code">string str = <span class="d_string">"a,b,c\nHello,65,63.63\nWorld,123,3673.562"</span>;
<span class="d_keyword">struct</span> Layout
{
    <span class="d_keyword">int</span> value;
    <span class="d_keyword">double</span> other;
    string name;
}

<span class="d_keyword">auto</span> records = <span class="d_psymbol">csvReader</span>!Layout(str, [<span class="d_string">"b"</span>,<span class="d_string">"c"</span>,<span class="d_string">"a"</span>]);
</pre>
<p></p>

 The header can also be left empty if the input contains a header but
 all columns should be iterated. The header from the input can always
 be accessed from the header field.
<p></p>

<pre class="d_code">string str = <span class="d_string">"a,b,c\nHello,65,63.63\nWorld,123,3673.562"</span>;
<span class="d_keyword">auto</span> records = <span class="d_psymbol">csvReader</span>(str, <span class="d_keyword">null</span>);

<span class="d_keyword">assert</span>(records.header == [<span class="d_string">"a"</span>,<span class="d_string">"b"</span>,<span class="d_string">"c"</span>]);
</pre>

<p></p>
<b>Returns:</b><br>        An input range R as defined by <a href="std_range.html#isInputRange"><span class="d_inlinecode">std.range.isInputRange</span></a>. When <span class="d_inlinecode">        Contents</span> is a struct, class, or an associative array, the element
        type of R is <span class="d_inlinecode">Contents</span>, otherwise the element type of R is itself
        a range with element type <span class="d_inlinecode">Contents</span>.
<p></p>

        The returned range provides a header field for accessing the header
        from the input in array form.
<p></p>

<pre class="d_code">string str = <span class="d_string">"a,b,c\nHello,65,63.63"</span>;
<span class="d_keyword">auto</span> records = <span class="d_psymbol">csvReader</span>(str, [<span class="d_string">"a"</span>]);

<span class="d_keyword">assert</span>(records.header == [<span class="d_string">"a"</span>,<span class="d_string">"b"</span>,<span class="d_string">"c"</span>]);
</pre>

<p></p>
<b>Throws:</b><br><a href="#CSVException"><span class="d_inlinecode">CSVException</span></a> When a quote is found in an unquoted field,
       data continues after a closing quote, the quoted field was not
       closed before data was empty, a conversion failed, or when the row's
       length does not match the previous length.
<p></p>

       <a href="#HeaderMismatchException"><span class="d_inlinecode">HeaderMismatchException</span></a>  when a header is provided but a
       matching column is not found or the order did not match that found in
       the input. Read the exception documentation for specific details of
       when the exception is thrown for different types of <span class="d_inlinecode">Contents</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".csvNextToken"></a>void <a name="csvNextToken"></a><span class="ddoc_psymbol">csvNextToken</span>(Range, Malformed ErrorLevel = Malformed.throwException, Separator, Output)(ref Range <i>input</i>, ref Output <i>ans</i>, Separator <i>sep</i>, Separator <i>quote</i>, bool <i>startQuoted</i> = false) if (isSomeChar!Separator &amp;&amp; isInputRange!Range &amp;&amp; is(ElementType!Range == dchar) &amp;&amp; isOutputRange!(Output, dchar));
</dt>
<dd>Lower level control over parsing CSV
<p></p>
 This function consumes the input. After each call the input will
 start with either a delimiter or record break (\n, \r\n, \r) which
 must be removed for subsequent calls.
<p></p>

<pre class="d_code">string str = <span class="d_string">"65,63\n123,3673"</span>;

<span class="d_keyword">auto</span> a = appender!(<span class="d_keyword">char</span>[])();

<span class="d_psymbol">csvNextToken</span>(str,a,',','"');
<span class="d_keyword">assert</span>(a.data == <span class="d_string">"65"</span>);
<span class="d_keyword">assert</span>(str == <span class="d_string">",63\n123,3673"</span>);

str.popFront();
a.shrinkTo(0);
<span class="d_psymbol">csvNextToken</span>(str,a,',','"');
<span class="d_keyword">assert</span>(a.data == <span class="d_string">"63"</span>);
<span class="d_keyword">assert</span>(str == <span class="d_string">"\n123,3673"</span>);

str.popFront();
a.shrinkTo(0);
<span class="d_psymbol">csvNextToken</span>(str,a,',','"');
<span class="d_keyword">assert</span>(a.data == <span class="d_string">"123"</span>);
<span class="d_keyword">assert</span>(str == <span class="d_string">",3673"</span>);
</pre>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Range input</td>
<td valign=top>Any CSV input</td></tr>
<tr><td valign=top>Output ans</td>
<td valign=top>The first field in the input</td></tr>
<tr><td valign=top>Separator sep</td>
<td valign=top>The character to represent a comma in the specification</td></tr>
<tr><td valign=top>Separator quote</td>
<td valign=top>The character to represent a quote in the specification</td></tr>
<tr><td valign=top>bool startQuoted</td>
<td valign=top>Whether the input should be considered to already be in
 quotes</td></tr>
</table><p></p>
<b>Throws:</b><br><a href="#IncompleteCellException"><span class="d_inlinecode">IncompleteCellException</span></a> When a quote is found in an unquoted
       field, data continues after a closing quote, or the quoted field was
       not closed before data was empty.<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright 2011
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

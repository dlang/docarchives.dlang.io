<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.regex - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/regex.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.regex</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/regex.d -->
<h3><a id="Intro">Intro</a></h3>
  <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Regular expressions">Regular expressions</a> are a commonly used method of pattern matching
  on strings, with <i><a name="regex"></a><span class="ddoc_psymbol">regex</span></i> being a catchy word for a pattern in this domain
  specific language. Typical problems usually solved by regular expressions
  include validation of user input and the ubiquitous find &amp; replace
  in text processing utilities.
<p></p>
  <h3><a id="Synopsis">Synopsis</a></h3>
<pre class="d_code"><span class="d_keyword">import</span> std.<span class="d_psymbol">regex</span>;
<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">void</span> main()
{
    <span class="d_comment">// Print out all possible dd/mm/yy(yy) dates found in user input.
</span>    <span class="d_keyword">auto</span> r = <span class="d_psymbol">regex</span>(<span class="d_string">r"\b[0-9][0-9]?/[0-9][0-9]?/[0-9][0-9](?:[0-9][0-9])?\b"</span>);
    <span class="d_keyword">foreach</span>(line; stdin.byLine)
    {
      <span class="d_comment">// matchAll() returns a range that can be iterated
</span>      <span class="d_comment">// to get all subsequent matches.
</span>      <span class="d_keyword">foreach</span>(c; matchAll(line, r))
          writeln(c.hit);
    }
}
...

<span class="d_comment">// Create a static regex at compile-time, which contains fast native code.
</span><span class="d_keyword">auto</span> ctr = ctRegex!(<span class="d_string">`^.*/([^/]+)/?$`</span>);

<span class="d_comment">// It works just like a normal regex:
</span><span class="d_keyword">auto</span> c2 = matchFirst(<span class="d_string">"foo/bar"</span>, ctr);   <span class="d_comment">// First match found here, if any
</span><span class="d_keyword">assert</span>(!c2.empty);   <span class="d_comment">// Be sure to check if there is a match before examining contents!
</span><span class="d_keyword">assert</span>(c2[1] == <span class="d_string">"bar"</span>);   <span class="d_comment">// Captures is a range of submatches: 0 = full match.
</span>
...

<span class="d_comment">// The result of the $(D matchAll) is directly testable with if/assert/while.
</span><span class="d_comment">// e.g. test if a string consists of letters:
</span><span class="d_keyword">assert</span>(matchFirst(<span class="d_string">"Letter"</span>, <span class="d_string">`^\p{L}+$`</span>));


</pre>
  <h3><a id="Syntax and general information">Syntax and general information</a></h3>
  The general usage guideline is to keep <a name="regex"></a><span class="ddoc_psymbol">regex</span> complexity on the side of simplicity,
  as its capabilities reside in purely character-level manipulation.
  As such it's ill-suited for tasks involving higher level invariants
  like matching an integer number <u>bounded</u> in an [a,b] interval.
  Checks of this sort of are better addressed by additional post-processing.
<p></p>

  The basic syntax shouldn't surprise experienced users of regular expressions.
  For an introduction to <span class="d_inlinecode">std.<a name="regex"></a><span class="ddoc_psymbol">regex</span></span> see a
  <a href="http://dlang.org/regular-expression.html">short tour</a> of the module API
  and its abilities.
<p></p>

  There are other web resources on regular expressions to help newcomers,
  and a good <a href="http://www.regular-expressions.info">reference with tutorial</a>
  can easily be found.
<p></p>

  This library uses a remarkably common ECMAScript syntax flavor
  with the following extensions:
  <ul>    <li>Named subexpressions, with Python syntax. </li>
    <li>Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.</li>
    <li>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</li>
  </ul>
<p></p>

  <h3><div align="center"> Pattern syntax  </div></h3>
  <i>std.<a name="regex"></a><span class="ddoc_psymbol">regex</span> operates on codepoint level,
    'character' in this table denotes a single Unicode codepoint.</i>
  <table border="1" cellspacing="0" cellpadding="5" >     <tr><td valign=top><b>Pattern element</b></td> <td valign=top><b>Semantics </b></td> </tr>
    <tr><td valign=top><b>Atoms</b></td> <td valign=top><b>Match single characters </b></td> </tr>
    <tr><td valign=top><i>any character except [{|*+?()^$ </i></td> <td valign=top>Matches the character itself. </td> </tr>
    <tr><td valign=top><i>. </i></td> <td valign=top>In single line mode matches any character.
      Otherwise it matches any character except '\n' and '\r'. </td> </tr>
    <tr><td valign=top><i>[class] </i></td> <td valign=top>Matches a single character
      that belongs to this character class. </td> </tr>
    <tr><td valign=top><i>[^class] </i></td> <td valign=top>Matches a single character that
      does <u>not</u> belong to this character class.</td> </tr>
    <tr><td valign=top><i>\cC </i></td> <td valign=top>Matches the control character corresponding to letter C</td> </tr>
    <tr><td valign=top><i>\xXX </i></td> <td valign=top>Matches a character with hexadecimal value of XX. </td> </tr>
    <tr><td valign=top><i>\uXXXX </i></td> <td valign=top>Matches a character  with hexadecimal value of XXXX. </td> </tr>
    <tr><td valign=top><i>\U00YYYYYY </i></td> <td valign=top>Matches a character with hexadecimal value of YYYYYY. </td> </tr>
    <tr><td valign=top><i>\f </i></td> <td valign=top>Matches a formfeed character. </td> </tr>
    <tr><td valign=top><i>\n </i></td> <td valign=top>Matches a linefeed character. </td> </tr>
    <tr><td valign=top><i>\r </i></td> <td valign=top>Matches a carriage return character. </td> </tr>
    <tr><td valign=top><i>\t </i></td> <td valign=top>Matches a tab character. </td> </tr>
    <tr><td valign=top><i>\v </i></td> <td valign=top>Matches a vertical tab character. </td> </tr>
    <tr><td valign=top><i>\d </i></td> <td valign=top>Matches any Unicode digit. </td> </tr>
    <tr><td valign=top><i>\D </i></td> <td valign=top>Matches any character except Unicode digits. </td> </tr>
    <tr><td valign=top><i>\w </i></td> <td valign=top>Matches any word character (note: this includes numbers).</td> </tr>
    <tr><td valign=top><i>\W </i></td> <td valign=top>Matches any non-word character.</td> </tr>
    <tr><td valign=top><i>\s </i></td> <td valign=top>Matches whitespace, same as \p{White_Space}.</td> </tr>
    <tr><td valign=top><i>\S </i></td> <td valign=top>Matches any character except those recognized as <i>\s </i>. </td> </tr>
    <tr><td valign=top><i>\\ </i></td> <td valign=top>Matches \ character. </td> </tr>
    <tr><td valign=top><i>\c where c is one of [|*+?() </i></td> <td valign=top>Matches the character c itself. </td> </tr>
    <tr><td valign=top><i>\p{PropertyName} </i></td> <td valign=top>Matches a character that belongs
        to the Unicode PropertyName set.
      Single letter abbreviations can be used without surrounding {,}. </td> </tr>
    <tr><td valign=top><i> \P{PropertyName} </i></td> <td valign=top>Matches a character that does not belong
        to the Unicode PropertyName set.
      Single letter abbreviations can be used without surrounding {,}. </td> </tr>
    <tr><td valign=top><i>\p{InBasicLatin} </i></td> <td valign=top>Matches any character that is part of
          the BasicLatin Unicode <u>block</u>.</td> </tr>
    <tr><td valign=top><i>\P{InBasicLatin} </i></td> <td valign=top>Matches any character except ones in
          the BasicLatin Unicode <u>block</u>.</td> </tr>
    <tr><td valign=top><i>\p{Cyrillic} </i></td> <td valign=top>Matches any character that is part of
        Cyrillic <u>script</u>.</td> </tr>
    <tr><td valign=top><i>\P{Cyrillic} </i></td> <td valign=top>Matches any character except ones in
        Cyrillic <u>script</u>.</td> </tr>
    <tr><td valign=top><b>Quantifiers</b></td> <td valign=top><b>Specify repetition of other elements</b></td> </tr>
    <tr><td valign=top><i>* </i></td> <td valign=top>Matches previous character/subexpression 0 or more times.
      Greedy version - tries as many times as possible.</td> </tr>
    <tr><td valign=top><i>*? </i></td> <td valign=top>Matches previous character/subexpression 0 or more times.
      Lazy version  - stops as early as possible.</td> </tr>
    <tr><td valign=top><i>+ </i></td> <td valign=top>Matches previous character/subexpression 1 or more times.
      Greedy version - tries as many times as possible.</td> </tr>
    <tr><td valign=top><i>+? </i></td> <td valign=top>Matches previous character/subexpression 1 or more times.
      Lazy version  - stops as early as possible.</td> </tr>
    <tr><td valign=top><i>{n} </i></td> <td valign=top>Matches previous character/subexpression exactly n times. </td> </tr>
    <tr><td valign=top><i>{n&#44} </i></td> <td valign=top>Matches previous character/subexpression n times or more.
      Greedy version - tries as many times as possible. </td> </tr>
    <tr><td valign=top><i>{n&#44}? </i></td> <td valign=top>Matches previous character/subexpression n times or more.
      Lazy version - stops as early as possible.</td> </tr>
    <tr><td valign=top><i>{n&#44m} </i></td> <td valign=top>Matches previous character/subexpression n to m times.
      Greedy version - tries as many times as possible, but no more than m times. </td> </tr>
    <tr><td valign=top><i>{n&#44m}? </i></td> <td valign=top>Matches previous character/subexpression n to m times.
      Lazy version - stops as early as possible, but no less then n times.</td> </tr>
    <tr><td valign=top><b>Other</b></td> <td valign=top><b>Subexpressions &amp; alternations </b></td> </tr>
    <tr><td valign=top><i>(<a name="regex"></a><span class="ddoc_psymbol">regex</span>) </i></td> <td valign=top> Matches subexpression <a name="regex"></a><span class="ddoc_psymbol">regex</span>,
      saving matched portion of text for later retrieval. </td> </tr>
    <tr><td valign=top><i>(?:<a name="regex"></a><span class="ddoc_psymbol">regex</span>) </i></td> <td valign=top>Matches subexpression <a name="regex"></a><span class="ddoc_psymbol">regex</span>,
      <u>not</u> saving matched portion of text. Useful to speed up matching. </td> </tr>
    <tr><td valign=top><i>A|B </i></td> <td valign=top>Matches subexpression A, or failing that, matches B. </td> </tr>
    <tr><td valign=top><i>(?P&lt;name&gt;<a name="regex"></a><span class="ddoc_psymbol">regex</span>) </i></td> <td valign=top>Matches named subexpression
        <a name="regex"></a><span class="ddoc_psymbol">regex</span> labeling it with name 'name'.
        When referring to a matched portion of text,
        names work like aliases in addition to direct numbers.
     </td> </tr>
    <tr><td valign=top><b>Assertions</b></td> <td valign=top><b>Match position rather than character </b></td> </tr>
    <tr><td valign=top><i>^ </i></td> <td valign=top>Matches at the begining of input or line (in multiline mode).</td> </tr>
    <tr><td valign=top><i>$ </i></td> <td valign=top>Matches at the end of input or line (in multiline mode). </td> </tr>
    <tr><td valign=top><i>\b </i></td> <td valign=top>Matches at word boundary. </td> </tr>
    <tr><td valign=top><i>\B </i></td> <td valign=top>Matches when <u>not</u> at word boundary. </td> </tr>
    <tr><td valign=top><i>(?=<a name="regex"></a><span class="ddoc_psymbol">regex</span>) </i></td> <td valign=top>Zero-width lookahead assertion.
        Matches at a point where the subexpression
        <a name="regex"></a><span class="ddoc_psymbol">regex</span> could be matched starting from the current position.
      </td> </tr>
    <tr><td valign=top><i>(?!<a name="regex"></a><span class="ddoc_psymbol">regex</span>) </i></td> <td valign=top>Zero-width negative lookahead assertion.
        Matches at a point where the subexpression
        <a name="regex"></a><span class="ddoc_psymbol">regex</span> could <u>not</u> be matched starting from the current position.
      </td> </tr>
    <tr><td valign=top><i>(?&lt;=<a name="regex"></a><span class="ddoc_psymbol">regex</span>) </i></td> <td valign=top>Zero-width lookbehind assertion. Matches at a point
        where the subexpression <a name="regex"></a><span class="ddoc_psymbol">regex</span> could be matched ending
        at the current position (matching goes backwards).
      </td> </tr>
    <tr><td valign=top><i> (?&lt;!<a name="regex"></a><span class="ddoc_psymbol">regex</span>) </i></td> <td valign=top>Zero-width negative lookbehind assertion.
      Matches at a point where the subexpression <a name="regex"></a><span class="ddoc_psymbol">regex</span> could <u>not</u>
      be matched ending at the current position (matching goes backwards).
     </td> </tr>
   </table>
<p></p>

  <h3><div align="center"> Character classes  </div></h3>
  <table border="1" cellspacing="0" cellpadding="5" >     <tr><td valign=top><b>Pattern element</b></td> <td valign=top><b>Semantics </b></td> </tr>
    <tr><td valign=top><i>Any atom </i></td> <td valign=top>Has the same meaning as outside of a character class.</td> </tr>
    <tr><td valign=top><i>a-z </i></td> <td valign=top>Includes characters a, b, c, ..., z. </td> </tr>
    <tr><td valign=top><i>[a||b]&#44 [a--b]&#44 [a~~b]&#44 [a&amp;&b] </i></td> <td valign=top>Where a, b are arbitrary classes,
     means union, set difference, symmetric set difference, and intersection respectively.
     <i>Any sequence of character class elements implicitly forms a union.</i> </td> </tr>
   </table>
<p></p>

  <h3><div align="center"> Regex flags  </div></h3>
  <table border="1" cellspacing="0" cellpadding="5" >     <tr><td valign=top><b>Flag</b></td> <td valign=top><b>Semantics </b></td> </tr>
    <tr><td valign=top><i>g </i></td> <td valign=top>Global <a name="regex"></a><span class="ddoc_psymbol">regex</span>, repeat over the whole input. </td> </tr>
    <tr><td valign=top><i>i </i></td> <td valign=top>Case insensitive matching. </td> </tr>
    <tr><td valign=top><i>m </i></td> <td valign=top>Multi-line mode, match ^, $ on start and end line separators
       as well as start and end of input.</td> </tr>
    <tr><td valign=top><i>s </i></td> <td valign=top>Single-line mode, makes . match '\n' and '\r' as well. </td> </tr>
    <tr><td valign=top><i>x </i></td> <td valign=top>Free-form syntax, ignores whitespace in pattern,
      useful for formatting complex regular expressions. </td> </tr>
   </table>
<p></p>

  <h3><a id="Unicode support">Unicode support</a></h3>
<p></p>

  This library provides full Level 1 support* according to
    <a href="http://unicode.org/reports/tr18/">UTS 18</a>. Specifically:
  <ul>    <li>1.1 Hex notation via any of \uxxxx, \U00YYYYYY, \xZZ.</li>
    <li>1.2 Unicode properties.</li>
    <li>1.3 Character classes with set operations.</li>
    <li>1.4 Word boundaries use the full set of "word" characters.</li>
    <li>1.5 Using simple casefolding to match case
        insensitively across the full range of codepoints.</li>
    <li>1.6 Respecting line breaks as any of
        \u000A | \u000B | \u000C | \u000D | \u0085 | \u2028 | \u2029 | \u000D\u000A.</li>
    <li>1.7 Operating on codepoint level.</li>
  </ul>
  *With exception of point 1.1.1, as of yet, normalization of input
    is expected to be enforced by user.
<p></p>

    <h3><a id="Replace format string">Replace format string</a></h3>
<p></p>

    A set of functions in this module that do the substitution rely
    on a simple format to guide the process. In particular the table below
    applies to the <span class="d_inlinecode">format</span> argument of
    <a href="#replaceFirst"><span class="d_inlinecode">replaceFirst</span></a> and <a href="#replaceAll"><span class="d_inlinecode">replaceAll</span></a>.
<p></p>

    The format string can reference parts of match using the following notation.
    <table border="1" cellspacing="0" cellpadding="5" >         <tr><td valign=top><b>Format specifier</b></td> <td valign=top><b>Replaced by </b></td> </tr>
        <tr><td valign=top><i>$&amp; </i></td> <td valign=top>the whole match. </td> </tr>
        <tr><td valign=top><i>$` </i></td> <td valign=top>part of input <i>preceding</i> the match. </td> </tr>
        <tr><td valign=top><i>$' </i></td> <td valign=top>part of input <i>following</i> the match. </td> </tr>
        <tr><td valign=top><i>$$ </i></td> <td valign=top>'$' character. </td> </tr>
        <tr><td valign=top><i>\c &#44 where c is any character </i></td> <td valign=top>the character c itself. </td> </tr>
        <tr><td valign=top><i>\\ </i></td> <td valign=top>'\' character. </td> </tr>
        <tr><td valign=top><i>&#36;1 .. &#36;99 </i></td> <td valign=top>submatch number 1 to 99 respectively. </td> </tr>
     </table>
<p></p>

  <h3><a id="Slicing and zero memory allocations orientation">Slicing and zero memory allocations orientation</a></h3>
<p></p>

  All matches returned by pattern matching functionality in this library
    are slices of the original input. The notable exception is the <span class="d_inlinecode">replace</span>
    family of functions  that generate a new string from the input.
<p></p>

    In cases where producing the replacement is the ultimate goal
    <a href="#replaceFirstInto"><span class="d_inlinecode">replaceFirstInto</span></a> and <a href="#replaceAllInto"><span class="d_inlinecode">replaceAllInto</span></a> could come in handy
    as functions that  avoid allocations even for replacement.

<p></p>
<b>License:</b><br><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

<p></p>
<b>Authors:</b><br>Dmitry Olshansky,
<p></p>

    API and utility constructs are modeled after the original <span class="d_inlinecode">std.<a name="regex"></a><span class="ddoc_psymbol">regex</span></span>
  by Walter Bright and Andrei Alexandrescu.

<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/regex.d">std/regex.d</a>

<p></p>

<dl><dt class="d_decl"><a name=".Regex"></a>struct <a name="Regex"></a><span class="ddoc_psymbol">Regex</span>(Char);
</dt>
<dd><span class="d_inlinecode"><a name="Regex"></a><span class="ddoc_psymbol">Regex</span></span> object holds regular expression pattern in compiled form.
    Instances of this object are constructed via calls to <span class="d_inlinecode">regex</span>.
    This is an intended form for caching and storage of frequently
    used regular expressions.<p></p>

<dl><dt class="d_decl"><a name=".Regex.empty"></a>const nothrow @property @safe bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Test if this object doesn't contain any compiled pattern.
<p></p>
<b>Example:</b><br>
<pre class="d_code">Regex!<span class="d_keyword">char</span> r;
<span class="d_keyword">assert</span>(r.<span class="d_psymbol">empty</span>);
r = regex(<span class="d_string">""</span>); <span class="d_comment">// Note: "" is a valid regex pattern.
</span><span class="d_keyword">assert</span>(!r.<span class="d_psymbol">empty</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Regex.namedCaptures"></a>@property @safe auto <a name="namedCaptures"></a><span class="ddoc_psymbol">namedCaptures</span>();
</dt>
<dd>A range of all the named captures in the regex.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">import</span> std.range;
<span class="d_keyword">import</span> std.algorithm;

<span class="d_keyword">auto</span> re = regex(<span class="d_string">`(?P&lt;name&gt;\w+) = (?P&lt;var&gt;\d+)`</span>);
<span class="d_keyword">auto</span> nc = re.<span class="d_psymbol">namedCaptures</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isRandomAccessRange!(<span class="d_keyword">typeof</span>(nc)));
<span class="d_keyword">assert</span>(!nc.empty);
<span class="d_keyword">assert</span>(nc.length == 2);
<span class="d_keyword">assert</span>(nc.equal([<span class="d_string">"name"</span>, <span class="d_string">"var"</span>]));
<span class="d_keyword">assert</span>(nc[0] == <span class="d_string">"name"</span>);
<span class="d_keyword">assert</span>(nc[1..$].equal([<span class="d_string">"var"</span>]));
</pre>
<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".StaticRegex"></a>struct <a name="StaticRegex"></a><span class="ddoc_psymbol">StaticRegex</span>(Char);
</dt>
<dd>A <span class="d_inlinecode"><a name="StaticRegex"></a><span class="ddoc_psymbol">StaticRegex</span></span> is <span class="d_inlinecode">Regex</span> object that contains specially
    generated machine code to speed up matching.
    Implicitly convertible to normal <span class="d_inlinecode">Regex</span>,
    however doing so will result in losing this additional capability.<p></p>

</dd>
<dt class="d_decl"><a name=".Captures"></a>struct <a name="Captures"></a><span class="ddoc_psymbol">Captures</span>(R, DIndex = size_t) if (isSomeString!R);
</dt>
<dd><span class="d_inlinecode"><a name="Captures"></a><span class="ddoc_psymbol">Captures</span></span> object contains submatches captured during a call
    to <span class="d_inlinecode">match</span> or iteration over <span class="d_inlinecode">RegexMatch</span> range.
<p></p>
First element of range is the whole match.<p></p>

<dl><dt class="d_decl"><a name=".Captures.pre"></a>@property R <a name="pre"></a><span class="ddoc_psymbol">pre</span>();
</dt>
<dd>Slice of input prior to the match.<p></p>

</dd>
<dt class="d_decl"><a name=".Captures.post"></a>@property R <a name="post"></a><span class="ddoc_psymbol">post</span>();
</dt>
<dd>Slice of input immediately after the match.<p></p>

</dd>
<dt class="d_decl"><a name=".Captures.hit"></a>@property R <a name="hit"></a><span class="ddoc_psymbol">hit</span>();
</dt>
<dd>Slice of matched portion of input.<p></p>

</dd>
<dt class="d_decl"><a name=".Captures.front"></a>@property R <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Captures.back"></a>@property R <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".Captures.popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".Captures.popBack"></a>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br><a name=".Captures.empty"></a>const @property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".Captures.opIndex"></a>R <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>()(size_t <i>i</i>);
</dt>
<dd>Range interface.<p></p>

</dd>
<dt class="d_decl"><a name=".Captures.opCast"></a>const nothrow @safe bool <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : bool)();
</dt>
<dd>Explicit cast to bool.
        Useful as a shorthand for !(x.empty) in if and assert statements.
<p></p>
<pre class="d_code"><span class="d_keyword">import</span> std.regex;

<span class="d_keyword">assert</span>(!matchFirst(<span class="d_string">"nothing"</span>, <span class="d_string">"something"</span>));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Captures.opIndex"></a>R <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(String)(String <i>i</i>) if (isSomeString!String);
</dt>
<dd>Lookup named submatch.
<p></p>
<pre class="d_code"><span class="d_keyword">import</span> std.regex;
<span class="d_keyword">import</span> std.range;

<span class="d_keyword">auto</span> c = matchFirst(<span class="d_string">"a = 42;"</span>, regex(<span class="d_string">`(?P&lt;var&gt;\w+)\s*=\s*(?P&lt;value&gt;\d+);`</span>));
<span class="d_keyword">assert</span>(c[<span class="d_string">"var"</span>] == <span class="d_string">"a"</span>);
<span class="d_keyword">assert</span>(c[<span class="d_string">"value"</span>] == <span class="d_string">"42"</span>);
popFrontN(c, 2);
<span class="d_comment">//named groups are unaffected by range primitives
</span><span class="d_keyword">assert</span>(c[<span class="d_string">"var"</span>] ==<span class="d_string">"a"</span>);
<span class="d_keyword">assert</span>(c.front == <span class="d_string">"42"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Captures.length"></a>const @property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>Number of matches in this object.<p></p>

</dd>
<dt class="d_decl"><a name=".Captures.captures"></a>@property ref auto <a name="captures"></a><span class="ddoc_psymbol">captures</span>();
</dt>
<dd>A hook for compatibility with original std.regex.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".RegexMatch"></a>struct <a name="RegexMatch"></a><span class="ddoc_psymbol">RegexMatch</span>(R, alias Engine = ThompsonMatcher) if (isSomeString!R);
</dt>
<dd>A regex engine state, as returned by <span class="d_inlinecode">match</span> family of functions.
<p></p>
Effectively it's a forward range of Captures!R, produced
    by lazily searching for matches in a given input.
<p></p>

    <span class="d_inlinecode">alias Engine</span> specifies an engine type to use during matching,
    and is automatically deduced in a call to <span class="d_inlinecode">match</span>/<span class="d_inlinecode">bmatch</span>.<p></p>

<dl><dt class="d_decl"><a name=".RegexMatch.pre"></a>@property R <a name="pre"></a><span class="ddoc_psymbol">pre</span>();
<br><a name=".RegexMatch.post"></a>@property R <a name="post"></a><span class="ddoc_psymbol">post</span>();
<br><a name=".RegexMatch.hit"></a>@property R <a name="hit"></a><span class="ddoc_psymbol">hit</span>();
</dt>
<dd>Shorthands for front.<a name="pre"></a><span class="ddoc_psymbol">pre</span>, front.post, front.hit.<p></p>

</dd>
<dt class="d_decl"><a name=".RegexMatch.front"></a>@property auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".RegexMatch.popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".RegexMatch.save"></a>auto <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd>        Functionality for processing subsequent matches of global regexes via range interface:
<pre class="d_code"><span class="d_keyword">import</span> std.regex;
<span class="d_keyword">auto</span> m = matchAll(<span class="d_string">"Hello, world!"</span>, regex(<span class="d_string">`\w+`</span>));
<span class="d_keyword">assert</span>(m.<span class="d_psymbol">front</span>.hit == <span class="d_string">"Hello"</span>);
m.popFront();
<span class="d_keyword">assert</span>(m.<span class="d_psymbol">front</span>.hit == <span class="d_string">"world"</span>);
m.popFront();
<span class="d_keyword">assert</span>(m.empty);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".RegexMatch.empty"></a>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Test if this match object is <a name="empty"></a><span class="ddoc_psymbol">empty</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".RegexMatch.opCast"></a>T <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : bool)();
</dt>
<dd>Same as !(x.empty), provided for its convenience  in conditional statements.<p></p>

</dd>
<dt class="d_decl"><a name=".RegexMatch.captures"></a>@property auto <a name="captures"></a><span class="ddoc_psymbol">captures</span>();
</dt>
<dd>Same as .front, provided for compatibility with original std.regex.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".regex"></a>@trusted auto <a name="regex"></a><span class="ddoc_psymbol">regex</span>(S)(S <i>pattern</i>, const(char)[] <i>flags</i> = "") if (isSomeString!S);
</dt>
<dd>Compile regular expression pattern for the later execution.
<p></p>
<b>Returns:</b><br><span class="d_inlinecode">Regex</span> object that works on inputs having
    the same character width as <span class="d_inlinecode">pattern</span>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>S pattern</td>
<td valign=top>Regular expression</td></tr>
<tr><td valign=top>const(char)[] flags</td>
<td valign=top>The attributes (g, i, m and x accepted)</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">RegexException</span> if there were any errors during compilation.<p></p>

</dd>
<dt class="d_decl"><a name=".ctRegex"></a>template <a name="ctRegex"></a><span class="ddoc_psymbol">ctRegex</span>(alias pattern, alias flags = [])</dt>
<dd>Compile regular expression using CTFE
    and generate optimized native machine code for matching it.
<p></p>
<b>Returns:</b><br>StaticRegex object for faster matching.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pattern</td>
<td valign=top>Regular expression</td></tr>
<tr><td valign=top>flags</td>
<td valign=top>The attributes (g, i, m and x accepted)</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".match"></a>auto <a name="match"></a><span class="ddoc_psymbol">match</span>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
</dt>
<dd>Start matching <span class="d_inlinecode">input</span> to regex pattern <span class="d_inlinecode">re</span>,
    using Thompson NFA matching scheme.
<p></p>
The use of this function is <span style="color:red">discouraged</span> - use either of
    <a href="#matchAll"><span class="d_inlinecode">matchAll</span></a> or <a href="#matchFirst"><span class="d_inlinecode">matchFirst</span></a>.
<p></p>

    Delegating  the kind of operation
    to "g" flag is soon to be phased out along with the
    ability to choose the exact matching scheme. The choice of
    matching scheme to use depends highly on the pattern kind and
    can done automatically on case by case basis.

<p></p>
<b>Returns:</b><br>a <span class="d_inlinecode">RegexMatch</span> object holding engine state after first <a name="match"></a><span class="ddoc_psymbol">match</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".match"></a>auto <a name="match"></a><span class="ddoc_psymbol">match</span>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</dt>
<dd>ditto<p></p>

</dd>
<dt class="d_decl"><a name=".matchFirst"></a>auto <a name="matchFirst"></a><span class="ddoc_psymbol">matchFirst</span>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
</dt>
<dd>Find the first (leftmost) slice of the <span class="d_inlinecode">input</span> that
    matches the pattern <span class="d_inlinecode">re</span>. This function picks the most suitable
    regular expression engine depending on the pattern properties.
<p></p>
<span class="d_inlinecode">re</span> parameter can be one of three types:
    <ul>      <li>Plain string, in which case it's compiled to bytecode before matching. </li>
      <li>Regex!char (wchar/dchar) that contains a pattern in the form of
        compiled  bytecode. </li>
      <li>StaticRegex!char (wchar/dchar) that contains a pattern in the form of
        compiled native machine code. </li>
    </ul>

<p></p>
<b>Returns:</b><br><a href="#Captures"><span class="d_inlinecode">Captures</span></a> containing the extent of a match together with all submatches
    if there was a match, otherwise an empty <a href="#Captures"><span class="d_inlinecode">Captures</span></a> object.<p></p>

</dd>
<dt class="d_decl"><a name=".matchFirst"></a>auto <a name="matchFirst"></a><span class="ddoc_psymbol">matchFirst</span>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</dt>
<dd>ditto<p></p>

</dd>
<dt class="d_decl"><a name=".matchAll"></a>auto <a name="matchAll"></a><span class="ddoc_psymbol">matchAll</span>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
</dt>
<dd>Initiate a search for all non-overlapping matches to the pattern <span class="d_inlinecode">re</span>
    in the given <span class="d_inlinecode">input</span>. The result is a lazy range of matches generated
    as they are encountered in the input going left to right.
<p></p>
This function picks the most suitable regular expression engine
    depending on the pattern properties.
<p></p>

    <span class="d_inlinecode">re</span> parameter can be one of three types:
    <ul>      <li>Plain string, in which case it's compiled to bytecode before matching. </li>
      <li>Regex!char (wchar/dchar) that contains a pattern in the form of
        compiled  bytecode. </li>
      <li>StaticRegex!char (wchar/dchar) that contains a pattern in the form of
        compiled native machine code. </li>
    </ul>

<p></p>
<b>Returns:</b><br><a href="#RegexMatch"><span class="d_inlinecode">RegexMatch</span></a> object that represents matcher state
    after the first match was found or an empty one if not present.<p></p>

</dd>
<dt class="d_decl"><a name=".matchAll"></a>auto <a name="matchAll"></a><span class="ddoc_psymbol">matchAll</span>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</dt>
<dd>ditto<p></p>

</dd>
<dt class="d_decl"><a name=".bmatch"></a>auto <a name="bmatch"></a><span class="ddoc_psymbol">bmatch</span>(R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; is(RegEx == Regex!(BasicElementOf!R)));
</dt>
<dd>Start matching of <span class="d_inlinecode">input</span> to regex pattern <span class="d_inlinecode">re</span>,
    using traditional <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=backtracking">backtracking</a> matching scheme.
<p></p>
The use of this function is <span style="color:red">discouraged</span> - use either of
    <a href="#matchAll"><span class="d_inlinecode">matchAll</span></a> or <a href="#matchFirst"><span class="d_inlinecode">matchFirst</span></a>.
<p></p>

    Delegating  the kind of operation
    to "g" flag is soon to be phased out along with the
    ability to choose the exact matching scheme. The choice of
    matching scheme to use depends highly on the pattern kind and
    can done automatically on case by case basis.

<p></p>
<b>Returns:</b><br>a <span class="d_inlinecode">RegexMatch</span> object holding engine
    state after first match.<p></p>

</dd>
<dt class="d_decl"><a name=".bmatch"></a>auto <a name="bmatch"></a><span class="ddoc_psymbol">bmatch</span>(R, String)(R <i>input</i>, String <i>re</i>) if (isSomeString!R &amp;&amp; isSomeString!String);
</dt>
<dd>ditto<p></p>

</dd>
<dt class="d_decl"><a name=".replaceFirst"></a>R <a name="replaceFirst"></a><span class="ddoc_psymbol">replaceFirst</span>(R, C, RegEx)(R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>Construct a new string from <span class="d_inlinecode">input</span> by replacing the first match with
    a string generated from it according to the <span class="d_inlinecode">format</span> specifier.
<p></p>
To replace all matches use <a href="#replaceAll"><span class="d_inlinecode">replaceAll</span></a>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>R input</td>
<td valign=top>string to search</td></tr>
<tr><td valign=top>RegEx re</td>
<td valign=top>compiled regular expression to use</td></tr>
<tr><td valign=top>const(C)[] format</td>
<td valign=top>format string to generate replacements from,
    see <a href="#Replace format string">the format string</a>.</td></tr>
</table><p></p>
<b>Returns:</b><br>A string of the same type with the first match (if any) replaced.
    If no match is found returns the input string itself.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">replaceFirst</span>(<span class="d_string">"noon"</span>, regex(<span class="d_string">"n"</span>), <span class="d_string">"[$&amp;]"</span>) == <span class="d_string">"[n]oon"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".replaceFirst"></a>R <a name="replaceFirst"></a><span class="ddoc_psymbol">replaceFirst</span>(alias fun, R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>This is a general replacement tool that construct a new string by replacing
    matches of pattern <span class="d_inlinecode">re</span> in the <span class="d_inlinecode">input</span>. Unlike the other overload
    there is no format string instead captures are passed to
    to a user-defined functor <span class="d_inlinecode">fun</span> that returns a new string
    to use as replacement.
<p></p>
This version replaces the first match in <span class="d_inlinecode">input</span>,
    see <a href="#replaceAll"><span class="d_inlinecode">replaceAll</span></a> to replace the all of the matches.

<p></p>
<b>Returns:</b><br>A new string of the same type as <span class="d_inlinecode">input</span> with all matches
    replaced by return values of <span class="d_inlinecode">fun</span>. If no matches found
    returns the <span class="d_inlinecode">input</span> itself.

<p></p>
<b>Example:</b><br>
<pre class="d_code">string list = <span class="d_string">"#21 out of 46"</span>;
string newList = <span class="d_psymbol">replaceFirst</span>!(cap =&gt; to!string(to!<span class="d_keyword">int</span>(cap.hit)+1))
    (list, regex(<span class="d_string">`[0-9]+`</span>));
<span class="d_keyword">assert</span>(newList == <span class="d_string">"#22 out of 46"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".replaceFirstInto"></a>@trusted void <a name="replaceFirstInto"></a><span class="ddoc_psymbol">replaceFirstInto</span>(Sink, R, C, RegEx)(ref Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>A variation on <a href="#replaceFirst"><span class="d_inlinecode">replaceFirst</span></a> that instead of allocating a new string
    on each call outputs the result piece-wise to the <span class="d_inlinecode">sink</span>. In particular
    this enables efficient construction of a final output incrementally.
<p></p>
Like in <a href="#replaceFirst"><span class="d_inlinecode">replaceFirst</span></a> family of functions there is an overload
    for the substitution guided by the <span class="d_inlinecode">format</span> string
    and the one with the user defined callback.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">import</span> std.array;
string m1 = <span class="d_string">"first message\n"</span>;
string m2 = <span class="d_string">"second message\n"</span>;
<span class="d_keyword">auto</span> result = appender!string();
<span class="d_psymbol">replaceFirstInto</span>(result, m1, regex(<span class="d_string">`([a-z]+) message`</span>), <span class="d_string">"$1"</span>);
<span class="d_comment">//equivalent of the above with user-defined callback
</span><span class="d_psymbol">replaceFirstInto</span>!(cap=&gt;cap[1])(result, m2, regex(<span class="d_string">`([a-z]+) message`</span>));
<span class="d_keyword">assert</span>(result.data == <span class="d_string">"first\nsecond\n"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".replaceFirstInto"></a>@trusted void <a name="replaceFirstInto"></a><span class="ddoc_psymbol">replaceFirstInto</span>(alias fun, Sink, R, RegEx)(Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>ditto<p></p>

</dd>
<dt class="d_decl"><a name=".replaceAll"></a>@trusted R <a name="replaceAll"></a><span class="ddoc_psymbol">replaceAll</span>(R, C, RegEx)(R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>Construct a new string from <span class="d_inlinecode">input</span> by replacing all of the
    fragments that match a pattern <span class="d_inlinecode">re</span> with a string generated
    from the match according to the <span class="d_inlinecode">format</span> specifier.
<p></p>
To replace only the first match use <a href="#replaceFirst"><span class="d_inlinecode">replaceFirst</span></a>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>R input</td>
<td valign=top>string to search</td></tr>
<tr><td valign=top>RegEx re</td>
<td valign=top>compiled regular expression to use</td></tr>
<tr><td valign=top>const(C)[] format</td>
<td valign=top>format string to generate replacements from,
    see <a href="#Replace format string">the format string</a>.</td></tr>
</table><p></p>
<b>Returns:</b><br>A string of the same type as <span class="d_inlinecode">input</span> with the all
    of the matches (if any) replaced.
    If no match is found returns the input string itself.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Comify a number
</span><span class="d_keyword">auto</span> com = regex(<span class="d_string">r"(?&lt;=\d)(?=(\d\d\d)+\b)"</span>,<span class="d_string">"g"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">replaceAll</span>(<span class="d_string">"12000 + 42100 = 54100"</span>, com, <span class="d_string">","</span>) == <span class="d_string">"12,000 + 42,100 = 54,100"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".replaceAll"></a>@trusted R <a name="replaceAll"></a><span class="ddoc_psymbol">replaceAll</span>(alias fun, R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>This is a general replacement tool that construct a new string by replacing
    matches of pattern <span class="d_inlinecode">re</span> in the <span class="d_inlinecode">input</span>. Unlike the other overload
    there is no format string instead captures are passed to
    to a user-defined functor <span class="d_inlinecode">fun</span> that returns a new string
    to use as replacement.
<p></p>
This version replaces all of the matches found in <span class="d_inlinecode">input</span>,
    see <a href="#replaceFirst"><span class="d_inlinecode">replaceFirst</span></a> to replace the first match only.

<p></p>
<b>Returns:</b><br>A new string of the same type as <span class="d_inlinecode">input</span> with all matches
    replaced by return values of <span class="d_inlinecode">fun</span>. If no matches found
    returns the <span class="d_inlinecode">input</span> itself.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>R input</td>
<td valign=top>string to search</td></tr>
<tr><td valign=top>RegEx re</td>
<td valign=top>compiled regular expression</td></tr>
<tr><td valign=top>fun</td>
<td valign=top>delegate to use</td></tr>
</table><p></p>
<b>Example:</b><br>
    Capitalize the letters 'a' and 'r':
<pre class="d_code">string baz(Captures!(string) m)
{
    <span class="d_keyword">return</span> std.string.toUpper(m.hit);
}
<span class="d_keyword">auto</span> s = <span class="d_psymbol">replaceAll</span>!(baz)(<span class="d_string">"Strap a rocket engine on a chicken."</span>,
        regex(<span class="d_string">"[ar]"</span>));
<span class="d_keyword">assert</span>(s == <span class="d_string">"StRAp A Rocket engine on A chicken."</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".replaceAllInto"></a>@trusted void <a name="replaceAllInto"></a><span class="ddoc_psymbol">replaceAllInto</span>(Sink, R, C, RegEx)(Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>A variation on <a href="#replaceAll"><span class="d_inlinecode">replaceAll</span></a> that instead of allocating a new string
    on each call outputs the result piece-wise to the <span class="d_inlinecode">sink</span>. In particular
    this enables efficient construction of a final output incrementally.
<p></p>
As with <a href="#replaceAll"><span class="d_inlinecode">replaceAll</span></a> there are 2 overloads - one with a format string,
    the other one with a user defined functor.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">//swap all 3 letter words and bring it back
</span>string text = <span class="d_string">"How are you doing?"</span>;
<span class="d_keyword">auto</span> sink = appender!(<span class="d_keyword">char</span>[])();
<span class="d_psymbol">replaceAllInto</span>!(cap =&gt; retro(cap[0]))(sink, text, regex(<span class="d_string">`\b\w{3}\b`</span>));
<span class="d_keyword">auto</span> swapped = sink.data.dup; <span class="d_comment">// make a copy explicitly
</span><span class="d_keyword">assert</span>(swapped == <span class="d_string">"woH era uoy doing?"</span>);
sink.clear();
<span class="d_psymbol">replaceAllInto</span>!(cap =&gt; retro(cap[0]))(sink, swapped, regex(<span class="d_string">`\b\w{3}\b`</span>));
<span class="d_keyword">assert</span>(sink.data == text);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".replaceAllInto"></a>@trusted void <a name="replaceAllInto"></a><span class="ddoc_psymbol">replaceAllInto</span>(alias fun, Sink, R, RegEx)(Sink <i>sink</i>, R <i>input</i>, RegEx <i>re</i>) if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>ditto<p></p>

</dd>
<dt class="d_decl"><a name=".replace"></a>R <a name="replace"></a><span class="ddoc_psymbol">replace</span>(alias scheme = match, R, C, RegEx)(R <i>input</i>, RegEx <i>re</i>, const(C)[] <i>format</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>Old API for replacement, operation depends on flags of pattern <span class="d_inlinecode">re</span>.
    With "g" flag it performs the equivalent of <a href="#replaceAll"><span class="d_inlinecode">replaceAll</span></a> otherwise it
    works the same as <a href="#replaceFirst"><span class="d_inlinecode">replaceFirst</span></a>.
<p></p>
The use of this function is <span style="color:red">discouraged</span>, please use <a href="#replaceAll"><span class="d_inlinecode">replaceAll</span></a>
    or <a href="#replaceFirst"><span class="d_inlinecode">replaceFirst</span></a> explicitly.<p></p>

</dd>
<dt class="d_decl"><a name=".replace"></a>R <a name="replace"></a><span class="ddoc_psymbol">replace</span>(alias fun, R, RegEx)(R <i>input</i>, RegEx <i>re</i>) if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R));
</dt>
<dd>ditto<p></p>

</dd>
<dt class="d_decl"><a name=".Splitter"></a>struct <a name="Splitter"></a><span class="ddoc_psymbol">Splitter</span>(Range, alias RegEx = Regex) if (isSomeString!Range &amp;&amp; isRegexFor!(RegEx, Range));
</dt>
<dd>Range that splits a string using a regular expression as a
separator.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> s1 = <span class="d_string">", abc, de,  fg, hi, "</span>;
<span class="d_keyword">assert</span>(equal(splitter(s1, regex(<span class="d_string">", *"</span>)),
    [<span class="d_string">""</span>, <span class="d_string">"abc"</span>, <span class="d_string">"de"</span>, <span class="d_string">"fg"</span>, <span class="d_string">"hi"</span>, <span class="d_string">""</span>]));
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".Splitter.front"></a>@property Range <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Splitter.empty"></a>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".Splitter.popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".Splitter.save"></a>@property auto <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd>Forward range primitives.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".splitter"></a>Splitter!(Range, RegEx) <a name="splitter"></a><span class="ddoc_psymbol">splitter</span>(Range, RegEx)(Range <i>r</i>, RegEx <i>pat</i>) if (is(BasicElementOf!Range : dchar) &amp;&amp; isRegexFor!(RegEx, Range));
</dt>
<dd>A helper function, creates a <span class="d_inlinecode">Splitter</span> on range <span class="d_inlinecode">r</span> separated by regex <span class="d_inlinecode">pat</span>.
    Captured subexpressions have no effect on the resulting range.<p></p>

</dd>
<dt class="d_decl"><a name=".split"></a>@trusted String[] <a name="split"></a><span class="ddoc_psymbol">split</span>(String, RegEx)(String <i>input</i>, RegEx <i>rx</i>) if (isSomeString!String &amp;&amp; isRegexFor!(RegEx, String));
</dt>
<dd>An eager version of <span class="d_inlinecode">splitter</span> that creates an array with splitted slices of <span class="d_inlinecode">input</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".RegexException"></a>class <a name="RegexException"></a><span class="ddoc_psymbol">RegexException</span>: <u>object.Exception</u>;
</dt>
<dd>Exception object thrown in case of errors during regex compilation.<p></p>

<dl><dt class="d_decl"><a name=".RegexException.this"></a>@trusted this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Dmitry Olshansky, 2011-

 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

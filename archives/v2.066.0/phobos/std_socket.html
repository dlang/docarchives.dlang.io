<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.socket - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/socket.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Phobos/StdSocket" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.socket</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/socket.d -->
<b>Example:</b><br>
See <a href="https://github.com/D-Programming-Language/dmd/blob/master/samples/listener.d">/dmd/samples/d/listener.d</a> and <a href="https://github.com/D-Programming-Language/dmd/blob/master/samples/htmlget.d">/dmd/samples/d/htmlget.d</a>
<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br>Christopher E. Miller, <a href="http://klickverbot.at">David Nadlinger</a>,
      <a href="http://thecybershadow.net">Vladimir Panteleev</a>
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/socket.d">std/socket.d</a>
<p></p>

<dl><dt class="d_decl"><a name=".SocketException"></a>class <a name="SocketException"></a><span class="ddoc_psymbol">SocketException</span>: <u>object.Exception</u>;
</dt>
<dd>Base exception thrown by <span class="d_inlinecode">std.socket</span>.<p></p>

<dl><dt class="d_decl"><a name=".SocketException.this"></a>this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".SocketException.this"></a>this(string <i>msg</i>, Throwable <i>next</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".lastSocketError"></a>@property string <a name="lastSocketError"></a><span class="ddoc_psymbol">lastSocketError</span>();
</dt>
<dd>Retrieve the error message for the most recently encountered network error.<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOSException"></a>class <a name="SocketOSException"></a><span class="ddoc_psymbol">SocketOSException</span>: <u>std.socket.SocketException</u>;
</dt>
<dd>Socket exceptions representing network errors reported by the operating
<p></p>
system.<p></p>

<dl><dt class="d_decl"><a name=".SocketOSException.errorCode"></a>int <a name="errorCode"></a><span class="ddoc_psymbol">errorCode</span>;
</dt>
<dd>Platform-specific error code.<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOSException.this"></a>this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null, int <i>err</i> = _lasterr(), string function(int) <i>errorFormatter</i> = &amp;formatSocketError);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".SocketOSException.this"></a>this(string <i>msg</i>, Throwable <i>next</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, int <i>err</i> = _lasterr(), string function(int) <i>errorFormatter</i> = &amp;formatSocketError);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".SocketOSException.this"></a>this(string <i>msg</i>, int <i>err</i>, string function(int) <i>errorFormatter</i> = &amp;formatSocketError, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketParameterException"></a>class <a name="SocketParameterException"></a><span class="ddoc_psymbol">SocketParameterException</span>: <u>std.socket.SocketException</u>;
</dt>
<dd>Socket exceptions representing invalid parameters specified by user code.<p></p>

<dl><dt class="d_decl"><a name=".SocketParameterException.this"></a>this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".SocketParameterException.this"></a>this(string <i>msg</i>, Throwable <i>next</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketFeatureException"></a>class <a name="SocketFeatureException"></a><span class="ddoc_psymbol">SocketFeatureException</span>: <u>std.socket.SocketException</u>;
</dt>
<dd>Socket exceptions representing attempts to use network capabilities not
<p></p>
available on the current system.<p></p>

<dl><dt class="d_decl"><a name=".SocketFeatureException.this"></a>this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".SocketFeatureException.this"></a>this(string <i>msg</i>, Throwable <i>next</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".wouldHaveBlocked"></a>bool <a name="wouldHaveBlocked"></a><span class="ddoc_psymbol">wouldHaveBlocked</span>();
</dt>
<dd>Return <span class="d_inlinecode"><b>true</b></span> if the last socket operation failed because the socket
<p></p>
was in non-blocking mode and the operation would have blocked.<p></p>

</dd>
<dt class="d_decl"><a name=".AddressFamily"></a>enum <a name="AddressFamily"></a><span class="ddoc_psymbol">AddressFamily</span>: int;
</dt>
<dd>The communication domain used to resolve an address.<p></p>

<dl><dt class="d_decl"><a name=".AddressFamily.UNSPEC"></a><a name="UNSPEC"></a><span class="ddoc_psymbol">UNSPEC</span></dt>
<dd>Unspecified address family<p></p>

</dd>
<dt class="d_decl"><a name=".AddressFamily.UNIX"></a><a name="UNIX"></a><span class="ddoc_psymbol">UNIX</span></dt>
<dd>Local communication<p></p>

</dd>
<dt class="d_decl"><a name=".AddressFamily.INET"></a><a name="INET"></a><span class="ddoc_psymbol">INET</span></dt>
<dd>Internet Protocol version 4<p></p>

</dd>
<dt class="d_decl"><a name=".AddressFamily.IPX"></a><a name="IPX"></a><span class="ddoc_psymbol">IPX</span></dt>
<dd>Novell <a name="IPX"></a><span class="ddoc_psymbol">IPX</span><p></p>

</dd>
<dt class="d_decl"><a name=".AddressFamily.APPLETALK"></a><a name="APPLETALK"></a><span class="ddoc_psymbol">APPLETALK</span></dt>
<dd>AppleTalk<p></p>

</dd>
<dt class="d_decl"><a name=".AddressFamily.INET6"></a><a name="INET6"></a><span class="ddoc_psymbol">INET6</span></dt>
<dd>Internet Protocol version 6<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketType"></a>enum <a name="SocketType"></a><span class="ddoc_psymbol">SocketType</span>: int;
</dt>
<dd>Communication semantics<p></p>

<dl><dt class="d_decl"><a name=".SocketType.STREAM"></a><a name="STREAM"></a><span class="ddoc_psymbol">STREAM</span></dt>
<dd>Sequenced, reliable, two-way communication-based byte streams<p></p>

</dd>
<dt class="d_decl"><a name=".SocketType.DGRAM"></a><a name="DGRAM"></a><span class="ddoc_psymbol">DGRAM</span></dt>
<dd>Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order<p></p>

</dd>
<dt class="d_decl"><a name=".SocketType.RAW"></a><a name="RAW"></a><span class="ddoc_psymbol">RAW</span></dt>
<dd>Raw protocol access<p></p>

</dd>
<dt class="d_decl"><a name=".SocketType.RDM"></a><a name="RDM"></a><span class="ddoc_psymbol">RDM</span></dt>
<dd>Reliably-delivered message datagrams<p></p>

</dd>
<dt class="d_decl"><a name=".SocketType.SEQPACKET"></a><a name="SEQPACKET"></a><span class="ddoc_psymbol">SEQPACKET</span></dt>
<dd>Sequenced, reliable, two-way connection-based datagrams with a fixed maximum length<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ProtocolType"></a>enum <a name="ProtocolType"></a><span class="ddoc_psymbol">ProtocolType</span>: int;
</dt>
<dd>Protocol<p></p>

<dl><dt class="d_decl"><a name=".ProtocolType.IP"></a><a name="IP"></a><span class="ddoc_psymbol">IP</span></dt>
<dd>Internet Protocol version 4<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.ICMP"></a><a name="ICMP"></a><span class="ddoc_psymbol">ICMP</span></dt>
<dd>Internet Control Message Protocol<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.IGMP"></a><a name="IGMP"></a><span class="ddoc_psymbol">IGMP</span></dt>
<dd>Internet Group Management Protocol<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.GGP"></a><a name="GGP"></a><span class="ddoc_psymbol">GGP</span></dt>
<dd>Gateway to Gateway Protocol<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.TCP"></a><a name="TCP"></a><span class="ddoc_psymbol">TCP</span></dt>
<dd>Transmission Control Protocol<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.PUP"></a><a name="PUP"></a><span class="ddoc_psymbol">PUP</span></dt>
<dd>PARC Universal Packet Protocol<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.UDP"></a><a name="UDP"></a><span class="ddoc_psymbol">UDP</span></dt>
<dd>User Datagram Protocol<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.IDP"></a><a name="IDP"></a><span class="ddoc_psymbol">IDP</span></dt>
<dd>Xerox NS protocol<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.RAW"></a><a name="RAW"></a><span class="ddoc_psymbol">RAW</span></dt>
<dd>Raw IP packets<p></p>

</dd>
<dt class="d_decl"><a name=".ProtocolType.IPV6"></a><a name="IPV6"></a><span class="ddoc_psymbol">IPV6</span></dt>
<dd>Internet Protocol version 6<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Protocol"></a>class <a name="Protocol"></a><span class="ddoc_psymbol">Protocol</span>;
</dt>
<dd><span class="d_inlinecode"><a name="Protocol"></a><span class="ddoc_psymbol">Protocol</span></span> is a class for retrieving protocol information.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> proto = <span class="d_keyword">new</span> <span class="d_psymbol">Protocol</span>;
writeln(<span class="d_string">"About protocol TCP:"</span>);
<span class="d_keyword">if</span> (proto.getProtocolByType(ProtocolType.TCP))
{
    writefln(<span class="d_string">"  Name: %s"</span>, proto.name);
    <span class="d_keyword">foreach</span>(string s; proto.aliases)
         writefln(<span class="d_string">"  Alias: %s"</span>, s);
}
<span class="d_keyword">else</span>
    writeln(<span class="d_string">"  No information found"</span>);
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".Protocol.type"></a>ProtocolType <a name="type"></a><span class="ddoc_psymbol">type</span>;
<br><a name=".Protocol.name"></a>string <a name="name"></a><span class="ddoc_psymbol">name</span>;
<br><a name=".Protocol.aliases"></a>string[] <a name="aliases"></a><span class="ddoc_psymbol">aliases</span>;
</dt>
<dd>These members are populated when one of the following functions are called successfully:<p></p>

</dd>
<dt class="d_decl"><a name=".Protocol.getProtocolByName"></a>bool <a name="getProtocolByName"></a><span class="ddoc_psymbol">getProtocolByName</span>(in char[] <i>name</i>);
</dt>
<dd><b>Returns:</b><br><b>false</b> on failure<p></p>

</dd>
<dt class="d_decl"><a name=".Protocol.getProtocolByType"></a>bool <a name="getProtocolByType"></a><span class="ddoc_psymbol">getProtocolByType</span>(ProtocolType <i>type</i>);
</dt>
<dd><b>Returns:</b><br><b>false</b> on failure<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Service"></a>class <a name="Service"></a><span class="ddoc_psymbol">Service</span>;
</dt>
<dd><span class="d_inlinecode"><a name="Service"></a><span class="ddoc_psymbol">Service</span></span> is a class for retrieving service information.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> serv = <span class="d_keyword">new</span> <span class="d_psymbol">Service</span>;
writeln(<span class="d_string">"About service epmap:"</span>);
<span class="d_keyword">if</span> (serv.getServiceByName(<span class="d_string">"epmap"</span>, <span class="d_string">"tcp"</span>))
{
    writefln(<span class="d_string">"  Service: %s"</span>, serv.name);
    writefln(<span class="d_string">"  Port: %d"</span>, serv.port);
    writefln(<span class="d_string">"  Protocol: %s"</span>, serv.protocolName);
    <span class="d_keyword">foreach</span> (string s; serv.aliases)
         writefln(<span class="d_string">"  Alias: %s"</span>, s);
}
<span class="d_keyword">else</span>
    writefln(<span class="d_string">"  No service for epmap."</span>);
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".Service.name"></a>string <a name="name"></a><span class="ddoc_psymbol">name</span>;
<br><a name=".Service.aliases"></a>string[] <a name="aliases"></a><span class="ddoc_psymbol">aliases</span>;
<br><a name=".Service.port"></a>ushort <a name="port"></a><span class="ddoc_psymbol">port</span>;
<br><a name=".Service.protocolName"></a>string <a name="protocolName"></a><span class="ddoc_psymbol">protocolName</span>;
</dt>
<dd>These members are populated when one of the following functions are called successfully:<p></p>

</dd>
<dt class="d_decl"><a name=".Service.getServiceByName"></a>bool <a name="getServiceByName"></a><span class="ddoc_psymbol">getServiceByName</span>(in char[] <i>name</i>, in char[] <i>protocolName</i> = null);
<br><a name=".Service.getServiceByPort"></a>bool <a name="getServiceByPort"></a><span class="ddoc_psymbol">getServiceByPort</span>(ushort <i>port</i>, in char[] <i>protocolName</i> = null);
</dt>
<dd>If a protocol <i>name</i> is omitted, any protocol will be matched.
<p></p>
<b>Returns:</b><br><b>false</b> on failure.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".HostException"></a>class <a name="HostException"></a><span class="ddoc_psymbol">HostException</span>: <u>std.socket.SocketOSException</u>;
</dt>
<dd>Class for exceptions thrown from an <span class="d_inlinecode">InternetHost</span>.<p></p>

<dl><dt class="d_decl"><a name=".HostException.this"></a>this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null, int <i>err</i> = _lasterr());
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".HostException.this"></a>this(string <i>msg</i>, Throwable <i>next</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, int <i>err</i> = _lasterr());
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".HostException.this"></a>this(string <i>msg</i>, int <i>err</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".InternetHost"></a>class <a name="InternetHost"></a><span class="ddoc_psymbol">InternetHost</span>;
</dt>
<dd><span class="d_inlinecode"><a name="InternetHost"></a><span class="ddoc_psymbol">InternetHost</span></span> is a class for resolving IPv4 addresses.
<p></p>
Consider using <span class="d_inlinecode">getAddress</span>, <span class="d_inlinecode">parseAddress</span> and <span class="d_inlinecode">Address</span> methods
 instead of using this class directly.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> ih = <span class="d_keyword">new</span> <span class="d_psymbol">InternetHost</span>;

<span class="d_comment">// Forward lookup
</span>writeln(<span class="d_string">"About www.digitalmars.com:"</span>);
<span class="d_keyword">if</span> (ih.getHostByName(<span class="d_string">"www.digitalmars.com"</span>))
{
    writefln(<span class="d_string">"  Name: %s"</span>, ih.name);
    <span class="d_keyword">auto</span> ip = InternetAddress.addrToString(ih.addrList[0]);
    writefln(<span class="d_string">"  IP address: %s"</span>, ip);
    <span class="d_keyword">foreach</span> (string s; ih.aliases)
         writefln(<span class="d_string">"  Alias: %s"</span>, s);
    writeln(<span class="d_string">"---"</span>);

    <span class="d_comment">// Reverse lookup
</span>    writefln(<span class="d_string">"About IP %s:"</span>, ip);
    <span class="d_keyword">if</span> (ih.getHostByAddr(ih.addrList[0]))
    {
        writefln(<span class="d_string">"  Name: %s"</span>, ih.name);
        <span class="d_keyword">foreach</span> (string s; ih.aliases)
             writefln(<span class="d_string">"  Alias: %s"</span>, s);
    }
    <span class="d_keyword">else</span>
        writeln(<span class="d_string">"  Reverse lookup failed"</span>);
}
<span class="d_keyword">else</span>
    writeln(<span class="d_string">"  Can't resolve www.digitalmars.com"</span>);
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".InternetHost.name"></a>string <a name="name"></a><span class="ddoc_psymbol">name</span>;
<br><a name=".InternetHost.aliases"></a>string[] <a name="aliases"></a><span class="ddoc_psymbol">aliases</span>;
<br><a name=".InternetHost.addrList"></a>uint[] <a name="addrList"></a><span class="ddoc_psymbol">addrList</span>;
</dt>
<dd>These members are populated when one of the following functions are called successfully:<p></p>

</dd>
<dt class="d_decl"><a name=".InternetHost.getHostByName"></a>bool <a name="getHostByName"></a><span class="ddoc_psymbol">getHostByName</span>(in char[] <i>name</i>);
</dt>
<dd>Resolve host <i>name</i>.
<p></p>
<b>Returns:</b><br><b>false</b> if unable to resolve.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetHost.getHostByAddr"></a>bool <a name="getHostByAddr"></a><span class="ddoc_psymbol">getHostByAddr</span>(uint <i>addr</i>);
</dt>
<dd>Resolve IPv4 address number.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>uint <i>addr</i></td>
<td valign=top>The IPv4 address to resolve, in host byte order.</td></tr>
</table><p></p>
<b>Returns:</b><br><b>false</b> if unable to resolve.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetHost.getHostByAddr"></a>bool <a name="getHostByAddr"></a><span class="ddoc_psymbol">getHostByAddr</span>(in char[] <i>addr</i>);
</dt>
<dd>Same as previous, but <i>addr</i> is an IPv4 address string in the
 dotted-decimal form <i>a.b.c.d</i>.
<p></p>
<b>Returns:</b><br><b>false</b> if unable to resolve.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".AddressInfo"></a>struct <a name="AddressInfo"></a><span class="ddoc_psymbol">AddressInfo</span>;
</dt>
<dd>Holds information about a socket address retrieved by <span class="d_inlinecode">getAddressInfo</span>.<p></p>

<dl><dt class="d_decl"><a name=".AddressInfo.family"></a>AddressFamily <a name="family"></a><span class="ddoc_psymbol">family</span>;
</dt>
<dd>Address family<p></p>

</dd>
<dt class="d_decl"><a name=".AddressInfo.type"></a>SocketType <a name="type"></a><span class="ddoc_psymbol">type</span>;
</dt>
<dd>Socket type<p></p>

</dd>
<dt class="d_decl"><a name=".AddressInfo.protocol"></a>ProtocolType <a name="protocol"></a><span class="ddoc_psymbol">protocol</span>;
</dt>
<dd>Protocol<p></p>

</dd>
<dt class="d_decl"><a name=".AddressInfo.address"></a>Address <a name="address"></a><span class="ddoc_psymbol">address</span>;
</dt>
<dd>Socket address<p></p>

</dd>
<dt class="d_decl"><a name=".AddressInfo.canonicalName"></a>string <a name="canonicalName"></a><span class="ddoc_psymbol">canonicalName</span>;
</dt>
<dd>Canonical name, when <span class="d_inlinecode">AddressInfoFlags.CANONNAME</span> is used.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".AddressInfoFlags"></a>enum <a name="AddressInfoFlags"></a><span class="ddoc_psymbol">AddressInfoFlags</span>: int;
</dt>
<dd>Specifies option flags for <span class="d_inlinecode">getAddressInfo</span>.<p></p>

<dl><dt class="d_decl"><a name=".AddressInfoFlags.PASSIVE"></a><a name="PASSIVE"></a><span class="ddoc_psymbol">PASSIVE</span></dt>
<dd>The resulting addresses will be used in a call to <span class="d_inlinecode">Socket.bind</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".AddressInfoFlags.CANONNAME"></a><a name="CANONNAME"></a><span class="ddoc_psymbol">CANONNAME</span></dt>
<dd>The canonical name is returned in <span class="d_inlinecode">canonicalName</span> member in the first <span class="d_inlinecode">AddressInfo</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".AddressInfoFlags.NUMERICHOST"></a><a name="NUMERICHOST"></a><span class="ddoc_psymbol">NUMERICHOST</span></dt>
<dd>The <span class="d_inlinecode">node</span> parameter passed to <span class="d_inlinecode">getAddressInfo</span> must be a numeric string.
<p></p>
This will suppress any potentially lengthy network host address lookups.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".getAddressInfo"></a>AddressInfo[] <a name="getAddressInfo"></a><span class="ddoc_psymbol">getAddressInfo</span>(T...)(in char[] <i>node</i>, T <i>options</i>);
</dt>
<dd>Provides protocol-independent translation from host names to socket
 addresses. If advanced functionality is not required, consider using
 <span class="d_inlinecode">getAddress</span> for compatibility with older systems.
<p></p>
<b>Returns:</b><br>Array with one <span class="d_inlinecode">AddressInfo</span> per socket address.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">SocketOSException</span> on failure, or <span class="d_inlinecode">SocketFeatureException</span>
 if this functionality is not available on the current system.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>char[] node</td>
<td valign=top>string containing host name or numeric address</td></tr>
<tr><td valign=top>T options</td>
<td valign=top>optional additional parameters, identified by type:
             <ul><li><span class="d_inlinecode">string</span> - service name or port number</li>
                  <li><span class="d_inlinecode">AddressInfoFlags</span> - option flags</li>
                  <li><span class="d_inlinecode">AddressFamily</span> - address family to filter by</li>
                  <li><span class="d_inlinecode">SocketType</span> - socket type to filter by</li>
                  <li><span class="d_inlinecode">ProtocolType</span> - protocol to filter by</li></ul></td></tr>
</table><p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Roundtrip DNS resolution
</span><span class="d_keyword">auto</span> results = <span class="d_psymbol">getAddressInfo</span>(<span class="d_string">"www.digitalmars.com"</span>);
<span class="d_keyword">assert</span>(results[0].address.toHostNameString() ==
    <span class="d_string">"digitalmars.com"</span>);

<span class="d_comment">// Canonical name
</span>results = <span class="d_psymbol">getAddressInfo</span>(<span class="d_string">"www.digitalmars.com"</span>,
    AddressInfoFlags.CANONNAME);
<span class="d_keyword">assert</span>(results[0].canonicalName == <span class="d_string">"digitalmars.com"</span>);

<span class="d_comment">// IPv6 resolution
</span>results = <span class="d_psymbol">getAddressInfo</span>(<span class="d_string">"ipv6.google.com"</span>);
<span class="d_keyword">assert</span>(results[0].family == AddressFamily.INET6);

<span class="d_comment">// Multihomed resolution
</span>results = <span class="d_psymbol">getAddressInfo</span>(<span class="d_string">"google.com"</span>);
<span class="d_keyword">assert</span>(results.length &gt; 1);

<span class="d_comment">// Parsing IPv4
</span>results = <span class="d_psymbol">getAddressInfo</span>(<span class="d_string">"127.0.0.1"</span>,
    AddressInfoFlags.NUMERICHOST);
<span class="d_keyword">assert</span>(results.length &amp;&amp; results[0].family ==
    AddressFamily.INET);

<span class="d_comment">// Parsing IPv6
</span>results = <span class="d_psymbol">getAddressInfo</span>(<span class="d_string">"::1"</span>,
    AddressInfoFlags.NUMERICHOST);
<span class="d_keyword">assert</span>(results.length &amp;&amp; results[0].family ==
    AddressFamily.INET6);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".getAddress"></a>Address[] <a name="getAddress"></a><span class="ddoc_psymbol">getAddress</span>(in char[] <i>hostname</i>, in char[] <i>service</i> = null);
<br><a name=".getAddress"></a>Address[] <a name="getAddress"></a><span class="ddoc_psymbol">getAddress</span>(in char[] <i>hostname</i>, ushort <i>port</i>);
</dt>
<dd>Provides protocol-independent translation from host names to socket
 addresses. Uses <span class="d_inlinecode">getAddressInfo</span> if the current system supports it,
 and <span class="d_inlinecode">InternetHost</span> otherwise.
<p></p>
<b>Returns:</b><br>Array with one <span class="d_inlinecode">Address</span> instance per socket address.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">SocketOSException</span> on failure.

<p></p>
<b>Example:</b><br>
<pre class="d_code">writeln(<span class="d_string">"Resolving www.digitalmars.com:"</span>);
<span class="d_keyword">try</span>
{
    <span class="d_keyword">auto</span> addresses = <span class="d_psymbol">getAddress</span>(<span class="d_string">"www.digitalmars.com"</span>);
    <span class="d_keyword">foreach</span> (address; addresses)
        writefln(<span class="d_string">"  IP: %s"</span>, address.toAddrString());
}
<span class="d_keyword">catch</span> (SocketException e)
    writefln(<span class="d_string">"  Lookup failed: %s"</span>, e.msg);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".parseAddress"></a>Address <a name="parseAddress"></a><span class="ddoc_psymbol">parseAddress</span>(in char[] <i>hostaddr</i>, in char[] <i>service</i> = null);
<br><a name=".parseAddress"></a>Address <a name="parseAddress"></a><span class="ddoc_psymbol">parseAddress</span>(in char[] <i>hostaddr</i>, ushort <i>port</i>);
</dt>
<dd>Provides protocol-independent parsing of network addresses. Does not
 attempt name resolution. Uses <span class="d_inlinecode">getAddressInfo</span> with
 <span class="d_inlinecode">AddressInfoFlags.NUMERICHOST</span> if the current system supports it, and
 <span class="d_inlinecode">InternetAddress</span> otherwise.
<p></p>
<b>Returns:</b><br>An <span class="d_inlinecode">Address</span> instance representing specified address.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">SocketException</span> on failure.

<p></p>
<b>Example:</b><br>
<pre class="d_code">writeln(<span class="d_string">"Enter IP address:"</span>);
string ip = readln().chomp();
<span class="d_keyword">try</span>
{
    Address address = <span class="d_psymbol">parseAddress</span>(ip);
    writefln(<span class="d_string">"Looking up reverse of %s:"</span>,
        address.toAddrString());
    <span class="d_keyword">try</span>
    {
        string reverse = address.toHostNameString();
        <span class="d_keyword">if</span> (reverse)
            writefln(<span class="d_string">"  Reverse name: %s"</span>, reverse);
        <span class="d_keyword">else</span>
            writeln(<span class="d_string">"  Reverse hostname not found."</span>);
    }
    <span class="d_keyword">catch</span> (SocketException e)
        writefln(<span class="d_string">"  Lookup error: %s"</span>, e.msg);
}
<span class="d_keyword">catch</span> (SocketException e)
{
    writefln(<span class="d_string">"  %s is not a valid IP address: %s"</span>,
        ip, e.msg);
}
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".AddressException"></a>class <a name="AddressException"></a><span class="ddoc_psymbol">AddressException</span>: <u>std.socket.SocketOSException</u>;
</dt>
<dd>Class for exceptions thrown from an <span class="d_inlinecode">Address</span>.<p></p>

<dl><dt class="d_decl"><a name=".AddressException.this"></a>this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null, int <i>err</i> = _lasterr());
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".AddressException.this"></a>this(string <i>msg</i>, Throwable <i>next</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, int <i>err</i> = _lasterr());
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".AddressException.this"></a>this(string <i>msg</i>, int <i>err</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Address"></a>abstract class <a name="Address"></a><span class="ddoc_psymbol">Address</span>;
</dt>
<dd><span class="d_inlinecode"><a name="Address"></a><span class="ddoc_psymbol">Address</span></span> is an abstract class for representing a socket addresses.
<p></p>
<b>Example:</b><br>
<pre class="d_code">writeln(<span class="d_string">"About www.google.com port 80:"</span>);
<span class="d_keyword">try</span>
{
    <span class="d_psymbol">Address</span>[] addresses = getAddress(<span class="d_string">"www.google.com"</span>, 80);
    writefln(<span class="d_string">"  %d addresses found."</span>, addresses.length);
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> i, <span class="d_psymbol">Address</span> a; addresses)
    {
        writefln(<span class="d_string">"  Address %d:"</span>, i+1);
        writefln(<span class="d_string">"    IP address: %s"</span>, a.toAddrString());
        writefln(<span class="d_string">"    Hostname: %s"</span>, a.toHostNameString());
        writefln(<span class="d_string">"    Port: %s"</span>, a.toPortString());
        writefln(<span class="d_string">"    Service name: %s"</span>,
            a.toServiceNameString());
    }
}
<span class="d_keyword">catch</span> (SocketException e)
    writefln(<span class="d_string">"  Lookup error: %s"</span>, e.msg);
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".Address.name"></a>abstract @property sockaddr* <a name="name"></a><span class="ddoc_psymbol">name</span>();
<br><a name=".Address.name"></a>abstract const @property const(sockaddr)* <a name="name"></a><span class="ddoc_psymbol">name</span>();
</dt>
<dd>Returns pointer to underlying <span class="d_inlinecode">sockaddr</span> structure.<p></p>

</dd>
<dt class="d_decl"><a name=".Address.nameLen"></a>abstract const @property socklen_t <a name="nameLen"></a><span class="ddoc_psymbol">nameLen</span>();
</dt>
<dd>Returns actual size of underlying <span class="d_inlinecode">sockaddr</span> structure.<p></p>

</dd>
<dt class="d_decl"><a name=".Address.addressFamily"></a>const @property AddressFamily <a name="addressFamily"></a><span class="ddoc_psymbol">addressFamily</span>();
</dt>
<dd>Family of this address.<p></p>

</dd>
<dt class="d_decl"><a name=".Address.toAddrString"></a>const string <a name="toAddrString"></a><span class="ddoc_psymbol">toAddrString</span>();
</dt>
<dd>Attempts to retrieve the host address as a human-readable string.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">AddressException</span> on failure, or <span class="d_inlinecode">SocketFeatureException</span>
 if address retrieval for this address family is not available on the
 current system.<p></p>

</dd>
<dt class="d_decl"><a name=".Address.toHostNameString"></a>const string <a name="toHostNameString"></a><span class="ddoc_psymbol">toHostNameString</span>();
</dt>
<dd>Attempts to retrieve the host name as a fully qualified domain name.
<p></p>
<b>Returns:</b><br>The FQDN corresponding to this <span class="d_inlinecode">Address</span>, or <span class="d_inlinecode"><b>null</b></span> if
 the host name did not resolve.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">AddressException</span> on error, or <span class="d_inlinecode">SocketFeatureException</span>
 if host name lookup for this address family is not available on the
 current system.<p></p>

</dd>
<dt class="d_decl"><a name=".Address.toPortString"></a>const string <a name="toPortString"></a><span class="ddoc_psymbol">toPortString</span>();
</dt>
<dd>Attempts to retrieve the numeric port number as a string.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">AddressException</span> on failure, or <span class="d_inlinecode">SocketFeatureException</span>
 if port number retrieval for this address family is not available on the
 current system.<p></p>

</dd>
<dt class="d_decl"><a name=".Address.toServiceNameString"></a>const string <a name="toServiceNameString"></a><span class="ddoc_psymbol">toServiceNameString</span>();
</dt>
<dd>Attempts to retrieve the service name as a string.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">AddressException</span> on failure, or <span class="d_inlinecode">SocketFeatureException</span>
 if service name lookup for this address family is not available on the
 current system.<p></p>

</dd>
<dt class="d_decl"><a name=".Address.toString"></a>const string <a name="toString"></a><span class="ddoc_psymbol">toString</span>();
</dt>
<dd>Human readable string representing this address.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".UnknownAddress"></a>class <a name="UnknownAddress"></a><span class="ddoc_psymbol">UnknownAddress</span>: <u>std.socket.Address</u>;
</dt>
<dd><span class="d_inlinecode"><a name="UnknownAddress"></a><span class="ddoc_psymbol">UnknownAddress</span></span> encapsulates an unknown socket address.<p></p>

</dd>
<dt class="d_decl"><a name=".UnknownAddressReference"></a>class <a name="UnknownAddressReference"></a><span class="ddoc_psymbol">UnknownAddressReference</span>: <u>std.socket.Address</u>;
</dt>
<dd><span class="d_inlinecode"><a name="UnknownAddressReference"></a><span class="ddoc_psymbol">UnknownAddressReference</span></span> encapsulates a reference to an arbitrary
 socket address.<p></p>

<dl><dt class="d_decl"><a name=".UnknownAddressReference.this"></a>this(sockaddr* <i>sa</i>, socklen_t <i>len</i>);
</dt>
<dd>Constructs an <span class="d_inlinecode">Address</span> with a reference to the specified <span class="d_inlinecode">sockaddr</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".UnknownAddressReference.this"></a>this(const(sockaddr)* <i>sa</i>, socklen_t <i>len</i>);
</dt>
<dd>Constructs an <span class="d_inlinecode">Address</span> with a copy of the specified <span class="d_inlinecode">sockaddr</span>.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".InternetAddress"></a>class <a name="InternetAddress"></a><span class="ddoc_psymbol">InternetAddress</span>: <u>std.socket.Address</u>;
</dt>
<dd><span class="d_inlinecode"><a name="InternetAddress"></a><span class="ddoc_psymbol">InternetAddress</span></span> encapsulates an IPv4 (Internet Protocol version 4)
 socket address.
<p></p>
Consider using <span class="d_inlinecode">getAddress</span>, <span class="d_inlinecode">parseAddress</span> and <span class="d_inlinecode">Address</span> methods
 instead of using this class directly.<p></p>

<dl><dt class="d_decl"><a name=".InternetAddress.ADDR_ANY"></a>uint <a name="ADDR_ANY"></a><span class="ddoc_psymbol">ADDR_ANY</span>;
</dt>
<dd>Any IPv4 host address.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.ADDR_NONE"></a>uint <a name="ADDR_NONE"></a><span class="ddoc_psymbol">ADDR_NONE</span>;
</dt>
<dd>An invalid IPv4 host address.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.PORT_ANY"></a>ushort <a name="PORT_ANY"></a><span class="ddoc_psymbol">PORT_ANY</span>;
</dt>
<dd>Any IPv4 port number.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.port"></a>const @property ushort <a name="port"></a><span class="ddoc_psymbol">port</span>();
</dt>
<dd>Returns the IPv4 port number (in host byte order).<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.addr"></a>const @property uint <a name="addr"></a><span class="ddoc_psymbol">addr</span>();
</dt>
<dd>Returns the IPv4 address number (in host byte order).<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.this"></a>this(in char[] <i>addr</i>, ushort <i>port</i>);
</dt>
<dd>Construct a new <span class="d_inlinecode">InternetAddress</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>char[] <i>addr</i></td>
<td valign=top>an IPv4 address string in the dotted-decimal form a.b.c.d,
          or a host name which will be resolved using an <span class="d_inlinecode">InternetHost</span>
          object.</td></tr>
<tr><td valign=top>ushort <i>port</i></td>
<td valign=top><i>port</i> number, may be <span class="d_inlinecode">PORT_ANY</span>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.this"></a>this(uint <i>addr</i>, ushort <i>port</i>);
<br><a name=".InternetAddress.this"></a>this(ushort <i>port</i>);
</dt>
<dd>Construct a new <span class="d_inlinecode">InternetAddress</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>uint <i>addr</i></td>
<td valign=top>(optional) an IPv4 address in host byte order, may be <span class="d_inlinecode">ADDR_ANY</span>.</td></tr>
<tr><td valign=top>ushort <i>port</i></td>
<td valign=top><i>port</i> number, may be <span class="d_inlinecode">PORT_ANY</span>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.toAddrString"></a>const string <a name="toAddrString"></a><span class="ddoc_psymbol">toAddrString</span>();
</dt>
<dd>Human readable string representing the IPv4 address in dotted-decimal form.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.toPortString"></a>const string <a name="toPortString"></a><span class="ddoc_psymbol">toPortString</span>();
</dt>
<dd>Human readable string representing the IPv4 port.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.toHostNameString"></a>const string <a name="toHostNameString"></a><span class="ddoc_psymbol">toHostNameString</span>();
</dt>
<dd>Attempts to retrieve the host name as a fully qualified domain name.
<p></p>
<b>Returns:</b><br>The FQDN corresponding to this <span class="d_inlinecode">InternetAddress</span>, or
 <span class="d_inlinecode"><b>null</b></span> if the host name did not resolve.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">AddressException</span> on error.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.parse"></a>static uint <a name="parse"></a><span class="ddoc_psymbol">parse</span>(in char[] <i>addr</i>);
</dt>
<dd>Parse an IPv4 address string in the dotted-decimal form <i>a.b.c.d</i>
 and return the number.
<p></p>
<b>Returns:</b><br>If the string is not a legitimate IPv4 address,
 <span class="d_inlinecode">ADDR_NONE</span> is returned.<p></p>

</dd>
<dt class="d_decl"><a name=".InternetAddress.addrToString"></a>static string <a name="addrToString"></a><span class="ddoc_psymbol">addrToString</span>(uint <i>addr</i>);
</dt>
<dd>Convert an IPv4 address number in host byte order to a human readable
 string representing the IPv4 address in dotted-decimal form.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Internet6Address"></a>class <a name="Internet6Address"></a><span class="ddoc_psymbol">Internet6Address</span>: <u>std.socket.Address</u>;
</dt>
<dd><span class="d_inlinecode"><a name="Internet6Address"></a><span class="ddoc_psymbol">Internet6Address</span></span> encapsulates an IPv6 (Internet Protocol version 6)
 socket address.
<p></p>
Consider using <span class="d_inlinecode">getAddress</span>, <span class="d_inlinecode">parseAddress</span> and <span class="d_inlinecode">Address</span> methods
 instead of using this class directly.<p></p>

<dl><dt class="d_decl"><a name=".Internet6Address.ADDR_ANY"></a>static @property ref const(ubyte)[16] <a name="ADDR_ANY"></a><span class="ddoc_psymbol">ADDR_ANY</span>();
</dt>
<dd>Any IPv6 host address.<p></p>

</dd>
<dt class="d_decl"><a name=".Internet6Address.PORT_ANY"></a>ushort <a name="PORT_ANY"></a><span class="ddoc_psymbol">PORT_ANY</span>;
</dt>
<dd>Any IPv6 port number.<p></p>

</dd>
<dt class="d_decl"><a name=".Internet6Address.port"></a>const @property ushort <a name="port"></a><span class="ddoc_psymbol">port</span>();
</dt>
<dd>Returns the IPv6 <a name="port"></a><span class="ddoc_psymbol">port</span> number.<p></p>

</dd>
<dt class="d_decl"><a name=".Internet6Address.addr"></a>const @property ubyte[16] <a name="addr"></a><span class="ddoc_psymbol">addr</span>();
</dt>
<dd>Returns the IPv6 address.<p></p>

</dd>
<dt class="d_decl"><a name=".Internet6Address.this"></a>this(in char[] <i>addr</i>, in char[] <i>service</i> = null);
</dt>
<dd>Construct a new <span class="d_inlinecode">Internet6Address</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>char[] <i>addr</i></td>
<td valign=top>an IPv6 host address string in the form described in RFC 2373,
             or a host name which will be resolved using <span class="d_inlinecode">getAddressInfo</span>.</td></tr>
<tr><td valign=top>char[] <i>service</i></td>
<td valign=top>(optional) <i>service</i> name.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".Internet6Address.this"></a>this(in char[] <i>addr</i>, ushort <i>port</i>);
</dt>
<dd>Construct a new <span class="d_inlinecode">Internet6Address</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>char[] <i>addr</i></td>
<td valign=top>an IPv6 host address string in the form described in RFC 2373,
          or a host name which will be resolved using <span class="d_inlinecode">getAddressInfo</span>.</td></tr>
<tr><td valign=top>ushort <i>port</i></td>
<td valign=top><i>port</i> number, may be <span class="d_inlinecode">PORT_ANY</span>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".Internet6Address.this"></a>this(ubyte[16] <i>addr</i>, ushort <i>port</i>);
<br><a name=".Internet6Address.this"></a>this(ushort <i>port</i>);
</dt>
<dd>Construct a new <span class="d_inlinecode">Internet6Address</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>ubyte[16] <i>addr</i></td>
<td valign=top>(optional) an IPv6 host address in host byte order, or
          <span class="d_inlinecode">ADDR_ANY</span>.</td></tr>
<tr><td valign=top>ushort <i>port</i></td>
<td valign=top><i>port</i> number, may be <span class="d_inlinecode">PORT_ANY</span>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".Internet6Address.parse"></a>static ubyte[16] <a name="parse"></a><span class="ddoc_psymbol">parse</span>(in char[] <i>addr</i>);
</dt>
<dd>Parse an IPv6 host address string as described in RFC 2373, and return the
 address.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">SocketException</span> on error.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".UnixAddress"></a>abstract class <a name="UnixAddress"></a><span class="ddoc_psymbol">UnixAddress</span>: <u>std.socket.Address</u>;
</dt>
<dd><span class="d_inlinecode"><a name="UnixAddress"></a><span class="ddoc_psymbol">UnixAddress</span></span> encapsulates an address for a Unix domain socket
 (<span class="d_inlinecode">AF_UNIX</span>). Available only on supported systems.<p></p>

<dl><dt class="d_decl"><a name=".UnixAddress.this"></a>this(in char[] <i>path</i>);
</dt>
<dd>Construct a new <span class="d_inlinecode">UnixAddress</span> from the specified <i>path</i>.<p></p>

</dd>
<dt class="d_decl"><a name=".UnixAddress.path"></a>const @property string <a name="path"></a><span class="ddoc_psymbol">path</span>();
<br><a name=".UnixAddress.toString"></a>const string <a name="toString"></a><span class="ddoc_psymbol">toString</span>();
</dt>
<dd>Get the underlying path.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketAcceptException"></a>class <a name="SocketAcceptException"></a><span class="ddoc_psymbol">SocketAcceptException</span>: <u>std.socket.SocketOSException</u>;
</dt>
<dd>Class for exceptions thrown by <span class="d_inlinecode">Socket.accept</span>.<p></p>

<dl><dt class="d_decl"><a name=".SocketAcceptException.this"></a>this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null, int <i>err</i> = _lasterr());
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".SocketAcceptException.this"></a>this(string <i>msg</i>, Throwable <i>next</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, int <i>err</i> = _lasterr());
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".SocketAcceptException.this"></a>this(string <i>msg</i>, int <i>err</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketShutdown"></a>enum <a name="SocketShutdown"></a><span class="ddoc_psymbol">SocketShutdown</span>: int;
</dt>
<dd>How a socket is shutdown:<p></p>

<dl><dt class="d_decl"><a name=".SocketShutdown.RECEIVE"></a><a name="RECEIVE"></a><span class="ddoc_psymbol">RECEIVE</span></dt>
<dd>socket receives are disallowed<p></p>

</dd>
<dt class="d_decl"><a name=".SocketShutdown.SEND"></a><a name="SEND"></a><span class="ddoc_psymbol">SEND</span></dt>
<dd>socket sends are disallowed<p></p>

</dd>
<dt class="d_decl"><a name=".SocketShutdown.BOTH"></a><a name="BOTH"></a><span class="ddoc_psymbol">BOTH</span></dt>
<dd>both RECEIVE and SEND<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketFlags"></a>enum <a name="SocketFlags"></a><span class="ddoc_psymbol">SocketFlags</span>: int;
</dt>
<dd>Flags may be OR'ed together:<p></p>

<dl><dt class="d_decl"><a name=".SocketFlags.NONE"></a><a name="NONE"></a><span class="ddoc_psymbol">NONE</span></dt>
<dd>no flags specified<p></p>

</dd>
<dt class="d_decl"><a name=".SocketFlags.OOB"></a><a name="OOB"></a><span class="ddoc_psymbol">OOB</span></dt>
<dd>out-of-band stream data<p></p>

</dd>
<dt class="d_decl"><a name=".SocketFlags.PEEK"></a><a name="PEEK"></a><span class="ddoc_psymbol">PEEK</span></dt>
<dd>peek at incoming data without removing it from the queue, only for receiving<p></p>

</dd>
<dt class="d_decl"><a name=".SocketFlags.DONTROUTE"></a><a name="DONTROUTE"></a><span class="ddoc_psymbol">DONTROUTE</span></dt>
<dd>data should not be subject to routing; this flag may be ignored. Only for sending<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".TimeVal"></a>struct <a name="TimeVal"></a><span class="ddoc_psymbol">TimeVal</span>;
</dt>
<dd>Duration timeout value.<p></p>

<dl><dt class="d_decl"><a name=".TimeVal.seconds"></a>tv_sec_t <a name="seconds"></a><span class="ddoc_psymbol">seconds</span>;
</dt>
<dd>Number of seconds.<p></p>

</dd>
<dt class="d_decl"><a name=".TimeVal.microseconds"></a>tv_usec_t <a name="microseconds"></a><span class="ddoc_psymbol">microseconds</span>;
</dt>
<dd>Number of additional microseconds.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketSet"></a>class <a name="SocketSet"></a><span class="ddoc_psymbol">SocketSet</span>;
</dt>
<dd>A collection of sockets for use with <span class="d_inlinecode">Socket.select</span>.
<p></p>
<span class="d_inlinecode"><a name="SocketSet"></a><span class="ddoc_psymbol">SocketSet</span></span> wraps the platform <span class="d_inlinecode">fd_set</span> type. However, unlike
 <span class="d_inlinecode">fd_set</span>, <span class="d_inlinecode"><a name="SocketSet"></a><span class="ddoc_psymbol">SocketSet</span></span> is not statically limited to <span class="d_inlinecode">FD_SETSIZE</span>
 or any other limit, and grows as needed.<p></p>

<dl><dt class="d_decl"><a name=".SocketSet.this"></a>this(size_t <i>size</i> = FD_SETSIZE);
</dt>
<dd>Create a SocketSet with a specific initial capacity (defaults to
 <span class="d_inlinecode">FD_SETSIZE</span>, the system's default capacity).<p></p>

</dd>
<dt class="d_decl"><a name=".SocketSet.reset"></a>void <a name="reset"></a><span class="ddoc_psymbol">reset</span>();
</dt>
<dd>Reset the <span class="d_inlinecode">SocketSet</span> so that there are 0 <span class="d_inlinecode">Socket</span>s in the collection.<p></p>

</dd>
<dt class="d_decl"><a name=".SocketSet.add"></a>void <a name="add"></a><span class="ddoc_psymbol">add</span>(Socket <i>s</i>);
</dt>
<dd>Add a <span class="d_inlinecode">Socket</span> to the collection.
<p></p>
The socket must not already be in the collection.<p></p>

</dd>
<dt class="d_decl"><a name=".SocketSet.remove"></a>void <a name="remove"></a><span class="ddoc_psymbol">remove</span>(Socket <i>s</i>);
</dt>
<dd>Remove this <span class="d_inlinecode">Socket</span> from the collection.
<p></p>
Does nothing if the socket is not in the collection already.<p></p>

</dd>
<dt class="d_decl"><a name=".SocketSet.isSet"></a>const int <a name="isSet"></a><span class="ddoc_psymbol">isSet</span>(Socket <i>s</i>);
</dt>
<dd>Return nonzero if this <span class="d_inlinecode">Socket</span> is in the collection.<p></p>

</dd>
<dt class="d_decl"><a name=".SocketSet.max"></a>const @property uint <a name="max"></a><span class="ddoc_psymbol">max</span>();
</dt>
<dd>Return the current capacity of this <span class="d_inlinecode">SocketSet</span>. The exact
<p></p>
meaning of the return value varies from platform to platform.
<p></p>

Note that since D 2.065, this value does not indicate a
<p></p>

restriction, and <span class="d_inlinecode">SocketSet</span> will grow its capacity as
<p></p>

needed automatically.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketOptionLevel"></a>enum <a name="SocketOptionLevel"></a><span class="ddoc_psymbol">SocketOptionLevel</span>: int;
</dt>
<dd>The level at which a socket option is defined:<p></p>

<dl><dt class="d_decl"><a name=".SocketOptionLevel.SOCKET"></a><a name="SOCKET"></a><span class="ddoc_psymbol">SOCKET</span></dt>
<dd>Socket level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.IP"></a><a name="IP"></a><span class="ddoc_psymbol">IP</span></dt>
<dd>Internet Protocol version 4 level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.ICMP"></a><a name="ICMP"></a><span class="ddoc_psymbol">ICMP</span></dt>
<dd>Internet Control Message Protocol level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.IGMP"></a><a name="IGMP"></a><span class="ddoc_psymbol">IGMP</span></dt>
<dd>Internet Group Management Protocol level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.GGP"></a><a name="GGP"></a><span class="ddoc_psymbol">GGP</span></dt>
<dd>Gateway to Gateway Protocol level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.TCP"></a><a name="TCP"></a><span class="ddoc_psymbol">TCP</span></dt>
<dd>Transmission Control Protocol level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.PUP"></a><a name="PUP"></a><span class="ddoc_psymbol">PUP</span></dt>
<dd>PARC Universal Packet Protocol level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.UDP"></a><a name="UDP"></a><span class="ddoc_psymbol">UDP</span></dt>
<dd>User Datagram Protocol level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.IDP"></a><a name="IDP"></a><span class="ddoc_psymbol">IDP</span></dt>
<dd>Xerox NS protocol level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.RAW"></a><a name="RAW"></a><span class="ddoc_psymbol">RAW</span></dt>
<dd>Raw IP packet level<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOptionLevel.IPV6"></a><a name="IPV6"></a><span class="ddoc_psymbol">IPV6</span></dt>
<dd>Internet Protocol version 6 level<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Linger"></a>struct <a name="Linger"></a><span class="ddoc_psymbol">Linger</span>;
</dt>
<dd>Linger information for use with SocketOption.LINGER.<p></p>

<dl><dt class="d_decl"><a name=".Linger.on"></a>l_onoff_t <a name="on"></a><span class="ddoc_psymbol">on</span>;
</dt>
<dd>Nonzero for on.<p></p>

</dd>
<dt class="d_decl"><a name=".Linger.time"></a>l_linger_t <a name="time"></a><span class="ddoc_psymbol">time</span>;
</dt>
<dd>Linger time.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SocketOption"></a>enum <a name="SocketOption"></a><span class="ddoc_psymbol">SocketOption</span>: int;
</dt>
<dd>Specifies a socket option:<p></p>

<dl><dt class="d_decl"><a name=".SocketOption.DEBUG"></a><a name="DEBUG"></a><span class="ddoc_psymbol">DEBUG</span></dt>
<dd>Record debugging information<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.BROADCAST"></a><a name="BROADCAST"></a><span class="ddoc_psymbol">BROADCAST</span></dt>
<dd>Allow transmission of broadcast messages<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.REUSEADDR"></a><a name="REUSEADDR"></a><span class="ddoc_psymbol">REUSEADDR</span></dt>
<dd>Allow local reuse of address<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.LINGER"></a><a name="LINGER"></a><span class="ddoc_psymbol">LINGER</span></dt>
<dd>Linger on close if unsent data is present<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.OOBINLINE"></a><a name="OOBINLINE"></a><span class="ddoc_psymbol">OOBINLINE</span></dt>
<dd>Receive out-of-band data in band<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.SNDBUF"></a><a name="SNDBUF"></a><span class="ddoc_psymbol">SNDBUF</span></dt>
<dd>Send buffer size<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.RCVBUF"></a><a name="RCVBUF"></a><span class="ddoc_psymbol">RCVBUF</span></dt>
<dd>Receive buffer size<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.DONTROUTE"></a><a name="DONTROUTE"></a><span class="ddoc_psymbol">DONTROUTE</span></dt>
<dd>Do not route<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.SNDTIMEO"></a><a name="SNDTIMEO"></a><span class="ddoc_psymbol">SNDTIMEO</span></dt>
<dd>Send timeout<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.RCVTIMEO"></a><a name="RCVTIMEO"></a><span class="ddoc_psymbol">RCVTIMEO</span></dt>
<dd>Receive timeout<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.ERROR"></a><a name="ERROR"></a><span class="ddoc_psymbol">ERROR</span></dt>
<dd>Retrieve and clear error status<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.KEEPALIVE"></a><a name="KEEPALIVE"></a><span class="ddoc_psymbol">KEEPALIVE</span></dt>
<dd>Enable keep-alive packets<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.ACCEPTCONN"></a><a name="ACCEPTCONN"></a><span class="ddoc_psymbol">ACCEPTCONN</span></dt>
<dd>Listen<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.RCVLOWAT"></a><a name="RCVLOWAT"></a><span class="ddoc_psymbol">RCVLOWAT</span></dt>
<dd>Minimum number of input bytes to process<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.SNDLOWAT"></a><a name="SNDLOWAT"></a><span class="ddoc_psymbol">SNDLOWAT</span></dt>
<dd>Minimum number of output bytes to process<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.TYPE"></a><a name="TYPE"></a><span class="ddoc_psymbol">TYPE</span></dt>
<dd>Socket type<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.TCP_NODELAY"></a><a name="TCP_NODELAY"></a><span class="ddoc_psymbol">TCP_NODELAY</span></dt>
<dd>Disable the Nagle algorithm for send coalescing<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.IPV6_UNICAST_HOPS"></a><a name="IPV6_UNICAST_HOPS"></a><span class="ddoc_psymbol">IPV6_UNICAST_HOPS</span></dt>
<dd>IP unicast hop limit<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.IPV6_MULTICAST_IF"></a><a name="IPV6_MULTICAST_IF"></a><span class="ddoc_psymbol">IPV6_MULTICAST_IF</span></dt>
<dd>IP multicast interface<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.IPV6_MULTICAST_LOOP"></a><a name="IPV6_MULTICAST_LOOP"></a><span class="ddoc_psymbol">IPV6_MULTICAST_LOOP</span></dt>
<dd>IP multicast loopback<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.IPV6_MULTICAST_HOPS"></a><a name="IPV6_MULTICAST_HOPS"></a><span class="ddoc_psymbol">IPV6_MULTICAST_HOPS</span></dt>
<dd>IP multicast hops<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.IPV6_JOIN_GROUP"></a><a name="IPV6_JOIN_GROUP"></a><span class="ddoc_psymbol">IPV6_JOIN_GROUP</span></dt>
<dd>Add an IP group membership<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.IPV6_LEAVE_GROUP"></a><a name="IPV6_LEAVE_GROUP"></a><span class="ddoc_psymbol">IPV6_LEAVE_GROUP</span></dt>
<dd>Drop an IP group membership<p></p>

</dd>
<dt class="d_decl"><a name=".SocketOption.IPV6_V6ONLY"></a><a name="IPV6_V6ONLY"></a><span class="ddoc_psymbol">IPV6_V6ONLY</span></dt>
<dd>Treat wildcard bind as AF_INET6-only<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Socket"></a>class <a name="Socket"></a><span class="ddoc_psymbol">Socket</span>;
</dt>
<dd><span class="d_inlinecode"><a name="Socket"></a><span class="ddoc_psymbol">Socket</span></span> is a class that creates a network communication endpoint using
 the Berkeley sockets interface.<p></p>

<dl><dt class="d_decl"><a name=".Socket.this"></a>this(AddressFamily <i>af</i>, SocketType <i>type</i>, ProtocolType <i>protocol</i>);
<br><a name=".Socket.this"></a>this(AddressFamily <i>af</i>, SocketType <i>type</i>);
<br><a name=".Socket.this"></a>this(AddressFamily <i>af</i>, SocketType <i>type</i>, in char[] <i>protocolName</i>);
</dt>
<dd>Create a blocking socket. If a single <i>protocol</i> <i>type</i> exists to support
 this socket <i>type</i> within the address family, the <span class="d_inlinecode">ProtocolType</span> may be
 omitted.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.this"></a>this(in AddressInfo <i>info</i>);
</dt>
<dd>Create a blocking socket using the parameters from the specified
 <span class="d_inlinecode">AddressInfo</span> structure.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.this"></a>this(socket_t <i>sock</i>, AddressFamily <i>af</i>);
</dt>
<dd>Use an existing socket handle.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.handle"></a>const @property socket_t <a name="handle"></a><span class="ddoc_psymbol">handle</span>();
</dt>
<dd>Get underlying socket <a name="handle"></a><span class="ddoc_psymbol">handle</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.blocking"></a>const @property bool <a name="blocking"></a><span class="ddoc_psymbol">blocking</span>();
<br><a name=".Socket.blocking"></a>@property void <a name="blocking"></a><span class="ddoc_psymbol">blocking</span>(bool <i>byes</i>);
</dt>
<dd>Get/set socket's <a name="blocking"></a><span class="ddoc_psymbol">blocking</span> flag.
<p></p>
When a socket is <a name="blocking"></a><span class="ddoc_psymbol">blocking</span>, calls to receive(), accept(), and send()
 will block and wait for data/action.
 A non-<a name="blocking"></a><span class="ddoc_psymbol">blocking</span> socket will immediately return instead of <a name="blocking"></a><span class="ddoc_psymbol">blocking</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.addressFamily"></a>@property AddressFamily <a name="addressFamily"></a><span class="ddoc_psymbol">addressFamily</span>();
</dt>
<dd>Get the socket's address family.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.isAlive"></a>const @property bool <a name="isAlive"></a><span class="ddoc_psymbol">isAlive</span>();
</dt>
<dd>Property that indicates if this is a valid, alive socket.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.bind"></a>void <a name="bind"></a><span class="ddoc_psymbol">bind</span>(Address <i>addr</i>);
</dt>
<dd>Associate a local address with this socket.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.connect"></a>void <a name="connect"></a><span class="ddoc_psymbol">connect</span>(Address <i>to</i>);
</dt>
<dd>Establish a connection. If the socket is blocking, <a name="connect"></a><span class="ddoc_psymbol">connect</span> waits for
 the connection <i>to</i> be made. If the socket is nonblocking, <a name="connect"></a><span class="ddoc_psymbol">connect</span>
 returns immediately and the connection attempt is still in progress.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.listen"></a>void <a name="listen"></a><span class="ddoc_psymbol">listen</span>(int <i>backlog</i>);
</dt>
<dd>Listen for an incoming connection. <span class="d_inlinecode">bind</span> must be called before you
 can <span class="d_inlinecode"><a name="listen"></a><span class="ddoc_psymbol">listen</span></span>. The <span class="d_inlinecode"><i>backlog</i></span> is a request of how many pending
 incoming connections are queued until <span class="d_inlinecode">accept</span>ed.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.accepting"></a>protected Socket <a name="accepting"></a><span class="ddoc_psymbol">accepting</span>();
</dt>
<dd>Called by <span class="d_inlinecode">accept</span> when a new <span class="d_inlinecode">Socket</span> must be created for a new
 connection. To use a derived class, override this method and return an
 instance of your class. The returned <span class="d_inlinecode">Socket</span>'s handle must not be
 set; <span class="d_inlinecode">Socket</span> has a protected constructor <span class="d_inlinecode">this()</span> to use in this
 situation.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.accept"></a>Socket <a name="accept"></a><span class="ddoc_psymbol">accept</span>();
</dt>
<dd>Accept an incoming connection. If the socket is blocking, <span class="d_inlinecode"><a name="accept"></a><span class="ddoc_psymbol">accept</span></span>
 waits for a connection request. Throws <span class="d_inlinecode">SocketAcceptException</span> if
 unable to accept. See <span class="d_inlinecode">accepting</span> for use with derived classes.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.shutdown"></a>void <a name="shutdown"></a><span class="ddoc_psymbol">shutdown</span>(SocketShutdown <i>how</i>);
</dt>
<dd>Disables sends and/or receives.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.close"></a>void <a name="close"></a><span class="ddoc_psymbol">close</span>();
</dt>
<dd>Immediately drop any connections and release socket resources.
 Calling <span class="d_inlinecode">shutdown</span> before <span class="d_inlinecode"><a name="close"></a><span class="ddoc_psymbol">close</span></span> is recommended for
 connection-oriented sockets. The <span class="d_inlinecode">Socket</span> object is no longer
 usable after <span class="d_inlinecode"><a name="close"></a><span class="ddoc_psymbol">close</span></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.hostName"></a>static @property string <a name="hostName"></a><span class="ddoc_psymbol">hostName</span>();
</dt>
<dd>Returns the local machine's host name.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.remoteAddress"></a>@property Address <a name="remoteAddress"></a><span class="ddoc_psymbol">remoteAddress</span>();
</dt>
<dd>Remote endpoint <span class="d_inlinecode">Address</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.localAddress"></a>@property Address <a name="localAddress"></a><span class="ddoc_psymbol">localAddress</span>();
</dt>
<dd>Local endpoint <span class="d_inlinecode">Address</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.ERROR"></a>int <a name="ERROR"></a><span class="ddoc_psymbol">ERROR</span>;
</dt>
<dd>Send or receive error code. See <span class="d_inlinecode">wouldHaveBlocked</span>,
 <span class="d_inlinecode">lastSocketError</span> and <span class="d_inlinecode">Socket.getErrorText</span> for obtaining more
 information about the error.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.send"></a>ptrdiff_t <a name="send"></a><span class="ddoc_psymbol">send</span>(const(void)[] <i>buf</i>, SocketFlags <i>flags</i>);
<br><a name=".Socket.send"></a>ptrdiff_t <a name="send"></a><span class="ddoc_psymbol">send</span>(const(void)[] <i>buf</i>);
</dt>
<dd>Send data on the connection. If the socket is blocking and there is no
 buffer space left, <span class="d_inlinecode"><a name="send"></a><span class="ddoc_psymbol">send</span></span> waits.
<p></p>
<b>Returns:</b><br>The number of bytes actually sent, or <span class="d_inlinecode">Socket.ERROR</span> on
 failure.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.sendTo"></a>ptrdiff_t <a name="sendTo"></a><span class="ddoc_psymbol">sendTo</span>(const(void)[] <i>buf</i>, SocketFlags <i>flags</i>, Address <i>to</i>);
<br><a name=".Socket.sendTo"></a>ptrdiff_t <a name="sendTo"></a><span class="ddoc_psymbol">sendTo</span>(const(void)[] <i>buf</i>, Address <i>to</i>);
<br><a name=".Socket.sendTo"></a>ptrdiff_t <a name="sendTo"></a><span class="ddoc_psymbol">sendTo</span>(const(void)[] <i>buf</i>, SocketFlags <i>flags</i>);
<br><a name=".Socket.sendTo"></a>ptrdiff_t <a name="sendTo"></a><span class="ddoc_psymbol">sendTo</span>(const(void)[] <i>buf</i>);
</dt>
<dd>Send data <i>to</i> a specific destination Address. If the destination address is
 not specified, a connection must have been made and that address is used.
 If the socket is blocking and there is no buffer space left, <span class="d_inlinecode"><a name="sendTo"></a><span class="ddoc_psymbol">sendTo</span></span> waits.
<p></p>
<b>Returns:</b><br>The number of bytes actually sent, or <span class="d_inlinecode">Socket.ERROR</span> on
 failure.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.receive"></a>ptrdiff_t <a name="receive"></a><span class="ddoc_psymbol">receive</span>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br><a name=".Socket.receive"></a>ptrdiff_t <a name="receive"></a><span class="ddoc_psymbol">receive</span>(void[] <i>buf</i>);
</dt>
<dd>Receive data on the connection. If the socket is blocking, <span class="d_inlinecode"><a name="receive"></a><span class="ddoc_psymbol">receive</span></span>
 waits until there is data to be received.
<p></p>
<b>Returns:</b><br>The number of bytes actually received, <span class="d_inlinecode">0</span> if the remote side
 has closed the connection, or <span class="d_inlinecode">Socket.ERROR</span> on failure.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.receiveFrom"></a>ptrdiff_t <a name="receiveFrom"></a><span class="ddoc_psymbol">receiveFrom</span>(void[] <i>buf</i>, SocketFlags <i>flags</i>, ref Address <i>from</i>);
<br><a name=".Socket.receiveFrom"></a>ptrdiff_t <a name="receiveFrom"></a><span class="ddoc_psymbol">receiveFrom</span>(void[] <i>buf</i>, ref Address <i>from</i>);
<br><a name=".Socket.receiveFrom"></a>ptrdiff_t <a name="receiveFrom"></a><span class="ddoc_psymbol">receiveFrom</span>(void[] <i>buf</i>, SocketFlags <i>flags</i>);
<br><a name=".Socket.receiveFrom"></a>ptrdiff_t <a name="receiveFrom"></a><span class="ddoc_psymbol">receiveFrom</span>(void[] <i>buf</i>);
</dt>
<dd>Receive data and get the remote endpoint <span class="d_inlinecode">Address</span>.
 If the socket is blocking, <span class="d_inlinecode"><a name="receiveFrom"></a><span class="ddoc_psymbol">receiveFrom</span></span> waits until there is data to
 be received.
<p></p>
<b>Returns:</b><br>The number of bytes actually received, <span class="d_inlinecode">0</span> if the remote side
 has closed the connection, or <span class="d_inlinecode">Socket.ERROR</span> on failure.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.getOption"></a>int <a name="getOption"></a><span class="ddoc_psymbol">getOption</span>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, void[] <i>result</i>);
</dt>
<dd>Get a socket <i>option</i>.
<p></p>
<b>Returns:</b><br>The number of bytes written to <span class="d_inlinecode"><i>result</i></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.getOption"></a>int <a name="getOption"></a><span class="ddoc_psymbol">getOption</span>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, out int32_t <i>result</i>);
</dt>
<dd>Common case of getting integer and boolean options.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.getOption"></a>int <a name="getOption"></a><span class="ddoc_psymbol">getOption</span>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, out Linger <i>result</i>);
</dt>
<dd>Get the linger <i>option</i>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.getOption"></a>void <a name="getOption"></a><span class="ddoc_psymbol">getOption</span>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, out Duration <i>result</i>);
</dt>
<dd>Get a timeout (duration) <i>option</i>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.setOption"></a>void <a name="setOption"></a><span class="ddoc_psymbol">setOption</span>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, int32_t <i>value</i>);
</dt>
<dd>Common case for setting integer and boolean options.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.setOption"></a>void <a name="setOption"></a><span class="ddoc_psymbol">setOption</span>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, Linger <i>value</i>);
</dt>
<dd>Set the linger <i>option</i>.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.setOption"></a>void <a name="setOption"></a><span class="ddoc_psymbol">setOption</span>(SocketOptionLevel <i>level</i>, SocketOption <i>option</i>, Duration <i>value</i>);
</dt>
<dd>Sets a timeout (duration) <i>option</i>, i.e. <span class="d_inlinecode">SocketOption.SNDTIMEO</span> or
 <span class="d_inlinecode">RCVTIMEO</span>. Zero indicates no timeout.
<p></p>
In a typical application, you might also want to consider using
 a non-blocking socket instead of setting a timeout on a blocking one.

<p></p>
<b>Note:</b><br>
While the receive timeout setting is generally quite accurate
 on *nix systems even for smaller durations, there are two issues to
 be aware of on Windows: First, although undocumented, the effective
 timeout duration seems to be the one set on the socket plus half
 a second. <span class="d_inlinecode"><a name="setOption"></a><span class="ddoc_psymbol">setOption</span>()</span> tries to compensate for that, but still,
 timeouts under 500ms are not possible on Windows. Second, be aware
 that the actual amount of time spent until a blocking call returns
 randomly varies on the order of 10ms.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>SocketOptionLevel <i>level</i></td>
<td valign=top>The <i>level</i> at which a socket <i>option</i> is defined.</td></tr>
<tr><td valign=top>SocketOption <i>option</i></td>
<td valign=top>Either <span class="d_inlinecode">SocketOption.SNDTIMEO</span> or <span class="d_inlinecode">SocketOption.RCVTIMEO</span>.</td></tr>
<tr><td valign=top>Duration <i>value</i></td>
<td valign=top>The timeout duration to set. Must not be negative.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">SocketException</span> if setting the options fails.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">import</span> std.datetime;
<span class="d_keyword">auto</span> pair = socketPair();
<span class="d_keyword">scope</span>(exit) <span class="d_keyword">foreach</span> (s; pair) s.close();

<span class="d_comment">// Set a receive timeout, and then wait at one end of
</span><span class="d_comment">// the socket pair, knowing that no data will arrive.
</span>pair[0].<span class="d_psymbol">setOption</span>(SocketOptionLevel.SOCKET,
    SocketOption.RCVTIMEO, dur!<span class="d_string">"seconds"</span>(1));

<span class="d_keyword">auto</span> sw = StopWatch(AutoStart.yes);
<span class="d_keyword">ubyte</span>[1] buffer;
pair[0].receive(buffer);
writefln(<span class="d_string">"Waited %s ms until the socket timed out."</span>,
    sw.peek.msecs);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.getErrorText"></a>string <a name="getErrorText"></a><span class="ddoc_psymbol">getErrorText</span>();
</dt>
<dd>Get a text description of this socket's error status, and clear the
<p></p>
socket's error status.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.setKeepAlive"></a>void <a name="setKeepAlive"></a><span class="ddoc_psymbol">setKeepAlive</span>(int <i>time</i>, int <i>interval</i>);
</dt>
<dd>Enables TCP keep-alive with the specified parameters.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>time</i></td>
<td valign=top>Number of seconds with no activity until the first
              keep-alive packet is sent.</td></tr>
<tr><td valign=top>int <i>interval</i></td>
<td valign=top>Number of seconds between when successive keep-alive
              packets are sent if no acknowledgement is received.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">SocketOSException</span> if setting the options fails, or
 <span class="d_inlinecode">SocketFeatureException</span> if setting keep-alive parameters is
 unsupported on the current platform.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.select"></a>static int <a name="select"></a><span class="ddoc_psymbol">select</span>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>, Duration <i>timeout</i>);
<br><a name=".Socket.select"></a>static int <a name="select"></a><span class="ddoc_psymbol">select</span>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>);
<br><a name=".Socket.select"></a>static int <a name="select"></a><span class="ddoc_psymbol">select</span>(SocketSet <i>checkRead</i>, SocketSet <i>checkWrite</i>, SocketSet <i>checkError</i>, TimeVal* <i>timeout</i>);
</dt>
<dd>Wait for a socket to change status. A wait <i>timeout</i> of  or
 <span class="d_inlinecode">TimeVal</span>, may be specified; if a <i>timeout</i> is not specified or the
 <span class="d_inlinecode">TimeVal</span> is <span class="d_inlinecode"><b>null</b></span>, the maximum <i>timeout</i> is used. The <span class="d_inlinecode">TimeVal</span>
 <i>timeout</i> has an unspecified value when <span class="d_inlinecode"><a name="select"></a><span class="ddoc_psymbol">select</span></span> returns.
<p></p>
<b>Returns:</b><br>The number of sockets with status changes, <span class="d_inlinecode">0</span> on <i>timeout</i>,
 or <span class="d_inlinecode">-1</span> on interruption. If the return value is greater than <span class="d_inlinecode">0</span>,
 the <span class="d_inlinecode">SocketSets</span> are updated to only contain the sockets having status
 changes. For a connecting socket, a write status change means the
 connection is established and it's able to send. For a listening socket,
 a read status change means there is an incoming connection request and
 it's able to accept.<p></p>

</dd>
<dt class="d_decl"><a name=".Socket.createAddress"></a>protected Address <a name="createAddress"></a><span class="ddoc_psymbol">createAddress</span>();
</dt>
<dd>Returns a new Address object for the current address family.
<p></p>
Can be overridden to support other addresses.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".TcpSocket"></a>class <a name="TcpSocket"></a><span class="ddoc_psymbol">TcpSocket</span>: <u>std.socket.Socket</u>;
</dt>
<dd><span class="d_inlinecode"><a name="TcpSocket"></a><span class="ddoc_psymbol">TcpSocket</span></span> is a shortcut class for a TCP Socket.<p></p>

<dl><dt class="d_decl"><a name=".TcpSocket.this"></a>this(AddressFamily <i>family</i>);
</dt>
<dd>Constructs a blocking TCP Socket.<p></p>

</dd>
<dt class="d_decl"><a name=".TcpSocket.this"></a>this();
</dt>
<dd>Constructs a blocking IPv4 TCP Socket.<p></p>

</dd>
<dt class="d_decl"><a name=".TcpSocket.this"></a>this(Address <i>connectTo</i>);
</dt>
<dd>Constructs a blocking TCP Socket and connects to an <span class="d_inlinecode">Address</span>.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".UdpSocket"></a>class <a name="UdpSocket"></a><span class="ddoc_psymbol">UdpSocket</span>: <u>std.socket.Socket</u>;
</dt>
<dd><span class="d_inlinecode"><a name="UdpSocket"></a><span class="ddoc_psymbol">UdpSocket</span></span> is a shortcut class for a UDP Socket.<p></p>

<dl><dt class="d_decl"><a name=".UdpSocket.this"></a>this(AddressFamily <i>family</i>);
</dt>
<dd>Constructs a blocking UDP Socket.<p></p>

</dd>
<dt class="d_decl"><a name=".UdpSocket.this"></a>this();
</dt>
<dd>Constructs a blocking IPv4 UDP Socket.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".socketPair"></a>Socket[2] <a name="socketPair"></a><span class="ddoc_psymbol">socketPair</span>();
</dt>
<dd>Creates a pair of connected sockets.
<p></p>
The two sockets are indistinguishable.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">SocketException</span> if creation of the sockets fails.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">immutable</span> <span class="d_keyword">ubyte</span>[] data = [1, 2, 3, 4];
<span class="d_keyword">auto</span> pair = <span class="d_psymbol">socketPair</span>();
<span class="d_keyword">scope</span>(exit) <span class="d_keyword">foreach</span> (s; pair) s.close();

pair[0].send(data);

<span class="d_keyword">auto</span> buf = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[data.length];
pair[1].receive(buf);
<span class="d_keyword">assert</span>(buf == data);
</pre>
<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright &copy; 1999-2017 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

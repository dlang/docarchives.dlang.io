<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.container.array - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/container/array.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.container.array</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/container/array.d -->
<p></p>
<dl><dt class="d_decl"><a name=".Array"></a>struct <a name="Array"></a><span class="ddoc_psymbol">Array</span>(T) if (!is(Unqual!T == bool));
</dt>
<dd><a name="Array"></a><span class="ddoc_psymbol">Array</span> type with deterministic control of memory. The memory allocated
for the array is reclaimed as soon as possible; there is no reliance
on the garbage collector. <span class="d_inlinecode"><a name="Array"></a><span class="ddoc_psymbol">Array</span></span> uses <span class="d_inlinecode">malloc</span> and <span class="d_inlinecode">free</span>
for managing its own memory.<p></p>

<dl><dt class="d_decl"><a name=".Array.this"></a>this(U)(U[] <i>values</i>...) if (isImplicitlyConvertible!(U, T));
</dt>
<dd>Constructor taking a number of items<p></p>

</dd>
<dt class="d_decl"><a name=".Array.this"></a>this(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T) &amp;&amp; !is(Stuff == T[]));
</dt>
<dd>Constructor taking an input range<p></p>

</dd>
<dt class="d_decl"><a name=".Array.opEquals"></a>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(const Array <i>rhs</i>);
<br><a name=".Array.opEquals"></a>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const Array <i>rhs</i>);
</dt>
<dd>Comparison for equality.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.Range"></a>struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</dt>
<dd>Defines the container's primary range, which is a random-access range.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.dup"></a>@property Array <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.empty"></a>const @property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.length"></a>const @property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
<br><a name=".Array.opDollar"></a>const size_t <a name="opDollar"></a><span class="ddoc_psymbol">opDollar</span>();
</dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.capacity"></a>@property size_t <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</dt>
<dd>Returns the maximum number of elements the container can store without
   (a) allocating memory, (b) invalidating iterators upon insertion.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.reserve"></a>void <a name="reserve"></a><span class="ddoc_psymbol">reserve</span>(size_t <i>elements</i>);
</dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">e</span> <i>elements</i>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= e</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Returns a range that iterates over elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>i</i>, size_t <i>j</i>);
</dt>
<dd>Returns a range that iterates over elements of the container from
index <span class="d_inlinecode">a</span> up to (excluding) index <span class="d_inlinecode">b</span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">a &lt;= b &amp;&amp; b &lt;= length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.front"></a>@property ref T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Array.back"></a>@property ref T <a name="back"></a><span class="ddoc_psymbol">back</span>();
</dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span> and <span class="d_inlinecode">opSlice().back</span>, respectively.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opIndex"></a>ref T <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
</dt>
<dd>Indexing operators yield or modify the value at a specified index.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>i</i> &lt; length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opSliceAssign"></a>void <a name="opSliceAssign"></a><span class="ddoc_psymbol">opSliceAssign</span>(T <i>value</i>);
<br><a name=".Array.opSliceAssign"></a>void <a name="opSliceAssign"></a><span class="ddoc_psymbol">opSliceAssign</span>(T <i>value</i>, size_t <i>i</i>, size_t <i>j</i>);
<br><a name=".Array.opSliceUnary"></a>void <a name="opSliceUnary"></a><span class="ddoc_psymbol">opSliceUnary</span>(string op)() if (op == "++" || op == "--");
<br><a name=".Array.opSliceUnary"></a>void <a name="opSliceUnary"></a><span class="ddoc_psymbol">opSliceUnary</span>(string op)(size_t <i>i</i>, size_t <i>j</i>) if (op == "++" || op == "--");
<br><a name=".Array.opSliceOpAssign"></a>void <a name="opSliceOpAssign"></a><span class="ddoc_psymbol">opSliceOpAssign</span>(string op)(T <i>value</i>);
<br><a name=".Array.opSliceOpAssign"></a>void <a name="opSliceOpAssign"></a><span class="ddoc_psymbol">opSliceOpAssign</span>(string op)(T <i>value</i>, size_t <i>i</i>, size_t <i>j</i>);
</dt>
<dd>Slicing operations execute an operation on an entire slice.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">i &lt; j &amp;&amp; j &lt; length</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">slice.length</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opBinary"></a>Array <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, Stuff)(Stuff <i>stuff</i>) if (op == "~");
</dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span></span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opOpAssign"></a>void <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, Stuff)(Stuff <i>stuff</i>) if (op == "~");
</dt>
<dd>Forwards to <span class="d_inlinecode">insertBack(stuff)</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Removes all contents from the container. The container decides how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.length"></a>@property void <a name="length"></a><span class="ddoc_psymbol">length</span>(size_t <i>newLength</i>);
</dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span></span>, the added elements are added to
unspecified positions in the container and initialized with <span class="d_inlinecode">T.init</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b><i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span> == <i>newLength</i></span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.removeAny"></a>T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br><a name=".Array.stableRemoveAny"></a>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span> = removeAny;
</dt>
<dd>Picks one value in an unspecified position in the container, removes
it from the container, and returns it. Implementations should pick the
value that's the most advantageous for the container, but document the
exact behavior. The stable version behaves the same, but guarantees
that ranges iterating over the container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.insertBack"></a>size_t <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff)(Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, T) || isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
<br><a name=".Array.insert"></a>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span> = insertBack;
</dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the front or back of the container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.removeBack"></a>void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
<br><a name=".Array.stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes the value at the back of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.removeBack"></a>size_t <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>(size_t <i>howMany</i>);
<br><a name=".Array.stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i></span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.insertBefore"></a>size_t <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, T));
<br><a name=".Array.insertBefore"></a>size_t <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
<br><a name=".Array.insertAfter"></a>size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".Array.replace"></a>size_t <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T));
<br><a name=".Array.replace"></a>size_t <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (isImplicitlyConvertible!(Stuff, T));
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>, which must
be a valid range previously extracted from this container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
<br><a name=".Array.stableLinearRemove"></a>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span> = remove;
</dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
obtained originally from this container. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n - m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of elements in
<span class="d_inlinecode"><i>r</i></span><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Array"></a>struct <a name="Array"></a><span class="ddoc_psymbol">Array</span>(T) if (is(Unqual!T == bool));
</dt>
<dd>Array specialized for <span class="d_inlinecode">bool</span>. Packs together values efficiently by
allocating one bit per element.<p></p>

<dl><dt class="d_decl"><a name=".Array.Range"></a>struct <a name="Range"></a><span class="ddoc_psymbol">Range</span>;
</dt>
<dd>Defines the container's primary range.<p></p>

<dl><dt class="d_decl"><a name=".Array.Range.save"></a>@property Range <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br><a name=".Array.Range.empty"></a>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".Array.Range.front"></a>@property T <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Array.Range.front"></a>@property void <a name="front"></a><span class="ddoc_psymbol">front</span>(bool <i>value</i>);
<br><a name=".Array.Range.moveFront"></a>T <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
<br><a name=".Array.Range.popFront"></a>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".Array.Range.back"></a>@property T <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".Array.Range.back"></a>@property void <a name="back"></a><span class="ddoc_psymbol">back</span>(bool <i>value</i>);
<br><a name=".Array.Range.moveBack"></a>T <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
<br><a name=".Array.Range.popBack"></a>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br><a name=".Array.Range.opIndex"></a>T <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
<br><a name=".Array.Range.opIndexAssign"></a>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(T <i>value</i>, size_t <i>i</i>);
<br><a name=".Array.Range.moveAt"></a>T <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>i</i>);
<br><a name=".Array.Range.length"></a>const @property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
<br><a name=".Array.Range.opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>low</i>, size_t <i>high</i>);
</dt>
<dd>Range primitives<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Array.empty"></a>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has
       no elements.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.dup"></a>@property Array <a name="dup"></a><span class="ddoc_psymbol">dup</span>();
</dt>
<dd>Returns a duplicate of the container. The elements themselves
       are not transitively duplicated.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.length"></a>const @property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.capacity"></a>@property size_t <a name="capacity"></a><span class="ddoc_psymbol">capacity</span>();
</dt>
<dd>Returns the maximum number of elements the container can store
       without (a) allocating memory, (b) invalidating iterators upon
       insertion.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.reserve"></a>void <a name="reserve"></a><span class="ddoc_psymbol">reserve</span>(size_t <i>e</i>);
</dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">n</span> elements.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= n</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(<i>e</i> - capacity)</span><b><i>)</i></b> if <span class="d_inlinecode"><i>e</i> &gt; capacity</span>,
       otherwise <b><i>&Omicron;</i>(</b><span class="d_inlinecode">1</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd>Returns a range that iterates over all elements of the
       container, in a container-defined order. The container should
       choose the most convenient and fast method of iteration for <span class="d_inlinecode">       <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>()</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opSlice"></a>Range <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>a</i>, size_t <i>b</i>);
</dt>
<dd>Returns <i>a</i> range that iterates the container between two
       specified positions.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.front"></a>@property bool <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Array.front"></a>@property void <a name="front"></a><span class="ddoc_psymbol">front</span>(bool <i>value</i>);
<br><a name=".Array.back"></a>@property bool <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".Array.back"></a>@property void <a name="back"></a><span class="ddoc_psymbol">back</span>(bool <i>value</i>);
</dt>
<dd>Equivalent to <span class="d_inlinecode">opSlice().<a name="front"></a><span class="ddoc_psymbol">front</span></span> and <span class="d_inlinecode">opSlice().back</span>,
       respectively.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opIndex"></a>bool <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
<br><a name=".Array.opIndexAssign"></a>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(bool <i>value</i>, size_t <i>i</i>);
<br><a name=".Array.opIndexOpAssign"></a>void <a name="opIndexOpAssign"></a><span class="ddoc_psymbol">opIndexOpAssign</span>(string op)(bool <i>value</i>, size_t <i>i</i>);
<br><a name=".Array.moveAt"></a>T <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>i</i>);
</dt>
<dd>Indexing operators yield or modify the value at a specified index.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.opBinary"></a>Array!bool <a name="opBinary"></a><span class="ddoc_psymbol">opBinary</span>(string op, Stuff)(Stuff <i>rhs</i>) if (op == "~");
</dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span>
       and its argument.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where m is the number of elements
       in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.opOpAssign"></a>Array!bool <a name="opOpAssign"></a><span class="ddoc_psymbol">opOpAssign</span>(string op, Stuff)(Stuff <i>stuff</i>) if (op == "~");
</dt>
<dd>Forwards to <span class="d_inlinecode">insertAfter(this[], stuff)</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>Removes all contents from the container. The container decides
       how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.length"></a>@property void <a name="length"></a><span class="ddoc_psymbol">length</span>(size_t <i>newLength</i>);
</dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">       newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><span class="ddoc_psymbol">length</span></span>, the
       added elements are added to the container and initialized with
       <span class="d_inlinecode">ElementType.init</span>.
<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b><i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">length == <i>newLength</i></span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.insert"></a>alias <a name="insert"></a><span class="ddoc_psymbol">insert</span> = insertBack;
<br><a name=".Array.stableInsert"></a>alias <a name="stableInsert"></a><span class="ddoc_psymbol">stableInsert</span> = insertBack;
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> in the container. <span class="d_inlinecode">stuff</span> can be a value
       convertible to <span class="d_inlinecode">ElementType</span> or a range of objects
       convertible to <span class="d_inlinecode">ElementType</span>.
<p></p>
The <span class="d_inlinecode">stable</span> version guarantees that ranges iterating over
       the container are never invalidated. Client code that counts on
       non-invalidating insertion should use <span class="d_inlinecode">stableInsert</span>.

<p></p>
<b>Returns:</b><br>The number of elements added.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">m * log(n)</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
       elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.linearInsert"></a>alias <a name="linearInsert"></a><span class="ddoc_psymbol">linearInsert</span> = insertBack;
<br><a name=".Array.stableLinearInsert"></a>alias <a name="stableLinearInsert"></a><span class="ddoc_psymbol">stableLinearInsert</span> = insertBack;
</dt>
<dd>Same as <span class="d_inlinecode">insert(stuff)</span> and <span class="d_inlinecode">stableInsert(stuff)</span>
       respectively, but relax the complexity constraint to linear.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.removeAny"></a>T <a name="removeAny"></a><span class="ddoc_psymbol">removeAny</span>();
<br><a name=".Array.stableRemoveAny"></a>alias <a name="stableRemoveAny"></a><span class="ddoc_psymbol">stableRemoveAny</span> = removeAny;
</dt>
<dd>Picks one value in the container, removes it from the
       container, and returns it. The stable version behaves the same,
       but guarantees that ranges iterating over the container are
       never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.insertBack"></a>size_t <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff)(Stuff <i>stuff</i>) if (is(Stuff : bool));
<br><a name=".Array.insertBack"></a>size_t <a name="insertBack"></a><span class="ddoc_psymbol">insertBack</span>(Stuff)(Stuff <i>stuff</i>) if (isInputRange!Stuff &amp;&amp; is(ElementType!Stuff : bool));
<br><a name=".Array.stableInsertBack"></a>alias <a name="stableInsertBack"></a><span class="ddoc_psymbol">stableInsertBack</span> = insertBack;
</dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the back of the container. <span class="d_inlinecode">stuff</span> can
       be a value convertible to <span class="d_inlinecode">ElementType</span> or a range of
       objects convertible to <span class="d_inlinecode">ElementType</span>. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b><p></p>

</dd>
<dt class="d_decl"><a name=".Array.removeBack"></a>void <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>();
<br><a name=".Array.stableRemoveBack"></a>alias <a name="stableRemoveBack"></a><span class="ddoc_psymbol">stableRemoveBack</span> = removeBack;
</dt>
<dd>Removes the value at the front or back of the container. The
       stable version behaves the same, but guarantees that ranges
       iterating over the container are never invalidated. The
       optional parameter <span class="d_inlinecode">howMany</span> instructs removal of that many
       elements. If <span class="d_inlinecode">howMany &gt; n</span>, all elements are removed and no
       exception is thrown.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(n)</span><b><i>)</i></b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Array.removeBack"></a>size_t <a name="removeBack"></a><span class="ddoc_psymbol">removeBack</span>(size_t <i>howMany</i>);
</dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
       container. Unlike the unparameterized versions above, these
       functions do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span>
       elements. Instead, if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are
       removed. The returned value is the effective number of elements
       removed. The stable version behaves the same, but guarantees
       that ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b><i>)</i></b>.
<p></p>

ditto<p></p>

</dd>
<dt class="d_decl"><a name=".Array.insertBefore"></a>size_t <a name="insertBefore"></a><span class="ddoc_psymbol">insertBefore</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".Array.stableInsertBefore"></a>alias <a name="stableInsertBefore"></a><span class="ddoc_psymbol">stableInsertBefore</span> = insertBefore;
<br><a name=".Array.insertAfter"></a>size_t <a name="insertAfter"></a><span class="ddoc_psymbol">insertAfter</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br><a name=".Array.stableInsertAfter"></a>alias <a name="stableInsertAfter"></a><span class="ddoc_psymbol">stableInsertAfter</span> = insertAfter;
<br><a name=".Array.replace"></a>size_t <a name="replace"></a><span class="ddoc_psymbol">replace</span>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>) if (is(Stuff : bool));
<br><a name=".Array.stableReplace"></a>alias <a name="stableReplace"></a><span class="ddoc_psymbol">stableReplace</span> = replace;
</dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>,
       which must be a valid range previously extracted from this
       container. <span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">       ElementType</span> or a range of objects convertible to <span class="d_inlinecode">       ElementType</span>. The stable version behaves the same, but
       guarantees that ranges iterating over the container are never
       invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n + m</span><b><i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt class="d_decl"><a name=".Array.linearRemove"></a>Range <a name="linearRemove"></a><span class="ddoc_psymbol">linearRemove</span>(Range <i>r</i>);
<br><a name=".Array.stableLinearRemove"></a>alias <a name="stableLinearRemove"></a><span class="ddoc_psymbol">stableLinearRemove</span> = linearRemove;
</dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
       obtained originally from this container. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
       initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">n</span><b><i>)</i></b><p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright &copy; 1999-2017 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

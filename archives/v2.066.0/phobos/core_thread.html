<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>core.thread - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos </a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/druntime/edit/master/src/core/thread.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>core.thread</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from src/core/thread.d -->
The <a name="thread"></a><span class="ddoc_psymbol">thread</span> module provides support for <a name="thread"></a><span class="ddoc_psymbol">thread</span> creation and management.
<p></p>
<b>License:</b><br>Distributed under the
      <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License 1.0</a>.
    (See accompanying file LICENSE)
<p></p>
<b>Authors:</b><br>Sean Kelly, Walter Bright, Alex Rønne Petersen, Martin Nowak
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/druntime/blob/master/src/core/thread.d">core/thread.d</a><p></p>

<dl><dt class="d_decl"><a name=".getpid"></a>alias <a name="getpid"></a><span class="ddoc_psymbol">getpid</span> = core.sys.posix.unistd.<a name="getpid"></a><span class="ddoc_psymbol">getpid</span>;
</dt>
<dd>Returns the process ID of the calling process, which is guaranteed to be
 unique on the system. This call is always successful.
<p></p>
<b>Example:</b><br>
<pre class="d_code">writefln(<span class="d_string">"Current process id: %s"</span>, <span class="d_psymbol">getpid</span>());
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadException"></a>class <a name="ThreadException"></a><span class="ddoc_psymbol">ThreadException</span>: <u>object.Exception</u>;
</dt>
<dd>Base class for thread exceptions.<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadError"></a>class <a name="ThreadError"></a><span class="ddoc_psymbol">ThreadError</span>: <u>object.Error</u>;
</dt>
<dd>Base class for thread errors to be used for function inside GC when allocations are unavailable.<p></p>

</dd>
<dt class="d_decl"><a name=".FiberException"></a>class <a name="FiberException"></a><span class="ddoc_psymbol">FiberException</span>: <u>object.Exception</u>;
</dt>
<dd>Base class for fiber exceptions.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread"></a>class <a name="Thread"></a><span class="ddoc_psymbol">Thread</span>;
</dt>
<dd>This class encapsulates all threading functionality for the D
 programming language.  As thread manipulation is a required facility
 for garbage collection, all user threads should derive from this
 class, and instances of this class should never be explicitly deleted.
 A new thread may be created using either derivation or composition, as
 in the following example.
<p></p>
<b>Example:</b><br>
<pre class="d_code">
<span class="d_keyword">class</span> DerivedThread : <span class="d_psymbol">Thread</span>
{
    <span class="d_keyword">this</span>()
    {
        <span class="d_keyword">super</span>( &amp;run );
    }

<span class="d_keyword">private</span> :
    <span class="d_keyword">void</span> run()
    {
        printf( <span class="d_string">"Derived thread running.\n"</span> );
    }
}

<span class="d_keyword">void</span> threadFunc()
{
    printf( <span class="d_string">"Composed thread running.\n"</span> );
}

<span class="d_comment">// create instances of each type
</span><span class="d_psymbol">Thread</span> derived = <span class="d_keyword">new</span> DerivedThread();
<span class="d_psymbol">Thread</span> composed = <span class="d_keyword">new</span> <span class="d_psymbol">Thread</span>( &amp;threadFunc );

<span class="d_comment">// start both threads
</span>derived.start();
composed.start();

</pre>
<p></p>

<dl><dt class="d_decl"><a name=".Thread.this"></a>this(void function() <i>fn</i>, size_t <i>sz</i> = 0);
</dt>
<dd>Initializes a thread object which is associated with a static
 D function.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void function() <i>fn</i></td>
<td valign=top>The thread function.</td></tr>
<tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The stack size for this thread.</td></tr>
</table><p></p>
<b>In:</b><br>
<i>fn</i> must not be <b>null</b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.this"></a>this(void delegate() <i>dg</i>, size_t <i>sz</i> = 0);
</dt>
<dd>Initializes a thread object which is associated with a dynamic
 D function.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void delegate() <i>dg</i></td>
<td valign=top>The thread function.</td></tr>
<tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The stack size for this thread.</td></tr>
</table><p></p>
<b>In:</b><br>
<i>dg</i> must not be <b>null</b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.start"></a>final void <a name="start"></a><span class="ddoc_psymbol">start</span>();
</dt>
<dd>Starts the thread and invokes the function or delegate passed upon
 construction.
<p></p>
<b>In:</b><br>
This routine may only be called once per thread instance.

<p></p>
<b>Throws:</b><br>ThreadException if the thread fails to <a name="start"></a><span class="ddoc_psymbol">start</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.join"></a>final Throwable <a name="join"></a><span class="ddoc_psymbol">join</span>(bool <i>rethrow</i> = true);
</dt>
<dd>Waits for this thread to complete.  If the thread terminated as the
 result of an unhandled exception, this exception will be rethrown.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>bool <i>rethrow</i></td>
<td valign=top>Rethrow any unhandled exception which may have caused this
            thread to terminate.</td></tr>
</table><p></p>
<b>Throws:</b><br>ThreadException if the operation fails.
  Any exception not handled by the joined thread.

<p></p>
<b>Returns:</b><br>Any exception not handled by this thread if <i>rethrow</i> = <b>false</b>, <b>null</b>
  otherwise.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.name"></a>final @property string <a name="name"></a><span class="ddoc_psymbol">name</span>();
</dt>
<dd>Gets the user-readable label for this thread.
<p></p>
<b>Returns:</b><br>The <a name="name"></a><span class="ddoc_psymbol">name</span> of this thread.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.name"></a>final @property void <a name="name"></a><span class="ddoc_psymbol">name</span>(string <i>val</i>);
</dt>
<dd>Sets the user-readable label for this thread.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>val</i></td>
<td valign=top>The new <a name="name"></a><span class="ddoc_psymbol">name</span> of this thread.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".Thread.isDaemon"></a>final @property bool <a name="isDaemon"></a><span class="ddoc_psymbol">isDaemon</span>();
</dt>
<dd>Gets the daemon status for this thread.  While the runtime will wait for
 all normal threads to complete before tearing down the process, daemon
 threads are effectively ignored and thus will not prevent the process
 from terminating.  In effect, daemon threads will be terminated
 automatically by the OS when the process exits.
<p></p>
<b>Returns:</b><br><b>true</b> if this is a daemon thread.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.isDaemon"></a>final @property void <a name="isDaemon"></a><span class="ddoc_psymbol">isDaemon</span>(bool <i>val</i>);
</dt>
<dd>Sets the daemon status for this thread.  While the runtime will wait for
 all normal threads to complete before tearing down the process, daemon
 threads are effectively ignored and thus will not prevent the process
 from terminating.  In effect, daemon threads will be terminated
 automatically by the OS when the process exits.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>bool <i>val</i></td>
<td valign=top>The new daemon status for this thread.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".Thread.isRunning"></a>final nothrow @property bool <a name="isRunning"></a><span class="ddoc_psymbol">isRunning</span>();
</dt>
<dd>Tests whether this thread is running.
<p></p>
<b>Returns:</b><br><b>true</b> if the thread is running, <b>false</b> if not.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.PRIORITY_MIN"></a>const int <a name="PRIORITY_MIN"></a><span class="ddoc_psymbol">PRIORITY_MIN</span>;
</dt>
<dd>The minimum scheduling priority that may be set for a thread.  On
 systems where multiple scheduling policies are defined, this value
 represents the minimum valid priority for the scheduling policy of
 the process.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.PRIORITY_MAX"></a>const int <a name="PRIORITY_MAX"></a><span class="ddoc_psymbol">PRIORITY_MAX</span>;
</dt>
<dd>The maximum scheduling priority that may be set for a thread.  On
 systems where multiple scheduling policies are defined, this value
 represents the maximum valid priority for the scheduling policy of
 the process.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.PRIORITY_DEFAULT"></a>const int <a name="PRIORITY_DEFAULT"></a><span class="ddoc_psymbol">PRIORITY_DEFAULT</span>;
</dt>
<dd>The default scheduling priority that is set for a thread.  On
 systems where multiple scheduling policies are defined, this value
 represents the default priority for the scheduling policy of
 the process.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.priority"></a>final @property int <a name="priority"></a><span class="ddoc_psymbol">priority</span>();
</dt>
<dd>Gets the scheduling <a name="priority"></a><span class="ddoc_psymbol">priority</span> for the associated thread.
<p></p>
<b>Returns:</b><br>The scheduling <a name="priority"></a><span class="ddoc_psymbol">priority</span> of this thread.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.priority"></a>final @property void <a name="priority"></a><span class="ddoc_psymbol">priority</span>(int <i>val</i>);
</dt>
<dd>Sets the scheduling <a name="priority"></a><span class="ddoc_psymbol">priority</span> for the associated thread.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>val</i></td>
<td valign=top>The new scheduling <a name="priority"></a><span class="ddoc_psymbol">priority</span> of this thread.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".Thread.sleep"></a>static void <a name="sleep"></a><span class="ddoc_psymbol">sleep</span>(Duration <i>val</i>);
</dt>
<dd>Suspends the calling thread for at least the supplied period.  This may
 result in multiple OS calls if period is greater than the maximum <a name="sleep"></a><span class="ddoc_psymbol">sleep</span>
 duration supported by the operating system.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Duration <i>val</i></td>
<td valign=top>The minimum duration the calling thread should be suspended.</td></tr>
</table><p></p>
<b>In:</b><br>
period must be non-negative.

<p></p>
<b>Example:</b><br>
<pre class="d_code">
Thread.<span class="d_psymbol">sleep</span>( dur!(<span class="d_string">"msecs"</span>)( 50 ) );  <span class="d_comment">// sleep for 50 milliseconds
</span>Thread.<span class="d_psymbol">sleep</span>( dur!(<span class="d_string">"seconds"</span>)( 5 ) ); <span class="d_comment">// sleep for 5 seconds
</span>
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.yield"></a>static void <a name="yield"></a><span class="ddoc_psymbol">yield</span>();
</dt>
<dd>Forces a context switch to occur away from the calling thread.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.getThis"></a>static nothrow Thread <a name="getThis"></a><span class="ddoc_psymbol">getThis</span>();
</dt>
<dd>Provides a reference to the calling thread.
<p></p>
<b>Returns:</b><br>The thread object representing the calling thread.  The result of
  deleting this object is undefined.  If the current thread is not
  attached to the runtime, a <b>null</b> reference is returned.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.getAll"></a>static Thread[] <a name="getAll"></a><span class="ddoc_psymbol">getAll</span>();
</dt>
<dd>Provides a list of all threads currently being tracked by the system.
<p></p>
<b>Returns:</b><br>An array containing references to all threads currently being
  tracked by the system.  The result of deleting any contained
  objects is undefined.<p></p>

</dd>
<dt class="d_decl"><a name=".Thread.opApply"></a>static int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(scope int delegate(ref Thread) <i>dg</i>);
</dt>
<dd>Operates on all threads currently being tracked by the system.  The
 result of deleting any Thread object is undefined.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int delegate(ref Thread) <i>dg</i></td>
<td valign=top>The supplied code as a delegate.</td></tr>
</table><p></p>
<b>Returns:</b><br>Zero if all elemented are visited, nonzero if not.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".thread_init"></a>void <a name="thread_init"></a><span class="ddoc_psymbol">thread_init</span>();
</dt>
<dd>Initializes the thread module.  This function must be called by the
 garbage collector on startup and before any other thread routines
 are called.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_term"></a>void <a name="thread_term"></a><span class="ddoc_psymbol">thread_term</span>();
</dt>
<dd>Terminates the thread module. No other thread routine may be called
 afterwards.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_isMainThread"></a>bool <a name="thread_isMainThread"></a><span class="ddoc_psymbol">thread_isMainThread</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".thread_attachThis"></a>Thread <a name="thread_attachThis"></a><span class="ddoc_psymbol">thread_attachThis</span>();
</dt>
<dd>Registers the calling thread for use with the D Runtime.  If this routine
 is called for a thread which is already registered, no action is performed.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_detachThis"></a>void <a name="thread_detachThis"></a><span class="ddoc_psymbol">thread_detachThis</span>();
<br><a name=".thread_detachByAddr"></a>void <a name="thread_detachByAddr"></a><span class="ddoc_psymbol">thread_detachByAddr</span>(Thread.ThreadAddr <i>addr</i>);
</dt>
<dd>Deregisters the calling thread from use with the runtime.  If this routine
 is called for a thread which is not registered, no action is performed.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_findByAddr"></a>static Thread <a name="thread_findByAddr"></a><span class="ddoc_psymbol">thread_findByAddr</span>(Thread.ThreadAddr <i>addr</i>);
</dt>
<dd>Search the list of all threads for a thread with the given thread identifier.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Thread.ThreadAddr <i>addr</i></td>
<td valign=top>The thread identifier to search for.</td></tr>
</table><p></p>
<b>Returns:</b><br>The thread object associated with the thread identifier, <b>null</b> if not found.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_setThis"></a>void <a name="thread_setThis"></a><span class="ddoc_psymbol">thread_setThis</span>(Thread <i>t</i>);
</dt>
<dd>Sets the current thread to a specific reference. Only to be used
 when dealing with externally-created threads (in e.g. C code).
 The primary use of this function is when Thread.getThis() must
 return a sensible value in, for example, TLS destructors. In
 other words, don'<i>t</i> touch this unless you know what you're doing.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Thread <i>t</i></td>
<td valign=top>A reference to the current thread. May be <b>null</b>.</td></tr>
</table><p></p>

</dd>
<dt class="d_decl"><a name=".thread_joinAll"></a>void <a name="thread_joinAll"></a><span class="ddoc_psymbol">thread_joinAll</span>();
</dt>
<dd>Joins all non-daemon threads that are currently running.  This is done by
 performing successive scans through the thread list until a scan consists
 of only daemon threads.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_suspendAll"></a>nothrow void <a name="thread_suspendAll"></a><span class="ddoc_psymbol">thread_suspendAll</span>();
</dt>
<dd>Suspend all threads but the calling thread for "stop the world" garbage
 collection runs.  This function may be called multiple times, and must
 be followed by a matching number of calls to thread_resumeAll before
 processing is resumed.
<p></p>
<b>Throws:</b><br>ThreadError if the suspend operation fails for a running thread.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_resumeAll"></a>nothrow void <a name="thread_resumeAll"></a><span class="ddoc_psymbol">thread_resumeAll</span>();
</dt>
<dd>Resume all threads but the calling thread for "stop the world" garbage
 collection runs.  This function must be called once for each preceding
 call to thread_suspendAll before the threads are actually resumed.
<p></p>
<b>In:</b><br>
This routine must be preceded by a call to thread_suspendAll.

<p></p>
<b>Throws:</b><br>ThreadError if the resume operation fails for a running thread.<p></p>

</dd>
<dt class="d_decl"><a name=".ScanType"></a>enum <a name="ScanType"></a><span class="ddoc_psymbol">ScanType</span>: int;
</dt>
<dd>Indicates the kind of scan being performed by <span class="d_inlinecode">thread_scanAllType</span>.<p></p>

<dl><dt class="d_decl"><a name=".ScanType.stack"></a><a name="stack"></a><span class="ddoc_psymbol">stack</span></dt>
<dd>The <a name="stack"></a><span class="ddoc_psymbol">stack</span> and/or registers are being scanned.<p></p>

</dd>
<dt class="d_decl"><a name=".ScanType.tls"></a><a name="tls"></a><span class="ddoc_psymbol">tls</span></dt>
<dd>TLS data is being scanned.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ScanAllThreadsFn"></a>alias <a name="ScanAllThreadsFn"></a><span class="ddoc_psymbol">ScanAllThreadsFn</span> = void delegate(void*, void*) nothrow;
<br><a name=".ScanAllThreadsTypeFn"></a>alias <a name="ScanAllThreadsTypeFn"></a><span class="ddoc_psymbol">ScanAllThreadsTypeFn</span> = void delegate(ScanType, void*, void*) nothrow;
</dt>
<dd>The scanning function.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_scanAllType"></a>nothrow void <a name="thread_scanAllType"></a><span class="ddoc_psymbol">thread_scanAllType</span>(scope ScanAllThreadsTypeFn <i>scan</i>);
</dt>
<dd>The main entry point for garbage collection.  The supplied delegate
 will be passed ranges representing both stack and register values.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>ScanAllThreadsTypeFn <i>scan</i></td>
<td valign=top>The scanner function.  It should <i>scan</i> from p1 through p2 - 1.</td></tr>
</table><p></p>
<b>In:</b><br>
This routine must be preceded by a call to thread_suspendAll.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_scanAll"></a>nothrow void <a name="thread_scanAll"></a><span class="ddoc_psymbol">thread_scanAll</span>(scope ScanAllThreadsFn <i>scan</i>);
</dt>
<dd>The main entry point for garbage collection.  The supplied delegate
 will be passed ranges representing both stack and register values.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>ScanAllThreadsFn <i>scan</i></td>
<td valign=top>The scanner function.  It should <i>scan</i> from p1 through p2 - 1.</td></tr>
</table><p></p>
<b>In:</b><br>
This routine must be preceded by a call to thread_suspendAll.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_enterCriticalRegion"></a>void <a name="thread_enterCriticalRegion"></a><span class="ddoc_psymbol">thread_enterCriticalRegion</span>();
</dt>
<dd>Signals that the code following this call is a critical region. Any code in
 this region must finish running before the calling thread can be suspended
 by a call to thread_suspendAll.
<p></p>
This function is, in particular, meant to help maintain garbage collector
 invariants when a lock is not used.
<p></p>

 A critical region is exited with thread_exitCriticalRegion.
<p></p>

 <span style="color:red">Warning</span>:
 Using critical regions is extremely error-prone. For instance, using locks
 inside a critical region can easily result in a deadlock when another thread
 holding the lock already got suspended.
<p></p>

 The term and concept of a 'critical region' comes from
 <a href="https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925 Mono's SGen garbage collector"></a>.

<p></p>
<b>In:</b><br>
The calling thread must be attached to the runtime.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_exitCriticalRegion"></a>void <a name="thread_exitCriticalRegion"></a><span class="ddoc_psymbol">thread_exitCriticalRegion</span>();
</dt>
<dd>Signals that the calling thread is no longer in a critical region. Following
 a call to this function, the thread can once again be suspended.
<p></p>
<b>In:</b><br>
The calling thread must be attached to the runtime.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_inCriticalRegion"></a>bool <a name="thread_inCriticalRegion"></a><span class="ddoc_psymbol">thread_inCriticalRegion</span>();
</dt>
<dd>Returns <b>true</b> if the current thread is in a critical region; otherwise, <b>false</b>.
<p></p>
<b>In:</b><br>
The calling thread must be attached to the runtime.<p></p>

</dd>
<dt class="d_decl"><a name=".IsMarked"></a>enum <a name="IsMarked"></a><span class="ddoc_psymbol">IsMarked</span>: int;
</dt>
<dd>Indicates whether an address has been marked by the GC.<p></p>

<dl><dt class="d_decl"><a name=".IsMarked.no"></a><a name="no"></a><span class="ddoc_psymbol">no</span></dt>
<dd>Address is not marked.<p></p>

</dd>
<dt class="d_decl"><a name=".IsMarked.yes"></a><a name="yes"></a><span class="ddoc_psymbol">yes</span></dt>
<dd>Address is marked.<p></p>

</dd>
<dt class="d_decl"><a name=".IsMarked.unknown"></a><a name="unknown"></a><span class="ddoc_psymbol">unknown</span></dt>
<dd>Address is not managed by the GC.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".IsMarkedDg"></a>alias <a name="IsMarkedDg"></a><span class="ddoc_psymbol">IsMarkedDg</span> = int delegate(void* addr) nothrow;
</dt>
<dd>The isMarked callback function.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_processGCMarks"></a>nothrow void <a name="thread_processGCMarks"></a><span class="ddoc_psymbol">thread_processGCMarks</span>(scope IsMarkedDg <i>isMarked</i>);
</dt>
<dd>This routine allows the runtime to process any special per-thread handling
 for the GC.  This is needed for taking into account any memory that is
 referenced by non-scanned pointers but is about to be freed.  That currently
 means the array append cache.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>IsMarkedDg <i>isMarked</i></td>
<td valign=top>The function used to check if <span class="d_inlinecode">addr</span> is marked.</td></tr>
</table><p></p>
<b>In:</b><br>
This routine must be called just prior to resuming all threads.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_stackTop"></a>void* <a name="thread_stackTop"></a><span class="ddoc_psymbol">thread_stackTop</span>();
</dt>
<dd>Returns the stack top of the currently active stack within the calling
 thread.
<p></p>
<b>In:</b><br>
The calling thread must be attached to the runtime.

<p></p>
<b>Returns:</b><br>The address of the stack top.<p></p>

</dd>
<dt class="d_decl"><a name=".thread_stackBottom"></a>void* <a name="thread_stackBottom"></a><span class="ddoc_psymbol">thread_stackBottom</span>();
</dt>
<dd>Returns the stack bottom of the currently active stack within the calling
 thread.
<p></p>
<b>In:</b><br>
The calling thread must be attached to the runtime.

<p></p>
<b>Returns:</b><br>The address of the stack bottom.<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadGroup"></a>class <a name="ThreadGroup"></a><span class="ddoc_psymbol">ThreadGroup</span>;
</dt>
<dd>This class is intended to simplify certain common programming techniques.<p></p>

<dl><dt class="d_decl"><a name=".ThreadGroup.create"></a>final Thread <a name="create"></a><span class="ddoc_psymbol">create</span>(void function() <i>fn</i>);
</dt>
<dd>Creates and starts a new Thread object that executes <i>fn</i> and adds it to
 the list of tracked threads.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void function() <i>fn</i></td>
<td valign=top>The thread function.</td></tr>
</table><p></p>
<b>Returns:</b><br>A reference to the newly created thread.<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadGroup.create"></a>final Thread <a name="create"></a><span class="ddoc_psymbol">create</span>(void delegate() <i>dg</i>);
</dt>
<dd>Creates and starts a new Thread object that executes <i>dg</i> and adds it to
 the list of tracked threads.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void delegate() <i>dg</i></td>
<td valign=top>The thread function.</td></tr>
</table><p></p>
<b>Returns:</b><br>A reference to the newly created thread.<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadGroup.add"></a>final void <a name="add"></a><span class="ddoc_psymbol">add</span>(Thread <i>t</i>);
</dt>
<dd>Add <i>t</i> to the list of tracked threads if it is not already being tracked.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Thread <i>t</i></td>
<td valign=top>The thread to <a name="add"></a><span class="ddoc_psymbol">add</span>.</td></tr>
</table><p></p>
<b>In:</b><br>
<i>t</i> must not be <b>null</b>.<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadGroup.remove"></a>final void <a name="remove"></a><span class="ddoc_psymbol">remove</span>(Thread <i>t</i>);
</dt>
<dd>Removes <i>t</i> from the list of tracked threads.  No operation will be
 performed if <i>t</i> is not currently being tracked by this object.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Thread <i>t</i></td>
<td valign=top>The thread to <a name="remove"></a><span class="ddoc_psymbol">remove</span>.</td></tr>
</table><p></p>
<b>In:</b><br>
<i>t</i> must not be <b>null</b>.<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadGroup.opApply"></a>final int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(scope int delegate(ref Thread) <i>dg</i>);
</dt>
<dd>Operates on all threads currently tracked by this object.<p></p>

</dd>
<dt class="d_decl"><a name=".ThreadGroup.joinAll"></a>final void <a name="joinAll"></a><span class="ddoc_psymbol">joinAll</span>(bool <i>rethrow</i> = true);
</dt>
<dd>Iteratively joins all tracked threads.  This function will block add,
 remove, and opApply until it completes.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>bool <i>rethrow</i></td>
<td valign=top>Rethrow any unhandled exception which may have caused the
            current thread to terminate.</td></tr>
</table><p></p>
<b>Throws:</b><br>Any exception not handled by the joined threads.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Fiber"></a>class <a name="Fiber"></a><span class="ddoc_psymbol">Fiber</span>;
</dt>
<dd>This class provides a cooperative concurrency mechanism integrated with the
 threading and garbage collection functionality.  Calling a fiber may be
 considered a blocking operation that returns when the fiber yields (via
 <a name="Fiber"></a><span class="ddoc_psymbol">Fiber</span>.yield()).  Execution occurs within the context of the calling thread
 so synchronization is not necessary to guarantee memory visibility so long
 as the same thread calls the fiber each time.  Please note that there is no
 requirement that a fiber be bound to one specific thread.  Rather, fibers
 may be freely passed between threads so long as they are not currently
 executing.  Like threads, a new fiber thread may be created using either
 derivation or composition, as in the following example.
<p></p>
<b>Warning:</b><br>
Status registers are not saved by the current implementations. This means
 floating point exception status bits (overflow, divide by 0), rounding mode
 and similar stuff is set per-thread, not per <a name="Fiber"></a><span class="ddoc_psymbol">Fiber</span>!

<p></p>
<b>Warning:</b><br>
On ARM FPU registers are not saved if druntime was compiled as ARM_SoftFloat.
 If such a build is used on a ARM_SoftFP system which actually has got a FPU
 and other libraries are using the FPU registers (other code is compiled
 as ARM_SoftFP) this can cause problems. Druntime must be compiled as
 ARM_SoftFP in this case.

<p></p>
<b>Example:</b><br>
<pre class="d_code">
<span class="d_keyword">class</span> DerivedFiber : <span class="d_psymbol">Fiber</span>
{
    <span class="d_keyword">this</span>()
    {
        <span class="d_keyword">super</span>( &amp;run );
    }

<span class="d_keyword">private</span> :
    <span class="d_keyword">void</span> run()
    {
        printf( <span class="d_string">"Derived fiber running.\n"</span> );
    }
}

<span class="d_keyword">void</span> fiberFunc()
{
    printf( <span class="d_string">"Composed fiber running.\n"</span> );
    <span class="d_psymbol">Fiber</span>.yield();
    printf( <span class="d_string">"Composed fiber running.\n"</span> );
}

<span class="d_comment">// create instances of each type
</span><span class="d_psymbol">Fiber</span> derived = <span class="d_keyword">new</span> DerivedFiber();
<span class="d_psymbol">Fiber</span> composed = <span class="d_keyword">new</span> <span class="d_psymbol">Fiber</span>( &amp;fiberFunc );

<span class="d_comment">// call both fibers once
</span>derived.call();
composed.call();
printf( <span class="d_string">"Execution returned to calling context.\n"</span> );
composed.call();

<span class="d_comment">// since each fiber has run to completion, each should have state TERM
</span><span class="d_keyword">assert</span>( derived.state == <span class="d_psymbol">Fiber</span>.State.TERM );
<span class="d_keyword">assert</span>( composed.state == <span class="d_psymbol">Fiber</span>.State.TERM );

</pre>

<p></p>
<b>Authors:</b><br>Based on a design by Mikola Lysenko.<p></p>

<dl><dt class="d_decl"><a name=".Fiber.this"></a>this(void function() <i>fn</i>, size_t <i>sz</i> = PAGESIZE * 4);
</dt>
<dd>Initializes a fiber object which is associated with a static
 D function.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void function() <i>fn</i></td>
<td valign=top>The fiber function.</td></tr>
<tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The stack size for this fiber.</td></tr>
</table><p></p>
<b>In:</b><br>
<i>fn</i> must not be <b>null</b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Fiber.this"></a>this(void delegate() <i>dg</i>, size_t <i>sz</i> = PAGESIZE * 4);
</dt>
<dd>Initializes a fiber object which is associated with a dynamic
 D function.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>void delegate() <i>dg</i></td>
<td valign=top>The fiber function.</td></tr>
<tr><td valign=top>size_t <i>sz</i></td>
<td valign=top>The stack size for this fiber.</td></tr>
</table><p></p>
<b>In:</b><br>
<i>dg</i> must not be <b>null</b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Fiber.call"></a>final Throwable <a name="call"></a><span class="ddoc_psymbol">call</span>(bool <i>rethrow</i> = true);
</dt>
<dd>Transfers execution to this fiber object.  The calling context will be
 suspended until the fiber calls Fiber.yield() or until it terminates
 via an unhandled exception.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>bool <i>rethrow</i></td>
<td valign=top>Rethrow any unhandled exception which may have caused this
            fiber to terminate.</td></tr>
</table><p></p>
<b>In:</b><br>
This fiber must be in state HOLD.

<p></p>
<b>Throws:</b><br>Any exception not handled by the joined thread.

<p></p>
<b>Returns:</b><br>Any exception not handled by this fiber if <i>rethrow</i> = <b>false</b>, <b>null</b>
  otherwise.<p></p>

</dd>
<dt class="d_decl"><a name=".Fiber.reset"></a>final void <a name="reset"></a><span class="ddoc_psymbol">reset</span>();
<br><a name=".Fiber.reset"></a>final void <a name="reset"></a><span class="ddoc_psymbol">reset</span>(void function() <i>fn</i>);
<br><a name=".Fiber.reset"></a>final void <a name="reset"></a><span class="ddoc_psymbol">reset</span>(void delegate() <i>dg</i>);
</dt>
<dd>Resets this fiber so that it may be re-used, optionally with a
 new function/delegate.  This routine may only be called for
 fibers that have terminated, as doing otherwise could result in
 scope-dependent functionality that is not executed.
 Stack-based classes, for example, may not be cleaned up
 properly if a fiber is <a name="reset"></a><span class="ddoc_psymbol">reset</span> before it has terminated.
<p></p>
<b>In:</b><br>
This fiber must be in state TERM.<p></p>

</dd>
<dt class="d_decl"><a name=".Fiber.State"></a>enum <a name="State"></a><span class="ddoc_psymbol">State</span>: int;
</dt>
<dd>A fiber may occupy one of three states: HOLD, EXEC, and TERM.  The HOLD
 state applies to any fiber that is suspended and ready to be called.
 The EXEC state will be set for any fiber that is currently executing.
 And the TERM state is set when a fiber terminates.  Once a fiber
 terminates, it must be reset before it may be called again.<p></p>

<dl><dt class="d_decl"><a name=".Fiber.State.HOLD"></a><a name="HOLD"></a><span class="ddoc_psymbol">HOLD</span></dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".Fiber.State.EXEC"></a><a name="EXEC"></a><span class="ddoc_psymbol">EXEC</span></dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".Fiber.State.TERM"></a><a name="TERM"></a><span class="ddoc_psymbol">TERM</span></dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Fiber.state"></a>final const @property State <a name="state"></a><span class="ddoc_psymbol">state</span>();
</dt>
<dd>Gets the current <a name="state"></a><span class="ddoc_psymbol">state</span> of this fiber.
<p></p>
<b>Returns:</b><br>The <a name="state"></a><span class="ddoc_psymbol">state</span> of this fiber as an enumerated value.<p></p>

</dd>
<dt class="d_decl"><a name=".Fiber.yield"></a>static void <a name="yield"></a><span class="ddoc_psymbol">yield</span>();
</dt>
<dd>Forces a context switch to occur away from the calling fiber.<p></p>

</dd>
<dt class="d_decl"><a name=".Fiber.yieldAndThrow"></a>static void <a name="yieldAndThrow"></a><span class="ddoc_psymbol">yieldAndThrow</span>(Throwable <i>t</i>);
</dt>
<dd>Forces a context switch to occur away from the calling fiber and then
 throws obj in the calling fiber.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Throwable <i>t</i></td>
<td valign=top>The object to throw.</td></tr>
</table><p></p>
<b>In:</b><br>
<i>t</i> must not be <b>null</b>.<p></p>

</dd>
<dt class="d_decl"><a name=".Fiber.getThis"></a>static Fiber <a name="getThis"></a><span class="ddoc_psymbol">getThis</span>();
</dt>
<dd>Provides a reference to the calling fiber or <b>null</b> if no fiber is
 currently active.
<p></p>
<b>Returns:</b><br>The fiber object representing the calling fiber or <b>null</b> if no fiber
  is currently active within this thread. The result of deleting this object is undefined.<p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Sean Kelly 2005 - 2012.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

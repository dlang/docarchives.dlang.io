<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.uuid - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){
        return function(aa, bb){
            return aa == bb ? 0 : (aa < bb ? -1 : 1);
        }(lastName(a).toLowerCase(), lastName(b).toLowerCase());
    });

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos 2.066.0</a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://code.dlang.org" title="Third Party Packages">Third Party Packages</a></li>
    </ul>
</div>
</div>
    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>
</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/uuid.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.uuid</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/uuid.d -->
<script type="text/javascript">inhibitQuickIndex = 1</script>
<p></p>
<table cellspacing=0 cellpadding=5 class=book><caption></caption><tr><th>Category</th> <th>Functions</th>
</tr>
<tr><td valign=top class="donthyphenate" nowrap>Parsing UUIDs</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#parseUUID">parseUUID</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#UUID(string)">UUID(string)</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#UUIDParsingException">UUIDParsingException</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#uuidRegex">uuidRegex</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate" nowrap>Generating UUIDs</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#sha1UUID">sha1UUID</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#randomUUID">randomUUID</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#md5UUID">md5UUID</a>&nbsp;</font></td>
</tr>
<tr><td valign=top class="donthyphenate" nowrap>Using UUIDs</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#uuidVersion">UUID.uuidVersion</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#variant">UUID.variant</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#toString">UUID.toString</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#data">UUID.data</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#swap">UUID.swap</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#opEquals">UUID.opEquals</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#opCmp">UUID.opCmp</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#toHash">UUID.toHash</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate" nowrap>UUID namespaces</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#dnsNamespace">dnsNamespace</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#urlNamespace">urlNamespace</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#oidNamespace">oidNamespace</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#x500Namespace">x500Namespace</a>&nbsp;</font> </td>
</tr>
</table>
<p></p>

 A <a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>, or
 <a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">Universally unique identifier</a>,
 is intended to uniquely identify information in a distributed environment
 without significant central coordination. It can be
 used to tag objects with very short lifetimes, or to reliably identify very
 persistent objects across a network.
<p></p>

 UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify
 rows or records in order to ensure that they are unique across different
 databases, or for publication/subscription services. Network messages may be
 identified with a UUID to ensure that different parts of a message are put back together
 again. Distributed computing may use UUIDs to identify a remote procedure call.
 Transactions and classes involved in serialization may be identified by UUIDs.
 Microsoft's component object model (COM) uses UUIDs to distinguish different software
 component interfaces. UUIDs are inserted into documents from Microsoft Office programs.
 UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are
 also a basis for OIDs (object identifiers), and URNs (uniform resource name).
<p></p>

 An attractive feature of UUIDs when compared to alternatives is their relative small size,
 of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require
 a centralized authority.
<p></p>

 When UUIDs are generated by one of the defined mechanisms, they are either guaranteed
 to be unique, different from all other generated UUIDs (that is, it has never been
 generated before and it will never be generated again), or it is extremely likely
 to be unique (depending on the mechanism).
<p></p>

 For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly
 initialized. An UUID is empty if <a href="#empty"><span class="d_inlinecode">UUID.empty</span></a> is <b>true</b>. Empty UUIDs are equal to
 <span class="d_inlinecode">UUID.init</span>, which is a UUID with all 16 bytes set to 0.
 Use UUID's constructors or the UUID generator functions to get an initialized UUID.
<p></p>

 This is a port of <a href="http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html"> boost.uuid</a> from the Boost project with some minor additions and API
 changes for a more D-like API.

<p></p>
<b>Examples:</b><br><pre class="d_code">UUID[] ids;
ids ~= randomUUID();
ids ~= md5UUID(<span class="d_string">"test.name.123"</span>);
ids ~= sha1UUID(<span class="d_string">"test.name.123"</span>);

<span class="d_keyword">foreach</span>(entry; ids)
{
    <span class="d_keyword">assert</span>(entry.variant == UUID.Variant.rfc4122);
}

<span class="d_keyword">assert</span>(ids[0].uuidVersion == UUID.Version.randomNumberBased);
<span class="d_keyword">assert</span>(ids[1].toString() == <span class="d_string">"22390768-cced-325f-8f0f-cfeaa19d0ccd"</span>);
<span class="d_keyword">assert</span>(ids[1].data == [34, 57, 7, 104, 204, 237, 50, 95, 143, 15, 207,
    234, 161, 157, 12, 205]);

UUID id;
<span class="d_keyword">assert</span>(id.empty);

</pre>
<p></p>
<b>Standards:</b><br><a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>

<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">http://en.wikipedia.org/wiki/Universally_unique_identifier</a>

<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<p></p>
<b>Authors:</b><br>Johannes Pfau
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/uuid.d">std/uuid.d</a>

<p></p>

<dl><dt class="d_decl"><a name=".UUID"></a>struct <a name="UUID"></a><span class="ddoc_psymbol">UUID</span>;
</dt>
<dd><p></p>
<dl><dt class="d_decl"><a name=".UUID.Variant"></a>enum <a name="Variant"></a><span class="ddoc_psymbol">Variant</span>: int;
</dt>
<dd>RFC 4122 defines different internal data layouts for UUIDs. These are
 the UUID formats supported by this module. It's
 possible to read, compare and use all these Variants, but
 UUIDs generated by this module will always be in rfc4122 format.
<p></p>
<b>Note:</b><br>
Do not confuse this with <a href="std_variant.html#Variant"><span class="d_inlinecode">std.variant.Variant</span></a>. This has nothing
 to do with <a href="std_variant.html#Variant"><span class="d_inlinecode">std.variant.Variant</span></a>.<p></p>

<dl><dt class="d_decl"><a name=".UUID.Variant.ncs"></a><a name="ncs"></a><span class="ddoc_psymbol">ncs</span></dt>
<dd>NCS backward compatibility<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Variant.rfc4122"></a><a name="rfc4122"></a><span class="ddoc_psymbol">rfc4122</span></dt>
<dd>Defined in RFC 4122 document<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Variant.microsoft"></a><a name="microsoft"></a><span class="ddoc_psymbol">microsoft</span></dt>
<dd>Microsoft Corporation backward compatibility<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Variant.future"></a><a name="future"></a><span class="ddoc_psymbol">future</span></dt>
<dd>Reserved for <a name="future"></a><span class="ddoc_psymbol">future</span> use<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".UUID.Version"></a>enum <a name="Version"></a><span class="ddoc_psymbol">Version</span>: int;
</dt>
<dd>RFC 4122 defines different UUID versions. The version shows
 how a UUID was generated, e.g. a version 4 UUID was generated
 from a random number, a version 3 UUID from an MD5 hash of a name.
<p></p>
<b>Note:</b><br>
All of these UUID versions can be read and processed by
 <span class="d_inlinecode">std.uuid</span>, but only version 3, 4 and 5 UUIDs can be generated.<p></p>

<dl><dt class="d_decl"><a name=".UUID.Version.unknown"></a><a name="unknown"></a><span class="ddoc_psymbol">unknown</span></dt>
<dd>Unknown version<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Version.timeBased"></a><a name="timeBased"></a><span class="ddoc_psymbol">timeBased</span></dt>
<dd>Version 1<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Version.dceSecurity"></a><a name="dceSecurity"></a><span class="ddoc_psymbol">dceSecurity</span></dt>
<dd>Version 2<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Version.nameBasedMD5"></a><a name="nameBasedMD5"></a><span class="ddoc_psymbol">nameBasedMD5</span></dt>
<dd>Version 3 (Name based + MD5)<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Version.randomNumberBased"></a><a name="randomNumberBased"></a><span class="ddoc_psymbol">randomNumberBased</span></dt>
<dd>Version 4 (Random)<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.Version.nameBasedSHA1"></a><a name="nameBasedSHA1"></a><span class="ddoc_psymbol">nameBasedSHA1</span></dt>
<dd>Version 5 (Name based + SHA-1)<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".UUID.data"></a>ubyte[16] <a name="data"></a><span class="ddoc_psymbol">data</span>;
</dt>
<dd>It is sometimes useful to get or set the 16 bytes of a UUID
 directly.
<p></p>
<b>Note:</b><br>
UUID uses a 16-ubyte representation for the UUID <a name="data"></a><span class="ddoc_psymbol">data</span>.
 RFC 4122 defines a UUID as a special structure in big-endian
 format. These 16-ubytes always equal the big-endian structure
 defined in RFC 4122.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> rawData = uuid.<span class="d_psymbol">data</span>; <span class="d_comment">//get data
</span>rawData[0] = 1; <span class="d_comment">//modify
</span>uuid.<span class="d_psymbol">data</span> = rawData; <span class="d_comment">//set data
</span>uuid.<span class="d_psymbol">data</span>[1] = 2; <span class="d_comment">//modify directly
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.this"></a>pure nothrow @safe this(ref ubyte[16] <i>uuidData</i>);
<br><a name=".UUID.this"></a>pure nothrow @safe this(in ubyte[16] <i>uuidData</i>);
</dt>
<dd>Construct a UUID struct from the 16 byte representation
 of a UUID.<p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">enum</span> <span class="d_keyword">ubyte</span>[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
<span class="d_keyword">auto</span> uuid = UUID(data);
<span class="d_keyword">enum</span> ctfe = UUID(data);
<span class="d_keyword">assert</span>(uuid.data == data);
<span class="d_keyword">assert</span>(ctfe.data == data);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".UUID.this"></a>this(T)(in T[] <i>uuid</i>) if (isSomeChar!(Unqual!T));
</dt>
<dd><a name="UUID(string)"></a>
 Parse a UUID from its canonical string form. An UUID in its
 canonical form looks like this: 8ab3060e-2cba-4f23-b74c-b52db3bdfb46
<p></p>
<b>Throws:</b><br><a href="#UUIDParsingException"><span class="d_inlinecode">UUIDParsingException</span></a> if the input is invalid

<p></p>
<b>CTFE:</b><br>
This function is supported in CTFE code. Note that error messages
 caused by a malformed UUID parsed at compile time can be cryptic,
 but errors are detected and reported at
 compile time.

<p></p>
<b>Note:</b><br>
This is a strict parser. It only accepts the pattern above.
 It doesn't support any leading or trailing characters. It only
 accepts characters used for hex numbers and the string must have
 hyphens exactly like above.
<p></p>

 For a less strict parser, see <a href="#parseUUID"><span class="d_inlinecode">parseUUID</span></a>

<p></p>
<b>Examples:</b><br><pre class="d_code">id = UUID(<span class="d_string">"8AB3060E-2cba-4f23-b74c-b52db3bdfb46"</span>);
<span class="d_keyword">assert</span>(id.data == [138, 179, 6, 14, 44, 186, 79, 35, 183, 76,
   181, 45, 179, 189, 251, 70]);
<span class="d_keyword">assert</span>(id.toString() == <span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46"</span>);

<span class="d_comment">//Can also be used in CTFE, for example as UUID literals:
</span><span class="d_keyword">enum</span> ctfeID = UUID(<span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46"</span>);
<span class="d_comment">//here parsing is done at compile time, no runtime overhead!
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.empty"></a>const pure nothrow @property @trusted bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd>Returns <b>true</b> if and only if the UUID is equal
 to {00000000-0000-0000-0000-000000000000}<p></p>
<b>Examples:</b><br><pre class="d_code">
UUID id;
<span class="d_keyword">assert</span>(id.<span class="d_psymbol">empty</span>);
id = UUID(<span class="d_string">"00000000-0000-0000-0000-000000000001"</span>);
<span class="d_keyword">assert</span>(!id.<span class="d_psymbol">empty</span>);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".UUID.variant"></a>const pure nothrow @property @safe Variant <a name="variant"></a><span class="ddoc_psymbol">variant</span>();
</dt>
<dd>RFC 4122 defines different internal data layouts for UUIDs.
 Returns the format used by this UUID.
<p></p>
<b>Note:</b><br>
Do not confuse this with <a href="std_variant.html#Variant"><span class="d_inlinecode">std.variant.Variant</span></a>. This has nothing
 to do with <a href="std_variant.html#Variant"><span class="d_inlinecode">std.variant.Variant</span></a>. The type of this property is
 <a href="#Variant"><span class="d_inlinecode">std.uuid.UUID.Variant</span></a>.

<p></p>
<b>See Also:</b><br><a href="#Variant"><span class="d_inlinecode">UUID.Variant</span></a><p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">assert</span>(UUID(<span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46"</span>).<span class="d_psymbol">variant</span>
   == UUID.Variant.rfc4122);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".UUID.uuidVersion"></a>const pure nothrow @property @safe Version <a name="uuidVersion"></a><span class="ddoc_psymbol">uuidVersion</span>();
</dt>
<dd>RFC 4122 defines different UUID versions. The version shows
 how a UUID was generated, e.g. a version 4 UUID was generated
 from a random number, a version 3 UUID from an MD5 hash of a name.
 Returns the version used by this UUID.
<p></p>
<b>See Also:</b><br><a href="#Version"><span class="d_inlinecode">UUID.Version</span></a><p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">assert</span>(UUID(<span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46"</span>).<span class="d_psymbol">uuidVersion</span>
    == UUID.Version.randomNumberBased);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".UUID.swap"></a>pure nothrow @safe void <a name="swap"></a><span class="ddoc_psymbol">swap</span>(ref UUID <i>rhs</i>);
</dt>
<dd>Swap the data of this UUID with the data of <i>rhs</i>.<p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">immutable</span> <span class="d_keyword">ubyte</span>[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
UUID u1;
UUID u2 = UUID(data);
u1.<span class="d_psymbol">swap</span>(u2);

<span class="d_keyword">assert</span>(u1 == UUID(data));
<span class="d_keyword">assert</span>(u2 == UUID.init);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".UUID.opEquals"></a>const pure nothrow @safe bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(in UUID <i>s</i>);
<br><a name=".UUID.opEquals"></a>const pure nothrow @safe bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref UUID <i>s</i>);
<br><a name=".UUID.opCmp"></a>const pure nothrow @safe int <a name="opCmp"></a><span class="ddoc_psymbol">opCmp</span>(in UUID <i>s</i>);
<br><a name=".UUID.opCmp"></a>const pure nothrow @safe int <a name="opCmp"></a><span class="ddoc_psymbol">opCmp</span>(ref UUID <i>s</i>);
<br><a name=".UUID.toHash"></a>const pure nothrow @safe size_t <a name="toHash"></a><span class="ddoc_psymbol">toHash</span>();
</dt>
<dd>All of the standard numeric operators are defined for
 the UUID struct.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//compare UUIDs
</span><span class="d_keyword">assert</span>(UUID(<span class="d_string">"00000000-0000-0000-0000-000000000000"</span>) == UUID.init);

<span class="d_comment">//UUIDs in associative arrays:
</span><span class="d_keyword">int</span>[UUID] test = [UUID(<span class="d_string">"8a94f585-d180-44f7-8929-6fca0189c7d0"</span>) : 1,
    UUID(<span class="d_string">"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a"</span>) : 2,
    UUID(<span class="d_string">"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1"</span>) : 3];

<span class="d_keyword">assert</span>(test[UUID(<span class="d_string">"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1"</span>)] == 3);

<span class="d_comment">//UUIDS can be sorted:
</span><span class="d_keyword">import</span> std.algorithm;
UUID[] ids = [UUID(<span class="d_string">"8a94f585-d180-44f7-8929-6fca0189c7d0"</span>),
              UUID(<span class="d_string">"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a"</span>),
              UUID(<span class="d_string">"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1"</span>)];
sort(ids);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".UUID.toString"></a>const void <a name="toString"></a><span class="ddoc_psymbol">toString</span>(scope void delegate(const(char)[]) <i>sink</i>);
<br><a name=".UUID.toString"></a>const pure nothrow @safe string <a name="toString"></a><span class="ddoc_psymbol">toString</span>();
</dt>
<dd>Return the UUID as a string in the canonical form.<p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">immutable</span> str = <span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46"</span>;
<span class="d_keyword">auto</span> id = UUID(str);
<span class="d_keyword">assert</span>(id.<span class="d_psymbol">toString</span>() == str);
</pre>
<p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".md5UUID"></a>pure @safe UUID <a name="md5UUID"></a><span class="ddoc_psymbol">md5UUID</span>(const(char[]) <i>name</i>, const UUID <i>namespace</i> = UUID.init);
<br><a name=".md5UUID"></a>pure @safe UUID <a name="md5UUID"></a><span class="ddoc_psymbol">md5UUID</span>(const(ubyte[]) <i>data</i>, const UUID <i>namespace</i> = UUID.init);
</dt>
<dd>This function generates a <i>name</i> based (Version 3) UUID from a <i>namespace</i> UUID and a <i>name</i>.
 If no <i>namespace</i> UUID was passed, the empty UUID <span class="d_inlinecode">UUID.init</span> is used.
<p></p>
<b>Note:</b><br>
The default namespaces (<a href="#dnsNamespace"><span class="d_inlinecode">dnsNamespace</span></a>, ...) defined by
 this module should be used when appropriate.
<p></p>

 RFC 4122 recommends to use Version 5 UUIDs (SHA-1) instead of Version 3
 UUIDs (MD5) for new applications.

<p></p>
<b>CTFE:</b><br>
CTFE is not supported.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//Use default UUID.init namespace
</span><span class="d_keyword">auto</span> simpleID = <span class="d_psymbol">md5UUID</span>(<span class="d_string">"test.uuid.any.string"</span>);

<span class="d_comment">//use a name-based id as namespace
</span><span class="d_keyword">auto</span> <span class="d_param">namespace</span> = <span class="d_psymbol">md5UUID</span>(<span class="d_string">"my.app"</span>);
<span class="d_keyword">auto</span> id = <span class="d_psymbol">md5UUID</span>(<span class="d_string">"some-description"</span>, <span class="d_param">namespace</span>);
</pre>

<p></p>
<b>Note:</b><br>
RFC 4122 isn't very clear on how UUIDs should be generated from names.
 It is possible that different implementations return different UUIDs
 for the same input, so be warned. The implementation for UTF-8 strings
 and byte arrays used by <span class="d_inlinecode">std.uuid</span> is compatible with Boost's implementation.
 <span class="d_inlinecode">std.uuid</span> guarantees that the same input to this function will generate
 the same output at any time, on any system (this especially means endianness
 doesn't matter).

<p></p>
<b>Note:</b><br>
This function does not provide overloads for wstring and dstring, as
 there's no clear answer on how that should be implemented. It could be
 argued, that string, wstring and dstring input should have the same output,
 but that wouldn't be compatible with Boost, which generates different output
 for strings and wstrings. It's always possible to pass wstrings and dstrings
 by using the ubyte[] function overload (but be aware of endianness issues!).<p></p>

</dd>
<dt class="d_decl"><a name=".sha1UUID"></a>pure @safe UUID <a name="sha1UUID"></a><span class="ddoc_psymbol">sha1UUID</span>(in char[] <i>name</i>, const UUID <i>namespace</i> = UUID.init);
<br><a name=".sha1UUID"></a>pure @safe UUID <a name="sha1UUID"></a><span class="ddoc_psymbol">sha1UUID</span>(in ubyte[] <i>data</i>, const UUID <i>namespace</i> = UUID.init);
</dt>
<dd>This function generates a <i>name</i> based (Version 5) UUID from a <i>namespace</i>
 UUID and a <i>name</i>.
 If no <i>namespace</i> UUID was passed, the empty UUID <span class="d_inlinecode">UUID.init</span> is used.
<p></p>
<b>Note:</b><br>
The default namespaces (<a href="#dnsNamespace"><span class="d_inlinecode">dnsNamespace</span></a>, ...) defined by
 this module should be used when appropriate.

<p></p>
<b>CTFE:</b><br>
CTFE is not supported.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//Use default UUID.init namespace
</span><span class="d_keyword">auto</span> simpleID = <span class="d_psymbol">sha1UUID</span>(<span class="d_string">"test.uuid.any.string"</span>);

<span class="d_comment">//use a name-based id as namespace
</span><span class="d_keyword">auto</span> <span class="d_param">namespace</span> = <span class="d_psymbol">sha1UUID</span>(<span class="d_string">"my.app"</span>);
<span class="d_keyword">auto</span> id = <span class="d_psymbol">sha1UUID</span>(<span class="d_string">"some-description"</span>, <span class="d_param">namespace</span>);
</pre>

<p></p>
<b>Note:</b><br>
RFC 4122 isn't very clear on how UUIDs should be generated from names.
 It is possible that different implementations return different UUIDs
 for the same input, so be warned. The implementation for UTF-8 strings
 and byte arrays used by <span class="d_inlinecode">std.uuid</span> is compatible with Boost's implementation.
 <span class="d_inlinecode">std.uuid</span> guarantees that the same input to this function will generate
 the same output at any time, on any system (this especially means endianness
 doesn't matter).

<p></p>
<b>Note:</b><br>
This function does not provide overloads for wstring and dstring, as
 there's no clear answer on how that should be implemented. It could be
 argued, that string, wstring and dstring input should have the same output,
 but that wouldn't be compatible with Boost, which generates different output
 for strings and wstrings. It's always possible to pass wstrings and dstrings
 by using the ubyte[] function overload (but be aware of endianness issues!).<p></p>

</dd>
<dt class="d_decl"><a name=".randomUUID"></a>@trusted UUID <a name="randomUUID"></a><span class="ddoc_psymbol">randomUUID</span>();
<br><a name=".randomUUID"></a>@trusted UUID <a name="randomUUID"></a><span class="ddoc_psymbol">randomUUID</span>(RNG)(ref RNG <i>randomGen</i>) if (isUniformRNG!RNG &amp;&amp; isIntegral!(typeof(RNG.front)));
</dt>
<dd>This function generates a random number based UUID from a random
 number generator.
<p></p>
<b>CTFE:</b><br>
This function is not supported at compile time.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//simple call
</span><span class="d_keyword">auto</span> uuid = <span class="d_psymbol">randomUUID</span>();

<span class="d_comment">//provide a custom RNG. Must be seeded manually.
</span>Xorshift192 gen;

gen.seed(unpredictableSeed);
<span class="d_keyword">auto</span> uuid3 = <span class="d_psymbol">randomUUID</span>(gen);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".parseUUID"></a>UUID <a name="parseUUID"></a><span class="ddoc_psymbol">parseUUID</span>(T)(T <i>uuidString</i>) if (isSomeString!T);
<br><a name=".parseUUID"></a>UUID <a name="parseUUID"></a><span class="ddoc_psymbol">parseUUID</span>(Range)(ref Range <i>uuidRange</i>) if (isInputRange!Range &amp;&amp; is(Unqual!(ElementType!Range) == dchar));
</dt>
<dd>This is a less strict parser compared to the parser used in the
 UUID constructor. It enforces the following rules:
<p></p>
<ul>   <li>hex numbers are always two hexdigits([0-9a-fA-F])</li>
   <li>there must be exactly 16 such pairs in the input, not less, not more</li>
   <li>there can be exactly one dash between two hex-pairs, but not more</li>
   <li>there can be multiple characters enclosing the 16 hex pairs,
     as long as these characters do not contain [0-9a-fA-F]</li>
 </ul>

<p></p>
<b>Note:</b><br>
 Like most parsers, it consumes its argument. This means:
<pre class="d_code">string s = <span class="d_string">"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46"</span>;
<span class="d_psymbol">parseUUID</span>(s);
<span class="d_keyword">assert</span>(s == <span class="d_string">""</span>);
</pre>

<p></p>
<b>Throws:</b><br><a href="#UUIDParsingException"><span class="d_inlinecode">UUIDParsingException</span></a> if the input is invalid

<p></p>
<b>CTFE:</b><br>
This function is supported in CTFE code. Note that error messages
 caused by a malformed UUID parsed at compile time can be cryptic,
 but errors are detected and reported at compile time.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> id = <span class="d_psymbol">parseUUID</span>(<span class="d_string">"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46"</span>);
<span class="d_comment">//no dashes
</span>id = <span class="d_psymbol">parseUUID</span>(<span class="d_string">"8ab3060e2cba4f23b74cb52db3bdfb46"</span>);
<span class="d_comment">//dashes at different positions
</span>id = <span class="d_psymbol">parseUUID</span>(<span class="d_string">"8a-b3-06-0e2cba4f23b74c-b52db3bdfb-46"</span>);
<span class="d_comment">//leading / trailing characters
</span>id = <span class="d_psymbol">parseUUID</span>(<span class="d_string">"{8ab3060e-2cba-4f23-b74c-b52db3bdfb46}"</span>);
<span class="d_comment">//unicode
</span>id = <span class="d_psymbol">parseUUID</span>(<span class="d_string">"ü8ab3060e2cba4f23b74cb52db3bdfb46ü"</span>);
<span class="d_comment">//multiple trailing/leading characters
</span>id = <span class="d_psymbol">parseUUID</span>(<span class="d_string">"///8ab3060e2cba4f23b74cb52db3bdfb46||"</span>);

<span class="d_comment">//Can also be used in CTFE, for example as UUID literals:
</span><span class="d_keyword">enum</span> ctfeID = <span class="d_psymbol">parseUUID</span>(<span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46"</span>);
<span class="d_comment">//here parsing is done at compile time, no runtime overhead!
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".dnsNamespace"></a>UUID <a name="dnsNamespace"></a><span class="ddoc_psymbol">dnsNamespace</span>;
</dt>
<dd>Default namespace from RFC 4122
<p></p>
Name string is a fully-qualified domain name<p></p>

</dd>
<dt class="d_decl"><a name=".urlNamespace"></a>UUID <a name="urlNamespace"></a><span class="ddoc_psymbol">urlNamespace</span>;
</dt>
<dd>Default namespace from RFC 4122
<p></p>
Name string is a URL<p></p>

</dd>
<dt class="d_decl"><a name=".oidNamespace"></a>UUID <a name="oidNamespace"></a><span class="ddoc_psymbol">oidNamespace</span>;
</dt>
<dd>Default namespace from RFC 4122
<p></p>
Name string is an ISO OID<p></p>

</dd>
<dt class="d_decl"><a name=".x500Namespace"></a>UUID <a name="x500Namespace"></a><span class="ddoc_psymbol">x500Namespace</span>;
</dt>
<dd>Default namespace from RFC 4122
<p></p>
Name string is an X.500 DN (in DER or a text output format)<p></p>

</dd>
<dt class="d_decl"><a name=".uuidRegex"></a>string <a name="uuidRegex"></a><span class="ddoc_psymbol">uuidRegex</span>;
</dt>
<dd>Regex string to extract UUIDs from text.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.algorithm;
<span class="d_keyword">import</span> std.regex;

string test = <span class="d_string">"Lorem ipsum dolor sit amet, consetetur "</span>
    <span class="d_string">"6ba7b814-9dad-11d1-80b4-00c04fd430c8 sadipscing \n"</span>
    <span class="d_string">"elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore \r\n"</span>
    <span class="d_string">"magna aliquyam erat, sed diam voluptua. "</span>
    <span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46 At vero eos et accusam et "</span>
    <span class="d_string">"justo duo dolores et ea rebum."</span>;

<span class="d_keyword">auto</span> r = regex(<span class="d_psymbol">uuidRegex</span>, <span class="d_string">"g"</span>);

UUID[] found;
<span class="d_keyword">foreach</span>(c; match(test, r))
{
    found ~= UUID(c.hit);
}

writeln(found);
</pre>
<p></p>
<b>Examples:</b><br><pre class="d_code">
<span class="d_keyword">import</span> std.algorithm;
<span class="d_keyword">import</span> std.regex;

string test = <span class="d_string">"Lorem ipsum dolor sit amet, consetetur "</span>~
<span class="d_string">"6ba7b814-9dad-11d1-80b4-00c04fd430c8 sadipscing \n"</span>~
<span class="d_string">"elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore \r\n"</span>~
<span class="d_string">"magna aliquyam erat, sed diam voluptua. "</span>~
<span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46 At vero eos et accusam et "</span>~
<span class="d_string">"justo duo dolores et ea rebum."</span>;

<span class="d_keyword">auto</span> r = regex(<span class="d_psymbol">uuidRegex</span>, <span class="d_string">"g"</span>);
UUID[] found;
<span class="d_keyword">foreach</span>(c; match(test, r))
{
    found ~= UUID(c.hit);
}
<span class="d_keyword">assert</span>(found == [
    UUID(<span class="d_string">"6ba7b814-9dad-11d1-80b4-00c04fd430c8"</span>),
    UUID(<span class="d_string">"8ab3060e-2cba-4f23-b74c-b52db3bdfb46"</span>),
]);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".UUIDParsingException"></a>class <a name="UUIDParsingException"></a><span class="ddoc_psymbol">UUIDParsingException</span>: <u>object.Exception</u>;
</dt>
<dd>This exception is thrown if an error occurs when parsing a UUID
 from a string.<p></p>

<dl><dt class="d_decl"><a name=".UUIDParsingException.Reason"></a>enum <a name="Reason"></a><span class="ddoc_psymbol">Reason</span>: int;
<br><a name=".UUIDParsingException.reason"></a>Reason <a name="reason"></a><span class="ddoc_psymbol">reason</span>;
</dt>
<dd>The reason why parsing the UUID string failed (if known)<p></p>

<dl><dt class="d_decl"><a name=".UUIDParsingException.Reason.unknown"></a><a name="unknown"></a><span class="ddoc_psymbol">unknown</span></dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".UUIDParsingException.Reason.tooLittle"></a><a name="tooLittle"></a><span class="ddoc_psymbol">tooLittle</span></dt>
<dd>The passed in input was correct, but more input was expected.<p></p>

</dd>
<dt class="d_decl"><a name=".UUIDParsingException.Reason.tooMuch"></a><a name="tooMuch"></a><span class="ddoc_psymbol">tooMuch</span></dt>
<dd>The input data is too long (There's no guarantee the first part of the data is valid)<p></p>

</dd>
<dt class="d_decl"><a name=".UUIDParsingException.Reason.invalidChar"></a><a name="invalidChar"></a><span class="ddoc_psymbol">invalidChar</span></dt>
<dd>Encountered an invalid character<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".UUIDParsingException.input"></a>string <a name="input"></a><span class="ddoc_psymbol">input</span>;
</dt>
<dd>The original <a name="input"></a><span class="ddoc_psymbol">input</span> string which should have been parsed.<p></p>

</dd>
<dt class="d_decl"><a name=".UUIDParsingException.position"></a>size_t <a name="position"></a><span class="ddoc_psymbol">position</span>;
</dt>
<dd>The <a name="position"></a><span class="ddoc_psymbol">position</span> in the input string where the error occurred.<p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><!--/content-->


<div id="copyright">
Copyright Johannes Pfau 2011 - .
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

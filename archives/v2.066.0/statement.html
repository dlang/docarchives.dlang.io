
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Statements - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run-main-website.js" type="text/javascript"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
    var links = document.getElementById("navigation").getElementsByTagName("a");
    for (var i = 0; i < links.length; i++)
    {
        var url = "/" + links[i].getAttribute("href");
        if (window.location.href.match(url + "\x24") == url)
        {
            var cls = links[i].getAttribute("class");
            links[i].setAttribute("class", cls ? cls + " active" : "active");
            break;
        }
    }
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
    <div id="search-box">
        <form method="get" action="http://google.com/search">
            <img src="images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="images/search-button.gif" />
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <div id="search-dropdown">
                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </div>
        </form>
    </div>
    <div id="header">
        <a id="d-language" href="/">
        <img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png">
        D Programming Language</a>
    </div>
</div>

<!--Generated by Ddoc from statement.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D 2.066.0</a></h2>
<ul>    <li><a href="overview.html" title="D language overview">Overview</a></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://ddili.org/ders/d.en/index.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a>

    <div class="navblock">
<ul>    <li><a href="intro.html">Introduction</a></li>
    <li><a href="lex.html">Lexical</a></li>
    <li><a href="grammar.html">Grammar</a></li>
    <li><a href="module.html">Modules</a></li>
    <li><a href="declaration.html">Declarations</a></li>
    <li><a href="type.html">Types</a></li>
    <li><a href="property.html">Properties</a></li>
    <li><a href="attribute.html">Attributes</a></li>
    <li><a href="pragma.html">Pragmas</a></li>
    <li><a href="expression.html">Expressions</a></li>
    <li><a href="statement.html">Statements</a></li>
    <li><a href="arrays.html">Arrays</a></li>
    <li><a href="hash-map.html">Associative Arrays</a></li>
    <li><a href="struct.html">Structs &amp; Unions</a></li>
    <li><a href="class.html">Classes</a></li>
    <li><a href="interface.html">Interfaces</a></li>
    <li><a href="enum.html">Enums</a></li>
    <li><a href="const3.html">Const and Immutable</a></li>
    <li><a href="function.html">Functions</a></li>
    <li><a href="operatoroverloading.html">Operator Overloading</a></li>
    <li><a href="template.html">Templates</a></li>
    <li><a href="template-mixin.html">Template Mixins</a></li>
    <li><a href="contracts.html">Contracts</a></li>
    <li><a href="version.html">Conditional Compilation</a></li>
    <li><a href="traits.html">Traits</a></li>
    <li><a href="errors.html">Handling errors</a></li>
    <li><a href="unittest.html">Unit Tests</a></li>
    <li><a href="garbage.html">Garbage Collection</a></li>
    <li><a href="float.html">Floating Point</a></li>
    <li><a href="iasm.html">Inline Assembler</a></li>
    <li><a href="ddoc.html">Documentation Comments</a></li>
    <li><a href="interfaceToC.html">Interfacing To C</a></li>
    <li><a href="cpp_interface.html">Interfacing To C++</a></li>
    <li><a href="portability.html">Portability Guide</a></li>
    <li><a href="entity.html">Named Character Entities</a></li>
    <li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
    <li><a href="abi.html">Application Binary Interface</a></li>
    <li><a href="simd.html">Vector Extensions</a></li>
    </ul>
</div></li>
    <li><a href="phobos/index.html">Library Reference</a></li>
    <li><a href="library/index.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a></li>
</ul>
    </div>

<div class="navblock">
<h2><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></h2>
<ul></ul>
    </div>

<div class="navblock">
<h2>Community</h2>
<ul>    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
    
</ul>
    </div>
  
<div id="translate" class="tool">Translate this page:
    <div id="google_translate_element"></div><script type="text/javascript">
    function googleTranslateElementInit() {
      new google.translate.TranslateElement({
        pageLanguage: 'en',
        autoDisplay: false,
        layout: google.translate.TranslateElement.InlineLayout.SIMPLE
      }, 'google_translate_element');
    }
    </script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>
</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
    <!--span id="lastupdate">Last update (no date time)</span-->
    <span class="tip">
        <a href="https://github.com/D-Programming-Language/dlang.org/edit/master/statement.dd" class="button">Improve this page</a>
        <span>
            Quickly fork, edit online, and submit a pull request for this page.
            Requires a signed-in GitHub account. This works well for small changes.
            If you'd like to make larger changes you may want to consider using
            local clone.
        </span>
    </span>
    <span class="tip">
        <a href="http://wiki.dlang.org/DocComments/Statement" class="button">Page wiki</a>
        <span>
            View or edit the community-maintained wiki page associated with this page.
        </span>
    </span>
</div>
  <h1>Statements</h1>
  
C and C++ programmers will find the D statements very familiar, with a few
interesting additions.

<pre class="bnf"><span class="notranslate"><a name="Statement"><i>Statement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <a href="#NonEmptyStatement"><i>NonEmptyStatement</i></a>
    <a href="#ScopeBlockStatement"><i>ScopeBlockStatement</i></a>

<a name="NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>:
    <a href="#NonEmptyStatement"><i>NonEmptyStatement</i></a>
    <a href="#BlockStatement"><i>BlockStatement</i></a>

<a name="NoScopeStatement"><i>NoScopeStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <a href="#NonEmptyStatement"><i>NonEmptyStatement</i></a>
    <a href="#BlockStatement"><i>BlockStatement</i></a>

<a name="NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a>:
    <a href="#NonEmptyStatement"><i>NonEmptyStatement</i></a>
    <a href="#ScopeBlockStatement"><i>ScopeBlockStatement</i></a>

<a name="NonEmptyStatement"><i>NonEmptyStatement</i></a>:
    <a href="#NonEmptyStatementNoCaseNoDefault"><i>NonEmptyStatementNoCaseNoDefault</i></a>
    <a href="#CaseStatement"><i>CaseStatement</i></a>
    <a href="#CaseRangeStatement"><i>CaseRangeStatement</i></a>
    <a href="#DefaultStatement"><i>DefaultStatement</i></a>

<a name="NonEmptyStatementNoCaseNoDefault"><i>NonEmptyStatementNoCaseNoDefault</i></a>:
    <a href="#LabeledStatement"><i>LabeledStatement</i></a>
    <a href="#ExpressionStatement"><i>ExpressionStatement</i></a>
    <a href="#DeclarationStatement"><i>DeclarationStatement</i></a>
    <a href="#IfStatement"><i>IfStatement</i></a>
    <a href="#WhileStatement"><i>WhileStatement</i></a>
    <a href="#DoStatement"><i>DoStatement</i></a>
    <a href="#ForStatement"><i>ForStatement</i></a>
    <a href="#ForeachStatement"><i>ForeachStatement</i></a>
    <a href="#SwitchStatement"><i>SwitchStatement</i></a>
    <a href="#FinalSwitchStatement"><i>FinalSwitchStatement</i></a>
    <a href="#ContinueStatement"><i>ContinueStatement</i></a>
    <a href="#BreakStatement"><i>BreakStatement</i></a>
    <a href="#ReturnStatement"><i>ReturnStatement</i></a>
    <a href="#GotoStatement"><i>GotoStatement</i></a>
    <a href="#WithStatement"><i>WithStatement</i></a>
    <a href="#SynchronizedStatement"><i>SynchronizedStatement</i></a>
    <a href="#TryStatement"><i>TryStatement</i></a>
    <a href="#ScopeGuardStatement"><i>ScopeGuardStatement</i></a>
    <a href="#ThrowStatement"><i>ThrowStatement</i></a>
    <a href="#AsmStatement"><i>AsmStatement</i></a>
    <a href="#PragmaStatement"><i>PragmaStatement</i></a>
    <a href="#MixinStatement"><i>MixinStatement</i></a>
    <a href="#ForeachRangeStatement"><i>ForeachRangeStatement</i></a>
    <a href="version.html#ConditionalStatement"><i>ConditionalStatement</i></a>
    <a href="version.html#StaticAssert"><i>StaticAssert</i></a>
    <a href="template-mixin.html#TemplateMixin"><i>TemplateMixin</i></a>
    <a href="module.html#ImportDeclaration"><i>ImportDeclaration</i></a>
</span></pre>


        <p>Any ambiguities in the grammar between <i>Statement</i>s and
        <a href="declaration.html#Declaration"><i>Declaration</i></a>s are
        resolved by the declarations taking precedence.
        If a <i>Statement</i> is desired instead, wrapping it in parentheses will
        disambiguate it in favor of being a <i>Statement</i>.
        </p>

<h3><a name="ScopeStatement">Scope Statements</a></h3>

<pre class="bnf"><span class="notranslate"><a name="ScopeStatement"><i>ScopeStatement</i></a>:
    <a href="#NonEmptyStatement"><i>NonEmptyStatement</i></a>
    <a href="#BlockStatement"><i>BlockStatement</i></a>
</span></pre>

        <p>A new scope for local symbols
        is introduced for the <i>NonEmptyStatement</i>
        or <a href="#BlockStatement"><i>BlockStatement</i></a>.
        </p>

        <p>Even though a new scope is introduced,
        local symbol declarations cannot shadow (hide) other
        local symbol declarations in the same function.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> func1(<span class="d_keyword">int</span> x) {
  <span class="d_keyword">int</span> x;    <span class="d_comment">// illegal, x shadows parameter x
</span>
  <span class="d_keyword">int</span> y;

  { <span class="d_keyword">int</span> y; } <span class="d_comment">// illegal, y shadows enclosing scope's y
</span>
  <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() dg;
  dg = { <span class="d_keyword">int</span> y; }; <span class="d_comment">// ok, this y is not in the same function
</span>
  <span class="d_keyword">struct</span> S {
    <span class="d_keyword">int</span> y;    <span class="d_comment">// ok, this y is a member, not a local
</span>  }

  { <span class="d_keyword">int</span> z; }
  { <span class="d_keyword">int</span> z; }  <span class="d_comment">// ok, this z is not shadowing the other z
</span>
  { <span class="d_keyword">int</span> t; }
  { t++;   }  <span class="d_comment">// illegal, t is undefined
</span>}
</span></pre>

<p>        The idea is to avoid bugs in complex functions caused by
        scoped declarations inadvertently hiding previous ones.
        Local names should all be unique within a function.
</p>


<h3><a name="ScopeBlockStatement">Scope Block Statements</a></h3>

<pre class="bnf"><span class="notranslate"><a name="ScopeBlockStatement"><i>ScopeBlockStatement</i></a>:
    <a href="#BlockStatement"><i>BlockStatement</i></a>
</span></pre>

        <p>A scope block statement introduces a new scope for the
        <a href="#BlockStatement"><i>BlockStatement</i></a>.
        </p>

<h3><a name="LabeledStatement">Labeled Statements</a></h3>

<p>    Statements can be labeled. A label is an identifier that
        precedes a statement.
</p>

<pre class="bnf"><span class="notranslate"><a name="LabeledStatement"><i>LabeledStatement</i></a>:
    <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span>
    <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#NoScopeStatement"><i>NoScopeStatement</i></a>
    <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#Statement"><i>Statement</i></a>
</span></pre>

<p>        Any statement can be labeled, including empty statements,
        and so can serve as the target
        of a goto statement. Labeled statements can also serve as the
        target of a break or continue statement.
</p>
<p>        A label can appear without a following statement at the end of
        a block.
</p>
<p>        Labels are in a name space independent of declarations, variables,
        types, etc.
        Even so, labels cannot have the same name as local declarations.
        The label name space is the body of the function
        they appear in. Label name spaces do not nest, i.e. a label
        inside a block statement is accessible from outside that block.
</p>

<h3><a name="BlockStatement">Block Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="BlockStatement"><i>BlockStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">{ }</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">{</span></span> <a href="#StatementList"><i>StatementList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">}</span></span>

<a name="StatementList"><i>StatementList</i></a>:
    <a href="#Statement"><i>Statement</i></a>
    <a href="#Statement"><i>Statement</i></a> <i>StatementList</i>
</span></pre>

<p>        A block statement is a sequence of statements enclosed
        by { }. The statements are executed in lexical order.
</p>
<h3><a name="ExpressionStatement">Expression Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="ExpressionStatement"><i>ExpressionStatement</i></a>:
    <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>

        <p>The expression is evaluated.</p>

        <p>Expressions that have no effect, like <span class="notranslate"><span class="d_inlinecode donthyphenate">(x + x)</span></span>,
        are illegal
        in expression statements.
        If such an expression is needed, casting it to <span class="d_keyword">void</span> will
        make it legal.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> x;
x++;               <span class="d_comment">// ok
</span>x;                 <span class="d_comment">// illegal
</span>1+1;               <span class="d_comment">// illegal
</span><span class="d_keyword">cast</span>(<span class="d_keyword">void</span>)(x + x); <span class="d_comment">// ok
</span></span></pre>

<h3><a name="DeclarationStatement">Declaration Statement</a></h3>

        Declaration statements declare variables and types.

<pre class="bnf"><span class="notranslate"><a name="DeclarationStatement"><i>DeclarationStatement</i></a>:
    <a href="declaration.html#Declaration"><i>Declaration</i></a>
</span></pre>

        <p>Some declaration statements:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> a;        <span class="d_comment">// declare a as type int and initialize it to 0
</span><span class="d_keyword">struct</span> S { }  <span class="d_comment">// declare struct s
</span><span class="d_keyword">alias</span> myint = <span class="d_keyword">int</span>;
</span></pre>

<h3><a name="IfStatement">If Statement</a></h3>

        If statements provide simple conditional execution of statements.

<pre class="bnf"><span class="notranslate"><a name="IfStatement"><i>IfStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">if (</span></span> <a href="#IfCondition"><i>IfCondition</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ThenStatement"><i>ThenStatement</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">if (</span></span> <a href="#IfCondition"><i>IfCondition</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ThenStatement"><i>ThenStatement</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">else</span></span> <a href="#ElseStatement"><i>ElseStatement</i></a>

<a name="IfCondition"><i>IfCondition</i></a>:
    <a href="expression.html#Expression"><i>Expression</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">auto</span></span> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="expression.html#Expression"><i>Expression</i></a>
    <a href="declaration.html#TypeCtors"><i>TypeCtors</i></a> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="expression.html#Expression"><i>Expression</i></a>
    <a href="declaration.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <a href="declaration.html#BasicType"><i>BasicType</i></a> <a href="declaration.html#Declarator"><i>Declarator</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="expression.html#Expression"><i>Expression</i></a>

<a name="ThenStatement"><i>ThenStatement</i></a>:
    <a href="#ScopeStatement"><i>ScopeStatement</i></a>

<a name="ElseStatement"><i>ElseStatement</i></a>:
    <a href="#ScopeStatement"><i>ScopeStatement</i></a>
</span></pre>

        <p><a href="expression.html#Expression"><i>Expression</i></a> is evaluated and must have a type that
        can be converted to a boolean. If it's true the
        <i>ThenStatement</i> is transferred to, else the <i>ElseStatement</i>
        is transferred to.</p>

        <p>The 'dangling else' parsing problem is solved by associating the
        else with the nearest if statement.</p>

        <p>If an <span class="notranslate"><span class="d_inlinecode donthyphenate">auto</span></span> <i>Identifier</i> is provided, it is declared and
        initialized
        to the value
        and type of the <a href="expression.html#Expression"><i>Expression</i></a>. Its scope extends from when it is
        initialized to the end of the <i>ThenStatement</i>.</p>

        <p>If a <i>Declarator</i> is provided, it is declared and
        initialized
        to the value
        of the <a href="expression.html#Expression"><i>Expression</i></a>. Its scope extends from when it is
        initialized to the end of the <i>ThenStatement</i>.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.regexp;
...
<span class="d_keyword">if</span> (<span class="d_keyword">auto</span> m = std.regexp.search(<span class="d_string">"abcdef"</span>, <span class="d_string">"b(c)d"</span>))
{
  writefln(<span class="d_string">"[%s]"</span>, m.pre);      <span class="d_comment">// prints [a]
</span>  writefln(<span class="d_string">"[%s]"</span>, m.post);     <span class="d_comment">// prints [ef]
</span>  writefln(<span class="d_string">"[%s]"</span>, m.match(0)); <span class="d_comment">// prints [bcd]
</span>  writefln(<span class="d_string">"[%s]"</span>, m.match(1)); <span class="d_comment">// prints [c]
</span>  writefln(<span class="d_string">"[%s]"</span>, m.match(2)); <span class="d_comment">// prints []
</span>}
<span class="d_keyword">else</span>
{
  writeln(m.post);    <span class="d_comment">// error, m undefined
</span>}
writeln(m.pre);         <span class="d_comment">// error, m undefined
</span></span></pre>

<h3><a name="WhileStatement">While Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="WhileStatement"><i>WhileStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">while (</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>
</span></pre>

        While statements implement simple loops.

        <a href="expression.html#Expression"><i>Expression</i></a> is evaluated and must have a type that
        can be converted to a boolean. If it's true the
        <a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed. After the <a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed,
        the <a href="expression.html#Expression"><i>Expression</i></a> is evaluated again, and if true the
        <a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed again. This continues until the
        <a href="expression.html#Expression"><i>Expression</i></a> evaluates to false.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> i = 0;
<span class="d_keyword">while</span> (i &lt; 10) {
  foo(i);
  i++;
}
</span></pre>

        A <a href="#BreakStatement"><i>BreakStatement</i></a> will exit the loop.
        A <a href="#ContinueStatement"><i>ContinueStatement</i></a>
        will transfer directly to evaluating <a href="expression.html#Expression"><i>Expression</i></a> again.

<h3><a name="DoStatement">Do Statement</a></h3>


<pre class="bnf"><span class="notranslate"><a name="DoStatement"><i>DoStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">do</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate"> while (</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>


        Do while statements implement simple loops.

        <a href="#ScopeStatement"><i>ScopeStatement</i></a> is executed. Then
        <a href="expression.html#Expression"><i>Expression</i></a> is evaluated and must have a type that
        can be converted to a boolean. If it's true the
        loop is iterated again.
        This continues until the
        <a href="expression.html#Expression"><i>Expression</i></a> evaluates to false.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> i = 0;
<span class="d_keyword">do</span> {
  foo(i);
} <span class="d_keyword">while</span> (++i &lt; 10);
</span></pre>

        A <a href="#BreakStatement"><i>BreakStatement</i></a> will exit the loop.
        A <a href="#ContinueStatement"><i>ContinueStatement</i></a>
        will transfer directly to evaluating <a href="expression.html#Expression"><i>Expression</i></a> again.

<h3><a name="ForStatement">For Statement</a></h3>

        For statements implement loops with initialization,
        test, and increment clauses.

<pre class="bnf"><span class="notranslate"><a name="ForStatement"><i>ForStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">for (</span></span> <a href="#Initialize"><i>Initialize</i></a> <i>Test</i><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span> <a href="#Increment"><i>Increment</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>

<a name="Initialize"><i>Initialize</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>

<a name="Test"><i>Test</i></a>:
    <a href="expression.html#Expression"><i>Expression</i></a>

<a name="Increment"><i>Increment</i></a>:
    <a href="expression.html#Expression"><i>Expression</i></a>
</span></pre>

        <p><i>Initialize</i> is executed.
        <i>Test</i> is evaluated and must have a type that
        can be converted to a boolean. If it's true the
        statement is executed. After the statement is executed,
        the <i>Increment</i> is executed.
        Then <i>Test</i> is evaluated again, and if true the
        statement is executed again. This continues until the
        <i>Test</i> evaluates to false.
        </p>

        <p>A <a href="#BreakStatement"><i>BreakStatement</i></a> will exit the loop.
        A <a href="#ContinueStatement"><i>ContinueStatement</i></a>
        will transfer directly to the <i>Increment</i>.
        </p>

        <p>A <i>ForStatement</i> creates a new scope.
        If <i>Initialize</i> declares a variable, that variable's scope
        extends through the end of the for statement. For example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 10; i++)
  foo(i);
</span></pre>

        is equivalent to:

<pre class="d_code"><span class="notranslate">{
  <span class="d_keyword">int</span> i;
  <span class="d_keyword">for</span> (i = 0; i &lt; 10; i++)
    foo(i);
}
</span></pre>

        Function bodies cannot be empty:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 10; i++)
  ;       <span class="d_comment">// illegal
</span></span></pre>

        Use instead:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 10; i++)
{
}
</span></pre>

        The <i>Initialize</i> may be omitted. <i>Test</i> may also be
        omitted, and if so, it is treated as if it evaluated to true.

<h3><a name="ForeachStatement">Foreach Statement</a></h3>

        A foreach statement loops over the contents of an aggregate.

<pre class="bnf"><span class="notranslate"><a name="ForeachStatement"><i>ForeachStatement</i></a>:
    <i>Foreach</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ForeachTypeList"><i>ForeachTypeList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span> <a href="#ForeachAggregate"><i>ForeachAggregate</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>

<a name="Foreach"><i>Foreach</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach_reverse</span></span>

<a name="ForeachTypeList"><i>ForeachTypeList</i></a>:
    <a href="#ForeachType"><i>ForeachType</i></a>
    <a href="#ForeachType"><i>ForeachType</i></a> , <i>ForeachTypeList</i>

<a name="ForeachType"><i>ForeachType</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">ref</span></span><sub>opt</sub> <a href="declaration.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <a href="declaration.html#BasicType"><i>BasicType</i></a> <a href="declaration.html#Declarator"><i>Declarator</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">ref</span></span><sub>opt</sub> <a href="declaration.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <i>Identifier</i>

<a name="ForeachAggregate"><i>ForeachAggregate</i></a>:
    <a href="expression.html#Expression"><i>Expression</i></a>
</span></pre>

<p>        <i>ForeachAggregate</i> is evaluated. It must evaluate to an expression
        of type static array, dynamic array, associative array,
        struct, class, delegate, or tuple.
        The <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a> is executed, once for each element of the
        aggregate.
        At the start of each iteration, the variables declared by
        the <i>ForeachTypeList</i>
        are set to be a copy of the elements of the aggregate.
        If the variable is <span class="notranslate"><span class="d_inlinecode donthyphenate">ref</span></span>, it is a reference to the
        contents of that aggregate.
</p>
<p>        The aggregate must be loop invariant, meaning that
        elements to the aggregate cannot be added or removed from it
        in the <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>.
</p>

<h4>Foreach over Arrays</h4>

<p>        If the aggregate is a static or dynamic array, there
        can be one or two variables declared. If one, then the variable
        is said to be the <i>value</i> set to the elements of the array,
        one by one. The type of the
        variable must match the type of the array contents, except for the
        special cases outlined below.
        If there are
        two variables declared, the first is said to be the <i>index</i>
        and the second is said to be the <i>value</i>. The <i>index</i>
        must be of <span class="notranslate"><span class="d_inlinecode donthyphenate">int</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">uint</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">size_t</span></span> type,
        it cannot be <i>ref</i>,
        and it is set to be the index of the array element.
</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>[] a;
...
<span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> i, <span class="d_keyword">char</span> c; a)
{
  writefln(<span class="d_string">"a[%d] = '%c'"</span>, i, c);
}
</span></pre>

        <p>For <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach</span></span>, the
        elements for the array are iterated over starting at index 0
        and continuing to the maximum of the array.
        For <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach_reverse</span></span>, the array elements are visited in the reverse
        order.
        </p>

<h4>Foreach over Arrays of Characters</h4>

        <p>If the aggregate expression is a static or dynamic array of
        <span class="notranslate"><span class="d_inlinecode donthyphenate">char</span></span>s, <span class="notranslate"><span class="d_inlinecode donthyphenate">wchar</span></span>s, or <span class="notranslate"><span class="d_inlinecode donthyphenate">dchar</span></span>s, then the <i>Type</i> of
        the <i>value</i>
        can be any of <span class="notranslate"><span class="d_inlinecode donthyphenate">char</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">wchar</span></span>, or <span class="notranslate"><span class="d_inlinecode donthyphenate">dchar</span></span>.
        In this manner any UTF array
        can be decoded into any UTF type:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>[] a = <span class="d_string">"\xE2\x89\xA0"</span>.dup;  <span class="d_comment">// \u2260 encoded as 3 UTF-8 bytes
</span>
<span class="d_keyword">foreach</span> (<span class="d_keyword">dchar</span> c; a)
{
  writefln(<span class="d_string">"a[] = %x"</span>, c); <span class="d_comment">// prints 'a[] = 2260'
</span>}

<span class="d_keyword">dchar</span>[] b = <span class="d_string">"\u2260"d</span>.dup;

<span class="d_keyword">foreach</span> (<span class="d_keyword">char</span> c; b)
{
  writef(<span class="d_string">"%x, "</span>, c);  <span class="d_comment">// prints 'e2, 89, a0, '
</span>}
</span></pre>


        <p>Aggregates can be string literals, which can be accessed
        as char, wchar, or dchar arrays:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test() {
  <span class="d_keyword">foreach</span> (<span class="d_keyword">char</span> c; <span class="d_string">"ab"</span>) {
    writefln(<span class="d_string">"'%s'"</span>, c);
  }
  <span class="d_keyword">foreach</span> (<span class="d_keyword">wchar</span> w; <span class="d_string">"xy"</span>) {
    writefln(<span class="d_string">"'%s'"</span>, w);
  }
}
</span></pre>

        <p>which would print:
        </p>

<pre class="console"><span class="notranslate">'a'
'b'
'x'
'y'
</span></pre>

<h4>Foreach over Associative Arrays</h4>

        <p>If the aggregate expression is an associative array, there
        can be one or two variables declared. If one, then the variable
        is said to be the <i>value</i> set to the elements of the array,
        one by one. The type of the
        variable must match the type of the array contents. If there are
        two variables declared, the first is said to be the <i>index</i>
        and the second is said to be the <i>value</i>. The <i>index</i>
        must be of the same type as the indexing type of the associative
        array. It cannot be <i>ref</i>,
        and it is set to be the index of the array element.
        The order in which the elements of the array are iterated over is unspecified
        for <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach</span></span>. <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach_reverse</span></span> for associative arrays
        is illegal.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">double</span>[string] a; <span class="d_comment">// index type is string, value type is double
</span>...
<span class="d_keyword">foreach</span> (string s, <span class="d_keyword">double</span> d; a)
{
  writefln(<span class="d_string">"a['%s'] = %g"</span>, s, d);
}
</span></pre>

<h4><a name="foreach_with_ranges">Foreach over Structs and Classes with Ranges</a></h4>

        <p>Iteration over struct and class objects can be done with
        ranges, which means the following properties and methods must be defined:
        </p>

        <center><table border=1 cellpadding=4 cellspacing=0><caption>Foreach Range Properties</caption>        <tr><th class="donthyphenate"><b>Property</b></th><th class="donthyphenate"><b>Purpose</b></th></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.empty</span></span></td><td>returns true if no more elements</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.front</span></span></td><td>return the leftmost element of the range</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.back</span></span></td><td>return the rightmost element of the range</td></tr>
        </table></center>

        <center><table border=1 cellpadding=4 cellspacing=0><caption>Foreach Range Methods</caption>        <tr><th class="donthyphenate"><b>Method</b></th><th class="donthyphenate"><b>Purpose</b></th></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.popFront()</span></span></td><td>move the left edge of the range right one</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.popBack()</span></span></td><td>move the right edge of the range left one</td></tr>
        </table></center>

        <p>Meaning:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">foreach</span> (e; range) { ... }
</span></pre>

        <p>translates to:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (<span class="d_keyword">auto</span> __r = range; !__r.empty; __r.popFront())
{
  <span class="d_keyword">auto</span> e = __r.front;
  ...
}
</span></pre>

        <p>Similarly:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">foreach_reverse</span> (e; range) { ... }
</span></pre>

        <p>translates to:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (<span class="d_keyword">auto</span> __r = range; !__r.empty; __r.popBack())
{
  <span class="d_keyword">auto</span> e = __r.back;
  ...
}
</span></pre>

        <p>If the foreach range properties do not exist, the <span class="notranslate"><span class="d_inlinecode donthyphenate">opApply</span></span>
        method will be used instead.
        </p>


<h4>Foreach over Structs and Classes with opApply</h4>

        <p>        If it is a struct or class object, the <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach</span></span> is defined by
        the special <a name="opApply"><i>opApply</i></a> member function.
        The <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach_reverse</span></span> behavior is defined by the special
        <a name="opApplyReverse"><i>opApplyReverse</i></a> member function.
        These special functions must be defined by the type in order
        to use the corresponding foreach statement.
        The functions have the type:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> opApply(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">ref</span> Type [, ...]) dg);

<span class="d_keyword">int</span> opApplyReverse(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">ref</span> Type [, ...]) dg);
</span></pre>

        <p>where <i>Type</i> matches the <i>Type</i> used in the <i>ForeachType</i>
        declaration of <i>Identifier</i>. Multiple <i>ForeachType</i>s
        correspond with multiple <i>Type</i>'s in the delegate type
        passed to <span class="notranslate"><span class="d_inlinecode donthyphenate">opApply</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">opApplyReverse</span></span>.
        There can be multiple <span class="notranslate"><span class="d_inlinecode donthyphenate">opApply</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">opApplyReverse</span></span> functions,
        one is selected
        by matching the type of <i>dg</i> to the <i>ForeachType</i>s
        of the <i>ForeachStatement</i>.
        The body of the apply
        function iterates over the elements it aggregates, passing them
        each to the <i>dg</i> function. If the <i>dg</i> returns 0, then
        apply goes on to the next element.
        If the <i>dg</i> returns a nonzero value, apply must cease
        iterating and return that value. Otherwise, after done iterating
        across all the elements, apply will return 0.
        </p>

        <p>For example, consider a class that is a container for two elements:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">uint</span>[2] array;

  <span class="d_keyword">int</span> opApply(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">ref</span> <span class="d_keyword">uint</span>) dg)
  {
    <span class="d_keyword">int</span> result = 0;

    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; array.length; i++)
    {
      result = dg(array[i]);
      <span class="d_keyword">if</span> (result)
        <span class="d_keyword">break</span>;
    }
    <span class="d_keyword">return</span> result;
  }
}
</span></pre>

        An example using this might be:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test() {
  Foo a = <span class="d_keyword">new</span> Foo();

  a.array[0] = 73;
  a.array[1] = 82;

  <span class="d_keyword">foreach</span> (<span class="d_keyword">uint</span> u; a)
  {
    writefln(<span class="d_string">"%d"</span>, u);
  }
}
</span></pre>

        which would print:

<pre class="console"><span class="notranslate">73
82
</span></pre>

        <p><a name="opApply"><i>opApply</i></a> can also be a templated function,
        which will infer the types of parameters based on the <i>ForeachStatement</i>.</p>

        <p>For example:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">import</span> std.traits : ParameterTypeTuple;  <span class="d_comment">// introspection template
</span>
    <span class="d_keyword">int</span> opApply(Dg)(<span class="d_keyword">scope</span> Dg dg)
        <span class="d_keyword">if</span> (ParameterTypeTuple!Dg.length == 2)  <span class="d_comment">// foreach function takes 2 parameters
</span>    {
        <span class="d_keyword">return</span> 0;
    }

    <span class="d_keyword">int</span> opApply(Dg)(<span class="d_keyword">scope</span> Dg dg)
        <span class="d_keyword">if</span> (ParameterTypeTuple!Dg.length == 3)  <span class="d_comment">// foreach function takes 3 parameters
</span>    {
        <span class="d_keyword">return</span> 0;
    }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b; S()) { }  <span class="d_comment">// calls first opApply function
</span>    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b, <span class="d_keyword">float</span> c; S()) { }  <span class="d_comment">// calls second opApply function
</span>}
</span></pre>

<h4>Foreach over Delegates</h4>

        <p>If <i>ForeachAggregate</i> is a delegate, the type signature of
        the delegate is of the same as for <span class="notranslate"><span class="d_inlinecode donthyphenate">opApply</span></span>. This enables
        many different named looping strategies to coexist in the same
        class or struct.</p>

<h4>Foreach over Tuples</h4>

<p>        If the aggregate expression is a tuple, there
        can be one or two variables declared. If one, then the variable
        is said to be the <i>value</i> set to the elements of the tuple,
        one by one. If the type of the
        variable is given, it must match the type of the tuple contents.
        If it is not given, the type of the variable is set to the type
        of the tuple element, which may change from iteration to iteration.
        If there are
        two variables declared, the first is said to be the <i>index</i>
        and the second is said to be the <i>value</i>. The <i>index</i>
        must be of <span class="notranslate"><span class="d_inlinecode donthyphenate">int</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">uint</span></span> type, it cannot be <i>ref</i>,
        and it is set to be the index of the tuple element.
</p>

<p>        If the tuple is a list of types, then the foreach statement
        is executed once for each type, and the value is aliased to that
        type.
</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.typetuple; <span class="d_comment">// for TypeTuple
</span>
<span class="d_keyword">void</span> main() {
  <span class="d_keyword">alias</span> TL = TypeTuple!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>, <span class="d_keyword">double</span>);

  <span class="d_keyword">foreach</span> (T; TL)
  {
    writeln(<span class="d_keyword">typeid</span>(T));
  }
}
</span></pre>

        <p>Prints:</p>

<pre class="console"><span class="notranslate">int
long
double
</span></pre>

<h4>Foreach Ref Parameters</h4>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">ref</span></span> can be used to update the original elements:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test() {
  <span class="d_keyword">static</span> <span class="d_keyword">uint</span>[2] a = [7, 8];

  <span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> <span class="d_keyword">uint</span> u; a)
  {
    u++;
  }
  <span class="d_keyword">foreach</span> (<span class="d_keyword">uint</span> u; a)
  {
    writefln(<span class="d_string">"%d"</span>, u);
  }
}
</span></pre>

        which would print:

<pre class="console"><span class="notranslate">8
9
</span></pre>
        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">ref</span></span> can not be applied to the index values.</p>

        <p>If not specified, the <i>Type</i>s in the <i>ForeachType</i> can be
        inferred from
        the type of the <i>ForeachAggregate</i>.
        </p>

<h4>Foreach Restrictions</h4>

        <p>The aggregate itself must not be resized, reallocated, free'd,
        reassigned or destructed
        while the foreach is iterating over the elements.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] a;
<span class="d_keyword">int</span>[] b;
<span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> i; a)
{
  a = <span class="d_keyword">null</span>;       <span class="d_comment">// error
</span>  a.length += 10; <span class="d_comment">// error
</span>  a = b;          <span class="d_comment">// error
</span>}
a = <span class="d_keyword">null</span>;         <span class="d_comment">// ok
</span></span></pre>

<h3><a name="ForeachRangeStatement">Foreach Range Statement</a></h3>

        A foreach range statement loops over the specified range.

<pre class="bnf"><span class="notranslate"><a name="ForeachRangeStatement"><i>ForeachRangeStatement</i></a>:
    <a href="#Foreach"><i>Foreach</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ForeachType"><i>ForeachType</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span> <a href="#LwrExpression"><i>LwrExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">..</span></span> <a href="#UprExpression"><i>UprExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>

<a name="LwrExpression"><i>LwrExpression</i></a>:
    <a href="expression.html#Expression"><i>Expression</i></a>

<a name="UprExpression"><i>UprExpression</i></a>:
    <a href="expression.html#Expression"><i>Expression</i></a>
</span></pre>

        <p>        <i>ForeachType</i> declares a variable with either an explicit type,
        or a type inferred from <i>LwrExpression</i> and <i>UprExpression</i>.
        The <i>ScopeStatement</i> is then executed <i>n</i> times, where <i>n</i>
        is the result of <i>UprExpression</i> - <i>LwrExpression</i>.
        If <i>UprExpression</i> is less than or equal to <i>LwrExpression</i>,
        the <i>ScopeStatement</i> is executed zero times.
        If <i>Foreach</i> is <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach</span></span>, then the variable is set to
        <i>LwrExpression</i>, then incremented at the end of each iteration.
        If <i>Foreach</i> is <span class="notranslate"><span class="d_inlinecode donthyphenate">foreach_reverse</span></span>, then the variable is set to
        <i>UprExpression</i>, then decremented before each iteration.
        <i>LwrExpression</i> and <i>UprExpression</i> are each evaluated
        exactly once, regardless of how many times the <i>ScopeStatement</i>
        is executed.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> foo() {
  write(<span class="d_string">"foo"</span>);
  <span class="d_keyword">return</span> 10;
}

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">foreach</span> (i; 0 .. foo())
  {
    write(i);
  }
}
</span></pre>

        <p>Prints:</p>

<pre class="console"><span class="notranslate">foo0123456789
</span></pre>


<h4>Break and Continue out of Foreach</h4>


        <p>A <a href="#BreakStatement"><i>BreakStatement</i></a> in the body of the foreach will exit the
        foreach, a <a href="#ContinueStatement"><i>ContinueStatement</i></a> will immediately start the
        next iteration.
        </p>

<h3><a name="SwitchStatement">Switch Statement</a></h3>

        A switch statement goes to one of a collection of case
        statements depending on the value of the switch
        expression.

<pre class="bnf"><span class="notranslate"><a name="SwitchStatement"><i>SwitchStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">switch (</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>

<a name="CaseStatement"><i>CaseStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">case</span></span> <a href="expression.html#ArgumentList"><i>ArgumentList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#ScopeStatementList"><i>ScopeStatementList</i></a>

<a name="CaseRangeStatement"><i>CaseRangeStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">case</span></span> <a href="#FirstExp"><i>FirstExp</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">: .. case</span></span> <a href="#LastExp"><i>LastExp</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#ScopeStatementList"><i>ScopeStatementList</i></a>

<a name="FirstExp"><i>FirstExp</i></a>:
    <a href="expression.html#AssignExpression"><i>AssignExpression</i></a>

<a name="LastExp"><i>LastExp</i></a>:
    <a href="expression.html#AssignExpression"><i>AssignExpression</i></a>

<a name="DefaultStatement"><i>DefaultStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">default :</span></span> <a href="#ScopeStatementList"><i>ScopeStatementList</i></a>

<a name="ScopeStatementList"><i>ScopeStatementList</i></a>:
    <a href="#StatementListNoCaseNoDefault"><i>StatementListNoCaseNoDefault</i></a>

<a name="StatementListNoCaseNoDefault"><i>StatementListNoCaseNoDefault</i></a>:
    <a href="#StatementNoCaseNoDefault"><i>StatementNoCaseNoDefault</i></a>
    <a href="#StatementNoCaseNoDefault"><i>StatementNoCaseNoDefault</i></a> <i>StatementListNoCaseNoDefault</i>

<a name="StatementNoCaseNoDefault"><i>StatementNoCaseNoDefault</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <a href="#NonEmptyStatementNoCaseNoDefault"><i>NonEmptyStatementNoCaseNoDefault</i></a>
    <a href="#ScopeBlockStatement"><i>ScopeBlockStatement</i></a>
</span></pre>

        <p><a href="expression.html#Expression"><i>Expression</i></a> is evaluated. The result type T must be
        of integral type or <span class="notranslate"><span class="d_inlinecode donthyphenate">char[]</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">wchar[]</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">dchar[]</span></span>.
        The result is
        compared against each of the case expressions. If there is
        a match, the corresponding case statement is transferred to.
        </p>

        <p>The case expressions, <a href="expression.html#ArgumentList"><i>ArgumentList</i></a>,
        are a comma separated list of expressions.
        </p>

        <p>A <i>CaseRangeStatement</i> is a shorthand for listing a series
        of case statements from <i>FirstExp</i> to <i>LastExp</i>.
        </p>


        <p>If none of the case expressions match, and there is a default
        statement, the default statement is transferred to.
        </p>


        <p>A switch statement must have a default statement.</p>


        <p>
        The case expressions must all evaluate to a constant value
        or array, or a runtime initialized const or immutable variable of
        integral type.

        They must be implicitly convertible to the type of the
        switch <a href="expression.html#Expression"><i>Expression</i></a>.
        </p>

        <p>Case expressions must all evaluate to distinct values.
        Const or immutable variables must all have different names.
        If they share a value, the first case statement with that value
        gets control.
        There must be exactly one default statement.


        </p>

        <p>The <a href="#ScopeStatementList"><i>ScopeStatementList</i></a> introduces a new scope.
        </p>

        <p>Case statements and default statements associated with the switch
        can be nested within block statements; they do not have to be in
        the outermost block. For example, this is allowed:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">switch</span> (i) {
  <span class="d_keyword">case</span> 1:
  {
    <span class="d_keyword">case</span> 2:
  }
    <span class="d_keyword">break</span>;
}
</span></pre>



        <p>A <a href="#ScopeStatementList"><i>ScopeStatementList</i></a> must either be empty, or be ended with
        a <a href="#ContinueStatement"><i>ContinueStatement</i></a>, <a href="#BreakStatement"><i>BreakStatement</i></a>,
        <a href="#ReturnStatement"><i>ReturnStatement</i></a>, <a href="#GotoStatement"><i>GotoStatement</i></a>, <a href="#ThrowStatement"><i>ThrowStatement</i></a>
        or assert(0) expression unless this is the last case. This is to
        set apart with C's error-prone implicit fall-through behavior.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">goto case;</span></span> could be used for explicit fall-through:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> number;
string message;
<span class="d_keyword">switch</span> (number)
{
  <span class="d_keyword">default</span>:    <span class="d_comment">// valid: ends with 'throw'
</span>    <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"unknown number"</span>);

  <span class="d_keyword">case</span> 3:     <span class="d_comment">// valid: ends with 'break' (break out of the 'switch' only)
</span>    message ~= <span class="d_string">"three "</span>;
    <span class="d_keyword">break</span>;

  <span class="d_keyword">case</span> 4:     <span class="d_comment">// valid: ends with 'continue' (continue the enclosing loop)
</span>    message ~= <span class="d_string">"four "</span>;
    <span class="d_keyword">continue</span>;

  <span class="d_keyword">case</span> 5:     <span class="d_comment">// valid: ends with 'goto' (explicit fall-through to next case.)
</span>    message ~= <span class="d_string">"five "</span>;
    <span class="d_keyword">goto</span> <span class="d_keyword">case</span>;

  <span class="d_keyword">case</span> 6:     <span class="d_comment">// ERROR: implicit fall-through
</span>    message ~= <span class="d_string">"six "</span>;

  <span class="d_keyword">case</span> 1:     <span class="d_comment">// valid: the body is empty
</span>  <span class="d_keyword">case</span> 2:     <span class="d_comment">// valid: this is the last case in the switch statement.
</span>    message = <span class="d_string">"one or two"</span>;
}
</span></pre>

        <p>A break statement will exit the switch <i>BlockStatement</i>.</p>


        <p><a name="string-switch">Strings can be used in switch expressions</a>.
        For example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>[] name;
...
<span class="d_keyword">switch</span> (name) {
  <span class="d_keyword">case</span> <span class="d_string">"fred"</span>:
  <span class="d_keyword">case</span> <span class="d_string">"sally"</span>:
    ...
}
</span></pre>

        <p>For applications like command line switch processing, this
        can lead to much more straightforward code, being clearer and
        less error prone. char, wchar and dchar strings are allowed.
        </p>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">Implementation Note:</span></span> The compiler's code generator may
        assume that the case
        statements are sorted by frequency of use, with the most frequent
        appearing first and the least frequent last. Although this is
        irrelevant as far as program correctness is concerned, it is of
        performance interest.
        </p>

<h3><a name="FinalSwitchStatement">Final Switch Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="FinalSwitchStatement"><i>FinalSwitchStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">final switch (</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>
</span></pre>

        <p>A final switch statement is just like a switch statement,
        except that:</p>

        <ul>        <li>No <a href="#DefaultStatement"><i>DefaultStatement</i></a> is allowed.</li>
        <li>No <a href="#CaseRangeStatement"><i>CaseRangeStatement</i></a>s are allowed.</li>
        <li>If the switch <a href="expression.html#Expression"><i>Expression</i></a> is of enum type, all
        the enum members must appear in the <a href="#CaseStatement"><i>CaseStatement</i></a>s.</li>
        <li>The case expressions cannot evaluate to a run time
        initialized value.</li>
        </ul>



<h3><a name="ContinueStatement">Continue Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="ContinueStatement"><i>ContinueStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">continue</span></span> <i>Identifier</i><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>

        A continue aborts the current iteration of its enclosing loop
        statement, and starts the next iteration.

        <p>continue executes the next iteration of its innermost enclosing
        while, for, foreach, or do loop. The increment clause is executed.</p>

        <p>If continue is followed by <i>Identifier</i>, the <i>Identifier</i>
        must be the label of an enclosing while, for, or do
        loop, and the next iteration of that loop is executed.
        It is an error if
        there is no such statement.</p>

        <p>Any intervening finally clauses are executed, and any intervening
        synchronization objects are released.</p>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">Note:</span></span> If a finally clause executes a return, throw, or goto
        out of the finally clause,
        the continue target is never reached.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (i = 0; i &lt; 10; i++)
{
  <span class="d_keyword">if</span> (foo(i))
    <span class="d_keyword">continue</span>;
  bar();
}
</span></pre>

<h3><a name="BreakStatement">Break Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="BreakStatement"><i>BreakStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">break</span></span> <i>Identifier</i><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>

        A break exits the enclosing statement.

        break exits the innermost enclosing while, for, foreach, do, or switch
        statement, resuming execution at the statement following it.

        <p>If break is followed by <i>Identifier</i>, the <i>Identifier</i>
        must be the label of an enclosing while, for, do or switch
        statement, and that statement is exited. It is an error if
        there is no such statement.</p>

        <p>Any intervening finally clauses are executed, and any intervening
        synchronization objects are released.</p>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">Note:</span></span> If a finally clause executes a return, throw, or goto
        out of the finally clause,
        the break target is never reached.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (i = 0; i &lt; 10; i++)
{
  <span class="d_keyword">if</span> (foo(i))
    <span class="d_keyword">break</span>;
}
</span></pre>

<h3><a name="ReturnStatement">Return Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="ReturnStatement"><i>ReturnStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">return</span></span> <a href="expression.html#Expression"><i>Expression</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>

        A return exits the current function and supplies its return
        value.

        <a href="expression.html#Expression"><i>Expression</i></a> is required if the function specifies
        a return type that is not void.
        The <a href="expression.html#Expression"><i>Expression</i></a> is implicitly converted to the
        function return type.

        <p>At least one return statement, throw statement, or assert(0) expression
        is required if the function specifies a return type that is not void,
        unless the function contains inline assembler code.</p>


        <p>Before the function actually returns,
        any objects with scope storage duration are destroyed,
        any enclosing finally clauses are executed,
        any scope(exit) statements are executed,
        any scope(success) statements are executed,
        and any enclosing synchronization
        objects are released.</p>

        <p>The function will not return if any enclosing finally clause
        does a return, goto or throw that exits the finally clause.</p>

        <p>If there is an out postcondition
        (see <a href="contracts.html">Contract Programming</a>),
        that postcondition is executed
        after the <a href="expression.html#Expression"><i>Expression</i></a> is evaluated and before the function
        actually returns.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">return</span> x + 3;
}
</span></pre>

<h3><a name="GotoStatement">Goto Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="GotoStatement"><i>GotoStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">goto</span></span> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">goto</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">default</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">goto</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">case</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">goto</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">case</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>

        A goto transfers to the statement labeled with
        <i>Identifier</i>.

<pre class="d_code"><span class="notranslate">  <span class="d_keyword">if</span> (foo)
    <span class="d_keyword">goto</span> L1;
  x = 3;
L1:
  x++;
</span></pre>

        The second form, <span class="notranslate"><span class="d_inlinecode donthyphenate">goto default;</span></span>, transfers to the
        innermost <a href="#DefaultStatement"><i>DefaultStatement</i></a> of an enclosing
        <a href="#SwitchStatement"><i>SwitchStatement</i></a>.

        <p>The third form, <span class="notranslate"><span class="d_inlinecode donthyphenate">goto case;</span></span>, transfers to the
        next <a href="#CaseStatement"><i>CaseStatement</i></a> of the innermost enclosing
        <a href="#SwitchStatement"><i>SwitchStatement</i></a>.</p>

        <p>The fourth form, <span class="notranslate"><span class="d_inlinecode donthyphenate">goto case</span></span> <a href="expression.html#Expression"><i>Expression</i></a><span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>, transfers to the
        <a href="#CaseStatement"><i>CaseStatement</i></a> of the innermost enclosing
        <a href="#SwitchStatement"><i>SwitchStatement</i></a>
        with a matching <a href="expression.html#Expression"><i>Expression</i></a>.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">switch</span> (x)
{
  <span class="d_keyword">case</span> 3:
    <span class="d_keyword">goto</span> <span class="d_keyword">case</span>;
  <span class="d_keyword">case</span> 4:
    <span class="d_keyword">goto</span> <span class="d_keyword">default</span>;
  <span class="d_keyword">case</span> 5:
    <span class="d_keyword">goto</span> <span class="d_keyword">case</span> 4;
  <span class="d_keyword">default</span>:
    x = 4;
    <span class="d_keyword">break</span>;
}
</span></pre>
        Any intervening finally clauses are executed, along with
        releasing any intervening synchronization mutexes.

        <p>It is illegal for a <i>GotoStatement</i> to be used to skip
        initializations.</p>

<h3><a name="WithStatement">With Statement</a></h3>

        The with statement is a way to simplify repeated references
        to the same object.

<pre class="bnf"><span class="notranslate"><a name="WithStatement"><i>WithStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">with</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">with</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="template.html#Symbol"><i>Symbol</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">with</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="template.html#TemplateInstance"><i>TemplateInstance</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>
</span></pre>

        where <a href="expression.html#Expression"><i>Expression</i></a> evaluates to a class reference or struct
        instance.
        Within the with body the referenced object is searched first for
        identifier symbols. The <i>WithStatement</i>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">with</span> (expression)
{
  ...
  ident;
}
</span></pre>

        is semantically equivalent to:

<pre class="d_code"><span class="notranslate">{
  Object tmp;
  tmp = expression;
  ...
  tmp.ident;
}
</span></pre>

        <p>Note that <a href="expression.html#Expression"><i>Expression</i></a> only gets evaluated once.
        The with statement does not change what <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> or
        <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span> refer to.
        </p>

        <p>For <i>Symbol</i> which is a scope or <i>TemplateInstance</i>,
        the corresponding scope is searched when looking up symbols.
        For example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> Foo {
  <span class="d_keyword">alias</span> Y = <span class="d_keyword">int</span>;
}
...
Y y;        <span class="d_comment">// error, Y undefined
</span><span class="d_keyword">with</span> (Foo) {
  Y y;      <span class="d_comment">// same as Foo.Y y;
</span>}
</span></pre>

        <p>Use of with object symbols that shadow local symbols with
        the same identifier are not allowed.
        This is to reduce the risk of inadvertant breakage of with
        statements when new members are added to the object declaration.
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">float</span> x;
}

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">int</span> x;
  S s;
  <span class="d_keyword">with</span> (s) {
    x++;  <span class="d_comment">// error, shadows the int x declaration
</span>  }
}
</span></pre>


<h3><a name="SynchronizedStatement">Synchronized Statement</a></h3>

        <p>The synchronized statement wraps a statement with
        a mutex to synchronize access among multiple threads.
        </p>

<pre class="bnf"><span class="notranslate"><a name="SynchronizedStatement"><i>SynchronizedStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">synchronized</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">synchronized (</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a>
</span></pre>

        <p>Synchronized allows only one thread at a time to execute
        <i>ScopeStatement</i> by using a mutex.
        </p>

        <p>What mutex is used is determined by the <a href="expression.html#Expression"><i>Expression</i></a>.
        If there is no <a href="expression.html#Expression"><i>Expression</i></a>, then a global mutex is created,
        one per such synchronized statement.
        Different synchronized statements will have different global mutexes.
        </p>

        <p>If there is an <a href="expression.html#Expression"><i>Expression</i></a>, it must evaluate to either an
        Object or an instance of an <i>Interface</i>, in which case it
        is cast to the Object instance that implemented that <i>Interface</i>.
        The mutex used is specific to that Object instance, and
        is shared by all synchronized statements referring to that instance.
        </p>

        <p>The synchronization gets released even if <i>ScopeStatement</i>
        terminates with an exception, goto, or return.
        </p>

        <p>Example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">synchronized</span> { ... }
</span></pre>

        <p>This implements a standard critical section.
        </p>

        <p>Synchronized statements support recursive locking; that is, a
        function wrapped in synchronized is allowed to recursively call
        itself and the behavior will be as expected: The mutex will be
        locked and unlocked as many times as there is recursion.
        </p>

<h3><a name="TryStatement">Try Statement</a></h3>

        Exception handling is done with the try-catch-finally statement.

<pre class="bnf"><span class="notranslate"><a name="TryStatement"><i>TryStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">try</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a> <a href="#Catches"><i>Catches</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">try</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a> <a href="#Catches"><i>Catches</i></a> <a href="#FinallyStatement"><i>FinallyStatement</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">try</span></span> <a href="#ScopeStatement"><i>ScopeStatement</i></a> <a href="#FinallyStatement"><i>FinallyStatement</i></a>

<a name="Catches"><i>Catches</i></a>:
    <a href="#LastCatch"><i>LastCatch</i></a>
    <a href="#Catch"><i>Catch</i></a>
    <a href="#Catch"><i>Catch</i></a> <i>Catches</i>

<a name="LastCatch"><i>LastCatch</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">catch</span></span> <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>

<a name="Catch"><i>Catch</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">catch (</span></span> <a href="#CatchParameter"><i>CatchParameter</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>

<a name="CatchParameter"><i>CatchParameter</i></a>:
    <a href="declaration.html#BasicType"><i>BasicType</i></a> <i>Identifier</i>

<a name="FinallyStatement"><i>FinallyStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">finally</span></span> <a href="#NoScopeNonEmptyStatement"><i>NoScopeNonEmptyStatement</i></a>
</span></pre>

        <p><i>CatchParameter</i> declares a variable v of type T, where T is

        Throwable or derived from Throwable.
        v is initialized by the throw expression if T is of the same type or a
        base class of the throw expression. The catch clause will be executed
        if the exception object is of type T or derived from T.
        </p>

        <p>If just type T is given and no variable v, then the catch clause
        is still executed.
        </p>

        <p>It is an error if any <i>CatchParameter</i> type T1 hides
        a subsequent <i>Catch</i> with type T2, i.e. it is an error if
        T1 is the same type as or a base class of T2.
        </p>

        <p><i>LastCatch</i> catches all exceptions.
        </p>

        <p>The <i>FinallyStatement</i> is always executed, whether
        the <span class="notranslate"><span class="d_inlinecode donthyphenate">try</span></span> <i>ScopeStatement</i> exits with a goto, break,
        continue, return, exception, or fall-through.
        </p>

        <p>If an exception is raised in the <i>FinallyStatement</i> and is not
        caught before the original exception is caught, it is chained to the
        previous exception via the <i>next</i> member of <i>Throwable</i>.
        Note that, in contrast to most other programming languages, the new
        exception does not replace the original exception. Instead, later
        exceptions are regarded as 'collateral damage' caused by the first
        exception. The original exception must be caught, and this results in
        the capture of the entire chain.
        </p>

        <p>Thrown objects derived from <i>Error</i> are treated differently. They
        bypass the normal chaining mechanism, such that the chain can only be
        caught by catching the first <i>Error</i>. In addition to the list of
        subsequent exceptions, <i>Error</i> also contains a pointer that points
        to the original exception (the head of the chain) if a bypass occurred,
        so that the entire exception history is retained.
    </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> main() {
  <span class="d_keyword">try</span> {
    <span class="d_keyword">try</span> {
      <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"first"</span>);
    }
    <span class="d_keyword">finally</span> {
      writeln(<span class="d_string">"finally"</span>);
      <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"second"</span>);
    }
  }
  <span class="d_keyword">catch</span>(Exception e) {
    writeln(<span class="d_string">"catch %s"</span>, e.msg);
  }
  writeln(<span class="d_string">"done"</span>);
  <span class="d_keyword">return</span> 0;
}
</span></pre>

    prints:

<pre class="console"><span class="notranslate">finally
catch first
done
</span></pre>


        <p>A <i>FinallyStatement</i> may not exit with a goto, break,
        continue, or return; nor may it be entered with a goto.
        </p>

        <p>A <i>FinallyStatement</i> may not contain any <i>Catches</i>.
        This restriction may be relaxed in future versions.
        </p>

<h3><a name="ThrowStatement">Throw Statement</a></h3>

        Throw an exception.

<pre class="bnf"><span class="notranslate"><a name="ThrowStatement"><i>ThrowStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">throw</span></span> <a href="expression.html#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>

        <a href="expression.html#Expression"><i>Expression</i></a> is evaluated and must be  a Throwable reference.
        The  Throwable reference is thrown as an exception.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"message"</span>);
</span></pre>

<h3><a name="ScopeGuardStatement">Scope Guard Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="ScopeGuardStatement"><i>ScopeGuardStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(exit)</span></span> <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(success)</span></span> <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(failure)</span></span> <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a>
</span></pre>

        The <i>ScopeGuardStatement</i> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> at the close
        of the current scope, rather than at the point where the
        <i>ScopeGuardStatement</i> appears.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(exit)</span></span> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> when the scope
        exits normally or when it exits due to exception unwinding.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(failure)</span></span> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> when the scope
        exits due to exception unwinding.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(success)</span></span> executes <a href="#NonEmptyOrScopeBlockStatement"><i>NonEmptyOrScopeBlockStatement</i></a> when the scope
        exits normally.

        <p>If there are multiple <i>ScopeGuardStatement</i>s in a scope, they
        are executed in the reverse lexical order in which they appear.
        If any scope instances are to be destructed upon the close of the
        scope, they also are interleaved with the <i>ScopeGuardStatement</i>s
        in the reverse lexical order in which they appear.</p>


<pre class="d_code"><span class="notranslate">write(<span class="d_string">"1"</span>); {
  write(<span class="d_string">"2"</span>);
  <span class="d_keyword">scope</span>(exit) write(<span class="d_string">"3"</span>);
  <span class="d_keyword">scope</span>(exit) write(<span class="d_string">"4"</span>);
  write(<span class="d_string">"5"</span>);
}
writeln();
</span></pre>

        writes:

<pre class="console"><span class="notranslate">12543
</span></pre>


<pre class="d_code"><span class="notranslate">{
  <span class="d_keyword">scope</span>(exit) write(<span class="d_string">"1"</span>);
  <span class="d_keyword">scope</span>(success) write(<span class="d_string">"2"</span>);
  <span class="d_keyword">scope</span>(exit) write(<span class="d_string">"3"</span>);
  <span class="d_keyword">scope</span>(success) write(<span class="d_string">"4"</span>);
}
writeln();
</span></pre>

        writes:

<pre class="console"><span class="notranslate">4321
</span></pre>


<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">this</span>() { write(<span class="d_string">"0"</span>); }
  ~<span class="d_keyword">this</span>() { write(<span class="d_string">"1"</span>); }
}

<span class="d_keyword">try</span> {
  <span class="d_keyword">scope</span>(exit) write(<span class="d_string">"2"</span>);
  <span class="d_keyword">scope</span>(success) write(<span class="d_string">"3"</span>);
  <span class="d_keyword">scope</span> Foo f = <span class="d_keyword">new</span> Foo();
  <span class="d_keyword">scope</span>(failure) write(<span class="d_string">"4"</span>);
  <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"msg"</span>);
  <span class="d_keyword">scope</span>(exit) write(<span class="d_string">"5"</span>);
  <span class="d_keyword">scope</span>(success) write(<span class="d_string">"6"</span>);
  <span class="d_keyword">scope</span>(failure) write(<span class="d_string">"7"</span>);
}
<span class="d_keyword">catch</span> (Exception e) {
}
writeln();
</span></pre>

        writes:

<pre class="console"><span class="notranslate">0412
</span></pre>

        A <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(exit)</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">scope(success)</span></span> statement
        may not exit with a throw, goto, break, continue, or
        return; nor may it be entered with a goto.



<h3><a name="asm">Asm Statement</a></h3>

        Inline assembler is supported with the asm statement:

<pre class="bnf"><span class="notranslate"><a name="AsmStatement"><i>AsmStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">asm {</span></span> <a href="#AsmInstructionList"><i>AsmInstructionList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">}</span></span>

<a name="AsmInstructionList"><i>AsmInstructionList</i></a>:
    <a href="iasm.html#AsmInstruction"><i>AsmInstruction</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <a href="iasm.html#AsmInstruction"><i>AsmInstruction</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span> <i>AsmInstructionList</i>
</span></pre>

        An asm statement enables the direct use of assembly language
        instructions. This makes it easy to obtain direct access to special
        CPU features without resorting to an external assembler. The
        D compiler will take care of the function calling conventions,
        stack setup, etc.

        <p>The format of the instructions is, of course, highly dependent
        on the native instruction set of the target CPU, and so is
        <a href="iasm.html">implementation defined</a>.
        But, the format will follow the following
        conventions:</p>

        <ul>        <li>It must use the same tokens as the D language uses.</li>
        <li>The comment form must match the D language comments.</li>
        <li>Asm instructions are terminated by a ;, not by an
        end of line.</li>
        </ul>

        These rules exist to ensure that D source code can be tokenized
        independently of syntactic or semantic analysis.

        <p>For example, for the Intel Pentium:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> x = 3;
<span class="d_keyword">asm</span> {
  mov EAX,x; <span class="d_comment">// load x and put it in register EAX
</span>}
</span></pre>

        Inline assembler can be used to access hardware directly:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> gethardware() {
  <span class="d_keyword">asm</span> {
    mov EAX, dword ptr 0x1234;
  }
}
</span></pre>

        For some D implementations, such as a translator from D to C, an
        inline assembler makes no sense, and need not be implemented.
        The version statement can be used to account for this:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">version</span> (D_InlineAsm_X86)
{
  <span class="d_keyword">asm</span> {
    ...
  }
}
<span class="d_keyword">else</span>
{
  <span class="d_comment">/* ... some workaround ... */</span>
}
</span></pre>

        <p>Semantically consecutive <i>AsmStatement</i>s shall not have
        any other instructions (such as register save or restores) inserted
        between them by the compiler.
        </p>

<h3><a name="PragmaStatement">Pragma Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="PragmaStatement"><i>PragmaStatement</i></a>:
    <a href="pragma.html#Pragma"><i>Pragma</i></a> <a href="#NoScopeStatement"><i>NoScopeStatement</i></a>
</span></pre>

<h3><a name="MixinStatement">Mixin Statement</a></h3>

<pre class="bnf"><span class="notranslate"><a name="MixinStatement"><i>MixinStatement</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">mixin</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="expression.html#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
</span></pre>

        <p>The <a href="expression.html#AssignExpression"><i>AssignExpression</i></a> must evaluate at compile time
        to a constant string.
        The text contents of the string must be compilable as a valid
        <a href="#StatementList"><i>StatementList</i></a>, and is compiled as such.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">int</span> j;
  <span class="d_keyword">mixin</span>(<span class="d_string">"
    int x = 3;
    for (int i = 0; i &lt; 3; i++)
      writeln(x + i, ++j);
    "</span>);    <span class="d_comment">// ok
</span>
  <span class="d_keyword">const</span> <span class="d_keyword">char</span>[] s = <span class="d_string">"int y;"</span>;
  <span class="d_keyword">mixin</span>(s);  <span class="d_comment">// ok
</span>  y = 4;     <span class="d_comment">// ok, mixin declared y
</span>
  <span class="d_keyword">char</span>[] t = <span class="d_string">"y = 3;"</span>;
  <span class="d_keyword">mixin</span>(t);  <span class="d_comment">// error, t is not evaluatable at compile time
</span>
  <span class="d_keyword">mixin</span>(<span class="d_string">"y ="</span>) 4; <span class="d_comment">// error, string must be complete statement
</span>
  <span class="d_keyword">mixin</span>(<span class="d_string">"y ="</span> ~ <span class="d_string">"4;"</span>);  <span class="d_comment">// ok
</span>}
</span></pre>


  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div><!--/content-->



<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/Statement" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2017 by Digital Mars &reg;, All Rights Reserved |
Page generated by <a href="ddoc.html">Ddoc</a> on (no date time)
</div>
</body>
</html>


<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Arrays - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run-main-website.js" type="text/javascript"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
    var links = document.getElementById("navigation").getElementsByTagName("a");
    for (var i = 0; i < links.length; i++)
    {
        var url = "/" + links[i].getAttribute("href");
        if (window.location.href.match(url + "\x24") == url)
        {
            var cls = links[i].getAttribute("class");
            links[i].setAttribute("class", cls ? cls + " active" : "active");
            break;
        }
    }
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
    <div id="search-box">
        <form method="get" action="http://google.com/search">
            <img src="images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="images/search-button.gif" />
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <div id="search-dropdown">
                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </div>
        </form>
    </div>
    <div id="header">
        <a id="d-language" href="/">
        <img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png">
        D Programming Language</a>
    </div>
</div>

<!--Generated by Ddoc from arrays.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D 2.066.0</a></h2>
<ul>    <li><a href="overview.html" title="D language overview">Overview</a></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://ddili.org/ders/d.en/index.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a>

    <div class="navblock">
<ul>    <li><a href="intro.html">Introduction</a></li>
    <li><a href="lex.html">Lexical</a></li>
    <li><a href="grammar.html">Grammar</a></li>
    <li><a href="module.html">Modules</a></li>
    <li><a href="declaration.html">Declarations</a></li>
    <li><a href="type.html">Types</a></li>
    <li><a href="property.html">Properties</a></li>
    <li><a href="attribute.html">Attributes</a></li>
    <li><a href="pragma.html">Pragmas</a></li>
    <li><a href="expression.html">Expressions</a></li>
    <li><a href="statement.html">Statements</a></li>
    <li><a href="arrays.html">Arrays</a></li>
    <li><a href="hash-map.html">Associative Arrays</a></li>
    <li><a href="struct.html">Structs &amp; Unions</a></li>
    <li><a href="class.html">Classes</a></li>
    <li><a href="interface.html">Interfaces</a></li>
    <li><a href="enum.html">Enums</a></li>
    <li><a href="const3.html">Const and Immutable</a></li>
    <li><a href="function.html">Functions</a></li>
    <li><a href="operatoroverloading.html">Operator Overloading</a></li>
    <li><a href="template.html">Templates</a></li>
    <li><a href="template-mixin.html">Template Mixins</a></li>
    <li><a href="contracts.html">Contracts</a></li>
    <li><a href="version.html">Conditional Compilation</a></li>
    <li><a href="traits.html">Traits</a></li>
    <li><a href="errors.html">Handling errors</a></li>
    <li><a href="unittest.html">Unit Tests</a></li>
    <li><a href="garbage.html">Garbage Collection</a></li>
    <li><a href="float.html">Floating Point</a></li>
    <li><a href="iasm.html">Inline Assembler</a></li>
    <li><a href="ddoc.html">Documentation Comments</a></li>
    <li><a href="interfaceToC.html">Interfacing To C</a></li>
    <li><a href="cpp_interface.html">Interfacing To C++</a></li>
    <li><a href="portability.html">Portability Guide</a></li>
    <li><a href="entity.html">Named Character Entities</a></li>
    <li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
    <li><a href="abi.html">Application Binary Interface</a></li>
    <li><a href="simd.html">Vector Extensions</a></li>
    </ul>
</div></li>
    <li><a href="phobos/index.html">Library Reference</a></li>
    <li><a href="library/index.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a></li>
</ul>
    </div>

<div class="navblock">
<h2><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></h2>
<ul></ul>
    </div>

<div class="navblock">
<h2>Community</h2>
<ul>    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
    
</ul>
    </div>
  
<div id="translate" class="tool">Translate this page:
    <div id="google_translate_element"></div><script type="text/javascript">
    function googleTranslateElementInit() {
      new google.translate.TranslateElement({
        pageLanguage: 'en',
        autoDisplay: false,
        layout: google.translate.TranslateElement.InlineLayout.SIMPLE
      }, 'google_translate_element');
    }
    </script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>
</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
    <!--span id="lastupdate">Last update (no date time)</span-->
    <span class="tip">
        <a href="https://github.com/D-Programming-Language/dlang.org/edit/master/arrays.dd" class="button">Improve this page</a>
        <span>
            Quickly fork, edit online, and submit a pull request for this page.
            Requires a signed-in GitHub account. This works well for small changes.
            If you'd like to make larger changes you may want to consider using
            local clone.
        </span>
    </span>
    <span class="tip">
        <a href="http://wiki.dlang.org/DocComments/Arrays" class="button">Page wiki</a>
        <span>
            View or edit the community-maintained wiki page associated with this page.
        </span>
    </span>
</div>
  <h1>Arrays</h1>
  
    <p>There are four kinds of arrays:</p>

    <center><table border=1 cellpadding=4 cellspacing=0><caption>Kinds of Arrays</caption>        <tr><th class="donthyphenate"><b>Syntax</b></th><th class="donthyphenate"><b>Description</b></th></tr>
        <tr><td><i>type</i>*</td><td><a href="#pointers">Pointers to data</a></td></tr>
        <tr><td><i>type</i>[<i>integer</i>]</td><td><a href="#static-arrays">Static arrays</a></td></tr>
        <tr><td><i>type</i>[]</td><td> <a href="#dynamic-arrays">Dynamic arrays</a></td></tr>
        <tr><td><i>type</i>[<i>type</i>]</td><td><a href="hash-map.html">Associative arrays</a></td></tr>
    </table></center>

<h4><a name="pointers">Pointers</a></h4>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>* p;
</span></pre>

        <p>These are simple pointers to data, analogous to C pointers.
        Pointers are provided for interfacing with C and for
        specialized systems work.
        There
        is no length associated with it, and so there is no way for the
        compiler or runtime to do bounds checking, etc., on it.
        Most conventional uses for pointers can be replaced with
        dynamic arrays, <span class="notranslate"><span class="d_inlinecode donthyphenate">out</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">ref</span></span> parameters,
        and reference types.
        </p>

<h4><a name="static-arrays">Static Arrays</a></h4>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[3] s;
</span></pre>

        <p>These are analogous to C arrays. Static arrays are distinguished
        by having a length fixed at compile time.
        </p>

        <p>The total size of a static array cannot exceed 16Mb.
        A dynamic array should be used instead for such large arrays.
        </p>

        <p>A static array with a dimension of 0 is allowed, but no
        space is allocated for it. It's useful as the last member
        of a variable length struct, or as the degenerate case of
        a template expansion.
        </p>


        <p>Static arrays are value types. Unlike in C and D version 1,
        static arrays are passed to functions by value.
        Static arrays can also be returned by functions.
        </p>


<h4><a name="dynamic-arrays">Dynamic Arrays</a></h4>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] a;
</span></pre>

        <p>Dynamic arrays consist of a length and a pointer to the array data.
        Multiple dynamic arrays can share all or parts of the array data.
        </p>

<h3>Array Declarations</h3>

        <p>There are two ways to declare arrays, prefix and postfix.
        The prefix form is the preferred method, especially for
        non-trivial types.
        </p>

<h5>Prefix Array Declarations</h5>

        <p>Prefix declarations appear before the identifier being
        declared and read right to left, so:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] a;      <span class="d_comment">// dynamic array of ints
</span><span class="d_keyword">int</span>[4][3] b;  <span class="d_comment">// array of 3 arrays of 4 ints each
</span><span class="d_keyword">int</span>[][5] c;   <span class="d_comment">// array of 5 dynamic arrays of ints.
</span><span class="d_keyword">int</span>*[]*[3] d; <span class="d_comment">// array of 3 pointers to dynamic arrays of pointers to ints
</span><span class="d_keyword">int</span>[]* e;     <span class="d_comment">// pointer to dynamic array of ints
</span></span></pre>


<h5>Postfix Array Declarations</h5>

        <p>Postfix declarations appear after the identifier being
        declared and read left to right.
        Each group lists equivalent declarations:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_comment">// dynamic array of ints
</span><span class="d_keyword">int</span>[] a;
<span class="d_keyword">int</span> a[];

<span class="d_comment">// array of 3 arrays of 4 ints each
</span><span class="d_keyword">int</span>[4][3] b;
<span class="d_keyword">int</span>[4] b[3];
<span class="d_keyword">int</span> b[3][4];

<span class="d_comment">// array of 5 dynamic arrays of ints.
</span><span class="d_keyword">int</span>[][5] c;
<span class="d_keyword">int</span>[] c[5];
<span class="d_keyword">int</span> c[5][];

<span class="d_comment">// array of 3 pointers to dynamic arrays of pointers to ints
</span><span class="d_keyword">int</span>*[]*[3] d;
<span class="d_keyword">int</span>*[]* d[3];
<span class="d_keyword">int</span>* (*d[3])[];

<span class="d_comment">// pointer to dynamic array of ints
</span><span class="d_keyword">int</span>[]* e;
<span class="d_keyword">int</span> (*e)[];
</span></pre>

        <p><b>Rationale:</b> The postfix form matches the way arrays are
        declared in C and C++, and supporting this form provides an
        easy migration path for programmers used to it.
        </p>

<h3><a name="usage">Usage</a></h3>

        <p>There are two broad kinds of operations to do on an array -
        affecting
        the handle to the array,
        and affecting the contents of the array.
        C only has
        operators to affect the handle. In D, both are accessible.
        </p>

        <p>The handle to an array is specified by naming the array, as
        in p, s or a:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>* p;
<span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[] a;

<span class="d_keyword">int</span>* q;
<span class="d_keyword">int</span>[3] t;
<span class="d_keyword">int</span>[] b;

p = q;     <span class="d_comment">// p points to the same thing q does.
</span>p = s.ptr; <span class="d_comment">// p points to the first element of the array s.
</span>p = a.ptr; <span class="d_comment">// p points to the first element of the array a.
</span>
s = ...;   <span class="d_comment">// error, since s is a compiled in static
</span>           <span class="d_comment">// reference to an array.
</span>
a = p;     <span class="d_comment">// error, since the length of the array pointed
</span>           <span class="d_comment">// to by p is unknown
</span>a = s;     <span class="d_comment">// a is initialized to point to the s array
</span>a = b;     <span class="d_comment">// a points to the same array as b does
</span></span></pre>

<h3><a name="slicing">Slicing</a></h3>

        <p><i>Slicing</i> an array means to specify a subarray of it.
        An array slice does not copy the data, it is only another
        reference to it.
        For example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[10] a;   <span class="d_comment">// declare array of 10 ints
</span><span class="d_keyword">int</span>[] b;

b = a[1..3]; <span class="d_comment">// a[1..3] is a 2 element array consisting of
</span>             <span class="d_comment">// a[1] and a[2]
</span>foo(b[1]);   <span class="d_comment">// equivalent to foo(0)
</span>a[2] = 3;
foo(b[1]);   <span class="d_comment">// equivalent to foo(3)
</span></span></pre>

        <p>The [] is shorthand for a slice of the entire array.
        For example, the assignments to b:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[10] a;
<span class="d_keyword">int</span>[] b;

b = a;
b = a[];
b = a[0 .. a.length];
</span></pre>

        <p>are all semantically equivalent.
        </p>

        <p>Slicing
        is not only handy for referring to parts of other arrays,
        but for converting pointers into bounds-checked arrays:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>* p;
<span class="d_keyword">int</span>[] b = p[0..8];
</span></pre>

<h3><a name="array-copying">Array Copying</a></h3>

        <p>When the slice operator appears as the lvalue of an assignment
        expression, it means that the contents of the array are the
        target of the assignment rather than a reference to the array.
        Array copying happens when the lvalue is a slice, and the rvalue
        is an array of or pointer to the same type.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[3] t;

s[] = t;           <span class="d_comment">// the 3 elements of t[3] are copied into s[3]
</span>s[] = t[];         <span class="d_comment">// the 3 elements of t[3] are copied into s[3]
</span>s[1..2] = t[0..1]; <span class="d_comment">// same as s[1] = t[0]
</span>s[0..2] = t[1..3]; <span class="d_comment">// same as s[0] = t[1], s[1] = t[2]
</span>s[0..4] = t[0..4]; <span class="d_comment">// error, only 3 elements in s
</span>s[0..2] = t;       <span class="d_comment">// error, different lengths for lvalue and rvalue
</span></span></pre>

        <p>Overlapping copies are an error:</p>

<pre class="d_code"><span class="notranslate">s[0..2] = s[1..3]; <span class="d_comment">// error, overlapping copy
</span>s[1..3] = s[0..2]; <span class="d_comment">// error, overlapping copy
</span></span></pre>

        <p>Disallowing overlapping makes it possible for more aggressive
        parallel code optimizations than possible with the serial
        semantics of C.
        </p>

<h3><a name="array-setting">Array Setting</a></h3>

        <p>If a slice operator appears as the lvalue of an assignment
        expression, and the type of the rvalue is the same as the element
        type of the lvalue, then the lvalue's array contents
        are set to the rvalue.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>* p;

s[] = 3;     <span class="d_comment">// same as s[0] = 3, s[1] = 3, s[2] = 3
</span>p[0..2] = 3; <span class="d_comment">// same as p[0] = 3, p[1] = 3
</span></span></pre>

<h3><a name="array-concatenation">Array Concatenation</a></h3>

        <p>The binary operator ~ is the <i>cat</i> operator. It is used
        to concatenate arrays:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] a;
<span class="d_keyword">int</span>[] b;
<span class="d_keyword">int</span>[] c;

a = b ~ c; <span class="d_comment">// Create an array from the concatenation
</span>           <span class="d_comment">// of the b and c arrays
</span></span></pre>

        <p>Many languages overload the + operator to mean concatenation.
        This confusingly leads to, does:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_string">"10"</span> + 3 + 4
</span></pre>

        <p>produce the number 17, the string "1034" or the string "107" as the
        result? It isn't obvious, and the language designers wind up carefully
        writing rules to disambiguate it - rules that get incorrectly
        implemented, overlooked, forgotten, and ignored. It's much better to
        have + mean addition, and a separate operator to be array
        concatenation.
        </p>

        <p>Similarly, the ~= operator means append, as in:
        </p>

<pre class="d_code"><span class="notranslate">a ~= b; <span class="d_comment">// a becomes the concatenation of a and b
</span></span></pre>

        <p>Concatenation always creates a copy of its operands, even
        if one of the operands is a 0 length array, so:
        </p>

<pre class="d_code"><span class="notranslate">a = b;           <span class="d_comment">// a refers to b
</span>a = b ~ c[0..0]; <span class="d_comment">// a refers to a copy of b
</span></span></pre>

        <p>Appending does not always create a copy, see <a href="#resize">        setting dynamic array length</a> for details.
        </p>

<h3><a name="array-operations">Array Operations</a></h3>

        <p>Many array operations, also known as vector operations,
        can be expressed at a high level rather than as a loop.
        For example, the loop:
        </p>

<pre class="d_code"><span class="notranslate">T[] a, b;
...
<span class="d_keyword">for</span> (size_t i = 0; i &lt; a.length; i++)
  a[i] = b[i] + 4;
</span></pre>

        <p>assigns to the elements of <span class="notranslate"><span class="d_inlinecode donthyphenate">a</span></span> the elements of <span class="notranslate"><span class="d_inlinecode donthyphenate">b</span></span>
        with <span class="notranslate"><span class="d_inlinecode donthyphenate">4</span></span> added to each. This can also be expressed in
        vector notation as:
        </p>

<pre class="d_code"><span class="notranslate">T[] a, b;
...
a[] = b[] + 4;
</span></pre>

        <p>A vector operation is indicated by the slice operator appearing
        as the lvalue of an =, +=, -=, *=, /=, %=, ^=, &amp;= or |= operator.
        The rvalue can be an expression consisting either of an array
        slice of the same length and type as the lvalue or an expression
        of the element type of the lvalue, in any combination.
        The operators supported for vector operations are the binary
        operators +, -, *, /, %, ^, &amp; and |, and the unary operators
        - and ~.
        </p>

        <p>The lvalue slice and any rvalue slices must not overlap.
        The vector assignment operators are evaluated right to left,
        and the other binary operators are evaluated left to right.
        All operands are evaluated exactly once, even if the array slice
        has zero elements in it.
        </p>

        <p>The order in which the array elements are computed
        is implementation defined, and may even occur in parallel.
        An application must not depend on this order.
        </p>

        <p>Implementation note: many of the more common vector
        operations are expected to take advantage of any vector
        math instructions available on the target computer.
        </p>

<h3><a name="pointer-arithmetic">Pointer Arithmetic</a></h3>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[3] abc;              <span class="d_comment">// static array of 3 ints
</span><span class="d_keyword">int</span>[] def = [ 1, 2, 3 ]; <span class="d_comment">// dynamic array of 3 ints
</span>
<span class="d_keyword">void</span> dibb(<span class="d_keyword">int</span>* array) {
  array[2];     <span class="d_comment">// means same thing as *(array + 2)
</span>  *(array + 2); <span class="d_comment">// get 3rd element
</span>}

<span class="d_keyword">void</span> diss(<span class="d_keyword">int</span>[] array) {
  array[2];     <span class="d_comment">// ok
</span>  *(array + 2); <span class="d_comment">// error, array is not a pointer
</span>}

<span class="d_keyword">void</span> ditt(<span class="d_keyword">int</span>[3] array) {
  array[2];     <span class="d_comment">// ok
</span>  *(array + 2); <span class="d_comment">// error, array is not a pointer
</span>}
</span></pre>

<h3><a name="rectangular-arrays">Rectangular Arrays</a></h3>

        <p>Experienced FORTRAN numerics programmers know that multidimensional
        "rectangular" arrays for things like matrix operations are much faster than trying to
        access them via pointers to pointers resulting from "array of pointers to array" semantics.
        For example, the D syntax:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">double</span>[][] matrix;
</span></pre>

        <p>declares matrix as an array of pointers to arrays. (Dynamic arrays are implemented as
        pointers to the array data.) Since the arrays can have varying sizes (being dynamically
        sized), this is sometimes called "jagged" arrays. Even worse for optimizing the code, the
        array rows can sometimes point to each other! Fortunately, D static arrays, while using
        the same syntax, are implemented as a fixed rectangular layout:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">double</span>[3][3] matrix;
</span></pre>

        <p>declares a rectangular matrix with 3 rows and 3 columns, all contiguously in memory. In
        other languages, this would be called a multidimensional array and be declared as:
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">double</span> matrix[3,3];
</span></pre>

<h3><a name="array-length">Array Length</a></h3>


        <p>Within the [ ] of a static or a dynamic array,
        the symbol <span class="notranslate"><span class="d_inlinecode donthyphenate">$</span></span>
        represents the length of the array.
        </p>


<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[4] foo;
<span class="d_keyword">int</span>[]  bar = foo;
<span class="d_keyword">int</span>*   p = &amp;foo[0];

<span class="d_comment">// These expressions are equivalent:
</span>bar[]
bar[0 .. 4]
bar[0 .. $]
bar[0 .. bar.length]


p[0 .. $]      <span class="d_comment">// '$' is not defined, since p is not an array
</span>bar[0]+$            <span class="d_comment">// '$' is not defined, out of scope of [ ]
</span>
bar[$-1] <span class="d_comment">// retrieves last element of the array
</span></span></pre>

<h3><a name="array-properties">Array Properties</a></h3>

        <p>Static array properties are:</p>

    <center><table border=1 cellpadding=4 cellspacing=0><caption>Static Array Properties</caption>        <tr><th class="donthyphenate"><b>Property</b></th><th class="donthyphenate"><b>Description</b></th></tr>
        <tr><td> <span class="notranslate"><span class="d_inlinecode donthyphenate">.init</span></span></td><td>Returns an array literal with each element of the literal being the <span class="notranslate"><span class="d_inlinecode donthyphenate">.init</span></span> property of the array element type.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.sizeof</span></span></td><td>Returns the array length multiplied by
        the number of bytes per array element.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.length</span></span></td><td>Returns the number of elements in the array.
        This is a fixed quantity for static arrays. It is of type <span class="notranslate"><span class="d_inlinecode donthyphenate">size_t</span></span>.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.ptr</span></span></td><td>Returns a pointer to the first element of the array.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.dup</span></span></td><td>Create a dynamic array of the same size and copy the contents of the array into it.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.idup</span></span></td><td>Create a dynamic array of the same size and copy the contents of the array into it. The copy is typed as being immutable.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.reverse</span></span></td><td>Reverses in place the order of the elements in the array.
        Returns the array.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.sort</span></span></td><td>Sorts in place the order of the elements in
        the array. Returns the array.</td></tr>
        </table></center>

        <p>Dynamic array properties are:</p>

    <center><table border=1 cellpadding=4 cellspacing=0><caption>Dynamic Array Properties</caption>        <tr><th class="donthyphenate"><b>Property</b></th><th class="donthyphenate"><b>Description</b></th></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.init</span></span></td><td>Returns <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.sizeof</span></span></td><td>Returns the size of the dynamic array reference,
        which is 8 in 32-bit builds and 16 on 64-bit builds.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.length</span></span></td><td>Get/set number of elements in the
        array. It is of type <span class="notranslate"><span class="d_inlinecode donthyphenate">size_t</span></span>.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.ptr</span></span></td><td>Returns a pointer to the first element of the array.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.dup</span></span></td><td>Create a dynamic array of the same size
        and copy the contents of the array into it.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.idup</span></span></td><td>Create a dynamic array of the same size and
        copy the contents of the array into it. The copy is typed as
        being immutable. <i>D 2.0 only</i></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.reverse</span></span></td><td>Reverses in place the order of the
        elements in the array. Returns the array.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">.sort</span></span></td><td>Sorts in place the order of the elements in
        the array. Returns the array.</td></tr></table></center>

        <p>For the <span class="notranslate"><span class="d_inlinecode donthyphenate">.sort</span></span> property to work on arrays of class
        objects, the class definition must define the function:
        <span class="notranslate"><span class="d_inlinecode donthyphenate">int opCmp(Object)</span></span>. This is used to determine the
        ordering of the class objects. Note that the parameter
        is of type <span class="notranslate"><span class="d_inlinecode donthyphenate">Object</span></span>, not the type of the class.</p>

        <p>For the <span class="notranslate"><span class="d_inlinecode donthyphenate">.sort</span></span> property to work on arrays of
        structs or unions, the struct or union definition must
        define the function:

        <span class="notranslate"><span class="d_inlinecode donthyphenate">int opCmp(ref const S) const</span></span>.

        The type <span class="notranslate"><span class="d_inlinecode donthyphenate">S</span></span> is the type of the struct or union.
        This function will determine the sort ordering.
        </p>

    <p>Examples:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>* p;
<span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[] a;

p.length; <span class="d_comment">// error, length not known for pointer
</span>s.length; <span class="d_comment">// compile time constant 3
</span>a.length; <span class="d_comment">// runtime value
</span>
p.dup;    <span class="d_comment">// error, length not known
</span>s.dup;    <span class="d_comment">// creates an array of 3 elements, copies
</span>          <span class="d_comment">// elements s into it
</span>a.dup;    <span class="d_comment">// creates an array of a.length elements, copies
</span>          <span class="d_comment">// elements of a into it
</span></span></pre>

<h4><a name="resize">Setting Dynamic Array Length</a></h4>

        <p>The <span class="notranslate"><span class="d_inlinecode donthyphenate">.length</span></span> property of a dynamic array can be set
        as the lvalue of an = operator:
        </p>

<pre class="d_code"><span class="notranslate">array.length = 7;
</span></pre>

        <p>This causes the array to be reallocated in place, and the existing
        contents copied over to the new array. If the new array length is
        shorter, the array is not reallocated, and no data is copied.  It is
        equivalent to slicing the array:</p>

<pre class="d_code"><span class="notranslate">array = array[0..7];
</span></pre>

        <p>If the new array length is longer, the remainder is filled out with the
        default initializer.
        </p>

        <p>To maximize efficiency, the runtime always tries to resize the
        array in place to avoid extra copying.

        It will always do a copy if the new size is larger and the array
        was not allocated via the new operator or resizing in place would
        overwrite valid data in the array.
        </p>



        For example:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>[] a = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[20];
<span class="d_keyword">char</span>[] b = a[0..10];
<span class="d_keyword">char</span>[] c = a[10..20];
<span class="d_keyword">char</span>[] d = a;

b.length = 15; <span class="d_comment">// always reallocates because extending in place would
</span>               <span class="d_comment">// overwrite other data in a.
</span>b[11] = 'x';   <span class="d_comment">// a[11] and c[1] are not affected
</span>
d.length = 1;
d.length = 20; <span class="d_comment">// also reallocates, because doing this will overwrite a and
</span>               <span class="d_comment">// c
</span>
c.length = 12; <span class="d_comment">// may reallocate in place if space allows, because nothing
</span>               <span class="d_comment">// was allocated after c.
</span>c[5] = 'y';    <span class="d_comment">// may affect contents of a, but not b or d because those
</span>               <span class="d_comment">// were reallocated.
</span>
a.length = 25; <span class="d_comment">// This always reallocates because if c extended in place,
</span>               <span class="d_comment">// then extending a would overwrite c.  If c didn't
</span>               <span class="d_comment">// reallocate in place, it means there was not enough space,
</span>               <span class="d_comment">// which will still be true for a.
</span>a[15] = 'z';   <span class="d_comment">// does not affect c, because either a or c has reallocated.
</span></span></pre>


        <p>To guarantee copying behavior, use the .dup property to ensure
        a unique array that can be resized. Also, one may use the phobos
        <span class="notranslate"><span class="d_inlinecode donthyphenate">.capacity</span></span> property to determine how many elements can be appended
        to the array without reallocating.
        </p>

        <p>These issues also apply to appending arrays with the ~= operator.
        Concatenation using the ~ operator is not affected since it always
        reallocates.
        </p>

        <p>Resizing a dynamic array is a relatively expensive operation.
        So, while the following method of filling an array:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] array;
<span class="d_keyword">while</span> (1) {
  c = getinput();
  <span class="d_keyword">if</span> (!c)
    <span class="d_keyword">break</span>;
  ++array.length;
  array[array.length - 1] = c;
}
</span></pre>

        <p>will work, it will be inefficient. A more practical
        approach would be to minimize the number of resizes:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] array;
array.length = 100;        <span class="d_comment">// guess
</span><span class="d_keyword">for</span> (i = 0; ; i++) {
  c = getinput();
  <span class="d_keyword">if</span> (!c)
    <span class="d_keyword">break</span>;
  <span class="d_keyword">if</span> (i == array.length)
    array.length *= 2;
  array[i] = c;
}
array.length = i;
</span></pre>

        <p>Picking a good initial guess is an art, but you usually can
        pick a value covering 99% of the cases.
        For example, when gathering user
        input from the console - it's unlikely to be longer than 80.
        </p>

        <p>Also, you may wish to utilize the phobos <span class="notranslate"><span class="d_inlinecode donthyphenate">reserve</span></span>
        function to pre-allocate array data to use with the append operator.</p>

<h4><a name="func-as-property">Functions as Array Properties</a></h4>

        <p>If the first parameter to a function is an array, the
        function can be called as if it were a property of the array:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] array;
<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span>[] a, <span class="d_keyword">int</span> x);

foo(array, 3);
array.foo(3);   <span class="d_comment">// means the same thing
</span></span></pre>

<h3><a name="bounds">Array Bounds Checking</a></h3>

        <p>It is an error to index an array with an index that is less than
        0 or greater than or equal to the array length. If an index is
        out of bounds, a RangeError exception is
        raised if detected at runtime, and an error if detected at compile
        time.  A program may not rely on array bounds checking happening, for
        example, the following program is incorrect:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">try</span> {
  <span class="d_keyword">for</span> (i = 0; ; i++) {
    array[i] = 5;
  }
}
<span class="d_keyword">catch</span> (RangeError) {
  <span class="d_comment">// terminate loop
</span>}
</span></pre>

        The loop is correctly written:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">for</span> (i = 0; i &lt; array.length; i++) {
  array[i] = 5;
}
</span></pre>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">Implementation Note:</span></span> Compilers should attempt to detect
        array bounds errors at compile time, for example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[3] foo;
<span class="d_keyword">int</span> x = foo[3]; <span class="d_comment">// error, out of bounds
</span></span></pre>

        <p>Insertion of array bounds checking code at runtime should be
        turned on and off
        with a compile time switch.
        </p>

<h3><a name="array-initialization">Array Initialization</a></h3>

<h4><a name="default-initialization">Default Initialization</a></h4>

        <ul>        <li>Pointers are initialized to <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>.</li>
        <li>Static array contents are initialized to the default
        initializer for the array element type.</li>
        <li>Dynamic arrays are initialized to having 0 elements.</li>
        <li>Associative arrays are initialized to having 0 elements.</li>
        </ul>

<h4><a name="void-initialization">Void Initialization</a></h4>

        <p>Void initialization happens when the <i>Initializer</i> for
        an array is <span class="notranslate"><span class="d_inlinecode donthyphenate">void</span></span>. What it means is that no initialization
        is done, i.e. the contents of the array will be undefined.
        This is most useful as an efficiency optimization.
        Void initializations are an advanced technique and should only be used
        when profiling indicates that it matters.
        </p>

<h4><a name="static-init-static">Static Initialization of Statically Allocated Arrays</a></h4>

        <p>Static initalizations are supplied by a list of array
        element values enclosed in [ ]. The values can be optionally
        preceded by an index and a :.
        If an index is not supplied, it is set to the previous index
        plus 1, or 0 if it is the first value.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[3] a = [ 1:2, 3 ]; <span class="d_comment">// a[0] = 0, a[1] = 2, a[2] = 3
</span></span></pre>

        <p>This is most handy when the array indices are given by enums:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">enum</span> Color { red, blue, green };

<span class="d_keyword">int</span> value[Color.max + 1] =
  [ Color.blue :6,
    Color.green:2,
    Color.red  :5 ];
</span></pre>

        <p>These arrays are statically allocated when they appear in global scope.
        Otherwise, they need to be marked with <span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">static</span></span>
        storage classes to make them statically allocated arrays.</p>


<h3><a name="special-array">Special Array Types</a></h3>

<h4><a name="strings">Strings</a></h4>

        <p>A string is
        an array of characters. String literals are just
        an easy way to write character arrays.
        String literals are immutable (read only).
        </p>


<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>[] str1 = <span class="d_string">"abc"</span>;                <span class="d_comment">// error, "abc" is not mutable
</span><span class="d_keyword">char</span>[] str2 = <span class="d_string">"abc"</span>.dup;            <span class="d_comment">// ok, make mutable copy
</span><span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)[] str3 = <span class="d_string">"abc"</span>;     <span class="d_comment">// ok
</span><span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)[] str4 = str1;      <span class="d_comment">// error, str4 is not mutable
</span><span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)[] str5 = str1.idup; <span class="d_comment">// ok, make immutable copy
</span></span></pre>

        <p>The name <span class="notranslate"><span class="d_inlinecode donthyphenate">string</span></span> is aliased to <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable(char)[]</span></span>,
        so the above declarations could be equivalently written as:
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>[] str1 = <span class="d_string">"abc"</span>;     <span class="d_comment">// error, "abc" is not mutable
</span><span class="d_keyword">char</span>[] str2 = <span class="d_string">"abc"</span>.dup; <span class="d_comment">// ok, make mutable copy
</span>string str3 = <span class="d_string">"abc"</span>;     <span class="d_comment">// ok
</span>string str4 = str1;      <span class="d_comment">// error, str4 is not mutable
</span>string str5 = str1.idup; <span class="d_comment">// ok, make immutable copy
</span></span></pre>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">char[]</span></span> strings are in UTF-8 format.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">wchar[]</span></span> strings are in UTF-16 format.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">dchar[]</span></span> strings are in UTF-32 format.
        </p>

        <p>Strings can be copied, compared, concatenated, and appended:</p>

<pre class="d_code"><span class="notranslate">str1 = str2;
<span class="d_keyword">if</span> (str1 &lt; str3) ...
func(str3 ~ str4);
str4 ~= str1;
</span></pre>

        <p>with the obvious semantics. Any generated temporaries get cleaned up
        by the garbage collector (or by using <span class="notranslate"><span class="d_inlinecode donthyphenate">alloca()</span></span>).
        Not only that, this works with any
        array not just a special String array.
        </p>

        <p>A pointer to a char can be generated:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>* p = &amp;str[3]; <span class="d_comment">// pointer to 4th element
</span><span class="d_keyword">char</span>* p = str;     <span class="d_comment">// pointer to 1st element
</span></span></pre>

        <p>Since strings, however, are not 0 terminated in D,
        when transferring a pointer
        to a string to C, add a terminating 0:
        </p>

<pre class="d_code"><span class="notranslate">str ~= <span class="d_string">"\0"</span>;
</span></pre>

        <p>or use the function <span class="notranslate"><span class="d_inlinecode donthyphenate">std.string.toStringz</span></span>.</p>

        <p>The type of a string is determined by the semantic phase of
        compilation. The type is
        one of: char[], wchar[], dchar[], and is determined by
        implicit conversion rules.
        If there are two equally applicable implicit conversions,
        the result is an error. To
        disambiguate these cases, a cast or a postfix of <span class="notranslate"><span class="d_inlinecode donthyphenate">c</span></span>,
        <span class="notranslate"><span class="d_inlinecode donthyphenate">w</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">d</span></span> can be used:
        </p>

<pre class="d_code"><span class="notranslate">
<span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span>(<span class="d_keyword">wchar</span>) [])<span class="d_string">"abc"</span> <span class="d_comment">// this is an array of wchar characters
</span><span class="d_string">"abc"w</span>                         <span class="d_comment">// so is this
</span>
</span></pre>

        <p>String literals that do not have a postfix character and that
        have not been cast can be implicitly converted between
	string, wstring, and dstring as necessary.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span> c;
<span class="d_keyword">wchar</span> w;
<span class="d_keyword">dchar</span> d;

c = 'b';     <span class="d_comment">// c is assigned the character 'b'
</span>w = 'b';     <span class="d_comment">// w is assigned the wchar character 'b'
</span><span class="d_comment">//w = 'bc';  // error - only one wchar character at a time
</span>w = <span class="d_string">"b"</span>[0];  <span class="d_comment">// w is assigned the wchar character 'b'
</span>w = <span class="d_string">"\r"</span>[0]; <span class="d_comment">// w is assigned the carriage return wchar character
</span>d = 'd';     <span class="d_comment">// d is assigned the character 'd'
</span></span></pre>

<h5><a name="strings_unicode">Strings and Unicode</a></h5>
        <p>Note that built-in comparison operators operate on a
        <a href="http://goo.gl/zRY1K">code unit</a> basis. 
        The end result for valid strings is the same as that of 
        <a href="http://goo.gl/WR424">code point</a> 
        for <a href="http://goo.gl/WR424">code point</a>
        comparison as long as both strings are in the same
        <a href="http://goo.gl/3DKfI">normalization form</a>.
        Since normalization is a costly operation not suitable for language 
        primitives it's assumed to be enforced by the user.
        </p>
        <p>The standard library lends a hand for comparing strings with mixed encodings
        (by transparently decoding, see <a href="phobos/std_algorithm.html#cmp">std.algorithm.cmp</a>), 
        <a href="phobos/std_uni.html#icmp">case-insensitive comparison</a> and <a href="phobos/std_uni.html#normalize">normalization</a>.
        </p>
        <p>Last but not least, a desired string sorting order differs 
        by culture and language and is usually nothing like code point 
        for code point comparison. The natural order of strings is obtained by applying
        <a href="http://www.unicode.org/reports/tr10/">the Unicode collation algorithm</a>
        that should be implemented in the standard library.
        </p>

<h5><a name="printf">C's printf() and Strings</a></h5>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">printf()</span></span> is a C function and is not part of D. <span class="notranslate"><span class="d_inlinecode donthyphenate">printf()</span></span>
        will print C strings, which are 0 terminated. There are two ways
        to use <span class="notranslate"><span class="d_inlinecode donthyphenate">printf()</span></span> with D strings. The first is to add a
        terminating 0, and cast the result to a char*:
        </p>

<pre class="d_code"><span class="notranslate">str ~= <span class="d_string">"\0"</span>;
printf(<span class="d_string">"the string is '%s'\n"</span>, <span class="d_keyword">cast</span>(<span class="d_keyword">char</span>*)str);
</span></pre>

        <p>or:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.string;
printf(<span class="d_string">"the string is '%s'\n"</span>, std.string.toStringz(str));
</span></pre>

        <p>String literals already have a 0 appended to them, so
        can be used directly:</p>

<pre class="d_code"><span class="notranslate">printf(<span class="d_string">"the string is '%s'\n"</span>, <span class="d_keyword">cast</span>(<span class="d_keyword">char</span>*)<span class="d_string">"string literal"</span>);
</span></pre>

        <p>So, why does the first string literal to printf not need
        the cast? The first parameter is prototyped as a const(char)*, and
        a string literal can be implicitly cast to a const(char)*.
        The rest of the arguments to printf, however, are variadic
        (specified by ...),
        and a string literal is passed as a (length,pointer) combination
        to variadic parameters.</p>

        <p>The second way is to use the precision specifier.
        The length comes first, followed by the pointer:</p>

<pre class="d_code"><span class="notranslate">printf(<span class="d_string">"the string is '%.*s'\n"</span>, str.length, str.ptr);
</span></pre>

        <p>The best way is to use std.stdio.writefln, which can handle
        D strings:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;
writefln(<span class="d_string">"the string is '%s'"</span>, str);
</span></pre>

<h4><a name="implicit-conversions">Implicit Conversions</a></h4>

        <p>A pointer <span class="notranslate"><span class="d_inlinecode donthyphenate">T*</span></span> can be implicitly converted to
        one of the following:</p>

        <ul>        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">void*</span></span></li>
        </ul>

        <p>A static array <span class="notranslate"><span class="d_inlinecode donthyphenate">T[dim]</span></span> can be implicitly
        converted to
        one of the following:
        </p>

        <ul>        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">T[]</span></span></li>

        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">const(U)[]</span></span></li>
        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">const(U[])</span></span></li>
        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">void[]</span></span></li>
        </ul>

        <p>A dynamic array <span class="notranslate"><span class="d_inlinecode donthyphenate">T[]</span></span> can be implicitly converted to
        one of the following:
        </p>

        <ul>
        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">const(U)[]</span></span></li>
        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">const(U[])</span></span></li>
        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">void[]</span></span></li>
        </ul>

        <p>Where <span class="notranslate"><span class="d_inlinecode donthyphenate">U</span></span> is a base class of <span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span>.</p>

  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div><!--/content-->



<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/Arrays" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2017 by Digital Mars &reg;, All Rights Reserved |
Page generated by <a href="ddoc.html">Ddoc</a> on (no date time)
</div>
</body>
</html>

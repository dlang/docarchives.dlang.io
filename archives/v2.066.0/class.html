
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Classes - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run-main-website.js" type="text/javascript"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
    var links = document.getElementById("navigation").getElementsByTagName("a");
    for (var i = 0; i < links.length; i++)
    {
        var url = "/" + links[i].getAttribute("href");
        if (window.location.href.match(url + "\x24") == url)
        {
            var cls = links[i].getAttribute("class");
            links[i].setAttribute("class", cls ? cls + " active" : "active");
            break;
        }
    }
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
    <div id="search-box">
        <form method="get" action="http://google.com/search">
            <img src="images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="images/search-button.gif" />
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <div id="search-dropdown">
                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </div>
        </form>
    </div>
    <div id="header">
        <a id="d-language" href="/">
        <img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png">
        D Programming Language</a>
    </div>
</div>

<!--Generated by Ddoc from class.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D 2.066.0</a></h2>
<ul>    <li><a href="overview.html" title="D language overview">Overview</a></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://ddili.org/ders/d.en/index.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a>

    <div class="navblock">
<ul>    <li><a href="intro.html">Introduction</a></li>
    <li><a href="lex.html">Lexical</a></li>
    <li><a href="grammar.html">Grammar</a></li>
    <li><a href="module.html">Modules</a></li>
    <li><a href="declaration.html">Declarations</a></li>
    <li><a href="type.html">Types</a></li>
    <li><a href="property.html">Properties</a></li>
    <li><a href="attribute.html">Attributes</a></li>
    <li><a href="pragma.html">Pragmas</a></li>
    <li><a href="expression.html">Expressions</a></li>
    <li><a href="statement.html">Statements</a></li>
    <li><a href="arrays.html">Arrays</a></li>
    <li><a href="hash-map.html">Associative Arrays</a></li>
    <li><a href="struct.html">Structs &amp; Unions</a></li>
    <li><a href="class.html">Classes</a></li>
    <li><a href="interface.html">Interfaces</a></li>
    <li><a href="enum.html">Enums</a></li>
    <li><a href="const3.html">Const and Immutable</a></li>
    <li><a href="function.html">Functions</a></li>
    <li><a href="operatoroverloading.html">Operator Overloading</a></li>
    <li><a href="template.html">Templates</a></li>
    <li><a href="template-mixin.html">Template Mixins</a></li>
    <li><a href="contracts.html">Contracts</a></li>
    <li><a href="version.html">Conditional Compilation</a></li>
    <li><a href="traits.html">Traits</a></li>
    <li><a href="errors.html">Handling errors</a></li>
    <li><a href="unittest.html">Unit Tests</a></li>
    <li><a href="garbage.html">Garbage Collection</a></li>
    <li><a href="float.html">Floating Point</a></li>
    <li><a href="iasm.html">Inline Assembler</a></li>
    <li><a href="ddoc.html">Documentation Comments</a></li>
    <li><a href="interfaceToC.html">Interfacing To C</a></li>
    <li><a href="cpp_interface.html">Interfacing To C++</a></li>
    <li><a href="portability.html">Portability Guide</a></li>
    <li><a href="entity.html">Named Character Entities</a></li>
    <li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
    <li><a href="abi.html">Application Binary Interface</a></li>
    <li><a href="simd.html">Vector Extensions</a></li>
    </ul>
</div></li>
    <li><a href="phobos/index.html">Library Reference</a></li>
    <li><a href="library/index.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a></li>
</ul>
    </div>

<div class="navblock">
<h2><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></h2>
<ul></ul>
    </div>

<div class="navblock">
<h2>Community</h2>
<ul>    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
    
</ul>
    </div>
  
<div id="translate" class="tool">Translate this page:
    <div id="google_translate_element"></div><script type="text/javascript">
    function googleTranslateElementInit() {
      new google.translate.TranslateElement({
        pageLanguage: 'en',
        autoDisplay: false,
        layout: google.translate.TranslateElement.InlineLayout.SIMPLE
      }, 'google_translate_element');
    }
    </script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>
</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
    <!--span id="lastupdate">Last update (no date time)</span-->
    <span class="tip">
        <a href="https://github.com/D-Programming-Language/dlang.org/edit/master/class.dd" class="button">Improve this page</a>
        <span>
            Quickly fork, edit online, and submit a pull request for this page.
            Requires a signed-in GitHub account. This works well for small changes.
            If you'd like to make larger changes you may want to consider using
            local clone.
        </span>
    </span>
    <span class="tip">
        <a href="http://wiki.dlang.org/DocComments/Class" class="button">Page wiki</a>
        <span>
            View or edit the community-maintained wiki page associated with this page.
        </span>
    </span>
</div>
  <h1>Classes</h1>
  
        <p>The object-oriented features of D all come from classes. The class
        hierarchy
        has as its root the class Object. Object defines a minimum level of functionality
        that each derived class has, and a default implementation for that functionality.
        </p>

        <p>Classes are programmer defined types. Support for classes are what
        make D an object oriented language, giving it encapsulation, inheritance,
        and polymorphism. D classes support the single inheritance paradigm, extended
        by adding support for interfaces. Class objects are instantiated by reference
        only.
        </p>

        <p>A class can be exported, which means its name and all its
        non-private
        members are exposed externally to the DLL or EXE.
        </p>

        <p>A class declaration is defined:
        </p>

<pre class="bnf"><span class="notranslate"><a name="ClassDeclaration"><i>ClassDeclaration</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span> <i>Identifier</i> <a href="#BaseClassList"><i>BaseClassList</i></a><sub>opt</sub> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>
    <a href="template.html#ClassTemplateDeclaration"><i>ClassTemplateDeclaration</i></a>

<a name="BaseClassList"><i>BaseClassList</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#SuperClass"><i>SuperClass</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#SuperClass"><i>SuperClass</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="#Interfaces"><i>Interfaces</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#Interfaces"><i>Interfaces</i></a>

<a name="SuperClass"><i>SuperClass</i></a>:
    <i>Identifier</i>

<a name="Interfaces"><i>Interfaces</i></a>:
    <a href="#Interface"><i>Interface</i></a>
    <a href="#Interface"><i>Interface</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <i>Interfaces</i>

<a name="Interface"><i>Interface</i></a>:
    <i>Identifier</i>
</span></pre>

Classes consist of:

<ul>        <li>a super class</li>
        <li>interfaces</li>
        <li>dynamic fields</li>
        <li>static fields</li>
        <li>types</li>
        <li><a href="#synchronized-classes">an optional synchronized attribute</a></li>
        <li><a href="#member-functions">member functions</a>
        <ul>            <li>static member functions</li>
            <li><a href="function.html#virtual-functions">Virtual Functions</a></li>
            <li><a href="#constructors">Constructors</a></li>
            <li><a href="#destructors">Destructors</a></li>
            <li><a href="#StaticConstructor">Static Constructors</a></li>
            <li><a href="#StaticDestructor">Static Destructors</a></li>
            <li><a href="#SharedStaticConstructor"><i>SharedStaticConstructor</i></a>s</li>
            <li><a href="#SharedStaticDestructor"><i>SharedStaticDestructor</i></a>s</li>
            <li><a href="#invariants">Class Invariants</a></li>
            <li><a href="unittest.html#unittest">Unit Tests</a></li>
            <li><a href="#allocators">Class Allocators</a></li>
            <li><a href="#deallocators">Class Deallocators</a></li>
            <li><a href="#AliasThis">Alias This</a></li>
        </ul>
        </li>
</ul>

        A class is defined:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  ... members ...
}
</span></pre>

        <p>Note that there is no trailing <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span> after the closing <span class="notranslate"><span class="d_inlinecode donthyphenate">}</span></span> of the class
        definition.
        It is also not possible to declare a variable var like:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo { } var;
</span></pre>

        Instead:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo { }
Foo var;
</span></pre>

<h3>Access Control</h3>

	<p>Access to class members is controlled using <a href="attribute.html#ProtectionAttribute"><i>ProtectionAttribute</i></a>s.
	The default protection attribute is <span class="notranslate"><span class="d_inlinecode donthyphenate">public</span></span>.
	Access control does not affect visibility.
	</p>

<h3>Fields</h3>

        <p>Class members are always accessed with the . operator.
        </p>

	<p>Members of a base class can be accessed by prepending the name of
	the base class followed by a dot:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { <span class="d_keyword">int</span> a; }
<span class="d_keyword">class</span> B : A { <span class="d_keyword">int</span> a; }

<span class="d_keyword">void</span> foo(B b) {
  b.a = 3;   <span class="d_comment">// accesses field B.a
</span>  b.A.a = 4; <span class="d_comment">// accesses field A.a
</span></span></pre>

        <p>The D compiler is free to rearrange the order of fields in a class to
        optimally pack them in an implementation-defined manner.
        Consider the fields much like the local
        variables in a function -
        the compiler assigns some to registers and shuffles others around all to
        get the optimal
        stack frame layout. This frees the code designer to organize the fields
        in a manner that
        makes the code more readable rather than being forced to organize it
        according to
        machine optimization rules. Explicit control of field layout is provided
        by struct/union
        types, not classes.
        </p>

<h3>Field Properties</h3>

        <p>The <span class="notranslate"><span class="d_inlinecode donthyphenate">.offsetof</span></span> property gives the offset in bytes of the field
        from the beginning of the class instantiation.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">.offsetof</span></span> can only be applied to
        expressions which produce the type of
        the field itself, not the class type:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">int</span> x;
}
...
<span class="d_keyword">void</span> test(Foo foo) {
  size_t o;

  o = Foo.x.offsetof; <span class="d_comment">// error, Foo.x needs a 'this' reference
</span>  o = foo.x.offsetof; <span class="d_comment">// ok
</span>}
</span></pre>

<h3>Class Properties</h3>

        <p>The <span class="notranslate"><span class="d_inlinecode donthyphenate">.tupleof</span></span> property returns an <i>ExpressionTuple</i>
        of all the fields
        in the class, excluding the hidden fields and the fields in the
        base class.
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo { <span class="d_keyword">int</span> x; <span class="d_keyword">long</span> y; }
<span class="d_keyword">void</span> test(Foo foo) {
  foo.tupleof[0] = 1; <span class="d_comment">// set foo.x to 1
</span>  foo.tupleof[1] = 2; <span class="d_comment">// set foo.y to 2
</span>  <span class="d_keyword">foreach</span> (x; foo.tupleof)
    write(x);         <span class="d_comment">// prints 12
</span>}
</span></pre>

        <p>The properties <span class="notranslate"><span class="d_inlinecode donthyphenate">.__vptr</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">.__monitor</span></span> give access
        to the class object's vtbl[] and monitor, respectively, but
        should not be used in user code.
        </p>

<h3>Super Class</h3>

        All classes inherit from a super class. If one is not specified,
        it inherits from Object. Object forms the root of the D class
        inheritance hierarchy.

<h3><a name="member-functions">Member Functions</a></h3>

        <p>Non-static member functions have an extra hidden parameter
        called <i>this</i> through which the class object's other members
        can be accessed.
        </p>

	<p>Non-static member functions can have, in addition to the usual
	<a href="declaration.html#FunctionAttribute"><i>FunctionAttribute</i></a>s, the attributes
	<span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span>, or <span class="notranslate"><span class="d_inlinecode donthyphenate">inout</span></span>.
	These attributes apply to the hidden <i>this</i> parameter.
	</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">int</span> a;
  <span class="d_keyword">const</span> <span class="d_keyword">void</span> foo() {
    a = 3; <span class="d_comment">// error, 'this' is const
</span>  }
  <span class="d_keyword">void</span> foo() <span class="d_keyword">immutable</span> {
    a = 3; <span class="d_comment">// error, 'this' is immutable
</span>  }
</span></pre>


<h3><a name="synchronized-classes">Synchronized Classes</a></h3>

        <p>All member functions of synchronized classes are synchronized.
        A static member function is synchronized on the <i>classinfo</i>
        object for the class, which means that one monitor is used
        for all static member functions for that synchronized class.
        For non-static functions of a synchronized class, the monitor
        used is part of the class object. For example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">synchronized</span> <span class="d_keyword">class</span> Foo {
   <span class="d_keyword">void</span> bar() { ...statements... }
}
</span></pre>

        <p>is equivalent to (as far as the monitors go):
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">synchronized</span> <span class="d_keyword">class</span> Foo {
  <span class="d_keyword">void</span> bar() {
    <span class="d_keyword">synchronized</span> (<span class="d_keyword">this</span>) { ...statements... }
  }
}
</span></pre>

        <p>Member functions of non-synchronized classes cannot be individually marked as synchronized.
        The synchronized attribute must be applied to the class declaration itself:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">synchronized</span> <span class="d_keyword">void</span> foo() { }  <span class="d_comment">// disallowed!
</span>}

<span class="d_keyword">synchronized</span> <span class="d_keyword">class</span> Bar {
  <span class="d_keyword">void</span> bar() { }  <span class="d_comment">// bar is synchronized
</span>}
</span></pre>

        <p>Member fields of a synchronized class cannot be public:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">synchronized</span> <span class="d_keyword">class</span> Foo {
  <span class="d_keyword">int</span> foo;  <span class="d_comment">// disallowed: public field
</span>}

<span class="d_keyword">synchronized</span> <span class="d_keyword">class</span> Bar {
  <span class="d_keyword">private</span> <span class="d_keyword">int</span> bar;  <span class="d_comment">// ok
</span>}
</span></pre>

        <p>The <span class="notranslate"><span class="d_inlinecode donthyphenate">synchronized</span></span> attribute can only be applied to classes,
        structs cannot be marked to be synchronized.</p>

<h3><a name="constructors">Constructors</a></h3>

<pre class="bnf"><span class="notranslate"><a name="Constructor"><i>Constructor</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> <a href="declaration.html#Parameters"><i>Parameters</i></a> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> <a href="declaration.html#Parameters"><i>Parameters</i></a> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
    <a href="template.html#ConstructorTemplate"><i>ConstructorTemplate</i></a>
</span></pre>

        <p>Members are always initialized to the
        <a name="class-default-initializer">default initializer</a>
        for their type, which is usually 0 for integer types and
        NAN for floating point types.
        This eliminates an entire
        class of obscure problems that come from
        neglecting to initialize a member in one of the constructors.
        In the class definition,
        there can be a static initializer to be
        used instead of the default:
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Abc {
  <span class="d_keyword">int</span> a;      <span class="d_comment">// default initializer for a is 0
</span>  <span class="d_keyword">long</span> b = 7; <span class="d_comment">// default initializer for b is 7
</span>  <span class="d_keyword">float</span> f;    <span class="d_comment">// default initializer for f is NAN
</span>}
</span></pre>

        This static initialization is done before any constructors are
        called.

        <p>Constructors are defined with a function name of <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span>
        and having no return value:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <b><i><span class="d_keyword">this</span></i></b>(<span class="d_keyword">int</span> x)  <span class="d_comment">// declare constructor for Foo
</span>  {   ...
  }
  <b><i><span class="d_keyword">this</span></i></b>()
  {   ...
  }
}
</span></pre>

        Base class construction is done by calling the base class
        constructor by the name <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span>:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { <span class="d_keyword">this</span>(<span class="d_keyword">int</span> y) { } }

<span class="d_keyword">class</span> B : A {
  <span class="d_keyword">int</span> j;
  <span class="d_keyword">this</span>() {
    ...
    <b><i><span class="d_keyword">super</span></i></b>(3);  <span class="d_comment">// call base constructor A.this(3)
</span>    ...
  }
}
</span></pre>

        <p>Constructors can also call other constructors for the same class
        in order to share common initializations
        <a name="delegating-constructors">(this is called delegating constructors)</a>:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">int</span> j;
  <span class="d_keyword">this</span>() {
    ...
  }
  <span class="d_keyword">this</span>(<span class="d_keyword">int</span> i) {
    <b><i><span class="d_keyword">this</span></i></b>();
    j = i;
  }
}
</span></pre>

        If no call to constructors via <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span> appear
        in a constructor, and the base class has a constructor, a call
        to <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span>() is inserted at the beginning of the constructor.

        <p>If there is no constructor for a class, but there is a constructor
        for the base class, a default constructor of the form:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">this</span>() { }
</span></pre>

        <p>is implicitly generated.</p>

        <p>Class object construction is very flexible, but some restrictions
        apply:</p>

    <ol>        <li>It is illegal for constructors to mutually call each other,
        although the compiler is not required to detect it. It will result
        in undefined behavior.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">this</span>() { <span class="d_keyword">this</span>(1); }
<span class="d_keyword">this</span>(<span class="d_keyword">int</span> i) { <span class="d_keyword">this</span>(); } <span class="d_comment">// illegal, cyclic constructor calls
</span></span></pre>
        </li>

        <li>If any constructor call appears inside a constructor, any
        path through the constructor must make exactly one constructor
        call:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">this</span>()  { a || <span class="d_keyword">super</span>(); }       <span class="d_comment">// illegal
</span>
<span class="d_keyword">this</span>() { (a) ? <span class="d_keyword">this</span>(1) : <span class="d_keyword">super</span>(); }     <span class="d_comment">// ok
</span>
<span class="d_keyword">this</span>() {
  <span class="d_keyword">for</span> (...) {
    <span class="d_keyword">super</span>();  <span class="d_comment">// illegal, inside loop
</span>  }
}
</span></pre>
        </li>

        <li>It is illegal to refer to <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> implicitly or explicitly
        prior to making a constructor call.</li>

        <li>Constructor calls cannot appear after labels (in order to make
        it easy to check for the previous conditions in the presence of goto's).</li>
    </ol>

        <p>Instances of class objects are created with <i>NewExpression</i>s:</p>

<pre class="d_code"><span class="notranslate">A a = <span class="d_keyword">new</span> A(3);
</span></pre>

        <p>The following steps happen:</p>

    <ol>        <li>Storage is allocated for the object.
        If this fails, rather than return <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>, an
        <span class="notranslate"><span class="d_inlinecode donthyphenate">OutOfMemoryError</span></span> is thrown.
        Thus, tedious checks for null references are unnecessary.
        </li>

        <li>The raw data is statically initialized using the values provided
        in the class definition.
        The pointer to the vtbl[] (the array of pointers to virtual functions)
        is assigned.
        This ensures that constructors are
        passed fully formed objects for which virtual functions can be called.
        This operation is equivalent to doing a memory copy of a static
        version of the object onto the newly allocated one,
        although more advanced compilers
        may be able to optimize much of this away.
        </li>

        <li>If there is a constructor defined for the class,
        the constructor matching the
        argument list is called.
        </li>

        <li>If class invariant checking is turned on, the class invariant
        is called at the end of the constructor.
        </li>
    </ol>

        <p>Constructors can have one of these member function attributes:
        <span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span>, and <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span>. Construction of qualified
        objects will then be restricted to the implemented qualified constructors.
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">this</span>();   <span class="d_comment">// non-shared mutable constructor
</span>}

<span class="d_comment">// create mutable object
</span>C m = <span class="d_keyword">new</span> C();

<span class="d_comment">// create const object using by mutable constructor
</span><span class="d_keyword">const</span> C c2 = <span class="d_keyword">new</span> <span class="d_keyword">const</span> C();

<span class="d_comment">// a mutable constructor cannot create an immutable object
</span><span class="d_comment">// immutable C i = new immutable C();
</span>
<span class="d_comment">// a mutable constructor cannot create a shared object
</span><span class="d_comment">// shared C s = new shared C();
</span></span></pre>

        <p>Constructors can be overloaded with different attributes.
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">this</span>();               <span class="d_comment">// non-shared mutable constructor
</span>  <span class="d_keyword">this</span>() <span class="d_keyword">shared</span>;        <span class="d_comment">// shared mutable constructor
</span>  <span class="d_keyword">this</span>() <span class="d_keyword">immutable</span>;     <span class="d_comment">// immutable constructor
</span>}

C m = <span class="d_keyword">new</span> C();
<span class="d_keyword">shared</span> s = <span class="d_keyword">new</span> <span class="d_keyword">shared</span> C();
<span class="d_keyword">immutable</span> i = <span class="d_keyword">new</span> <span class="d_keyword">immutable</span> C();
</span></pre>

        <p>If the constructor can create unique object (e.g. if it is pure),
        the object can be implicitly convertible to any qualifiers.
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">this</span>() <span class="d_keyword">pure</span>;
  <span class="d_comment">// Based on the definition, this creates a mutable object. But the
</span>  <span class="d_comment">// created object cannot contain any mutable global data.
</span>  <span class="d_comment">// Then compiler can guarantee that the created object is unique.
</span>
  <span class="d_keyword">this</span>(<span class="d_keyword">int</span>[] arr) <span class="d_keyword">immutable</span> <span class="d_keyword">pure</span>;
  <span class="d_comment">// Based on the definition, this creates an immutable object. But the
</span>  <span class="d_comment">// argument int[] never appears in the created object so it isn't
</span>  <span class="d_comment">// implicitly convertible to immutable. Also, it cannot store any
</span>  <span class="d_comment">// immutable global data.
</span>  <span class="d_comment">// Therefore the compiler can guarantee that the created object is
</span>  <span class="d_comment">// unique.
</span>}

<span class="d_keyword">immutable</span> i = <span class="d_keyword">new</span> <span class="d_keyword">immutable</span> C();           <span class="d_comment">// this() pure is called
</span><span class="d_keyword">shared</span> s = <span class="d_keyword">new</span> <span class="d_keyword">shared</span> C();                 <span class="d_comment">// this() pure is called
</span>C m = <span class="d_keyword">new</span> C([1,2,3]);       <span class="d_comment">// this(int[]) immutable pure is called
</span></span></pre>

<h3><a name="field-init">Field initialization inside constructor</a></h3>

    <p>Inside constructor, the first instance field assignment is specially
        handled for its initialization.
    </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">int</span> num;
  <span class="d_keyword">this</span>() {
    num = 1;  <span class="d_comment">// initialize
</span>    num = 2;  <span class="d_comment">// assignment
</span>  }
}
</span></pre>

    <p>If the field type has opAssign method, it won't be used for initialization.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> A {
  <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) {}
  <span class="d_keyword">void</span> opAssign(A rhs) {}
}
<span class="d_keyword">class</span> C {
  A val;
  <span class="d_keyword">this</span>() {
    val = A(1);  <span class="d_comment">// A(1) is moved in this.val for initializing
</span>    val = A(2);  <span class="d_comment">// rewritten to val.opAssign(A(2))
</span>  }
}
</span></pre>

    <p>If the field type is not modifiable, multiple initialization will be rejected.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">immutable</span> <span class="d_keyword">int</span> num;
  <span class="d_keyword">this</span>() {
    num = 1;  <span class="d_comment">// OK
</span>    num = 2;  <span class="d_comment">// Error: multiple field initialization
</span>  }
}
</span></pre>

    <p>If the assignment expression for the field initialization may be invoked
        multiple times, it would als be rejected.
    </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">immutable</span> <span class="d_keyword">int</span> num;
  <span class="d_keyword">immutable</span> string str;
  <span class="d_keyword">this</span>() {
    <span class="d_keyword">foreach</span> (i; 0..2) {
      num = 1;      <span class="d_comment">// Error: field initialization not allowed in loops
</span>    }
    size_t i = 0;
  Label:
    str = <span class="d_string">"hello"</span>;  <span class="d_comment">// Error: field initialization not allowed after labels
</span>    <span class="d_keyword">if</span> (i++ &lt; 2)
      <span class="d_keyword">goto</span> Label;
  }
}
</span></pre>

<h3><a name="destructors">Destructors</a></h3>

<pre class="bnf"><span class="notranslate"><a name="Destructor"><i>Destructor</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">~ this ( )</span></span> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">~ this ( )</span></span> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

        The garbage collector calls the destructor function when the object
        is deleted. The syntax
        is:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  ~<span class="d_keyword">this</span>() <span class="d_comment">// destructor for Foo
</span>  {
  }
}
</span></pre>

        <p>There can be only one destructor per class, the destructor
        does not have any parameters,
        and has no attributes. It is always virtual.
        </p>

        <p>The destructor is expected to release any resources held by the
        object.
        </p>

        <p>The  program can explicitly inform the garbage collector that an
        object is no longer referred to (with the delete expression), and
        then the garbage collector calls the destructor
        immediately, and adds the object's memory to the free storage.
        The destructor is guaranteed to never be called twice.
        </p>

        <p>The destructor for the super class automatically gets called when
        the destructor ends. There is no way to call the super destructor
        explicitly.
        </p>

        <p>The garbage collector is not guaranteed to run the destructor
        for all unreferenced objects. Furthermore, the order in which the
        garbage collector calls destructors for unreference objects
        is not specified.
        This means that
        when the garbage collector calls a destructor for an object of a class
        that has
        members that are references to garbage collected objects, those
        references may no longer be valid. This means that destructors
        cannot reference sub objects.
        This rule does not apply to auto objects or objects deleted
        with the <i>DeleteExpression</i>, as the destructor is not being run
        by the garbage collector, meaning all references are valid.
        </p>

        <p>Objects referenced from the data segment never get collected
        by the gc.
        </p>

<h3>Static Constructors</h3>

<pre class="bnf"><span class="notranslate"><a name="StaticConstructor"><i>StaticConstructor</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">static this ( )</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">static this ( )</span></span> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

	<p>

        A static constructor is a function that performs
        initializations of thread local data before the <span class="notranslate"><span class="d_inlinecode donthyphenate">main()</span></span> function gets control for
	the main thread, and upon thread startup.

	Static constructors are used to initialize
        static class members
        with values that cannot be computed at compile time.
        </p>

        <p>Static constructors in other languages are built implicitly by using
        member
        initializers that can't be computed at compile time. The trouble with
        this stems from not
        having good control over exactly when the code is executed, for example:
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> a = b + 1;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> b = a * 2;
}
</span></pre>

        What values do a and b end up with, what order are the initializations
        executed in, what
        are the values of a and b before the initializations are run, is this a
        compile error, or is this
        a runtime error? Additional confusion comes from it not being obvious if
        an initializer is
        static or dynamic.

        <p>D makes this simple. All member initializations must be determinable by
        the compiler at
        compile time, hence there is no order-of-evaluation dependency for
        member
        initializations, and it is not possible to read a value that has not
        been initialized. Dynamic
        initialization is performed by a static constructor, defined with
        a special syntax <span class="notranslate"><span class="d_inlinecode donthyphenate">static this()</span></span>.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> a;         <span class="d_comment">// default initialized to 0
</span>  <span class="d_keyword">static</span> <span class="d_keyword">int</span> b = 1;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> c = b + a; <span class="d_comment">// error, not a constant initializer
</span>
  <b><i><span class="d_keyword">static</span> <span class="d_keyword">this</span></i></b>()    <span class="d_comment">// static constructor
</span>  {
    a = b + 1;          <span class="d_comment">// a is set to 2
</span>    b = a * 2;          <span class="d_comment">// b is set to 4
</span>  }
}
</span></pre>

	<p>
		If <span class="notranslate"><span class="d_inlinecode donthyphenate">main()</span></span> or the thread returns normally,
        (does not throw an exception), the static destructor is added
        to the list of functions to be
        called on thread termination.

        Static constructors have empty parameter lists.
        </p>

	<p>        Static constructors within a module are executed in the lexical
        order in which they appear.
        All the static constructors for modules that are directly or
        indirectly imported
        are executed before the static constructors for the importer.
        </p>

	<p>        The <span class="notranslate"><span class="d_inlinecode donthyphenate">static</span></span> in the static constructor declaration is not
        an attribute, it must appear immediately before the <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span>:
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">static</span> <span class="d_keyword">this</span>() { ... } <span class="d_comment">// a static constructor
</span>  <span class="d_keyword">static</span> <span class="d_keyword">private</span> <span class="d_keyword">this</span>() { ... } <span class="d_comment">// not a static constructor
</span>  <span class="d_keyword">static</span> {
    <span class="d_keyword">this</span>() { ... }      <span class="d_comment">// not a static constructor
</span>  }
  <span class="d_keyword">static</span>:
    <span class="d_keyword">this</span>() { ... }      <span class="d_comment">// not a static constructor
</span>}
</span></pre>

<h3>Static Destructors</h3>

<pre class="bnf"><span class="notranslate"><a name="StaticDestructor"><i>StaticDestructor</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">static ~ this ( )</span></span> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">static ~ this ( )</span></span> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

        A static destructor is defined as a special static function with the
        syntax <span class="notranslate"><span class="d_inlinecode donthyphenate">static ~this()</span></span>.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">static</span> ~<span class="d_keyword">this</span>() <span class="d_comment">// static destructor
</span>  {
  }
}
</span></pre>

	<p>        A static destructor gets called on thread termination,
	but only if the static constructor
        completed successfully.
        Static destructors have empty parameter lists.
        Static destructors get called in the reverse order that the static
        constructors were called in.
        </p>

	<p>        The <span class="notranslate"><span class="d_inlinecode donthyphenate">static</span></span> in the static destructor declaration is not
        an attribute, it must appear immediately before the <span class="notranslate"><span class="d_inlinecode donthyphenate">~this</span></span>:
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">static</span> ~<span class="d_keyword">this</span>() { ... }  <span class="d_comment">// a static destructor
</span>  <span class="d_keyword">static</span> <span class="d_keyword">private</span> ~<span class="d_keyword">this</span>() { ... } <span class="d_comment">// not a static destructor
</span>  <span class="d_keyword">static</span>
  {
    ~<span class="d_keyword">this</span>() { ... }  <span class="d_comment">// not a static destructor
</span>  }
  <span class="d_keyword">static</span>:
    ~<span class="d_keyword">this</span>() { ... }  <span class="d_comment">// not a static destructor
</span>}
</span></pre>

<h3>Shared Static Constructors</h3>

<pre class="bnf"><span class="notranslate"><a name="SharedStaticConstructor"><i>SharedStaticConstructor</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">shared static this ( )</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">shared static this ( )</span></span> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

        <p>Shared static constructors are executed before any <a href="#StaticConstructor"><i>StaticConstructor</i></a>s,
        and are intended for initializing any shared global data.
        </p>

<h3>Shared Static Destructors</h3>

<pre class="bnf"><span class="notranslate"><a name="SharedStaticDestructor"><i>SharedStaticDestructor</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">shared static ~ this ( )</span></span> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">shared static ~ this ( )</span></span> <a href="declaration.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

        <p>Shared static destructors are executed at program termination
        in the reverse order that
        <a href="#SharedStaticConstructor"><i>SharedStaticConstructor</i></a>s were executed.
        </p>


<h3><a name="invariants">Class Invariants</a></h3>

<pre class="bnf"><span class="notranslate"><a name="Invariant"><i>Invariant</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">invariant ( )</span></span> <a href="statement.html#BlockStatement"><i>BlockStatement</i></a>
</span></pre>

    Class invariants are used to specify characteristics of a class that always
    must be true (except while executing a member function).
    They are described in <a href="contracts.html#Invariants"><i>Invariants</i></a>.

<h3><a name="allocators">Class Allocators</a></h3>
<b>Note</b>: Class allocators are deprecated in D2.
<pre class="bnf"><span class="notranslate"><a name="Allocator"><i>Allocator</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> <a href="declaration.html#Parameters"><i>Parameters</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> <a href="declaration.html#Parameters"><i>Parameters</i></a> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

        A class member function of the form:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">new</span>(<span class="d_keyword">uint</span> size) {
  ...
}
</span></pre>

        is called a class allocator.
        The class allocator can have any number of parameters, provided
        the first one is of type uint.
        Any number can be defined for a class, the correct one is
        determined by the usual function overloading rules.
        When a new expression:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">new</span> Foo;
</span></pre>

        is executed, and Foo is a class that has
        an allocator, the allocator is called with the first argument
        set to the size in bytes of the memory to be allocated for the
        instance.
        The allocator must allocate the memory and return it as a
        <span class="notranslate"><span class="d_inlinecode donthyphenate">void*</span></span>.
        If the allocator fails, it must not return a <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>, but
        must throw an exception.
        If there is more than one parameter to the allocator, the
        additional arguments are specified within parentheses after
        the <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> in the <i>NewExpression</i>:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">this</span>(<span class="d_keyword">char</span>[] a) { ... }

  <span class="d_keyword">new</span>(<span class="d_keyword">uint</span> size, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) {
    ...
  }
}

...

<span class="d_keyword">new</span>(1,2) Foo(a);        <span class="d_comment">// calls new(Foo.sizeof,1,2)
</span></span></pre>

        <p>Derived classes inherit any allocator from their base class,
        if one is not specified.
        </p>

        <p>The class allocator is not called if the instance is created
        on the stack.
        </p>

        <p>See also
        <a href="memory.html#newdelete">Explicit Class Instance Allocation</a>.
        </p>

<h3><a name="deallocators">Class Deallocators</a></h3>
<b>Note</b>: Class deallocators and the delete operator are deprecated in D2.
Use the <span class="notranslate"><span class="d_inlinecode donthyphenate">destroy</span></span> function to finalize an object by calling its destructor.
The memory of the object is <b>not</b> immediately deallocated, instead the GC
will collect the memory of the object at an undetermined point after finalization:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo { <span class="d_keyword">int</span> x; <span class="d_keyword">this</span>() { x = 1; } }
Foo foo = <span class="d_keyword">new</span> Foo;
destroy(foo);
<span class="d_keyword">assert</span>(foo.x == <span class="d_keyword">int</span>.init);  <span class="d_comment">// object is still accessible
</span></span></pre>

<pre class="bnf"><span class="notranslate"><a name="Deallocator"><i>Deallocator</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">delete</span></span> <a href="declaration.html#Parameters"><i>Parameters</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">;</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">delete</span></span> <a href="declaration.html#Parameters"><i>Parameters</i></a> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

        A class member function of the form:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">delete</span>(<span class="d_keyword">void</span> *p) {
  ...
}
</span></pre>

        is called a class deallocator.
        The deallocator must have exactly one parameter of type <span class="notranslate"><span class="d_inlinecode donthyphenate">void*</span></span>.
        Only one can be specified for a class.
        When a delete expression:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">delete</span> f;
</span></pre>

        <p>is executed, and f is a reference to a class instance that has
        a deallocator, the deallocator is called with a pointer to the
        class instance after the destructor (if any) for the class is
        called. It is the responsibility of the deallocator to free
        the memory.
        </p>

        <p>Derived classes inherit any deallocator from their base class,
        if one is not specified.
        </p>

        <p>The class allocator is not called if the instance is created
        on the stack.
        </p>

        <p>See also
        <a href="memory.html#newdelete">Explicit Class Instance Allocation</a>.
        </p>

<h3><a name="AliasThis">Alias This</a></h3>

<pre class="bnf"><span class="notranslate"><a name="AliasThis"><i>AliasThis</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">alias</span></span> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">this ;</span></span>
</span></pre>

        <p>An <i>AliasThis</i> declaration names a member to subtype.
        The <i>Identifier</i> names that member.
        </p>

        <p>A class or struct can be implicitly converted to the <i>AliasThis</i>
        member.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> x;
  <span class="d_keyword">alias</span> x <span class="d_keyword">this</span>;
}

<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> i * 2; }

<span class="d_keyword">void</span> test() {
  S s;
  s.x = 7;
  <span class="d_keyword">int</span> i = -s;  <span class="d_comment">// i == -7
</span>  i = s + 8;   <span class="d_comment">// i == 15
</span>  i = s + s;   <span class="d_comment">// i == 14
</span>  i = 9 + s;   <span class="d_comment">// i == 16
</span>  i = foo(s);  <span class="d_comment">// implicit conversion to int
</span>}
</span></pre>

        <p>If the member is a class or struct, undefined lookups will
        be forwarded to the <i>AliasThis</i> member.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> Foo
{
  <span class="d_keyword">int</span> baz = 4;
  <span class="d_keyword">int</span> get() { <span class="d_keyword">return</span> 7; }
}

<span class="d_keyword">class</span> Bar
{
  Foo foo;
  <span class="d_keyword">alias</span> foo <span class="d_keyword">this</span>;
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">auto</span> bar = <span class="d_keyword">new</span> Bar;
  <span class="d_keyword">int</span> i = bar.baz; <span class="d_comment">// i == 4
</span>  i = bar.get(); <span class="d_comment">// i == 7
</span>}
</span></pre>

        <p>If the <i>Identifier</i> refers to a property member
        function with no parameters, conversions and undefined
        lookups are forwarded to the return value of the function.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S
{
  <span class="d_keyword">int</span> x;
  @property <span class="d_keyword">int</span> get() {
    <span class="d_keyword">return</span> x * 2;
  }
  <span class="d_keyword">alias</span> get <span class="d_keyword">this</span>;
}

<span class="d_keyword">void</span> test() {
  S s;
  s.x = 2;
  <span class="d_keyword">int</span> i = s; <span class="d_comment">// i == 4
</span>}
</span></pre>

        <p>Multiple <i>AliasThis</i> are allowed. For implicit conversions
        and forwarded lookups, all <i>AliasThis</i> declarations are attempted;
        if more than one <i>AliasThis</i> is eligible, the ambiguity is
        disallowed by raising an error.
        Note: Multiple <i>AliasThis</i> is currently unimplemented.
        </p>


<h3><a name="auto">Scope Classes</a></h3>

        A scope class is a class with the <span class="notranslate"><span class="d_inlinecode donthyphenate">scope</span></span> attribute, as in:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">scope</span> <span class="d_keyword">class</span> Foo { ... }
</span></pre>

        The scope characteristic is inherited, so if any classes derived
        from a scope class are also scope.

        <p>An scope class reference can only appear as a function local variable.
        It must be declared as being <span class="notranslate"><span class="d_inlinecode donthyphenate">scope</span></span>:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">scope</span> <span class="d_keyword">class</span> Foo { ... }

<span class="d_keyword">void</span> func() {
  Foo f;    <span class="d_comment">// error, reference to scope class must be scope
</span>  <span class="d_keyword">scope</span> Foo g = <span class="d_keyword">new</span> Foo(); <span class="d_comment">// correct
</span>}
</span></pre>

        When an scope class reference goes out of scope, the destructor
        (if any) for it is automatically called. This holds true even if
        the scope was exited via a thrown exception.

<h3><a name="final">Final Classes</a></h3>

        <p>Final classes cannot be subclassed:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">final</span> <span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }  <span class="d_comment">// error, class A is final
</span></span></pre>

<h2><a name="nested">Nested Classes</a></h2>

        A <i>nested class</i> is a class that is declared inside the scope
        of a function or another class.
        A nested class has access to the variables and other symbols
        of the classes and functions it is nested inside:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Outer {
  <span class="d_keyword">int</span> m;

  <span class="d_keyword">class</span> Inner {
    <span class="d_keyword">int</span> foo() {
      <span class="d_keyword">return</span> m;   <span class="d_comment">// Ok to access member of Outer
</span>    }
  }
}

<span class="d_keyword">void</span> func() {
  <span class="d_keyword">int</span> m;

  <span class="d_keyword">class</span> Inner {
    <span class="d_keyword">int</span> foo() {
      <span class="d_keyword">return</span> m; <span class="d_comment">// Ok to access local variable m of func()
</span>    }
  }
}
</span></pre>

        If a nested class has the <span class="notranslate"><span class="d_inlinecode donthyphenate">static</span></span> attribute, then it can
        not access variables of the enclosing scope that are local to the
        stack or need a <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span>:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Outer {
  <span class="d_keyword">int</span> m;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> n;

  <span class="d_keyword">static</span> <span class="d_keyword">class</span> Inner {
    <span class="d_keyword">int</span> foo() {
      <span class="d_keyword">return</span> m;   <span class="d_comment">// Error, Inner is static and m needs a this
</span>      <span class="d_keyword">return</span> n;   <span class="d_comment">// Ok, n is static
</span>    }
  }
}

<span class="d_keyword">void</span> func() {
  <span class="d_keyword">int</span> m;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> n;

  <span class="d_keyword">static</span> <span class="d_keyword">class</span> Inner {
    <span class="d_keyword">int</span> foo() {
      <span class="d_keyword">return</span> m;   <span class="d_comment">// Error, Inner is static and m is local to the stack
</span>      <span class="d_keyword">return</span> n;   <span class="d_comment">// Ok, n is static
</span>    }
  }
}
</span></pre>

        Non-static nested classes work by containing an extra hidden member
        (called the context pointer)
        that is the frame pointer of the enclosing function if it is nested
        inside a function, or the <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> of the enclosing class's instance
        if it is nested inside a class.

        <p>When a non-static nested class is instantiated, the context pointer
        is assigned before the class's constructor is called, therefore
        the constructor has full access to the enclosing variables.
        A non-static nested class can only be instantiated when the necessary
        context pointer information is available:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Outer {
  <span class="d_keyword">class</span> Inner { }

  <span class="d_keyword">static</span> <span class="d_keyword">class</span> SInner { }
}

<span class="d_keyword">void</span> func() {
  <span class="d_keyword">class</span> Nested { }

  Outer o = <span class="d_keyword">new</span> Outer;        <span class="d_comment">// Ok
</span>  Outer.Inner oi = <span class="d_keyword">new</span> Outer.Inner;   <span class="d_comment">// Error, no 'this' for Outer
</span>  Outer.SInner os = <span class="d_keyword">new</span> Outer.SInner; <span class="d_comment">// Ok
</span>
  Nested n = <span class="d_keyword">new</span> Nested;      <span class="d_comment">// Ok
</span>}
</span></pre>



        <p>A <i>this</i> can be supplied to the creation of an
        inner class instance by prefixing it to the <i>NewExpression</i>:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Outer {
  <span class="d_keyword">int</span> a;

  <span class="d_keyword">class</span> Inner {
    <span class="d_keyword">int</span> foo() {
      <span class="d_keyword">return</span> a;
    }
  }
}

<span class="d_keyword">int</span> bar() {
  Outer o = <span class="d_keyword">new</span> Outer;
  o.a = 3;
  Outer.Inner oi = <b><i>o</i></b>.<span class="d_keyword">new</span> Inner;
  <span class="d_keyword">return</span> oi.foo();    <span class="d_comment">// returns 3
</span>}
</span></pre>

        <p>Here <span class="notranslate"><span class="d_inlinecode donthyphenate">o</span></span> supplies the <i>this</i> to the outer class
        instance of <span class="notranslate"><span class="d_inlinecode donthyphenate">Outer</span></span>.
        </p>

        <p>The property <span class="notranslate"><span class="d_inlinecode donthyphenate">.outer</span></span> used in a nested class gives the
        <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> pointer to its enclosing class. If the enclosing
        context is not a class, the <span class="notranslate"><span class="d_inlinecode donthyphenate">.outer</span></span> will give the pointer
        to it as a <span class="notranslate"><span class="d_inlinecode donthyphenate">void*</span></span> type.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Outer {
  <span class="d_keyword">class</span> Inner {
    Outer foo() {
      <span class="d_keyword">return</span> <span class="d_keyword">this</span>.<b><i>outer</i></b>;
    }
  }

  <span class="d_keyword">void</span> bar() {
    Inner i = <span class="d_keyword">new</span> Inner;
    <span class="d_keyword">assert</span>(<span class="d_keyword">this</span> == i.foo());
  }
}

<span class="d_keyword">void</span> test() {
  Outer o = <span class="d_keyword">new</span> Outer;
  o.bar();
}
</span></pre>

<h3><a name="anonymous">Anonymous Nested Classes</a></h3>

        <p>An anonymous nested class is both defined and instantiated with
        a <i>NewAnonClassExpression</i>:
        </p>

<pre class="bnf"><span class="notranslate"><a name="NewAnonClassExpression"><i>NewAnonClassExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> <a href="expression.html#AllocatorArguments"><i>AllocatorArguments</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span> <i>ClassArguments</i><sub>opt</sub> <a href="#SuperClass"><i>SuperClass</i></a><sub>opt</sub> <a href="#Interfaces"><i>Interfaces</i></a><sub>opt</sub> <a href="struct.html#AggregateBody"><i>AggregateBody</i></a>

<a name="ClassArguments"><i>ClassArguments</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="expression.html#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
</span></pre>

        <p>which is equivalent to:
        </p>

<pre class="d_code"><span class="notranslate"><span class="notranslate"><span class="d_inlinecode donthyphenate"><span class="d_keyword">class</span></span></span> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <i>SuperClass</i> <i>Interfaces</i> <i>AggregateBody</i>

<span class="notranslate"><span class="d_inlinecode donthyphenate"><span class="d_keyword">new</span></span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span><i>ArgumentList</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span><i>ArgumentList</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>;
</span></pre>

        <p>where <i>Identifier</i> is the name generated for the anonymous
        nested class.
        </p>

<h3><a name="ConstClass">Const, Immutable and Shared Classes</a></h3>
    <p>If a <i>ClassDeclaration</i> has a <span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span>
        or <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span> storage class, then it is as if each member of the class
        was declared with that storage class.
        If a base class is const, immutable or shared, then all classes derived
        from it are also const, immutable or shared.
    </p>


  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div><!--/content-->



<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/Class" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2017 by Digital Mars &reg;, All Rights Reserved |
Page generated by <a href="ddoc.html">Ddoc</a> on (no date time)
</div>
</body>
</html>

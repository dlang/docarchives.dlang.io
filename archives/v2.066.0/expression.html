
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Expressions - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="js/codemirror-compressed.js"></script>
<script src="js/run-main-website.js" type="text/javascript"></script>
<script src="js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
    var links = document.getElementById("navigation").getElementsByTagName("a");
    for (var i = 0; i < links.length; i++)
    {
        var url = "/" + links[i].getAttribute("href");
        if (window.location.href.match(url + "\x24") == url)
        {
            var cls = links[i].getAttribute("class");
            links[i].setAttribute("class", cls ? cls + " active" : "active");
            break;
        }
    }
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
    <div id="search-box">
        <form method="get" action="http://google.com/search">
            <img src="images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="images/search-button.gif" />
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <div id="search-dropdown">
                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </div>
        </form>
    </div>
    <div id="header">
        <a id="d-language" href="/">
        <img id="logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png">
        D Programming Language</a>
    </div>
</div>

<!--Generated by Ddoc from expression.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D 2.066.0</a></h2>
<ul>    <li><a href="overview.html" title="D language overview">Overview</a></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>

<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://ddili.org/ders/d.en/index.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a>

    <div class="navblock">
<ul>    <li><a href="intro.html">Introduction</a></li>
    <li><a href="lex.html">Lexical</a></li>
    <li><a href="grammar.html">Grammar</a></li>
    <li><a href="module.html">Modules</a></li>
    <li><a href="declaration.html">Declarations</a></li>
    <li><a href="type.html">Types</a></li>
    <li><a href="property.html">Properties</a></li>
    <li><a href="attribute.html">Attributes</a></li>
    <li><a href="pragma.html">Pragmas</a></li>
    <li><a href="expression.html">Expressions</a></li>
    <li><a href="statement.html">Statements</a></li>
    <li><a href="arrays.html">Arrays</a></li>
    <li><a href="hash-map.html">Associative Arrays</a></li>
    <li><a href="struct.html">Structs &amp; Unions</a></li>
    <li><a href="class.html">Classes</a></li>
    <li><a href="interface.html">Interfaces</a></li>
    <li><a href="enum.html">Enums</a></li>
    <li><a href="const3.html">Const and Immutable</a></li>
    <li><a href="function.html">Functions</a></li>
    <li><a href="operatoroverloading.html">Operator Overloading</a></li>
    <li><a href="template.html">Templates</a></li>
    <li><a href="template-mixin.html">Template Mixins</a></li>
    <li><a href="contracts.html">Contracts</a></li>
    <li><a href="version.html">Conditional Compilation</a></li>
    <li><a href="traits.html">Traits</a></li>
    <li><a href="errors.html">Handling errors</a></li>
    <li><a href="unittest.html">Unit Tests</a></li>
    <li><a href="garbage.html">Garbage Collection</a></li>
    <li><a href="float.html">Floating Point</a></li>
    <li><a href="iasm.html">Inline Assembler</a></li>
    <li><a href="ddoc.html">Documentation Comments</a></li>
    <li><a href="interfaceToC.html">Interfacing To C</a></li>
    <li><a href="cpp_interface.html">Interfacing To C++</a></li>
    <li><a href="portability.html">Portability Guide</a></li>
    <li><a href="entity.html">Named Character Entities</a></li>
    <li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
    <li><a href="abi.html">Application Binary Interface</a></li>
    <li><a href="simd.html">Vector Extensions</a></li>
    </ul>
</div></li>
    <li><a href="phobos/index.html">Library Reference</a></li>
    <li><a href="library/index.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a></li>
</ul>
    </div>

<div class="navblock">
<h2><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></h2>
<ul></ul>
    </div>

<div class="navblock">
<h2>Community</h2>
<ul>    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
    
</ul>
    </div>
  
<div id="translate" class="tool">Translate this page:
    <div id="google_translate_element"></div><script type="text/javascript">
    function googleTranslateElementInit() {
      new google.translate.TranslateElement({
        pageLanguage: 'en',
        autoDisplay: false,
        layout: google.translate.TranslateElement.InlineLayout.SIMPLE
      }, 'google_translate_element');
    }
    </script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>
</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
    <!--span id="lastupdate">Last update (no date time)</span-->
    <span class="tip">
        <a href="https://github.com/D-Programming-Language/dlang.org/edit/master/expression.dd" class="button">Improve this page</a>
        <span>
            Quickly fork, edit online, and submit a pull request for this page.
            Requires a signed-in GitHub account. This works well for small changes.
            If you'd like to make larger changes you may want to consider using
            local clone.
        </span>
    </span>
    <span class="tip">
        <a href="http://wiki.dlang.org/DocComments/Expression" class="button">Page wiki</a>
        <span>
            View or edit the community-maintained wiki page associated with this page.
        </span>
    </span>
</div>
  <h1>Expressions</h1>
  
        <p>C and C++ programmers will find the D expressions very familiar,
        with a few interesting additions.
        </p>

        <p>Expressions are used to compute values with a resulting type.
        These values can then be assigned,
        tested, or ignored. Expressions can also have side effects.
        </p>

<h3><a name="order-of-evaluation">Order Of Evaluation</a></h3>

        <p>The following binary expressions are evaluated in strictly
        left-to-right order:</p>

        <p>        <a href="#OrExpression"><i>OrExpression</i></a>,
        <a href="#XorExpression"><i>XorExpression</i></a>,
        <a href="#AndExpression"><i>AndExpression</i></a>,
        <a href="#CmpExpression"><i>CmpExpression</i></a>,
        <a href="#ShiftExpression"><i>ShiftExpression</i></a>,
        <a href="#AddExpression"><i>AddExpression</i></a>,
        <a href="#CatExpression"><i>CatExpression</i></a>,
        <a href="#MulExpression"><i>MulExpression</i></a>,
        <a href="#PowExpression"><i>PowExpression</i></a>,

        <a href="#CommaExpression"><i>CommaExpression</i></a>,
        <a href="#OrOrExpression"><i>OrOrExpression</i></a>,
        <a href="#AndAndExpression"><i>AndAndExpression</i></a>
        </p>

        <p>The following binary expressions are evaluated in an
        implementation-defined order:</p>

        <p>        <a href="#AssignExpression"><i>AssignExpression</i></a>,

        function arguments
        </p>

        <p>It is an error
        to depend on order of evaluation when it is not specified.
        For example, the following are illegal:
        </p>
<pre class="d_code"><span class="notranslate">i = i++;
</span></pre>
        <p>If the compiler can determine that the result of an expression
        is illegally dependent on the order of evaluation, it can issue
        an error (but is not required to). The ability to detect these kinds
        of errors is a quality of implementation issue.
        </p>

        <p>The evaluation order of function arguments is defined to be left to
        right. This is similar to Java but different to C/C++ where the evaluation
        order is unspecified. Thus, the following code is valid and well defined.
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.conv;
<span class="d_keyword">int</span> i = 0;
<span class="d_keyword">assert</span>(text(++i, ++i) == <span class="d_string">"12"</span>); <span class="d_comment">// left to right evaluation of arguments
</span></span></pre>

        <p>But even though the order of evaluation is well defined writing code that
        depends on it is rarely recommended.
        <b>Note that dmd currently does not comply with left to right evaluation of
        function arguments.</b></p>

<h3><a name="Expression">Expressions</a></h3>

<pre class="bnf"><span class="notranslate"><a name="Expression"><i>Expression</i></a>:
    <i>CommaExpression</i>

<a name="CommaExpression"><i>CommaExpression</i></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <i>CommaExpression</i>
</span></pre>

        The left operand of the <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> is evaluated, then the right operand
        is evaluated. The type of the expression is the type of the right
        operand, and the result is the result of the right operand.


<h3>Assign Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="AssignExpression"><i>AssignExpression</i></a>:
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">+=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">-=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">*=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">/=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">%=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">|=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">^=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">~=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;&gt;=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;&gt;&gt;=</span></span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">^^=</span></span> <i>AssignExpression</i>
</span></pre>

        <p>The right operand is implicitly converted to the type of the
        left operand, and assigned to it. The result type is the type
        of the lvalue, and the result value is the value of the lvalue
        after the assignment.</p>

        The left operand must be an lvalue.

<h4>Assignment Operator Expressions</h4>

        Assignment operator expressions, such as:

<pre class="d_code"><span class="notranslate">a op= b
</span></pre>

        are semantically equivalent to:

<pre class="d_code"><span class="notranslate">a = <span class="d_keyword">cast</span>(<span class="d_keyword">typeof</span>(a))(a op b)
</span></pre>

        <p>except that:</p>

        <ul>        <li>operand <span class="notranslate"><span class="d_inlinecode donthyphenate">a</span></span> is only evaluated once</li>
        <li>overloading <i>op</i> uses a different function than overloading <i>op</i>= does</li>
        <li>the left operand of <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;&gt;&gt;=</span></span> does not undergo integral promotions before shifting</li>
        </ul>

<h3>Conditional Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="ConditionalExpression"><i>ConditionalExpression</i></a>:
    <a href="#OrOrExpression"><i>OrOrExpression</i></a>
    <a href="#OrOrExpression"><i>OrOrExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">?</span></span> <a href="#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <i>ConditionalExpression</i>
</span></pre>

        The first expression is converted to bool, and is evaluated.
        If it is true, then the second expression is evaluated, and
        its result is the result of the conditional expression.
        If it is false, then the third expression is evaluated, and
        its result is the result of the conditional expression.
        If either the second or third expressions are of type void,
        then the resulting type is void. Otherwise, the second and third
        expressions are implicitly converted to a common type which becomes
        the result type of the conditional expression.

<h3>OrOr Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="OrOrExpression"><i>OrOrExpression</i></a>:
    <a href="#AndAndExpression"><i>AndAndExpression</i></a>
    <i>OrOrExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">||</span></span> <a href="#AndAndExpression"><i>AndAndExpression</i></a>
</span></pre>

        <p>The result type of an <i>OrOrExpression</i> is bool,
        unless the right operand
        has type void, when the result is type void.</p>

        <p>The <i>OrOrExpression</i> evaluates its left operand.

        If the left operand, converted to type bool, evaluates to
        true, then the right operand is not evaluated. If the result type of
        the <i>OrOrExpression</i> is bool then the result of the
        expression is true.

        If the left operand is false, then the right
        operand is evaluated.
        If the result type of
        the <i>OrOrExpression</i> is bool then the result of the
        expression is the right operand converted to type bool.</p>

<h3>AndAnd Expressions</h3>


<pre class="bnf"><span class="notranslate"><a name="AndAndExpression"><i>AndAndExpression</i></a>:
    <a href="#OrExpression"><i>OrExpression</i></a>
    <i>AndAndExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span> <a href="#OrExpression"><i>OrExpression</i></a>
    <a href="#CmpExpression"><i>CmpExpression</i></a>
    <i>AndAndExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span> <a href="#CmpExpression"><i>CmpExpression</i></a>
</span></pre>


        <p>The result type of an <i>AndAndExpression</i> is bool, unless the right operand
        has type void, when the result is type void.
        </p>

        <p>The <i>AndAndExpression</i> evaluates its left operand.
        </p>

        <p>If the left operand, converted to type bool, evaluates to
        false, then the right operand is not evaluated. If the result type of
        the <i>AndAndExpression</i> is bool then the result of the
        expression is false.
        </p>

        <p>If the left operand is true, then the right
        operand is evaluated.
        If the result type of
        the <i>AndAndExpression</i> is bool then the result of the
        expression is the right operand converted to type bool.
        </p>


<h3>Bitwise Expressions</h3>

        Bit wise expressions perform a bitwise operation on their operands.
        Their operands must be integral types.
        First, the default integral promotions are done. Then, the bitwise
        operation is done.

<h4>Or Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="OrExpression"><i>OrExpression</i></a>:
    <a href="#XorExpression"><i>XorExpression</i></a>
    <i>OrExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">|</span></span> <a href="#XorExpression"><i>XorExpression</i></a>
</span></pre>

        The operands are OR'd together.

<h4>Xor Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="XorExpression"><i>XorExpression</i></a>:
    <a href="#AndExpression"><i>AndExpression</i></a>
    <i>XorExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">^</span></span> <a href="#AndExpression"><i>AndExpression</i></a>
</span></pre>

        The operands are XOR'd together.

<h4>And Expressions</h4>


<pre class="bnf"><span class="notranslate"><a name="AndExpression"><i>AndExpression</i></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <i>AndExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</span></pre>

        The operands are AND'd together.


<h3>Compare Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="CmpExpression"><i>CmpExpression</i></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#EqualExpression"><i>EqualExpression</i></a>
    <a href="#IdentityExpression"><i>IdentityExpression</i></a>
    <a href="#RelExpression"><i>RelExpression</i></a>
    <a href="#InExpression"><i>InExpression</i></a>
</span></pre>

<h3>Equality Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="EqualExpression"><i>EqualExpression</i></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!=</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</span></pre>

        <p>Equality expressions compare the two operands for equality (<span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span>)
        or inequality (<span class="notranslate"><span class="d_inlinecode donthyphenate">!=</span></span>).
        The type of the result is bool. The operands
        go through the usual conversions to bring them to a common type before
        comparison.</p>

        <p>If they are integral values or pointers, equality
        is defined as the bit pattern of the type matches exactly.
        Equality for struct objects means the bit patterns of the objects
        match exactly (the existence of alignment holes in the objects
        is accounted for, usually by setting them all to 0 upon
        initialization).
        Equality for floating point types is more complicated. -0 and
        +0 compare as equal. If either or both operands are NAN, then
        both the == returns false and != returns true. Otherwise, the bit
        patterns are compared for equality.</p>

        <p>For complex numbers, equality is defined as equivalent to:</p>

<pre class="d_code"><span class="notranslate">x.re == y.re &amp;&amp; x.im == y.im
</span></pre>

        and inequality is defined as equivalent to:

<pre class="d_code"><span class="notranslate">x.re != y.re || x.im != y.im
</span></pre>

        <p>For class and struct objects, the expression <span class="notranslate"><span class="d_inlinecode donthyphenate">(a == b)</span></span>
        is rewritten as
        <span class="notranslate"><span class="d_inlinecode donthyphenate">a.opEquals(b)</span></span>, and <span class="notranslate"><span class="d_inlinecode donthyphenate">(a != b)</span></span> is rewritten as
        <span class="notranslate"><span class="d_inlinecode donthyphenate">!a.opEquals(b)</span></span>.
        </p>

        <p>For class objects, the <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">!=</span></span>
        operators compare the
        contents of the objects. Therefore, comparing against
        <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span> is invalid, as <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span> has no contents.
        Use the <span class="notranslate"><span class="d_inlinecode donthyphenate">is</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">!is</span></span> operators instead.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C;
C c;
<span class="d_keyword">if</span> (c == <span class="d_keyword">null</span>)  <span class="d_comment">// error
</span>  ...
<span class="d_keyword">if</span> (c <span class="d_keyword">is</span> <span class="d_keyword">null</span>)  <span class="d_comment">// ok
</span>  ...
</span></pre>

        <p>For static and dynamic arrays, equality is defined as the
        lengths of the arrays
        matching, and all the elements are equal.
        </p>

<h4>Identity Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="IdentityExpression"><i>IdentityExpression</i></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">is</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!is</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</span></pre>

        <p>The <span class="notranslate"><span class="d_inlinecode donthyphenate">is</span></span> compares for identity.
        To compare for not identity, use <span class="notranslate"><span class="d_inlinecode donthyphenate">e1 !is e2</span></span>.
        The type of the result is bool. The operands
        go through the usual conversions to bring them to a common type before
        comparison.
        </p>

        <p>For class objects, identity is defined as the object references
        are for the same object. Null class objects can be compared with
        <span class="notranslate"><span class="d_inlinecode donthyphenate">is</span></span>.
        </p>

        <p>For struct objects, identity is defined as the bits in the
        struct being identical.
        </p>

        <p>For static and dynamic arrays, identity is defined as referring
        to the same array elements and the same number of elements.
        </p>

        <p>For other operand types, identity is defined as being the same
        as equality.
        </p>

        <p>The identity operator <span class="notranslate"><span class="d_inlinecode donthyphenate">is</span></span> cannot be overloaded.
        </p>

<h3>Relational Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="RelExpression"><i>RelExpression</i></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;=</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!&lt;&gt;=</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!&lt;&gt;</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;&gt;</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;&gt;=</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!&gt;</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!&gt;=</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!&lt;</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!&lt;=</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</span></pre>

        <p>First, the integral promotions are done on the operands.
        The result type of a relational expression is bool.</p>

        <p>For class objects, the result of Object.opCmp() forms the left
        operand, and 0 forms the right operand. The result of the
        relational expression (o1 op o2) is:</p>

<pre class="d_code"><span class="notranslate">(o1.opCmp(o2) op 0)
</span></pre>

        <p>It is an error to compare objects if one is <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>.</p>

        <p>For static and dynamic arrays, the result of the relational
        op is the result of the operator applied to the first non-equal
        element of the array. If two arrays compare equal, but are of
        different lengths, the shorter array compares as "less" than the
        longer array.</p>

<h4>Integer comparisons</h4>

        <p>Integer comparisons happen when both operands are integral
        types.
        </p>

        <center><table border=1 cellpadding=4 cellspacing=0><caption>Integer comparison operators</caption>        <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Relation</b></th></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span></td><td>less</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span></td><td>greater</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td>less or equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;=</span></span></td><td>greater or equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span></td><td>equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!=</span></span></td><td>not equal</td></tr>
        </table></center>

        <p>It is an error to have one operand be signed and the other
        unsigned for a <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> or
        <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> expression.
        Use casts to make both operands signed or both operands unsigned.
        </p>

<h4><a name="floating_point_comparisons">Floating point comparisons</a></h4>

        <p>If one or both operands are floating point, then a floating
        point comparison is performed.</p>

        <p>Useful floating point operations must take into account NAN values.
        In particular, a relational operator can have NAN operands.
        The result of a relational operation on float
        values is less, greater, equal, or unordered (unordered means
        either or both of the
        operands is a NAN). That means there are 14 possible comparison
        conditions to test for:</p>

        <center><table border=1 cellpadding=4 cellspacing=0><caption>Floating point comparison operators</caption>        <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Greater</b></th><th class="donthyphenate"><b>Less</b></th><th class="donthyphenate"><b>Equal</b></th><th class="donthyphenate"><b>Unordered</b></th><th class="donthyphenate"><b>Exception</b></th><th class="donthyphenate"><b>Relation</b></th></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>unordered, less, or greater</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">yes</span></span></td><td>greater</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">yes</span></span></td><td>greater or equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">yes</span></span></td><td>less</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">yes</span></span></td><td>less or equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>unordered</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">yes</span></span></td><td>less or greater</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">yes</span></span></td><td>less, equal, or greater</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!&lt;=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>unordered or greater</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!&lt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>unordered, greater, or equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!&gt;=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>unordered or less</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!&gt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>unordered, less, or equal</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">!&lt;&gt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">F</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">T</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">no</span></span></td><td>unordered or equal</td></tr>
        </table></center>

        <h5>Notes:</h5>

        <ol>        <li>For floating point comparison operators,
         <span class="notranslate"><span class="d_inlinecode donthyphenate">(a !op b)</span></span>
         is not the same as <span class="notranslate"><span class="d_inlinecode donthyphenate">!(a op b)</span></span>.</li>
        <li>"Unordered" means one or both of the operands is a NAN.</li>
        <li>"Exception" means the <i>Invalid Exception</i> is raised if one
                of the operands is a NAN. It does not mean an exception
                is thrown. The <i>Invalid Exception</i> can be checked
                using the functions in <a href="phobos/std_c_fenv.html">std.c.fenv</a>.
        </li>
        </ol>

<h4><a name="class_comparisons">Class comparisons</a></h4>

        <p>For class objects, the relational
        operators compare the
        contents of the objects. Therefore, comparing against
        <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span> is invalid, as <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span> has no contents.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C;
C c;
<span class="d_keyword">if</span> (c &lt; <span class="d_keyword">null</span>)  <span class="d_comment">// error
</span>  ...
</span></pre>

<h3>In Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="InExpression"><i>InExpression</i></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">in</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">!in</span></span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</span></pre>

        <p>An associative array can be tested to see if an element is in the array:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo[<span class="d_keyword">char</span>[]];
...
<span class="d_keyword">if</span> (<span class="d_string">"hello"</span> <span class="d_keyword">in</span> foo)
    ...
</span></pre>

        <p>The <span class="notranslate"><span class="d_inlinecode donthyphenate">in</span></span> expression has the same precedence as the
        relational expressions <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span>,
        etc.
        The return value of the <i>InExpression</i> is <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>
        if the element is not in the array;
        if it is in the array it is a pointer to the element.
        </p>

        <p>The <span class="notranslate"><span class="d_inlinecode donthyphenate">!in</span></span> expression is the logical negation of the <span class="notranslate"><span class="d_inlinecode donthyphenate">in</span></span>
        operation.
        </p>

<h3>Shift Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="ShiftExpression"><i>ShiftExpression</i></a>:
    <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span> <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> <a href="#AddExpression"><i>AddExpression</i></a>
</span></pre>

        <p>The operands must be integral types, and undergo the usual integral
        promotions. The result type is the type of the left operand after
        the promotions. The result value is the result of shifting the bits
        by the right operand's value.
        </p>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span> is a left shift.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> is a signed right shift.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> is an unsigned right shift.
        </p>

        <p>It's illegal to shift by the same or more bits than the size of the
        quantity being shifted:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> c;
c &lt;&lt; 33;        <span class="d_comment">// error
</span></span></pre>

<h3>Add Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="AddExpression"><i>AddExpression</i></a>:
    <a href="#MulExpression"><i>MulExpression</i></a>
    <i>AddExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span> <a href="#MulExpression"><i>MulExpression</i></a>
    <i>AddExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span> <a href="#MulExpression"><i>MulExpression</i></a>
    <a href="#CatExpression"><i>CatExpression</i></a>
</span></pre>

        <p>If the operands are of integral types, they undergo integral
        promotions, and then are brought to a common type using the
        usual arithmetic conversions.
        </p>

        <p>If either operand is a floating point type, the other is implicitly
        converted to floating point and they are brought to a common type
        via the usual arithmetic conversions.
        </p>

        <p>If the operator is <span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span>, and
        the first operand is a pointer, and the second is an integral type,
        the resulting type is the type of the first operand, and the resulting
        value is the pointer plus (or minus) the second operand multiplied by
        the size of the type pointed to by the first operand.
        </p>

        <p>If the second operand is a pointer, and the first is an integral type,
        and the operator is <span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span>,
        the operands are reversed and the pointer arithmetic just described
        is applied.
        </p>

        <p>If both operands are pointers, and the operator is <span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span>,
        then it is illegal. For <span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span>, the pointers are subtracted and the
        result is divided by the size of the type pointed to by the
        operands. It is an error if the pointers point to different types.
        </p>

        <p>If both operands are of integral types and an overflow or underflow
        occurs in the computation, wrapping will happen. That is,
        <span class="notranslate"><span class="d_inlinecode donthyphenate">uint.max + 1 == uint.min</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">uint.min - 1 == uint.max</span></span>.
        </p>

        <p>Add expressions for floating point operands are not associative.
        </p>

<h3>Cat Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="CatExpression"><i>CatExpression</i></a>:
    <a href="#AddExpression"><i>AddExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">~</span></span> <a href="#MulExpression"><i>MulExpression</i></a>
</span></pre>

        <p>A <i>CatExpression</i> concatenates arrays, producing
        a dynmaic array with the result. The arrays must be
        arrays of the same element type. If one operand is an array
        and the other is of that array's element type, that element
        is converted to an array of length 1 of that element,
        and then the concatenation is performed.
        </p>

<h3>Mul Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="MulExpression"><i>MulExpression</i></a>:
    <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">/</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">%</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</span></pre>

        <p>The operands must be arithmetic types. They undergo integral
        promotions, and then are brought to a common type using the
        usual arithmetic conversions.
        </p>

        <p>For integral operands, the <span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">/</span></span>, and <span class="notranslate"><span class="d_inlinecode donthyphenate">%</span></span>
        correspond to multiply, divide, and modulus operations.
        For multiply, overflows are ignored and simply chopped to fit
        into the integral type.
        </p>

        <p>For integral operands of the <span class="notranslate"><span class="d_inlinecode donthyphenate">/</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">%</span></span> operators,
        the quotient rounds towards zero and the remainder has the
        same sign as the dividend.
        If the divisor is zero, an Exception is thrown.
        </p>

        <p>For floating point operands, the * and / operations correspond
        to the IEEE 754 floating point equivalents. % is not the same as
        the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas
        for IEEE 754, remainder(15.0,10.0) == -5.0.
        </p>

        <p>Mul expressions for floating point operands are not associative.
        </p>

<h3><a name="UnaryExpression">Unary Expressions</a></h3>

<pre class="bnf"><span class="notranslate"><a name="UnaryExpression"><i>UnaryExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span> <i>UnaryExpression</i>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span> <i>UnaryExpression</i>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span> <i>UnaryExpression</i>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span> <i>UnaryExpression</i>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span> <i>UnaryExpression</i>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span> <i>UnaryExpression</i>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">!</span></span> <i>UnaryExpression</i>
    <a href="#ComplementExpression"><i>ComplementExpression</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">) .</span></span> <a href="lex.html#Identifier"><i>Identifier</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">) .</span></span> <a href="template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <a href="#DeleteExpression"><i>DeleteExpression</i></a>
    <a href="#CastExpression"><i>CastExpression</i></a>
    <a href="#PowExpression"><i>PowExpression</i></a>
</span></pre>

<h4>Complement Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="ComplementExpression"><i>ComplementExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">~</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</span></pre>

        <p><i>ComplementExpression</i>s work on integral types (except bool).
        All the bits in the value are complemented.</p>

        <p>Note: unlike in C and C++, the usual integral promotions are not performed
        prior to the complement operation.
        </p>

<h4>New Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="NewExpression"><i>NewExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> <i>AllocatorArguments</i><sub>opt</sub> <a href="declaration.html#Type"><i>Type</i></a>
    <a href="#NewExpressionWithArgs"><i>NewExpressionWithArgs</i></a>

<a name="NewExpressionWithArgs"><i>NewExpressionWithArgs</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> <i>AllocatorArguments</i><sub>opt</sub> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> <i>AllocatorArguments</i><sub>opt</sub> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <a href="class.html#NewAnonClassExpression"><i>NewAnonClassExpression</i></a>

<a name="AllocatorArguments"><i>AllocatorArguments</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>

<a name="ArgumentList"><i>ArgumentList</i></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <i>ArgumentList</i>
</span></pre>

        <p><i>NewExpression</i>s are used to allocate memory on the garbage
        collected heap (default) or using a class or struct specific allocator.
        </p>

        <p>To allocate multidimensional arrays, the declaration reads
        in the same order as the prefix array declaration order.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">char</span>[][] foo;   <span class="d_comment">// dynamic array of strings
</span>...
foo = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[][30]; <span class="d_comment">// allocate array of 30 strings
</span></span></pre>

        <p>The above allocation can also be written as:</p>

<pre class="d_code"><span class="notranslate">foo = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[][](30); <span class="d_comment">// allocate array of 30 strings
</span></span></pre>

        <p>To allocate the nested arrays, multiple arguments can be used:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[][][] bar;
...
bar = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][][](5,20,30);
</span></pre>

        <p>Which is equivalent to:</p>

<pre class="d_code"><span class="notranslate">bar = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][][5];
<span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> a; bar)
{
  a = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][20];
  <span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> b; a)
  {
    b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[30];
  }
}
</span></pre>

        <p>If there is a <span class="notranslate"><span class="d_inlinecode donthyphenate">new (</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>,
        then
        those arguments are passed to the class or struct specific
        <a href="class.html#allocators">allocator function</a> after the size argument.
        </p>

        <p>If a <i>NewExpression</i> is used as an initializer for
        a function local variable with <span class="notranslate"><span class="d_inlinecode donthyphenate">scope</span></span> storage class,
        and the <a href="#ArgumentList"><i>ArgumentList</i></a> to <span class="notranslate"><span class="d_inlinecode donthyphenate">new</span></span> is empty, then
        the instance is allocated on the stack rather than the heap
        or using the class specific allocator.
        </p>

<h4>Delete Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="DeleteExpression"><i>DeleteExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">delete</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</span></pre>
        <p>If the <i>UnaryExpression</i> is a class object reference, and
        there is a destructor for that class, the destructor
        is called for that object instance.
        </p>

        <p>Next, if the <i>UnaryExpression</i> is a class object reference, or
        a pointer to a struct instance, and the class or struct
        has overloaded operator delete, then that operator delete is called
        for that class object instance or struct instance.
        </p>

        <p>Otherwise, the garbage collector is called to immediately free the
        memory allocated for the class instance or struct instance.
        If the garbage collector was not used to allocate the memory for
        the instance, undefined behavior will result.
        </p>

        <p>If the <i>UnaryExpression</i> is a pointer or a dynamic array,
        the garbage collector is called to immediately release the
        memory.
        If the garbage collector was not used to allocate the memory for
        the instance, undefined behavior will result.
        </p>

        <p>The pointer, dynamic array, or reference is set to <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span>
        after the delete is performed.
        Any attempt to reference the data after the deletion via another
        reference to it will result in undefined behavior.
        </p>

        <p>If <i>UnaryExpression</i> is a variable allocated
        on the stack, the class destructor (if any) is called for that
        instance. Neither the garbage collector nor any class deallocator
        is called.
        </p>

<h4>Cast Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="CastExpression"><i>CastExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">cast (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">cast (</span></span> <a href="declaration.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</span></pre>

        <p>A <i>CastExpression</i> converts the <i>UnaryExpression</i>
        to <a href="declaration.html#Type"><i>Type</i></a>.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">cast</span>(foo) -p; <span class="d_comment">// cast (-p) to type foo
</span>(foo) - p;      <span class="d_comment">// subtract p from foo
</span></span></pre>

        <p>Any casting of a class reference to a
        derived class reference is done with a runtime check to make sure it
        really is a downcast. <span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span> is the result if it isn't.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">Note:</span></span> This is equivalent to the behavior of the
        <span class="notranslate"><span class="d_inlinecode donthyphenate">dynamic_cast</span></span> operator in C++.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { ... }
<span class="d_keyword">class</span> B : A { ... }

<span class="d_keyword">void</span> test(A a, B b) {
  B bx = a;         <span class="d_comment">// error, need cast
</span>  B bx = <span class="d_keyword">cast</span>(B) a; <span class="d_comment">// bx is null if a is not a B
</span>  A ax = b;         <span class="d_comment">// no cast needed
</span>  A ax = <span class="d_keyword">cast</span>(A) b; <span class="d_comment">// no runtime check needed for upcast
</span>}
</span></pre>

        <p>In order to determine if an object <span class="notranslate"><span class="d_inlinecode donthyphenate">o</span></span> is an instance of
        a class <span class="notranslate"><span class="d_inlinecode donthyphenate">B</span></span> use a cast:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">if</span> (<span class="d_keyword">cast</span>(B) o)
{
  <span class="d_comment">// o is an instance of B
</span>}
<span class="d_keyword">else</span>
{
  <span class="d_comment">// o is not an instance of B
</span>}
</span></pre>

        <p>Casting a pointer type to and from a class type is done as a type paint
        (i.e. a reinterpret cast).</p>

        <p>Casting a dynamic array to another dynamic array is done only if the
        array lengths multiplied by the element sizes match. The cast is done
        as a type paint, with the array length adjusted to match any change in
        element size. If there's not a match, a runtime error is generated.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> main() {
  <span class="d_keyword">byte</span>[] a = [1,2,3];
  <span class="d_keyword">auto</span> b = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[])a; <span class="d_comment">// runtime array cast misalignment
</span>
  <span class="d_keyword">int</span>[] c = [1, 2, 3];
  <span class="d_keyword">auto</span> d = <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>[])c; <span class="d_comment">// ok
</span>  <span class="d_comment">// prints:
</span>  <span class="d_comment">// [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]
</span>  writeln(d);
  <span class="d_keyword">return</span> 0;
}
</span></pre>

        <p>Casting a floating point literal from one type to another
        changes its type, but internally it is retained at full
        precision for the purposes of constant folding.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test() {
  <span class="d_keyword">real</span> a = 3.40483L;
  <span class="d_keyword">real</span> b;
  b = 3.40483;     <span class="d_comment">// literal is not truncated to double precision
</span>  <span class="d_keyword">assert</span>(a == b);
  <span class="d_keyword">assert</span>(a == 3.40483);
  <span class="d_keyword">assert</span>(a == 3.40483L);
  <span class="d_keyword">assert</span>(a == 3.40483F);
  <span class="d_keyword">double</span> d = 3.40483; <span class="d_comment">// truncate literal when assigned to variable
</span>  <span class="d_keyword">assert</span>(d != a);     <span class="d_comment">// so it is no longer the same
</span>  <span class="d_keyword">const</span> <span class="d_keyword">double</span> x = 3.40483; <span class="d_comment">// assignment to const is not
</span>  <span class="d_keyword">assert</span>(x == a);     <span class="d_comment">// truncated if the initializer is visible
</span>}
</span></pre>

        <p>Casting a value <i>v</i> to a struct <i>S</i>, when value is not a struct
        of the same type, is equivalent to:
        </p>

<pre class="d_code"><span class="notranslate">S(v)
</span></pre>

        <p>Casting to a <a href="#CastQual"><i>CastQual</i></a> replaces the qualifiers to the type of
        the <a href="#UnaryExpression"><i>UnaryExpression</i></a>.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">shared</span> <span class="d_keyword">int</span> x;
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span>)x) == <span class="d_keyword">const</span> <span class="d_keyword">int</span>));
</span></pre>

        <p>Casting with no <a href="#Type"><i>Type</i></a> or <a href="#CastQual"><i>CastQual</i></a> removes
        any top level <span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">inout</span></span>
        type modifiers from the type
        of the <a href="#UnaryExpression"><i>UnaryExpression</i></a>.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">shared</span> <span class="d_keyword">int</span> x;
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(<span class="d_keyword">cast</span>()x) == <span class="d_keyword">int</span>));
</span></pre>

        <p>Casting an expression to <span class="notranslate"><span class="d_inlinecode donthyphenate">void</span></span> type is allowed to mark that
        the result is unused. On <a href="statement.html#ExpressionStatement"><i>ExpressionStatement</i></a>,
        it could be used properly to avoid "has no effect" error.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">lazy</span> <span class="d_keyword">void</span> exp) {}
<span class="d_keyword">void</span> main() {
  foo(10);              <span class="d_comment">// NG - has no effect in expression '10'
</span>  foo(<span class="d_keyword">cast</span>(<span class="d_keyword">void</span>)10);    <span class="d_comment">// OK
</span>}
</span></pre>

<h3>Pow Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="PowExpression"><i>PowExpression</i></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a>
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">^^</span></span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</span></pre>

        <p><i>PowExpression</i> raises its left operand to the power of its
        right operand.
        </p>



<h3>Postfix Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="PostfixExpression"><i>PostfixExpression</i></a>:
    <a href="#PrimaryExpression"><i>PrimaryExpression</i></a>
    <i>PostfixExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <a href="lex.html#Identifier"><i>Identifier</i></a>
    <i>PostfixExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <a href="template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <i>PostfixExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <a href="#NewExpression"><i>NewExpression</i></a>
    <i>PostfixExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span>
    <i>PostfixExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span>
    <i>PostfixExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <a href="declaration.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <a href="declaration.html#BasicType"><i>BasicType</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <a href="#IndexExpression"><i>IndexExpression</i></a>
    <a href="#SliceExpression"><i>SliceExpression</i></a>
</span></pre>

<h3>Index Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="IndexExpression"><i>IndexExpression</i></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span>
</span></pre>

        <p><i>PostfixExpression</i> is evaluated.

        If <i>PostfixExpression</i> is an expression of type
        static array or dynamic array, the symbol $ is
        set to be the the number of elements in the array.

        If <i>PostfixExpression</i> is an <i>ExpressionTuple</i>,
        the symbol $ is
        set to be the the number of elements in the tuple.

        A new declaration scope is created for the evaluation of the
        <a href="#ArgumentList"><i>ArgumentList</i></a> and $ appears in that scope only.
        </p>

        <p>If <i>PostfixExpression</i> is an <i>ExpressionTuple</i>,
        then the <a href="#ArgumentList"><i>ArgumentList</i></a> must consist of only one argument,
        and that must be statically evaluatable to an integral constant.
        That integral constant <i>n</i> then selects the <i>n</i>th
        expression in the <i>ExpressionTuple</i>, which is the result
        of the <i>IndexExpression</i>.
        It is an error if <i>n</i> is out of bounds of the <i>ExpressionTuple</i>.
        </p>

<h3>Slice Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="SliceExpression"><i>SliceExpression</i></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span>
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">..</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span>
</span></pre>

        <p><i>PostfixExpression</i> is evaluated.
        if <i>PostfixExpression</i> is an expression of type
        static array or dynamic array, the variable <span class="notranslate"><span class="d_inlinecode donthyphenate">length</span></span>
        (and the special variable $)
        is declared and set to be the length of the array.
        A new declaration scope is created for the evaluation of the
        <a href="#AssignExpression"><i>AssignExpression</i></a>..<a href="#AssignExpression"><i>AssignExpression</i></a>
        and <span class="notranslate"><span class="d_inlinecode donthyphenate">length</span></span> (and $) appears in that scope only.
        </p>

        <p>The first <i>AssignExpression</i> is taken to be the inclusive
        lower bound
        of the slice, and the second <i>AssignExpression</i> is the
        exclusive upper bound.
        The result of the expression is a slice of the <i>PostfixExpression</i>
        array.
        </p>

        <p>If the <span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span> form is used, the slice is of the entire
        array.
        </p>

        <p>The type of the slice is a dynamic array of the element
        type of the <i>PostfixExpression</i>.
        </p>

        <p>A <i>SliceExpression</i> is not a modifiable lvalue.</p>

        <p>If <i>PostfixExpression</i> is an <i>ExpressionTuple</i>, then
        the result of the slice is a new <i>ExpressionTuple</i> formed
        from the upper and lower bounds, which must statically evaluate
        to integral constants.
        It is an error if those
        bounds are out of range.
        </p>

<h3>Primary Expressions</h3>

<pre class="bnf"><span class="notranslate"><a name="PrimaryExpression"><i>PrimaryExpression</i></a>:
    <a href="lex.html#Identifier"><i>Identifier</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <a href="lex.html#Identifier"><i>Identifier</i></a>
    <a href="template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <a href="template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <a href="#this"><span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span></a>
    <a href="#super"><span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span></a>
    <a href="#null"><span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">true</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">false</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">$</span></span>
    <a href="lex.html#IntegerLiteral"><i>IntegerLiteral</i></a>
    <a href="lex.html#FloatLiteral"><i>FloatLiteral</i></a>
    <a href="#CharacterLiteral"><i>CharacterLiteral</i></a>
    <a href="#StringLiterals"><i>StringLiterals</i></a>
    <a href="#ArrayLiteral"><i>ArrayLiteral</i></a>
    <a href="#AssocArrayLiteral"><i>AssocArrayLiteral</i></a>
    <a href="#FunctionLiteral"><i>FunctionLiteral</i></a>
    <a href="#AssertExpression"><i>AssertExpression</i></a>
    <a href="#MixinExpression"><i>MixinExpression</i></a>
    <a href="#ImportExpression"><i>ImportExpression</i></a>
    <a href="#NewExpressionWithArgs"><i>NewExpressionWithArgs</i></a>
    <a href="declaration.html#BasicTypeX"><i>BasicTypeX</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">.</span></span> <a href="lex.html#Identifier"><i>Identifier</i></a>
    <a href="declaration.html#BasicTypeX"><i>BasicTypeX</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <a href="declaration.html#Typeof"><i>Typeof</i></a>
    <a href="#TypeidExpression"><i>TypeidExpression</i></a>
    <a href="#IsExpression"><i>IsExpression</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <a href="traits.html#TraitsExpression"><i>TraitsExpression</i></a>
    <a href="traits.html#SpecialKeyword"><i>SpecialKeyword</i></a>
</span></pre>

<h4>.Identifier</h4>

        <a href="lex.html#Identifier"><i>Identifier</i></a> is looked up at module scope, rather than the current
        lexically nested scope.

<h4><a name="this">this</a></h4>

        <p>Within a non-static member function, <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> resolves to
        a reference to the object for which the function was called.
        If the object is an instance of a struct, <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> will
        be a pointer to that instance.
        If a member function is called with an explicit reference
        to <span class="notranslate"><span class="d_inlinecode donthyphenate">typeof(this)</span></span>, a non-virtual call is made:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A {
  <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'A'; }

  <span class="d_keyword">char</span> foo() { <span class="d_keyword">return</span> <span class="d_keyword">typeof</span>(<span class="d_keyword">this</span>).get(); }
  <span class="d_keyword">char</span> bar() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>.get(); }
}

<span class="d_keyword">class</span> B : A {
  <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'B'; }
}

<span class="d_keyword">void</span> main() {
  B b = <span class="d_keyword">new</span> B();

  b.foo();  <span class="d_comment">// returns 'A'
</span>  b.bar();  <span class="d_comment">// returns 'B'
</span>}
</span></pre>

        <p>Assignment to <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span> is not allowed.</p>

<h4><a name="super">super</a></h4>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span> is identical to <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span>, except that it is
        cast to <span class="notranslate"><span class="d_inlinecode donthyphenate">this</span></span>'s base class.
        It is an error if there is no base class.
        It is an error to use <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span> within a struct member function.
        (Only class <span class="notranslate"><span class="d_inlinecode donthyphenate">Object</span></span> has no base class.)
        If a member function is called with an explicit reference
        to <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span>, a non-virtual call is made.
        </p>

        <p>Assignment to <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span> is not allowed.</p>

<h4><a name="null">null</a></h4>

        <p><span class="notranslate"><span class="d_inlinecode donthyphenate">null</span></span> represents the null value for
        pointers, pointers to functions, delegates,
        dynamic arrays, associative arrays,
        and class objects.
        If it has not already been cast to a type,
        it is given the type (void *) and it is an exact conversion
        to convert it to the null value for pointers, pointers to
        functions, delegates, etc.
        After it is cast to a type, such conversions are implicit,
        but no longer exact.
        </p>

<h4>true, false</h4>

        These are of type <span class="notranslate"><span class="d_inlinecode donthyphenate">bool</span></span> and when cast to another integral
        type become the values 1 and 0,
        respectively.

<h4><a name="CharacterLiteral">Character Literals</a></h4>

        Character literals are single characters and resolve to one
        of type <span class="notranslate"><span class="d_inlinecode donthyphenate">char</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">wchar</span></span>, or <span class="notranslate"><span class="d_inlinecode donthyphenate">dchar</span></span>.
        If the literal is a <span class="notranslate"><span class="d_inlinecode donthyphenate">\u</span></span> escape sequence, it resolves to type <span class="notranslate"><span class="d_inlinecode donthyphenate">wchar</span></span>.
        If the literal is a <span class="notranslate"><span class="d_inlinecode donthyphenate">\U</span></span> escape sequence, it resolves to type <span class="notranslate"><span class="d_inlinecode donthyphenate">dchar</span></span>.
        Otherwise, it resolves to the type with the smallest size it
        will fit into.

<h4>String Literals</h4>

<pre class="bnf"><span class="notranslate"><a name="StringLiterals"><i>StringLiterals</i></a>:
    <a href="lex.html#StringLiteral"><i>StringLiteral</i></a>
    <i>StringLiterals</i> <a href="lex.html#StringLiteral"><i>StringLiteral</i></a>
</span></pre>

        <p>String literals can implicitly convert to any
        of the following types, they have equal weight:
        </p>


        <table border=1 cellpadding=4 cellspacing=0>        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">immutable(char)*</span></span></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">immutable(wchar)*</span></span></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">immutable(dchar)*</span></span></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">immutable(char)[]</span></span></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">immutable(wchar)[]</span></span></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">immutable(dchar)[]</span></span></td></tr>
        </table>

        <p>String literals have a 0 appended to them, which makes
        them easy to pass to C or C++ functions expecting a <span class="notranslate"><span class="d_inlinecode donthyphenate">const char*</span></span>
        string.
        The 0 is not included in the <span class="notranslate"><span class="d_inlinecode donthyphenate">.length</span></span> property of the
        string literal.
        </p>

<h4>Array Literals</h4>

<pre class="bnf"><span class="notranslate"><a name="ArrayLiteral"><i>ArrayLiteral</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span>
</span></pre>

        <p>Array literals are a comma-separated list of <a href="#AssignExpression"><i>AssignExpression</i></a>s
        between square brackets [ and ].
        The <i>AssignExpression</i>s form the elements of a static array,
        the length of the array is the number of elements.
        The type of the first element is taken to be the type of
        all the elements, and all elements are implicitly converted
        to that type.
        If that type is a static array, it is converted to a dynamic
        array.
        </p>

<pre class="d_code"><span class="notranslate">[1,2,3];  <span class="d_comment">// type is int[3], with elements 1, 2 and 3
</span>[1u,2,3]; <span class="d_comment">// type is uint[3], with elements 1u, 2u, and 3u
</span></span></pre>

        <p>If any of the arguments in the <a href="#ArgumentList"><i>ArgumentList</i></a> are
        an <i>ExpressionTuple</i>, then the elements of the <i>ExpressionTuple</i>
        are inserted as arguments in place of the tuple.
        </p>

        <p>Array literals are allocated on the memory managed heap.
        Thus, they can be returned safely from functions:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] foo() {
  <span class="d_keyword">return</span> [1, 2, 3];
}
</span></pre>

        <p>When array literals are cast to another array type, each
        element of the array is cast to the new element type.
        When arrays that are not literals are cast, the array is
        reinterpreted as the new type, and the length is recomputed:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
  <span class="d_comment">// cast array literal
</span>  <span class="d_keyword">const</span> <span class="d_keyword">short</span>[] ct = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>[]) [<span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1, 1];
  writeln(ct);  <span class="d_comment">// writes [1, 1]
</span>
  <span class="d_comment">// cast other array expression
</span>  <span class="d_keyword">short</span>[] rt = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>[]) [<span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1, <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1].dup;
  writeln(rt);  <span class="d_comment">// writes [257]
</span>}
</span></pre>


<h4>Associative Array Literals</h4>

<pre class="bnf"><span class="notranslate"><a name="AssocArrayLiteral"><i>AssocArrayLiteral</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span> <a href="#KeyValuePairs"><i>KeyValuePairs</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span>

<a name="KeyValuePairs"><i>KeyValuePairs</i></a>:
    <a href="#KeyValuePair"><i>KeyValuePair</i></a>
    <a href="#KeyValuePair"><i>KeyValuePair</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <i>KeyValuePairs</i>

<a name="KeyValuePair"><i>KeyValuePair</i></a>:
    <a href="#KeyExpression"><i>KeyExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#ValueExpression"><i>ValueExpression</i></a>

<a name="KeyExpression"><i>KeyExpression</i></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>

<a name="ValueExpression"><i>ValueExpression</i></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
</span></pre>

        <p>Associative array literals are a comma-separated list of
        <i>key</i>:<i>value</i> pairs
        between square brackets [ and ].
        The list cannot be empty.
        The type of the first key is taken to be the type of
        all the keys, and all subsequent keys are implicitly converted
        to that type.
        The type of the first value is taken to be the type of
        all the values, and all subsequent values are implicitly converted
        to that type.
        An <i>AssocArrayLiteral</i> cannot be used to statically initialize
        anything.
        </p>

<pre class="d_code"><span class="notranslate">[21u:<span class="d_string">"he"</span>,38:<span class="d_string">"ho"</span>,2:<span class="d_string">"hi"</span>]; <span class="d_comment">// type is char[2][uint],
</span>                           <span class="d_comment">// with keys 21u, 38u and 2u
</span>                           <span class="d_comment">// and values "he", "ho", and "hi"
</span></span></pre>

        <p>If any of the keys or values in the <i>KeyValuePairs</i> are
        an <i>ExpressionTuple</i>, then the elements of the <i>ExpressionTuple</i>
        are inserted as arguments in place of the tuple.
        </p>


<h4>Function Literals</h4>

<pre class="bnf"><span class="notranslate"><a name="FunctionLiteral"><i>FunctionLiteral</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span> <a href="declaration.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterAttributes"><i>ParameterAttributes</i></a> <sub>opt</sub> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span> <a href="declaration.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterAttributes"><i>ParameterAttributes</i></a> <sub>opt</sub> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
    <a href="#ParameterAttributes"><i>ParameterAttributes</i></a> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
    <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
    <a href="#Lambda"><i>Lambda</i></a>

<a name="ParameterAttributes"><i>ParameterAttributes</i></a>:
    <a href="declaration.html#Parameters"><i>Parameters</i></a>
    <a href="declaration.html#Parameters"><i>Parameters</i></a> <a href="declaration.html#FunctionAttributes"><i>FunctionAttributes</i></a>
</span></pre>

        <p><i>FunctionLiteral</i>s enable embedding anonymous functions
        and anonymous delegates directly into expressions.
        <i>Type</i> is the return type of the function or delegate,
        if omitted it is inferred from any <i>ReturnStatement</i>s
        in the <i>FunctionBody</i>.
        <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
        forms the arguments to the function.
        If omitted it defaults to the empty argument list <span class="notranslate"><span class="d_inlinecode donthyphenate">( )</span></span>.
        The type of a function literal is pointer to function or
        pointer to delegate.
        If the keywords <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span> or <span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span> are omitted,
        it is inferred from whether <i>FunctionBody</i> is actually
        accessing to the outer context.</p>

        <p>For example:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp; <span class="d_comment">// declare pointer to a function
</span>
<span class="d_keyword">void</span> test() {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6; }

  fp = &amp;foo;
}
</span></pre>

        is exactly equivalent to:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp;

<span class="d_keyword">void</span> test() {
  fp = <span class="d_keyword">function</span> <span class="d_keyword">int</span>(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6;} ;
}
</span></pre>

        And:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> b = 3;
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; }

  abc(&amp;foo);
}
</span></pre>

        is exactly equivalent to:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> b = 3;

  abc( <span class="d_keyword">delegate</span> <span class="d_keyword">int</span>(<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; } );
}
</span></pre>

        <p>and the following where the return type <span class="notranslate"><span class="d_inlinecode donthyphenate">int</span></span> and
        <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span>/<span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span> are inferred:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));
<span class="d_keyword">int</span> def(<span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span> s));

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> b = 3;

  abc( (<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; } );  <span class="d_comment">// inferred to delegate
</span>  def( (<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> c * 2; } );  <span class="d_comment">// inferred to function
</span><span class="d_comment">//def( (int c) { return c * b; } );  // error!
</span>  <span class="d_comment">// Because the FunctionBody accesses b, then the function literal type
</span>  <span class="d_comment">// is inferred to delegate. But def cannot receive delegate.
</span>}
</span></pre>

        <p>If the type of a function literal can be uniquely determined from its context,
        the parameter type inference is possible.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span>) fp);

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span>) fp = (n) { <span class="d_keyword">return</span> n * 2; };
  <span class="d_comment">// The type of parameter n is inferred to int.
</span>
  foo((n) { <span class="d_keyword">return</span> n * 2; });
  <span class="d_comment">// The type of parameter n is inferred to int.
</span>}
</span></pre>

        <p>Anonymous delegates can behave like arbitrary statement literals.
        For example, here an arbitrary statement is executed by a loop:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">double</span> test() {
  <span class="d_keyword">double</span> d = 7.6;
  <span class="d_keyword">float</span> f = 2.3;

  <span class="d_keyword">void</span> loop(<span class="d_keyword">int</span> k, <span class="d_keyword">int</span> j, <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() statement) {
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = k; i &lt; j; i++) {
      statement();
    }
  }

  loop(5, 100, { d += 1; } );
  loop(3, 10,  { f += 3; } );

  <span class="d_keyword">return</span> d + f;
}
</span></pre>

        <p>When comparing with <a href="function.html#nested">nested functions</a>,
        the <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span> form is analogous to static
        or non-nested functions, and the <span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span> form is
        analogous to non-static nested functions. In other words,
        a delegate literal can access stack variables in its enclosing
        function, a function literal cannot.</p>


<h4>Lambdas</h4>

<pre class="bnf"><span class="notranslate"><a name="Lambda"><i>Lambda</i></a>:
    <a href="lex.html#Identifier"><i>Identifier</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">=&gt;</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span><sub>opt</sub> <a href="#ParameterAttributes"><i>ParameterAttributes</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">=&gt;</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span><sub>opt</sub> <a href="#ParameterAttributes"><i>ParameterAttributes</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">=&gt;</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a>
</span></pre>

        <p><i>Lambda</i>s are a shorthand syntax for <a href="#FunctionLiteral"><i>FunctionLiteral</i></a>s.</p>

    <ol>        <li><p>Just one <a href="lex.html#Identifier"><i>Identifier</i></a> is rewritten to
             <a href="declaration.html#Parameters"><i>Parameters</i></a>:</p>

             <span class="notranslate"><span class="d_inlinecode donthyphenate">(</span></span> <a href="lex.html#Identifier"><i>Identifier</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
        </li>
        <li><p>The following part <span class="notranslate"><span class="d_inlinecode donthyphenate">=&gt;</span></span> <i>AssignExpression</i> is rewritten to
             <a href="function.html#FunctionBody"><i>FunctionBody</i></a>:</p>

             <span class="notranslate"><span class="d_inlinecode donthyphenate">{ return</span></span> <i>AssignExpression</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">; }</span></span>
        </li>
    </ol>

        Example usage:
<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> i = 3;
    <span class="d_keyword">auto</span> twice  = <span class="d_keyword">function</span> (<span class="d_keyword">int</span> x) =&gt; x * 2;
    <span class="d_keyword">auto</span> square = <span class="d_keyword">delegate</span> (<span class="d_keyword">int</span> x) =&gt; x * x;

    <span class="d_keyword">auto</span> n = 5;
    <span class="d_keyword">auto</span> mul_n = (<span class="d_keyword">int</span> x) =&gt; x * n;

    writeln(twice(i));   <span class="d_comment">// prints 6
</span>    writeln(square(i));  <span class="d_comment">// prints 9
</span>    writeln(mul_n(i));   <span class="d_comment">// prints 15
</span>}
</span></pre>


<h4>Uniform construction syntax for built-in scalar types</h4>

    <p>The implicit conversions of built-in scalar types can be explicitly
        represented by using function call syntax. For example:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">auto</span> a = <span class="d_keyword">short</span>(1);  <span class="d_comment">// implicitly convert an integer literal '1' to short
</span><span class="d_keyword">auto</span> b = <span class="d_keyword">double</span>(a); <span class="d_comment">// implicitly convert a short variable 'a' to double
</span><span class="d_keyword">auto</span> c = <span class="d_keyword">byte</span>(128); <span class="d_comment">// error, 128 cannot be represented in a byte
</span></span></pre>
    </p>

    <p>If the argument is omitted, it means default construction of the
        scalar type:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">auto</span> a = <span class="d_keyword">ushort</span>();  <span class="d_comment">// same as: ushort.init
</span><span class="d_keyword">auto</span> b = <span class="d_keyword">wchar</span>();   <span class="d_comment">// same as: wchar.init
</span><span class="d_keyword">auto</span> c = <span class="d_keyword">creal</span>();   <span class="d_comment">// same as: creal.init
</span></span></pre>
    </p>


<h4>Assert Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="AssertExpression"><i>AssertExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">assert (</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">assert (</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
</span></pre>

        <p>Asserts evaluate the <i>AssignExpression</i>.
        If it evaluates to a non-null class reference, the class invariant is run.
        Otherwise, if it evaluates to a non-null pointer to a struct, the struct invariant is run.
        Otherwise, if the result is false,
        an <span class="notranslate"><span class="d_inlinecode donthyphenate">AssertError</span></span> is thrown. If the result is true, then no
        exception is thrown.
        It is an error if the <i>expression</i> contains any side effects
        that the program depends on. The compiler may optionally not
        evaluate assert expressions at all.
        The result type of an assert expression is <span class="notranslate"><span class="d_inlinecode donthyphenate">void</span></span>.
        Asserts are a fundamental part of the
        <a href="contracts.html">Contract Programming</a>
        support in D.
        </p>

        <p>The expression <span class="notranslate"><span class="d_inlinecode donthyphenate">assert(0)</span></span> is a special case; it
        signifies that it is unreachable code.
        Either <span class="notranslate"><span class="d_inlinecode donthyphenate">AssertError</span></span> is thrown at runtime if it is reachable,
        or the execution is halted
        (on the x86 processor, a <span class="notranslate"><span class="d_inlinecode donthyphenate">HLT</span></span> instruction can be used to halt
        execution).
        The optimization and code generation phases of compilation may
        assume that it is unreachable code.
        </p>

        <p>The second <i>AssignExpression</i>, if present, must be implicitly
        convertible to type <span class="notranslate"><span class="d_inlinecode donthyphenate">const(char)[]</span></span>.
        It is evaluated if the
        result is false, and the string result is appended to the
        <span class="notranslate"><span class="d_inlinecode donthyphenate">AssertError</span></span>'s message.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> main() {
  <span class="d_keyword">assert</span>(0, <span class="d_string">"an"</span> ~ <span class="d_string">" error message"</span>);
}
</span></pre>

        <p>When compiled and run, it will produce the message:</p>

<pre class="console"><span class="notranslate">Error: AssertError Failure test.d(3) an error message
</span></pre>


<h4>Mixin Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="MixinExpression"><i>MixinExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">mixin (</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
</span></pre>

        <p>The <i>AssignExpression</i> must evaluate at compile time
        to a constant string.
        The text contents of the string must be compilable as a valid
        <i>AssignExpression</i>, and is compiled as such.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) {
  <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(<span class="d_string">"x + 1"</span>) * 7;  <span class="d_comment">// same as ((x + 1) * 7)
</span>}
</span></pre>

<h4>Import Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="ImportExpression"><i>ImportExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">import (</span></span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
</span></pre>

        <p>The <i>AssignExpression</i> must evaluate at compile time
        to a constant string.
        The text contents of the string are interpreted as a file
        name. The file is read, and the exact contents of the file
        become a string literal.
        </p>

        <p>Implementations may restrict the file name in order to avoid
        directory traversal security vulnerabilities.
        A possible restriction might be to disallow any path components
        in the file name.
        </p>

        <p>Note that by default an import expression will not compile unless
            you pass one or more paths via the <b>-J</b> switch. This tells the compiler
            where it should look for the files to import. This is a security feature.
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo() {
  <span class="d_comment">// Prints contents of file foo.txt
</span>  writeln( <span class="d_keyword">import</span>(<span class="d_string">"foo.txt"</span>) );
}
</span></pre>

<h4>Typeid Expressions</h4>

<pre class="bnf"><span class="notranslate"><a name="TypeidExpression"><i>TypeidExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">typeid (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">typeid (</span></span> <a href="#Expression"><i>Expression</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
</span></pre>


        <p>If <i>Type</i>, returns an instance of class
        <a href="phobos/object.html"><span class="notranslate"><span class="d_inlinecode donthyphenate">TypeInfo</span></span></a>
        corresponding
        to <i>Type</i>.
        </p>

        <p>If <i>Expression</i>, returns an instance of class
        <a href="phobos/object.html"><span class="notranslate"><span class="d_inlinecode donthyphenate">TypeInfo</span></span></a>
        corresponding
        to the type of the <i>Expression</i>.
        If the type is a class, it returns the <span class="notranslate"><span class="d_inlinecode donthyphenate">TypeInfo</span></span>
        of the dynamic type (i.e. the most derived type).
        The <i>Expression</i> is always executed.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">void</span> main() {
  writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>));  <span class="d_comment">// int
</span>  <span class="d_keyword">uint</span> i;
  writeln(<span class="d_keyword">typeid</span>(i++));  <span class="d_comment">// uint
</span>  writeln(i);            <span class="d_comment">// 1
</span>  A a = <span class="d_keyword">new</span> B();
  writeln(<span class="d_keyword">typeid</span>(a));    <span class="d_comment">// B
</span>  writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(a)));  <span class="d_comment">// A
</span>}
</span></pre>


<h4>IsExpression</h4>

<pre class="bnf"><span class="notranslate"><a name="IsExpression"><i>IsExpression</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <a href="lex.html#Identifier"><i>Identifier</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <a href="lex.html#Identifier"><i>Identifier</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <a href="lex.html#Identifier"><i>Identifier</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <a href="lex.html#Identifier"><i>Identifier</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <a href="declaration.html#Type"><i>Type</i></a> <a href="lex.html#Identifier"><i>Identifier</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>


<a name="TypeSpecialization"><i>TypeSpecialization</i></a>:
    <a href="declaration.html#Type"><i>Type</i></a>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">struct</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">union</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">interface</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">enum</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">inout</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">return</span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate">__parameters</span></span>
</span></pre>

        <p><i>IsExpression</i>s are evaluated at compile time and are
        used for checking for valid types, comparing types for equivalence,
        determining if one type can be implicitly converted to another,
        and deducing the subtypes of a type.
        The result of an <i>IsExpression</i> is an int of type 0
        if the condition is not satisified, 1 if it is.</p>

        <p><i>Type</i> is the type being tested. It must be syntactically
        correct, but it need not be semantically correct.
        If it is not semantically correct, the condition is not satisfied.</p>

        <p><a href="lex.html#Identifier"><i>Identifier</i></a> is declared to be an alias of the resulting
        type if the condition is satisfied. The <a href="lex.html#Identifier"><i>Identifier</i></a> forms
        can only be used if the <i>IsExpression</i> appears in a
        <a href="version.html#StaticIfCondition"><i>StaticIfCondition</i></a>.</p>

        <p><i>TypeSpecialization</i> is the type that <i>Type</i> is being
        compared against.</p>

        <p>The forms of the <i>IsExpression</i> are:</p>

        <ol>
        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>
        The condition is satisfied if <span class="notranslate"><span class="d_inlinecode donthyphenate">Type</span></span> is semantically
        correct (it must be syntactically correct regardless).

<pre class="d_code"><span class="notranslate"><span class="d_keyword">alias</span> <span class="d_keyword">int</span> func(<span class="d_keyword">int</span>);    <span class="d_comment">// func is a alias to a function type
</span><span class="d_keyword">void</span> foo() {
  <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(func[]) ) <span class="d_comment">// not satisfied because arrays of
</span>                        <span class="d_comment">// functions are not allowed
</span>    writeln(<span class="d_string">"satisfied"</span>);
  <span class="d_keyword">else</span>
    writeln(<span class="d_string">"not satisfied"</span>);

  <span class="d_keyword">if</span> (<span class="d_keyword">is</span>([][]))  <span class="d_comment">// error, [][] is not a syntactically valid type
</span>    ...
}
</span></pre>
        </li>

        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>
        The condition is satisfied if <i>Type</i> is semantically
        correct and it is the same as
        or can be implicitly converted to <i>TypeSpecialization</i>.
        <i>TypeSpecialization</i> is only allowed to be a <i>Type</i>.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">alias</span> bar = <span class="d_keyword">short</span>;
<span class="d_keyword">void</span> foo(bar x) {
  <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(bar : <span class="d_keyword">int</span>) )   <span class="d_comment">// satisfied because short can be
</span>                              <span class="d_comment">// implicitly converted to int
</span>    writeln(<span class="d_string">"satisfied"</span>);
  <span class="d_keyword">else</span>
    writeln(<span class="d_string">"not satisfied"</span>);
}
</span></pre>
        </li>

        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>
        <p>The condition is satisfied if <i>Type</i> is semantically
        correct and is the same type as <i>TypeSpecialization</i>.</p>

        If <i>TypeSpecialization</i> is one of

                <span class="notranslate"><span class="d_inlinecode donthyphenate">struct</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">union</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">interface</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">enum</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span>
           <span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span>
        then the condition is satisfied if <i>Type</i> is one of those.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">alias</span> bar = <span class="d_keyword">short</span>;

<span class="d_keyword">void</span> test(bar x) {
  <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(bar == <span class="d_keyword">int</span>) ) <span class="d_comment">// not satisfied because short is not
</span>                        <span class="d_comment">// the same type as int
</span>    writeln(<span class="d_string">"satisfied"</span>);
  <span class="d_keyword">else</span>
    writeln(<span class="d_string">"not satisfied"</span>);
}
</span></pre>
        </li>

        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>
        The condition is satisfied if <i>Type</i> is semantically
        correct. If so, <i>Identifier</i>
        is declared to be an alias of <i>Type</i>.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">alias</span> bar = <span class="d_keyword">short</span>;
<span class="d_keyword">void</span> foo(bar x) {
  <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(bar T) )
    <span class="d_keyword">alias</span> S = T;
  <span class="d_keyword">else</span>
    <span class="d_keyword">alias</span> S = <span class="d_keyword">long</span>;

  writeln(<span class="d_keyword">typeid</span>(S));  <span class="d_comment">// prints "short"
</span>  <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(bar T) )  <span class="d_comment">// error, Identifier T form can
</span>                      <span class="d_comment">// only be in StaticIfConditions
</span>    ...
}
</span></pre>
        </li>

        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>

        <p>        The condition is satisfied if <i>Type</i> is the same as
        <i>TypeSpecialization</i>, or if <i>Type</i> is a class and
        <i>TypeSpecialization</i> is a base class or base interface
        of it.
        The <i>Identifier</i> is declared to be either an alias of the
        <i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is
        dependent on <i>Identifier</i>, the deduced type.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">alias</span> bar = <span class="d_keyword">int</span>;
<span class="d_keyword">alias</span> abc = <span class="d_keyword">long</span>*;
<span class="d_keyword">void</span> foo(bar x, abc a) {
  <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(bar T : <span class="d_keyword">int</span>) )
    <span class="d_keyword">alias</span> S = T;
  <span class="d_keyword">else</span>
    <span class="d_keyword">alias</span> S = <span class="d_keyword">long</span>;

  writeln(<span class="d_keyword">typeid</span>(S));  <span class="d_comment">// prints "int"
</span>
  <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(abc U : U*) )
  {
    U u;
    writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(u)));  <span class="d_comment">// prints "long"
</span>  }
}
</span></pre>

        <p>The way the type of <i>Identifier</i> is determined is analogous
        to the way template parameter types are determined by
        <a href="template.html#TemplateTypeParameterSpecialization"><i>TemplateTypeParameterSpecialization</i></a>.
        </p>
        </li>

        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>


        <p>The condition is satisfied if <i>Type</i> is semantically
        correct and is the same as <i>TypeSpecialization</i>.
        The <i>Identifier</i> is declared to be either an alias of the
        <i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is
        dependent on <i>Identifier</i>, the deduced type.
        </p>

        <p>If <i>TypeSpecialization</i> is one of
               <span class="notranslate"><span class="d_inlinecode donthyphenate">struct</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">union</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">interface</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">enum</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span>
           <span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span>
                <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span>

        then the condition is satisfied if <i>Type</i> is one of those.
        Furthermore, <i>Identifier</i> is set to be an alias of the type:
        </p>

        <center><table border=1 cellpadding=4 cellspacing=0><caption></caption>        <tr><th class="donthyphenate"><b>keyword</b></th><th class="donthyphenate"><b>alias type for <i>Identifier</i></b></th></tr>

        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">struct</span></span></td><td><i>Type</i></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">union</span></span></td><td><i>Type</i></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">class</span></span></td><td><i>Type</i></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">interface</span></span></td><td><i>Type</i></td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">super</span></span></td><td><i>TypeTuple</i> of base classes and interfaces</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">enum</span></span></td><td>the base type of the enum</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">function</span></span></td><td><i>TypeTuple</i> of the function parameter types.
             For C- and D-style variadic functions,
             only the non-variadic parameters are included.
             For typesafe variadic functions, the <span class="notranslate"><span class="d_inlinecode donthyphenate">...</span></span> is ignored.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">delegate</span></span></td><td>the function type of the delegate</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">return</span></span></td><td>the return type of the function, delegate, or function pointer</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">__parameters</span></span></td><td>the parameter tuple of a function, delegate, or function pointer.
         This includes the parameter types, names, and default values.</td></tr>
        <tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">const</span></span></td><td><i>Type</i></td></tr>
        <tr><td>        <span class="notranslate"><span class="d_inlinecode donthyphenate">immutable</span></span></td><td>        <i>Type</i>
        </td></tr>
        <tr><td>        <span class="notranslate"><span class="d_inlinecode donthyphenate">shared</span></span></td><td>        <i>Type</i>
        </td></tr>

        </table></center>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">alias</span> bar = <span class="d_keyword">short</span>;
<span class="d_keyword">enum</span> E : <span class="d_keyword">byte</span> { Emember }
<span class="d_keyword">void</span> foo(bar x) {
  <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(bar T == <span class="d_keyword">int</span>) ) <span class="d_comment">// not satisfied, short is not int
</span>    <span class="d_keyword">alias</span> S = T;
  <span class="d_keyword">alias</span> U = T;       <span class="d_comment">// error, T is not defined
</span>
  <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(E V == <span class="d_keyword">enum</span>) )  <span class="d_comment">// satisified, E is an enum
</span>    V v;           <span class="d_comment">// v is declared to be a byte
</span>}
</span></pre>


        </li>

        <li><span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>
             <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>
             <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">:</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span><br>
             <span class="notranslate"><span class="d_inlinecode donthyphenate">is (</span></span> <i>Type</i> <i>Identifier</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> <i>TypeSpecialization</i> <span class="notranslate"><span class="d_inlinecode donthyphenate">,</span></span> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>

        <p>More complex types can be pattern matched; the
        <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> declares symbols based on the
        parts of the pattern that are matched, analogously to the
        way implied template parameters are matched.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio, std.typecons;

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">alias</span> Tup = Tuple!(<span class="d_keyword">int</span>, string);
  <span class="d_keyword">alias</span> AA = <span class="d_keyword">long</span>[<span class="d_keyword">char</span>[]];

  <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Tup : TX!TL, <span class="d_keyword">alias</span> TX, TL...))
  {
    writeln(<span class="d_keyword">is</span>(TX!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>) == Tuple!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>)));  <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">typeid</span>(TL[0]));  <span class="d_comment">// int
</span>    writeln(<span class="d_keyword">typeid</span>(TL[1]));  <span class="d_comment">// immutable(char)[]
</span>  }

  <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(AA T : T[U], U : <span class="d_keyword">const</span> <span class="d_keyword">char</span>[]))
  {
    writeln(<span class="d_keyword">typeid</span>(T));  <span class="d_comment">// long
</span>    writeln(<span class="d_keyword">typeid</span>(U));  <span class="d_comment">// const char[]
</span>  }

  <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(AA A : A[B], B : <span class="d_keyword">int</span>))
  {
    <span class="d_keyword">assert</span>(0);  <span class="d_comment">// should not match, as B is not an int
</span>  }

  <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">int</span>[10] W : W[V], <span class="d_keyword">int</span> V))
  {
    writeln(<span class="d_keyword">typeid</span>(W));  <span class="d_comment">// int
</span>    writeln(V);          <span class="d_comment">// 10
</span>  }

  <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">int</span>[10] X : X[Y], <span class="d_keyword">int</span> Y : 5))
  {
    <span class="d_keyword">assert</span>(0);  <span class="d_comment">// should not match, Y should be 10
</span>  }
}
</span></pre>

        </li>

        </ol>


<h3><a name="associativity">Associativity and Commutativity</a></h3>

        <p>An implementation may rearrange the evaluation of expressions
        according to arithmetic associativity and commutativity rules
        as long as, within that thread of execution, no observable
        difference is possible.
        </p>

        <p>This rule precludes any associative or commutative reordering of
        floating point expressions.</p>

  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div><!--/content-->



<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/Expression" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2017 by Digital Mars &reg;, All Rights Reserved |
Page generated by <a href="ddoc.html">Ddoc</a> on (no date time)
</div>
</body>
</html>

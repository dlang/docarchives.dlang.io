
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Function Parameters - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Function Parameters' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BFunction Parameters%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/function_parameters.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Function Parameters</h1>
        
        



<p>This chapter covers various kinds of function parameters.
</p>

<p>Some of the concepts of this chapter have already appeared earlier in the book. For example, the <code class="d_inline">ref</code> keyword that we saw in the <a href="foreach.html"><code class="d_inline">foreach</code> Loop chapter</a> was making <i>actual elements</i> available in <code class="d_inline">foreach</code> loops as opposed to <i>copies</i> of those elements.
</p>

<p>Additionally, we covered the <code class="d_inline">const</code> and <code class="d_inline">immutable</code> keywords and the differences between value types and reference types in previous chapters.
</p>

<p>We have written functions that produced results by making use of their parameters. For example, the following function uses its parameters in a calculation:
</p>

<pre class="d_code"><span class="d_keyword">double</span> weightedAverage(<span class="d_keyword">double</span> quizGrade, <span class="d_keyword">double</span> finalGrade) {
    <span class="d_keyword">return</span> quizGrade * 0.4 + finalGrade * 0.6;
}
</pre>

<p>That function calculates the average grade by taking 40% of the quiz grade and 60% of the final grade. Here is how it may be used:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> quizGrade = 76;
    <span class="d_keyword">int</span> finalGrade = 80;

    writefln(<span class="d_string">"Weighted average: %2.0f"</span>,
             weightedAverage(quizGrade, finalGrade));
</pre>

<h5 class="subsection"><a id="ix_Function Parameters.pass-by copy" content="pass-by copy"></a> <a id="ix_Function Parameters.copy, parameter" content="copy, parameter"></a> Parameters are always copied</h5>

<p>In the code above, the two variables are passed as arguments to <code class="d_inline">weightedAverage()</code>. The function <i>uses</i> its parameters. This fact may give the false impression that the function uses the actual variables that have been passed as arguments. In reality, what the function uses are <i>copies</i> of those variables.
</p>

<p>This distinction is important because modifying a parameter changes only the copy. This can be seen in the following function that is trying to modify its parameter (i.e. making a side effect). Let's assume that the following function is written for reducing the energy of a game character:
</p>

<pre class="d_code"><span class="d_keyword">void</span> reduceEnergy(<span class="d_keyword">double</span> energy) {
    energy /= 4;
}
</pre>

<p>Here is a program that tests <code class="d_inline">reduceEnergy()</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> reduceEnergy(<span class="d_keyword">double</span> energy) {
    energy /= 4;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">double</span> energy = 100;

    reduceEnergy(energy);
    writeln(<span class="d_string">"New energy: "</span>, energy);
}
</pre>

<p>The output:
</p>

<pre class="shell">New energy: 100     <span class="shell_note_wrong">← Not changed</span>
</pre>

<p>Although <code class="d_inline">reduceEnergy()</code> drops the value of its parameter to a quarter of its original value, the variable <code class="d_inline">energy</code> in <code class="d_inline">main()</code> does not change. The reason for this is that the <code class="d_inline">energy</code> variable in <code class="d_inline">main()</code> and the <code class="d_inline">energy</code> parameter of <code class="d_inline">reduceEnergy()</code> are separate; the parameter is a copy of the variable in <code class="d_inline">main()</code>.
</p>

<p>To observe this more closely, let's insert some <code class="d_inline">writeln()</code> expressions:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> reduceEnergy(<span class="d_keyword">double</span> energy) {
    writeln(<span class="d_string">"Entered the function      : "</span>, energy);
    energy /= 4;
    writeln(<span class="d_string">"Leaving the function      : "</span>, energy);
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">double</span> energy = 100;

    writeln(<span class="d_string">"Calling the function      : "</span>, energy);
    reduceEnergy(energy);
    writeln(<span class="d_string">"Returned from the function: "</span>, energy);
}
</pre>

<p>The output:
</p>

<pre class="shell">Calling the function      : 100
Entered the function      : 100
Leaving the function      : 25   <span class="shell_note">← the parameter changes,</span>
Returned from the function: 100  <span class="shell_note">← the variable remains the same</span>
</pre>

<h5 class="subsection"><a id="ix_Function Parameters.pass-by reference" content="pass-by reference"></a> Referenced variables are not copied</h5>

<p>Even parameters of reference types like slices, associative arrays, and class variables are copied to functions. However, the original variables that are referenced (i.e. elements of slices and associative arrays, and class objects) are not copied. Effectively, such variables are passed to functions as <i>references</i>: the parameter becomes another reference to the original object. It means that a modification made through the reference modifies the original object as well.
</p>

<p>Being slices of characters, this applies to strings as well:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> makeFirstLetterDot(<span class="d_keyword">dchar</span>[] str) {
    str[0] = '.';
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">dchar</span>[] str = <span class="d_string">"abc"d</span>.dup;
    makeFirstLetterDot(str);
    writeln(str);
}
</pre>

<p>The change made to the first element of the parameter affects the actual element in <code class="d_inline">main()</code>:
</p>

<pre class="shell">.bc
</pre>

<p>However, the original slice and associative array variables are still passed by copy. This may have surprising and seemingly unpredictable results unless the parameters are qualified as <code class="d_inline">ref</code> themselves.
</p>

<h6>Surprising reference semantics of slices</h6>

<p>As we saw in the <a href="slices.html">Slices and Other Array Features chapter</a>, adding elements to a slice <i>may</i> terminate element sharing. Obviously, once sharing ends, a slice parameter like <code class="d_inline">str</code> above would not be a reference to the elements of the passed-in original variable anymore.
</p>

<p>For example, the element that is appended by the following function will not be seen by the caller:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> appendZero(<span class="d_keyword">int</span>[] arr) {
    arr <span class="hilite">~= 0</span>;
    writefln(<span class="d_string">"Inside appendZero()       : %s"</span>, arr);
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> arr = [ 1, 2 ];
    appendZero(arr);
    writefln(<span class="d_string">"After appendZero() returns: %s"</span>, arr);
}
</pre>

<p>The element is appended only to the function parameter, not to the original slice:
</p>

<pre class="shell">Inside appendZero()       : [1, 2, 0]
After appendZero() returns: [1, 2]    <span class="shell_note_wrong">← No 0</span>
</pre>

<p>If the new elements need to be appended to the original slice, then the slice must be passed as <code class="d_inline">ref</code>:
</p>

<pre class="d_code"><span class="d_keyword">void</span> appendZero(<span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">int</span>[] arr) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>The <code class="d_inline">ref</code> qualifier will be explained below.
</p>

<h6>Surprising reference semantics of associative arrays</h6>

<p>Associative arrays that are passed as function parameters may cause surprises as well because associative arrays start their lives as <code class="d_inline">null</code>, not empty.
</p>

<p>In this context, <code class="d_inline">null</code> means an uninitialized associative array. Associative arrays are initialized automatically when their first key-value pair is added. As a consequence, if a function adds an element to a <code class="d_inline">null</code> associative array, then that element cannot be seen in the original variable because although the parameter is initialized, the original variable remains <code class="d_inline">null</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> appendElement(<span class="d_keyword">int</span>[string] aa) {
    aa<span class="hilite">[<span class="d_string">"red"</span>] = 100</span>;
    writefln(<span class="d_string">"Inside appendElement()       : %s"</span>, aa);
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span>[string] aa;    <span class="d_comment">// ← null to begin with
</span>    appendElement(aa);
    writefln(<span class="d_string">"After appendElement() returns: %s"</span>, aa);
}
</pre>

<p>The original variable does not have the added element:
</p>

<pre class="shell">Inside appendElement()       : ["red":100]
After appendElement() returns: []    <span class="shell_note_wrong">← Still null</span>
</pre>

<p>On the other hand, if the associative array were not <code class="d_inline">null</code> to begin with, then the added element would be seen by the caller as well:
</p>

<pre class="d_code">    <span class="d_keyword">int</span>[string] aa;
    aa[<span class="d_string">"blue"</span>] = 10;  <span class="d_comment">// ← Not null before the call
</span>    appendElement(aa);
</pre>

<p>This time the added element is seen by the caller:
</p>

<pre class="shell">Inside appendElement()       : ["red":100, "blue":10]
After appendElement() returns: [<span class="hilite">"red":100</span>, "blue":10]
</pre>

<p>For that reason, it may be better to pass the associative array as a <code class="d_inline">ref</code> parameter, which will be explained below.
</p>

<h5 class="subsection">Parameter qualifiers</h5>

<p>Parameters are passed to functions according to the general rules described above:
</p>

<ul>
<li>Value types are copied, after which the original variable and the copy are independent.</li>

<li>Reference types are copied as well but both the original reference and the parameter provide access to the same variable.</li>

</ul>

<p>Those are the default rules that are applied when parameter definitions have no qualifiers. The following qualifiers change the way parameters are passed and what operations are allowed on them.
</p>

<h6><a id="ix_Function Parameters.in, parameter" content="in, parameter"></a> <code class="d_inline">in</code></h6>

<p>We have seen that functions can produce values and can have side effects. The <code class="d_inline">in</code> keyword specifies that the parameter is going be used only as input:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">double</span> weightedTotal(<span class="hilite"><span class="d_keyword">in</span></span> <span class="d_keyword">double</span> currentTotal,
                     <span class="hilite"><span class="d_keyword">in</span></span> <span class="d_keyword">double</span> weight,
                     <span class="hilite"><span class="d_keyword">in</span></span> <span class="d_keyword">double</span> addend) {
    <span class="d_keyword">return</span> currentTotal + (weight * addend);
}

<span class="d_keyword">void</span> main() {
    writeln(weightedTotal(1.23, 4.56, 7.89));
}
</pre>

<p>Like <code class="d_inline">const</code>, <code class="d_inline">in</code> parameters cannot be modified:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">in</span> <span class="d_keyword">int</span> value) {
    value = 1;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}
</pre>

<h6><a id="ix_Function Parameters.out, parameter" content="out, parameter"></a> <code class="d_inline">out</code></h6>

<p>We know that functions return what they produce as their return values. The fact that there is only one return value is sometimes limiting as some functions may need to produce more than one result. (<i><b>Note:</b> It is possible to return more than one result by defining the return type as a <code class="d_inline">Tuple</code> or a <code class="d_inline">struct</code>. We will see these features in later chapters.</i>)
</p>

<p>The <code class="d_inline">out</code> keyword makes it possible for functions to return results through their parameters. When <code class="d_inline">out</code> parameters are modified within the function, those modifications affect the original variable that has been passed to the function. In a sense, the assigned value goes <i>out</i> of the function through the <code class="d_inline">out</code> parameter.
</p>

<p>Let's have a look at a function that divides two numbers and produces both the quotient and the remainder. The return value is used for the quotient and the remainder is <i>returned</i> through the <code class="d_inline">out</code> parameter:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> divide(<span class="d_keyword">int</span> dividend, <span class="d_keyword">int</span> divisor, <span class="hilite"><span class="d_keyword">out</span></span> <span class="d_keyword">int</span> remainder) {
    <span class="hilite">remainder = dividend % divisor</span>;
    <span class="d_keyword">return</span> dividend / divisor;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span> remainder;
    <span class="d_keyword">int</span> result = divide(7, 3, remainder);

    writeln(<span class="d_string">"result: "</span>, result, <span class="d_string">", remainder: "</span>, remainder);
}
</pre>

<p>Modifying the <code class="d_inline">remainder</code> parameter of the function modifies the <code class="d_inline">remainder</code> variable in <code class="d_inline">main()</code> (their names need not be the same):
</p>

<pre class="shell">result: 2, remainder: 1
</pre>

<p>Regardless of their values at the call site, <code class="d_inline">out</code> parameters are first assigned to the <code class="d_inline">.init</code> value of their types automatically:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> parameter) {
    writeln(<span class="d_string">"After entering the function      : "</span>, parameter);
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span> variable = 100;

    writeln(<span class="d_string">"Before calling the function      : "</span>, variable);
    foo(variable);
    writeln(<span class="d_string">"After returning from the function: "</span>, variable);
}
</pre>

<p>Even though there is no explicit assignment to the parameter in the function, the value of the parameter automatically becomes the initial value of <code class="d_inline">int</code>, affecting the variable in <code class="d_inline">main()</code>:
</p>

<pre class="shell">Before calling the function      : 100
After entering the function      : 0  <span class="shell_note">← the value of int.init</span>
After returning from the function: 0
</pre>

<p>As this demonstrates, <code class="d_inline">out</code> parameters cannot pass values into functions; they are strictly for passing values out of functions.
</p>

<p>We will see in later chapters that returning <code class="d_inline">Tuple</code> or <code class="d_inline">struct</code> types are better alternatives to <code class="d_inline">out</code> parameters.
</p>

<h6><a id="ix_Function Parameters.const, parameter" content="const, parameter"></a> <code class="d_inline">const</code></h6>

<p>As we saw earlier, <code class="d_inline">const</code> guarantees that the parameter will not be modified inside the function. It is helpful for the programmers to know that certain variables will not be changed by a function. <code class="d_inline">const</code> also makes functions more useful by allowing <code class="d_inline">const</code>, <code class="d_inline">immutable</code>, and <i>mutable</i> variables to be passed through that parameter:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">dchar</span> lastLetter(<span class="hilite"><span class="d_keyword">const</span></span> <span class="d_keyword">dchar</span>[] str) {
    <span class="d_keyword">return</span> str[$ - 1];
}

<span class="d_keyword">void</span> main() {
    writeln(lastLetter(<span class="d_string">"constant"</span>));
}
</pre>

<h6><a id="ix_Function Parameters.immutable, parameter" content="immutable, parameter"></a> <code class="d_inline">immutable</code></h6>

<p>As we saw earlier, <code class="d_inline">immutable</code> makes functions require that certain variables must be immutable. Because of such a requirement, the following function can only be called with strings with <code class="d_inline">immutable</code> elements (e.g. string literals):
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">dchar</span>[] mix(<span class="hilite"><span class="d_keyword">immutable</span></span> <span class="d_keyword">dchar</span>[] first,
            <span class="hilite"><span class="d_keyword">immutable</span></span> <span class="d_keyword">dchar</span>[] second) {
    <span class="d_keyword">dchar</span>[] result;
    <span class="d_keyword">int</span> i;

    <span class="d_keyword">for</span> (i = 0; (i &lt; first.length) &amp;&amp; (i &lt; second.length); ++i) {
        result ~= first[i];
        result ~= second[i];
    }

    result ~= first[i..$];
    result ~= second[i..$];

    <span class="d_keyword">return</span> result;
}

<span class="d_keyword">void</span> main() {
    writeln(mix(<span class="d_string">"HELLO"</span>, <span class="d_string">"world"</span>));
}
</pre>

<p>Since it forces a requirement on the parameter, <code class="d_inline">immutable</code> parameters should be used only when immutability is required. Otherwise, in general <code class="d_inline">const</code> is more useful because it accepts <code class="d_inline">immutable</code>, <code class="d_inline">const</code>, and <i>mutable</i> variables.
</p>

<h6><a id="ix_Function Parameters.ref, parameter" content="ref, parameter"></a> <code class="d_inline">ref</code></h6>

<p>This keyword allows passing a variable by reference even though it would normally be passed as a copy (i.e. by value).
</p>

<p>For the <code class="d_inline">reduceEnergy()</code> function that we saw earlier to modify the original variable, it must take its parameter as <code class="d_inline">ref</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> reduceEnergy(<span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">double</span> energy) {
    energy /= 4;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">double</span> energy = 100;

    reduceEnergy(energy);
    writeln(<span class="d_string">"New energy: "</span>, energy);
}
</pre>

<p>This time, the modification that is made to the parameter changes the original variable in <code class="d_inline">main()</code>:
</p>

<pre class="shell">New energy: 25
</pre>

<p>As can be seen, <code class="d_inline">ref</code> parameters can be used both as input and output. <code class="d_inline">ref</code> parameters can also be thought of as aliases of the original variables. The function parameter <code class="d_inline">energy</code> above is an alias of the variable <code class="d_inline">energy</code> in <code class="d_inline">main()</code>.
</p>

<p>Similar to <code class="d_inline">out</code> parameters, <code class="d_inline">ref</code> parameters allow functions to have side effects as well. In fact, <code class="d_inline">reduceEnergy()</code> does not return a value; it only causes a side effect through its single parameter.
</p>

<p>The programming style called <i>functional programming</i> favors return values over side effects, so much so that some functional programming languages do not allow side effects at all. This is because functions that produce results <i>purely</i> through their return values are easier to understand, implement, and maintain.
</p>

<p>The same function can be written in a functional programming style by returning the result, instead of causing a side effect. The parts of the program that changed are highlighted:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="hilite"><span class="d_keyword">double</span> reducedEnergy</span>(<span class="d_keyword">double</span> energy) {
    <span class="hilite"><span class="d_keyword">return</span> energy / 4</span>;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">double</span> energy = 100;

    <span class="hilite">energy = reducedEnergy(energy)</span>;
    writeln(<span class="d_string">"New energy: "</span>, energy);
}
</pre>

<p>Note the change in the name of the function as well. Now it is a noun as opposed to a verb.
</p>

<h6><code class="d_inline">auto ref</code></h6>

<p>This qualifier can only be used with <a href="templates.html">templates</a>. As we will see in the next chapter, an <code class="d_inline">auto ref</code> parameter takes <i>lvalues</i> by reference and <i>rvalues</i> by copy.
</p>

<h6><a id="ix_Function Parameters.inout, parameter" content="inout, parameter"></a> <code class="d_inline">inout</code></h6>

<p>Despite its name consisting of <code class="d_inline">in</code> and <code class="d_inline">out</code>, this keyword does not mean <i>input and output</i>; we have already seen that input and output is achieved by the <code class="d_inline">ref</code> keyword.
</p>

<p><code class="d_inline">inout</code> carries the <i>mutability</i> of the parameter to the return type. If the parameter is <code class="d_inline">const</code>, <code class="d_inline">immutable</code>, or <i>mutable</i>; then the return value is also <code class="d_inline">const</code>, <code class="d_inline">immutable</code>, or <i>mutable</i>; respectively.
</p>

<p>To see how <code class="d_inline">inout</code> helps in programs, let's look at a function that returns a slice to the <i>inner</i> elements of its parameter:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span>[] inner(<span class="d_keyword">int</span>[] slice) {
    <span class="d_keyword">if</span> (slice.length) {
        --slice.length;               <span class="d_comment">// trim from the end
</span>
        <span class="d_keyword">if</span> (slice.length) {
            slice = slice[1 .. $];    <span class="d_comment">// trim from the beginning
</span>        }
    }

    <span class="d_keyword">return</span> slice;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span>[] numbers = [ 5, 6, 7, 8, 9 ];
    writeln(inner(numbers));
}
</pre>

<p>The output:
</p>

<pre class="shell">[6, 7, 8]
</pre>

<p>According to what we have established so far in the book, in order for the function to be more useful, its parameter should be <code class="d_inline">const(int)[]</code> because the elements are not being modified inside the function. (Note that there is no harm in modifying the parameter slice itself, as it is a copy of the original variable.)
</p>

<p>However, defining the function that way would cause a compilation error:
</p>

<pre class="d_code"><span class="d_keyword">int</span>[] inner(<span class="hilite"><span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]</span> slice) {
    <span class="d_comment">// ...
</span>    <span class="d_keyword">return</span> slice;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}
</pre>

<p>The compilation error indicates that a slice of <code class="d_inline">const(int)</code> cannot be returned as a slice of <i>mutable</i> <code class="d_inline">int</code>:
</p>

<pre class="shell">Error: cannot implicitly convert expression (slice) of type
const(int)[] to int[]
</pre>

<p>One may think that specifying the return type as <code class="d_inline">const(int)[]</code> would be the solution:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]</span> inner(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] slice) {
    <span class="d_comment">// ...
</span>    <span class="d_keyword">return</span> slice;    <span class="d_comment">// now compiles
</span>}
</pre>

<p>Although the code now compiles, it brings a limitation: even when the function is called with a slice of <i>mutable</i> elements, this time the returned slice ends up consisting of <code class="d_inline">const</code> elements. To see how limiting this would be, let's look at the following code, which tries to modify the inner elements of a slice:
</p>

<pre class="d_code">    <span class="d_keyword">int</span>[] numbers = [ 5, 6, 7, 8, 9 ];
    <span class="d_keyword">int</span>[] middle = inner(numbers);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    middle[] *= 10;
</pre>

<p>The returned slice of type <code class="d_inline">const(int)[]</code> cannot be assigned to a slice of type <code class="d_inline">int[]</code>, resulting in an error:
</p>

<pre class="shell">Error: cannot implicitly convert expression (inner(numbers))
of type const(int)[] to int[]
</pre>

<p>However, since we started with a slice of mutable elements, this limitation is artificial and unfortunate. <code class="d_inline">inout</code> solves this mutability problem between parameters and return values. It is specified on both the parameter and the return type and carries the mutability of the former to the latter:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">inout</span></span>(<span class="d_keyword">int</span>)[] inner(<span class="hilite"><span class="d_keyword">inout</span></span>(<span class="d_keyword">int</span>)[] slice) {
    <span class="d_comment">// ...
</span>    <span class="d_keyword">return</span> slice;
}
</pre>

<p>With that change, the same function can now be called with <code class="d_inline">const</code>, <code class="d_inline">immutable</code>, and <i>mutable</i> slices:
</p>

<pre class="d_code">    {
        <span class="hilite"><span class="d_keyword">int</span>[]</span> numbers = [ 5, 6, 7, 8, 9 ];
        <span class="d_comment">// The return type is a slice of mutable elements
</span>        <span class="hilite"><span class="d_keyword">int</span>[]</span> middle = inner(numbers);
        middle[] *= 10;
        writeln(middle);
    }
    {
        <span class="hilite"><span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[]</span> numbers = [ 10, 11, 12 ];
        <span class="d_comment">// The return type is a slice of immutable elements
</span>        <span class="hilite"><span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[]</span> middle = inner(numbers);
        writeln(middle);
    }
    {
        <span class="hilite"><span class="d_keyword">const</span> <span class="d_keyword">int</span>[]</span> numbers = [ 13, 14, 15, 16 ];
        <span class="d_comment">// The return type is a slice of const elements
</span>        <span class="hilite"><span class="d_keyword">const</span> <span class="d_keyword">int</span>[]</span> middle = inner(numbers);
        writeln(middle);
    }
</pre>

<h6><a id="ix_Function Parameters.lazy" content="lazy"></a> <code class="d_inline">lazy</code></h6>

<p>It is natural to expect that arguments are evaluated <i>before</i> entering functions that use those arguments. For example, the function <code class="d_inline">add()</code> below is called with the return values of two other functions:
</p>

<pre class="d_code">    result = add(anAmount(), anotherAmount());
</pre>

<p>In order for <code class="d_inline">add()</code> to be called, first <code class="d_inline">anAmount()</code> and <code class="d_inline">anotherAmount()</code> must be called. Otherwise, the values that <code class="d_inline">add()</code> needs would not be available.
</p>

<p>Evaluating arguments before calling a function is called <i>eager evaluation</i>.
</p>

<p>However, depending on certain conditions, some parameters may not get a chance to be used in the function at all. In such cases, evaluating the arguments eagerly would be wasteful.
</p>

<p>A classic example of this situation is a <i>logging</i> function that outputs a message only if the importance of the message is above a certain configuration setting:
</p>

<pre class="d_code"><span class="d_keyword">enum</span> Level { low, medium, high }

<span class="d_keyword">void</span> log(Level level, string message) {
    <span class="d_keyword">if</span> (level &gt;= interestedLevel) {
        writeln(message);
    }
}
</pre>

<p>For example, if the user is interested only in the messages that are <code class="d_inline">Level.high</code>, a message with <code class="d_inline">Level.medium</code> would not be printed. However, the argument would still be evaluated before calling the function. For example, the entire <code class="d_inline">format()</code> expression below including the <code class="d_inline">getConnectionState()</code> call that it makes would be wasted if the message is never printed:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (failedToConnect) {
        log(Level.medium,
            format(<span class="d_string">"Failure. The connection state is '%s'."</span>,
                   getConnectionState()));
    }
</pre>

<p>The <code class="d_inline">lazy</code> keyword specifies that an expression that is passed as a parameter will be evaluated only if and when needed:
</p>

<pre class="d_code"><span class="d_keyword">void</span> log(Level level, <span class="hilite"><span class="d_keyword">lazy</span></span> string message) {
   <span class="d_comment">// ... the body of the function is the same as before ...
</span>}
</pre>

<p>This time, the expression would be evaluated only if the <code class="d_inline">message</code> parameter is used.
</p>

<p>One thing to be careful about is that a <code class="d_inline">lazy</code> parameter is evaluated <i>every time</i> that parameter is used in the function.
</p>

<p>For example, because the <code class="d_inline">lazy</code> parameter of the following function is used three times in the function, the expression that provides its value is evaluated three times:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> valueOfArgument() {
    writeln(<span class="d_string">"Calculating..."</span>);
    <span class="d_keyword">return</span> 1;
}

<span class="d_keyword">void</span> functionWithLazyParameter(<span class="d_keyword">lazy</span> <span class="d_keyword">int</span> value) {
    <span class="d_keyword">int</span> result = <span class="hilite">value + value + value</span>;
    writeln(result);
}

<span class="d_keyword">void</span> main() {
    functionWithLazyParameter(valueOfArgument());
}
</pre>

<p>The output:
</p>

<pre class="shell">Calculating
Calculating
Calculating
3
</pre>

<h6><a id="ix_Function Parameters.scope" content="scope"></a> <code class="d_inline">scope</code></h6>

<p><a id="ix_Function Parameters.DIP" content="DIP"></a> <a id="ix_Function Parameters.-dip1000" content="-dip1000"></a> This keyword specifies that a parameter will not be used beyond the scope of the function. As of this writing, <code class="d_inline">scope</code> is effective only if the function is defined as <a href="functions_more.html"><code class="d_inline">@safe</code></a> and if <code class="d_inline">-dip1000</code> compiler switch is used. DIP is short for <i>D Improvement Proposal</i>. DIP 1000 is experimental as of this writing; so it may not work as expected in all cases.
</p>

<pre class="shell"><span class="shell_observed">$</span> dmd -dip1000 deneme.d
</pre>

<pre class="d_code"><span class="d_keyword">int</span>[] globalSlice;

<span class="hilite">@safe</span> <span class="d_keyword">int</span>[] foo(<span class="hilite"><span class="d_keyword">scope</span></span> <span class="d_keyword">int</span>[] parameter) {
    globalSlice = parameter;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    <span class="d_keyword">return</span> parameter;           <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span>[] slice = [ 10, 20 ];
    <span class="d_keyword">int</span>[] result = foo(slice);
}
</pre>

<p>The function above violates the promise of <code class="d_inline">scope</code> in two places: It assigns the parameter to a global variable, and it returns it. Both those actions would make it possible for the parameter to be accessed after the function finishes.
</p>

<h6><a id="ix_Function Parameters.shared, parameter" content="shared, parameter"></a> <code class="d_inline">shared</code></h6>

<p>This keyword requires that the parameter is shareable between threads of execution:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="hilite"><span class="d_keyword">shared</span></span> <span class="d_keyword">int</span>[] i) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span>[] numbers = [ 10, 20 ];
    foo(numbers);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}
</pre>

<p>The program above cannot be compiled because the argument is not <code class="d_inline">shared</code>. The following is the necessary change to make it compile:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">shared</span></span> <span class="d_keyword">int</span>[] numbers = [ 10, 20 ];
    foo(numbers);    <span class="d_comment">// now compiles
</span></pre>

<p>We will see the <code class="d_inline">shared</code> keyword later in the <a href="concurrency_shared.html">Data Sharing Concurrency chapter</a>.
</p>

<h6><a id="ix_Function Parameters.return, parameter" content="return, parameter"></a> <code class="d_inline">return</code></h6>

<p>Sometimes it is useful for a function to return one of its <code class="d_inline">ref</code> parameters directly. For example, the following <code class="d_inline">pick()</code> function picks and returns one of its parameters randomly so that the caller can mutate the lucky one directly:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.random;

<span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">int</span> pick(<span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">int</span> lhs, <span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">int</span> rhs) {
    <span class="d_keyword">return</span> uniform(0, 2) ? lhs : rhs;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span> a;
    <span class="d_keyword">int</span> b;

    pick(a, b) <span class="hilite">= 42</span>;

    writefln(<span class="d_string">"a: %s, b: %s"</span>, a, b);
}
</pre>

<p>As a result, either <code class="d_inline">a</code> or <code class="d_inline">b</code> inside <code class="d_inline">main()</code> is assigned the value <code class="d_inline">42</code>:
</p>

<pre class="shell">a: 42, b: 0
</pre>

<pre class="shell">a: 0, b: 42
</pre>

<p>Unfortunately, one of the arguments of <code class="d_inline">pick()</code> may have a shorter lifetime than the returned reference. For example, the following <code class="d_inline">foo()</code> function calls <code class="d_inline">pick()</code> with two local variables, effectively itself returning a reference to one of them:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.random;

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> pick(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> lhs, <span class="d_keyword">ref</span> <span class="d_keyword">int</span> rhs) {
    <span class="d_keyword">return</span> uniform(0, 2) ? lhs : rhs;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo() {
    <span class="d_keyword">int</span> a;
    <span class="d_keyword">int</span> b;

    <span class="d_keyword">return</span> pick(a, b);    <span class="d_comment">// ← <span class="code_note_wrong">BUG: returning invalid reference</span></span>
}

<span class="d_keyword">void</span> main() {
    foo() = 42;           <span class="d_comment">// ← <span class="code_note_wrong">BUG: writing to invalid memory</span></span>
}
</pre>

<p>Since the lifetimes of both <code class="d_inline">a</code> and <code class="d_inline">b</code> end upon leaving <code class="d_inline">foo()</code>, the assignment in <code class="d_inline">main()</code> cannot be made to a valid variable. This results in <i>undefined behavior</i>.
</p>

<p><a id="ix_Function Parameters.undefined behavior" content="undefined behavior"></a> The term <i>undefined behavior</i> describes situations where the behavior of the program is not defined by the programming language specification. Nothing can be said about the behavior of a program that contains undefined behavior. (In practice though, for the program above, the value <code class="d_inline">42</code> would most likely be written to a memory location that used to be occupied by either <code class="d_inline">a</code> or <code class="d_inline">b</code>, potentially currently a part of an unrelated variable, effectively corrupting the value of that unrelated variable.)
</p>

<p>The <code class="d_inline">return</code> keyword can be applied to a parameter to prevent such bugs. It specifies that a parameter must be a reference to a variable with a longer lifetime than the returned reference:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.random;

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> pick(<span class="hilite"><span class="d_keyword">return</span></span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> lhs, <span class="hilite"><span class="d_keyword">return</span></span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> rhs) {
    <span class="d_keyword">return</span> uniform(0, 2) ? lhs : rhs;
}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo() {
    <span class="d_keyword">int</span> a;
    <span class="d_keyword">int</span> b;

    <span class="d_keyword">return</span> pick(a, b);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}

<span class="d_keyword">void</span> main() {
    foo() = 42;
}
</pre>

<p>This time the compiler sees that the arguments to <code class="d_inline">pick()</code> have a shorter lifetime than the reference that <code class="d_inline">foo()</code> is attempting to return:
</p>

<pre class="shell">Error: escaping reference to local variable a
Error: escaping reference to local variable b
</pre>

<p><a id="ix_Function Parameters.sealed reference" content="sealed reference"></a> <a id="ix_Function Parameters.reference, sealed" content="reference, sealed"></a> This feature is called <i>sealed references</i>.
</p>

<p><i><b>Note:</b> Although it is conceivable that the compiler could inspect <code class="d_inline">pick()</code> and detect the bug even without the <code class="d_inline">return</code> keyword, it cannot do so in general because the bodies of some functions may not be available to the compiler during every compilation.</i>
</p>

<h5 class="subsection">Summary</h5>

<ul>
<li>A <i>parameter</i> is what the function takes from its caller to accomplish its task.</li>

<li>An <i>argument</i> is an expression (e.g. a variable) that is passed to a function as a parameter.</li>

<li>Every argument is passed by copy. However, for reference types, it is the reference that is copied, not the original variable.
</li>

<li><code class="d_inline">in</code> specifies that the parameter is used only for data input.</li>

<li><code class="d_inline">out</code> specifies that the parameter is used only for data output.</li>

<li><code class="d_inline">ref</code> specifies that the parameter is used for data input and data output.</li>

<li><code class="d_inline">auto ref</code> is used in templates only. It specifies that if the argument is an lvalue, then a reference to it is passed; if the argument is an rvalue, then it is passed by copy.</li>

<li><code class="d_inline">const</code> guarantees that the parameter is not modified inside the function. (Remember that <code class="d_inline">const</code> is transitive: any data reached through a <code class="d_inline">const</code> variable is <code class="d_inline">const</code> as well.)</li>

<li><code class="d_inline">immutable</code> requires the argument to be <code class="d_inline">immutable</code>.</li>

<li><code class="d_inline">inout</code> appears both at the parameter and the return type, and transfers the <i>mutability</i> of the parameter to the return type.</li>

<li><code class="d_inline">lazy</code> is used to make a parameter be evaluated when (and every time) it is actually used.</li>

<li><code class="d_inline">scope</code> guarantees that no reference to the parameter will be leaked from the function.</li>

<li><code class="d_inline">shared</code> requires the parameter to be <code class="d_inline">shared</code>.</li>

<li><code class="d_inline">return</code> on a parameter requires the parameter to live longer than the returned reference.</li>

</ul>

<h5 class="subsection">Problem</h5>
    
<p>The following program is trying to swap the values of two arguments:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> swap(<span class="d_keyword">int</span> first, <span class="d_keyword">int</span> second) {
    <span class="d_keyword">int</span> temp = first;
    first = second;
    second = temp;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span> a = 1;
    <span class="d_keyword">int</span> b = 2;

    swap(a, b);

    writeln(a, ' ', b);
}
</pre>

<p>However, the program does not have any effect on <code class="d_inline">a</code> or <code class="d_inline">b</code>:
</p>

<pre class="shell">1 2          <span class="shell_note_wrong">← not swapped</span>
</pre>

<p>Fix the function so that the values of <code class="d_inline">a</code> and <code class="d_inline">b</code> are swapped.
</p>

 <div class="cozum_link_tek"><p><a target="ddili_cozum" href="function_parameters.cozum.html"><i>... çözüm</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 21:19:12 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

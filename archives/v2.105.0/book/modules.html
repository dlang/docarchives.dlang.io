
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Modules and Libraries - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Modules and Libraries' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BModules and Libraries%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/modules.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Modules and Libraries</h1>
        
        



<p>The building blocks of D programs (and libraries) are modules.
</p>

<p>D modules are based on a simple concept: Every source file is a module. Accordingly, the single files that we have been writing our programs in have all been individual modules.
</p>

<p>By default, the name of a module is the same as its filename without the <code class="d_inline">.d</code> extension. When explicitly specified, the name of the module is defined by the <code class="d_inline">module</code> keyword, which must appear as the first non-comment line in the source file.
</p>

<p>For example, assuming that the name of a source file is "cat.d", the name of the module would be specified by the <code class="d_inline">module</code> keyword:
</p>

<pre class="d_code"><span class="d_keyword">module</span> cat;

<span class="d_keyword">class</span> Cat {
    <span class="d_comment">// ...
</span>}
</pre>

<p>The <code class="d_inline">module</code> line is optional if the module is not part of any package (see below). When not specified, it is the same as the file name without the <code class="d_inline">.d</code> extension.
</p>

<h6><a id="ix_Modules and Libraries.static this, module" content="static this, module"></a> <a id="ix_Modules and Libraries.static ~this, module" content="static ~this, module"></a> <a id="ix_Modules and Libraries.this, static, module" content="this, static, module"></a> <a id="ix_Modules and Libraries.~this, static, module" content="~this, static, module"></a> <a id="ix_Modules and Libraries.module constructor, thread-local" content="module constructor, thread-local"></a> <code class="d_inline">static this()</code> and <code class="d_inline">static ~this()</code></h6>

<p><code class="d_inline">static this()</code> and <code class="d_inline">static ~this()</code> at module scope are similar to their <code class="d_inline">struct</code> and <code class="d_inline">class</code> counterparts:
</p>

<pre class="d_code"><span class="d_keyword">module</span> cat;

<span class="d_keyword">static</span> <span class="d_keyword">this</span>() {
    <span class="d_comment">// ... the initial operations of the module ...
</span>}

<span class="d_keyword">static</span> ~<span class="d_keyword">this</span>() {
    <span class="d_comment">// ... the final operations of the module ...
</span>}
</pre>

<p>Code that are in these scopes are executed once for each thread. (Note that most programs consist of a single thread that starts executing the <code class="d_inline">main()</code> function.) Code that should be executed only once for the entire program (e.g. initializing <code class="d_inline">shared</code> and <code class="d_inline">immutable</code> variables) must be defined in <code class="d_inline">shared static this()</code> and <code class="d_inline">shared static ~this()</code> blocks, which will be covered in <a href="concurrency_shared.html">the Data Sharing Concurrency chapter</a>.
</p>

<h6>File and module names</h6>

<p>D supports Unicode in source code and module names. However, the Unicode support of file systems vary. For example, although most Linux file systems support Unicode, the file names in Windows file systems may not distinguish between lower and upper case letters. Additionally, most file systems limit the characters that can be used in file and directory names.
</p>

<p>For portability reasons, I recommend that you use only lower case ASCII letters in file names. For example, "resume.d" would be a suitable file name for a class named <code class="d_inline">Résumé</code>.
</p>

<p>Accordingly, the name of the module would consist of ASCII letters as well:
</p>

<pre class="d_code"><span class="d_keyword">module</span> resume;  <span class="d_comment">// Module name consisting of ASCII letters
</span>
<span class="d_keyword">class</span> Résumé {  <span class="d_comment">// Program code consisting of Unicode characters
</span>    <span class="d_comment">// ...
</span>}
</pre>

<h5 class="subsection"><a id="ix_Modules and Libraries.package, definition" content="package, definition"></a> Packages</h5>

<p>A combination of related modules are called a <i>package</i>. D packages are a simple concept as well: The source files that are inside the same directory are considered to belong to the same package. The name of the directory becomes the name of the package, which must also be specified as the first parts of module names.
</p>

<p>For example, if "cat.d" and "dog.d" are inside the directory "animal", then specifying the directory name along with the module name makes them be a part of the same package:
</p>

<pre class="d_code"><span class="d_keyword">module</span> <span class="hilite">animal.</span>cat;

<span class="d_keyword">class</span> Cat {
    <span class="d_comment">// ...
</span>}
</pre>

<p>Similarly, for the <code class="d_inline">dog</code> module:
</p>

<pre class="d_code"><span class="d_keyword">module</span> <span class="hilite">animal.</span>dog;

<span class="d_keyword">class</span> Dog {
    <span class="d_comment">// ...
</span>}
</pre>

<p>For modules that are parts of packages, the <code class="d_inline">module</code> line is not optional and the whole module name including the package name must be specified.
</p>

<p>Since package names correspond to directory names, the package names of modules that are deeper than one directory level must reflect that hierarchy. For example, if the "animal" directory included a "vertebrate" directory, the name of a module inside that directory would include <code class="d_inline">vertebrate</code> as well:
</p>

<pre class="d_code"><span class="d_keyword">module</span> animal.vertebrate.cat;
</pre>

<p>The directory hierarchies can be arbitrarily complex depending on the needs of the program. Relatively short programs usually have all of their source files in a single directory.
</p>

<h5 class="subsection">Importing modules</h5>

<p><a id="ix_Modules and Libraries.import" content="import"></a> The <code class="d_inline">import</code> keyword, which we have been using in almost every program so far, is for introducing a module to the current module:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
</pre>

<p>The module name may contain the package name as well. For example, the <code class="d_inline">std.</code> part above indicates that <code class="d_inline">stdio</code> is a module that is a part of the <code class="d_inline">std</code> package.
</p>

<p>The <code class="d_inline">animal.cat</code> and <code class="d_inline">animal.dog</code> modules would be imported similarly. Let's assume that the following code is inside a file named "deneme.d":
</p>

<pre class="d_code"><span class="d_keyword">module</span> deneme;        <span class="d_comment">// the name of this module
</span>
<span class="d_keyword">import</span> animal.cat;    <span class="d_comment">// a module that it uses
</span><span class="d_keyword">import</span> animal.dog;    <span class="d_comment">// another module that it uses
</span>
<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> cat = <span class="d_keyword">new</span> Cat();
    <span class="d_keyword">auto</span> dog = <span class="d_keyword">new</span> Dog();
}
</pre>

<p><i><b>Note:</b> As described below, for the program to be built correctly, those module files must also be provided to the linker.</i>
</p>

<p>More than one module can be imported at the same time:
</p>

<pre class="d_code"><span class="d_keyword">import</span> animal.cat, animal.dog;
</pre>

<h6><a id="ix_Modules and Libraries.selective import" content="selective import"></a> <a id="ix_Modules and Libraries.import, selective" content="import, selective"></a> Selective imports</h6>

<p><a id="ix_Modules and Libraries.:, import" content=":, import"></a> Instead of importing a module as a whole with all of its names, it is possible to import just specific names from it.
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio <span class="hilite">: writeln;</span>

<span class="d_comment">// ...
</span>
    write<span class="hilite">f</span>ln(<span class="d_string">"Hello %s."</span>, name);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>The code above cannot be compiled because only <code class="d_inline">writeln</code> is imported, not <code class="d_inline">writefln</code>.
</p>

<p>Selective imports are considered to be better than importing an entire module because it reduces the chance of <i>name collisions</i>. As we will see in an example below, a name collision can occur when the same name appears in more than one imported module.
</p>

<p>Selective imports may reduce compilation times as well because the compiler needs to compile only the parts of a module that are actually imported. On the other hand, selective imports require more work as every imported name must be specified separately on the <code class="d_inline">import</code> line.
</p>

<p>This book does not take advantage of selective imports mostly for brevity.
</p>

<h6><a id="ix_Modules and Libraries.local import" content="local import"></a> <a id="ix_Modules and Libraries.import, local" content="import, local"></a> Local imports</h6>

<p>So far we have always imported all of the required modules at the tops of programs:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;     <span class="d_comment">// ← at the top</span>
<span class="d_keyword">import</span> std.string;    <span class="d_comment">// ← at the top</span>

<span class="d_comment">// ... the rest of the module ...
</span></pre>

<p>Instead, modules can be imported at any other line of the source code. For example, the two functions of the following program import the modules that they need in their own scopes:
</p>

<pre class="d_code">string makeGreeting(string name) {
    <span class="hilite"><span class="d_keyword">import</span> std.string;</span>

    string greeting = format(<span class="d_string">"Hello %s"</span>, name);
    <span class="d_keyword">return</span> greeting;
}

<span class="d_keyword">void</span> interactWithUser() {
    <span class="hilite"><span class="d_keyword">import</span> std.stdio;</span>

    write(<span class="d_string">"Please enter your name: "</span>);
    string name = readln();
    writeln(makeGreeting(name));
}

<span class="d_keyword">void</span> main() {
    interactWithUser();
}
</pre>

<p>Local imports are recommended over global imports because instead of importing every module unconditionally at the top, the compiler can import only the ones that are in the scopes that are actually used. If the compiler knows that the program never calls a function, it can ignore the import directives inside that function.
</p>

<p>Additionally, a locally imported module is accessible only inside that local scope, further reducing the risk of name collisions.
</p>

<p>We will later see in <a href="mixin.html">the Mixins chapter</a> that local imports are in fact required for <i>template mixins.</i>
</p>

<p>The examples throughout this book do not take advantage of local imports mostly because local imports were added to D after the start of writing this book.
</p>

<h6>Locations of modules</h6>

<p>The compiler finds the module files by converting the package and module names directly to directory and file names.
</p>

<p>For example, the previous two modules would be located as "animal/cat.d" and "animal/dog.d", respectively (or "animal\cat.d" and "animal\dog.d", depending on the file system). Considering the main source file as well, the program above consists of three files.
</p>

<h6>Long and short module names</h6>

<p>The names that are used in the program may be spelled out with the module and package names:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> cat0 = Cat();
    <span class="d_keyword">auto</span> cat1 = animal.cat.Cat();   <span class="d_comment">// same as above
</span></pre>

<p>The long names are normally not needed but sometimes there are name conflicts. For example, when referring to a name that appears in more than one module, the compiler cannot decide which one is meant.
</p>

<p>The following program is spelling out the long names to distinguish between two separate <code class="d_inline">Jaguar</code> structs that are defined in two separate modules: <code class="d_inline">animal</code> and <code class="d_inline">car</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> animal.jaguar;
<span class="d_keyword">import</span> car.jaguar;

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> conflicted =  Jaguar();            <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>

    <span class="d_keyword">auto</span> myAnimal = animal.jaguar.Jaguar(); <span class="d_comment">// ← compiles</span>
    <span class="d_keyword">auto</span> myCar    =    car.jaguar.Jaguar(); <span class="d_comment">// ← compiles</span>
</pre>

<h6>Renamed imports</h6>

<p><a id="ix_Modules and Libraries.renamed import" content="renamed import"></a> It is possible to rename imported modules either for convenience or to resolve name conflicts:
</p>

<pre class="d_code"><span class="d_keyword">import</span> <span class="hilite">carnivore =</span> animal.jaguar;
<span class="d_keyword">import</span> <span class="hilite">vehicle =</span> car.jaguar;

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> myAnimal = <span class="hilite">carnivore.</span>Jaguar();       <span class="d_comment">// ← compiles</span>
    <span class="d_keyword">auto</span> myCar    = <span class="hilite">vehicle.</span>Jaguar();         <span class="d_comment">// ← compiles</span>
</pre>

<p>Instead of renaming the entire import, it is possible to rename individual imported symbols.
</p>

<p>For example, when the following code is compiled with the <code class="d_inline">-w</code> compiler switch, the compiler would warn that <code class="d_inline">sort()</code> <i>function</i> should be preferred instead of <code class="d_inline">.sort</code> <i>property</i>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.algorithm;

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> arr = [ 2, 10, 1, 5 ];
    arr<span class="hilite">.sort</span>;    <span class="d_comment">// ← <span class="code_note_wrong">compilation WARNING</span></span>
    writeln(arr);
</pre>

<pre class="shell">Warning: use std.algorithm.sort instead of .sort property
</pre>

<p><i><b>Note:</b> The <code class="d_inline">arr.sort</code> expression above is the equivalent of <code class="d_inline">sort(arr)</code> but it is written in the UFCS syntax, which we will see in <a href="ufcs.html">a later chapter</a>.</i>
</p>

<p>One solution in this case is to import <code class="d_inline">std.algorithm.sort</code> by renaming it. The new name <code class="d_inline">algSort</code> below means the <code class="d_inline">sort()</code> <i>function</i> and the compiler warning is eliminated:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.algorithm : <span class="hilite">algSort =</span> sort;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> arr = [ 2, 10, 1, 5 ];
    arr<span class="hilite">.algSort</span>;
    writeln(arr);
}
</pre>

<h6><a id="ix_Modules and Libraries.package import" content="package import"></a> Importing a package as a module</h6>

<p>Sometimes multiple modules of a package may need to be imported together. For example, whenever one module from the <code class="d_inline">animal</code> package is imported, all of the other modules may need to be imported as well: <code class="d_inline">animal.cat</code>, <code class="d_inline">animal.dog</code>, <code class="d_inline">animal.horse</code>, etc.
</p>

<p>In such cases it is possible to import some or all of the modules of a package by importing the package as if it were a module:
</p>

<pre class="d_code"><span class="d_keyword">import</span> animal;    <span class="d_comment">// ← entire package imported as a module
</span></pre>

<p><a id="ix_Modules and Libraries.package.d" content="package.d"></a> It is achieved by a special configuration file in the package directory, which must always be named as <code class="d_inline">package.d</code>. That special file includes the <code class="d_inline">module</code> directive for the package and imports the modules of the package <i>publicly</i>:
</p>

<pre class="d_code"><span class="d_comment">// The contents of the file animal/package.d:
</span><span class="d_keyword">module</span> animal;

<span class="hilite"><span class="d_keyword">public</span></span> <span class="d_keyword">import</span> animal.cat;
<span class="hilite"><span class="d_keyword">public</span></span> <span class="d_keyword">import</span> animal.dog;
<span class="hilite"><span class="d_keyword">public</span></span> <span class="d_keyword">import</span> animal.horse;
<span class="d_comment">// ... same for the other modules ...
</span></pre>

<p>Importing a module publicly makes that module available to the users of the importing module as well. As a result, when the users import just the <code class="d_inline">animal</code> module (which actually is a package), they get access to <code class="d_inline">animal.cat</code> and all the other modules as well.
</p>

<h6><a id="ix_Modules and Libraries.deprecated" content="deprecated"></a> Deprecating features</h6>

<p>Modules evolve over time and get released under new version numbers. Going forward from a particular version, the authors of the module may decide to <i>deprecate</i> some of its features. Deprecating a feature means that newly written programs should not rely on that feature anymore; using a deprecated feature is disapproved. Deprecated features may even be removed from the module in the future.
</p>

<p>There can be many reasons why a feature is deprecated. For example, the new version of the module may include a better alternative, the feature may have been moved to another module, the name of the feature may have changed to be consistent with the rest of the module, etc.
</p>

<p>The deprecation of a feature is made official by defining it with the <code class="d_inline">deprecated</code> attribute, optionally with a custom message. For example, the following deprecation message communicates to its user that the name of the function has been changed:
</p>

<pre class="d_code"><span class="d_keyword">deprecated</span>(<span class="d_string">"Please use doSomething() instead."</span>)
<span class="d_keyword">void</span> do_something() {
    <span class="d_comment">// ...
</span>}
</pre>

<p>By specifying one of the following compiler switches, the user of the module can determine how the compiler should react when a deprecated feature is used:
</p>

<ul><li><a id="ix_Modules and Libraries.-d, compiler switch" content="-d, compiler switch"></a> <code class="d_inline">-d</code>: Using deprecated features should be allowed</li>
<li><a id="ix_Modules and Libraries.-dw, compiler switch" content="-dw, compiler switch"></a> <code class="d_inline">-dw</code>: Using deprecated features should produce compilation warnings</li>
<li><a id="ix_Modules and Libraries.-de, compiler switch" content="-de, compiler switch"></a> <code class="d_inline">-de</code>: Using deprecated features should produce compilation errors</li>
</ul>

<p>For example, calling the deprecated feature in a program and compiling it with <code class="d_inline">-de</code> would fail compilation:
</p>

<pre class="d_code">    do_something();
</pre>

<pre class="shell">$ dmd deneme.d <span class="hilite">-de</span>
<span class="shell_observed">deneme.d: <span class="hilite">Deprecation</span>: function deneme.do_something is
deprecated - Please use doSomething() instead.</span>
</pre>

<p>The name of a deprecated feature is usually defined as an <code class="d_inline">alias</code> of the new name:
</p>

<pre class="d_code"><span class="d_keyword">deprecated</span>(<span class="d_string">"Please use doSomething() instead."</span>)
<span class="hilite"><span class="d_keyword">alias</span> do_something</span> = doSomething;

<span class="d_keyword">void</span> doSomething() {
    <span class="d_comment">// ...
</span>}
</pre>

<p>We will see the <code class="d_inline">alias</code> keyword in <a href="alias.html">a later chapter</a>.
</p>

<h6>Adding module definitions to the program</h6>

<p>The <code class="d_inline">import</code> keyword is not sufficient to make modules become parts of the program. It simply makes available the features of a module inside the current module. That much is needed only to <i>compile</i> the code.
</p>

<p>It is not possible to build the previous program only by the main source file, "deneme.d":
</p>

<pre class="shell">$ dmd deneme.d -w -de
<span class="shell_observed">deneme.o: In function `_Dmain':
deneme.d: <span class="hilite">undefined reference</span> to `_D6animal3cat3Cat7__ClassZ'
deneme.d: <span class="hilite">undefined reference</span> to `_D6animal3dog3Dog7__ClassZ'
collect2: ld returned 1 exit status</span>
</pre>

<p>Those error messages are generated by the <i>linker</i>. Although they are not user-friendly messages, they indicate that some definitions that are needed by the program are missing.
</p>

<p><a id="ix_Modules and Libraries.linker" content="linker"></a> <a id="ix_Modules and Libraries.building the program" content="building the program"></a> The actual build of the program is the responsibility of the linker, which gets called automatically by the compiler behind the scenes. The compiler passes the modules that it has just compiled to the linker, and the linker combines those modules (and libraries) to produce the executable program.
</p>

<p>For that reason, all of the modules that make up the program must be provided to the linker. For the program above to be built, "animal/cat.d" and "animal/dog.d" must also be specified on the compilation line:
</p>

<pre class="shell">$ dmd deneme.d animal/cat.d animal/dog.d -w -de
</pre>

<p>Instead of having to mention the modules individually every time on the command line, they can be combined as libraries.
</p>

<h5 class="subsection"><a id="ix_Modules and Libraries.library" content="library"></a> Libraries</h5>

<p>A collection of compiled modules is called a library. Libraries are not programs themselves; they do not have the <code class="d_inline">main()</code> function. Libraries contain compiled definitions of functions, structs, classes, and other features of modules, which are to be linked later by the linker to produce the program.
</p>

<p>dmd's <code class="d_inline">-lib</code> command line option is for making libraries. The following command makes a library that contains the "cat.d" and the "dog.d" modules. The name of the library is specified with the <code class="d_inline">-of</code> switch:
</p>

<pre class="shell">$ dmd animal/cat.d animal/dog.d -lib -ofanimal -w -de
</pre>

<p>The actual name of the library file depends on the platform. For example, the extension of library files is <code class="d_inline">.a</code> under Linux systems: <code class="d_inline">animal.a</code>.
</p>

<p>Once that library is built, It is not necessary to specify the "animal/cat.d" and "animal/dog.d" modules individually anymore. The library file is sufficient:
</p>

<pre class="shell">$ dmd deneme.d animal.a -w -de
</pre>

<p>The command above replaces the following one:
</p>

<pre class="shell">$ dmd deneme.d animal/cat.d animal/dog.d -w -de
</pre>

<p><a id="ix_Modules and Libraries.Phobos, library" content="Phobos, library"></a> As an exception, the D standard library Phobos need not be specified on the command line. That library is automatically included behind the scenes. Otherwise, it could be specified similar to the following line:
</p>

<pre class="shell">$ dmd deneme.d animal.a /usr/lib64/libphobos2.a -w -de
</pre>

<p><i><b>Note:</b> The name and location of the Phobos library may be different on different systems.</i>
</p>

<h6>Using libraries of other languages</h6>

<p>D can use libraries that are written in some other compiled languages like C and C++. However, because different languages use different <i>linkages</i>, such libraries are available to D code only through their <i>D bindings</i>.
</p>

<p><a id="ix_Modules and Libraries.linkage" content="linkage"></a> <a id="ix_Modules and Libraries.name mangling" content="name mangling"></a> <a id="ix_Modules and Libraries.mangling, name" content="mangling, name"></a> <a id="ix_Modules and Libraries.symbol" content="symbol"></a> Linkage is the set of rules that determines the accessibility of entities in a library as well as how the names (symbols) of those entities are represented in compiled code. The names in compiled code are different from the names that the programmer writes in source code: The compiled names are <i>name-mangled</i> according to the rules of a particular language or compiler.
</p>

<p><a id="ix_Modules and Libraries.mangle, core.demangle" content="mangle, core.demangle"></a> <a id="ix_Modules and Libraries.demangle" content="demangle"></a> For example, according to C linkage, the C function name <code class="d_inline">foo</code> would be <i>mangled</i> with a leading underscore as <code class="d_inline">_foo</code> in compiled code. Name-mangling is more complex in languages like C++ and D because these languages allow using the same name for different entities in different modules, structs, classes, etc. as well as for overloads of functions. A D function named <code class="d_inline">foo</code> in source code has to be mangled in a way that would differentiate it from all other <code class="d_inline">foo</code> names that can exist in a program. Although the exact mangled names are usually not important to the programmer, the <code class="d_inline">core.demangle</code> module can be used to mangle and demangle symbols:
</p>

<pre class="d_code"><span class="d_keyword">module</span> deneme;

<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> core.demangle;

<span class="d_keyword">void</span> foo() {
}

<span class="d_keyword">void</span> main() {
    writeln(<span class="hilite">mangle</span>!(<span class="d_keyword">typeof</span>(foo))(<span class="d_string">"deneme.foo"</span>));
}
</pre>

<p><i><b>Note:</b> <code class="d_inline">mangle()</code> is a function template, the syntax of which is unfamiliar at this point in the book. We will see templates later in <a href="templates.html">the Templates chapter</a>.</i>
</p>

<p>A function that has the same type as <code class="d_inline">foo</code> above and is named as <code class="d_inline">deneme.foo</code>, has the following mangled name in compiled code:
</p>

<pre class="shell">_D6deneme3fooFZv
</pre>

<p>Name mangling is the reason why linker error messages cannot include user-friendly names. For example, a symbol in an error message above was <code class="d_inline">_D6animal3cat3Cat7__ClassZ</code> instead of <code class="d_inline">animal.cat.Cat</code>.
</p>

<p><a id="ix_Modules and Libraries.extern()" content="extern()"></a> <a id="ix_Modules and Libraries.C" content="C"></a> <a id="ix_Modules and Libraries.C++" content="C++"></a> <a id="ix_Modules and Libraries.D" content="D"></a> <a id="ix_Modules and Libraries.Objective-C" content="Objective-C"></a> <a id="ix_Modules and Libraries.Pascal" content="Pascal"></a> <a id="ix_Modules and Libraries.System" content="System"></a> <a id="ix_Modules and Libraries.Windows" content="Windows"></a> The <code class="d_inline">extern()</code> attribute specifies the linkage of entities. The valid linkage types that can be used with <code class="d_inline">extern()</code> are <code class="d_inline">C</code>, <code class="d_inline">C++</code>, <code class="d_inline">D</code>, <code class="d_inline">Objective-C</code>, <code class="d_inline">Pascal</code>, <code class="d_inline">System</code>, and <code class="d_inline">Windows</code>. For example, when a D code needs to make a call to a function that is defined in a C library, that function must be declared as having C linkage:
</p>

<pre class="d_code"><span class="d_comment">// Declaring that 'foo' has C linkage (e.g. it may be defined
</span><span class="d_comment">// in a C library):
</span><span class="hilite"><span class="d_keyword">extern</span>(C)</span> <span class="d_keyword">void</span> foo();

<span class="d_keyword">void</span> main() {
    foo();  <span class="d_comment">// this call would be compiled as a call to '_foo'
</span>}
</pre>

<p><a id="ix_Modules and Libraries.namespace, C++" content="namespace, C++"></a> In the case of C++ linkage, the namespace that a name is defined in is specified as the second argument to the <code class="d_inline">extern()</code> attribute. For example, according to the following declaration, <code class="d_inline">bar()</code> is the declaration of the function <code class="d_inline">a::b::c::bar()</code> defined in a C++ library (note that D code uses dots instead of colons):
</p>

<pre class="d_code"><span class="d_comment">// Declaring that 'bar' is defined inside namespace a::b::c
</span><span class="d_comment">// and that it has C++ linkage:
</span><span class="d_keyword">extern</span>(C++, <span class="hilite">a.b.c</span>) <span class="d_keyword">void</span> bar();

<span class="d_keyword">void</span> main() {
    bar();          <span class="d_comment">// a call to a::b::c::bar()
</span>    a.b.c.bar();    <span class="d_comment">// same as above
</span>}
</pre>

<p><a id="ix_Modules and Libraries.binding" content="binding"></a> A file that contains such D declarations of the features of an external library is called a <i>D binding</i> of that library. Fortunately, in most cases programmers do not need to write them from scratch as D bindings for many popular non-D libraries are available through <a href="https://github.com/D-Programming-Deimos/">the Deimos project</a>.
</p>

<p><a id="ix_Modules and Libraries.extern" content="extern"></a> When used without a linkage type, the <code class="d_inline">extern</code> attribute has a different meaning: It specifies that the storage for a variable is the responsibility of an external library; the D compiler should not reserve space for it in this module. Having different meanings, <code class="d_inline">extern</code> and <code class="d_inline">extern()</code> can be used together:
</p>

<pre class="d_code"><span class="d_comment">// Declaring that the storage for 'g_variable' is already
</span><span class="d_comment">// defined in a C library:
</span><span class="d_keyword">extern</span>(C) <span class="hilite"><span class="d_keyword">extern</span></span> <span class="d_keyword">int</span> g_variable;
</pre>

<p>If the <code class="d_inline">extern</code> attribute were not specified above, while having C linkage, <code class="d_inline">g_variable</code> would be a variable of this D module.
</p>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 21:19:10 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

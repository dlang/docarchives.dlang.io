
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>More Functions - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='More Functions' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BMore Functions%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/functions_more.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>More Functions</h1>
        
        



<p>Functions have been covered in the following chapters so far in the book:
</p>

<ul><li><a href="functions.html">Functions</a></li>

<li><a href="function_parameters.html">Function Parameters</a></li>

<li><a href="function_overloading.html">Function Overloading</a></li>

<li><a href="lambda.html">Function Pointers, Delegates, and Lambdas</a></li>

</ul>

<p>This chapter will cover more features of functions.
</p>

<h5 class="subsection">Return type attributes</h5>

<p>Functions can be marked as <code class="d_inline">auto</code>, <code class="d_inline">ref</code>, <code class="d_inline">inout</code>, and <code class="d_inline">auto ref</code>. These attributes are about return types of functions.
</p>

<h6><a id="ix_More Functions.auto, return type" content="auto, return type"></a> <a id="ix_More Functions.auto function" content="auto function"></a> <code class="d_inline">auto</code> functions</h6>

<p>The return types of <code class="d_inline">auto</code> functions need not be specified:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">auto</span></span> add(<span class="d_keyword">int</span> first, <span class="d_keyword">double</span> second) {
    <span class="d_keyword">double</span> result = first + second;
    <span class="d_keyword">return</span> result;
}
</pre>

<p>The return type is deduced by the compiler from the <code class="d_inline">return</code> expression. Since the type of <code class="d_inline">result</code> is <code class="d_inline">double</code>, the return type of <code class="d_inline">add()</code> is <code class="d_inline">double</code>.
</p>

<p>If there are more than one <code class="d_inline">return</code> statement, then the return type of the function is their <i>common type</i>. (We have seen common type in <a href="ternary.html">the Ternary Operator ?: chapter</a>.) For example, because the common type of <code class="d_inline">int</code> and <code class="d_inline">double</code> is <code class="d_inline">double</code>, the return type of the following <code class="d_inline">auto</code> function is <code class="d_inline">double</code> as well:
</p>

<pre class="d_code"><span class="d_keyword">auto</span> func(<span class="d_keyword">int</span> i) {
    <span class="d_keyword">if</span> (i &lt; 0) {
        <span class="d_keyword">return</span> i;      <span class="d_comment">// returns 'int' here
</span>    }

    <span class="d_keyword">return</span> i * 1.5;    <span class="d_comment">// returns 'double' here
</span>}

<span class="d_keyword">void</span> main() {
    <span class="d_comment">// The return type of the function is 'double'
</span>    <span class="d_keyword">auto</span> result = func(42);
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(result) == <span class="hilite"><span class="d_keyword">double</span></span>));
}
</pre>

<h6><a id="ix_More Functions.ref, return type" content="ref, return type"></a> <code class="d_inline">ref</code> functions</h6>

<p>Normally, the expression that is returned from a function is copied to the caller's context. <code class="d_inline">ref</code> specifies that the expression should be returned by-reference instead.
</p>

<p>For example, the following function returns the greater of its two parameters:
</p>

<pre class="d_code"><span class="d_keyword">int</span> greater(<span class="d_keyword">int</span> first, <span class="d_keyword">int</span> second) {
    <span class="d_keyword">return</span> (first &gt; second) ? first : second;
}
</pre>

<p>Normally, both the parameters and the return value of that function are copied:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span> a = 1;
    <span class="d_keyword">int</span> b = 2;
    <span class="d_keyword">int</span> result = greater(a, b);
    result += 10;                <span class="d_comment">// ← neither a nor b changes
</span>    writefln(<span class="d_string">"a: %s, b: %s, result: %s"</span>, a, b, result);
}
</pre>

<p>Because the return value of <code class="d_inline">greater()</code> is copied to <code class="d_inline">result</code>, adding to <code class="d_inline">result</code> affects only that variable; neither <code class="d_inline">a</code> nor <code class="d_inline">b</code> changes:
</p>

<pre class="shell">a: 1, b: 2, result: 12
</pre>

<p><code class="d_inline">ref</code> parameters are passed by references instead of being copied. The same keyword has the same effect on return values:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">int</span> greater(<span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">int</span> first, <span class="hilite"><span class="d_keyword">ref</span></span> <span class="d_keyword">int</span> second) {
    <span class="d_keyword">return</span> (first &gt; second) ? first : second;
}
</pre>

<p>This time, the returned reference would be an alias to one of the arguments and mutating the returned reference would modify either <code class="d_inline">a</code> or <code class="d_inline">b</code>:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> a = 1;
    <span class="d_keyword">int</span> b = 2;
    greater(a, b) += 10;         <span class="d_comment">// ← either a or b changes
</span>    writefln(<span class="d_string">"a: %s, b: %s"</span>, a, b);
</pre>

<p>Note that the returned reference is incremented directly. As a result, the greater of the two arguments changes:
</p>

<pre class="shell">a: 1, b: <span class="hilite">12</span>
</pre>

<p><a id="ix_More Functions.pointer" content="pointer"></a> <a id="ix_More Functions.local variable" content="local variable"></a> <a id="ix_More Functions.variable, local" content="variable, local"></a> <b>Local reference requires a pointer:</b> An important point is that although the return type is marked as <code class="d_inline">ref</code>, <code class="d_inline">a</code> and <code class="d_inline">b</code> would still not change if the return value were assigned to a local variable:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> result = greater(a, b);
    result += 10;                <span class="d_comment">// ← only result changes
</span></pre>

<p>Although <code class="d_inline">greater()</code> returns a reference to <code class="d_inline">a</code> or <code class="d_inline">b</code>, that reference gets copied to the local variable <code class="d_inline">result</code>, and again neither <code class="d_inline">a</code> nor <code class="d_inline">b</code> changes:
</p>

<pre class="shell">a: 1, b: 2, result: 12
</pre>

<p>For <code class="d_inline">result</code> be a reference to <code class="d_inline">a</code> or <code class="d_inline">b</code>, it has to be defined as a pointer:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> <span class="hilite">*</span> result = <span class="hilite">&amp;</span>greater(a, b);
    <span class="hilite">*</span>result += 10;
    writefln(<span class="d_string">"a: %s, b: %s, result: %s"</span>, a, b, <span class="hilite">*</span>result);
</pre>

<p>This time <code class="d_inline">result</code> would be a reference to either <code class="d_inline">a</code> or <code class="d_inline">b</code> and the mutation through it would affect the actual variable:
</p>

<pre class="shell">a: 1, b: <span class="hilite">12</span>, result: 12
</pre>

<p><b>It is not possible to return a reference to a local variable:</b> The <code class="d_inline">ref</code> return value is an alias to one of the arguments that start their lives even before the function is called. That means, regardless of whether a reference to <code class="d_inline">a</code> or <code class="d_inline">b</code> is returned, the returned reference refers to a variable that is still alive.
</p>

<p>Conversely, it is not possible to return a reference to a variable that is not going to be alive upon leaving the function:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">ref</span></span> string parenthesized(string phrase) {
    string result = '(' ~ phrase ~ ')';
    <span class="d_keyword">return</span> result;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
} <span class="d_comment">// ← the lifetime of result ends here
</span></pre>

<p>The lifetime of local <code class="d_inline">result</code> ends upon leaving the function. For that reason, it is not possible to return a reference to that variable:
</p>

<pre class="shell">Error: escaping <span class="hilite">reference to local variable</span> result
</pre>

<h6><a id="ix_More Functions.auto ref, return type" content="auto ref, return type"></a> <code class="d_inline">auto ref</code> functions</h6>

<p><code class="d_inline">auto ref</code> helps with functions like <code class="d_inline">parenthesized()</code> above. Similar to <code class="d_inline">auto</code>, the return type of an <code class="d_inline">auto ref</code> function is deduced by the compiler. Additionally, if the returned expression can be a reference, that variable is returned by reference as opposed to being copied.
</p>

<p><code class="d_inline">parenthesized()</code> can be compiled if the return type is <code class="d_inline">auto ref</code>:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span></span> string parenthesized(string phrase) {
    string result = '(' ~ phrase ~ ')';
    <span class="d_keyword">return</span> result;                  <span class="d_comment">// ← compiles
</span>}
</pre>

<p>The very first <code class="d_inline">return</code> statement of the function determines whether the function returns a copy or a reference.
</p>

<p><code class="d_inline">auto ref</code> is more useful in function templates where template parameters may be references or copies depending on context.
</p>

<h6><a id="ix_More Functions.inout, return type" content="inout, return type"></a> <code class="d_inline">inout</code> functions</h6>

<p>The <code class="d_inline">inout</code> keyword appears for parameter and return types of functions. It works like a template for <code class="d_inline">const</code>, <code class="d_inline">immutable</code>, and <i>mutable</i>.
</p>

<p>Let's rewrite the previous function as taking <code class="d_inline">string</code> (i.e. <code class="d_inline">immutable(char)[]</code>) and returning <code class="d_inline">string</code>:
</p>

<pre class="d_code">string parenthesized(string phrase) {
    <span class="d_keyword">return</span> '(' ~ phrase ~ ')';
}

<span class="d_comment">// ...
</span>
    writeln(parenthesized(<span class="d_string">"hello"</span>));
</pre>

<p>As expected, the code works with that <code class="d_inline">string</code> argument:
</p>

<pre class="shell">(hello)
</pre>

<p>However, as it works only with <code class="d_inline">immutable</code> strings, the function can be seen as being less useful than it could have been:
</p>

<pre class="d_code">    <span class="d_keyword">char</span>[] m;    <span class="d_comment">// has mutable elements
</span>    m ~= <span class="d_string">"hello"</span>;
    writeln(parenthesized(m));    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<pre class="shell">Error: function deneme.parenthesized (<span class="hilite">string</span> phrase)
is not callable using argument types (<span class="hilite">char[]</span>)
</pre>

<p>The same limitation applies to <code class="d_inline">const(char)[]</code> strings as well.
</p>

<p>One solution for this usability issue is to overload the function for <code class="d_inline">const</code> and <i>mutable</i> strings:
</p>

<pre class="d_code"><span class="d_keyword">char</span>[] parenthesized(<span class="d_keyword">char</span>[] phrase) {
    <span class="d_keyword">return</span> '(' ~ phrase ~ ')';
}

<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[] parenthesized(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[] phrase) {
    <span class="d_keyword">return</span> '(' ~ phrase ~ ')';
}
</pre>

<p>That design would be less than ideal due to the obvious code duplications. Another solution would be to define the function as a template:
</p>

<pre class="d_code">T parenthesized(T)(T phrase) {
    <span class="d_keyword">return</span> '(' ~ phrase ~ ')';
}
</pre>

<p>Although that would work, this time it may be seen as being too flexible and potentially requiring template constraints.
</p>

<p><code class="d_inline">inout</code> is very similar to the template solution. The difference is that not the entire type but just the mutability attribute is deduced from the parameter:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">inout</span></span>(<span class="d_keyword">char</span>)[] parenthesized(<span class="hilite"><span class="d_keyword">inout</span></span>(<span class="d_keyword">char</span>)[] phrase) {
    <span class="d_keyword">return</span> '(' ~ phrase ~ ')';
}
</pre>

<p><code class="d_inline">inout</code> transfers the deduced mutability attribute to the return type.
</p>

<p>When the function is called with  <code class="d_inline">char[]</code>, it gets compiled as if <code class="d_inline">inout</code> is not specified at all. On the other hand, when called with <code class="d_inline">immutable(char)[]</code> or <code class="d_inline">const(char)[]</code>, <code class="d_inline">inout</code> means <code class="d_inline">immutable</code> or <code class="d_inline">const</code>, respectively.
</p>

<p>The following code demonstrates this by printing the type of the returned expression:
</p>

<pre class="d_code">    <span class="d_keyword">char</span>[] m;
    writeln(<span class="d_keyword">typeof</span>(parenthesized(m)).stringof);

    <span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[] c;
    writeln(<span class="d_keyword">typeof</span>(parenthesized(c)).stringof);

    <span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)[] i;
    writeln(<span class="d_keyword">typeof</span>(parenthesized(i)).stringof);
</pre>

<p>The output:
</p>

<pre class="shell">char[]
const(char)[]
string
</pre>

<h5 class="subsection">Behavioral attributes</h5>

<p><code class="d_inline">pure</code>, <code class="d_inline">nothrow</code>, and <code class="d_inline">@nogc</code> are about function behaviors.
</p>

<h6><a id="ix_More Functions.pure" content="pure"></a> <code class="d_inline">pure</code> functions</h6>

<p>As we have seen in <a href="functions.html">the Functions chapter</a>, functions can produce return values and side effects. When possible, return values should be preferred over side effects because functions that do not have side effects are easier to make sense of, which in turn helps with program correctness and maintainability.
</p>

<p>A similar concept is the purity of a function. Purity is defined differently in D from most other programming languages: In D, a function that does not access <i>mutable</i> global or <code class="d_inline">static</code> state is pure. (Since input and output streams are considered as mutable global state, pure functions cannot perform input or output operations either.)
</p>

<p>In other words, a function is pure if it produces its return value and side effects only by accessing its parameters, local variables, and <i>immutable</i> global state.
</p>

<p>An important aspect of purity in D is that pure functions can mutate their parameters.
</p>

<p>Additionally, the following operations that mutate the global state of the program are explicitly allowed in pure functions:
</p>

<ul><li>Allocate memory with the <code class="d_inline">new</code> expression</li>
<li>Terminate the program</li>
<li>Access the floating point processing flags</li>
<li>Throw exceptions</li>
</ul>

<p>The <code class="d_inline">pure</code> keyword specifies that a function should behave according to those conditions and the compiler guarantees that it does so.
</p>

<p>Naturally, since impure functions do not provide the same guarantees, a pure function cannot call impure functions.
</p>

<p>The following program demonstrates some of the operations that a pure function can and cannot perform:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.exception;

<span class="d_keyword">int</span> mutableGlobal;
<span class="d_keyword">const</span> <span class="d_keyword">int</span> constGlobal;
<span class="d_keyword">immutable</span> <span class="d_keyword">int</span> immutableGlobal;

<span class="d_keyword">void</span> impureFunction() {
}

<span class="d_keyword">int</span> pureFunction(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> i, <span class="d_keyword">int</span>[] slice) <span class="hilite"><span class="d_keyword">pure</span></span> {
    <span class="d_comment">// Can throw exceptions:
</span>    enforce(slice.length &gt;= 1);

    <span class="d_comment">// Can mutate its parameters:
</span>    i = 42;
    slice[0] = 43;

    <span class="d_comment">// Can access immutable global state:
</span>    i = constGlobal;
    i = immutableGlobal;

    <span class="d_comment">// Can use the new expression:
</span>    <span class="d_keyword">auto</span> p = <span class="d_keyword">new</span> <span class="d_keyword">int</span>;

    <span class="d_comment">// Cannot access mutable global state:
</span>    i = mutableGlobal;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>

    <span class="d_comment">// Cannot perform input and output operations:
</span>    writeln(i);           <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>

    <span class="d_keyword">static</span> <span class="d_keyword">int</span> mutableStatic;

    <span class="d_comment">// Cannot access mutable static state:
</span>    i = mutableStatic;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>

    <span class="d_comment">// Cannot call impure functions:
</span>    impureFunction();     <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>

    <span class="d_keyword">return</span> 0;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span> i;
    <span class="d_keyword">int</span>[] slice = [ 1 ];
    pureFunction(i, slice);
}
</pre>

<p>Although they are allowed to, some pure functions do not mutate their parameters. Following from the rules of purity, the only observable effect of such a function would be its return value. Further, since the function cannot access any mutable global state, the return value would be the same for a given set of arguments, regardless of when and how many times the function is called during the execution of the program. This fact gives both the compiler and the programmer optimization opportunities. For example, instead of calling the function a second time for a given set of arguments, its return value from the first call can be cached and used instead of actually calling the function again.
</p>

<p><a id="ix_More Functions.inference, pure attribute" content="inference, pure attribute"></a> <a id="ix_More Functions.attribute inference, pure" content="attribute inference, pure"></a> Since the exact code that gets generated for a template instantiation depends on the actual template arguments, whether the generated code is pure depends on the arguments as well. For that reason, the purity of a template is inferred by the compiler from the generated code. (The <code class="d_inline">pure</code> keyword can still be specified by the programmer.) Similarly, the purity of an <code class="d_inline">auto</code> function is inferred.
</p>

<p>As a simple example, since the following function template would be impure when <code class="d_inline">N</code> is zero, it would not be possible to call <code class="d_inline">templ!0()</code> from a pure function:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_comment">// This template is impure when N is zero
</span><span class="d_keyword">void</span> templ(size_t N)() {
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (N == 0) {
        <span class="d_comment">// Prints when N is zero:
</span>        writeln(<span class="d_string">"zero"</span>);
    }
}

<span class="d_keyword">void</span> foo() <span class="hilite"><span class="d_keyword">pure</span></span> {
    templ!0();    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}

<span class="d_keyword">void</span> main() {
    foo();
}
</pre>

<p>The compiler infers that the <code class="d_inline">0</code> instantiation of the template is impure and rejects calling it from the pure function <code class="d_inline">foo()</code>:
</p>

<pre class="shell">Error: pure function 'deneme.foo' <span class="hilite">cannot call impure function</span>
'deneme.templ!0.templ'
</pre>

<p>However, since the instantiation of the template for values other than zero is pure, the program can be compiled for such values:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo() <span class="hilite"><span class="d_keyword">pure</span></span> {
    templ!1();    <span class="d_comment">// ← compiles
</span>}
</pre>

<p>We have seen earlier above that input and output functions like <code class="d_inline">writeln()</code> cannot be used in pure functions because they access global state. Sometimes such limitations are too restrictive e.g. when needing to print a message temporarily during debugging. For that reason, the purity rules are relaxed for code that is marked as <code class="d_inline">debug</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">debug</span> size_t fooCounter;

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> i) <span class="hilite"><span class="d_keyword">pure</span></span> {
    <span class="hilite"><span class="d_keyword">debug</span></span> ++fooCounter;

    <span class="d_keyword">if</span> (i == 0) {
        <span class="hilite"><span class="d_keyword">debug</span></span> writeln(<span class="d_string">"i is zero"</span>);
        i = 42;
    }

    <span class="d_comment">// ...
</span>}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">foreach</span> (i; 0..100) {
        <span class="d_keyword">if</span> ((i % 10) == 0) {
            foo(i);
        }
    }

    <span class="d_keyword">debug</span> writefln(<span class="d_string">"foo is called %s times"</span>, fooCounter);
}
</pre>

<p>The pure function above mutates the global state of the program by modifying a global variable and printing a message. Despite those impure operations, it still can be compiled because those operations are marked as <code class="d_inline">debug</code>.
</p>

<p><i><b>Note:</b> Remember that those statements are included in the program only if the program is compiled with the <code class="d_inline">-debug</code> command line switch.</i>
</p>

<p>Member functions can be marked as <code class="d_inline">pure</code> as well. Subclasses can override impure functions as <code class="d_inline">pure</code> but the reverse is not allowed:
</p>

<pre class="d_code"><span class="d_keyword">interface</span> Iface {
    <span class="d_keyword">void</span> foo() <span class="d_keyword">pure</span>;    <span class="d_comment">// Subclasses must define foo as pure.
</span>
    <span class="d_keyword">void</span> bar();         <span class="d_comment">// Subclasses may define bar as pure.
</span>}

<span class="d_keyword">class</span> Class : Iface {
    <span class="d_keyword">void</span> foo() <span class="d_keyword">pure</span> {   <span class="d_comment">// Required to be pure
</span>        <span class="d_comment">// ...
</span>    }

    <span class="d_keyword">void</span> bar() <span class="d_keyword">pure</span> {   <span class="d_comment">// pure although not required
</span>        <span class="d_comment">// ...
</span>    }
}
</pre>

<p>Delegates and anonymous functions can be pure as well. Similar to templates, whether a function or delegate literal, or <code class="d_inline">auto</code> function is pure is inferred by the compiler:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">double</span>) <span class="hilite"><span class="d_keyword">pure</span></span> dg) {
    <span class="d_keyword">int</span> i = dg(1.5);
}

<span class="d_keyword">void</span> main() {
    foo(a =&gt; 42);                <span class="d_comment">// ← compiles
</span>
    foo((a) {                    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
            writeln(<span class="d_string">"hello"</span>);
            <span class="d_keyword">return</span> 42;
        });
}
</pre>

<p><code class="d_inline">foo()</code> above requires that its parameter be a pure delegate. The compiler infers that the lambda <code class="d_inline">a&nbsp;=&gt;&nbsp;42</code> is pure and allows it as an argument for <code class="d_inline">foo()</code>. However, since the other delegate is impure it cannot be passed to <code class="d_inline">foo()</code>:
</p>

<pre class="shell">Error: function deneme.foo (int delegate(double) <span class="hilite">pure</span> dg)
is <span class="hilite">not callable</span> using argument types (void)
</pre>

<p>One benefit of <code class="d_inline">pure</code> functions is that their return values can be used to initialize <code class="d_inline">immutable</code> variables. Although the array produced by <code class="d_inline">makeNumbers()</code> below is mutable, it is not possible for its elements to be changed by any code outside of that function. For that reason, the initialization works.
</p>

<pre class="d_code"><span class="d_keyword">int</span>[] makeNumbers() <span class="d_keyword">pure</span> {
    <span class="d_keyword">int</span>[] result;
    result ~= 42;
    <span class="d_keyword">return</span> result;
}

<span class="d_keyword">void</span> main() {
    <span class="hilite"><span class="d_keyword">immutable</span></span> array = makeNumbers();
}
</pre>

<h6><a id="ix_More Functions.nothrow" content="nothrow"></a> <a id="ix_More Functions.throw" content="throw"></a> <code class="d_inline">nothrow</code> functions</h6>

<p>We saw the exception mechanism in <a href="exceptions.html">the Exceptions chapter.</a>
</p>

<p>It would be good practice for functions to document the types of exceptions that they may throw under specific error conditions. However, as a general rule, callers should assume that any function can throw any exception.
</p>

<p>Sometimes it is more important to know that a function does not emit any exception at all. For example, some algorithms can take advantage of the fact that certain of their steps cannot be interrupted by an exception.
</p>

<p><code class="d_inline">nothrow</code> guarantees that a function does not emit any exception:
</p>

<pre class="d_code"><span class="d_keyword">int</span> add(<span class="d_keyword">int</span> lhs, <span class="d_keyword">int</span> rhs) <span class="hilite"><span class="d_keyword">nothrow</span></span> {
    <span class="d_comment">// ...
</span>}
</pre>

<p><i><b>Note:</b> Remember that it is not recommended to catch <code class="d_inline">Error</code> nor its base class <code class="d_inline">Throwable</code>. What is meant here by "any exception" is "any exception that is defined under the <code class="d_inline">Exception</code> hierarchy." A <code class="d_inline">nothrow</code> function can still emit exceptions that are under the <code class="d_inline">Error</code> hierarchy, which represents irrecoverable error conditions that should preclude the program from continuing its execution.</i>
</p>

<p>Such a function can neither throw an exception itself nor can call a function that may throw an exception:
</p>

<pre class="d_code"><span class="d_keyword">int</span> add(<span class="d_keyword">int</span> lhs, <span class="d_keyword">int</span> rhs) <span class="d_keyword">nothrow</span> {
    writeln(<span class="d_string">"adding"</span>);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    <span class="d_keyword">return</span> lhs + rhs;
}
</pre>

<p>The compiler rejects the code because <code class="d_inline">add()</code> violates the no-throw guarantee:
</p>

<pre class="shell">Error: function 'deneme.add' is nothrow yet <span class="hilite">may throw</span>
</pre>

<p>This is because <code class="d_inline">writeln</code> is not (and cannot be) a <code class="d_inline">nothrow</code> function.
</p>

<p><a id="ix_More Functions.inference, nothrow attribute" content="inference, nothrow attribute"></a> <a id="ix_More Functions.attribute inference, nothrow" content="attribute inference, nothrow"></a> The compiler can infer that a function can never emit an exception. The following implementation of <code class="d_inline">add()</code> is <code class="d_inline">nothrow</code> because it is obvious to the compiler that the <code class="d_inline">try-catch</code> block prevents any exception from escaping the function:
</p>

<pre class="d_code"><span class="d_keyword">int</span> add(<span class="d_keyword">int</span> lhs, <span class="d_keyword">int</span> rhs) <span class="d_keyword">nothrow</span> {
    <span class="d_keyword">int</span> result;

    <span class="d_keyword">try</span> {
        writeln(<span class="d_string">"adding"</span>);    <span class="d_comment">// ← compiles
</span>        result = lhs + rhs;

    } <span class="d_keyword">catch</span> (Exception error) {   <span class="d_comment">// catches all exceptions
</span>        <span class="d_comment">// ...
</span>    }

    <span class="d_keyword">return</span> result;
}
</pre>

<p>As mentioned above, <code class="d_inline">nothrow</code> does not include exceptions that are under the <code class="d_inline">Error</code> hierarchy. For example, although accessing an element of an array with <code class="d_inline">[]</code> can throw <code class="d_inline">RangeError</code>, the following function can still be defined as <code class="d_inline">nothrow</code>:
</p>

<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>[] arr, size_t i) <span class="hilite"><span class="d_keyword">nothrow</span></span> {
    <span class="d_keyword">return</span> 10 * arr<span class="hilite">[i]</span>;
}
</pre>

<p>As with purity, the compiler automatically deduces whether a template, delegate, or anonymous function is <code class="d_inline">nothrow</code>.
</p>

<h6><a id="ix_More Functions.@nogc" content="@nogc"></a> <code class="d_inline">@nogc</code> functions</h6>

<p>D is a garbage collected language. Many data structures and algorithms in most D programs take advantage of dynamic memory blocks that are managed by the garbage collector (GC). Such memory blocks are reclaimed again by the GC by an algorithm called <i>garbage collection</i>.
</p>

<p>Some commonly used D operations take advantage of the GC as well. For example, elements of arrays live on dynamic memory blocks:
</p>

<pre class="d_code"><span class="d_comment">// A function that takes advantage of the GC indirectly
</span><span class="d_keyword">int</span>[] append(<span class="d_keyword">int</span>[] slice) {
    slice <span class="hilite">~=</span> 42;
    <span class="d_keyword">return</span> slice;
}
</pre>

<p>If the slice does not have sufficient capacity, the <code class="d_inline">~=</code> operator above allocates a new memory block from the GC.
</p>

<p>Although the GC is a significant convenience for data structures and algorithms, memory allocation and garbage collection are costly operations that make the execution of some programs noticeably slow.
</p>

<p><code class="d_inline">@nogc</code> means that a function cannot use the GC directly or indirectly:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo() <span class="hilite">@nogc</span> {
    <span class="d_comment">// ...
</span>}
</pre>

<p>The compiler guarantees that a <code class="d_inline">@nogc</code> function does not involve GC operations. For example, the following function cannot call <code class="d_inline">append()</code> above, which does not provide the <code class="d_inline">@nogc</code> guarantee:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo() <span class="hilite">@nogc</span> {
    <span class="d_keyword">int</span>[] slice;
    <span class="d_comment">// ...
</span>    append(slice);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}
</pre>

<pre class="shell">Error: @nogc function 'deneme.foo' <span class="hilite">cannot call non-@nogc function</span>
'deneme.append'
</pre>

<h5 class="subsection">Code safety attributes</h5>

<p><a id="ix_More Functions.inference, @safe attribute" content="inference, @safe attribute"></a> <a id="ix_More Functions.attribute inference, @safe" content="attribute inference, @safe"></a> <code class="d_inline">@safe</code>, <code class="d_inline">@trusted</code>, and <code class="d_inline">@system</code> are about the code safety that a function provides. As with purity, the compiler infers the safety level of templates, delegates, anonymous functions, and <code class="d_inline">auto</code> functions.
</p>

<h6><a id="ix_More Functions.@safe" content="@safe"></a> <code class="d_inline">@safe</code> functions</h6>

<p>A class of programming errors involve <i>corrupting</i> data at unrelated locations in memory by writing at those locations unintentionally. Such errors are mostly due to mistakes made in using pointers and applying type casts.
</p>

<p><code class="d_inline">@safe</code> functions guarantee that they do not contain any operation that may corrupt memory. The compiler does not allow the following operations in <code class="d_inline">@safe</code> functions:
</p>

<ul>
<li>Pointers cannot be converted to other pointer types other than <code class="d_inline">void*</code>.</li>

<li>A non-pointer expression cannot be converted to a pointer value.</li>

<li>Pointer values cannot be changed (no pointer <i>arithmetic</i>; however, assigning a pointer to another pointer of the same type is safe).</li>

<li>Unions that have pointer or reference members cannot be used.</li>

<li>Functions marked as <code class="d_inline">@system</code> cannot be called.</li>

<li>Exceptions that are not descended from <code class="d_inline">Exception</code> cannot be caught.</li>

<li><i>Inline assembler</i> cannot be used.</li>

<li><i>Mutable</i> variables cannot be cast to <code class="d_inline">immutable</code>.</li>

<li><code class="d_inline">immutable</code> variables cannot be cast to <i>mutable</i>.</li>

<li>Thread-local variables cannot be cast to <code class="d_inline">shared</code>.</li>

<li><code class="d_inline">shared</code> variables cannot be cast to thread-local.</li>

<li>Addresses of function-local variables cannot be taken.</li>

<li><code class="d_inline">__gshared</code> variables cannot be accessed.</li>

</ul>

<h6><a id="ix_More Functions.@trusted" content="@trusted"></a> <code class="d_inline">@trusted</code> functions</h6>

<p>Some functions may actually be safe but cannot be marked as <code class="d_inline">@safe</code> for various reasons. For example, a function may have to call a library written in C, where no language support exists for safety in that language.
</p>

<p>Some other functions may actually perform operations that are not allowed in <code class="d_inline">@safe</code> code, but may be well tested and <i>trusted</i> to be correct.
</p>

<p><code class="d_inline">@trusted</code> is an attribute that communicates to the compiler that <i>although the function cannot be marked as <code class="d_inline">@safe</code>, consider it safe</i>. The compiler trusts the programmer and treats <code class="d_inline">@trusted</code> code as if it is safe. For example, it allows <code class="d_inline">@safe</code> code to call <code class="d_inline">@trusted</code> code.
</p>

<h6><a id="ix_More Functions.@system" content="@system"></a> <code class="d_inline">@system</code> functions</h6>

<p>Any function that is not marked as <code class="d_inline">@safe</code> or <code class="d_inline">@trusted</code> is considered <code class="d_inline">@system</code>, which is the default safety attribute.
</p>

<h5 class="subsection"><a id="ix_More Functions.CTFE" content="CTFE"></a> <a id="ix_More Functions.compile time function execution" content="compile time function execution"></a> Compile time function execution (CTFE)</h5>

<p>In many programming languages, computations that are performed at compile time are very limited. Such computations are usually as simple as calculating the length of a fixed-length array or simple arithmetic operations:
</p>

<pre class="d_code">    writeln(1 + 2);
</pre>

<p>The <code class="d_inline">1&nbsp;+&nbsp;2</code> expression above is compiled as if it has been written as <code class="d_inline">3</code>; there is no computation at runtime.
</p>

<p>D has CTFE, which allows any function to be executed at compile time as long as it is possible to do so.
</p>

<p>Let's consider the following program that prints a menu to the output:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.range;

string menuLines(string[] choices) {
    string result;

    <span class="d_keyword">foreach</span> (i, choice; choices) {
        result ~= format(<span class="d_string">" %s. %s\n"</span>, i + 1, choice);
    }

    <span class="d_keyword">return</span> result;
}

string menu(string title,
            string[] choices,
            size_t width) {
    <span class="d_keyword">return</span> format(<span class="d_string">"%s\n%s\n%s"</span>,
                  title.center(width),
                  '='.repeat(width),    <span class="d_comment">// horizontal line
</span>                  menuLines(choices));
}

<span class="d_keyword">void</span> main() {
    <span class="hilite"><span class="d_keyword">enum</span></span> drinks =
        menu(<span class="d_string">"Drinks"</span>,
             [ <span class="d_string">"Coffee"</span>, <span class="d_string">"Tea"</span>, <span class="d_string">"Hot chocolate"</span> ], 20);

    writeln(drinks);
}
</pre>

<p>Although the same result can be achieved in different ways, the program above performs non-trivial operations to produce the following <code class="d_inline">string</code>:
</p>

<pre class="shell">       Drinks       
====================
 1. Coffee
 2. Tea
 3. Hot chocolate
</pre>

<p>Remember that the initial value of <code class="d_inline">enum</code> constants like <code class="d_inline">drinks</code> must be known at compile time. That fact is sufficient for <code class="d_inline">menu()</code> to be executed at compile time. The value that it returns at compile time is used as the initial value of <code class="d_inline">drinks</code>. As a result, the program is compiled as if that value is written explicitly in the program:
</p>

<pre class="d_code">    <span class="d_comment">// The equivalent of the code above:
</span>    <span class="d_keyword">enum</span> drinks = <span class="d_string">"       Drinks       \n"</span>
                  <span class="d_string">"====================\n"</span>
                  <span class="d_string">" 1. Coffee\n"</span>
                  <span class="d_string">" 2. Tea\n"</span>
                  <span class="d_string">" 3. Hot chocolate\n"</span>;
</pre>

<p>For a function to be executed at compile time, it must appear in an expression that in fact is needed at compile time:
</p>

<ul><li>Initializing a <code class="d_inline">static</code> variable</li>
<li>Initializing an <code class="d_inline">enum</code> variable</li>
<li>Calculating the length of a fixed-length array</li>
<li>Calculating a template <i>value</i> argument</li>
</ul>

<p>Clearly, it would not be possible to execute every function at compile time. For example, a function that accesses a global variable cannot be executed at compile time because the global variable does not start its life until run time. Similarly, since <code class="d_inline">stdout</code> is available only at run time, functions that print cannot be executed at compile time.
</p>

<h6><a id="ix_More Functions.__ctfe" content="__ctfe"></a> The <code class="d_inline">__ctfe</code> variable</h6>

<p>It is a powerful aspect of CTFE that the same function is used for both compile time and run time depending on when its result is needed. Although the function need not be written in any special way for CTFE, some operations in the function may make sense only at compile time or run time. The special variable <code class="d_inline">__ctfe</code> can be used to differentiate the code that are only for compile time or only for run time. The value of this variable is <code class="d_inline">true</code> when the function is being executed for CTFE, <code class="d_inline">false</code> otherwise:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

size_t counter;

<span class="d_keyword">int</span> foo() {
    <span class="d_keyword">if</span> (!<span class="hilite">__ctfe</span>) {
        <span class="d_comment">// This code is for execution at run time
</span>        ++counter;
    }

    <span class="d_keyword">return</span> 42;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">enum</span> i = foo();
    <span class="d_keyword">auto</span> j = foo();
    writefln(<span class="d_string">"foo is called %s times."</span>, counter);
}
</pre>

<p>As <code class="d_inline">counter</code> lives only at run time, it cannot be incremented at compile time. For that reason, the code above attempts to increment it only for run-time execution. Since the value of <code class="d_inline">i</code> is determined at compile time and the value of <code class="d_inline">j</code> is determined at run time, <code class="d_inline">foo()</code> is reported to have been called just once during the execution of the program:
</p>

<pre class="shell">foo is called 1 times.
</pre>

<h5 class="subsection">Summary</h5>

<ul>
<li>The return type of an <code class="d_inline">auto</code> function is deduced automatically.</li>

<li>The return value of a <code class="d_inline">ref</code> function is a reference to an existing variable.</li>

<li>The return value of an <code class="d_inline">auto ref</code> function is a reference if possible, a copy otherwise.</li>

<li><code class="d_inline">inout</code> carries the <code class="d_inline">const</code>, <code class="d_inline">immutable</code>, or <i>mutable</i> attribute of the parameter to the return type.</li>

<li>A <code class="d_inline">pure</code> function cannot access <i>mutable</i> global or static state. The compiler infers the purity of templates, delegates, anonymous functions, and <code class="d_inline">auto</code> functions.</li>

<li><code class="d_inline">nothrow</code> functions cannot emit exceptions. The compiler infers whether a template, delegate, anonymous function, or <code class="d_inline">auto</code> function is no-throw.</li>

<li><code class="d_inline">@nogc</code> functions cannot involve GC operations.</li>

<li><code class="d_inline">@safe</code> functions cannot corrupt memory. The compiler infers the safety attributes of templates, delegates, anonymous functions, and <code class="d_inline">auto</code> functions.</li>

<li><code class="d_inline">@trusted</code> functions are indeed safe but cannot be specified as such; they are considered <code class="d_inline">@safe</code> both by the programmer and the compiler.</li>

<li><code class="d_inline">@system</code> functions can use every D feature. <code class="d_inline">@system</code> is the default safety attribute.</li>

<li>Functions can be executed at compile time as well (CTFE). This can be differentiated by the value of the special variable <code class="d_inline">__ctfe</code>.</li>

</ul>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 21:19:11 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

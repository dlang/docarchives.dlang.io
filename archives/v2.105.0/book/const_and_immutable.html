
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Immutability - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Immutability' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BImmutability%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/const_and_immutable.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Immutability</h1>
        
        



<p>We have seen that variables represent concepts in programs. The interactions of these concepts are achieved by expressions that change the values of those variables:
</p>

<pre class="d_code">    <span class="d_comment">// Pay the bill
</span>    totalPrice = calculateAmount(itemPrices);
    moneyInWallet <span class="hilite">-=</span> totalPrice;
    moneyAtMerchant <span class="hilite">+=</span> totalPrice;
</pre>

<p>Modifying a variable is called <i>mutating</i> that variable. The concept of mutability is essential for most tasks. However, there are some cases where mutability is not desirable:
</p>

<ul>
<li>Some concepts are immutable by definition. For example, there are always seven days in a week, the math constant <i>pi</i> (π) never changes, the list of natural languages supported by a program may be fixed and small (e.g. only English and Turkish), etc.
</li>

<li>If every variable were modifiable, as we have seen so far, then every piece of code that used a variable could potentially modify it. Even if there was no reason to modify a variable in an operation there would be no guarantee that this would not happen by accident. Programs are difficult to read and maintain when there are no immutability guarantees.

<p>For example, consider a function call <code class="d_inline">retire(office, worker)</code> that retires a worker of an office. If both of those variables were mutable it would not be clear (just by looking at that function call) which of them would be modified by the function. It may be expected that the number of active employees of <code class="d_inline">office</code> would be decreased, but would the function call also modify <code class="d_inline">worker</code> in some way?
</p>

</li>

</ul>

<p>The concept of immutability helps with understanding parts of programs by guaranteeing that certain operations do not change certain variables. It also reduces the risk of some types of programming errors.
</p>

<p>The <i>immutability</i> concept is expressed in D by the <code class="d_inline">const</code> and <code class="d_inline">immutable</code> keywords. Although the two words themselves are close in meaning, their responsibilities in programs are different and they are sometimes incompatible.
</p>

<p><a id="ix_Immutability.type qualifier" content="type qualifier"></a> <a id="ix_Immutability.qualifier, type" content="qualifier, type"></a> <code class="d_inline">const</code>, <code class="d_inline">immutable</code>, <code class="d_inline">inout</code>, and <code class="d_inline">shared</code> are <i>type qualifiers</i>. (We will see <a href="function_parameters.html"><code class="d_inline">inout</code></a> and <a href="concurrency_shared.html"><code class="d_inline">shared</code></a> in later chapters.)
</p>

<h5 class="subsection">Immutable variables</h5>

<p>Both of the terms "immutable variable" and "constant variable" are nonsensical when the word "variable" is taken literally to mean <i>something that changes</i>. In a broader sense, the word "variable" is often understood to mean any concept of a program which may be mutable or immutable.
</p>

<p>There are three ways of defining variables that can never be mutated.
</p>

<h6><a id="ix_Immutability.enum" content="enum"></a> <code class="d_inline">enum</code> constants</h6>

<p>We have seen earlier in the <a href="enum.html"><code class="d_inline">enum</code> chapter</a> that <code class="d_inline">enum</code> defines named constant values:
</p>

<pre class="d_code">    <span class="d_keyword">enum</span> fileName = <span class="d_string">"list.txt"</span>;
</pre>

<p>As long as their values can be determined at compile time, <code class="d_inline">enum</code> variables can be initialized with return values of functions as well:
</p>

<pre class="d_code"><span class="d_keyword">int</span> totalLines() {
    <span class="d_keyword">return</span> 42;
}

<span class="d_keyword">int</span> totalColumns() {
    <span class="d_keyword">return</span> 7;
}

string name() {
    <span class="d_keyword">return</span> <span class="d_string">"list"</span>;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">enum</span> fileName = name() ~ <span class="d_string">".txt"</span>;
    <span class="d_keyword">enum</span> totalSquares = totalLines() * totalColumns();
}
</pre>

<p>The D feature that enables such initialization is <i>compile time function execution</i> (CTFE), which we will see in <a href="functions_more.html">a later chapter</a>.
</p>


<p>As expected, the values of <code class="d_inline">enum</code> constants cannot be modified:
</p>

<pre class="d_code">    ++totalSquares;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>Although it is a very effective way of representing immutable values, <code class="d_inline">enum</code> can only be used for compile-time values.
</p>

<p>An <code class="d_inline">enum</code> constant is <i>a manifest constant</i>, meaning that the program is compiled as if every mention of that constant had been replaced by its value. As an example, let's consider the following <code class="d_inline">enum</code> definition and the two expressions that make use of it:
</p>

<pre class="d_code">    <span class="d_keyword">enum</span> i = 42;
    writeln(i);
    foo(i);
</pre>

<p>The code above is completely equivalent to the one below, where we replace every use of <code class="d_inline">i</code> with its value of <code class="d_inline">42</code>:
</p>

<pre class="d_code">    writeln(42);
    foo(42);
</pre>

<p>Although that replacement makes sense for simple types like <code class="d_inline">int</code> and makes no difference to the resulting program, <code class="d_inline">enum</code> constants can bring a hidden cost when they are used for arrays or associative arrays:
</p>

<pre class="d_code">    <span class="d_keyword">enum</span> a = [ 42, 100 ];
    writeln(a);
    foo(a);
</pre>

<p>After replacing <code class="d_inline">a</code> with its value, the equivalent code that the compiler would be compiling is the following:
</p>

<pre class="d_code">    writeln([ 42, 100 ]); <span class="d_comment">// an array is created at run time
</span>    foo([ 42, 100 ]);     <span class="d_comment">// another array is created at run time
</span></pre>

<p>The hidden cost here is that there would be two separate arrays created for the two expressions above. For that reason, it may make more sense to define arrays and associative arrays as <code class="d_inline">immutable</code> variables if they are going to be used more than once in the program.
</p>

<h6><a id="ix_Immutability.variable, immutable" content="variable, immutable"></a> <code class="d_inline">immutable</code> variables</h6>

<p>Like <code class="d_inline">enum</code>, this keyword specifies that the value of a variable will never change. Unlike <code class="d_inline">enum</code>, an <code class="d_inline">immutable</code> variable is an actual variable with a memory address, which means that we can set its value during the execution of the program and that we can refer to its memory location.
</p>

<p>The following program compares the uses of <code class="d_inline">enum</code> and <code class="d_inline">immutable</code>. The program asks for the user to guess a number that has been picked randomly. Since the random number cannot be determined at compile time, it cannot be defined as an <code class="d_inline">enum</code>. Still, since the randomly picked value must never be changed after having been decided, it is suitable to specify that variable as <code class="d_inline">immutable</code>.
</p>

<p>The program takes advantage of the <code class="d_inline">readInt()</code> function that was defined in the previous chapter:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.random;

<span class="d_keyword">int</span> readInt(string message) {
    <span class="d_keyword">int</span> result;
    write(message, <span class="d_string">"? "</span>);
    readf(<span class="d_string">" %s"</span>, &amp;result);
    <span class="d_keyword">return</span> result;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">enum</span> min = 1;
    <span class="d_keyword">enum</span> max = 10;

    <span class="hilite"><span class="d_keyword">immutable</span></span> number = uniform(min, max + 1);

    writefln(<span class="d_string">"I am thinking of a number between %s and %s."</span>,
             min, max);

    <span class="d_keyword">auto</span> isCorrect = <span class="d_keyword">false</span>;
    <span class="d_keyword">while</span> (!isCorrect) {
        <span class="hilite"><span class="d_keyword">immutable</span></span> guess = readInt(<span class="d_string">"What is your guess"</span>);
        isCorrect = (guess == number);
    }

    writeln(<span class="d_string">"Correct!"</span>);
}
</pre>

<p>Observations:
</p>

<ul>
<li><code class="d_inline">min</code> and <code class="d_inline">max</code> are integral parts of the behavior of this program and their values are known at compile time. For that reason they are defined as <code class="d_inline">enum</code> constants.
</li>

<li><code class="d_inline">number</code> is specified as <code class="d_inline">immutable</code> because it would not be appropriate to modify it after its initialization at run time. Likewise for each user guess: once read, the guess should not be modified.
</li>

<li>Observe that the types of those variables are not specified explicitly. As with <code class="d_inline">auto</code> and <code class="d_inline">enum</code>, the type of an <code class="d_inline">immutable</code> variable can be inferred from the expression on the right hand side.
</li>

</ul>

<p>Although it is not necessary to write the type fully, <code class="d_inline">immutable</code> normally takes the actual type within parentheses, e.g. <code class="d_inline">immutable(int)</code>. The output of the following program demonstrates that the full names of the types of the three variables are in fact the same:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">immutable</span>      inferredType = 0;
    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>  explicitType = 1;
    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>) wholeType    = 2;

    writeln(<span class="d_keyword">typeof</span>(inferredType).stringof);
    writeln(<span class="d_keyword">typeof</span>(explicitType).stringof);
    writeln(<span class="d_keyword">typeof</span>(wholeType).stringof);
}
</pre>

<p>The actual name of the type includes <code class="d_inline">immutable</code>:
</p>

<pre class="shell">immutable(int)
immutable(int)
immutable(int)
</pre>

<p>The use of parentheses has significance, and specifies which parts of the type are immutable. We will see this below when discussing the immutability of the whole slice vs. its elements.
</p>

<h6><a id="ix_Immutability.variable, const" content="variable, const"></a> <code class="d_inline">const</code> variables</h6>

<p>When defining variables the <code class="d_inline">const</code> keyword has the same effect as <code class="d_inline">immutable</code>. <code class="d_inline">const</code> variables cannot be modified:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">const</span></span> half = total / 2;
    half = 10;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>I recommend that you prefer <code class="d_inline">immutable</code> over <code class="d_inline">const</code> for defining variables. The reason is that <code class="d_inline">immutable</code> variables can be passed to functions that have <code class="d_inline">immutable</code> parameters. We will see this below.
</p>

<h5 class="subsection">Immutable parameters</h5>

<p>It is possible for functions to promise that they do not modify certain parameters that they take, and the compiler will enforce this promise. Before seeing how this is achieved, let's first see that functions can indeed modify the elements of slices that are passed as arguments to those functions.
</p>

<p>As you would remember from the <a href="slices.html">Slices and Other Array Features chapter</a>, slices do not own elements but provide access to them. There may be more than one slice at a given time that provides access to the same elements.
</p>

<p>Although the examples in this section focus only on slices, this topic is applicable to associative arrays and classes as well because they too are <i>reference types</i>.
</p>

<p>A slice that is passed as a function argument is not the slice that the function is called with. The argument is a copy of the actual slice:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span>[] slice = [ 10, 20, 30, 40 ];  <span class="d_comment">// 1
</span>    halve(slice);
    writeln(slice);
}

<span class="d_keyword">void</span> halve(<span class="d_keyword">int</span>[] numbers) {            <span class="d_comment">// 2
</span>    <span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> number; numbers) {
        number /= 2;
    }
}
</pre>

<p>When program execution enters the <code class="d_inline">halve()</code> function, there are two slices that provide access to the same four elements:
</p>

<ol>
<li>The slice named <code class="d_inline">slice</code> that is defined in <code class="d_inline">main()</code>, which is passed to <code class="d_inline">halve()</code> as its argument
</li>

<li>The slice named <code class="d_inline">numbers</code> that <code class="d_inline">halve()</code> receives as its argument, which provides access to the same elements as <code class="d_inline">slice</code>
</li>

</ol>

<p>Since both slides refer to the same elements and given that we use the <code class="d_inline">ref</code> keyword in the <code class="d_inline">foreach</code> loop, the values of the elements get halved:
</p>

<pre class="shell">[5, 10, 15, 20]
</pre>

<p>It is useful for functions to be able to modify the elements of the slices that are passed as arguments. Some functions exist just for that purpose, as has been seen in this example.
</p>

<p>The compiler does not allow passing <code class="d_inline">immutable</code> variables as arguments to such functions because we cannot modify an immutable variable:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">immutable</span></span> <span class="d_keyword">int</span>[] slice = [ 10, 20, 30, 40 ];
    halve(slice);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>The compilation error indicates that a variable of type <code class="d_inline">immutable(int[])</code> cannot be used as an argument of type <code class="d_inline">int[]</code>:
</p>

<pre class="shell">Error: function deneme.halve (<span class="hilite">int[]</span> numbers) is not callable
using argument types (<span class="hilite">immutable(int[])</span>)
</pre>

<h6><a id="ix_Immutability.parameter, const" content="parameter, const"></a> <code class="d_inline">const</code> parameters</h6>

<p>It is important and natural that <code class="d_inline">immutable</code> variables be prevented from being passed to functions like <code class="d_inline">halve()</code>, which modify their arguments. However, it would be a limitation if they could not be passed to functions that do not modify their arguments in any way:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] slice = [ 10, 20, 30, 40 ];
    print(slice);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}

<span class="d_keyword">void</span> print(<span class="d_keyword">int</span>[] slice) {
    writefln(<span class="d_string">"%s elements: "</span>, slice.length);

    <span class="d_keyword">foreach</span> (i, element; slice) {
        writefln(<span class="d_string">"%s: %s"</span>, i, element);
    }
}
</pre>

<p>It does not make sense above that a slice is prevented from being printed just because it is <code class="d_inline">immutable</code>. The proper way of dealing with this situation is by using <code class="d_inline">const</code> parameters.
</p>

<p>The <code class="d_inline">const</code> keyword specifies that a variable is not modified through <i>that particular reference</i> (e.g. a slice) of that variable. Specifying a parameter as <code class="d_inline">const</code> guarantees that the elements of the slice are not modified inside the function. Once <code class="d_inline">print()</code> provides this guarantee, the program can now be compiled:
</p>

<pre class="d_code">    print(slice);    <span class="d_comment">// now compiles
</span><span class="d_comment">// ...
</span><span class="d_keyword">void</span> print(<span class="hilite"><span class="d_keyword">const</span></span> <span class="d_keyword">int</span>[] slice)
</pre>

<p>This guarantee allows passing both mutable and <code class="d_inline">immutable</code> variables as arguments:
</p>

<pre class="d_code">    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] slice = [ 10, 20, 30, 40 ];
    print(slice);           <span class="d_comment">// compiles
</span>
    <span class="d_keyword">int</span>[] mutableSlice = [ 7, 8 ];
    print(mutableSlice);    <span class="d_comment">// compiles
</span></pre>

<p>A parameter that is not modified in a function but is not specified as <code class="d_inline">const</code> reduces the applicability of that function. Additionally, <code class="d_inline">const</code> parameters provide useful information to the programmer. Knowing that a variable will not be modified when passed to a function makes the code easier to understand. It also prevents potential errors because the compiler detects modifications to <code class="d_inline">const</code> parameters:
</p>

<pre class="d_code"><span class="d_keyword">void</span> print(<span class="hilite"><span class="d_keyword">const</span></span> <span class="d_keyword">int</span>[] slice) {
    slice[0] = 42;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>The programmer would either realize the mistake in the function or would rethink the design and perhaps remove the <code class="d_inline">const</code> specifier.
</p>

<p>The fact that <code class="d_inline">const</code> parameters can accept both mutable and <code class="d_inline">immutable</code> variables has an interesting consequence. This is explained in the "Should a parameter be <code class="d_inline">const</code> or <code class="d_inline">immutable</code>?" section below.
</p>

<h6><a id="ix_Immutability.parameter, immutable" content="parameter, immutable"></a> <code class="d_inline">immutable</code> parameters</h6>

<p>As we saw above, both mutable and <code class="d_inline">immutable</code> variables can be passed to functions as their <code class="d_inline">const</code> parameters. In a way, <code class="d_inline">const</code> parameters are welcoming.
</p>

<p>In contrast, <code class="d_inline">immutable</code> parameters bring a strong requirement: only <code class="d_inline">immutable</code> variables can be passed to functions as their <code class="d_inline">immutable</code> parameters:
</p>

<pre class="d_code"><span class="d_keyword">void</span> func(<span class="hilite"><span class="d_keyword">immutable</span></span> <span class="d_keyword">int</span>[] slice) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] immSlice = [ 1, 2 ];
              <span class="d_keyword">int</span>[]    slice = [ 8, 9 ];

    func(immSlice);      <span class="d_comment">// compiles
</span>    func(slice);         <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}
</pre>

<p>For that reason, the <code class="d_inline">immutable</code> specifier should be used only when this requirement is actually necessary. We have indeed been using the <code class="d_inline">immutable</code> specifier indirectly through certain string types. This will be covered below.
</p>

<p>We have seen that the parameters that are specified as <code class="d_inline">const</code> or <code class="d_inline">immutable</code> promise not to modify <i>the actual variable</i> that is passed as an argument. This is relevant only for reference types because only then there is <i>the actual variable</i> to talk about the immutability of.
</p>

<p><i>Reference types</i> and <i>value types</i> will be covered in the next chapter. Among the types that we have seen so far, only slices and associative arrays are reference types; the others are value types.
</p>

<h6><a id="ix_Immutability.parameter, const vs. immutable" content="parameter, const vs. immutable"></a> Should a parameter be <code class="d_inline">const</code> or <code class="d_inline">immutable</code>?</h6>

<p>The two sections above may give the impression that, being more flexible, <code class="d_inline">const</code> parameters should be preferred over <code class="d_inline">immutable</code> parameters. This is not always true.
</p>

<p><code class="d_inline">const</code> <i>erases</i> the information about whether the original variable was mutable or <code class="d_inline">immutable</code>. This information is hidden even from the compiler.
</p>

<p>A consequence of this fact is that <code class="d_inline">const</code> parameters cannot be passed as arguments to functions that take <code class="d_inline">immutable</code> parameters. For example, <code class="d_inline">foo()</code> below cannot pass its <code class="d_inline">const</code> parameter to <code class="d_inline">bar()</code>:
</p>

<pre class="d_code"><span class="d_keyword">void</span> main() {
    <span class="d_comment">/* The original variable is immutable */</span>
    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] slice = [ 10, 20, 30, 40 ];
    foo(slice);
}

<span class="d_comment">/* A function that takes its parameter as const, in order to
 * be more useful. */</span>
<span class="d_keyword">void</span> foo(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[] slice) {
    bar(slice);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}

<span class="d_comment">/* A function that takes its parameter as immutable, for a
 * plausible reason. */</span>
<span class="d_keyword">void</span> bar(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] slice) {
    <span class="d_comment">// ...
</span>}
</pre>

<p><code class="d_inline">bar()</code> requires the parameter to be <code class="d_inline">immutable</code>. However, it is not known (in general) whether the original variable that <code class="d_inline">foo()</code>'s <code class="d_inline">const</code> parameter references was <code class="d_inline">immutable</code> or not.
</p>

<p><i><b>Note:</b> It is clear in the code above that the original variable in <code class="d_inline">main()</code> is <code class="d_inline">immutable</code>. However, the compiler compiles functions individually, without regard to all of the places that function is called from. To the compiler, the <code class="d_inline">slice</code> parameter of <code class="d_inline">foo()</code> may refer to a mutable variable or an <code class="d_inline">immutable</code> one.
</i>
</p>

<p>A solution would be to call <code class="d_inline">bar()</code> with an immutable copy of the parameter:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[] slice) {
    bar(slice<span class="hilite">.idup</span>);
}
</pre>

<p>Although that is a sensible solution, it does incur into the cost of copying the slice and its contents, which would be wasteful in the case where the original variable was <code class="d_inline">immutable</code> to begin with.
</p>

<p>After this analysis, it should be clear that always declaring parameters as <code class="d_inline">const</code> is not the best approach in every situation. After all, if <code class="d_inline">foo()</code>'s parameter had been defined as <code class="d_inline">immutable</code> there would be no need to copy it before calling <code class="d_inline">bar()</code>:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] slice) {  <span class="d_comment">// This time immutable
</span>    bar(slice);    <span class="d_comment">// Copying is not needed anymore
</span>}
</pre>

<p>Although the code compiles, defining the parameter as <code class="d_inline">immutable</code> has a similar cost: this time an immutable copy of the original variable is needed when calling <code class="d_inline">foo()</code>, if that variable was not immutable to begin with:
</p>

<pre class="d_code">    foo(mutableSlice<span class="hilite">.idup</span>);
</pre>

<p>Templates can help. (We will see templates in later chapters.) Although I don't expect you to fully understand the following function at this point in the book, I will present it as a solution to this problem. The following function template <code class="d_inline">foo()</code> can be called both with mutable and <code class="d_inline">immutable</code> variables. The parameter would be copied only if the original variable was mutable; no copying would take place if it were <code class="d_inline">immutable</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.conv;
<span class="d_comment">// ...
</span>
<span class="d_comment">/* Because it is a template, foo() can be called with both mutable
 * and immutable variables. */</span>
<span class="d_keyword">void</span> foo(T)(T[] slice) {
    <span class="d_comment">/* 'to()' does not make a copy if the original variable is
     * already immutable. */</span>
    bar(to!(<span class="d_keyword">immutable</span> T[])(slice));
}
</pre>

<h5 class="subsection">Immutability of the slice versus the elements</h5>

<p>We have seen above that the type of an <code class="d_inline">immutable</code> slice has been printed as <code class="d_inline">immutable(int[])</code>. As the parentheses after <code class="d_inline">immutable</code> indicate, it is the entire slice that is <code class="d_inline">immutable</code>. Such a slice cannot be modified in any way: elements may not be added or removed, their values may not be modified, and the slice may not start providing access to a different set of elements:
</p>

<pre class="d_code">    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] immSlice = [ 1, 2 ];
    immSlice ~= 3;               <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    immSlice[0] = 3;             <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    immSlice.length = 1;         <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>

    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] immOtherSlice = [ 10, 11 ];
    immSlice = immOtherSlice;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>Taking immutability to that extreme may not be suitable in every case. In most cases, what is important is the immutability of the elements themselves. Since a slice is just a tool to access the elements, it should not matter if we make changes to the slice itself as long as the elements are not modified. This is especially true in the cases we have seen so far, where the function receives a copy of the slice itself.
</p>

<p>To specify that only the elements are immutable we use the <code class="d_inline">immutable</code> keyword with parentheses that enclose just the element type. Modifying the code accordingly, now only the elements are immutable, not the slice itself:
</p>

<pre class="d_code">    <span class="d_keyword">immutable</span><span class="hilite">(<span class="d_keyword">int</span>)</span>[] immSlice = [ 1, 2 ];
    immSlice ~= 3;               <span class="d_comment">// can add elements
</span>    immSlice[0] = 3;             <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    immSlice.length = 1;         <span class="d_comment">// can drop elements
</span>
    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] immOtherSlice = [ 10, 11 ];
    immSlice = immOtherSlice;    <span class="d_comment">/* can provide access to
                                  * other elements */</span>
</pre>

<p>Although the two syntaxes are very similar, they have different meanings. To summarize:
</p>

<pre class="d_code">    <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[]  a = [1]; <span class="d_comment">/* Neither the elements nor the
                               * slice can be modified */</span>

    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>[]) b = [1]; <span class="d_comment">/* The same meaning as above */</span>

    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] c = [1]; <span class="d_comment">/* The elements cannot be
                               * modified but the slice can be */</span>
</pre>

<p>This distinction has been in effect in some of the programs that we have written so far. As you may remember, the three string aliases involve immutability:
</p>

<ul><li><code class="d_inline">string</code> is an alias for <code class="d_inline">immutable(char)[]</code></li>
<li><code class="d_inline">wstring</code> is an alias for <code class="d_inline">immutable(wchar)[]</code></li>
<li><code class="d_inline">dstring</code> is an alias for <code class="d_inline">immutable(dchar)[]</code></li>
</ul>

<p>Likewise, string literals are immutable as well:
</p>

<ul><li>The type of literal <code class="d_inline"><span class="d_string">"hello"c</span></code> is <code class="d_inline">string</code></li>
<li>The type of literal <code class="d_inline"><span class="d_string">"hello"w</span></code> is <code class="d_inline">wstring</code></li>
<li>The type of literal <code class="d_inline"><span class="d_string">"hello"d</span></code> is <code class="d_inline">dstring</code></li>
</ul>

<p>According to these definitions, D strings are normally arrays of <i>immutable characters</i>.
</p>

<h6><a id="ix_Immutability.transitive, immutability" content="transitive, immutability"></a> <code class="d_inline">const</code> and <code class="d_inline">immutable</code> are transitive</h6>

<p>As mentioned in the code comments of slices <code class="d_inline">a</code> and <code class="d_inline">b</code> above, both those slices and their elements are <code class="d_inline">immutable</code>.
</p>

<p>This is true for <a href="struct.html">structs</a> and <a href="class.html">classes</a> as well, both of which will be covered in later chapters. For example, all members of a <code class="d_inline">const</code> <code class="d_inline">struct</code> variable are <code class="d_inline">const</code> and all members of an <code class="d_inline">immutable</code> <code class="d_inline">struct</code> variable are <code class="d_inline">immutable</code>. (Likewise for classes.)
</p>

<h6><a id="ix_Immutability..dup" content=".dup"></a> <a id="ix_Immutability..idup" content=".idup"></a> <code class="d_inline">.dup</code> and <code class="d_inline">.idup</code></h6>

<p>There may be mismatches in immutability when strings are passed to functions as parameters. The <code class="d_inline">.dup</code> and <code class="d_inline">.idup</code> properties make copies of arrays with the desired mutability:
</p>

<ul><li><code class="d_inline">.dup</code> makes a mutable copy of the array; its name comes from "duplicate"</li>
<li><code class="d_inline">.idup</code> makes an immutable copy of the array</li>
</ul>

<p>For example, a function that insists on the immutability of a parameter may have to be called with an immutable copy of a mutable string:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="hilite">string</span> s) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">char</span>[] salutation;
    foo(salutation);                <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    foo(salutation<span class="hilite">.idup</span>);           <span class="d_comment">// ← this compiles
</span>}
</pre>

<h5 class="subsection">How to use</h5>

<ul>
<li>As a general rule, prefer immutable variables over mutable ones.
</li>

<li>Define constant values as <code class="d_inline">enum</code> if their values can be calculated at compile time. For example, the constant value of <i>seconds per minute</i> can be an <code class="d_inline">enum</code>:

<pre class="d_code">    <span class="d_keyword">enum</span> <span class="d_keyword">int</span> secondsPerMinute = 60;
</pre>

<p>There is no need to specify the type explicitly if it can be inferred from the right hand side:
</p>

<pre class="d_code">    <span class="d_keyword">enum</span> secondsPerMinute = 60;
</pre>

</li>

<li>Consider the hidden cost of <code class="d_inline">enum</code> arrays and <code class="d_inline">enum</code> associative arrays. Define them as <code class="d_inline">immutable</code> variables if the arrays are large and they are used more than once in the program.
</li>

<li>Specify variables as <code class="d_inline">immutable</code> if their values will never change but cannot be known at compile time. Again, the type can be inferred:

<pre class="d_code">    <span class="d_keyword">immutable</span> guess = readInt(<span class="d_string">"What is your guess"</span>);
</pre>

</li>

<li>If a function does not modify a parameter, specify that parameter as <code class="d_inline">const</code>. This would allow both mutable and <code class="d_inline">immutable</code> variables to be passed as arguments:

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">const</span> <span class="d_keyword">char</span>[] s) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">char</span>[] mutableString;
    string immutableString;

    foo(mutableString);      <span class="d_comment">// ← compiles
</span>    foo(immutableString);    <span class="d_comment">// ← compiles
</span>}
</pre>

</li>

<li>Following from the previous guideline, consider that <code class="d_inline">const</code> parameters cannot be passed to functions taking <code class="d_inline">immutable</code>. See the section titled "Should a parameter be <code class="d_inline">const</code> or <code class="d_inline">immutable</code>?" above.
</li>

<li>If the function modifies a parameter, leave that parameter as mutable (<code class="d_inline">const</code> or <code class="d_inline">immutable</code> would not allow modifications anyway):

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> reverse(<span class="d_keyword">dchar</span>[] s) {
    <span class="d_keyword">foreach</span> (i; 0 .. s.length / 2) {
        <span class="d_keyword">immutable</span> temp = s[i];
        s[i] = s[$ - 1 - i];
        s[$ - 1 - i] = temp;
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">dchar</span>[] salutation = <span class="d_string">"hello"d</span>.dup;
    reverse(salutation);
    writeln(salutation);
}
</pre>

<p>The output:
</p>

<pre class="shell">olleh
</pre>

</li>

</ul>

<h5 class="subsection">Summary</h5>

<ul>
<li><code class="d_inline">enum</code> variables represent immutable concepts that are known at compile time.</li>

<li><code class="d_inline">immutable</code> variables represent immutable concepts that must be calculated at run time, or that must have some memory location that we can refer to.</li>

<li><code class="d_inline">const</code> parameters are the ones that functions do not modify. Both mutable and <code class="d_inline">immutable</code> variables can be passed as arguments of <code class="d_inline">const</code> parameters.</li>

<li><code class="d_inline">immutable</code> parameters are the ones that functions specifically require them to be so. Only <code class="d_inline">immutable</code> variables can be passed as arguments of <code class="d_inline">immutable</code> parameters.</li>

<li><code class="d_inline">immutable(int[])</code> specifies that neither the slice nor its elements can be modified.</li>

<li><code class="d_inline">immutable(int)[]</code> specifies that only the elements cannot be modified.</li>

</ul>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 21:19:13 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

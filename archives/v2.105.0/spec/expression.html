
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Expressions - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Expressions' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../spec/glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Google Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option selected value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    <div class="head"><h2>Language Reference</h2> <p class="subnav-duplicate"><a href="../spec/spec.html">table of contents</a></p></div>
    <ul>        <li><a href='            ../spec/intro.html'>Introduction</a></li><li><a href='            ../spec/lex.html'>Lexical</a></li><li><a href='            ../spec/grammar.html'>Grammar</a></li><li><a href='            ../spec/module.html'>Modules</a></li><li><a href='            ../spec/declaration.html'>Declarations</a></li><li><a href='            ../spec/type.html'>Types</a></li><li><a href='            ../spec/property.html'>Properties</a></li><li><a href='            ../spec/attribute.html'>Attributes</a></li><li><a href='            ../spec/pragma.html'>Pragmas</a></li><li><a href='            ../spec/expression.html'>Expressions</a></li><li><a href='            ../spec/statement.html'>Statements</a></li><li><a href='            ../spec/arrays.html'>Arrays</a></li><li><a href='            ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='            ../spec/struct.html'>Structs and Unions</a></li><li><a href='            ../spec/class.html'>Classes</a></li><li><a href='            ../spec/interface.html'>Interfaces</a></li><li><a href='            ../spec/enum.html'>Enums</a></li><li><a href='            ../spec/const3.html'>Type Qualifiers</a></li><li><a href='            ../spec/function.html'>Functions</a></li><li><a href='            ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='            ../spec/template.html'>Templates</a></li><li><a href='            ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='            ../spec/contracts.html'>Contract Programming</a></li><li><a href='            ../spec/version.html'>Conditional Compilation</a></li><li><a href='            ../spec/traits.html'>Traits</a></li><li><a href='            ../spec/errors.html'>Error Handling</a></li><li><a href='            ../spec/unittest.html'>Unit Tests</a></li><li><a href='            ../spec/garbage.html'>Garbage Collection</a></li><li><a href='            ../spec/float.html'>Floating Point</a></li><li><a href='            ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='            ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='            ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='            ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='            ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='            ../spec/portability.html'>Portability Guide</a></li><li><a href='            ../spec/entity.html'>Named Character Entities</a></li><li><a href='            ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='            ../spec/abi.html'>Application Binary Interface</a></li><li><a href='            ../spec/simd.html'>Vector Extensions</a></li><li><a href='            ../spec/betterc.html'>Better C</a></li><li><a href='            ../spec/importc.html'>ImportC</a></li><li><a href='            ../spec/ob.html'>Live Functions</a></li><li><a href='            ../spec/windows.html'>Windows Programming</a></li><li><a href='            ../spec/glossary.html'>Glossary</a></li><li><a href='            ../spec/legacy.html'>Legacy Code
        </a></li>
    </ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BExpressions%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/spec/expression.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Expressions</h1>
        
<style>    body { counter-reset: h1 10; counter-increment: h1 -1; }
    h1 { counter-reset: h2 h3 p; }
    h2 { counter-reset: h3 h4 p; }
    h3 { counter-reset: h4 p; }
    h4 { counter-reset: p; }
    h1::before {
        counter-increment: h1;
        content: counter(h1) ". ";
    }
    .hyphenate h2::before {
        counter-increment: h2;
        content: counter(h1) "." counter(h2) " ";
    }
    h3::before {
        counter-increment: h3;
        content: counter(h1) "." counter(h2) "." counter(h3) " ";
    }
    h4::before {
        counter-increment: h4;
        content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) " ";
    }
    p::before, .spec-boxes::before {
        counter-increment: p;
        content: counter(p) ". ";
    }
    h1::before, h2::before, h3::before, h4::before, p::before, .spec-boxes::before
    {
        color: #999;
        font-size: 80%;
        margin-right: 0.25em;
    }
</style>
        <div class="blankline"></div>
<div class="blankline"></div>
<div class="blankline"></div>
<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#expression">Expressions</a></li>
    <li><a href="#definitions-and-terms">Definitions and Terms</a><ol>        <li><a href="#.define-full-expression">Full Expression</a></li>
        <li><a href="#.define-lvalue">Lvalue</a></li>
        <li><a href="#.define-rvalue">Rvalue</a></li>
        <li><a href="#.define-smallest-short-circuit">Smallest Short-Circuit Expression</a></li>
    </ol></li>
    <li><a href="#order-of-evaluation">Order Of Evaluation</a></li>
    <li><a href="#temporary-lifetime">Lifetime of Temporaries</a></li>
    <li><a href="#comma_expression">Comma Expression</a></li>
    <li><a href="#assign_expressions">Assign Expressions</a><ol>        <li><a href="#simple_assignment_expressions">Simple Assignment Expression</a></li>
        <li><a href="#assignment_operator_expressions">Assignment Operator Expressions</a></li>
    </ol></li>
    <li><a href="#conditional_expressions">Conditional Expressions</a></li>
    <li><a href="#logical_expressions">Logical Expressions</a><ol>        <li><a href="#oror_expressions">OrOr Expressions</a></li>
        <li><a href="#andand_expressions">AndAnd Expressions</a></li>
    </ol></li>
    <li><a href="#bitwise_expressions">Bitwise Expressions</a><ol>        <li><a href="#or_expressions">Or Expressions</a></li>
        <li><a href="#xor_expressions">Xor Expressions</a></li>
        <li><a href="#and_expressions">And Expressions</a></li>
    </ol></li>
    <li><a href="#compare_expressions">Compare Expressions</a><ol>        <li><a href="#equality_expressions">Equality Expressions</a></li>
        <li><a href="#identity_expressions">Identity Expressions</a></li>
        <li><a href="#relation_expressions">Relational Expressions</a></li>
        <li><a href="#array_comparisons">Array Comparisons</a></li>
        <li><a href="#integer_comparisons">Integer Comparisons</a></li>
        <li><a href="#floating-point-comparisons">Floating Point Comparisons</a></li>
        <li><a href="#class-comparisons">Class Comparisons</a></li>
    </ol></li>
    <li><a href="#in_expressions">In Expressions</a></li>
    <li><a href="#shift_expressions">Shift Expressions</a></li>
    <li><a href="#add_expressions">Add Expressions</a><ol>        <li><a href="#pointer_arithmetic">Pointer Arithmetic</a></li>
    </ol></li>
    <li><a href="#cat_expressions">Cat Expressions</a></li>
    <li><a href="#mul_expressions">Mul Expressions</a><ol>        <li><a href="#division">Division</a></li>
        <li><a href="#mul_floating">Floating Point</a></li>
    </ol></li>
    <li><a href="#unary-expression">Unary Expressions</a><ol>        <li><a href="#complement_expressions">Complement Expressions</a></li>
        <li><a href="#delete_expressions">Delete Expressions</a></li>
        <li><a href="#cast_expressions">Cast Expressions</a></li>
    </ol></li>
    <li><a href="#throw_expression">Throw Expression</a></li>
    <li><a href="#pow_expressions">Pow Expressions</a></li>
    <li><a href="#postfix_expressions">Postfix Expressions</a></li>
    <li><a href="#index_expressions">Index Expressions</a></li>
    <li><a href="#slice_expressions">Slice Expressions</a><ol>        <li><a href="#slice_to_static_array">Slice Conversion to Static Array</a></li>
    </ol></li>
    <li><a href="#primary_expressions">Primary Expressions</a><ol>        <li><a href="#identifier">.Identifier</a></li>
        <li><a href="#this">this</a></li>
        <li><a href="#super">super</a></li>
        <li><a href="#null">null</a></li>
        <li><a href="#string_literals">String Literals</a></li>
        <li><a href="#array_literals">Array Literals</a></li>
        <li><a href="#associative_array_literals">Associative Array Literals</a></li>
        <li><a href="#function_literals">Function Literals</a></li>
        <li><a href="#uniform_construction_syntax">Uniform construction syntax for built-in scalar types</a></li>
        <li><a href="#assert_expressions">Assert Expressions</a></li>
        <li><a href="#mixin_expressions">Mixin Expressions</a></li>
        <li><a href="#import_expressions">Import Expressions</a></li>
        <li><a href="#new_expressions">New Expressions</a></li>
        <li><a href="#typeid_expressions">Typeid Expressions</a></li>
        <li><a href="#is_expression">Is Expressions</a></li>
        <li><a href="#specialkeywords">Special Keywords</a></li>
    </ol></li>
    <li><a href="#associativity">Associativity and Commutativity</a></li>
</ol>
</div>
<div class="blankline"></div>
<h2><span id="Expression"><a class="anchor" title="Permalink to this section" id="expression" href="#expression">Expressions</a></span></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="Expression"><span class="gname">Expression</span></a>:
    <a href="#CommaExpression"><i>CommaExpression</i></a>
</pre>
<div class="blankline"></div>
<p>An expression is a sequence of operators and operands that specifies an evaluation.
The syntax, order of evaluation, and semantics of expressions are as follows.</p>
<div class="blankline"></div>
    <p>Expressions are used to compute values with a resulting type.
        These values can then be assigned,
        tested, or ignored. Expressions can also have side effects.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="definitions-and-terms" href="#definitions-and-terms">Definitions and Terms</a></h2>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id=".define-full-expression" href="#.define-full-expression">Full Expression</a></h3>
<div class="blankline"></div>
<p>For any expression
<i>expr</i>, the full expression of <i>expr</i> is defined as follows. If <i>expr</i> parses as a
subexpression of another expression <i>expr<sub>1</sub></i>, then the full expression of <i>expr</i> is the
full expression of <i>expr<sub>1</sub></i>. Otherwise, <i>expr</i> is its own full expression.</p>
<div class="blankline"></div>
<p>Each expression has a unique full expression. Example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">return</span> f() + g() * 2;
</pre>
<div class="blankline"></div>
<p>The full expression of <span class="d_inlinecode donthyphenate notranslate">g() * 2</span> above is <span class="d_inlinecode donthyphenate notranslate">f() + g() * 2</span>, but not the
full expression of <span class="d_inlinecode donthyphenate notranslate">f() + g()</span> because the latter is not parsed as a subexpression.</p>
<div class="blankline"></div>
<p>Note: Although the definition is straightforward, a few subtleties exist related to function literals:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">return</span> (() =&gt; x + f())() * g();
</pre>
<div class="blankline"></div>
<p>The full expression of <span class="d_inlinecode donthyphenate notranslate">f()</span> above is <span class="d_inlinecode donthyphenate notranslate">x + f()</span>, not the expression passed
to <span class="d_inlinecode donthyphenate notranslate">return</span>. This is because the parent of <span class="d_inlinecode donthyphenate notranslate">x + f()</span> has function literal type, not expression type.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id=".define-lvalue" href="#.define-lvalue">Lvalue</a></h3>
<div class="blankline"></div>
<p>The following expressions, and no others, are called <em>lvalue expressions</em> or <em>lvalues</em>:</p>
<ol><li><a href="#this"><span class="d_inlinecode donthyphenate notranslate">this</span></a> inside <span class="d_inlinecode donthyphenate notranslate">struct</span> and <span class="d_inlinecode donthyphenate notranslate">union</span> member functions;</li>
<li>a variable, function name, or invocation of a function that returns by reference;</li>
<li>the result of the <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="#PostfixExpression"><i>PostfixExpression</i></a> or
<a href="../spec/module.html#module_scope_operators">Module Scope Operator</a>
when the rightmost side of the dot is a variable,
field (direct or <span class="d_inlinecode donthyphenate notranslate">static</span>), function name, or invocation of a function that returns by reference;</li>
<li>the result of the following expressions:
<ul><li>built-in unary operators <span class="d_inlinecode donthyphenate notranslate">+</span> (when applied to an lvalue), <span class="d_inlinecode donthyphenate notranslate">*</span>, <span class="d_inlinecode donthyphenate notranslate">++</span> (prefix only), <span class="d_inlinecode donthyphenate notranslate">--</span> (prefix only);</li>
<li>built-in indexing operator <span class="d_inlinecode donthyphenate notranslate">[]</span> (but not the slicing operator);</li>
<li>built-in assignment binary operators, i.e. <span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">+=</span>, <span class="d_inlinecode donthyphenate notranslate">*=</span>, <span class="d_inlinecode donthyphenate notranslate">/=</span>, <span class="d_inlinecode donthyphenate notranslate">%=</span>, <span class="d_inlinecode donthyphenate notranslate">&amp;=</span>, <span class="d_inlinecode donthyphenate notranslate">|=</span>, <span class="d_inlinecode donthyphenate notranslate">^=</span>, <span class="d_inlinecode donthyphenate notranslate">~=</span>,
<span class="d_inlinecode donthyphenate notranslate">&lt;&lt;=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;=</span>, and <span class="d_inlinecode donthyphenate notranslate">^^=</span>;</li>
<li>the <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> operator <i>e</i> <span class="d_inlinecode donthyphenate notranslate">?</span> <i>e<sub>1</sub></i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>e<sub>2</sub></i> under the following
circumstances:</li>
<ol>    <li><i>e<sub>1</sub></i> and <i>e<sub>2</sub></i> are lvalues of the same type; OR</li>
    <li>One of <i>e<sub>1</sub></i> and <i>e<sub>2</sub></i> is an lvalue of type <span class="d_inlinecode donthyphenate notranslate">T</span> and the other has
    and <span class="d_inlinecode donthyphenate notranslate">alias this</span> converting it to <span class="d_inlinecode donthyphenate notranslate">ref T</span>;</li></ol>
<li><a href="../spec/operatoroverloading.html">user-defined operators</a>
if and only if the function called as a result of lowering returns
by reference;</li>
<li><a href="#mixin_expressions"><span class="d_inlinecode donthyphenate notranslate">mixin</span> expressions</a> if and only if the
compilation of the expression resulting from compiling
the argument(s) to <span class="d_inlinecode donthyphenate notranslate">mixin</span> is an lvalue;</li>
<li><span class="d_inlinecode donthyphenate notranslate">cast(U)</span> expressions applied to lvalues of type <span class="d_inlinecode donthyphenate notranslate">T</span> when <span class="d_inlinecode donthyphenate notranslate">T*</span> is implicitly convertible to <span class="d_inlinecode donthyphenate notranslate">U*</span>;</li>
<li><span class="d_inlinecode donthyphenate notranslate">cast()</span> and <span class="d_inlinecode donthyphenate notranslate">cast(</span><i>qualifier list</i><span class="d_inlinecode donthyphenate notranslate">)</span> when applied to an lvalue.</li>
</ul></li></ol>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id=".define-rvalue" href="#.define-rvalue">Rvalue</a></h3>
<div class="blankline"></div>
<p>Expressions that are not lvalues are <em>rvalues</em>. Rvalues include all literals, special value keywords such as <span class="d_inlinecode donthyphenate notranslate">__FILE__</span> and <span class="d_inlinecode donthyphenate notranslate">__LINE__</span>,
<span class="d_inlinecode donthyphenate notranslate">enum</span> values, and the result of expressions not defined as lvalues above.</p>
<div class="blankline"></div>
<p>The built-in address-of operator (unary <span class="d_inlinecode donthyphenate notranslate">&amp;</span>) may only be applied to lvalues.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id=".define-smallest-short-circuit" href="#.define-smallest-short-circuit">Smallest Short-Circuit Expression</a></h3>
<div class="blankline"></div>
<p>Given an expression <i>expr</i> that is a subexpression of a full
expression <i>fullexpr</i>, the <em>smallest short-circuit expression</em>, if any, is the shortest
subexpression <i>scexpr</i> of <i>fullexpr</i> that is an <a href="#AndAndExpression"><i>AndAndExpression</i></a> (<span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span>) or an
<a href="#OrOrExpression"><i>OrOrExpression</i></a> (<span class="d_inlinecode donthyphenate notranslate">||</span>), such that <i>expr</i> is a subexpression of <i>scexpr</i>. Example:</p>
<pre class="d_code notranslate">((f() * 2 &amp;&amp; g()) + 1) || h()
</pre>
The smallest short-circuit expression
of the subexpression <span class="d_inlinecode donthyphenate notranslate">f() * 2</span> above is <span class="d_inlinecode donthyphenate notranslate">f() * 2 &amp;&amp; g()</span>. Example:
<pre class="d_code notranslate">(f() &amp;&amp; g()) + h()
</pre>
The subexpression <span class="d_inlinecode donthyphenate notranslate">h()</span> above has no smallest short-circuit expression.
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="order-of-evaluation" href="#order-of-evaluation">Order Of Evaluation</a></h2>
<div class="blankline"></div>
<p>Built-in prefix unary expressions <span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> are evaluated as if lowered (rewritten) to
<a href="#assignment_operator_expressions">assignments</a> as follows:</p>
<div class="blankline"></div>
<table>    <tr><th class="donthyphenate"><b>Expression</b></th><th class="donthyphenate"><b>Equivalent</b></th></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">++expr</span></td><td><span class="d_inlinecode donthyphenate notranslate">((expr) += 1)</span></td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">--expr</span></td><td><span class="d_inlinecode donthyphenate notranslate">((expr) -= 1)</span></td></tr>
</table>
<p>Therefore, the result of prefix <span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> is the lvalue after the side effect has been
effected.</p>
<div class="blankline"></div>
<p>Built-in postfix unary expressions <span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> are evaluated as if lowered (rewritten) to
<a href="../spec/expression.html#function_literals">lambda</a>
invocations as follows:</p>
<div class="blankline"></div>
<table>    <tr><th class="donthyphenate"><b>Expression</b></th><th class="donthyphenate"><b>Equivalent</b></th></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">expr++</span></td><td><span class="d_inlinecode donthyphenate notranslate">(ref x){auto t = x; ++x; return t;}(expr)</span></td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">expr--</span></td><td><span class="d_inlinecode donthyphenate notranslate">(ref x){auto t = x; --x; return t;}(expr)</span></td></tr>
</table>
<p>Therefore, the result of postfix
<span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> is an rvalue just before the side effect has been effected.</p>
<div class="blankline"></div>
<p>Binary expressions except for <a href="#AssignExpression"><i>AssignExpression</i></a>, <a href="#OrOrExpression"><i>OrOrExpression</i></a>, and
<a href="#AndAndExpression"><i>AndAndExpression</i></a> are evaluated in lexical order (left-to-right). Example:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> i = 2;
i = ++i * i++ + i;
<span class="d_keyword">assert</span>(i == 3 * 3 + 4);
</pre>

</div>
<div class="blankline"></div>
<p><a href="#OrOrExpression"><i>OrOrExpression</i></a> and <a href="#AndAndExpression"><i>AndAndExpression</i></a> evaluate their left-hand side argument
first. Then, <a href="#OrOrExpression"><i>OrOrExpression</i></a> evaluates its right-hand side if and only if its left-hand
side does not evaluate to nonzero. <a href="#AndAndExpression"><i>AndAndExpression</i></a> evaluates its right-hand side if and
only if its left-hand side evaluates to nonzero.</p>
<div class="blankline"></div>
<p><a href="#ConditionalExpression"><i>ConditionalExpression</i></a> evaluates its left-hand side argument
first. Then, if the result is nonzero, the second operand is evaluated. Otherwise, the third operand
is evaluated.</p>
<div class="blankline"></div>
<p>Calls to functions  with <span class="d_inlinecode donthyphenate notranslate">extern(D)</span> <a href="../spec/attribute.html#linkage">linkage</a> (which is
the default linkage) are evaluated in the following order: first, if necessary, the address of the
function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then,
arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b, <span class="d_keyword">int</span> c) fun()
{
    writeln(<span class="d_string">"fun() called"</span>);
    <span class="d_keyword">static</span> <span class="d_keyword">void</span> r(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b, <span class="d_keyword">int</span> c) { writeln(<span class="d_string">"callee called"</span>); }
    <span class="d_keyword">return</span> &amp;r;
}
<span class="d_keyword">int</span> f1() { writeln(<span class="d_string">"f1() called"</span>); <span class="d_keyword">return</span> 1; }
<span class="d_keyword">int</span> f2() { writeln(<span class="d_string">"f2() called"</span>); <span class="d_keyword">return</span> 2; }
<span class="d_keyword">int</span> f3(<span class="d_keyword">int</span> x) { writeln(<span class="d_string">"f3() called"</span>); <span class="d_keyword">return</span> x + 3; }
<span class="d_keyword">int</span> f4() { writeln(<span class="d_string">"f4() called"</span>); <span class="d_keyword">return</span> 4; }

<span class="d_comment">// evaluates fun() then f1() then f2() then f3() then f4()
</span><span class="d_comment">// after which control is transferred to the callee
</span>fun()(f1(), f3(f2()), f4());
</pre>

</div>
<div class="blankline"></div>
    <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b>     <ol>    <li>The order of evaluation of the operands of <a href="#AssignExpression"><i>AssignExpression</i></a>.</li>
    <li>The order of evaluation of function arguments for functions with linkage other than <span class="d_inlinecode donthyphenate notranslate">extern (D)</span>.</li>
    </ol></div>


<div class="blankline"></div>
    <div class="spec-boxes best-practice"><b>Best Practices:</b> Even though the order of evaluation is well-defined, writing code that
    depends on it is rarely recommended.</div>


<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="temporary-lifetime" href="#temporary-lifetime">Lifetime of Temporaries</a></h2>
<div class="blankline"></div>
<p>Expressions and statements may create and/or consume rvalues. Such values are called
<i>temporaries</i> and do not have a name or a visible scope. Their lifetime is managed automatically
as defined in this section.</p>
<div class="blankline"></div>
<p>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the
evaluation point, similarly to creation of a usual named value initialized with an expression.</p>
<div class="blankline"></div>
<p>Termination of lifetime of temporaries does not obey the customary scoping rules and is defined
as follows:</p>
<div class="blankline"></div>
<ul><li>If:
<ol><li>the full expression has a smallest short-circuit expression <i>expr</i>; and</li>
<li>the temporary is created on the right-hand side of the <span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> or <span class="d_inlinecode donthyphenate notranslate">||</span> operator; and</li>
<li>the right-hand side is evaluated,</li></ol>
then temporary destructors are evaluated right after the right-hand side
expression has been evaluated and converted to <span class="d_inlinecode donthyphenate notranslate">bool</span>. Evaluation of destructors proceeds in
reverse order of construction.</li>
<div class="blankline"></div>
<li>For all other cases, the temporaries generated for the purpose of invoking functions are
deferred to the end of the full expression. The order of destruction is inverse to the order of
construction.</li></ul>
<div class="blankline"></div>
<p>If a subexpression of an expression throws an exception, all temporaries created up to the
evaluation of that subexpression will be destroyed per the rules above. No destructor calls will
be issued for temporaries not yet constructed.</p>
<div class="blankline"></div>
<p>Note: An intuition behind these rules is that destructors of temporaries are deferred to the end of full
expression and in reverse order of construction, with the exception that the right-hand side of
<span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> and <span class="d_inlinecode donthyphenate notranslate">||</span> are considered their own full expressions even when part of larger expressions.</p>
<div class="blankline"></div>
<p>Note: The <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <i>e<sub>1</sub> ? e<sub>2</sub> : e<sub>3</sub></i> is not
a special case although it evaluates expressions conditionally: <i>e<sub>1</sub></i> and one of
<i>e<sub>2</sub></i> and <i>e<sub>3</sub></i> may create temporaries. Their destructors are inserted
to the end of the full expression in the reverse order of creation.</p>
<div class="blankline"></div>
<p>Example:</p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) { x = n; writefln(<span class="d_string">"S(%s)"</span>, x); }
    ~<span class="d_keyword">this</span>() { writefln(<span class="d_string">"~S(%s)"</span>, x); }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">bool</span> b = (S(1) == S(2) || S(3) != S(4)) &amp;&amp; S(5) == S(6);
}
</pre>

</div>
<div class="blankline"></div>
The output of the code above is:
<div class="blankline"></div>
<pre class="console notranslate">S(1)
S(2)
S(3)
S(4)
~S(4)
~S(3)
S(5)
S(6)
~S(6)
~S(5)
~S(2)
~S(1)
</pre>
<div class="blankline"></div>
First, <span class="d_inlinecode donthyphenate notranslate">S(1)</span> and <span class="d_inlinecode donthyphenate notranslate">S(2)</span> are evaluated in lexical order. Per the rules, they will be destroyed at
the end of the full expression and in reverse order. The comparison <span class="d_inlinecode donthyphenate notranslate">S(1) == S(2)</span> yields
<span class="d_inlinecode donthyphenate notranslate">false</span>, so the right-hand side of the <span class="d_inlinecode donthyphenate notranslate">||</span> is evaluated causing <span class="d_inlinecode donthyphenate notranslate">S(3)</span> and <span class="d_inlinecode donthyphenate notranslate">S(4)</span> to be evaluated,
also in lexical order. However, their destruction is not deferred to the end of the full
expression. Instead, <span class="d_inlinecode donthyphenate notranslate">S(4)</span> and then <span class="d_inlinecode donthyphenate notranslate">S(3)</span> are destroyed at the end of the <span class="d_inlinecode donthyphenate notranslate">||</span> expression.
Following their destruction, <span class="d_inlinecode donthyphenate notranslate">S(5)</span> and <span class="d_inlinecode donthyphenate notranslate">S(6)</span> are constructed in lexical order. Again they are not
destroyed at the end of the full expression, but right at the end of the <span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> expression.
Consequently, the destruction of <span class="d_inlinecode donthyphenate notranslate">S(6)</span> and <span class="d_inlinecode donthyphenate notranslate">S(5)</span> is carried before that of <span class="d_inlinecode donthyphenate notranslate">S(2)</span> and <span class="d_inlinecode donthyphenate notranslate">S(1)</span>.
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="comma_expression" href="#comma_expression">Comma Expression</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CommaExpression"><span class="gname">CommaExpression</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <i>CommaExpression</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The left operand of the <span class="d_inlinecode donthyphenate notranslate">,</span> is evaluated, then the right operand
        is evaluated. The type of the expression is the type of the right
        operand, and the result is the result of the right operand.
        Using the result of comma expressions isn't allowed.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="assign_expressions" href="#assign_expressions">Assign Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AssignExpression"><span class="gname">AssignExpression</span></a>:
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">+=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">-=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">*=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">/=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">%=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&amp;=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">|=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">^=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">~=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&lt;&lt;=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">^^=</span> <i>AssignExpression</i>
</pre>
<div class="blankline"></div>
    <p>For all assign expressions, the left operand must be a modifiable
    lvalue. The type of the assign expression is the type of the left
    operand, and the result is the value of the left operand after assignment
    occurs. The resulting expression is a modifiable lvalue.
    </p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b>     If either operand is a reference type and one of the following:
    <ol>    <li>the operands have partially overlapping storage</li>
    <li>the operands' storage overlaps exactly but the types are different</li>
    </ol></div>


<div class="blankline"></div>
    <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b>     If neither operand is a reference type and one of the following:
    <ol>    <li>the operands have partially overlapping storage</li>
    <li>the operands' storage overlaps exactly but the types are different</li>
    </ol></div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="simple_assignment_expressions" href="#simple_assignment_expressions">Simple Assignment Expression</a></h3>
<div class="blankline"></div>
    <p>If the operator is <span class="d_inlinecode donthyphenate notranslate">=</span> then it is simple assignment.
    </p>
<div class="blankline"></div>
    <ul>    <li>If the left operand is a struct that
    <a href="../spec/operatoroverloading.html#assignment">defines <span class="d_inlinecode donthyphenate notranslate">opAssign</span></a>,
    the behaviour is defined by the overloaded function.
    </li>
<div class="blankline"></div>
    <li>If the left and right operands are of the same struct type, and the struct
    type has a <a href="../spec/struct.html#Postblit"><i>Postblit</i></a>, then the copy operation is
    as described in <a href="../spec/struct.html#struct-postblit">Struct Postblit</a>.
    </li>
<div class="blankline"></div>
    <li>If the lvalue is the <span class="d_inlinecode donthyphenate notranslate">.length</span> property of a dynamic array, the behavior is
    as described in <a href="../spec/arrays.html#resize">Setting Dynamic Array Length</a>.
    </li>
<div class="blankline"></div>
    <li>If the lvalue is a static array or a slice, the behavior is as
    described in <a href="../spec/arrays.html#array-copying">Array Copying</a> and
    <a href="../spec/arrays.html#array-setting">Array Setting</a>.
    </li>
<div class="blankline"></div>
    <li>If the lvalue is a user-defined property, the behavior is as
    described in <a href="../spec/function.html#property-functions">Property Functions</a>.
    </li>
    </ul>
<div class="blankline"></div>
    <p>Otherwise, the right operand is implicitly converted to the type of the
    left operand, and assigned to it.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="assignment_operator_expressions" href="#assignment_operator_expressions">Assignment Operator Expressions</a></h3>
<div class="blankline"></div>
    <p>For arguments of built-in types, assignment operator expressions such as</p>
<div class="blankline"></div>
<pre class="d_code notranslate">a op= b
</pre>
<div class="blankline"></div>
        are semantically equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate">a = <span class="d_keyword">cast</span>(<span class="d_keyword">typeof</span>(a))(a op b)
</pre>
<div class="blankline"></div>
    except that:
<div class="blankline"></div>
    <ul>        <li>operand <span class="d_inlinecode donthyphenate notranslate">a</span> is only evaluated once,</li>
        <li>overloading <i>op</i> uses a different function than overloading <i>op</i><span class="d_inlinecode donthyphenate notranslate">=</span> does, and</li>
        <li>the left operand of <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;=</span> does not undergo <a href="../spec/type.html#integer-promotions">Integer Promotions</a> before shifting.</li>
    </ul>
<div class="blankline"></div>
    <p>For user-defined types, assignment operator expressions are
        <a href="../spec/operatoroverloading.html#op-assign">overloaded separately</a> from
        the binary operators. Still the left operand must be an lvalue.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="conditional_expressions" href="#conditional_expressions">Conditional Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ConditionalExpression"><span class="gname">ConditionalExpression</span></a>:
    <a href="#OrOrExpression"><i>OrOrExpression</i></a>
    <a href="#OrOrExpression"><i>OrOrExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">?</span> <a href="#Expression"><i>Expression</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>ConditionalExpression</i>
</pre>
<div class="blankline"></div>
    <p>The first expression is converted to <span class="d_inlinecode donthyphenate notranslate">bool</span>, and is evaluated.
    </p>
<div class="blankline"></div>
    <p>If it is <span class="d_inlinecode donthyphenate notranslate">true</span>, then the second expression is evaluated, and
        its result is the result of the conditional expression.
    </p>
<div class="blankline"></div>
    <p>If it is <span class="d_inlinecode donthyphenate notranslate">false</span>, then the third expression is evaluated, and
        its result is the result of the conditional expression.
    </p>
<div class="blankline"></div>
    <p>If either the second or third expressions are of type <span class="d_inlinecode donthyphenate notranslate">void</span>,
        then the resulting type is <span class="d_inlinecode donthyphenate notranslate">void</span>. Otherwise, the second and third
        expressions are implicitly converted to a common type which becomes
        the result type of the conditional expression.
    </p>
<div class="blankline"></div>
    <p><b>Note:</b>
        When a conditional expression is the left operand of
        an <a href="#assign_expressions">assign expression</a>,
        parentheses are required for disambiguation:
    </p>
<pre class="d_code notranslate"><span class="d_keyword">bool</span> test;
<span class="d_keyword">int</span> a, b, c;
...
test ? a = b : c = 2;   <span class="d_comment">// Deprecated
</span>(test ? a = b : c) = 2; <span class="d_comment">// Equivalent
</span></pre>
<div class="blankline"></div>
    <p>This makes the intent clearer, because the first statement can
        easily be misread as the following code:
    </p>
<pre class="d_code notranslate">test ? a = b : (c = 2);
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="logical_expressions" href="#logical_expressions">Logical Expressions</a></h2>
<div class="blankline"></div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#UnaryExpression"><i>UnaryExpression</i></a> for <span class="d_inlinecode donthyphenate notranslate">!expr</span>.</div></div>

<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="oror_expressions" href="#oror_expressions">OrOr Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="OrOrExpression"><span class="gname">OrOrExpression</span></a>:
    <a href="#AndAndExpression"><i>AndAndExpression</i></a>
    <i>OrOrExpression</i> <span class="d_inlinecode donthyphenate notranslate">||</span> <a href="#AndAndExpression"><i>AndAndExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The result type of an <i>OrOrExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span>, unless the right operand
        has type <span class="d_inlinecode donthyphenate notranslate">void</span>, when the result is type <span class="d_inlinecode donthyphenate notranslate">void</span>.
    </p>
<div class="blankline"></div>
    <p>The <i>OrOrExpression</i> evaluates its left operand.
    </p>
<div class="blankline"></div>
    <p>If the left operand, converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>, evaluates to
        <span class="d_inlinecode donthyphenate notranslate">true</span>, then the right operand is not evaluated. If the result type of
        the <i>OrOrExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is <span class="d_inlinecode donthyphenate notranslate">true</span>.
    </p>
<div class="blankline"></div>
    <p>If the left operand is <span class="d_inlinecode donthyphenate notranslate">false</span>, then the right
        operand is evaluated.
        If the result type of
        the <i>OrOrExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is the right operand converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="andand_expressions" href="#andand_expressions">AndAnd Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AndAndExpression"><span class="gname">AndAndExpression</span></a>:
    <a href="#OrExpression"><i>OrExpression</i></a>
    <i>AndAndExpression</i> <span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> <a href="#OrExpression"><i>OrExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The result type of an <i>AndAndExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span>, unless the right operand
        has type <span class="d_inlinecode donthyphenate notranslate">void</span>, when the result is type <span class="d_inlinecode donthyphenate notranslate">void</span>.
    </p>
<div class="blankline"></div>
    <p>The <i>AndAndExpression</i> evaluates its left operand.
    </p>
<div class="blankline"></div>
    <p>If the left operand, converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>, evaluates to
        <span class="d_inlinecode donthyphenate notranslate">false</span>, then the right operand is not evaluated. If the result type of
        the <i>AndAndExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is <span class="d_inlinecode donthyphenate notranslate">false</span>.
    </p>
<div class="blankline"></div>
    <p>If the left operand is <span class="d_inlinecode donthyphenate notranslate">true</span>, then the right
        operand is evaluated.
        If the result type of
        the <i>AndAndExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is the right operand converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="bitwise_expressions" href="#bitwise_expressions">Bitwise Expressions</a></h2>
<div class="blankline"></div>
    <p>Bit wise expressions perform a
    <a href="https://en.wikipedia.org/wiki/Bitwise_operation">bitwise operation</a> on their operands.
        Their operands must be integral types.
        First, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are done. Then, the bitwise
        operation is done.
    </p>
    <div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#ShiftExpression"><i>ShiftExpression</i></a>, <a href="#ComplementExpression"><i>ComplementExpression</i></a></div></div>

<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="or_expressions" href="#or_expressions">Or Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="OrExpression"><span class="gname">OrExpression</span></a>:
    <a href="#XorExpression"><i>XorExpression</i></a>
    <i>OrExpression</i> <span class="d_inlinecode donthyphenate notranslate">|</span> <a href="#XorExpression"><i>XorExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands are OR'd together.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="xor_expressions" href="#xor_expressions">Xor Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="XorExpression"><span class="gname">XorExpression</span></a>:
    <a href="#AndExpression"><i>AndExpression</i></a>
    <i>XorExpression</i> <span class="d_inlinecode donthyphenate notranslate">^</span> <a href="#AndExpression"><i>AndExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands are XOR'd together.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="and_expressions" href="#and_expressions">And Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AndExpression"><span class="gname">AndExpression</span></a>:
    <a href="#CmpExpression"><i>CmpExpression</i></a>
    <i>AndExpression</i> <span class="d_inlinecode donthyphenate notranslate">&amp;</span> <a href="#CmpExpression"><i>CmpExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands are AND'd together.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="compare_expressions" href="#compare_expressions">Compare Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CmpExpression"><span class="gname">CmpExpression</span></a>:
    <a href="#EqualExpression"><i>EqualExpression</i></a>
    <a href="#IdentityExpression"><i>IdentityExpression</i></a>
    <a href="#RelExpression"><i>RelExpression</i></a>
    <a href="#InExpression"><i>InExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="equality_expressions" href="#equality_expressions">Equality Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="EqualExpression"><span class="gname">EqualExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">!=</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>Equality expressions compare the two operands for equality (<span class="d_inlinecode donthyphenate notranslate">==</span>)
        or inequality (<span class="d_inlinecode donthyphenate notranslate">!=</span>).
        The type of the result is <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
    <p>Inequality is defined as the logical negation of equality.</p>
<div class="blankline"></div>
    <p>If the operands are integral values, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are applied
        to bring them to a common type before comparison. Equality is defined as the bit patterns
        of the common type match exactly.
    </p>
<div class="blankline"></div>
    <p>If the operands are pointers, equality is defined as the bit patterns of the operands
        match exactly.
    </p>
<div class="blankline"></div>
    <p>For float, double, and real values, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are applied
        to bring them to a common type before comparison.
        The values <span class="d_inlinecode donthyphenate notranslate">-0</span> and <span class="d_inlinecode donthyphenate notranslate">+0</span> are considered equal.
        If either or both operands are NaN, then <span class="d_inlinecode donthyphenate notranslate">==</span> returns false and <span class="d_inlinecode donthyphenate notranslate">!=</span> returns <span class="d_inlinecode donthyphenate notranslate">true</span>.
        Otherwise, the bit patterns of the common type are compared for equality.
    </p>
<div class="blankline"></div>
    <p>For static and dynamic arrays, equality is defined as the
        lengths of the arrays
        matching, and all the elements are equal.
    </p>
<div class="blankline"></div>
    <div class="keyval Deprecated"><span class="key keyDeprecated">Deprecated:</span> <div class="val valDeprecated">For complex numbers, equality is defined as equivalent to:</div></div>

<div class="blankline"></div>
<pre class="d_code notranslate">x.re == y.re &amp;&amp; x.im == y.im
</pre>
<div class="blankline"></div>
    <h4><a class="anchor" title="Permalink to this section" id="class_struct_equality" href="#class_struct_equality">Class &amp; Struct Equality</a></h4>
<div class="blankline"></div>
    <p>For struct objects, equality means the result of the
        <a href="https://dlang.org/spec/operatoroverloading.html#equals"><span class="d_inlinecode donthyphenate notranslate">opEquals()</span> member function</a>.
        If an <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> is not provided, equality is defined as
        the logical product of all equality
        results of the corresponding object fields.
    </p>
<div class="blankline"></div>
        <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b> The contents of any alignment gaps in the struct object.</div>


<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b> If there are overlapping fields, which happens with unions, the default
        equality will compare each of the overlapping fields.
        An <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> can account for which of the overlapping fields contains valid data.
        An <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> can override the default behavior of floating point NaN values
        always comparing as unequal.
        Be careful using <span class="d_inlinecode donthyphenate notranslate">memcmp()</span> to implement <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> if:</div>


<div class="blankline"></div>
        <ul>        <li>there are any alignment gaps</li>
        <li>any fields have an <span class="d_inlinecode donthyphenate notranslate">opEquals()</span></li>
        <li>there are any floating point fields that may contain NaN or <span class="d_inlinecode donthyphenate notranslate">-0</span> values</li>
        </ul>
<div class="blankline"></div>
    <p>For class and struct objects, the expression <span class="d_inlinecode donthyphenate notranslate">(a == b)</span>
        is rewritten as
        <span class="d_inlinecode donthyphenate notranslate">a.opEquals(b)</span>, and <span class="d_inlinecode donthyphenate notranslate">(a != b)</span> is rewritten as
        <span class="d_inlinecode donthyphenate notranslate">!a.opEquals(b)</span>.
    </p>
<div class="blankline"></div>
    <p>For class objects, the <span class="d_inlinecode donthyphenate notranslate">==</span> and <span class="d_inlinecode donthyphenate notranslate">!=</span>
        operators are intended to compare the contents of the objects,
        however an appropriate <span class="d_inlinecode donthyphenate notranslate">opEquals</span> override must be defined for this to work.
        The default <span class="d_inlinecode donthyphenate notranslate">opEquals</span> provided by the root <span class="d_inlinecode donthyphenate notranslate">Object</span> class is
        equivalent to the <span class="d_inlinecode donthyphenate notranslate">is</span> operator (see below).
        Comparing against <span class="d_inlinecode donthyphenate notranslate">null</span> is invalid, as <span class="d_inlinecode donthyphenate notranslate">null</span> has no contents.
        Use the <span class="d_inlinecode donthyphenate notranslate">is</span> and <span class="d_inlinecode donthyphenate notranslate">!is</span> operators instead.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C;
C c;
<span class="d_keyword">if</span> (c == <span class="d_keyword">null</span>)  <span class="d_comment">// error
</span>    ...
<span class="d_keyword">if</span> (c <span class="d_keyword">is</span> <span class="d_keyword">null</span>)  <span class="d_comment">// ok
</span>    ...
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="identity_expressions" href="#identity_expressions">Identity Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="IdentityExpression"><span class="gname">IdentityExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">is</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">! is</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">is</span> operator compares for identity.
        To compare for nonidentity, use <span class="d_inlinecode donthyphenate notranslate">e1 !is e2</span>.
        The type of the result is <span class="d_inlinecode donthyphenate notranslate">bool</span>. The operands
        undergo the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> to bring them to a common type before
        comparison.
    </p>
<div class="blankline"></div>
    <p>For class objects, identity is defined as the object references
        are for the same object. Null class objects can be compared with
        <span class="d_inlinecode donthyphenate notranslate">is</span>.
    </p>
<div class="blankline"></div>
    <p>For struct objects and floating point values, identity is defined as the
        bits in the operands being identical.
    </p>
<div class="blankline"></div>
    <p>For static and dynamic arrays, identity of two arrays is given when
    both arrays refer to the same memory location and contain the same number
    of elements.
    </p>
<div class="blankline"></div>
    <div class="runnable-examples">
<pre class="d_code notranslate">Object o;
<span class="d_keyword">assert</span>(o <span class="d_keyword">is</span> <span class="d_keyword">null</span>);

<span class="d_keyword">auto</span> a = [1, 2];
<span class="d_keyword">assert</span>(a <span class="d_keyword">is</span> a[0..$]);
<span class="d_keyword">assert</span>(a !<span class="d_keyword">is</span> a[0..1]);

<span class="d_keyword">auto</span> b = [1, 2];
<span class="d_keyword">assert</span>(a !<span class="d_keyword">is</span> b);
</pre>
    
</div>
<div class="blankline"></div>
    <p>For other operand types, identity is defined as being the same
        as equality.
    </p>
<div class="blankline"></div>
    <p>The identity operator <span class="d_inlinecode donthyphenate notranslate">is</span> cannot be overloaded.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="relation_expressions" href="#relation_expressions">Relational Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="RelExpression"><span class="gname">RelExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&lt;</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&lt;=</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;=</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>First, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are done on the operands.
        The result type of a relational expression is <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="array_comparisons" href="#array_comparisons">Array Comparisons</a></h3>
<div class="blankline"></div>
    <p>For static and dynamic arrays, the result of a <em>CmpExpression</em>
        is the result of the operator applied to the first non-equal
        element of the array. If two arrays compare equal, but are of
        different lengths, the shorter array compares as "less" than the
        longer array.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="integer_comparisons" href="#integer_comparisons">Integer Comparisons</a></h3>
<div class="blankline"></div>
    <p>Integer comparisons happen when both operands are integral
        types.
    </p>
<div class="blankline"></div>
    <center><table><caption>Integer comparison operators</caption>        <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Relation</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span></td><td>less</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;</span></td><td>greater</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td>less or equal</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;=</span></td><td>greater or equal</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">==</span></td><td>equal</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">!=</span></td><td>not equal</td></tr>
    </table></center>
<div class="blankline"></div>
    <p>It is an error to have one operand be signed and the other
        unsigned for a <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span> or
        <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">=</span> expression.
        Use <a href="#cast_integers">casts</a> to make both operands signed or both operands unsigned.
    </p>
<div class="blankline"></div>
<h3><span id="floating_point_comparisons"><a class="anchor" title="Permalink to this section" id="floating-point-comparisons" href="#floating-point-comparisons">Floating Point Comparisons</a></span></h3>
<div class="blankline"></div>
    <p>If one or both operands are floating point, then a floating
        point comparison is performed.
    </p>
<div class="blankline"></div>
    <p>A <em>CmpExpression</em> can have <span class="d_inlinecode donthyphenate notranslate">NaN</span> operands.
        If either or both operands is <span class="d_inlinecode donthyphenate notranslate">NaN</span>, the floating point
        comparison operation returns as follows:</p>
<div class="blankline"></div>
        <center><table><caption>Floating point comparison operators</caption>        <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Relation</b></th><th class="donthyphenate"><b>Returns</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span></td><td>less</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;</span></td><td>greater</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td>less or equal</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;=</span></td><td>greater or equal</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">==</span></td><td>equal</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">!=</span></td><td>unordered, less, or greater</td><td><span class="d_inlinecode donthyphenate notranslate">true</span></td></tr>
        </table></center>
<div class="blankline"></div>
    <div class="spec-boxes best-practice"><b>Best Practices:</b> Although <em>IdentityExpression</em> can be used to check for <span class="d_inlinecode donthyphenate notranslate">T.nan</span>,
    there are other floating-point values for NaN produced at runtime.
    Use <a href="../phobos/std_math_traits.html#.isNaN"><span class="d_inlinecode donthyphenate notranslate">std.math.traits.isNaN</span></a> to handle all of them.</div>


<div class="blankline"></div>
<h3><span id="class_comparisons"><a class="anchor" title="Permalink to this section" id="class-comparisons" href="#class-comparisons">Class Comparisons</a></span></h3>
<div class="blankline"></div>
    <p>For class objects, <em>EqualExpression</em> and <em>RelExpression</em> compare the
        <em>contents</em> of the objects. Therefore, comparing against
        a <span class="d_inlinecode donthyphenate notranslate">null</span> class reference is invalid, as <span class="d_inlinecode donthyphenate notranslate">null</span> has no contents.</p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C {}

<span class="d_keyword">void</span> fun()
{
    C c;
    <span class="d_comment">//if (c &lt; null) {}  // compile-time error
</span>    <span class="d_keyword">assert</span>(c <span class="d_keyword">is</span> <span class="d_keyword">null</span>);
    <span class="d_keyword">if</span> (c &gt; <span class="d_keyword">new</span> C) {}  <span class="d_comment">// runtime error
</span>}
</pre>
        
</div>
<div class="blankline"></div>
    <p>For class objects, the result of <span class="d_inlinecode donthyphenate notranslate">Object.opCmp()</span> forms the left
        operand, and <span class="d_inlinecode donthyphenate notranslate">0</span> forms the right operand. The result of an
        <em>EqualExpression</em> or <em>RelExpression</em> <span class="d_inlinecode donthyphenate notranslate">(o1 op o2)</span> is:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">(o1.opCmp(o2) op 0)
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="in_expressions" href="#in_expressions">In Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="InExpression"><span class="gname">InExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">in</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">! in</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
<p>A container such as an associative array
    <a href="../spec/hash-map.html#testing_membership">can be tested</a> to see if it contains a certain key:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo[string];
...
<span class="d_keyword">if</span> (<span class="d_string">"hello"</span> <span class="d_keyword">in</span> foo)
{
    <span class="d_comment">// the string was found
</span>}
</pre>
<div class="blankline"></div>
    <p>The result of an <i>InExpression</i> is a pointer for associative
        arrays.
        The pointer is <span class="d_inlinecode donthyphenate notranslate">null</span> if the container has no matching key.
        If there is a match, the pointer points to a value associated
        with the key.
    </p>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">!in</span> expression is the logical negation of the <span class="d_inlinecode donthyphenate notranslate">in</span>
        operation.
    </p>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">in</span> expression has the same precedence as the
        relational expressions <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, etc.</p>
<div class="blankline"></div>
    <div class="spec-boxes note"><b>Note:</b> When <a href="../spec/operatoroverloading.html#binary">overloading</a>
        <span class="d_inlinecode donthyphenate notranslate">in</span>, normally only <em class="tt">opBinaryRight</em> would be defined. This is
        because the operation is usually not defined by the key type but by
        the container, which appears on the right hand side of the <span class="d_inlinecode donthyphenate notranslate">in</span>
        operator.</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="shift_expressions" href="#shift_expressions">Shift Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ShiftExpression"><span class="gname">ShiftExpression</span></a>:
    <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="d_inlinecode donthyphenate notranslate">&lt;&lt;</span> <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;</span> <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;</span> <a href="#AddExpression"><i>AddExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands must be integral types, and undergo the <a href="../spec/type.html#integer-promotions">Integer Promotions</a>.
        The result type is the type of the left operand after
        the promotions. The result value is the result of shifting the bits
        by the right operand's value.
    </p>
<div class="blankline"></div>
    <ul>        <li><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">&lt;</span> is a left shift.</li>
        <li><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span> is a signed right shift.</li>
        <li><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span> is an unsigned right shift.</li>
    </ul>
<div class="blankline"></div>
    <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b>     The result of a shift by a negative value or by the same or more bits
    than the size of the quantity being shifted is undefined.
    When the shift amount is known at compile time, doing this results in
    a compile error.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> c;

<span class="d_keyword">int</span> s = -3;
<span class="d_keyword">auto</span> y = c &lt;&lt; s; <span class="d_comment">// implementation defined value
</span>
<span class="d_keyword">auto</span> x = c &lt;&lt; 33;  <span class="d_comment">// error, max shift count allowed is 31
</span></pre>
    </div>


<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="add_expressions" href="#add_expressions">Add Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AddExpression"><span class="gname">AddExpression</span></a>:
    <a href="#MulExpression"><i>MulExpression</i></a>
    <i>AddExpression</i> <span class="d_inlinecode donthyphenate notranslate">+</span> <a href="#MulExpression"><i>MulExpression</i></a>
    <i>AddExpression</i> <span class="d_inlinecode donthyphenate notranslate">-</span> <a href="#MulExpression"><i>MulExpression</i></a>
    <a href="#CatExpression"><i>CatExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>If the operands are of integral types, they undergo the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>,
        and then are brought to a common type using the
        <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>.
    </p>
<div class="blankline"></div>
    <p>If both operands are of integral types and an overflow or underflow
        occurs in the computation, wrapping will happen. For example:</p>
    <ul>        <li><span class="d_inlinecode donthyphenate notranslate">uint.max + 1 == uint.min</span></li>
        <li><span class="d_inlinecode donthyphenate notranslate">uint.min - 1 == uint.max</span></li>
        <li><span class="d_inlinecode donthyphenate notranslate">int.max + 1 == int.min</span></li>
        <li><span class="d_inlinecode donthyphenate notranslate">int.min - 1 == int.max</span></li>
    </ul>
<div class="blankline"></div>
    <p>If either operand is a floating point type, the other is implicitly
        converted to floating point and they are brought to a common type
        via the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>.
    </p>
<div class="blankline"></div>
    <p>Add expressions for floating point operands are not associative.
    </p>
<div class="blankline"></div>
    <h3><a class="anchor" title="Permalink to this section" id="pointer_arithmetic" href="#pointer_arithmetic">Pointer Arithmetic</a></h3>
<div class="blankline"></div>
    <p>If the operator is <span class="d_inlinecode donthyphenate notranslate">+</span> or <span class="d_inlinecode donthyphenate notranslate">-</span>, and
        the first operand is a pointer, and the second is an integral type,
        the resulting type is the type of the first operand, and the resulting
        value is the pointer plus (or minus) the second operand multiplied by
        the size of the type pointed to by the first operand.
    </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [1,2,3];
<span class="d_keyword">int</span>* p = a.ptr;
<span class="d_keyword">assert</span>(*p == 1);

*(p + 2) = 4; <span class="d_comment">// same as `p[2] = 4`
</span><span class="d_keyword">assert</span>(a[2] == 4);
</pre>

</div>
<div class="blankline"></div>
    <p><a href="#IndexExpression"><i>IndexExpression</i></a> can also be used with a pointer and has
    the same behaviour as adding an integer, then dereferencing the result.</p>
<div class="blankline"></div>
    <p>If the second operand is a pointer, and the first is an integral type,
        and the operator is <span class="d_inlinecode donthyphenate notranslate">+</span>,
        the operands are reversed and the pointer arithmetic just described
        is applied.
    </p>
<div class="blankline"></div>
    <p>Producing a pointer through pointer arithmetic is not allowed in
        <a href="../spec/memory-safe-d.html"><span class="d_inlinecode donthyphenate notranslate">@safe</span></a> code.</p>
<div class="blankline"></div>
    <p>If both operands are pointers, and the operator is <span class="d_inlinecode donthyphenate notranslate">+</span>,
        then it is illegal.
    </p>
<div class="blankline"></div>
    <p>If both operands are pointers, and the operator is <span class="d_inlinecode donthyphenate notranslate">-</span>,
        the pointers are subtracted and the
        result is divided by the size of the type pointed to by the
        operands. In this calculation the assumed size of <span class="d_inlinecode donthyphenate notranslate">void</span> is one byte.
        It is an error if the pointers point to different types.
        The type of the result is <span class="d_inlinecode donthyphenate notranslate">ptrdiff_t</span>.
    </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [1,2,3];
ptrdiff_t d = &amp;a[2] - a.ptr;
<span class="d_keyword">assert</span>(d == 2);
</pre>

</div>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="cat_expressions" href="#cat_expressions">Cat Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CatExpression"><span class="gname">CatExpression</span></a>:
    <a href="#AddExpression"><i>AddExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">~</span> <a href="#MulExpression"><i>MulExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>A <i>CatExpression</i> concatenates a container's data with other data, producing
        a new container.</p>
<div class="blankline"></div>
    <p>For a dynamic array, the other operand must either be another array or a
        single value that implicitly converts to the element type of the array.
        See <a href="../spec/arrays.html#array-concatenation">Array Concatenation</a>.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="mul_expressions" href="#mul_expressions">Mul Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="MulExpression"><span class="gname">MulExpression</span></a>:
    <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="d_inlinecode donthyphenate notranslate">*</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="d_inlinecode donthyphenate notranslate">/</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="d_inlinecode donthyphenate notranslate">%</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands must be arithmetic types.
        They undergo the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>.
    </p>
<div class="blankline"></div>
    <p>For integral operands, the <span class="d_inlinecode donthyphenate notranslate">*</span>, <span class="d_inlinecode donthyphenate notranslate">/</span>, and <span class="d_inlinecode donthyphenate notranslate">%</span>
        correspond to multiply, divide, and modulus operations.
        For multiply, overflows are ignored and simply chopped to fit
        into the integral type.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="division" href="#division">Division</a></h3>
<div class="blankline"></div>
    <p>For integral operands of the <span class="d_inlinecode donthyphenate notranslate">/</span> and <span class="d_inlinecode donthyphenate notranslate">%</span> operators,
        the quotient rounds towards zero and the remainder has the
        same sign as the dividend.
    </p>
<div class="blankline"></div>
    <p>The following divide or modulus integral operands:</p>
<div class="blankline"></div>
    <ul>    <li>denominator is 0</li>
    <li>signed <span class="d_inlinecode donthyphenate notranslate">int.min</span> is the numerator and <span class="d_inlinecode donthyphenate notranslate">-1</span> is the denominator</li>
    <li>signed <span class="d_inlinecode donthyphenate notranslate">long.min</span> is the numerator and <span class="d_inlinecode donthyphenate notranslate">-1L</span> is the denominator</li>
    </ul>
<div class="blankline"></div>
    <p>are illegal if encountered during Compile Time Execution.</p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b> is exhibited if they are encountered during run time.
        <a href="https://dlang.org/phobos/core_checkedint.html"><span class="d_inlinecode donthyphenate notranslate">core.checkedint</span></a>
        can be used to check for them and select a defined behavior.
    </div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="mul_floating" href="#mul_floating">Floating Point</a></h3>
<div class="blankline"></div>
    <p>For floating point operands, the <span class="d_inlinecode donthyphenate notranslate">*</span> and <span class="d_inlinecode donthyphenate notranslate">/</span> operations correspond
        to the IEEE 754 floating point equivalents. <span class="d_inlinecode donthyphenate notranslate">%</span> is not the same as
        the IEEE 754 remainder. For example, <span class="d_inlinecode donthyphenate notranslate">15.0 % 10.0 == 5.0</span>, whereas
        for IEEE 754, <span class="d_inlinecode donthyphenate notranslate">remainder(15.0,10.0) == -5.0</span>.
    </p>
<div class="blankline"></div>
    <p>Mul expressions for floating point operands are not associative.
    </p>
<div class="blankline"></div>
<h2><span id="UnaryExpression"><a class="anchor" title="Permalink to this section" id="unary-expression" href="#unary-expression">Unary Expressions</a></span></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="UnaryExpression"><span class="gname">UnaryExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">&amp;</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">++</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">--</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">*</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">-</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">+</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">!</span> <i>UnaryExpression</i>
    <a href="#ComplementExpression"><i>ComplementExpression</i></a>
    <a href="#DeleteExpression"><i>DeleteExpression</i></a>
    <a href="#CastExpression"><i>CastExpression</i></a>
    <a href="#ThrowExpression"><i>ThrowExpression</i></a>
    <a href="#PowExpression"><i>PowExpression</i></a>
</pre>
<div class="blankline"></div>
<table>    <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Description</b></th></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">&amp;</span></td><td>Take memory address of an <a href="#.define-lvalue">lvalue</a> - see <a href="../spec/type.html#pointers">pointers</a></td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">++</span></td><td>Increment before use - see <a href="#order-of-evaluation">order of evaluation</a></td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">--</span></td><td>Decrement before use</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">*</span></td><td>Dereference/indirection - typically for pointers</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">-</span></td><td>Negative</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">+</span></td><td>Positive</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">!</span></td><td>Logical NOT</td></tr>
</table>
<div class="blankline"></div>
    <p>The usual <a href="../spec/type.html#integer-promotions">Integer Promotions</a> are performed prior to unary
    <span class="d_inlinecode donthyphenate notranslate">-</span> and <span class="d_inlinecode donthyphenate notranslate">+</span> operations.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="complement_expressions" href="#complement_expressions">Complement Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ComplementExpression"><span class="gname">ComplementExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">~</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p><i>ComplementExpression</i>s work on integral types (except <span class="d_inlinecode donthyphenate notranslate">bool</span>).
        All the bits in the value are complemented.
        The usual <a href="../spec/type.html#integer-promotions">Integer Promotions</a> are performed
        prior to the complement operation.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="delete_expressions" href="#delete_expressions">Delete Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="DeleteExpression"><span class="gname">DeleteExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">delete</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
    <div class="keyval Deprecated"><span class="key keyDeprecated">Deprecated:</span> <div class="val valDeprecated"><span class="d_inlinecode donthyphenate notranslate">delete</span> has been deprecated.  Instead, please use <a href="../phobos/object.html#.destroy""><span class="d_inlinecode donthyphenate notranslate">destroy</span></a>
    if feasible, or <a href="../phobos/core_memory.html#.__delete"><span class="d_inlinecode donthyphenate notranslate">core.memory.__delete</span></a> as a last resort.</div></div>

<div class="blankline"></div>
    <p>If the <i>UnaryExpression</i> is a class object reference, and
        there is a destructor for that class, the destructor
        is called for that object instance.
    </p>
<div class="blankline"></div>
    <p>Next, if the <i>UnaryExpression</i> is a class object reference, or
        a pointer to a struct instance, and the class or struct
        has overloaded operator delete, then that operator delete is called
        for that class object instance or struct instance.
    </p>
<div class="blankline"></div>
    <p>Otherwise, the garbage collector is called to immediately free the
        memory allocated for the class instance or struct instance.
    </p>
<div class="blankline"></div>
    <p>If the <i>UnaryExpression</i> is a pointer or a dynamic array,
        the garbage collector is called to immediately release the
        memory.
    </p>
<div class="blankline"></div>
    <p>The pointer, dynamic array, or reference is set to <span class="d_inlinecode donthyphenate notranslate">null</span>
        after the delete is performed.
        Any attempt to reference the data after the deletion via another
        reference to it will result in undefined behavior.
    </p>
<div class="blankline"></div>
    <p>If <i>UnaryExpression</i> is a variable allocated
        on the stack, the class destructor (if any) is called for that
        instance. The garbage collector is not called.
    </p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b>     <ol>    <li>Using <span class="d_inlinecode donthyphenate notranslate">delete</span> to free memory not allocated by the garbage collector.</li>
    <li>Referring to data that has been the operand of <span class="d_inlinecode donthyphenate notranslate">delete</span>.</li>
    </ol></div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="cast_expressions" href="#cast_expressions">Cast Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CastExpression"><span class="gname">CastExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">cast (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <a href="#CastQual"><i>CastQual</i></a>
</pre>
<div class="blankline"></div>
    <p>A <i>CastExpression</i> converts the <i>UnaryExpression</i>
        to <i>Type</i>.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">cast</span>(foo) -p; <span class="d_comment">// cast (-p) to type foo
</span>(foo) - p;      <span class="d_comment">// subtract p from foo
</span></pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_basic_data_types" href="#cast_basic_data_types">Basic Data Types</a></h4>
    <p>For situations where <a href="../spec/type.html#implicit-conversions">implicit conversions</a>
        on basic types cannot be performed, the type system may be forced to accept the
        reinterpretation of a memory region by using a cast.
    </p>
<div class="blankline"></div>
    <p>An example of such a scenario is represented by trying to store a wider type
        into a narrower one:
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> a;
<span class="d_keyword">byte</span> b = a; <span class="d_comment">// cannot implicitly convert expression a of type int to byte
</span></pre>
<div class="blankline"></div>
    <p>When casting a source type that is wider than the destination type,
        the value is truncated to the destination size.
    </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> a = 64389; <span class="d_comment">// 00000000 00000000 11111011 10000101
</span><span class="d_keyword">byte</span> b = <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>) a;       <span class="d_comment">// 10000101
</span><span class="d_keyword">ubyte</span> c = <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>) a;     <span class="d_comment">// 10000101
</span><span class="d_keyword">short</span> d = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>) a;     <span class="d_comment">// 11111011 10000101
</span><span class="d_keyword">ushort</span> e = <span class="d_keyword">cast</span>(<span class="d_keyword">ushort</span>) a;   <span class="d_comment">// 11111011 10000101
</span>
writeln(b);
writeln(c);
writeln(d);
writeln(e);
</pre>
        
</div>
<div class="blankline"></div>
    <p>For integral types casting from a narrower type to a wider type
        is done by performing sign extension.
    </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">ubyte</span> a = 133;  <span class="d_comment">// 10000101
</span><span class="d_keyword">byte</span> b = a;     <span class="d_comment">// 10000101
</span>
writeln(a);
writeln(b);

<span class="d_keyword">ushort</span> c = a;   <span class="d_comment">// 00000000 10000101
</span><span class="d_keyword">short</span> d = b;    <span class="d_comment">// 11111111 10000101
</span>
writeln(c);
writeln(d);
</pre>
        
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_class" href="#cast_class">Class References</a></h4>
<div class="blankline"></div>
    <p>Any casting of a class reference to a
        derived class reference is done with a runtime check to make sure it
        really is a downcast. <span class="d_inlinecode donthyphenate notranslate">null</span> is the result if it isn't.
    </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">class</span> A {}
<span class="d_keyword">class</span> B : A {}

<span class="d_keyword">void</span> main()
{
    A a = <span class="d_keyword">new</span> A;
    <span class="d_comment">//B b = a;         // error, need cast
</span>    B b = <span class="d_keyword">cast</span>(B) a; <span class="d_comment">// b is null if a is not a B
</span>    <span class="d_keyword">assert</span>(b <span class="d_keyword">is</span> <span class="d_keyword">null</span>);

    a = b;         <span class="d_comment">// no cast needed
</span>    a = <span class="d_keyword">cast</span>(A) b; <span class="d_comment">// no runtime check needed for upcast
</span>    <span class="d_keyword">assert</span>(a <span class="d_keyword">is</span> b);
}
</pre>
        
</div>
<div class="blankline"></div>
    <p>In order to determine if an object <span class="d_inlinecode donthyphenate notranslate">o</span> is an instance of
        a class <span class="d_inlinecode donthyphenate notranslate">B</span> use a cast:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">if</span> (<span class="d_keyword">cast</span>(B) o)
{
    <span class="d_comment">// o is an instance of B
</span>}
<span class="d_keyword">else</span>
{
    <span class="d_comment">// o is not an instance of B
</span>}
</pre>
<div class="blankline"></div>
    <p>Casting a pointer type to and from a class type is done as a type paint
        (i.e. a reinterpret cast).
    </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_pointers" href="#cast_pointers">Pointers</a></h4>
    <p>Casting a pointer variable to another pointer type modifies the value that
        will be obtained as a result of dereferencing, along with the number of bytes
        on which pointer arithmetic is performed.
    </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> val = 25185; <span class="d_comment">// 00000000 00000000 01100010 01100001
</span><span class="d_keyword">char</span> *ch = <span class="d_keyword">cast</span>(<span class="d_keyword">char</span>*)(&amp;val);

writeln(*ch);    <span class="d_comment">// a
</span>writeln(<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>)(*ch)); <span class="d_comment">// 97
</span>writeln(*(ch + 1));  <span class="d_comment">// b
</span>writeln(<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>)(*(ch + 1)));   <span class="d_comment">// 98
</span></pre>
        
</div>
<div class="blankline"></div>
    <p>Similarly, when casting a dynamically allocated array to a type of smaller size,
        the bytes of the initial array will be divided and regrouped according to the new
        dimension.
    </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.stdc.stdlib;

<span class="d_keyword">int</span> *p = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*) malloc(5 * <span class="d_keyword">int</span>.sizeof);
<span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 5; i++) {
    p[i] = i + 'a';
}
<span class="d_comment">// p = [97, 98, 99, 100, 101]
</span>
<span class="d_keyword">char</span>* c = <span class="d_keyword">cast</span>(<span class="d_keyword">char</span>*) p;     <span class="d_comment">// c = [97, 0, 0, 0, 98, 0, 0, 0, 99 ...]
</span><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 5 * <span class="d_keyword">int</span>.sizeof; i++) {
    writeln(c[i]);
}
</pre>
        
</div>
<div class="blankline"></div>
    <p>When casting a pointer of type A to a pointer of type B and type B is wider than type A,
        attempts at accessing the memory exceeding the size of A will result in undefined behaviour.
    </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">char</span> c = 'a';
<span class="d_keyword">int</span> *p = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*) (&amp;c);
writeln(*p);
</pre>
        
</div>
<div class="blankline"></div>
    <p>It is also possible to cast pointers to basic data types.
        A common practice could be to cast the pointer to an int value
        and then print its address:
    </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.stdc.stdlib;

<span class="d_keyword">int</span> *p = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*) malloc(<span class="d_keyword">int</span>.sizeof);
<span class="d_keyword">int</span> a = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) p;
writeln(a);
</pre>
        
</div>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_array" href="#cast_array">Arrays</a></h4>
<div class="blankline"></div>
    <p>Casting a dynamic array to another dynamic array is done only if the
        array lengths multiplied by the element sizes match. The cast is done
        as a type paint, with the array length adjusted to match any change in
        element size. If there's not a match, a runtime error is generated.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">byte</span>[] a = [1,2,3];
<span class="d_comment">//auto b = cast(int[])a; // runtime error: array cast misalignment
</span>
<span class="d_keyword">int</span>[] c = [1, 2, 3];
<span class="d_keyword">auto</span> d = <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>[])c; <span class="d_comment">// ok
</span><span class="d_comment">// prints:
</span><span class="d_comment">// [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]
</span>writeln(d);
</pre>
        
</div>
<div class="blankline"></div>
    <div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#cast_array_literal">Casting array literals</a>.</div></div>

<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_static_array" href="#cast_static_array">Static Arrays</a></h4>
<div class="blankline"></div>
    <p>Casting a static array to another static array is done only if the
        array lengths multiplied by the element sizes match; a mismatch
        is illegal.
        The cast is done as a type paint (aka a reinterpret cast).
        The contents of the array are not changed.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">byte</span>[16] b = 3; <span class="d_comment">// set each element to 3
</span><span class="d_keyword">assert</span>(b[0] == 0x03);
<span class="d_keyword">int</span>[4] ia = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[4]) b;
<span class="d_comment">// print elements as hex
</span><span class="d_keyword">foreach</span> (i; ia)
    writefln(<span class="d_string">"%x"</span>, i);
<span class="d_comment">/* prints:
   3030303
   3030303
   3030303
   3030303
 */</span>
</pre>
        
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_integers" href="#cast_integers">Integers</a></h4>
<div class="blankline"></div>
    <p>Casting an integer to a smaller integral will truncate the
        value towards the least significant bits.
        If the target type is signed and the most significant bit is set
        after truncation, that bit will be lost from the value and
        the sign bit will be set.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">uint</span> a = 260;
<span class="d_keyword">auto</span> b = <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>) a;
<span class="d_keyword">assert</span>(b == 4); <span class="d_comment">// truncated like 260 &amp; 0xff
</span>
<span class="d_keyword">int</span> c = 128;
<span class="d_keyword">assert</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)c == -128); <span class="d_comment">// reinterpreted
</span></pre>
        
</div>
<div class="blankline"></div>
    <p>Converting between signed and unsigned types will reinterpret the
        value if the destination type cannot represent the source
        value.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">short</span> c = -1;
<span class="d_keyword">ushort</span> d = c;
<span class="d_keyword">assert</span>(d == <span class="d_keyword">ushort</span>.max);
<span class="d_keyword">assert</span>(<span class="d_keyword">uint</span>(c) == <span class="d_keyword">uint</span>.max);

<span class="d_keyword">ubyte</span> e = 255;
<span class="d_keyword">byte</span> f = e;
<span class="d_keyword">assert</span>(f == -1); <span class="d_comment">// reinterpreted
</span><span class="d_keyword">assert</span>(<span class="d_keyword">short</span>(e) == 255); <span class="d_comment">// no change
</span></pre>
        
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_floating" href="#cast_floating">Floating Point</a></h4>
<div class="blankline"></div>
    <p>Casting a floating point literal from one type to another
        changes its type, but internally it is retained at full
        precision for the purposes of constant folding.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">real</span> a = 3.40483L;
    <span class="d_keyword">real</span> b;
    b = 3.40483;     <span class="d_comment">// literal is not truncated to double precision
</span>    <span class="d_keyword">assert</span>(a == b);
    <span class="d_keyword">assert</span>(a == 3.40483);
    <span class="d_keyword">assert</span>(a == 3.40483L);
    <span class="d_keyword">assert</span>(a == 3.40483F);
    <span class="d_keyword">double</span> d = 3.40483; <span class="d_comment">// truncate literal when assigned to variable
</span>    <span class="d_keyword">assert</span>(d != a);     <span class="d_comment">// so it is no longer the same
</span>    <span class="d_keyword">const</span> <span class="d_keyword">double</span> x = 3.40483; <span class="d_comment">// assignment to const is not
</span>    <span class="d_keyword">assert</span>(x == a);     <span class="d_comment">// truncated if the initializer is visible
</span>}
</pre>
<div class="blankline"></div>
    <p>Casting a floating point value to an integral type is the equivalent
        of converting to an integer using truncation. If the floating point
        value is outside the range of the integral type, the cast will produce
        an invalid result (this is also the case in C, C++).</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> a = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) 0.8f;
    <span class="d_keyword">assert</span>(a == 0);
    <span class="d_keyword">long</span> b = <span class="d_keyword">cast</span>(<span class="d_keyword">long</span>) 1.5;
    <span class="d_keyword">assert</span>(b == 1L);
    <span class="d_keyword">long</span> c = <span class="d_keyword">cast</span>(<span class="d_keyword">long</span>) -1.5;
    <span class="d_keyword">assert</span>(c == -1);

    <span class="d_comment">// if the float overflows, the cast returns the integer value of
</span>    <span class="d_comment">// 80000000_00000000H (64-bit operand) or 80000000H (32-bit operand)
</span>    <span class="d_keyword">long</span> d = <span class="d_keyword">cast</span>(<span class="d_keyword">long</span>) <span class="d_keyword">float</span>.max;
    <span class="d_keyword">assert</span>(d == <span class="d_keyword">long</span>.min);
    <span class="d_keyword">int</span> e = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) (1234.5 + <span class="d_keyword">int</span>.max);
    <span class="d_keyword">assert</span>(e == <span class="d_keyword">int</span>.min);

    <span class="d_comment">// for types represented on 16 or 8 bits, the result is the same as
</span>    <span class="d_comment">// 32-bit types, but the most significant bits are ignored
</span>    <span class="d_keyword">short</span> f = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>) <span class="d_keyword">float</span>.max;
    <span class="d_keyword">assert</span>(f == 0);
}
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_struct" href="#cast_struct">Structs</a></h4>
<div class="blankline"></div>
    <p>Casting a value <i>v</i> to a struct <i>S</i>, when value is not a struct
        of the same type, is equivalent to:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">S(v)
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_qualifier" href="#cast_qualifier">Qualifier Cast</a></h4>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CastQual"><span class="gname">CastQual</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">cast (</span> <a href="../spec/type.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>A <i>CastQual</i> replaces the qualifiers in the type of
        the <i>UnaryExpression</i>:</p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">shared</span> <span class="d_keyword">int</span> x;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span>)x) == <span class="d_keyword">const</span> <span class="d_keyword">int</span>));
</pre>
        
</div>
<div class="blankline"></div>
    <p>Casting with no type or qualifiers removes
        any top level <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span>, <span class="d_inlinecode donthyphenate notranslate">shared</span> or <span class="d_inlinecode donthyphenate notranslate">inout</span>
        type modifiers from the type
        of the <i>UnaryExpression</i>.</p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">shared</span> <span class="d_keyword">int</span> x;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(<span class="d_keyword">cast</span>()x) == <span class="d_keyword">int</span>));
</pre>
        
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_void" href="#cast_void">Casting to <span class="d_inlinecode donthyphenate notranslate">void</span></a></h4>
<div class="blankline"></div>
    <p>Casting an expression to <span class="d_inlinecode donthyphenate notranslate">void</span> type is allowed to mark that
        the result is unused. On <a href="../spec/statement.html#ExpressionStatement"><i>ExpressionStatement</i></a>,
        it could be used properly to avoid a "has no effect" error.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">lazy</span> <span class="d_keyword">void</span> exp) {}
<span class="d_keyword">void</span> main()
{
    foo(10);            <span class="d_comment">// NG - expression '10' has no effect
</span>    foo(<span class="d_keyword">cast</span>(<span class="d_keyword">void</span>)10);  <span class="d_comment">// OK
</span>}
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="throw_expression" href="#throw_expression">Throw Expression</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ThrowExpression"><span class="gname">ThrowExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">throw</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
</pre>
<div class="blankline"></div>
<p>    <i>AssignExpression</i> is evaluated and must yield a reference to a <span class="d_inlinecode donthyphenate notranslate">Throwable</span>
    or a class derived from <span class="d_inlinecode donthyphenate notranslate">Throwable</span>. The reference is thrown as an exception,
    interrupting the current control flow to continue at a suitable <span class="d_inlinecode donthyphenate notranslate">catch</span> clause
    of a <a href="../spec/statement.html#try-statement"><i>try-statement</i></a>. This process will execute any applicable
    <a href="statement.html#ScopeGuardStatement"><span class="d_inlinecode donthyphenate notranslate">scope (exit)</span> / <span class="d_inlinecode donthyphenate notranslate">scope (failure)</span></a>
    passed since entering the corresponding <span class="d_inlinecode donthyphenate notranslate">try</span> block.
</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"message"</span>);
</pre>
<div class="blankline"></div>
<p>    The <span class="d_inlinecode donthyphenate notranslate">Throwable</span> must not be a qualified as <span class="d_inlinecode donthyphenate notranslate">immutable</span>, <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">inout</span> or
    <span class="d_inlinecode donthyphenate notranslate">shared</span>. The runtime may modify a thrown object (e.g. to contain a stack
    trace) which would violate <span class="d_inlinecode donthyphenate notranslate">const</span> or <span class="d_inlinecode donthyphenate notranslate">immutable</span> objects.
</p>
<p>    A <i>ThrowExpression</i> may be nested in another expression:
</p>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">function</span>() f) {}

<span class="d_keyword">void</span> main() {
    foo(() =&gt; <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception());
}
</pre>
<div class="blankline"></div>
    <p>The type of a <em>ThrowExpression</em> is <a href="../spec/type.html#noreturn"><span class="d_inlinecode donthyphenate notranslate">noreturn</span></a>.</p>
<div class="blankline"></div>
<div class="spec-boxes best-practice"><b>Best Practices:</b> Use <a href="../spec/expression.html#assert_expressions">Assert Expressions</a>
rather than <a href="../library/object#.Error">Error</a> to report program bugs
and abort the program.
</div>


<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="pow_expressions" href="#pow_expressions">Pow Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="PowExpression"><span class="gname">PowExpression</span></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a>
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">^^</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p><i>PowExpression</i> raises its left operand to the power of its
        right operand.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="postfix_expressions" href="#postfix_expressions">Postfix Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="PostfixExpression"><span class="gname">PostfixExpression</span></a>:
    <a href="#PrimaryExpression"><i>PrimaryExpression</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="#NewExpression"><i>NewExpression</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">++</span>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">--</span>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#NamedArgumentList"><i>NamedArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/type.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <a href="../spec/type.html#BasicType"><i>BasicType</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#NamedArgumentList"><i>NamedArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="#IndexExpression"><i>IndexExpression</i></a>
    <a href="#SliceExpression"><i>SliceExpression</i></a>
</pre>
<div class="blankline"></div>
<table>    <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Description</b></th></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">.</span></td><td>        Either:
<ul><li>Access a <a href="../spec/property.html">property</a> of a type or expression.</li>
<li>Access a member of a module, package, aggregate type or instance, enum
          or template instance.</li>
<li>Call a free function using <a href="../spec/function.html#pseudo-member">UFCS</a>.</li>
</ul>
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">++</span></td><td>Increment after use - see <a href="#order-of-evaluation">order of evaluation</a></td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">--</span></td><td>Decrement after use</td></tr>
    <tr><td><em>IndexExpression</em></td><td>Select a single element</td></tr>
    <tr><td><em>SliceExpression</em></td><td>Select a series of elements</td></tr>
</table>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="index_expressions" href="#index_expressions">Index Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="IndexExpression"><span class="gname">IndexExpression</span></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="d_inlinecode donthyphenate notranslate">]</span>
</pre>
<div class="blankline"></div>
    <p><i>PostfixExpression</i> is evaluated.
        If <i>PostfixExpression</i> is an expression of static or
        dynamic array type, the result of the indexing is an lvalue
        of the <em>i</em>th element in the array, where <span class="d_inlinecode donthyphenate notranslate">i</span> is an integer
        evaluated from <i>ArgumentList</i>.
        If <i>PostfixExpression</i> is a pointer <span class="d_inlinecode donthyphenate notranslate">p</span>, the result is
        <span class="d_inlinecode donthyphenate notranslate">*(p + i)</span> (see <a href="#pointer_arithmetic">Pointer Arithmetic</a>).
    </p>
<div class="blankline"></div>
    <p>If <i>PostfixExpression</i> is a <a href="../spec/template.html#variadic-templates"><i>ValueSeq</i></a>
        then the <i>ArgumentList</i> must consist of only one argument,
        and that must be statically evaluatable to an integral constant.
        That integral constant <i>n</i> then selects the <i>n</i>th
        expression in the <i>ValueSeq</i>, which is the result
        of the <i>IndexExpression</i>.
        It is an error if <i>n</i> is out of bounds of the <i>ValueSeq</i>.
    </p>
<div class="blankline"></div>
    <p>The special variable <span class="d_inlinecode donthyphenate notranslate">$</span> is declared and set to be the number
        of elements in the <i>PostfixExpression</i> (when available).
        A new declaration scope is created for the evaluation of the
        <i>ArgumentList</i> and <span class="d_inlinecode donthyphenate notranslate">$</span> appears in that scope only.
    </p>
<div class="blankline"></div>
    <p>The index operator can be <a href="../spec/operatoroverloading.html#array">overloaded</a>.
        Using multiple indices in <em>ArgumentList</em> is only supported for operator
        overloading.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="slice_expressions" href="#slice_expressions">Slice Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="SliceExpression"><span class="gname">SliceExpression</span></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">[ ]</span>
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#Slice"><i>Slice</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">]</span>
<div class="blankline"></div>
<a id="Slice"><span class="gname">Slice</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>Slice</i>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">..</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">..</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>Slice</i>
</pre>
<div class="blankline"></div>
    <p><i>PostfixExpression</i> is evaluated.
        If <i>PostfixExpression</i> is a static or dynamic
        array <span class="d_inlinecode donthyphenate notranslate">a</span>, the result of the slice is a dynamic array
        referencing elements <span class="d_inlinecode donthyphenate notranslate">a[i]</span> to <span class="d_inlinecode donthyphenate notranslate">a[j-1]</span> inclusive, where <span class="d_inlinecode donthyphenate notranslate">i</span>
        and <span class="d_inlinecode donthyphenate notranslate">j</span> are integers evaluated from the first and second <i>        AssignExpression</i> respectively.
    </p>
<div class="blankline"></div>
    <p>If <i>PostfixExpression</i> is a pointer <span class="d_inlinecode donthyphenate notranslate">p</span>, the result
        will be a dynamic array referencing elements from <span class="d_inlinecode donthyphenate notranslate">p[i]</span> to <span class="d_inlinecode donthyphenate notranslate">p[j-1]</span>
        inclusive, where <span class="d_inlinecode donthyphenate notranslate">i</span> and <span class="d_inlinecode donthyphenate notranslate">j</span> are integers evaluated from the
        first and second <i>AssignExpression</i> respectively.
    </p>
<div class="blankline"></div>
    <p>If <i>PostfixExpression</i> is a <a href="../spec/template.html#variadic-templates"><i>ValueSeq</i></a>, then
        the result of the slice is a new <i>ValueSeq</i> formed
        from the upper and lower bounds, which must statically evaluate
        to integral constants.
        It is an error if those bounds are out of range.
    </p>
<div class="blankline"></div>
    <p>The first <i>AssignExpression</i> is taken to be the inclusive
        lower bound
        of the slice, and the second <i>AssignExpression</i> is the
        exclusive upper bound.
        The result of the expression is a slice of the elements in <i>PostfixExpression</i>.
    </p>
<div class="blankline"></div>
    <p>The special variable <span class="d_inlinecode donthyphenate notranslate">$</span> is declared and set to be the number
        of elements in the <i>PostfixExpression</i> (when available).
        A new declaration scope is created for the evaluation of the
        <i>AssignExpression</i><span class="d_inlinecode donthyphenate notranslate">..</span><i>AssignExpression</i> and <span class="d_inlinecode donthyphenate notranslate">$</span> appears in
        that scope only.
    </p>
<div class="blankline"></div>
    <p>If the <span class="d_inlinecode donthyphenate notranslate">[ ]</span> form is used, the slice is of all the elements in <i>PostfixExpression</i>.
        The expression cannot be a pointer.
    </p>
<div class="blankline"></div>
    <p>The slice operator can be <a href="../spec/operatoroverloading.html#slice">overloaded</a>.
        Using more than one <em>Slice</em> is only supported for operator
        overloading.</p>
<div class="blankline"></div>
    <p>A <i>SliceExpression</i> is not a modifiable lvalue.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="slice_to_static_array" href="#slice_to_static_array">Slice Conversion to Static Array</a></h3>
<div class="blankline"></div>
    <p>If the slice bounds can be known at compile time, the slice expression
    may be implicitly convertible to a static array lvalue. For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">arr[a .. b]     <span class="d_comment">// typed T[]
</span></pre>
<div class="blankline"></div>
        <p>        If both <span class="d_inlinecode donthyphenate notranslate">a</span> and <span class="d_inlinecode donthyphenate notranslate">b</span> are integers (which may be constant-folded),
        the slice expression can be converted to a static array of type
        <span class="d_inlinecode donthyphenate notranslate">T[b - a]</span>.
        </p>
        <div class="spec-boxes note"><b>Note:</b> a static array can also be <a href="../spec/arrays.html#assignment">        assigned from a slice</a>, performing a runtime check that the lengths match.</div>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> f(<span class="d_keyword">int</span>[2] sa) {}

<span class="d_keyword">int</span>[] arr = [1, 2, 3];

<span class="d_keyword">void</span> test()
{
    <span class="d_comment">//f(arr); // error, can't convert
</span>    f(arr[1 .. 3]); <span class="d_comment">// OK
</span>    <span class="d_comment">//f(arr[0 .. 3]); // error
</span>
    <span class="d_keyword">int</span>[2] g() { <span class="d_keyword">return</span> arr[0 .. 2]; }
}
</pre>
        
</div>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> bar(<span class="d_keyword">ref</span> <span class="d_keyword">int</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == [2, 3]);
    a = [4, 5];
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[] arr = [1, 2, 3];

    <span class="d_comment">// slicing an lvalue gives an lvalue
</span>    bar(arr[1 .. 3]);
    <span class="d_keyword">assert</span>(arr == [1, 4, 5]);
}
</pre>
        
</div>
<div class="blankline"></div>
    
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="primary_expressions" href="#primary_expressions">Primary Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="PrimaryExpression"><span class="gname">PrimaryExpression</span></a>:
    <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <a href="#this"><span class="d_inlinecode donthyphenate notranslate">this</span></a>
    <a href="#super"><span class="d_inlinecode donthyphenate notranslate">super</span></a>
    <a href="#null"><span class="d_inlinecode donthyphenate notranslate">null</span></a>
    <span id="true_false"><a class="anchor" title="Permalink to this section" id="" href="#"></a></span><a href="../spec/type.html#bool"><span class="d_inlinecode donthyphenate notranslate">true</span></a>
    <a href="../spec/type.html#bool"><span class="d_inlinecode donthyphenate notranslate">false</span></a>
    <a href="#IndexExpression"><span class="d_inlinecode donthyphenate notranslate">$</span></a>
    <a href="../spec/lex.html#IntegerLiteral"><i>IntegerLiteral</i></a>
    <a href="../spec/lex.html#FloatLiteral"><i>FloatLiteral</i></a>
    <span id="CharacterLiteral"><a class="anchor" title="Permalink to this section" id="" href="#"></a></span><span id="character-literal"><a class="anchor" title="Permalink to this section" id="" href="#"></a></span><a href="../spec/lex.html#CharacterLiteral"><i>CharacterLiteral</i></a>
    <a href="#string_literals"><em>StringLiteral</em></a>
    <a href="#ArrayLiteral"><i>ArrayLiteral</i></a>
    <a href="#AssocArrayLiteral"><i>AssocArrayLiteral</i></a>
    <a href="#FunctionLiteral"><i>FunctionLiteral</i></a>
    <a href="#AssertExpression"><i>AssertExpression</i></a>
    <a href="#MixinExpression"><i>MixinExpression</i></a>
    <a href="#ImportExpression"><i>ImportExpression</i></a>
    <a href="#NewExpression"><i>NewExpression</i></a>
    <a href="../spec/type.html#FundamentalType"><i>FundamentalType</i></a> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">) .</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">) .</span> <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <a href="../spec/type.html#FundamentalType"><i>FundamentalType</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#NamedArgumentList"><i>NamedArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/type.html#TypeCtor"><i>TypeCtor</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <a href="../spec/type.html#TypeCtor"><i>TypeCtor</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#NamedArgumentList"><i>NamedArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/type.html#Typeof"><i>Typeof</i></a>
    <a href="#TypeidExpression"><i>TypeidExpression</i></a>
    <a href="#IsExpression"><i>IsExpression</i></a>
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#Expression"><i>Expression</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="#SpecialKeyword"><i>SpecialKeyword</i></a>
    <a href="../spec/traits.html#TraitsExpression"><i>TraitsExpression</i></a>
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="identifier" href="#identifier">.Identifier</a></h3>
<div class="blankline"></div>
    <p>See <a href="../spec/module.html#module_scope_operators">Module Scope
        Operator</a>.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="this" href="#this">this</a></h3>
<div class="blankline"></div>
    <p>Within a constructor or non-static member function, <span class="d_inlinecode donthyphenate notranslate">this</span> resolves to
        a reference to the object for which the function was called.
    </p>
    <p><a href="../spec/type.html#typeof-this"><span class="d_inlinecode donthyphenate notranslate">typeof(this)</span></a> is valid anywhere
        inside an aggregate type definition.
        If a class member function is called with an explicit reference
        to <span class="d_inlinecode donthyphenate notranslate">typeof(this)</span>, a non-virtual call is made:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'A'; }

    <span class="d_keyword">char</span> foo() { <span class="d_keyword">return</span> <span class="d_keyword">typeof</span>(<span class="d_keyword">this</span>).get(); } <span class="d_comment">// calls `A.get`
</span>    <span class="d_keyword">char</span> bar() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>.get(); } <span class="d_comment">// dynamic, same as just `get()`
</span>}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'B'; }
}

<span class="d_keyword">void</span> main()
{
    B b = <span class="d_keyword">new</span> B();

    <span class="d_keyword">assert</span>(b.foo() == 'A');
    <span class="d_keyword">assert</span>(b.bar() == 'B');
}
</pre>
        
</div>
<div class="blankline"></div>
    <p>Assignment to <span class="d_inlinecode donthyphenate notranslate">this</span> is not allowed for classes.</p>
    <p>See also:</p>
<ul><li><a href="../spec/class.html#delegating-constructors">Delegating Constructors</a></li>
<li><a href="../spec/template.html#template_this_parameter">template <span class="d_inlinecode donthyphenate notranslate">this</span> parameters</a>
</li>
</ul>
<h3><a class="anchor" title="Permalink to this section" id="super" href="#super">super</a></h3>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">super</span> is identical to <span class="d_inlinecode donthyphenate notranslate">this</span>, except that it is
        cast to <span class="d_inlinecode donthyphenate notranslate">this</span>'s base class.
        It is an error if there is no base class.
        (The only <span class="d_inlinecode donthyphenate notranslate">extern(D)</span> class without a base class is <span class="d_inlinecode donthyphenate notranslate">Object</span>,
        however, note that <span class="d_inlinecode donthyphenate notranslate">extern(C++)</span> classes have no base class unless specified.)
        If a member function is called with an explicit reference
        to <span class="d_inlinecode donthyphenate notranslate">super</span>, a non-virtual call is made.
    </p>
<div class="blankline"></div>
    <p>Assignment to <span class="d_inlinecode donthyphenate notranslate">super</span> is not allowed.</p>
    <p>See also: <a href="../spec/class.html#base-construction">Base Class Construction</a>.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="null" href="#null">null</a></h3>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">null</span> represents the null value for
        pointers, pointers to functions, delegates,
        dynamic arrays, associative arrays,
        and class objects.
        If it has not already been cast to a type,
        it is given the singular type <span class="d_inlinecode donthyphenate notranslate">typeof(null)</span> and it is an exact conversion
        to convert it to the null value for pointers, pointers to
        functions, delegates, etc.
        After it is cast to a type, such conversions are implicit,
        but no longer exact.
    </p>
<div class="blankline"></div>
<h3><span id="StringLiteral"><a class="anchor" title="Permalink to this section" id="string_literals" href="#string_literals">String Literals</a></span></h3>
<div class="blankline"></div>
    <p>See <a href="../spec/lex.html#StringLiteral"><i>StringLiteral</i></a> grammar.</p>
<div class="blankline"></div>
    <p>String literals are read-only.
        A string literal without a <a href="../spec/lex.html#string_postfix">StringPostfix</a>
        can implicitly convert to any
        of the following types, which have equal weight:
    </p>
<div class="blankline"></div>
    <table>        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(char)*</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(wchar)*</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(dchar)*</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(char)[]</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(wchar)[]</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(dchar)[]</span></td></tr>
    </table>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b> writing to a string literal. This is not allowed in <span class="d_inlinecode donthyphenate notranslate">@safe</span> code.</div>


<div class="blankline"></div>
    <p>By default, a string literal is typed as a dynamic array, but the element
        count is known at compile time. So all string literals can be
        implicitly converted to an immutable static array:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">char</span>[2] a)
{
    <span class="d_keyword">assert</span>(a[0] == 'b');
}
<span class="d_keyword">void</span> bar(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> <span class="d_keyword">char</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == <span class="d_string">"bc"</span>);
}

<span class="d_keyword">void</span> main()
{
    foo(<span class="d_string">"bc"</span>);
    foo(<span class="d_string">"b"</span>); <span class="d_comment">// OK
</span>    <span class="d_comment">//foo("bcd"); // error, too many chars
</span>    bar(<span class="d_string">"bc"</span>); <span class="d_comment">// OK, same length
</span>    <span class="d_comment">//bar("b"); // error, lengths must match
</span>}
</pre>
        
</div>
    <p>A string literal converts to a static array rvalue of the same or longer length.
        Any extra elements are padded with zeros. A string literal
        can also convert to a static array lvalue of the same length.</p>
<div class="blankline"></div>
    <p>String literals have a <span class="d_inlinecode donthyphenate notranslate">'\0'</span> appended to them, which makes
        them easy to pass to C or C++ functions expecting a null-terminated
        <span class="d_inlinecode donthyphenate notranslate">const char*</span> string.
        The <span class="d_inlinecode donthyphenate notranslate">'\0'</span> is not included in the <span class="d_inlinecode donthyphenate notranslate">.length</span> property of the
        string literal.
    </p>
<div class="blankline"></div>
    <p>Concatenation of string literals requires the use of
        <a href="#cat_expressions">the <span class="d_inlinecode donthyphenate notranslate">~</span> operator</a>, and is resolved at compile time.
        C style implicit concatenation without an intervening operator is
        error prone and not supported in D.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="array_literals" href="#array_literals">Array Literals</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ArrayLiteral"><span class="gname">ArrayLiteral</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">[</span> <i>ArrayMemberInitializations</i><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">]</span>
<div class="blankline"></div>
<a id="ArrayMemberInitializations"><span class="gname">ArrayMemberInitializations</span></a>:
    <i>ArrayMemberInitialization</i>
    <i>ArrayMemberInitialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span>
    <i>ArrayMemberInitialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>ArrayMemberInitializations</i>
<div class="blankline"></div>
<a id="ArrayMemberInitialization"><span class="gname">ArrayMemberInitialization</span></a>:
    <a href="../spec/declaration.html#NonVoidInitializer"><i>NonVoidInitializer</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="../spec/declaration.html#NonVoidInitializer"><i>NonVoidInitializer</i></a>
</pre>
<div class="blankline"></div>
    <p>An array literal is a comma-separated list of expressions
        between square brackets <span class="d_inlinecode donthyphenate notranslate">[</span> and <span class="d_inlinecode donthyphenate notranslate">]</span>.
        The expressions form the elements of a dynamic array.
        The length of the array is the number of elements.
        The common type of all the elements is taken to be the
        array element type, and each expression is implicitly converted
        to that type.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a1 = [1,2,3];  <span class="d_comment">// type is int[], with elements 1, 2 and 3
</span><span class="d_keyword">auto</span> a2 = [1u,2,3]; <span class="d_comment">// type is uint[], with elements 1u, 2u, and 3u
</span></pre>
<div class="blankline"></div>
    <p>By default, an array literal is typed as a dynamic array, but the element
        count is known at compile time. Therefore, an array literal can be
        implicitly converted to a static array of the same length.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[2] sa = [1, 2];
</pre>
<div class="blankline"></div>
    <div class="spec-boxes note"><b>Note:</b> Slicing a dynamic array with a statically known slice length also
        <a href="#slice_to_static_array">allows conversion</a> to a static array.</div>
<div class="blankline"></div>
    <p>If any <i>ArrayMemberInitialization</i> is a
        <a href="../spec/template.html#TemplateParameterSequence">ValueSeq</a>,
        then the elements of the <i>ValueSeq</i>
        are inserted as expressions in place of the sequence.
    </p>
<div class="blankline"></div>
    <p>Escaping array literals are allocated on the memory managed heap.
        Thus, they can be returned safely from functions:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] foo()
{
    <span class="d_keyword">return</span> [1, 2, 3];
}
</pre>
<div class="blankline"></div>
    <p>To initialize an element at a particular index, use the
        <em>AssignExpression</em> <span class="d_inlinecode donthyphenate notranslate">:</span> <em>NonVoidInitializer</em> syntax.
        The <em>AssignExpression</em> must be known at compile-time.
        Any missing elements will be initialized to the default value
        of the element type.
        Note that if the array type is not specified, the literal will
        be parsed as an
        <a href="#associative_array_literals">associative array</a>.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> n = 4;
<span class="d_keyword">auto</span> aa = [0:1, 3:n]; <span class="d_comment">// associative array `int[int]`
</span>
<span class="d_keyword">int</span>[] a = [1, 3:n, 5];
<span class="d_keyword">assert</span>(a == [1, 0, 0, n, 5]);

<span class="d_comment">//int[] e = [n:2]; // error, n not known at compile-time
</span></pre>
        
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="cast_array_literal" href="#cast_array_literal">Casting</a></h4>
<div class="blankline"></div>
    <p>When array literals are cast to another array type, each
        element of the array is cast to the new element type.
        When arrays that are not literals <a href="#cast_array">are cast</a>, the array is
        reinterpreted as the new type, and the length is recomputed:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    <span class="d_comment">// cast array literal
</span>    <span class="d_keyword">const</span> <span class="d_keyword">short</span>[] ct = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>[]) [<span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1, 1];
    <span class="d_comment">// this is equivalent with:
</span>    <span class="d_comment">// const short[] ct = [cast(short)1, cast(short)1];
</span>    writeln(ct);  <span class="d_comment">// writes [1, 1]
</span>
    <span class="d_comment">// cast other array expression
</span>    <span class="d_comment">// --&gt; normal behavior of CastExpression
</span>    <span class="d_keyword">byte</span>[] arr = [<span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1, <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1];
    <span class="d_keyword">short</span>[] rt = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>[]) arr;
    writeln(rt);  <span class="d_comment">// writes [257]
</span>}
</pre>
        
</div>
<div class="blankline"></div>
        In other words, casting an array literal will change the type of each initializer element.
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="associative_array_literals" href="#associative_array_literals">Associative Array Literals</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AssocArrayLiteral"><span class="gname">AssocArrayLiteral</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#KeyValuePairs"><i>KeyValuePairs</i></a> <span class="d_inlinecode donthyphenate notranslate">]</span>
<div class="blankline"></div>
<a id="KeyValuePairs"><span class="gname">KeyValuePairs</span></a>:
    <a href="#KeyValuePair"><i>KeyValuePair</i></a>
    <a href="#KeyValuePair"><i>KeyValuePair</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>KeyValuePairs</i>
<div class="blankline"></div>
<a id="KeyValuePair"><span class="gname">KeyValuePair</span></a>:
    <a href="#KeyExpression"><i>KeyExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#ValueExpression"><i>ValueExpression</i></a>
<div class="blankline"></div>
<a id="KeyExpression"><span class="gname">KeyExpression</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
<div class="blankline"></div>
<a id="ValueExpression"><span class="gname">ValueExpression</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>Associative array literals are a comma-separated list of
        <i>key</i><span class="d_inlinecode donthyphenate notranslate">:</span><i>value</i> pairs
        between square brackets <span class="d_inlinecode donthyphenate notranslate">[</span> and <span class="d_inlinecode donthyphenate notranslate">]</span>.
        The list cannot be empty.
        The common type of the all keys is taken to be the key type of
        the associative array, and all keys are implicitly converted
        to that type.
        The common type of the all values is taken to be the value type of
        the associative array, and all values are implicitly converted
        to that type.
        An <i>AssocArrayLiteral</i> cannot be used to statically initialize
        anything.</p>
<div class="blankline"></div>
<pre class="d_code notranslate">[21u: <span class="d_string">"he"</span>, 38: <span class="d_string">"ho"</span>, 2: <span class="d_string">"hi"</span>]; <span class="d_comment">// type is string[uint],
</span>                              <span class="d_comment">// with keys 21u, 38u and 2u
</span>                              <span class="d_comment">// and values "he", "ho", and "hi"
</span></pre>
<div class="blankline"></div>
    <p>If any of the keys or values in the <i>KeyValuePairs</i> are
        a <i>ValueSeq</i>, then the elements of the <i>ValueSeq</i>
        are inserted as arguments in place of the sequence.
    </p>
<div class="blankline"></div>
    <p>Associative array initializers may contain duplicate keys,
        however, in that case, the last <i>KeyValuePair</i> lexicographically
        encountered is stored.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> aa = [21: <span class="d_string">"he"</span>, 38: <span class="d_string">"ho"</span>, 2: <span class="d_string">"hi"</span>, 2:<span class="d_string">"bye"</span>];
<span class="d_keyword">assert</span>(aa[2] == <span class="d_string">"bye"</span>)
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function_literals" href="#function_literals">Function Literals</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FunctionLiteral"><span class="gname">FunctionLiteral</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">function</span> <a href="#RefOrAutoRef"><i>RefOrAutoRef</i></a><sub>opt</sub> <a href="../spec/type.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterWithAttributes"><i>ParameterWithAttributes</i></a><sub>opt</sub> <a href="#FunctionLiteralBody2"><i>FunctionLiteralBody2</i></a>
    <span class="d_inlinecode donthyphenate notranslate">delegate</span> <a href="#RefOrAutoRef"><i>RefOrAutoRef</i></a><sub>opt</sub> <a href="../spec/type.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a><sub>opt</sub> <a href="#FunctionLiteralBody2"><i>FunctionLiteralBody2</i></a>
    <a href="#RefOrAutoRef"><i>RefOrAutoRef</i></a><sub>opt</sub> <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a> <a href="#FunctionLiteralBody2"><i>FunctionLiteralBody2</i></a>
    <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
    <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">=&gt;</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
<div class="blankline"></div>
<a id="ParameterWithAttributes"><span class="gname">ParameterWithAttributes</span></a>:
    <a href="../spec/function.html#Parameters"><i>Parameters</i></a> <a href="../spec/function.html#FunctionAttributes"><i>FunctionAttributes</i></a><sub>opt</sub>
<div class="blankline"></div>
<a id="ParameterWithMemberAttributes"><span class="gname">ParameterWithMemberAttributes</span></a>:
    <a href="../spec/function.html#Parameters"><i>Parameters</i></a> <a href="../spec/function.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub>
<div class="blankline"></div>
<a id="FunctionLiteralBody2"><span class="gname">FunctionLiteralBody2</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">=&gt;</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="../spec/function.html#SpecifiedFunctionBody"><i>SpecifiedFunctionBody</i></a>
<div class="blankline"></div>
<a id="RefOrAutoRef"><span class="gname">RefOrAutoRef</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">ref</span>
    <span class="d_inlinecode donthyphenate notranslate">auto ref</span>
</pre>
<div class="blankline"></div>
    <p><i>FunctionLiteral</i>s enable embedding anonymous functions
        and anonymous delegates directly into expressions.
        Short function literals are known as <a class="anchor" title="Permalink to this section" id="lambdas" href="#lambdas"><i>lambdas</i></a>.
    </p>
<ul><li><i>Type</i> is the return type of the function or delegate -
        if omitted it is <a href="#lambda-return-type">inferred</a>.</li>
<li><i>ParameterWithAttributes</i> or <i>ParameterWithMemberAttributes</i>
        can be used to specify the parameters for the function. If these are
        omitted, the function defaults to the empty parameter list <span class="d_inlinecode donthyphenate notranslate">( )</span>.</li>
<li>Parameter types can be <a href="#lambda-parameter-inference">omitted</a>.</li>
<li>The type of a function literal is a
        <a href="../spec/function.html#closures">delegate or a pointer to function</a>.
</li>
</ul>
    <p>For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp; <span class="d_comment">// declare pointer to a function
</span>
<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6; }

    fp = &amp;foo;
}
</pre>
<div class="blankline"></div>
        is exactly equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp;

<span class="d_keyword">void</span> test()
{
    fp = <span class="d_keyword">function</span> <span class="d_keyword">int</span>(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6; };
}
</pre>
<div class="blankline"></div>
    <p>A delegate is necessary if the <i>FunctionLiteralBody2</i> accesses any non-static
        local variables in enclosing functions.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> b = 3;
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; }

    abc(&amp;foo);
}
</pre>
<div class="blankline"></div>
        is exactly equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> b = 3;

    abc( <span class="d_keyword">delegate</span> <span class="d_keyword">int</span>(<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; } );
}
</pre>
<div class="blankline"></div>
    <p>The use of <span class="d_inlinecode donthyphenate notranslate">ref</span> declares that the return value is returned by reference:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">auto</span> dg = <span class="d_keyword">delegate</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span>() { <span class="d_keyword">return</span> x; };
    x = 3;
    <span class="d_keyword">assert</span>(dg() == 3);
}
</pre>
        
</div>
<div class="blankline"></div>
    <div class="spec-boxes note"><b>Note:</b> When comparing function literals with <a href="../spec/function.html#nested">nested functions</a>,
        the <span class="d_inlinecode donthyphenate notranslate">function</span> form is analogous to static
        or non-nested functions, and the <span class="d_inlinecode donthyphenate notranslate">delegate</span> form is
        analogous to non-static nested functions. I.e.
        a delegate literal can access non-static local variables in an enclosing
        function, a function literal cannot.
    </div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="lambda-type-inference" href="#lambda-type-inference">Delegate Inference</a></h4>
<div class="blankline"></div>
    <p>If a literal omits <span class="d_inlinecode donthyphenate notranslate">function</span> or <span class="d_inlinecode donthyphenate notranslate">delegate</span> and there's no
        expected type from the context, then
        it is inferred to be a delegate if it accesses a
        variable in an enclosing function, otherwise it is a function pointer.
        </p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> b = 3;

    <span class="d_keyword">auto</span> fp = (<span class="d_keyword">uint</span> c) { <span class="d_keyword">return</span> c * 2; }; <span class="d_comment">// inferred as function pointer
</span>    <span class="d_keyword">auto</span> dg = (<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; }; <span class="d_comment">// inferred as delegate
</span>
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(fp) == <span class="d_keyword">delegate</span>));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(dg) == <span class="d_keyword">delegate</span>));
}
</pre>
        
</div>
    <p>If a delegate is expected, the literal will be inferred as a delegate
        even if it accesses no variables from an enclosing function:</p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i)) {}
<span class="d_keyword">void</span> def(<span class="d_keyword">uint</span> <span class="d_keyword">function</span>(<span class="d_keyword">uint</span> s)) {}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> b = 3;

    abc( (<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; } );  <span class="d_comment">// inferred as delegate
</span>    abc( (<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> c * 2; } );  <span class="d_comment">// inferred as delegate
</span>
    def( (<span class="d_keyword">uint</span> c) { <span class="d_keyword">return</span> c * 2; } ); <span class="d_comment">// inferred as function
</span>    <span class="d_comment">//def( (uint c) { return c * b; } );  // error!
</span>    <span class="d_comment">// Because the FunctionLiteral accesses b, its type
</span>    <span class="d_comment">// is inferred as delegate. But def cannot accept a delegate argument.
</span>}
</pre>
        
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="lambda-parameter-inference" href="#lambda-parameter-inference">Parameter Type Inference</a></h4>
<div class="blankline"></div>
    <p>If the type of a function literal can be uniquely determined from its context,
        parameter type inference is possible.</p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span>) fp);

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span>) fp = (n) { <span class="d_keyword">return</span> n * 2; };
    <span class="d_comment">// The type of parameter n is inferred as int.
</span>
    foo((n) { <span class="d_keyword">return</span> n * 2; });
    <span class="d_comment">// The type of parameter n is inferred as int.
</span>}
</pre>
        
</div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> fp = (i) { <span class="d_keyword">return</span> 1; }; <span class="d_comment">// error, cannot infer type of `i`
</span></pre>
<div class="blankline"></div>
<h5><a class="anchor" title="Permalink to this section" id="function-literal-alias" href="#function-literal-alias">Function Literal Aliasing</a></h5>
<div class="blankline"></div>
    <p>If a function literal is
        <a href="../spec/declaration.html#alias">aliased</a>, the inference
        of the parameter types is done when the types are needed, as
        the function literal becomes a
        <a href="../spec/template.html#function-templates">function template</a>.</p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> fpt = (i) { <span class="d_keyword">return</span> i; }; <span class="d_comment">// ok, infer type of `i` when used
</span><span class="d_comment">//auto fpt(T)(T i) { return i; } // equivalent
</span>
<span class="d_keyword">auto</span> v = fpt(4);    <span class="d_comment">// `i` is inferred as int
</span><span class="d_keyword">auto</span> d = fpt(10.3); <span class="d_comment">// `i` is inferred as double
</span>
<span class="d_keyword">alias</span> fp = fpt!<span class="d_keyword">float</span>;
<span class="d_keyword">auto</span> f = fp(0); <span class="d_comment">// f is a float
</span></pre>
        
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="lambda-return-type" href="#lambda-return-type">Return Type Inference</a></h4>
<div class="blankline"></div>
    <p>The return type of the <a href="#FunctionLiteral"><i>FunctionLiteral</i></a> can be
        inferred from either the <em>AssignExpression</em>, or
        any <a href="../spec/statement.html#ReturnStatement"><i>ReturnStatement</i></a>s in the <i>BlockStatement</i>.
        If there is a different expected type from the context, and the
        initial inferred return type implicitly converts to the expected type,
        then the return type is inferred as the expected type.</p>
<div class="blankline"></div>
    <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> fi = (<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> i; };
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(fi(5)) == <span class="d_keyword">int</span>));

<span class="d_keyword">long</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span>) fl = (<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> i; };
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(fl(5)) == <span class="d_keyword">long</span>));
</pre>
    
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="lambda-short-syntax" href="#lambda-short-syntax">Short Syntax</a></h4>
<div class="blankline"></div>
    <p>Anonymous delegates can behave like arbitrary statement literals.
        For example, here an arbitrary statement is executed by a loop:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> loop(<span class="d_keyword">int</span> n, <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() statement)
{
    <span class="d_keyword">foreach</span> (_; 0 .. n)
    {
        statement();
    }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> n = 0;

    loop(5, { n += 1; });
    <span class="d_keyword">assert</span>(n == 5);
}
</pre>
        
</div>
<div class="blankline"></div>
    <p>The syntax <span class="d_inlinecode donthyphenate notranslate">=&gt; AssignExpression</span> is equivalent to <span class="d_inlinecode donthyphenate notranslate">{ return AssignExpression; }</span>.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> i = 3;
    <span class="d_keyword">auto</span> twice = <span class="d_keyword">function</span> (<span class="d_keyword">int</span> x) =&gt; x * 2;
    <span class="d_keyword">assert</span>(twice(i) == 6);

    <span class="d_keyword">auto</span> square = <span class="d_keyword">delegate</span> () =&gt; i * i;
    <span class="d_keyword">assert</span>(square() == 9);

    <span class="d_keyword">auto</span> n = 5;
    <span class="d_keyword">auto</span> mul_n = (<span class="d_keyword">int</span> x) =&gt; x * n;
    <span class="d_keyword">assert</span>(mul_n(i) == 15);
}
</pre>
        
</div>
<div class="blankline"></div>
    <p>The syntax <span class="d_inlinecode donthyphenate notranslate">Identifier =&gt; AssignExpression</span> is equivalent to <span class="d_inlinecode donthyphenate notranslate">(Identifier) { return AssignExpression; }</span>.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_comment">// the following two declarations are equivalent
</span><span class="d_keyword">alias</span> fp = i =&gt; 1;
<span class="d_keyword">alias</span> fp = (i) { <span class="d_keyword">return</span> 1; };
</pre>
<div class="blankline"></div>
    <div class="spec-boxes best-practice"><b>Best Practices:</b> The minimal form of the function literal is most useful as
        an argument to a template alias parameter:
<pre class="d_code notranslate"><span class="d_keyword">int</span> motor(<span class="d_keyword">alias</span> fp)(<span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> fp(i) + 1;
}

<span class="d_keyword">int</span> engine()
{
    <span class="d_keyword">return</span> motor!(i =&gt; i * 2)(6); <span class="d_comment">// returns 13
</span>}
</pre>
        </div>


<div class="blankline"></div>
    <div class="spec-boxes note"><b>Note:</b> The syntax <span class="d_inlinecode donthyphenate notranslate">Identifier { statement; }</span> is not supported because it is
        easily confused with statements <span class="d_inlinecode donthyphenate notranslate">x = Identifier; { statement; };</span>
        if the semicolons were accidentally omitted.
        </div>
<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="uniform_construction_syntax" href="#uniform_construction_syntax">Uniform construction syntax for built-in scalar types</a></h3>
<div class="blankline"></div>
    <p>The implicit conversions of built-in scalar types can be explicitly
        represented by using function call syntax. For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = <span class="d_keyword">short</span>(1);  <span class="d_comment">// implicitly convert an integer literal '1' to short
</span><span class="d_keyword">auto</span> b = <span class="d_keyword">double</span>(a); <span class="d_comment">// implicitly convert a short variable 'a' to double
</span><span class="d_keyword">auto</span> c = <span class="d_keyword">byte</span>(128); <span class="d_comment">// error, 128 cannot be represented in a byte
</span></pre>
<div class="blankline"></div>
    <p>If the argument is omitted, it means default construction of the
        scalar type:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = <span class="d_keyword">ushort</span>();  <span class="d_comment">// same as: ushort.init
</span><span class="d_keyword">auto</span> b = <span class="d_keyword">wchar</span>();   <span class="d_comment">// same as: wchar.init
</span></pre>
<div class="blankline"></div>
    <p>See also: <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="assert_expressions" href="#assert_expressions">Assert Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AssertExpression"><span class="gname">AssertExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">assert (</span> <a href="#AssertArguments"><i>AssertArguments</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<a id="AssertArguments"><span class="gname">AssertArguments</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span><sub>opt</sub>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span><sub>opt</sub>
</pre>
<div class="blankline"></div>
    <p>The first <i>AssignExpression</i> must evaluate to <span class="d_inlinecode donthyphenate notranslate">true</span>. If it does not, an <i>Assert Failure</i>
    has occurred and the program enters an <i>Invalid State</i>.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> i = fun();
<span class="d_keyword">assert</span>(i &gt; 0);
</pre>
<div class="blankline"></div>
    <p><i>AssertExpression</i> has different semantics if it is in a
    <a href="../spec/unittest.html"><span class="d_inlinecode donthyphenate notranslate">unittest</span></a> or
    <a href="../spec/function.html#preconditions"><span class="d_inlinecode donthyphenate notranslate">in</span> contract</a>.
    </p>
<div class="blankline"></div>
    <p>If the first <i>AssignExpression</i> is a reference to a class instance for
    which a <a href="../spec/class.html#invariants">class <em>Invariant</em></a> exists, the class <i>Invariant</i> must hold.
    </p>
<div class="blankline"></div>
    <p>If the first <i>AssignExpression</i> is a pointer to a struct instance for
    which a <a href="../spec/struct.html#Invariant">struct <i>Invariant</i></a> exists, the struct <i>Invariant</i> must hold.
    </p>
<div class="blankline"></div>
    <p>The type of an <i>AssertExpression</i> is <span class="d_inlinecode donthyphenate notranslate">void</span>.
    </p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b> Once in an <i>Invalid State</i> the behavior of the continuing execution
    of the program is undefined.</div>


<div class="blankline"></div>
    <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b> Whether the first <i>AssertExpression</i> is evaluated
    or not (at runtime) is typically set with a compiler switch. If it is not evaluated,
    any side effects specified by the <i>AssertExpression</i> may not occur.
    The behavior when the first <i>AssertExpression</i> evaluates to <span class="d_inlinecode donthyphenate notranslate">false</span>
    is also typically set with a compiler switch, and may include these options:
    <ol>        <li>Immediately halting via execution of a special CPU instruction</li>
        <li>Aborting the program</li>
        <li>Calling the assert failure function in the corresponding C
        runtime library</li>
        <li>Throwing the <span class="d_inlinecode donthyphenate notranslate">AssertError</span> exception in the D runtime library</li>
    </ol>
    </div>


<div class="blankline"></div>
    <div class="spec-boxes note"><b>Note:</b> <span class="d_inlinecode donthyphenate notranslate">AssertError</span> is the default for <b>dmd</b>, with an optional
    <a href="../dmd.html#switch-checkaction"><b>-checkaction=context</b></a>
    switch to show certain sub-expressions used in the first <em>AssertExpression</em>
    in the error message:</div>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> x = 4;
<span class="d_keyword">assert</span>(x &lt; 3);
</pre>
    <p>When in use, the above will throw an <span class="d_inlinecode donthyphenate notranslate">AssertError</span> with a message <span class="d_inlinecode donthyphenate notranslate">4 &gt;= 3</span>.</p>
<div class="blankline"></div>
    <div class="spec-boxes best-practice"><b>Best Practices:</b>     <ol>        <li>Do not have side effects in either <i>AssignExpression</i> that subsequent code
        depends on.</li>
        <li><i>AssertExpression</i>s are intended to detect bugs in the program.
        Do not use them for detecting input or environmental errors.</li>
        <li>Do not attempt to resume normal execution after an <i>Assert Failure</i>.</li>
    </ol>
    </div>


<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="assert-ct" href="#assert-ct">Compile-time Evaluation</a></h4>
<div class="blankline"></div>
    <p>If the first <i>AssignExpression</i> consists entirely of compile time constants,
    and evaluates to <span class="d_inlinecode donthyphenate notranslate">false</span>, it is a special case - it
    signifies that subsequent statements are unreachable code.
    Compile Time Function Execution (CTFE) is not attempted.
    </p>
<div class="blankline"></div>
    <p>The implementation may handle the case of the first <i>AssignExpression</i> evaluating to <span class="d_inlinecode donthyphenate notranslate">false</span>
    at compile time differently - even when other <span class="d_inlinecode donthyphenate notranslate">assert</span>s are ignored,
    it may still generate a <span class="d_inlinecode donthyphenate notranslate">HLT</span> instruction or equivalent.
    </p>
<div class="blankline"></div>
    <p>See also: <a href="../spec/version.html#static-assert"><span class="d_inlinecode donthyphenate notranslate">static assert</span></a>.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="assert-message" href="#assert-message">Assert Message</a></h4>
<div class="blankline"></div>
    <p>The second <i>AssignExpression</i>, if present, must be implicitly
        convertible to type <span class="d_inlinecode donthyphenate notranslate">const(char)[]</span>.
        When present, the implementation may evaluate it and print the
        resulting message upon assert failure:
    </p>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">assert</span>(0, <span class="d_string">"an"</span> ~ <span class="d_string">" error message"</span>);
}
</pre>
<div class="blankline"></div>
    <p>When compiled and run, it will produce the message:</p>
<div class="blankline"></div>
    <pre class="console notranslate">core.exception.AssertError@test.d(3) an error message</pre>
<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="mixin_expressions" href="#mixin_expressions">Mixin Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="MixinExpression"><span class="gname">MixinExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">mixin (</span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
</pre>
<div class="blankline"></div>
    <p>Each <a href="#AssignExpression"><i>AssignExpression</i></a> in the <i>ArgumentList</i> is
        evaluated at compile time, and the result must be representable
        as a string.
        The resulting strings are concatenated to form a string.
        The text contents of the string must be compilable as a valid
        <a href="#Expression"><i>Expression</i></a>, and is compiled as such.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(<span class="d_string">"x +"</span>, 1) * 7;  <span class="d_comment">// same as ((x + 1) * 7)
</span>}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="import_expressions" href="#import_expressions">Import Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ImportExpression"><span class="gname">ImportExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">import (</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
</pre>
<div class="blankline"></div>
    <p>The <i>AssignExpression</i> must evaluate at compile time
        to a constant string.
        The text contents of the string are interpreted as a file
        name. The file is read, and the exact contents of the file
        become a string literal.
    </p>
<div class="blankline"></div>
    <p>Implementations may restrict the file name in order to avoid
        directory traversal security vulnerabilities.
        A possible restriction might be to disallow any path components
        in the file name.
    </p>
<div class="blankline"></div>
    <p>Note that by default an import expression will not compile unless
        one or more paths are passed via the <b>-J</b> switch. This tells the compiler
        where it should look for the files to import. This is a security feature.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_comment">// Prints contents of file foo.txt
</span>    writeln(<span class="d_keyword">import</span>(<span class="d_string">"foo.txt"</span>));
}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="new_expressions" href="#new_expressions">New Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="NewExpression"><span class="gname">NewExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">new</span> <a href="../spec/type.html#Type"><i>Type</i></a>
    <span class="d_inlinecode donthyphenate notranslate">new</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">]</span>
    <span class="d_inlinecode donthyphenate notranslate">new</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#NamedArgumentList"><i>NamedArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/class.html#NewAnonClassExpression"><i>NewAnonClassExpression</i></a>
<div class="blankline"></div>
<a id="ArgumentList"><span class="gname">ArgumentList</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>ArgumentList</i>
</pre>
<div class="blankline"></div>
<a id="NamedArgumentList"><span class="gname">NamedArgumentList</span></a>:
    <a href="#NamedArgument"><i>NamedArgument</i></a>
    <a href="#NamedArgument"><i>NamedArgument</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span>
    <a href="#NamedArgument"><i>NamedArgument</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>NamedArgumentList</i>
<div class="blankline"></div>
<a id="NamedArgument"><span class="gname">NamedArgument</span></a>:
    <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a>
<div class="blankline"></div>
    <p><i>NewExpression</i>s allocate memory on the
        <a href="../spec/garbage.html">garbage
        collected</a> heap by default.
    </p>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">new</span> <em>Type</em> form constructs an instance of a type and default-initializes it.</p>
    <p>The <em>Type(NamedArgumentList)</em> form allows passing either a single initializer
        of the same type, or multiple arguments for more complex types.
        For class types, <em>NamedArgumentList</em> is passed to the class constructor.
        For a dynamic array, the argument sets the initial array length.
        For multidimensional dynamic arrays, each argument corresponds to
        an initial length (see <a href="#new_multidimensional">below</a>).</p>
<div class="blankline"></div>
    <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>* i = <span class="d_keyword">new</span> <span class="d_keyword">int</span>;
<span class="d_keyword">assert</span>(*i == 0);
i = <span class="d_keyword">new</span> <span class="d_keyword">int</span>(5);
<span class="d_keyword">assert</span>(*i == 5);

Object o = <span class="d_keyword">new</span> Object;
Exception e = <span class="d_keyword">new</span> Exception(<span class="d_string">"info"</span>);

<span class="d_keyword">auto</span> a = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[](2);
<span class="d_keyword">assert</span>(a.length == 2);
</pre>
    
</div>
<div class="blankline"></div>
    <p>The <em>Type[AssignExpression]</em> form allocates a dynamic array with
        length equal to <em>AssignExpression</em>.
        It is preferred to use the <em>Type(NamedArgumentList)</em> form when allocating
        dynamic arrays instead, as it is more general.</p>
<div class="blankline"></div>
    <div class="spec-boxes note"><b>Note:</b> It is not possible to allocate a static array directly with
        <span class="d_inlinecode donthyphenate notranslate">new</span> (only by using a type alias).</div>
<div class="blankline"></div>
    <p>The result is a <a href="../const3.html#unique-expressions">unique expression</a>
    which can implicitly convert to other qualifiers:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">immutable</span> o = <span class="d_keyword">new</span> Object;
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="new_class" href="#new_class">Class Instantiation</a></h4>
<div class="blankline"></div>
    <p>If a <i>NewExpression</i> is used with a class type as an initializer for
        a function local variable with <a href="../spec/attribute.html#scope"><span class="d_inlinecode donthyphenate notranslate">scope</span></a> storage class,
        then the instance is <a href="../spec/attribute.html#scope-class-var">allocated on the stack</a>.
    </p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">new</span> can also be used to allocate a
        <a href="../spec/class.html#nested-explicit">nested class</a>.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="new_multidimensional" href="#new_multidimensional">Multidimensional Arrays</a></h4>
<div class="blankline"></div>
    <p>To allocate multidimensional arrays, the declaration reads
        in the same order as the prefix array declaration order.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">char</span>[][] foo;   <span class="d_comment">// dynamic array of strings
</span>...
foo = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[][30]; <span class="d_comment">// allocate array of 30 strings
</span></pre>
<div class="blankline"></div>
    <p>The above allocation can also be written as:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">foo = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[][](30); <span class="d_comment">// allocate array of 30 strings
</span></pre>
<div class="blankline"></div>
    <p>To allocate the nested arrays, multiple arguments can be used:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[][][] bar;
bar = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][][](5, 20, 30);

<span class="d_keyword">assert</span>(bar.length == 5);
<span class="d_keyword">assert</span>(bar[0].length == 20);
<span class="d_keyword">assert</span>(bar[0][0].length == 30);
</pre>
        
</div>
<div class="blankline"></div>
    The assignment above is equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate">bar = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][][5];
<span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> a; bar)
{
    a = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][20];
    <span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> b; a)
    {
        b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[30];
    }
}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="typeid_expressions" href="#typeid_expressions">Typeid Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="TypeidExpression"><span class="gname">TypeidExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">typeid (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">typeid (</span> <a href="#Expression"><i>Expression</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
</pre>
<div class="blankline"></div>
    <p>If <i>Type</i>, returns an instance of class
        <a href="../phobos/object.html"><span class="d_inlinecode donthyphenate notranslate">TypeInfo</span></a>
        corresponding
        to <i>Type</i>.
    </p>
<div class="blankline"></div>
    <p>If <i>Expression</i>, returns an instance of class
        <a href="../phobos/object.html"><span class="d_inlinecode donthyphenate notranslate">TypeInfo</span></a>
        corresponding
        to the type of the <i>Expression</i>.
        If the type is a class, it returns the <span class="d_inlinecode donthyphenate notranslate">TypeInfo</span>
        of the dynamic type (i.e. the most derived type).
        The <i>Expression</i> is always executed.</p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">import</span> std.stdio;

    writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>));        <span class="d_comment">// int
</span>    <span class="d_keyword">uint</span> i;
    writeln(<span class="d_keyword">typeid</span>(i++));        <span class="d_comment">// uint
</span>    writeln(i);                  <span class="d_comment">// 1
</span>    A a = <span class="d_keyword">new</span> B();
    writeln(<span class="d_keyword">typeid</span>(a));          <span class="d_comment">// B
</span>    writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(a)));  <span class="d_comment">// A
</span>}
</pre>
        
</div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="is_expression" href="#is_expression">Is Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="IsExpression"><span class="gname">IsExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/type.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<div class="blankline"></div>
<a id="TypeSpecialization"><span class="gname">TypeSpecialization</span></a>:
    <a href="../spec/type.html#Type"><i>Type</i></a>
    <span class="d_inlinecode donthyphenate notranslate">struct</span>
    <span class="d_inlinecode donthyphenate notranslate">union</span>
    <span class="d_inlinecode donthyphenate notranslate">class</span>
    <span class="d_inlinecode donthyphenate notranslate">interface</span>
    <span class="d_inlinecode donthyphenate notranslate">enum</span>
    <span class="d_inlinecode donthyphenate notranslate">__vector</span>
    <span class="d_inlinecode donthyphenate notranslate">function</span>
    <span class="d_inlinecode donthyphenate notranslate">delegate</span>
    <span class="d_inlinecode donthyphenate notranslate">super</span>
    <span class="d_inlinecode donthyphenate notranslate">const</span>
    <span class="d_inlinecode donthyphenate notranslate">immutable</span>
    <span class="d_inlinecode donthyphenate notranslate">inout</span>
    <span class="d_inlinecode donthyphenate notranslate">shared</span>
    <span class="d_inlinecode donthyphenate notranslate">return</span>
    <span class="d_inlinecode donthyphenate notranslate">__parameters</span>
    <span class="d_inlinecode donthyphenate notranslate">module</span>
    <span class="d_inlinecode donthyphenate notranslate">package</span>
</pre>
<div class="blankline"></div>
    <p>An <i>IsExpression</i> is evaluated at compile time and is
        used to check if an expression is a valid type. In addition,
        there are forms which can also:</p>
    <ul>    <li>compare types for equivalence</li>
    <li>determine if one type can be implicitly converted to another</li>
    <li>deduce the subtypes of a type using
        <a href="#is-parameter-list">pattern matching</a></li>
    <li>deduce the template arguments of a type template instance</li>
    </ul>
    <p>        The result of an <i>IsExpression</i> is a boolean which is <span class="d_inlinecode donthyphenate notranslate">true</span>
        if the condition is satisfied and <span class="d_inlinecode donthyphenate notranslate">false</span> if not.
    </p>
<div class="blankline"></div>
    <p><i>Type</i> is the type being tested. It must be syntactically
        correct, but it need not be semantically correct.
        If it is not semantically correct, the condition is not satisfied.
    </p>
<div class="blankline"></div>
    <p><i>TypeSpecialization</i> is the type that <i>Type</i> is being
        pattern matched against.
    </p>
<div class="blankline"></div>
    <p><i>IsExpression</i>s may be used in conjunction with
    <a href="../spec/type.html#typeof"><span class="d_inlinecode donthyphenate notranslate">typeof</span></a> to check
    whether an expression type checks correctly. For example, <span class="d_inlinecode donthyphenate notranslate">is(typeof(foo))</span>
    will return <span class="d_inlinecode donthyphenate notranslate">true</span> if <span class="d_inlinecode donthyphenate notranslate">foo</span> has a valid type.
    </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="basic-forms" href="#basic-forms">Basic Forms</a></h4>
<div class="blankline"></div>
        <h5><a class="anchor" title="Permalink to this section" id="is-type" href="#is-type"><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">)</span></a></h5>
<div class="blankline"></div>
        <p>        The condition is satisfied if <i>Type</i> is semantically
        correct. <em>Type</em> must be syntactically correct regardless.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">pragma</span>(msg, <span class="d_keyword">is</span>(5)); <span class="d_comment">// error
</span><span class="d_keyword">pragma</span>(msg, <span class="d_keyword">is</span>([][])); <span class="d_comment">// error
</span></pre>

</div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">int</span> i;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(i))); <span class="d_comment">// same
</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(Undefined));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(<span class="d_keyword">int</span>))); <span class="d_comment">// int is not an expression
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(i)); <span class="d_comment">// i is a value
</span>
<span class="d_keyword">alias</span> Func = <span class="d_keyword">int</span>(<span class="d_keyword">int</span>); <span class="d_comment">// function type
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Func));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(Func[])); <span class="d_comment">// fails as an array of functions is not allowed
</span></pre>

</div>
        <h5><a class="anchor" title="Permalink to this section" id="is-type-convert" href="#is-type-convert"><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span></a></h5>
<div class="blankline"></div>
        <p>        The condition is satisfied if <i>Type</i> is semantically
        correct and it is the same as
        or can be implicitly converted to <i>TypeSpecialization</i>.
        <i>TypeSpecialization</i> is only allowed to be a <i>Type</i>.
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">short</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Bar : <span class="d_keyword">int</span>)); <span class="d_comment">// short implicitly converts to int
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(Bar : string));
</pre>

</div>
        <h5><a class="anchor" title="Permalink to this section" id="is-type-equal" href="#is-type-equal"><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span></a></h5>
<div class="blankline"></div>
        <p>        If <em>TypeSpecialization</em> is a type,
        the condition is satisfied if <i>Type</i> is semantically correct and is
        the same type as <i>TypeSpecialization</i>.
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">short</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Bar == <span class="d_keyword">short</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(Bar == <span class="d_keyword">int</span>));
</pre>

</div>
        <p>        If <i>TypeSpecialization</i> is one of
                <span class="d_inlinecode donthyphenate notranslate">struct</span>
                <span class="d_inlinecode donthyphenate notranslate">union</span>
                <span class="d_inlinecode donthyphenate notranslate">class</span>
                <span class="d_inlinecode donthyphenate notranslate">interface</span>
                <span class="d_inlinecode donthyphenate notranslate">enum</span>
                <span class="d_inlinecode donthyphenate notranslate">__vector</span>
                <span class="d_inlinecode donthyphenate notranslate">function</span>
                <span class="d_inlinecode donthyphenate notranslate">delegate</span>
                <span class="d_inlinecode donthyphenate notranslate">module</span>
                <span class="d_inlinecode donthyphenate notranslate">package</span>
        then the condition is satisfied if <i>Type</i> is one of those.
        </p>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Object == <span class="d_keyword">class</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(ModuleInfo == <span class="d_keyword">struct</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">int</span> == <span class="d_keyword">class</span>));
</pre>

</div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">module</span> and <span class="d_inlinecode donthyphenate notranslate">package</span> forms are satisfied when <em>Type</em> is a symbol, not a <em>type</em>,
        unlike the other forms. The <a href="../spec/traits.html#isModule">isModule</a>
        and <a href="../spec/traits.html#isPackage">isPackage</a> <span class="d_inlinecode donthyphenate notranslate">__traits</span> should be used instead.
        <a href="../spec/module.html#package-module">Package modules</a> are considered to be both
        packages and modules.
        </p>
        <p>        <em>TypeSpecialization</em> can also be one of these keywords:
        </p>
        <table>        <tr><th class="donthyphenate"><b>keyword</b></th><th class="donthyphenate"><b>condition</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">super</span></td><td><span class="d_inlinecode donthyphenate notranslate">true</span> if <em>Type</em> is a class or interface</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">return</span></td><td>            <span class="d_inlinecode donthyphenate notranslate">true</span> if <em>Type</em> is a function, delegate or function pointer</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">__parameters</span></td><td>            <span class="d_inlinecode donthyphenate notranslate">true</span> if <em>Type</em> is a function, delegate or function pointer</td></tr>
        </table>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(C == <span class="d_keyword">super</span>));

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> i);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(foo == <span class="d_keyword">return</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(foo) == <span class="d_keyword">return</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(foo) == <span class="d_keyword">__parameters</span>));
</pre>
        
</div>
        <p>        If <em>TypeSpecialization</em> is a <a href="../spec/type.html#TypeCtor"><i>TypeCtor</i></a> keyword
                <span class="d_inlinecode donthyphenate notranslate">const</span>
                <span class="d_inlinecode donthyphenate notranslate">immutable</span>
                <span class="d_inlinecode donthyphenate notranslate">inout</span>
                <span class="d_inlinecode donthyphenate notranslate">shared</span>
        then the condition is satisfied if <em>Type</em> is of that <em>TypeCtor</em>:
        </p>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">const</span> <span class="d_keyword">int</span> == <span class="d_keyword">const</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[] == <span class="d_keyword">const</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] == <span class="d_keyword">const</span>)); <span class="d_comment">// head is mutable
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span> == <span class="d_keyword">const</span>));
</pre>

</div>
        <p><b>See also:</b> <a href="../spec/traits.html">Traits</a>.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="is-identifier" href="#is-identifier">Identifier Forms</a></h4>
<div class="blankline"></div>
    <p><em>Identifier</em> is declared to be an alias of the resulting
        type if the condition is satisfied. The <em>Identifier</em> forms
        can only be used if the <i>IsExpression</i> appears in a
        <a href="../spec/version.html#StaticIfCondition"><i>StaticIfCondition</i></a> or the first argument of a
        <a href="../spec/version.html#StaticAssert"><i>StaticAssert</i></a>.
    </p>
<div class="blankline"></div>
        <h5><a class="anchor" title="Permalink to this section" id="is-type-identifier" href="#is-type-identifier"><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">)</span></a></h5>
<div class="blankline"></div>
        <p>        The condition is satisfied if <i>Type</i> is semantically
        correct. If so, <i>Identifier</i>
        is declared to be an alias of <i>Type</i>.
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> i, j;
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(S.i) T) &amp;&amp; T.sizeof == 4);
</pre>

</div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">short</span>;

<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar T))
        <span class="d_keyword">alias</span> S = T;
    <span class="d_keyword">else</span>
        <span class="d_keyword">alias</span> S = <span class="d_keyword">long</span>;

    <span class="d_keyword">pragma</span>(msg, S); <span class="d_comment">// short
</span>
    <span class="d_comment">// if T was defined, it remains in scope
</span>    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(T))
        <span class="d_keyword">pragma</span>(msg, T); <span class="d_comment">// short
</span>
    <span class="d_comment">//if (is(Bar U)) {} // error, cannot declare U here
</span>}
</pre>

</div>
<div class="blankline"></div>
        <h5><a class="anchor" title="Permalink to this section" id="is-identifier-convert" href="#is-identifier-convert"><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span>
        </a>
<div class="blankline"></div>
        <p>        If <em>TypeSpecialization</em> is a type,
        the condition is satisfied if <i>Type</i> is semantically
        correct and it is the same as
        or can be implicitly converted to <i>TypeSpecialization</i>.
        <i>Identifier</i> is declared to be an alias of the
        <i>TypeSpecialization</i>.
        </p>
<div class="blankline"></div>
    <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">int</span>;

<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar T : <span class="d_keyword">int</span>))
    <span class="d_keyword">alias</span> S = T;
<span class="d_keyword">else</span>
    <span class="d_keyword">alias</span> S = <span class="d_keyword">long</span>;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S == <span class="d_keyword">int</span>));
</pre>
    
</div>
        <p>        If <i>TypeSpecialization</i> is a type pattern involving
        <i>Identifier</i>, type deduction of <i>Identifier</i> is attempted
        based on either <em>Type</em> or a type that it implicitly converts to.
        The condition is only satisfied if the type pattern is matched.
        </p>
<div class="blankline"></div>
    <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">long</span>* i;
    <span class="d_keyword">alias</span> i <span class="d_keyword">this</span>; <span class="d_comment">// S converts to long*
</span>}

<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(S U : U*)) <span class="d_comment">// S is matched against the pattern U*
</span>{
    U u;
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(U == <span class="d_keyword">long</span>));
</pre>
    
</div>
<div class="blankline"></div>
        <p>        The way the type of <i>Identifier</i> is determined is analogous
        to the way template parameter types are determined by
        <a href="../spec/template.html#TemplateTypeParameterSpecialization"><i>TemplateTypeParameterSpecialization</i></a>.
        </p>
<div class="blankline"></div>
        <h5><a class="anchor" title="Permalink to this section" id="is-identifier-equal" href="#is-identifier-equal"><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span></a></h5>
<div class="blankline"></div>
        <p>        If <em>TypeSpecialization</em> is a type,
        the condition is satisfied if <i>Type</i> is semantically correct and is
        the same type as <i>TypeSpecialization</i>.
        <i>Identifier</i> is declared to be an alias of the
        <i>TypeSpecialization</i>.
        </p>
    <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">const</span> x = 5;

<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(x) T == <span class="d_keyword">const</span> <span class="d_keyword">int</span>))   <span class="d_comment">// satisfied, T is now defined
</span>    <span class="d_keyword">alias</span> S = T;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(T)); <span class="d_comment">// T is in scope
</span><span class="d_keyword">pragma</span>(msg, T); <span class="d_comment">// const int
</span></pre>
    
</div>
<div class="blankline"></div>
        <p>        If <i>TypeSpecialization</i> is a type pattern involving
        <i>Identifier</i>, type deduction of <i>Identifier</i> is attempted
        based on <em>Type</em>.
        The condition is only satisfied if the type pattern is matched.
        </p>
    <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Foo = <span class="d_keyword">long</span>*;

<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Foo U == U*)) <span class="d_comment">// Foo is matched against the pattern U*
</span>{
    U u;
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(U == <span class="d_keyword">long</span>));
</pre>
    
</div>
        <p>        If <em>TypeSpecialization</em> is a valid keyword for the
        <a href="#is-type-equal"><span class="d_inlinecode donthyphenate notranslate">is(Type == Keyword)</span> form</a>,
        the condition is satisfied in the same manner.
        <i>Identifier</i> is set as follows:
        </p>
<div class="blankline"></div>
        <center><table><caption></caption>        <tr><th class="donthyphenate"><b>keyword</b></th><th class="donthyphenate"><b>alias type for <i>Identifier</i></b></th></tr>
<div class="blankline"></div>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">struct</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">union</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">class</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">interface</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">super</span></td><td><i>TypeSeq</i> of base classes and interfaces</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">enum</span></td><td>the base type of the enum</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">__vector</span></td><td>the static array type of the vector</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">function</span></td><td><i>TypeSeq</i> of the function parameter types.
             For C- and D-style variadic functions,
             only the non-variadic parameters are included.
             For typesafe variadic functions, the <span class="d_inlinecode donthyphenate notranslate">...</span> is ignored.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">delegate</span></td><td>the function type of the delegate</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">return</span></td><td>the return type of the function, delegate, or function pointer</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">__parameters</span></td><td>the parameter sequence of a function, delegate, or function pointer.
         This includes the parameter types, names, and default values.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">const</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">inout</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">shared</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">module</span></td><td>the module</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">package</span></td><td>the package</td></tr>
        </table></center>
<div class="blankline"></div>
    <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">enum</span> E : <span class="d_keyword">byte</span> { Emember }

<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(E V == <span class="d_keyword">enum</span>))    <span class="d_comment">// satisfied, E is an enum
</span>    V v;                       <span class="d_comment">// v is declared to be a byte
</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(V == <span class="d_keyword">byte</span>));
</pre>
    
</div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="is-parameter-list" href="#is-parameter-list">Parameter List Forms</a></h4>
<div class="blankline"></div>
<pre class="bnf notranslate"><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
</pre>
<div class="blankline"></div>
        <p>        More complex types can be pattern matched. The
        <i>TemplateParameterList</i> declares symbols based on the
        parts of the pattern that are matched, analogously to the
        way <a href="../spec/template.html#parameters_specialization">        implied template parameters</a> are matched.
        </p>
<div class="blankline"></div>
<p><b>Example:</b> Matching a Template Instantiation</p></h5>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> Tuple(T...)
{
    <span class="d_comment">// ...
</span>}
<span class="d_keyword">alias</span> Tup2 = Tuple!(<span class="d_keyword">int</span>, string);

<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Tup2 : Template!Args, <span class="d_keyword">alias</span> Template, Args...))
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, Template, Tuple));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Template!(<span class="d_keyword">int</span>, string) == Tup2)); <span class="d_comment">// same struct
</span>}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Args[0] == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Args[1] == string));
</pre>

</div>
<div class="blankline"></div>
        <p><em>Type</em> cannot be matched when <em>TypeSpecialization</em> is an
        <a href="../spec/template.html#alias-template">alias template</a> instance:
        </p>
<div class="blankline"></div>
        <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S(T) {}
<span class="d_keyword">alias</span> A(T) = S!T;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(A!<span class="d_keyword">int</span> : S!T, T));
<span class="d_comment">//static assert(!is(A!int : A!T, T));
</span></pre>
        
</div>
<div class="blankline"></div>
<p><b>Example:</b> Matching an Associative Array</p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> AA = <span class="d_keyword">long</span>[string];

<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(AA T : T[U], U : string)) <span class="d_comment">// T[U] is the pattern
</span>{
    <span class="d_keyword">pragma</span>(msg, T);  <span class="d_comment">// long
</span>    <span class="d_keyword">pragma</span>(msg, U);  <span class="d_comment">// string
</span>}

<span class="d_comment">// no match, B is not an int
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(AA A : A[B], B : <span class="d_keyword">int</span>));
</pre>

</div>
<div class="blankline"></div>
<p><b>Example:</b> Matching a Static Array</p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">int</span>[10] W : W[len], <span class="d_keyword">int</span> len)) <span class="d_comment">// W[len] is the pattern
</span>{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(len == 10);
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(W == <span class="d_keyword">int</span>));

<span class="d_comment">// no match, len should be 10
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">int</span>[10] X : X[len], <span class="d_keyword">int</span> len : 5));
</pre>

</div>
<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="specialkeywords" href="#specialkeywords">Special Keywords</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="SpecialKeyword"><span class="gname">SpecialKeyword</span></a>:
    <a href="#specialkeywords"><span class="d_inlinecode donthyphenate notranslate">__FILE__</span></a>
    <a href="#specialkeywords"><span class="d_inlinecode donthyphenate notranslate">__FILE_FULL_PATH__</span></a>
    <a href="#specialkeywords"><span class="d_inlinecode donthyphenate notranslate">__MODULE__</span></a>
    <a href="#specialkeywords"><span class="d_inlinecode donthyphenate notranslate">__LINE__</span></a>
    <a href="#specialkeywords"><span class="d_inlinecode donthyphenate notranslate">__FUNCTION__</span></a>
    <a href="#specialkeywords"><span class="d_inlinecode donthyphenate notranslate">__PRETTY_FUNCTION__</span></a>
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__FILE__</span> and <span class="d_inlinecode donthyphenate notranslate">__LINE__</span> expand to the source
    file name and line number at the point of instantiation. The path of
    the source file is left up to the compiler. </p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__FILE_FULL_PATH__</span> expands to the absolute source
    file name at the point of instantiation.</p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__MODULE__</span> expands to the module name at the point of
    instantiation.</p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__FUNCTION__</span> expands to the fully qualified name of the
    function at the point of instantiation.</p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__PRETTY_FUNCTION__</span> is similar to <span class="d_inlinecode donthyphenate notranslate">__FUNCTION__</span>,
    but also expands the function return type, its parameter types,
    and its attributes.</p>
<div class="blankline"></div>
    <p>Example:</p>
<div class="blankline"></div>
    <div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">module</span> test;
<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> test(string file = <span class="d_keyword">__FILE__</span>, size_t line = <span class="d_keyword">__LINE__</span>,
        string mod = <span class="d_keyword">__MODULE__</span>, string func = <span class="d_keyword">__FUNCTION__</span>,
        string pretty = <span class="d_keyword">__PRETTY_FUNCTION__</span>,
        string fileFullPath = <span class="d_keyword">__FILE_FULL_PATH__</span>)
{
    writefln(<span class="d_string">"file: '%s', line: '%s', module: '%s',\nfunction: '%s', "</span> ~
        <span class="d_string">"pretty function: '%s',\nfile full path: '%s'"</span>,
        file, line, mod, func, pretty, fileFullPath);
}

<span class="d_keyword">int</span> main(string[] args)
{
    test();
    <span class="d_keyword">return</span> 0;
}
</pre>
    
</div>
<div class="blankline"></div>
    <p>Assuming the file was at /example/test.d, this will output:</p>
<div class="blankline"></div>
<pre class="console notranslate">file: 'test.d', line: '13', module: 'test',
function: 'test.main', pretty function: 'int test.main(string[] args)',
file full path: '/example/test.d'
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="associativity" href="#associativity">Associativity and Commutativity</a></h2>
<div class="blankline"></div>
    <p>An implementation may rearrange the evaluation of expressions
        according to arithmetic associativity and commutativity rules
        as long as, within that thread of execution, no observable
        difference is possible.
    </p>
<div class="blankline"></div>
    <p>This rule precludes any associative or commutative reordering of
        floating point expressions.
    </p>

<div style="float: left"><i class="fa fa-angle-left" aria-hidden="true"></i> <a href="../spec/pragma.html">Pragmas</a></div>
<div style="float: right"><a href="../spec/statement.html">Statements</a> <i class="fa fa-angle-right" aria-hidden="true"></i></div>
<div style="clear:both"></div>



        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(addVersionSelector);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

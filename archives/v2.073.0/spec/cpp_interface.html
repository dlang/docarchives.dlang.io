
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Interfacing to C++ - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Interfacing to C++' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.freenode.net/d'>IRC</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.php'>Issues</a></li>
    <li class="menu-divider"><a href='../foundation.html'>Foundation</a></li>
    <li><a href='../donate.html'>Donate</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option selected value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    
    <div class="head">        <h2>Language Reference</h2>
        <p class="subnav-duplicate">            <a href="../spec/spec.html">table of contents</a></p>
    </div>
    <ul>        <li><a href='            ../spec/intro.html'>Introduction</a></li><li><a href='            ../spec/lex.html'>Lexical</a></li><li><a href='            ../spec/grammar.html'>Grammar</a></li><li><a href='            ../spec/module.html'>Modules</a></li><li><a href='            ../spec/declaration.html'>Declarations</a></li><li><a href='            ../spec/type.html'>Types</a></li><li><a href='            ../spec/property.html'>Properties</a></li><li><a href='            ../spec/attribute.html'>Attributes</a></li><li><a href='            ../spec/pragma.html'>Pragmas</a></li><li><a href='            ../spec/expression.html'>Expressions</a></li><li><a href='            ../spec/statement.html'>Statements</a></li><li><a href='            ../spec/arrays.html'>Arrays</a></li><li><a href='            ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='            ../spec/struct.html'>Structs and Unions</a></li><li><a href='            ../spec/class.html'>Classes</a></li><li><a href='            ../spec/interface.html'>Interfaces</a></li><li><a href='            ../spec/enum.html'>Enums</a></li><li><a href='            ../spec/const3.html'>Type Qualifiers</a></li><li><a href='            ../spec/function.html'>Functions</a></li><li><a href='            ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='            ../spec/template.html'>Templates</a></li><li><a href='            ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='            ../spec/contracts.html'>Contract Programming</a></li><li><a href='            ../spec/version.html'>Conditional Compilation</a></li><li><a href='            ../spec/traits.html'>Traits</a></li><li><a href='            ../spec/errors.html'>Error Handling</a></li><li><a href='            ../spec/unittest.html'>Unit Tests</a></li><li><a href='            ../spec/garbage.html'>Garbage Collection</a></li><li><a href='            ../spec/float.html'>Floating Point</a></li><li><a href='            ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='            ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='            ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='            ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='            ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='            ../spec/portability.html'>Portability Guide</a></li><li><a href='            ../spec/entity.html'>Named Character Entities</a></li><li><a href='            ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='            ../spec/abi.html'>Application Binary Interface</a></li><li><a href='            ../spec/simd.html'>Vector Extensions
        </a></li>
    </ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;bug_severity=enhancement&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BInterfacing to C++%5D&amp;version=D2">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/spec/cpp_interface.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Interfacing to C++</h1>
        
        


    <p>This document specifies how to interface with C++ directly.</p>

    <p>It is also possible to indirectly interface with C++ code, either
    through a <a href="../spec/interfaceToC.html">C interface</a> or a
    COM interface.</p>

<h2>The General Idea</h2>

    <p>Being 100% compatible with C++ means more or less adding
    a fully functional C++ compiler front end to D.
    Anecdotal evidence suggests that writing such is a minimum
    of a 10 man-year project, essentially making a D compiler
    with such capability unimplementable.
    Other languages looking to hook up to C++ face the same
    problem, and the solutions have been:
    </p>

    <ol>    <li>Support the COM interface (but that only works for Windows).</li>
    <li>Laboriously construct a C wrapper around
    the C++ code.</li>
    <li>Use an automated tool such as SWIG to construct a
    C wrapper.</li>
    <li>Reimplement the C++ code in the other language.</li>
    <li>Give up.</li>
    </ol>

    <p>D takes a pragmatic approach that assumes a couple
    modest accommodations can solve a significant chunk of
    the problem:
    </p>

    <ul>    <li>matching C++ name mangling conventions</li>
    <li>matching C++ function calling conventions</li>
    <li>matching C++ virtual function table layout for single inheritance</li>
    </ul>

<h2><a class="anchor" title="Permalink to this section" id="global-functions" href="#global-functions">Global Functions</a></h2>

    <p>C++ global functions, including those in namespaces, can be declared
    and called in D, or defined in D and called in C++.</p>

<h3>Calling C++ Global Functions from D</h3>

    <p>Given a C++ function in a C++ source file:</p>

<pre class="cppcode notranslate">#include &lt;iostream&gt;

using namespace std;

int foo(int i, int j, int k)
{
    cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
    cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; endl;
    cout &lt;&lt; "k = " &lt;&lt; k &lt;&lt; endl;

    return 7;
}
</pre>

    <p>In the corresponding D code, <span class="d_inlinecode donthyphenate notranslate">foo</span>
    is declared as having C++ linkage and function calling conventions:
    </p>

<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C++) <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i, <span class="d_keyword">int</span> j, <span class="d_keyword">int</span> k);
</pre>

    <p>and then it can be called within the D code:</p>

<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C++) <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i, <span class="d_keyword">int</span> j, <span class="d_keyword">int</span> k);

<span class="d_keyword">void</span> main()
{
    foo(1, 2, 3);
}
</pre>

    <p>Compiling the two files, the first with a C++ compiler,
    the second with a D compiler, linking them together,
    and then running it yields:</p>

<pre class="console notranslate">i = 1
j = 2
k = 3
</pre>

    <p>There are several things going on here:</p>

    <ul>    <li>D understands how C++ function names are "mangled" and the
    correct C++ function call/return sequence.</li>

    <li>Because modules are not part of C++, each function with C++ linkage
    in the global namespace must be globally unique within the program.</li>

    <li>There are no <span class="d_inlinecode donthyphenate notranslate">__cdecl</span>, <span class="d_inlinecode donthyphenate notranslate">__far</span>, <span class="d_inlinecode donthyphenate notranslate">__stdcall</span>, <span class="d_inlinecode donthyphenate notranslate">__declspec</span>, or other
    such nonstandard C++ extensions in D.</li>

    <li>There are no volatile type modifiers in D.</li>

    <li>Strings are not 0 terminated in D. See "Data Type Compatibility"
    for more information about this. However, string literals in D are
    0 terminated.</li>

    </ul>

<h3>Calling Global D Functions From C++</h3>

    <p>To make a D function accessible from C++, give it
    C++ linkage:</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">extern</span> (C++) <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i, <span class="d_keyword">int</span> j, <span class="d_keyword">int</span> k)
{
    writefln(<span class="d_string">"i = %s"</span>, i);
    writefln(<span class="d_string">"j = %s"</span>, j);
    writefln(<span class="d_string">"k = %s"</span>, k);
    <span class="d_keyword">return</span> 1;
}

<span class="d_keyword">extern</span> (C++) <span class="d_keyword">void</span> bar();

<span class="d_keyword">void</span> main()
{
    bar();
}
</pre>

    <p>The C++ end looks like:</p>

<pre class="cppcode notranslate">int foo(int i, int j, int k);

void bar()
{
    foo(6, 7, 8);
}
</pre>

    <p>Compiling, linking, and running produces the output:</p>

<pre class="console notranslate">i = 6
j = 7
k = 8
</pre>

<h2><a class="anchor" title="Permalink to this section" id="cpp-namespaces" href="#cpp-namespaces">C++ Namespaces</a></h2>

        <p>C++ symbols that reside in namespaces can be
        accessed from D. A <a href="attribute.html#namespace">namespace</a>
        can be added to the <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span>
        <a href="attribute.html#linkage">LinkageAttribute</a>:
    </p>
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C++, N) <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i, <span class="d_keyword">int</span> j, <span class="d_keyword">int</span> k);

<span class="d_keyword">void</span> main()
{
    N.foo(1, 2, 3);   <span class="d_comment">// foo is in C++ namespace 'N'
</span>}
</pre>

<h2><a class="anchor" title="Permalink to this section" id="classes" href="#classes">Classes</a></h2>

    <p>C++ classes can be declared in D by using the <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span>
    attribute on <span class="d_inlinecode donthyphenate notranslate">class</span>, <span class="d_inlinecode donthyphenate notranslate">struct</span> and <span class="d_inlinecode donthyphenate notranslate">interface</span>
    declarations. <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> interfaces have the same restrictions as
    D interfaces, which means that Multiple Inheritance is supported to the
    extent that only one base class can have member fields.</p>

    <p><span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> structs do not support virtual functions but can
    be used to map C++ value types.</p>

    <p>Unlike classes and interfaces with D linkage, <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span>
    classes and interfaces are not rooted in <span class="d_inlinecode donthyphenate notranslate">Object</span> and cannot be used
    with <span class="d_inlinecode donthyphenate notranslate">typeid</span>.</p>
    
    <p>D structs and classes have different semantics whereas C++ structs and 
    classes are basically the same. The use of a D struct or class depends on
    the C++ implementation and not on the used C++ keyword.
    When mapping a D <span class="d_inlinecode donthyphenate notranslate">class</span> onto a C++ <span class="d_inlinecode donthyphenate notranslate">struct</span>,
    use <span class="d_inlinecode donthyphenate notranslate">extern(C++, struct)</span> to avoid linking problems with C++ compilers
    (notably MSVC) that distinguish between C++'s <span class="d_inlinecode donthyphenate notranslate">class</span> and <span class="d_inlinecode donthyphenate notranslate">struct</span>
    when mangling. Conversely, use <span class="d_inlinecode donthyphenate notranslate">extern(C++, class)</span> to map a D
    <span class="d_inlinecode donthyphenate notranslate">struct</span> onto a C++ <span class="d_inlinecode donthyphenate notranslate">class</span>.</p>

    <p><span class="d_inlinecode donthyphenate notranslate">extern(C++, class)</span> and <span class="d_inlinecode donthyphenate notranslate">extern(C++, struct)</span> can be combined
    with C++ namespaces:</p>
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C++, <span class="d_keyword">struct</span>) <span class="d_keyword">extern</span> (C++, foo)
<span class="d_keyword">class</span> Bar
{
}
</pre>

<h3>Using C++ Classes From D</h3>

    <p>The following example shows binding of a pure virtual function, its
    implementation in a derived class, a non-virtual member function, and a
    member field:</p>

<pre class="cppcode notranslate">#include &lt;iostream&gt;

using namespace std;

class Base
{
    public:
        virtual void print3i(int a, int b, int c) = 0;
};

class Derived : public Base
{
    public:
        int field;
        Derived(int field) : field(field) {}

        void print3i(int a, int b, int c)
        {
            cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
            cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
            cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl;
        }

        int mul(int factor);
};

int Derived::mul(int factor)
{
    return field * factor;
}

Derived *createInstance(int i)
{
    return new Derived(i);
}

void deleteInstance(Derived *&d)
{
    delete d;
    d = 0;
}
</pre>

    <p>We can use it in D code like:</p>

<pre class="d_code notranslate"><span class="d_keyword">extern</span>(C++)
{
    <span class="d_keyword">interface</span> Base
    {
        <span class="d_keyword">void</span> print3i(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b, <span class="d_keyword">int</span> c);
    }

    <span class="d_keyword">class</span> Derived : Base
    {
        <span class="d_keyword">int</span> field;
        @disable <span class="d_keyword">this</span>();
        <span class="d_keyword">override</span> <span class="d_keyword">void</span> print3i(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b, <span class="d_keyword">int</span> c);
        <span class="d_keyword">final</span> <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> factor);
    }

    Derived createInstance(<span class="d_keyword">int</span> i);
    <span class="d_keyword">void</span> deleteInstance(<span class="d_keyword">ref</span> Derived d);
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">import</span> std.stdio;

    <span class="d_keyword">auto</span> d1 = createInstance(5);
    writeln(d1.field);
    writeln(d1.mul(4));

    Base b1 = d1;
    b1.print3i(1, 2, 3);

    deleteInstance(d1);
    <span class="d_keyword">assert</span>(d1 <span class="d_keyword">is</span> <span class="d_keyword">null</span>);

    <span class="d_keyword">auto</span> d2 = createInstance(42);
    writeln(d2.field);

    deleteInstance(d2);
    <span class="d_keyword">assert</span>(d2 <span class="d_keyword">is</span> <span class="d_keyword">null</span>);
}
</pre>

<p>Compiling, linking, and running produces the output:</p>

<pre class="console notranslate">5
20
a = 1
b = 2
c = 3
42
</pre>

<p>Note how in the above example, the constructor is not bindable and is
instead disabled on the D side; an alternative would be to reimplement the
constructor in D. See the <a href="../spec/cpp_interface.html#lifetime-management">section below on lifetime management</a> for more information.</p>

<h3>Using D Classes From C++</h3>

    <p>Given D code like:</p>

<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C++) <span class="d_keyword">int</span> callE(E);

<span class="d_keyword">extern</span> (C++) <span class="d_keyword">interface</span> E
{
    <span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> i, <span class="d_keyword">int</span> j, <span class="d_keyword">int</span> k);
}

<span class="d_keyword">class</span> F : E
{
    <span class="d_keyword">extern</span> (C++) <span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> i, <span class="d_keyword">int</span> j, <span class="d_keyword">int</span> k)
    {
        writefln(<span class="d_string">"i = %s"</span>, i);
        writefln(<span class="d_string">"j = %s"</span>, j);
        writefln(<span class="d_string">"k = %s"</span>, k);
        <span class="d_keyword">return</span> 8;
    }
}

<span class="d_keyword">void</span> main()
{
    F f = <span class="d_keyword">new</span> F();
    callE(f);
}
</pre>

    <p>The C++ code to access it looks like:</p>

<pre class="cppcode notranslate">class E
{
  public:
    virtual int bar(int i, int j, int k);
};


int callE(E *e)
{
    return e-&gt;bar(11, 12, 13);
}
</pre>

<h2><a class="anchor" title="Permalink to this section" id="cpp-templates" href="#cpp-templates">C++ Templates</a></h2>

    <p>C++ function and type templates can be bound by using the
    <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> attribute on a function or type template declaration.</p>

    <p>Note that all instantiations used in D code must be provided by linking
    to C++ object code or shared libraries containing the instantiations.</p>

    <p>For example:</p>

<pre class="cppcode notranslate">#include &lt;iostream&gt;

template&lt;class T&gt;
struct Foo
{
    private:
    T field;

    public:
    Foo(T t) : field(t) {}
    T get();
    void set(T t);
};

template&lt;class T&gt;
T Foo&lt;T&gt;::get()
{
    return field;
}

template&lt;class T&gt;
void Foo&lt;T&gt;::set(T t)
{
    field = t;
}

Foo&lt;int&gt; makeIntFoo(int i)
{
    return Foo&lt;int&gt;(i);
}

Foo&lt;char&gt; makeCharFoo(char c)
{
    return Foo&lt;char&gt;(c);
}

template&lt;class T&gt;
void increment(Foo&lt;T&gt; &foo)
{
    foo.set(foo.get() + 1);
}

template&lt;class T&gt;
void printThreeNext(Foo&lt;T&gt; foo)
{
    for(size_t i = 0; i &lt; 3; ++i)
    {
        std::cout &lt;&lt; foo.get() &lt;&lt; std::endl;
        increment(foo);
    }
}

// The following two functions ensure that the required instantiations of
// printThreeNext are provided by this code module
void printThreeNexti(Foo&lt;int&gt; foo)
{
    printThreeNext(foo);
}

void printThreeNextc(Foo&lt;char&gt; foo)
{
    printThreeNext(foo);
}
</pre>

<pre class="d_code notranslate"><span class="d_keyword">extern</span>(C++):
<span class="d_keyword">struct</span> Foo(T)
{
    <span class="d_keyword">private</span>:
    T field;

    <span class="d_keyword">public</span>:
    @disable <span class="d_keyword">this</span>();
    T get();
    <span class="d_keyword">void</span> set(T t);
}

Foo!<span class="d_keyword">int</span> makeIntFoo(<span class="d_keyword">int</span> i);
Foo!<span class="d_keyword">char</span> makeCharFoo(<span class="d_keyword">char</span> c);
<span class="d_keyword">void</span> increment(T)(<span class="d_keyword">ref</span> Foo!T foo);
<span class="d_keyword">void</span> printThreeNext(T)(Foo!T foo);

<span class="d_keyword">extern</span>(D) <span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> i = makeIntFoo(42);
    <span class="d_keyword">assert</span>(i.get() == 42);
    i.set(1);
    increment(i);
    <span class="d_keyword">assert</span>(i.get() == 2);

    <span class="d_keyword">auto</span> c = makeCharFoo('a');
    increment(c);
    <span class="d_keyword">assert</span>(c.get() == 'b');

    c.set('A');
    printThreeNext(c);
}
</pre>

<p>Compiling, linking, and running produces the output:</p>

<pre class="console notranslate">A
B
C
</pre>

<h2><a class="anchor" title="Permalink to this section" id="function-overloading" href="#function-overloading">Function Overloading</a></h2>

    <p>C++ and D follow different rules for function overloading.
    D source code, even when calling <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> functions,
    will still follow D overloading rules.
    </p>

<h2><a class="anchor" title="Permalink to this section" id="memory-allocation" href="#memory-allocation">Memory Allocation</a></h2>

    <p>C++ code explicitly manages memory with calls to
    <span class="d_inlinecode donthyphenate notranslate">::operator new()</span> and <span class="d_inlinecode donthyphenate notranslate">::operator delete()</span>.
    D's <span class="d_inlinecode donthyphenate notranslate">new</span> operator allocates memory using the D garbage collector,
    so no explicit delete is necessary. D's <span class="d_inlinecode donthyphenate notranslate">new</span> operator is not
    compatible with C++'s <span class="d_inlinecode donthyphenate notranslate">::operator new</span> and <span class="d_inlinecode donthyphenate notranslate">::operator delete</span>.
    Attempting to allocate memory with D's <span class="d_inlinecode donthyphenate notranslate">new</span> and deallocate with
    C++ <span class="d_inlinecode donthyphenate notranslate">::operator delete</span> will result in miserable failure.
    </p>

    <p>D can explicitly manage memory using a variety of library tools, such as
    with <a href="../phobos/std_experimental_allocator.html"><span class="d_inlinecode donthyphenate notranslate">std.experimental.allocator</span></a>. Additionally,
    <span class="d_inlinecode donthyphenate notranslate">core.stdc.stdlib.malloc</span> and <span class="d_inlinecode donthyphenate notranslate">core.stdc.stdlib.free</span> can be
    used directly for connecting to C++ functions that expect <span class="d_inlinecode donthyphenate notranslate">malloc</span>'d
    buffers.
    </p>

    <p>If pointers to memory allocated on the D garbage collector heap are
    passed to C++ functions, it's critical to ensure that the referenced memory
    will not be collected by the D garbage collector before the C++ function is
    done with it. This is accomplished by:
    </p>

    <ul>
    <li>Making a copy of the data using
    <a href="../phobos/std_experimental_allocator.html"><span class="d_inlinecode donthyphenate notranslate">std.experimental.allocator</span></a> or <span class="d_inlinecode donthyphenate notranslate">core.stdc.stdlib.malloc</span>
    and passing the copy instead.</li>

    <li>Leaving a pointer to it on the stack (as a parameter or
    automatic variable), as the garbage collector will scan the stack.</li>

    <li>Leaving a pointer to it in the static data segment, as the
    garbage collector will scan the static data segment.</li>

    <li>Registering the pointer with the garbage collector using the
    <span class="d_inlinecode donthyphenate notranslate">core.memory.GC.addRoot</span> or <span class="d_inlinecode donthyphenate notranslate">core.memory.GC.addRange</span>
    functions.</li>

    </ul>

    <p>An interior pointer to the allocated memory block is sufficient to let
    the GC know the object is in use; i.e. it is not necessary to maintain
    a pointer to the <i>beginning</i> of the allocated memory.
    </p>

    <p>The garbage collector does not scan the stacks of threads not
    registered with the D runtime, nor does it scan the data segments of
    shared libraries that aren't registered with the D runtime.
    </p>

<h2><a class="anchor" title="Permalink to this section" id="data-type-compatibility" href="#data-type-compatibility">Data Type Compatibility</a></h2>

    <center><table><caption>D And C++ Type Equivalence</caption>
    <tr><th class="donthyphenate"><b>D type</b></th><th class="donthyphenate"><b>C++ type</b></th></tr>

    <tr><td>    <b>void</b></td><td>    <b>void</b>
    </td></tr>

    <tr><td>    <b>byte</b></td><td>    <b>signed char</b>
    </td></tr>

    <tr><td>    <b>ubyte</b></td><td>    <b>unsigned char</b>
    </td></tr>

    <tr><td>    <b>char</b></td><td>    <b>char</b> (chars are unsigned in D)
    </td></tr>

    <tr><td>    <span class="d_inlinecode donthyphenate notranslate">core.stdc.stddef.wchar_t</span></td><td>    <span class="d_inlinecode donthyphenate notranslate">wchar_t</span>
    </td></tr>

    <tr><td>    <b>short</b></td><td>    <b>short</b>
    </td></tr>

    <tr><td>    <b>ushort</b></td><td>    <b>unsigned short</b>
    </td></tr>

    <tr><td>    <b>int</b></td><td>    <b>int</b>
    </td></tr>

    <tr><td>    <b>uint</b></td><td>    <b>unsigned</b>
    </td></tr>

    <tr><td>    <b>long</b></td><td>    <b>long long</b>
    </td></tr>

    <tr><td>    <b>ulong</b></td><td>    <b>unsigned long long</b>
    </td></tr>

    <tr><td>    <span class="d_inlinecode donthyphenate notranslate">core.stdc.config.cpp_long</span></td><td>    <b>long</b>
    </td></tr>

    <tr><td>    <span class="d_inlinecode donthyphenate notranslate">core.stdc.config.cpp_ulong</span></td><td>    <b>unsigned long</b>
    </td></tr>

    <tr><td>    <b>float</b></td><td>    <b>float</b>
    </td></tr>

    <tr><td>    <b>double</b></td><td>    <b>double</b>
    </td></tr>

    <tr><td>    <b>real</b></td><td>    <b>long double</b>
    </td></tr>

    <tr><td>    <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> <b>struct</b></td><td>    <b>struct</b> or <b>class</b>
    </td></tr>

    <tr><td>    <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> <b>class</b></td><td>    <b>struct</b> or <b>class</b>
    </td></tr>

    <tr><td>    <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> <b>interface</b></td><td>    <b>struct</b> or <b>class</b> with no member fields
    </td></tr>

    <tr><td>    <b>union</b></td><td>    <b>union</b>
    </td></tr>

    <tr><td>    <b>enum</b></td><td>    <b>enum</b>
    </td></tr>

    <tr><td>    <i>type</i><b>*</b></td><td>    <i>type</i> <b>*</b>
    </td></tr>

    <tr><td>    <b>ref</b> <i>type</i> (in parameter lists only)</td><td>    <i>type</i> <span class="d_inlinecode donthyphenate notranslate">&amp;</span>
    </td></tr>

    <tr><td>    <i>type</i><b>[</b><i>dim</i><b>]</b></td><td>    <i>type</i><b>[</b><i>dim</i><b>]</b>
    </td></tr>

    <tr><td>    <i>type</i><b>[</b><i>dim</i><b>]*</b></td><td>    <i>type</i><b>(*)[</b><i>dim</i><b>]</b>
    </td></tr>

    <tr><td>    <i>type</i><b>[]</b></td><td>    no equivalent
    </td></tr>

    <tr><td>    <i>type</i><b>[</b><i>type</i><b>]</b></td><td>    no equivalent
    </td></tr>

    <tr><td>    <i>type</i> <b>function</b><b>(</b><i>parameters</i><b>)</b></td><td>    <i>type</i><b>(*)</b><b>(</b><i>parameters</i><b>)</b>
    </td></tr>

    <tr><td>    <i>type</i> <b>delegate</b><b>(</b><i>parameters</i><b>)</b></td><td>    no equivalent
    </td></tr>
    </table></center>

    <p>These equivalents hold when the D and C++ compilers used are companions
    on the host platform.</p>

<h2><a class="anchor" title="Permalink to this section" id="packing-and-alignment" href="#packing-and-alignment">Packing and Alignment</a></h2>

    <p>D structs and unions are analogous to C's.
    </p>

    <p>C code often adjusts the alignment and packing of struct members
    with a command line switch or with various implementation specific
    #pragma's. D supports explicit alignment attributes that correspond
    to the C compiler's rules. Check what alignment the C code is using,
    and explicitly set it for the D struct declaration.
    </p>

    <p>D supports bitfields in the standard library: see
    <span class="phobos"><a class="https" href="https://dlang.org/phobos/std_bitmanip.html#bitfields">std.bitmanip.bitfields</a></span>.
    </p>

<h2><a class="anchor" title="Permalink to this section" id="lifetime-management" href="#lifetime-management">Lifetime Management</a></h2>

    <p>C++ constructors, copy constructors, move constructors and destructors
    cannot be called directly in D code, and D constructors, postblit operators
    and destructors cannot be directly exported to C++ code. Interoperation of
    types with these special operators is possible by either 1)
    disabling the operator in the client language and only using it in the host
    language, or 2) faithfully reimplementing the operator in the
    client language. With the latter approach, care needs to be taken to ensure
    observable semantics remain the same with both implementations, which can be
    difficult, or in some edge cases impossible, due to differences in how the
    operators work in the two languages. For example, in D all objects are
    movable and there is no move constructor.</p>

<h2><a class="anchor" title="Permalink to this section" id="special-member-functions" href="#special-member-functions">Special Member Functions</a></h2>

    <p>D cannot directly call C++ special member functions, and vice versa.
    These include constructors, destructors, conversion operators,
    operator overloading, and allocators.
    </p>

<h2><a class="anchor" title="Permalink to this section" id="rtti" href="#rtti">Runtime Type Identification</a></h2>

    <p>D runtime type identification
    uses completely different techniques than C++.
    The two are incompatible.</p>

<h2><a class="anchor" title="Permalink to this section" id="exception-handling" href="#exception-handling">Exception Handling</a></h2>

    <p>Exception interoperability is a work in progress.</p>

    <p>At present, C++ exceptions cannot be caught in or thrown from D, and D
    exceptions cannot be caught in or thrown from C++. Additionally, objects
    in C++ stack frames are not guaranteed to be destroyed when unwinding the
    stack due to a D exception, and vice versa.</p>

    <p>The plan is to support all of the above except throwing D exceptions
    directly in C++ code (but they will be throwable indirectly by calling into
    a D function with C++ linkage).</p>

<h2>Comparing D Immutable and Const with C++ Const</h2>
<center><table><caption>Const, Immutable Comparison</caption>   <tr><th class="donthyphenate"><b>Feature</b></th><th class="donthyphenate"><b>D</b></th><th class="donthyphenate"><b>C++98</b></th></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">const</span> keyword</td><td>Yes</td><td>Yes</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable</span> keyword</td><td>Yes</td><td>No</td></tr>
    <tr><td>const notation</td><td><pre class="d_code notranslate"><span class="d_comment">// Functional:
</span><span class="d_comment">//ptr to const ptr to const int
</span><span class="d_keyword">const</span>(<span class="d_keyword">int</span>*)* p;
</pre>
</td><td><pre class="cppcode notranslate">// Postfix:
//ptr to const ptr to const int
const int *const *p;
</pre>
    </td></tr>

    <tr><td>transitive const</td><td><pre class="d_code notranslate"><span class="d_comment">// Yes:
</span><span class="d_comment">//const ptr to const ptr to const int
</span><span class="d_keyword">const</span> <span class="d_keyword">int</span>** p;
**p = 3; <span class="d_comment">// error
</span></pre>
</td><td><pre class="cppcode notranslate">// No:
// const ptr to ptr to int
int** const p;
**p = 3;    // ok
</pre>
    </td></tr>

    <tr><td>cast away const</td><td><pre class="d_code notranslate"><span class="d_comment">// Yes:
</span><span class="d_comment">// ptr to const int
</span><span class="d_keyword">const</span>(<span class="d_keyword">int</span>)* p;
<span class="d_keyword">int</span>* q = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)p; <span class="d_comment">// ok
</span></pre>
</td><td><pre class="cppcode notranslate">// Yes:
// ptr to const int
const int* p;
int* q = const_cast&lt;int*&gt;p; //ok
</pre>
    </td></tr>

    <tr><td>cast+mutate</td><td><pre class="d_code notranslate"><span class="d_comment">// No:
</span><span class="d_comment">// ptr to const int
</span><span class="d_keyword">const</span>(<span class="d_keyword">int</span>)* p;
<span class="d_keyword">int</span>* q = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)p;
*q = 3;   <span class="d_comment">// undefined behavior
</span></pre>
</td><td><pre class="cppcode notranslate">// Yes:
// ptr to const int
const int* p;
int* q = const_cast&lt;int*&gt;p;
*q = 3;   // ok
</pre>
    </td></tr>

    <tr><td>overloading</td><td><pre class="d_code notranslate"><span class="d_comment">// Yes:
</span><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x);
<span class="d_keyword">void</span> foo(<span class="d_keyword">const</span> <span class="d_keyword">int</span> x);  <span class="d_comment">//ok
</span></pre>
</td><td><pre class="cppcode notranslate">// No:
void foo(int x);
void foo(const int x);  //error
</pre>
    </td></tr>

    <tr><td>const/mutable aliasing</td><td><pre class="d_code notranslate"><span class="d_comment">// Yes:
</span><span class="d_keyword">void</span> foo(<span class="d_keyword">const</span> <span class="d_keyword">int</span>* x, <span class="d_keyword">int</span>* y)
{
    bar(*x); <span class="d_comment">// bar(3)
</span>    *y = 4;
    bar(*x); <span class="d_comment">// bar(4)
</span>}
...
<span class="d_keyword">int</span> i = 3;
foo(&amp;i, &amp;i);
</pre>
</td><td><pre class="cppcode notranslate">// Yes:
void foo(const int* x, int* y)
{
    bar(*x); // bar(3)
    *y = 4;
    bar(*x); // bar(4)
}
...
int i = 3;
foo(&i, &i);
</pre>
    </td></tr>

    <tr><td>immutable/mutable aliasing</td><td><pre class="d_code notranslate"><span class="d_comment">// No:
</span><span class="d_keyword">void</span> foo(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>* x, <span class="d_keyword">int</span>* y)
{
    bar(*x); <span class="d_comment">// bar(3)
</span>    *y = 4;  <span class="d_comment">// undefined behavior
</span>    bar(*x); <span class="d_comment">// bar(??)
</span>}
...
<span class="d_keyword">int</span> i = 3;
foo(<span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span>)&amp;i, &amp;i);
</pre>
</td><td>    No immutables
    </td></tr>

    <tr><td>type of string literal</td><td>    <span class="d_inlinecode donthyphenate notranslate">immutable(char)[]</span></td><td>    <span class="d_inlinecode donthyphenate notranslate">const char*</span>
    </td></tr>


    <tr><td>string literal to non-const</td><td>    not allowed</td><td>    allowed, but deprecated
    </td></tr>
</table></center>





        <div class="smallprint" id="copyright">Copyright &copy; 1999-2017 by the <a href="../foundation.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

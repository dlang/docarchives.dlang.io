
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2022 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>The C Preprocessor vs D - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='The C Preprocessor vs D' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.freenode.net/d'>IRC</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    
    <div class="head">        <h2>Articles</h2>
        <p class="Articles, ../articles/index.html, overview">            <a href="../articles/index.html">overview</a></p>
    </div>
    <ul><li><a href='        ../articles/faq.html'>FAQ</a></li><li><a href='        ../articles/const-faq.html'>const(FAQ)</a></li><li><a href='        ../articles/d-floating-point.html'>Floating Point</a></li><li><a href='        ../articles/warnings.html'>Warnings</a></li><li><a href='        ../articles/rationale.html'>Rationale</a></li><li><a href='        ../articles/builtin.html'>Builtin Rationale</a></li><li><a href='        ../articles/ctod.html'>C to D</a></li><li><a href='        ../articles/cpptod.html'>C++ to D</a></li><li><a href='        ../articles/pretod.html'>C Preprocessor vs D</a></li><li><a href='        ../articles/code_coverage.html'>Code coverage analysis</a></li><li><a href='        ../articles/exception-safe.html'>Exception Safety</a></li><li><a href='        ../articles/hijack.html'>Hijacking</a></li><li><a href='        ../articles/intro-to-datetime.html'>Introduction to std.datetime</a></li><li><a href='        ../articles/lazy-evaluation.html'>Lazy Evaluation</a></li><li><a href='        ../articles/migrate-to-shared.html'>Migrating to Shared</a></li><li><a href='        ../articles/mixin.html'>Mixins</a></li><li><a href='        ../articles/regular-expression.html'>Regular Expressions</a></li><li><a href='        ../articles/safed.html'>SafeD</a></li><li><a href='        ../articles/templates-revisited.html'>Templates Revisited</a></li><li><a href='        ../articles/ctarguments.html'>Compile-time Sequences</a></li><li><a href='        ../articles/variadic-function-templates.html'>Variadic Templates</a></li><li><a href='        ../articles/d-array-article.html'>D Slices</a></li><li><a href='        ../articles/cppcontracts.html'>D's Contract Programming</a></li><li><a href='        ../articles/template-comparison.html'>Template Comparison</a></li><li><a href='        ../articles/dll-linux.html'>Writing Shared Libraries
    </a></li></ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BThe C Preprocessor vs D%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/articles/pretod.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>The C Preprocessor vs D</h1>
        
        


<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#headerfiles">Header Files</a></li>
    <li><a href="#pragmaonce">#pragma once</a></li>
    <li><a href="#pragmapack">#pragma pack</a></li>
    <li><a href="#macros">Macros</a></li>
    <li><a href="#conditionalcompilation">Conditional Compilation</a></li>
    <li><a href="#codefactoring">Code Factoring</a></li>
    <li><a href="#staticassert">#error and Static Asserts</a></li>
    <li><a href="#mixins">Template Mixins</a></li>
</ol>
</div>

        <p>Back when C was invented, compiler technology was primitive.
        Installing a text
        macro preprocessor onto the front end was a straightforward
        and easy way to add many
        powerful features. The increasing size &amp; complexity of programs
        have illustrated
        that these features come with many inherent problems.
        D doesn't have a preprocessor; but
        D provides a more scalable means to solve the same problems.
        </p>

<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="headerfiles" href="#headerfiles">Header Files</a></h2>

<h4>The C Preprocessor Way</h4>
        <p>C and C++ rely heavily on textual inclusion of header files.
        This frequently results in the compiler having to recompile tens of thousands
        of lines of code over and over again for every source file, an obvious
        source of slow compile times. What header files are normally used for is
        more appropriately done doing a symbolic, rather than textual, insertion.
        This is done with the import statement. Symbolic inclusion means the compiler
        just loads an already compiled symbol table. The needs for macro "wrappers" to
        prevent multiple #inclusion, funky #pragma once syntax, and incomprehensible
        fragile syntax for precompiled headers are simply unnecessary and irrelevant to
        D.
        </p>

<pre class="ccode notranslate">#include &lt;stdio.h&gt;
</pre>


<h4>The D Way</h4>
        <p>D uses symbolic imports:</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> core.stdc.stdio;
</pre>


<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="pragmaonce" href="#pragmaonce">#pragma once</a></h2>

<h4>The C Preprocessor Way</h4>
        <p>C header files frequently need to be protected against
        being #include'd multiple times.
        To do it, a header file will contain the line:
        </p>

<pre class="ccode notranslate">#pragma once
</pre>

        <p>or the more portable:</p>

<pre class="ccode notranslate">#ifndef __STDIO_INCLUDE
#define __STDIO_INCLUDE
... header file contents
#endif
</pre>


<h4>The D Way</h4>        <p>Completely unnecessary since D does a symbolic include of import
        files; they only get imported once no matter how many times
        the import declaration appears.
        </p>


<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="pragmapack" href="#pragmapack">#pragma pack</a></h2>

<h4>The C Preprocessor Way</h4>        <p>This is used in C to adjust the alignment for structs.</p>


<h4>The D Way</h4>        <p>For D classes, there is no need to adjust the alignment (in fact, the
        compiler is free to rearrange the data fields to get the optimum layout,
        much as the compiler will rearrange local variables on the stack frame).
        For D structs that get mapped onto externally defined data structures,
        there is a need, and it is handled with:
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
  <span class="d_keyword">align</span> (4):  <span class="d_comment">// use 4 byte alignment
</span>    ...
}
</pre>


<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="macros" href="#macros">Macros</a></h2>

        <p>Preprocessor macros add powerful features and flexibility to C. But
        they have a downside:
        </p>

<ul>        <li>Macros have no concept of scope; they are valid from the point of definition
        to the end of the source. They cut a swath across .h files, nested code, etc. When
        #include'ing tens of thousands of lines of macro definitions, it becomes
        problematical to avoid inadvertent macro expansions.
        </li>

        <li>Macros are unknown to the debugger. Trying to debug a program with
        symbolic data is undermined by the debugger only knowing about macro
        expansions, not the macros themselves.
        </li>

        <li>Macros make it impossible to tokenize source code, as an earlier macro change
        can arbitrarily redo tokens.
        </li>

        <li>The purely textual basis of macros leads to arbitrary and inconsistent usage,
        making code using macros error prone. (Some attempt to resolve this was
        introduced with templates in C++.)
        </li>

        <li>Macros are still used to make up for deficits in the language's expressive
        capability, such as for "wrappers" around header files.
        </li>
</ul>


        <p>Here's an enumeration of the common uses for macros, and the
        corresponding feature in D:
        </p>

<ol>        <li>Defining literal constants:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#define VALUE   5
</pre>
        

        <h4>The D Way</h4>
<pre class="d_code notranslate"><span class="d_keyword">enum</span> <span class="d_keyword">int</span> VALUE = 5;
</pre>
        
        </li>

        <li>Creating a list of values or flags:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">int flags:
#define FLAG_X  0x1
#define FLAG_Y  0x2
#define FLAG_Z  0x4
...
flags |= FLAG_X;
</pre>
        

        <h4>The D Way</h4>
<pre class="d_code notranslate"><span class="d_keyword">enum</span> FLAGS { X = 0x1, Y = 0x2, Z = 0x4 };
FLAGS flags;
...
flags |= FLAGS.X;
</pre>
        
        </li>

        <li>Distinguishing between ascii chars and wchar chars:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#if UNICODE
    #define dchar       wchar_t
    #define TEXT(s)     L##s
#else
    #define dchar       char
    #define TEXT(s)     s
#endif

...
dchar h[] = TEXT("hello");
</pre>
        

        <h4>The D Way</h4>
<pre class="d_code notranslate"><span class="d_keyword">dchar</span>[] h = <span class="d_string">"hello"</span>;
</pre>


        <p>D's optimizer will inline the function, and will do the conversion of the
        string constant at compile time.</p>
        
        </li>

        <li>Supporting legacy compilers:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#if PROTOTYPES
#define P(p)    p
#else
#define P(p)    ()
#endif
int func P((int x, int y));
</pre>
        

        <h4>The D Way</h4>        By making the D compiler open source, it will largely
        avoid the problem of syntactical backwards compatibility.
        
        </li>

        <li>Type aliasing:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#define INT     int
</pre>
        

        <h4>The D Way</h4>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> INT = <span class="d_keyword">int</span>;
</pre>
        
        </li>

        <li>Using one header file for both declaration and definition:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#define EXTERN extern
#include "declarations.h"
#undef EXTERN
#define EXTERN
#include "declarations.h"
</pre>

        In declarations.h:

<pre class="ccode notranslate">EXTERN int foo;
</pre>
        

        <h4>The D Way</h4>
        The declaration and the definition are the same, so there is no need
        to muck with the storage class to generate both a declaration and a definition
        from the same source.
        
        </li>

        <li>Lightweight inline functions:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#define X(i)    ((i) = (i) / 3)
</pre>
        

        <h4>The D Way</h4>
<pre class="d_code notranslate"><span class="d_keyword">int</span> X(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> i = i / 3; }
</pre>

        The compiler optimizer will inline it; no efficiency is lost.
        
        </li>

        <li>Assert function file and line number information:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#define assert(e)       ((e) || _assert(__LINE__, __FILE__))
</pre>
        

        <h4>The D Way</h4>
        assert() is a built-in expression primitive. Giving the compiler
        such knowledge of assert() also enables the optimizer to know about things
        like the _assert() function never returns.
        
        </li>

        <li>Setting function calling conventions:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#ifndef _CRTAPI1
#define _CRTAPI1 __cdecl
#endif
#ifndef _CRTAPI2
#define _CRTAPI2 __cdecl
#endif

int _CRTAPI2 func();
</pre>
        

        <h4>The D Way</h4>
        Calling conventions can be specified in blocks, so there's no
        need to change it for every function:

<pre class="d_code notranslate"><span class="d_keyword">extern</span> (Windows)
{
    <span class="d_keyword">int</span> onefunc();
    <span class="d_keyword">int</span> anotherfunc();
}
</pre>
        
        </li>

        <li>Hiding __near or __far pointer weirdness:

        <h4>The C Preprocessor Way</h4>
<pre class="ccode notranslate">#define LPSTR   char FAR *
</pre>
        

        <h4>The D Way</h4>
        D doesn't support 16 bit code, mixed pointer sizes, and different
        kinds of pointers, and so the problem is just
        irrelevant.
        
        </li>

        <li>Simple generic programming:

        <h4>The C Preprocessor Way</h4>
        Selecting which function to use based on text substitution:

<pre class="ccode notranslate">#ifdef UNICODE
int getValueW(wchar_t *p);
#define getValue getValueW
#else
int getValueA(char *p);
#define getValue getValueA
#endif
</pre>
        

        <h4>The D Way</h4>
        D enables declarations of symbols that are <i>aliases</i> of
        other symbols:

<pre class="d_code notranslate"><span class="d_keyword">version</span> (UNICODE)
{
    <span class="d_keyword">int</span> getValueW(<span class="d_keyword">wchar</span>[] p);
    <span class="d_keyword">alias</span> getValue = getValueW;
}
<span class="d_keyword">else</span>
{
    <span class="d_keyword">int</span> getValueA(<span class="d_keyword">char</span>[] p);
    <span class="d_keyword">alias</span> getValue = getValueA;
}
</pre>
        
        </li>

</ol>

<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="conditionalcompilation" href="#conditionalcompilation">Conditional Compilation</a></h2>


<h4>The C Preprocessor Way</h4>
        <p>Conditional compilation is a powerful feature of the C preprocessor,
        but it has its downside:</p>

    <ul>        <li>The preprocessor has no concept of scope. #if/#endif can be
        interleaved with code in a completely unstructured and disorganized
        fashion, making things difficult to follow.
        </li>

        <li>Conditional compilation triggers off of macros - macros that
        can conflict with identifiers used in the program.
        </li>

        <li>#if expressions are evaluated in subtly different ways than
        C expressions are.
        </li>

        <li>The preprocessor language is fundamentally different in concept
        than C, for example, whitespace and line terminators mean things to
        the preprocessor that they do not in C.
        </li>
    </ul>


<h4>The D Way</h4>
        <p>D supports conditional compilation:</p>

    <ol>        <li>Separating version specific functionality into separate modules.
        </li>

        <li>The debug statement for enabling/disabling debug harnesses,
        extra printing, etc.
        </li>

        <li>The version statement for dealing with multiple versions
        of the program generated from a single set of sources.
        </li>

        <li>The if (0) statement.
        </li>

        <li>The /+ +/ nesting comment can be used to comment out blocks
        of code.
        </li>
    </ol>


<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="codefactoring" href="#codefactoring">Code Factoring</a></h2>

<h4>The C Preprocessor Way</h4>
        <p>It's common in a function to have a repetitive sequence
        of code to be executed in multiple places. Performance
        considerations preclude factoring it out into a separate
        function, so it is implemented as a macro. For example,
        consider this fragment from a byte code interpreter:
        </p>

<pre class="ccode notranslate">unsigned char *ip;  // byte code instruction pointer
int *stack;
int spi;            // stack pointer
...
#define pop()       (stack[--spi])
#define push(i)     (stack[spi++] = (i))
while (1)
{
    switch (*ip++)
    {
        case ADD:
            op1 = pop();
            op2 = pop();
            result = op1 + op2;
            push(result);
            break;

        case SUB:
        ...
    }
}
</pre>

        <p>This suffers from numerous problems:
        </p>

        <ol>        <li>The macros must evaluate to expressions and cannot declare
        any variables. Consider the difficulty of extending them to
        check for stack overflow/underflow.
        </li>
        <li>The macros exist outside of the semantic symbol table, so
        remain in scope even outside of the function they are declared in.
        </li>
        <li>Parameters to macros are passed textually, not by value,
        meaning that the macro implementation needs to be careful to not
        use the parameter more than once, and must protect it with ().
        </li>
        <li>Macros are invisible to the debugger, which sees only the
        expanded expressions.
        </li>
        </ol>


<h4>The D Way</h4>
        <p>D neatly addresses this with nested functions:</p>

<pre class="d_code notranslate"><span class="d_keyword">ubyte</span>* ip;      <span class="d_comment">// byte code instruction pointer
</span><span class="d_keyword">int</span>[] stack;    <span class="d_comment">// operand stack
</span><span class="d_keyword">int</span> spi;        <span class="d_comment">// stack pointer
</span>...

<span class="d_keyword">int</span> pop()        { <span class="d_keyword">return</span> stack[--spi]; }
<span class="d_keyword">void</span> push(<span class="d_keyword">int</span> i) { stack[spi++] = i; }

<span class="d_keyword">while</span> (1)
{
    <span class="d_keyword">switch</span> (*ip++)
    {
        <span class="d_keyword">case</span> ADD:
            op1 = pop();
            op2 = pop();
            push(op1 + op2);
            <span class="d_keyword">break</span>;

        <span class="d_keyword">case</span> SUB:
        ...
    }
}
</pre>

        <p>The problems addressed are:</p>

        <ol>        <li>The nested functions have available the full expressive
        power of D functions. The array accesses already are bounds
        checked (adjustable by compile time switch).
        </li>
        <li>Nested function names are scoped just like any other name.
        </li>
        <li>Parameters are passed by value, so no need to worry about
        side effects in the parameter expressions.
        </li>
        <li>Nested functions are visible to the debugger.
        </li>
        </ol>

        <p>Additionally, nested functions can be inlined by the implementation
        resulting in the same high performance that the C macro version
        exhibits.
        </p>


<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="staticassert" href="#staticassert">#error and Static Asserts</a></h2>

        <p>Static asserts are user-defined checks made at compile time;
        if the check fails the compile issues an error and fails.
        </p>

<h4>The C Preprocessor Way</h4>
        <p>The first way is to use the <span class="d_inlinecode donthyphenate notranslate">#error</span> preprocessing directive:
        </p>

<pre class="ccode notranslate">#if FOO || BAR
    ... code to compile ...
#else
#error "there must be either FOO or BAR"
#endif
</pre>

        <p>This has the limitations inherent in preprocessor expressions
        (i.e. integer constant expressions only, no casts, no <span class="d_inlinecode donthyphenate notranslate">sizeof</span>,
        no symbolic constants, etc.).
        </p>

        <p>These problems can be circumvented to some extent by defining a
        <span class="d_inlinecode donthyphenate notranslate">static_assert</span> macro (thanks to M. Wilson):
        </p>

<pre class="ccode notranslate">#define static_assert(_x) do { typedef int ai[(_x) ? 1 : 0]; } while(0)
</pre>

        <p>and using it like:</p>

<pre class="ccode notranslate">void foo(T t)
{
    static_assert(sizeof(T) &lt; 4);
    ...
}
</pre>

        <p>This works by causing a compile time semantic error if the condition
        evaluates
        to false. The limitations of this technique are a sometimes very
        confusing error message from the compiler, along with an inability
        to use a <span class="d_inlinecode donthyphenate notranslate">static_assert</span> outside of a function body.
        </p>


<h4>The D Way</h4>
        <p>D has the <a href="../spec/version.html#StaticAssert">static assert</a>,
        which can be used anywhere a declaration
        or a statement can be used. For example:
        </p>

<pre class="d_code notranslate"><span class="d_keyword">version</span> (FOO)
{
    <span class="d_keyword">class</span> Bar
    {
        <span class="d_keyword">const</span> <span class="d_keyword">int</span> x = 5;
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(Bar.x == 5 || Bar.x == 6);

        <span class="d_keyword">void</span> foo(T t)
        {
            <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(T.sizeof &lt; 4);
            ...
        }
    }
}
<span class="d_keyword">else</span> <span class="d_keyword">version</span> (BAR)
{
    ...
}
<span class="d_keyword">else</span>
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0);   <span class="d_comment">// unsupported version
</span>}
</pre>


<hr><!-- -------------------------------------------- -->
<h2><a class="anchor" title="Permalink to this section" id="mixins" href="#mixins">Template Mixins</a></h2>

        <p>D <a href="../spec/template-mixin.html">template mixins</a>
        superficially look just
        like using C's preprocessor to insert blocks of code and
        parse them in the scope of where they are instantiated.
        But the advantages of mixins over macros are:
        </p>

        <ol>        <li>Mixins substitute in parsed declaration trees that pass muster with
        the language syntax, macros substitute in arbitrary preprocessor tokens
        that have no organization.
        </li>

        <li>Mixins are in the same language. Macros are a separate and
        distinct language layered on top of C++, with its own expression rules,
        its own types, its distinct symbol table, its own scoping rules, etc.
        </li>

        <li>Mixins are selected based on partial specialization rules, macros
        have no overloading.
        </li>

        <li>Mixins create a scope, macros do not.
        </li>

        <li>Mixins are compatible with syntax parsing tools, macros are not.
        </li>

        <li>Mixin semantic information and symbol tables are passed through to
        the debugger, macros are lost in translation.
        </li>

        <li>Mixins have override conflict resolution rules, macros just
        collide.
        </li>

        <li>Mixins automatically create unique identifiers as required using a
        standard algorithm, macros have to do it manually with kludgy token
        pasting.
        </li>

        <li>Mixin value arguments with side effects are evaluated once, macro
        value arguments get evaluated each time they are used in the expansion
        (leading to weird bugs).
        </li>

        <li>Mixin argument replacements don't need to be &lsquo;protected&rsquo; with
        parentheses to avoid operator precedence regrouping.
        </li>

        <li>Mixins can be typed as normal D code of arbitrary length, multiline
        macros have to be backslash line-spliced, can't use // to end of line
        comments, etc.
        </li>

        <li>Mixins can define other mixins. Macros cannot create other macros.
        </li>

        </ol>




        <div class="smallprint" id="copyright">Copyright &copy; 1999-2022 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2022 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Functions - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Functions' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.freenode.net/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option selected value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    <div class="head"><h5>Language Reference</h5> <p class="subnav-duplicate"><a href="../spec/spec.html">table of contents</a></p></div>
    <ul>        <li><a href='            ../spec/intro.html'>Introduction</a></li><li><a href='            ../spec/lex.html'>Lexical</a></li><li><a href='            ../spec/grammar.html'>Grammar</a></li><li><a href='            ../spec/module.html'>Modules</a></li><li><a href='            ../spec/declaration.html'>Declarations</a></li><li><a href='            ../spec/type.html'>Types</a></li><li><a href='            ../spec/property.html'>Properties</a></li><li><a href='            ../spec/attribute.html'>Attributes</a></li><li><a href='            ../spec/pragma.html'>Pragmas</a></li><li><a href='            ../spec/expression.html'>Expressions</a></li><li><a href='            ../spec/statement.html'>Statements</a></li><li><a href='            ../spec/arrays.html'>Arrays</a></li><li><a href='            ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='            ../spec/struct.html'>Structs and Unions</a></li><li><a href='            ../spec/class.html'>Classes</a></li><li><a href='            ../spec/interface.html'>Interfaces</a></li><li><a href='            ../spec/enum.html'>Enums</a></li><li><a href='            ../spec/const3.html'>Type Qualifiers</a></li><li><a href='            ../spec/function.html'>Functions</a></li><li><a href='            ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='            ../spec/template.html'>Templates</a></li><li><a href='            ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='            ../spec/contracts.html'>Contract Programming</a></li><li><a href='            ../spec/version.html'>Conditional Compilation</a></li><li><a href='            ../spec/traits.html'>Traits</a></li><li><a href='            ../spec/errors.html'>Error Handling</a></li><li><a href='            ../spec/unittest.html'>Unit Tests</a></li><li><a href='            ../spec/garbage.html'>Garbage Collection</a></li><li><a href='            ../spec/float.html'>Floating Point</a></li><li><a href='            ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='            ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='            ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='            ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='            ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='            ../spec/portability.html'>Portability Guide</a></li><li><a href='            ../spec/entity.html'>Named Character Entities</a></li><li><a href='            ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='            ../spec/abi.html'>Application Binary Interface</a></li><li><a href='            ../spec/simd.html'>Vector Extensions</a></li><li><a href='            ../spec/betterc.html'>Better C</a></li><li><a href='            ../spec/ob.html'>Live Functions
        </a></li>
    </ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BFunctions%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/spec/function.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Functions</h1>
        
<style>    body { counter-reset: h1 19; counter-increment: h1 -1; }
    h1 { counter-reset: h2 h3 p; }
    h2 { counter-reset: h3 h4 p; }
    h3 { counter-reset: h4 p; }
    h4 { counter-reset: p; }
    h1::before {
        counter-increment: h1;
        content: counter(h1) ". ";
    }
    h2::before {
        counter-increment: h2;
        content: counter(h1) "." counter(h2) " ";
    }
    h3::before {
        counter-increment: h3;
        content: counter(h1) "." counter(h2) "." counter(h3) " ";
    }
    h4::before {
        counter-increment: h4;
        content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) " ";
    }
    p::before, .spec-boxes::before {
        counter-increment: p;
        content: counter(p) ". ";
    }
    h1::before, h2::before, h3::before, h4::before, p::before, .spec-boxes::before
    {
        color: #999;
        font-size: 80%;
        margin-right: 0.25em;
    }
</style>
        <div class="blankline"></div>
<div class="blankline"></div>
<div class="blankline"></div>
<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#grammar">Grammar</a></li>
    <li><a href="#contracts">Contracts</a></li>
    <li><a href="#function-return-values">Function Return Values</a></li>
    <li><a href="#function-declarations">Functions Without Bodies</a></li>
    <li><a href="#pure-functions">Pure Functions</a></li>
    <li><a href="#nothrow-functions">Nothrow Functions</a></li>
    <li><a href="#ref-functions">Ref Functions</a></li>
    <li><a href="#auto-functions">Auto Functions</a></li>
    <li><a href="#auto-ref-functions">Auto Ref Functions</a></li>
    <li><a href="#inout-functions">Inout Functions</a></li>
    <li><a href="#optional-parenthesis">Optional Parentheses</a></li>
    <li><a href="#property-functions">Property Functions</a></li>
    <li><a href="#virtual-functions">Virtual Functions</a><ol>        <li><a href="#function-inheritance">Function Inheritance and Overriding</a></li>
    </ol></li>
    <li><a href="#inline-functions">Inline Functions</a></li>
    <li><a href="#function-overloading">Function Overloading</a><ol>        <li><a href="#overload-sets">Overload Sets</a></li>
    </ol></li>
    <li><a href="#parameters">Function Parameters</a><ol>        <li><a href="#param-storage">Parameter Storage Classes</a></li>
        <li><a href="#lazy-params">Lazy Parameters</a></li>
        <li><a href="#function-default-args">Function Default Arguments</a></li>
        <li><a href="#return-ref-parameters">Return Ref Parameters</a></li>
        <li><a href="#return-scope-parameters">Return Scope Parameters</a></li>
        <li><a href="#ref-return-scope-parameters">Ref Return Scope Parameters</a></li>
        <li><a href="#udas-parameters">User-Defined Attributes for Parameters</a></li>
        <li><a href="#variadic">Variadic Functions</a></li>
    </ol></li>
    <li><a href="#local-variables">Local Variables</a><ol>        <li><a href="#local-static-variables">Local Static Variables</a></li>
    </ol></li>
    <li><a href="#nested">Nested Functions</a></li>
    <li><a href="#closures">Delegates, Function Pointers, and  Closures</a><ol>        <li><a href="#anonymous">Anonymous Functions and Anonymous Delegates</a></li>
    </ol></li>
    <li><a href="#main"><span class="d_inlinecode donthyphenate notranslate">main()</span> Function</a></li>
    <li><a href="#function-templates">Function Templates</a></li>
    <li><a href="#interpretation">Compile Time Function Execution (CTFE)</a><ol>        <li><a href="#string-mixins">String Mixins and Compile Time Function Execution</a></li>
    </ol></li>
    <li><a href="#nogc-functions">No-GC Functions</a></li>
    <li><a href="#function-safety">Function Safety</a><ol>        <li><a href="#safe-functions">Safe Functions</a></li>
        <li><a href="#trusted-functions">Trusted Functions</a></li>
        <li><a href="#system-functions">System Functions</a></li>
        <li><a href="#safe-interfaces">Safe Interfaces</a></li>
        <li><a href="#safe-values">Safe Values</a></li>
        <li><a href="#safe-aliasing">Safe Aliasing</a></li>
    </ol></li>
    <li><a href="#function-attribute-inference">Function Attribute Inference</a></li>
    <li><a href="#pseudo-member">Uniform Function Call Syntax (UFCS)</a></li>
</ol>
</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="grammar" href="#grammar">Grammar</a></h2>
<div class="blankline"></div>
<h3>Function declaration</h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FuncDeclaration"><span class="gname">FuncDeclaration</span></a>:
    <a href="../spec/declaration.html#StorageClasses"><i>StorageClasses</i></a><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="#FuncDeclarator"><i>FuncDeclarator</i></a> <a href="#FunctionBody"><i>FunctionBody</i></a>
    <a href="#AutoFuncDeclaration"><i>AutoFuncDeclaration</i></a>
<div class="blankline"></div>
<a id="AutoFuncDeclaration"><span class="gname">AutoFuncDeclaration</span></a>:
    <a href="../spec/declaration.html#StorageClasses"><i>StorageClasses</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <a href="#FuncDeclaratorSuffix"><i>FuncDeclaratorSuffix</i></a> <a href="#FunctionBody"><i>FunctionBody</i></a>
<div class="blankline"></div>
<a id="FuncDeclarator"><span class="gname">FuncDeclarator</span></a>:
    <a href="../spec/declaration.html#BasicType2"><i>BasicType2</i></a><sub>opt</sub> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <a href="#FuncDeclaratorSuffix"><i>FuncDeclaratorSuffix</i></a>
<div class="blankline"></div>
<a id="FuncDeclaratorSuffix"><span class="gname">FuncDeclaratorSuffix</span></a>:
    <a href="#Parameters"><i>Parameters</i></a> <a href="#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub>
    <a href="../spec/template.html#TemplateParameters"><i>TemplateParameters</i></a> <a href="#Parameters"><i>Parameters</i></a> <a href="#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="../spec/template.html#Constraint"><i>Constraint</i></a><sub>opt</sub>
</pre>
<div class="blankline"></div>
<h3>Parameters</h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="Parameters"><span class="gname">Parameters</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ParameterList"><i>ParameterList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<a id="ParameterList"><span class="gname">ParameterList</span></a>:
    <a href="#Parameter"><i>Parameter</i></a>
    <a href="#Parameter"><i>Parameter</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>ParameterList</i>
    <span class="d_inlinecode donthyphenate notranslate">...</span>
<div class="blankline"></div>
<a id="Parameter"><span class="gname">Parameter</span></a>:
    <i>ParameterAttributes</i><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="../spec/declaration.html#Declarator"><i>Declarator</i></a>
    <i>ParameterAttributes</i><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="../spec/declaration.html#Declarator"><i>Declarator</i></a> <span class="d_inlinecode donthyphenate notranslate">...</span>
    <i>ParameterAttributes</i><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="../spec/declaration.html#Declarator"><i>Declarator</i></a> = <a href="../spec/expression.html#AssignExpression"><i>AssignExpression</i></a>
    <i>ParameterAttributes</i><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a>
    <i>ParameterAttributes</i><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">...</span>
<div class="blankline"></div>
<a id="ParameterAttributes"><span class="gname">ParameterAttributes</span></a>:
    <i>InOut</i>
    <a href="../spec/attribute.html#UserDefinedAttribute"><i>UserDefinedAttribute</i></a>
    <i>ParameterAttributes InOut</i>
    <i>ParameterAttributes</i> <a href="../spec/attribute.html#UserDefinedAttribute"><i>UserDefinedAttribute</i></a>
    <i>ParameterAttributes</i>
<div class="blankline"></div>
<a id="InOut"><span class="gname">InOut</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">auto</span>
    <a href="../spec/declaration.html#TypeCtor"><i>TypeCtor</i></a>
    <span class="d_inlinecode donthyphenate notranslate">final</span>
    <span class="d_inlinecode donthyphenate notranslate">in</span>
    <span class="d_inlinecode donthyphenate notranslate">lazy</span>
    <span class="d_inlinecode donthyphenate notranslate">out</span>
    <span class="d_inlinecode donthyphenate notranslate">ref</span>
    <a href="#return-ref-parameters"><span class="d_inlinecode donthyphenate notranslate">return ref</span></a>
    <span class="d_inlinecode donthyphenate notranslate">scope</span>
</pre>
<div class="blankline"></div>
<h3>Function attributes</h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FunctionAttributes"><span class="gname">FunctionAttributes</span></a>:
    <a href="#FunctionAttribute"><i>FunctionAttribute</i></a>
    <a href="#FunctionAttribute"><i>FunctionAttribute</i></a> <i>FunctionAttributes</i>
<div class="blankline"></div>
<a id="FunctionAttribute"><span class="gname">FunctionAttribute</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">nothrow</span>
    <span class="d_inlinecode donthyphenate notranslate">pure</span>
    <a href="../spec/attribute.html#Property"><i>Property</i></a>
<div class="blankline"></div>
<a id="MemberFunctionAttributes"><span class="gname">MemberFunctionAttributes</span></a>:
    <a href="#MemberFunctionAttribute"><i>MemberFunctionAttribute</i></a>
    <a href="#MemberFunctionAttribute"><i>MemberFunctionAttribute</i></a> <i>MemberFunctionAttributes</i>
<div class="blankline"></div>
<a id="MemberFunctionAttribute"><span class="gname">MemberFunctionAttribute</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">const</span>
    <span class="d_inlinecode donthyphenate notranslate">immutable</span>
    <span class="d_inlinecode donthyphenate notranslate">inout</span>
    <span class="d_inlinecode donthyphenate notranslate">return</span>
    <span class="d_inlinecode donthyphenate notranslate">shared</span>
    <a href="#FunctionAttribute"><i>FunctionAttribute</i></a>
</pre>
<div class="blankline"></div>
<h3>Function body</h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FunctionBody"><span class="gname">FunctionBody</span></a>:
    <a href="#SpecifiedFunctionBody"><i>SpecifiedFunctionBody</i></a>
    <a href="#MissingFunctionBody"><i>MissingFunctionBody</i></a>
<div class="blankline"></div>
<a id="FunctionLiteralBody"><span class="gname">FunctionLiteralBody</span></a>:
    <a href="#SpecifiedFunctionBody"><i>SpecifiedFunctionBody</i></a>
<div class="blankline"></div>
<a id="SpecifiedFunctionBody"><span class="gname">SpecifiedFunctionBody</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">do</span><sub>opt</sub> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
    <a href="#FunctionContracts"><i>FunctionContracts</i></a><sub>opt</sub> <a href="#InOutContractExpression"><i>InOutContractExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">do</span><sub>opt</sub> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
    <a href="#FunctionContracts"><i>FunctionContracts</i></a><sub>opt</sub> <a href="#InOutStatement"><i>InOutStatement</i></a> <span class="d_inlinecode donthyphenate notranslate">do</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
<div class="blankline"></div>
<a id="MissingFunctionBody"><span class="gname">MissingFunctionBody</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">;</span>
    <a href="#FunctionContracts"><i>FunctionContracts</i></a><sub>opt</sub> <a href="#InOutContractExpression"><i>InOutContractExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">;</span>
    <a href="#FunctionContracts"><i>FunctionContracts</i></a><sub>opt</sub> <a href="#InOutStatement"><i>InOutStatement</i></a>
</pre>
<div class="blankline"></div>
<h3>Function contracts</h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FunctionContracts"><span class="gname">FunctionContracts</span></a>:
    <a href="#FunctionContract"><i>FunctionContract</i></a>
    <a href="#FunctionContract"><i>FunctionContract</i></a> <i>FunctionContracts</i>
<div class="blankline"></div>
<a id="FunctionContract"><span class="gname">FunctionContract</span></a>:
    <a href="#InOutContractExpression"><i>InOutContractExpression</i></a>
    <a href="#InOutStatement"><i>InOutStatement</i></a>
<div class="blankline"></div>
<a id="InOutContractExpression"><span class="gname">InOutContractExpression</span></a>:
    <a href="#InContractExpression"><i>InContractExpression</i></a>
    <a href="#OutContractExpression"><i>OutContractExpression</i></a>
<div class="blankline"></div>
<a id="InOutStatement"><span class="gname">InOutStatement</span></a>:
    <a href="#InStatement"><i>InStatement</i></a>
    <a href="#OutStatement"><i>OutStatement</i></a>
<div class="blankline"></div>
<a id="InContractExpression"><span class="gname">InContractExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">in (</span> <a href="../spec/expression.html#AssertArguments"><i>AssertArguments</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<a id="OutContractExpression"><span class="gname">OutContractExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">out ( ;</span> <a href="../spec/expression.html#AssertArguments"><i>AssertArguments</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">out (</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">;</span> <a href="../spec/expression.html#AssertArguments"><i>AssertArguments</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<a id="InStatement"><span class="gname">InStatement</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">in</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
<div class="blankline"></div>
<a id="OutStatement"><span class="gname">OutStatement</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">out</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
    <span class="d_inlinecode donthyphenate notranslate">out</span> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="contracts" href="#contracts">Contracts</a></h2>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">in</span> and <span class="d_inlinecode donthyphenate notranslate">out</span> blocks or expressions of a function declaration specify
    the pre- and post-conditions of the function. They are used in
    <a href="contracts.html">Contract Programming</a>.
    The code inside these blocks should
    not have any side-effects, including modifying function parameters
    and/or return values.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="function-return-values" href="#function-return-values">Function Return Values</a></h2>
<div class="blankline"></div>
        <p>Function return values are considered to be rvalues.
        This means they cannot be passed by reference to other functions.
        </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="function-declarations" href="#function-declarations">Functions Without Bodies</a></h2>
<div class="blankline"></div>
    <p>Functions without bodies:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo();
</pre>
<div class="blankline"></div>
    <p>that are not declared as <span class="d_inlinecode donthyphenate notranslate">abstract</span> are expected to have their implementations
    elsewhere, and that implementation will be provided at the link step.
    This enables an implementation of a function to be completely hidden from the user
    of it, and the implementation may be in another language such as C, assembler, etc.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="pure-functions" href="#pure-functions">Pure Functions</a></h2>
<div class="blankline"></div>
        <p>Pure functions are functions that cannot directly access global or static
            mutable state. <span class="d_inlinecode donthyphenate notranslate">pure</span> guarantees that a pure function call
            won't access or modify any implicit state in the program.
        </p>
<div class="blankline"></div>
        <p>Unlike other functional programming languages, D's <span class="d_inlinecode donthyphenate notranslate">pure</span>
            functions allow modification of the caller state through their mutable
            parameters.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">pure</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>[] arr) { arr[] += 1; <span class="d_keyword">return</span> arr.length; }
<span class="d_keyword">int</span>[] a = [1, 2, 3];
foo(a);
<span class="d_keyword">assert</span>(a == [2, 3, 4]);
</pre>
<div class="blankline"></div>
        <p>A <span class="d_inlinecode donthyphenate notranslate">pure</span> function accepting parameters with mutable indirections offers
            what's called "weak purity" because it can change program state
            transitively through its arguments. A <span class="d_inlinecode donthyphenate notranslate">pure</span> function that has
            no parameter with mutable indirections is called "strongly pure"
            and fulfills the purity definition in traditional functional languages.
            Weakly <span class="d_inlinecode donthyphenate notranslate">pure</span> functions are useful as reusable building blocks for strongly pure functions.
        </p>
<div class="blankline"></div>
        <p>To prevent mutation, D offers the <span class="d_inlinecode donthyphenate notranslate">immutable</span> type qualifier.
            If all of a <span class="d_inlinecode donthyphenate notranslate">pure</span> function's parameters are <span class="d_inlinecode donthyphenate notranslate">immutable</span> or
            copied values without any indirections (e.g. <span class="d_inlinecode donthyphenate notranslate">int</span>),
            the type system guarantees no side effects.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">double</span> x; }
<span class="d_keyword">pure</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] arr, <span class="d_keyword">int</span> num, S val)
{
    <span class="d_comment">//arr[num] = 1; // compile error
</span>    num = 2;        <span class="d_comment">// has no side effect to the caller side
</span>    val.x = 3.14;   <span class="d_comment">// ditto
</span>    <span class="d_keyword">return</span> arr.length;
}
</pre>
<div class="blankline"></div>
        <p>The maximum guarantee of <span class="d_inlinecode donthyphenate notranslate">pure</span> is called "strong purity". It can enable
            optimizations based on the fact
            that a function is guaranteed to not mutate anything which isn't passed to it.
            For cases where the compiler can guarantee that a pure function cannot
            alter its arguments, it can enable full, functional purity (i.e. the guarantee
            that the function will always return the same result for the same arguments).
            To that end, a pure function:
        </p>
<div class="blankline"></div>
        <ul>        <li>does not read or write any global or static mutable state</li>
        <li>cannot call functions that are not pure</li>
        <li>can override an impure function, but cannot be overridden by an impure function</li>
        <li>is covariant with an impure function</li>
        <li>cannot perform I/O</li>
        </ul>
<div class="blankline"></div>
        <p>This definition of mutable functions is more general than the one
        traditionally employed by pure functional languages because it allows a
        D pure function to use state mutation, as long as all state is created
        internally or reachable through its arguments. In particular, a pure
        function may allocate memory by means of e.g. <span class="d_inlinecode donthyphenate notranslate">new</span> or <span class="d_inlinecode donthyphenate notranslate">malloc</span> without
        these being special cases. A pure function is allowed to loop
        indefinitely or terminate the program.</p>
<div class="blankline"></div>
        <p>As a concession to practicality, a pure function can also:</p>
<div class="blankline"></div>
        <ul>        <li>read and write the floating point exception flags</li>
        <li>read and write the floating point mode flags, as long as those
        flags are restored to their initial state upon function entry</li>
        <li>perform impure operations in statements that are in a
        <a href="../spec/version.html#ConditionalStatement"><i>ConditionalStatement</i></a>
        controlled by a <a href="../spec/version.html#DebugCondition"><i>DebugCondition</i></a>.</li>
        </ul>
<div class="blankline"></div>
        <p>A pure function can throw exceptions.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">int</span> x;
<span class="d_keyword">immutable</span> <span class="d_keyword">int</span> y;
<span class="d_keyword">const</span> <span class="d_keyword">int</span>* pz;

<span class="d_keyword">pure</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i,
             <span class="d_keyword">char</span>* p,
             <span class="d_keyword">const</span> <span class="d_keyword">char</span>* q,
             <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>* s)
{
    <span class="d_keyword">debug</span> writeln(<span class="d_string">"in foo()"</span>); <span class="d_comment">// ok, impure code allowed in debug statement
</span>    x = i;   <span class="d_comment">// error, modifying global state
</span>    i = x;   <span class="d_comment">// error, reading mutable global state
</span>    i = y;   <span class="d_comment">// ok, reading immutable global state
</span>    i = *pz; <span class="d_comment">// error, reading const global state
</span>    <span class="d_keyword">return</span> i;
}
</pre>
<div class="blankline"></div>
    <p>An implementation may assume that a <span class="d_inlinecode donthyphenate notranslate">pure</span> function that (a) accepts
    only parameters without mutable indirections, and (b) returns a result
    without mutable indirections, will have the same effect for all invocation
    with equivalent arguments, and is allowed to memoize the result of the
    function under the assumption that equivalent parameters always produce
    equivalent results. Such functions are termed <i>strongly <span class="d_inlinecode donthyphenate notranslate">pure</span></i> functions
    in this document. Note that a strongly pure function may still have behavior
    inconsistent with memoization by e.g. using <span class="d_inlinecode donthyphenate notranslate">cast</span>s or by changing behavior
    depending on the address of its parameters. An implementation is currently
    not required to enforce validity of memoization in all cases.</p>
<div class="blankline"></div>
    <p>A pure function that accepts only parameters without mutable
    indirections and returns a result that has mutable indirections is called a
    <i>pure factory function</i>. An implementation may assume that all mutable
    memory returned by the call is not referenced by any other part of the
    program, i.e. it is newly allocated by the function. Conversely, the mutable
    references of the result may be assumed to not refer to any object that
    existed before the function call. For example:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">struct</span> List { <span class="d_keyword">int</span> payload; List* next; }
<span class="d_keyword">pure</span> List* make(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
{
    <span class="d_keyword">auto</span> result = <span class="d_keyword">new</span> List(a, <span class="d_keyword">null</span>);
    result.next = <span class="d_keyword">new</span> List(b, result);
    <span class="d_keyword">return</span> result;
}
</pre>

</div>
<div class="blankline"></div>
    <p>Here, an implementation may assume (without having knowledge of the body
    of <span class="d_inlinecode donthyphenate notranslate">make</span>) that all references in <span class="d_inlinecode donthyphenate notranslate">make</span>'s result refer to other <span class="d_inlinecode donthyphenate notranslate">List</span>
    objects created by <span class="d_inlinecode donthyphenate notranslate">make</span>, and that no other part of the program refers to
    any of these objects.</p>
<div class="blankline"></div>
    <p>Any <span class="d_inlinecode donthyphenate notranslate">pure</span> function that is not strongly pure cannot be assumed to be
    memoizable, and calls to it may not be elided even if it returns <span class="d_inlinecode donthyphenate notranslate">void</span>
    (save for compiler optimizations that prove the function has no effect).
    Function calls may still be elided, or results be memoized, by means of
    traditional inlining and optimization techniques available for all
    functions.</p>
<div class="blankline"></div>
    <p>If a strongly pure function throws an exception or an error, the
    assumptions related to memoization and references do not carry to the thrown
    exception.</p>
<div class="blankline"></div>
    <p>Pure destructors do not benefit of special elision.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="nothrow-functions" href="#nothrow-functions">Nothrow Functions</a></h2>
<div class="blankline"></div>
        <p>Nothrow functions can only throw exceptions derived
        from class <i>Error</i>.
        </p>
<div class="blankline"></div>
        <p>Nothrow functions are covariant with throwing ones.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="ref-functions" href="#ref-functions">Ref Functions</a></h2>
<div class="blankline"></div>
        <p>Ref functions allow functions to return by reference.
        This is analogous to ref function parameters.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo()
{
    <span class="d_keyword">auto</span> p = <span class="d_keyword">new</span> <span class="d_keyword">int</span>;
    <span class="d_keyword">return</span> *p;
}
...
foo() = 3;  <span class="d_comment">// reference returns can be lvalues
</span></pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="auto-functions" href="#auto-functions">Auto Functions</a></h2>
<div class="blankline"></div>
    <p>Auto functions have their return type inferred from any
        <a href="../spec/statement.html#ReturnStatement"><i>ReturnStatement</i></a>s in the function body.
    </p>
<div class="blankline"></div>
    <p>An auto function is declared without a return type.
        If it does not already have a storage class, use the
        <span class="d_keyword">auto</span> storage class.
    </p>
<div class="blankline"></div>
    <p>If there are multiple <i>ReturnStatement</i>s, the types
        of them must be implicitly convertible to a common type.
        If there are no <i>ReturnStatement</i>s, the return type is inferred
        to be <span class="d_keyword">void</span>.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">auto</span> foo(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x + 3; }          <span class="d_comment">// inferred to be int
</span><span class="d_keyword">auto</span> bar(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; <span class="d_keyword">return</span> 2.5; }  <span class="d_comment">// inferred to be double
</span></pre>
        
</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="auto-ref-functions" href="#auto-ref-functions">Auto Ref Functions</a></h2>
<div class="blankline"></div>
    <p>Auto ref functions infer their return type just as
        <a href="#auto-functions">auto functions</a> do.
        In addition, they become <a href="#ref-functions">ref functions</a>
        if all return expressions are lvalues,
        and it would not be a reference to a local or a parameter.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f1(<span class="d_keyword">int</span> x)     { <span class="d_keyword">return</span> x; }  <span class="d_comment">// value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f2()          { <span class="d_keyword">return</span> 3; }  <span class="d_comment">// value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f3(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f4(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f5() { <span class="d_keyword">static</span> <span class="d_keyword">int</span> x; <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span></pre>
        
</div>
<div class="blankline"></div>
    <p>The ref-ness of a function is determined from all
        <a href="../spec/statement.html#ReturnStatement"><i>ReturnStatement</i></a>s in the function body:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f1(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> 3; <span class="d_keyword">return</span> x; }  <span class="d_comment">// ok, value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f2(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; <span class="d_keyword">return</span> 3; }  <span class="d_comment">// ok, value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> f3(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x, <span class="d_keyword">ref</span> <span class="d_keyword">double</span> y)
{
    <span class="d_keyword">return</span> x; <span class="d_keyword">return</span> y;
    <span class="d_comment">// The return type is deduced to double, but cast(double)x is not an lvalue,
</span>    <span class="d_comment">// then become a value return.
</span>}
</pre>
        
</div>
<div class="blankline"></div>
    <p>Auto ref function can have explicit return type.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> (<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ok, ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">double</span> x) { <span class="d_keyword">return</span> x; }   <span class="d_comment">// error, cannot convert double to int
</span></pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="inout-functions" href="#inout-functions">Inout Functions</a></h2>
<div class="blankline"></div>
    <p>Functions that deal with mutable, const, or immutable types with
        equanimity often need to transmit their type to the return value:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] f1(<span class="d_keyword">int</span>[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }

<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] f2(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }

<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] f3(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }
</pre>
        
</div>
<div class="blankline"></div>
    <p>The code generated by these three functions is identical.
        To indicate that these can be one function, the <span class="d_keyword">inout</span>
        type constructor is employed:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }
</pre>
        
</div>
<div class="blankline"></div>
    <p>The <span class="d_keyword">inout</span> forms a wildcard that stands in for
        any of mutable, const, immutable, inout, or inout const. When the
        function is called, the inout of the return type is changed to whatever
        the mutable, const, immutable, inout, or inout const status of the
        argument type to the parameter inout was.
    </p>
<div class="blankline"></div>
    <p>Inout types can be implicitly converted to const or inout const,
        but to nothing else. Other types cannot be implicitly converted to inout.
        Casting to or from inout is not allowed in @safe functions.
    </p>
<div class="blankline"></div>
    <p>A set of arguments to a function with inout parameters is considered
        a match if any inout argument types match exactly, or:</p>
<div class="blankline"></div>
    <ol>        <li>No argument types are composed of inout types.</li>
        <li>A mutable, const or immutable argument type can be matched against each
        corresponding parameter inout type.</li>
    </ol>
<div class="blankline"></div>
    <p>If such a match occurs, the inout is considered the common qualifier of
        the matched qualifiers. If more than two parameters exist, the common
        qualifier calculation is recursively applied.
    </p>
<div class="blankline"></div>
    <center><table><caption>Common qualifier of the two type qualifiers</caption>        <tr><td></td><td><i>mutable</i></td><td><span class="d_inlinecode donthyphenate notranslate">const</span></td><td><span class="d_inlinecode donthyphenate notranslate">immutable</span></td><td><span class="d_inlinecode donthyphenate notranslate">inout</span></td><td><span class="d_inlinecode donthyphenate notranslate">inout const</span></td></tr>
        <tr><td><i>mutable</i> (= m)</td><td>m</td><td>c</td><td>c</td><td>c</td><td>c</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">const</span> (= c)</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable</span> (= i)</td><td>c</td><td>c</td><td>i</td><td>wc</td><td>wc</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">inout</span> (= w)</td><td>c</td><td>c</td><td>wc</td><td>w</td><td>wc</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">inout const</span> (= wc)</td><td>c</td><td>c</td><td>wc</td><td>wc</td><td>wc</td></tr>
    </table></center>
<div class="blankline"></div>
    <p>The inout in the return type is then rewritten to be the inout matched
        qualifiers:</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] ma;
<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] ca;
<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] ia;

<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] a) { <span class="d_keyword">return</span> a; }
<span class="d_keyword">void</span> test1()
{
    <span class="d_comment">// inout matches to mutable, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to int[]
</span>    <span class="d_keyword">int</span>[] x = foo(ma);

    <span class="d_comment">// inout matches to const, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to const(int)[]
</span>    <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] y = foo(ca);

    <span class="d_comment">// inout matches to immutable, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to immutable(int)[]
</span>    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] z = foo(ia);
}

<span class="d_keyword">inout</span>(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>))[] bar(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] a) { <span class="d_keyword">return</span> a; }
<span class="d_keyword">void</span> test2()
{
    <span class="d_comment">// inout matches to mutable, so inout(const(int))[] is
</span>    <span class="d_comment">// rewritten to const(int)[]
</span>    <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] x = bar(ma);

    <span class="d_comment">// inout matches to const, so inout(const(int))[] is
</span>    <span class="d_comment">// rewritten to const(int)[]
</span>    <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] y = bar(ca);

    <span class="d_comment">// inout matches to immutable, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to immutable(int)[]
</span>    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] z = bar(ia);
}
</pre>
        
</div>
<div class="blankline"></div>
    <p><b>Note:</b> Shared types are not overlooked. Shared types cannot
        be matched with inout.
    </p>
<div class="blankline"></div>
    <p><a href="#variadicnested">Nested functions</a> inside pure function are implicitly marked as pure.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">pure</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">immutable</span> <span class="d_keyword">int</span> y)
{
    <span class="d_keyword">int</span> bar()
    <span class="d_comment">// implicitly marked as pure, to be "weak purity"
</span>    <span class="d_comment">// hidden context pointer is mutable
</span>    {
        x = 10;     <span class="d_comment">// can access states in enclosing scope
</span>                    <span class="d_comment">// through the mutable context pointer
</span>        <span class="d_keyword">return</span> x;
    }
    <span class="d_keyword">pragma</span>(msg, <span class="d_keyword">typeof</span>(&amp;bar));  <span class="d_comment">// int delegate() pure
</span>
    <span class="d_keyword">int</span> baz() <span class="d_keyword">immutable</span>
    <span class="d_comment">// qualify hidden context pointer with immutable,
</span>    <span class="d_comment">// and has no other parameters, make "strong purity"
</span>    {
        <span class="d_comment">//return x; // error, cannot access mutable data
</span>                    <span class="d_comment">// through the immutable context pointer
</span>        <span class="d_keyword">return</span> y;   <span class="d_comment">// ok
</span>    }

    <span class="d_comment">// can call pure nested functions
</span>    <span class="d_keyword">return</span> bar() + baz();
}
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="optional-parenthesis" href="#optional-parenthesis">Optional Parentheses</a></h2>
<div class="blankline"></div>
    <p>If a function call passes no explicit argument, i.e. it would syntactically use <span class="d_inlinecode donthyphenate notranslate">()</span>, then these parentheses
    may be omitted, similar to a getter invocation of a
        <a href="#property-functions">property function</a>.
        </p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo() {}   <span class="d_comment">// no arguments
</span><span class="d_keyword">void</span> fun(<span class="d_keyword">int</span> x = 10) { }
<span class="d_keyword">void</span> bar(<span class="d_keyword">int</span>[] arr) {}  <span class="d_comment">// for UFCS
</span>
<span class="d_keyword">void</span> main()
{
    foo();      <span class="d_comment">// OK
</span>    foo;        <span class="d_comment">// also OK
</span>    fun;        <span class="d_comment">// OK
</span>
    <span class="d_keyword">int</span>[] arr;
    arr.bar();  <span class="d_comment">// OK
</span>    arr.bar;    <span class="d_comment">// also OK
</span>}
</pre>
        
</div>
<div class="blankline"></div>
    <p>Optional parentheses are not applied to delegates or function pointers.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

    <span class="d_keyword">assert</span>(fp == 6);    <span class="d_comment">// Error, incompatible types int function() and int
</span>    <span class="d_keyword">assert</span>(*fp == 6);   <span class="d_comment">// Error, incompatible types int() and int
</span>
    <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
    <span class="d_keyword">assert</span>(dg == 6);    <span class="d_comment">// Error, incompatible types int delegate() and int
</span>}
</pre>
<div class="blankline"></div>
    <p>If a function returns a delegate or function pointer, the parentheses are required if the
    returned value is to be called.
    </p>
<div class="blankline"></div>
    <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S {
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>() callfp() { <span class="d_keyword">return</span> &amp;numfp; }
    <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() calldg() <span class="d_keyword">return</span> { <span class="d_keyword">return</span> &amp;numdg; }
    <span class="d_keyword">int</span> numdg() { <span class="d_keyword">return</span> 6; }
}

<span class="d_keyword">int</span> numfp() { <span class="d_keyword">return</span> 6; }

<span class="d_keyword">void</span> main()
{
    S s;
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

    fp = s.callfp;
    <span class="d_keyword">assert</span>(fp() == 6);

    fp = s.callfp();
    <span class="d_keyword">assert</span>(fp() == 6);

    <span class="d_keyword">int</span> x = s.callfp()();
    <span class="d_keyword">assert</span>(x == 6);

    <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;

    dg = s.calldg;
    <span class="d_keyword">assert</span>(dg() == 6);

    dg = s.calldg();
    <span class="d_keyword">assert</span>(dg() == 6);

    <span class="d_keyword">int</span> y = s.calldg()();
    <span class="d_keyword">assert</span>(y == 6);
}
</pre>
    
</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="property-functions" href="#property-functions">Property Functions</a></h2>
<div class="blankline"></div>
    <p>WARNING: The definition and usefulness of property functions is being reviewed, and the implementation
    is currently incomplete.  Using property functions is not recommended until the definition is
    more certain and implementation more mature.</p>
<div class="blankline"></div>
    <p>Properties are functions that can be syntactically treated
    as if they were fields or variables. Properties can be read from or written to.
    A property is read by calling a method or function with no arguments;
    a property is written by calling a method or function with its argument
    being the value it is set to.
    </p>
<div class="blankline"></div>
    <p>Simple getter and setter properties can be written using <a href="#pseudo-member">UFCS</a>.
    These can be enhanced with the additon of the <span class="d_inlinecode donthyphenate notranslate">@property</span> attribute to the function, which
    adds the following behaviors:
    </p>
<div class="blankline"></div>
    <ul>    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> functions cannot be overloaded with non-<span class="d_inlinecode donthyphenate notranslate">@property</span> functions with the same name.</li>
    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> functions can only have zero, one or two parameters.</li>
    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> functions cannot have variadic parameters.</li>
    <li>For the expression <span class="d_inlinecode donthyphenate notranslate">typeof(exp)</span> where <span class="d_inlinecode donthyphenate notranslate">exp</span> is an <span class="d_inlinecode donthyphenate notranslate">@property</span> function,
    the type is the return type of the function, rather than the type of the function.</li>
    <li>For the expression <span class="d_inlinecode donthyphenate notranslate">__traits(compiles, exp)</span> where <span class="d_inlinecode donthyphenate notranslate">exp</span> is an <span class="d_inlinecode donthyphenate notranslate">@property</span> function,
    a further check is made to see if the function can be called.</li>
    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> are mangled differently, meaning that <span class="d_inlinecode donthyphenate notranslate">@property</span> must be consistently
    used across different compilation units.</li>
    <li>The ObjectiveC interface recognizes <span class="d_inlinecode donthyphenate notranslate">@property</span> setter functions as special and modifies
    them accordingly.</li>
    </ul>
<div class="blankline"></div>
    <p>A simple property would be:</p>
<div class="blankline"></div>
<div class="blankline"></div>
    <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
    @property <span class="d_keyword">int</span> data() { <span class="d_keyword">return</span> m_data; } <span class="d_comment">// read property
</span>
    @property <span class="d_keyword">int</span> data(<span class="d_keyword">int</span> value) { <span class="d_keyword">return</span> m_data = value; } <span class="d_comment">// write property
</span>
  <span class="d_keyword">private</span>:
    <span class="d_keyword">int</span> m_data;
}
</pre>
    
</div>
<div class="blankline"></div>
        <p>To use it:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> test()
{
    Foo f;

    f.data = 3;        <span class="d_comment">// same as f.data(3);
</span>    <span class="d_keyword">return</span> f.data + 3; <span class="d_comment">// same as return f.data() + 3;
</span>}
</pre>
<div class="blankline"></div>
    <p>The absence of a read method means that the property is write-only.
    The absence of a write method means that the property is read-only.
    Multiple write methods can exist; the correct one is selected using
    the usual function overloading rules.
    </p>
<div class="blankline"></div>
    <p>In all the other respects, these methods are like any other methods.
    They can be static, have different linkages,  have their address taken, etc.
    </p>
<div class="blankline"></div>
    <p>The built in properties <span class="d_inlinecode donthyphenate notranslate">.sizeof</span>, <span class="d_inlinecode donthyphenate notranslate">.alignof</span>, and <span class="d_inlinecode donthyphenate notranslate">.mangleof</span>
    may not be declared as fields or methods in structs, unions, classes or enums.
    </p>
<div class="blankline"></div>
        <p>If a property function has no parameters, it works as a getter.
        If has exactly one parameter, it works as a setter.
        </p>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="virtual-functions" href="#virtual-functions">Virtual Functions</a></h2>
<div class="blankline"></div>
        <p>Virtual functions are functions that are called indirectly through a
        function pointer table, called a vtbl[], rather than directly. All
        <span class="d_inlinecode donthyphenate notranslate">public</span> and <span class="d_inlinecode donthyphenate notranslate">protected</span> member functions which are non-static and
        are not templatized are virtual unless the compiler can determine that
        they will never be overridden (e.g. they are marked with <span class="d_inlinecode donthyphenate notranslate">final</span> and
        do not override any functions in a base class), in which case, it will
        make them non-virtual. Static or <span class="d_inlinecode donthyphenate notranslate">final</span> functions with <span class="d_inlinecode donthyphenate notranslate">Objective-C</span>
        linkage are virtual as well. This results in fewer bugs caused by not
        declaring a function virtual and then overriding it anyway.
        </p>
<div class="blankline"></div>
        <p>Member functions which are <span class="d_inlinecode donthyphenate notranslate">private</span> or <span class="d_inlinecode donthyphenate notranslate">package</span> are never
        virtual, and hence cannot be overridden.
        </p>
<div class="blankline"></div>
        <p>Functions with non-D linkage cannot be virtual and hence cannot be
        overridden.
        </p>
<div class="blankline"></div>
        <p>Member template functions cannot be virtual and hence cannot be
        overridden.
        </p>
<div class="blankline"></div>
        <p>Functions marked as <span class="d_inlinecode donthyphenate notranslate">final</span> may not be overridden in a
        derived class, unless they are also <span class="d_inlinecode donthyphenate notranslate">private</span>.
        For example:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> def() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">int</span> foo() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">private</span> <span class="d_keyword">int</span> bar() { ... }
    <span class="d_keyword">private</span> <span class="d_keyword">int</span> abc() { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> def() { ... }  <span class="d_comment">// ok, overrides A.def
</span>    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo() { ... }  <span class="d_comment">// error, A.foo is final
</span>    <span class="d_keyword">int</span> bar() { ... }  <span class="d_comment">// ok, A.bar is final private, but not virtual
</span>    <span class="d_keyword">int</span> abc() { ... }  <span class="d_comment">// ok, A.abc is not virtual, B.abc is virtual
</span>}

<span class="d_keyword">void</span> test(A a)
{
    a.def();    <span class="d_comment">// calls B.def
</span>    a.foo();    <span class="d_comment">// calls A.foo
</span>    a.bar();    <span class="d_comment">// calls A.bar
</span>    a.abc();    <span class="d_comment">// calls A.abc
</span>}

<span class="d_keyword">void</span> func()
{
    B b = <span class="d_keyword">new</span> B();
    test(b);
}
</pre>
<div class="blankline"></div>
        <p>Covariant return types
        are supported, which means that the
        overriding function in a derived class can return a type
        that is derived from the type returned by the overridden function:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">class</span> Foo
{
    A test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }
}

<span class="d_keyword">class</span> Bar : Foo
{
    <span class="d_comment">// overrides and is covariant with Foo.test()
</span>    <span class="d_keyword">override</span> B test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }
}
</pre>

</div>
<div class="blankline"></div>
        <p>Virtual functions all have a hidden parameter called the
        <i>this</i> reference, which refers to the class object for which
        the function is called.
        </p>
<div class="blankline"></div>
        <p>            Functions with <span class="d_inlinecode donthyphenate notranslate">Objective-C</span> linkage have an additional hidden,
            unnamed, parameter which is the selector it was called with.
        </p>
<div class="blankline"></div>
        <p>To avoid dynamic binding on member function call, insert
        base class name before the member function name. For example:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">class</span> B
{
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 1; }
}
<span class="d_keyword">class</span> C : B
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 2; }

    <span class="d_keyword">void</span> test()
    {
        <span class="d_keyword">assert</span>(B.foo() == 1);  <span class="d_comment">// translated to this.B.foo(), and
</span>                               <span class="d_comment">// calls B.foo statically.
</span>        <span class="d_keyword">assert</span>(C.foo() == 2);  <span class="d_comment">// calls C.foo statically, even if
</span>                               <span class="d_comment">// the actual instance of 'this' is D.
</span>    }
}
<span class="d_keyword">class</span> D : C
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 3; }
}
<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> d = <span class="d_keyword">new</span> D();
    <span class="d_keyword">assert</span>(d.foo() == 3);    <span class="d_comment">// calls D.foo
</span>    <span class="d_keyword">assert</span>(d.B.foo() == 1);  <span class="d_comment">// calls B.foo
</span>    <span class="d_keyword">assert</span>(d.C.foo() == 2);  <span class="d_comment">// calls C.foo
</span>    d.test();
}
</pre>

</div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function-inheritance" href="#function-inheritance">Function Inheritance and Overriding</a></h3>
<div class="blankline"></div>
        <p>A function in a derived class with the same name and parameter
        types as a function in a base class overrides that function:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo(1);   <span class="d_comment">// calls B.foo(int)
</span>}
</pre>
<div class="blankline"></div>
        <p>However, when doing overload resolution, the functions in the base
        class are not considered:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    b.foo(1);  <span class="d_comment">// calls B.foo(long), since A.foo(int) not considered
</span>    A a = b;

    a.foo(1);  <span class="d_comment">// issues runtime error (instead of calling A.foo(int))
</span>}
</pre>
<div class="blankline"></div>
        <p>To consider the base class's functions in the overload resolution
        process, use an <i>AliasDeclaration</i>:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <b><i><span class="d_keyword">alias</span> foo = A.foo;</i></b>
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo(1);      <span class="d_comment">// calls A.foo(int)
</span>    B b = <span class="d_keyword">new</span> B();
    b.foo(1);      <span class="d_comment">// calls A.foo(int)
</span>}
</pre>
<div class="blankline"></div>
        <p>If such an <i>AliasDeclaration</i> is not used, the derived
        class's functions completely override all the functions of the
        same name in the base class, even if the types of the parameters
        in the base class functions are different. If, through
        implicit conversions to the base class, those other functions do
        get called, a compile-time error will be given:
        </p>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> <b><i>set</i></b>(<span class="d_keyword">long</span> i) { }
    <span class="d_keyword">void</span> set(<span class="d_keyword">int</span> i)  { }
}
<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> set(<span class="d_keyword">long</span> i) { }
}

<span class="d_keyword">void</span> foo(A a)
{
    <span class="d_keyword">int</span> i;
    a.set(3);   <span class="d_comment">// error, use of A.set(int) is hidden by B
</span>                <span class="d_comment">// use 'alias set = A.set;' to introduce base class overload set.
</span>    <span class="d_keyword">assert</span>(i == 1);
}

<span class="d_keyword">void</span> main()
{
    foo(<span class="d_keyword">new</span> B);
}
</pre>
        <p>If an error occurs during the compilation of your program,
        the use of overloads and overrides needs to be reexamined in the
        relevant classes.</p>
<div class="blankline"></div>
        <p>The compiler will not give an error if the hidden function
        is disjoint, as far as overloading is concerned, from all the
        other virtual functions is the inheritance hierarchy.</p>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>A function parameter's default value is not inherited:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> <b><i>foo</i></b>(<span class="d_keyword">int</span> x = 5) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b><i>x = 7</i></b>) { ... }
}

<span class="d_keyword">class</span> C : B
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b><i>x</i></b>) { ... }
}

<span class="d_keyword">void</span> test()
{
    A a = <span class="d_keyword">new</span> A();
    a.foo();       <span class="d_comment">// calls A.foo(5)
</span>
    B b = <span class="d_keyword">new</span> B();
    b.foo();       <span class="d_comment">// calls B.foo(7)
</span>
    C c = <span class="d_keyword">new</span> C();
    c.foo();       <span class="d_comment">// error, need an argument for C.foo
</span>}
</pre>
<div class="blankline"></div>
        <p>If a derived class overrides a base class member function with different
        <a href="#FunctionAttributes"><i>FunctionAttributes</i></a>, the missing attributes will be
        automatically compensated by the compiler.</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">class</span> B
{
    <span class="d_keyword">void</span> foo() <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @safe {}
}
<span class="d_keyword">class</span> D : B
{
    <span class="d_keyword">override</span> <span class="d_keyword">void</span> foo() {}
}
<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> d = <span class="d_keyword">new</span> D();
    <span class="d_keyword">pragma</span>(msg, <span class="d_keyword">typeof</span>(&amp;d.foo));
    <span class="d_comment">// prints "void delegate() pure nothrow @safe" in compile time
</span>}
</pre>

</div>
<div class="blankline"></div>
    <p>It's not allowed to mark an overridden method with the attributes
    <a href="attribute.html#disable"><span class="d_inlinecode donthyphenate notranslate">@disable</span></a> or
    <a href="attribute.html#deprecated"><span class="d_inlinecode donthyphenate notranslate">deprecated</span></a>.
    To stop the compilation or to output the deprecation message, the compiler
    must be able to determine the target of the call, which can't be guaranteed
    when it is virtual.
    </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">class</span> B
{
    <span class="d_keyword">void</span> foo() {}
}

<span class="d_keyword">class</span> D : B
{
    @disable <span class="d_keyword">override</span> <span class="d_keyword">void</span> foo() {}
}

<span class="d_keyword">void</span> main()
{
    B b = <span class="d_keyword">new</span> D;
    b.foo(); <span class="d_comment">// compiles and calls the most derived even if disabled.
</span>}
</pre>

</div>
<div class="blankline"></div>
    <p>Static functions with <span class="d_inlinecode donthyphenate notranslate">Objective-C</span> linkage are overridable.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="inline-functions" href="#inline-functions">Inline Functions</a></h2>
<div class="blankline"></div>
        <p>The compiler makes the decision whether to inline a function or not.
        This decision may be controlled by <a href="pragma.html#inline"><span class="d_inlinecode donthyphenate notranslate">pragma(inline)</span></a>,
        assuming that the compiler implements it, which is not mandatory.</p>
<div class="blankline"></div>
        <p>Note that any <a href="../spec/expression.html#FunctionLiteral"><i>FunctionLiteral</i></a> should be inlined
        when used in its declaration scope.
        </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="function-overloading" href="#function-overloading">Function Overloading</a></h2>
<div class="blankline"></div>
        <p>Functions are overloaded based on how well the arguments
        to a function can match up with the parameters.
        The function with the <i>best</i> match is selected.
        The levels of matching are:
        </p>
<div class="blankline"></div>
        <ol>        <li>no match</li>
        <li>match with implicit conversions</li>
        <li>match with qualifier conversion (if the argument type is
        <a href="http://dlang.org/glossary.html#qualifier-convertible">qualifier-convertible</a> to the parameter type)</li>
        <li>exact match</li>
        </ol>
<div class="blankline"></div>
        <p>Each argument (including any <span class="d_inlinecode donthyphenate notranslate">this</span> pointer) is
        compared against the function's corresponding parameter, to
        determine the match level for that argument. The match level
        for a function is the <i>worst</i> match level of each of its
        arguments.</p>
<div class="blankline"></div>
        <p>Literals do not match <span class="d_inlinecode donthyphenate notranslate">ref</span> or <span class="d_inlinecode donthyphenate notranslate">out</span> parameters.</p>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>If two or more functions have the same match level,
        then <a class="anchor" title="Permalink to this section" id="partial-ordering" href="#partial-ordering"><i>partial ordering</i></a>
        is used to try to find the best match.
        Partial ordering finds the most specialized function.
        If neither function is more specialized than the other,
        then it is an ambiguity error.
        Partial ordering is determined for functions <span class="d_inlinecode donthyphenate notranslate">f()</span>
        and <span class="d_inlinecode donthyphenate notranslate">g()</span> by taking the parameter types of <span class="d_inlinecode donthyphenate notranslate">f()</span>,
        constructing a list of arguments by taking the default values
        of those types, and attempting to match them against <span class="d_inlinecode donthyphenate notranslate">g()</span>.
        If it succeeds, then <span class="d_inlinecode donthyphenate notranslate">g()</span> is at least as specialized
        as <span class="d_inlinecode donthyphenate notranslate">f()</span>.
        For example:
        </p>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }
<span class="d_keyword">class</span> C : B { }
<span class="d_keyword">void</span> foo(A);
<span class="d_keyword">void</span> foo(B);

<span class="d_keyword">void</span> test()
{
    C c;
    <span class="d_comment">/* Both foo(A) and foo(B) match with implicit conversion rules.
     * Applying partial ordering rules,
     * foo(B) cannot be called with an A, and foo(A) can be called
     * with a B. Therefore, foo(B) is more specialized, and is selected.
     */</span>
    foo(c); <span class="d_comment">// calls foo(B)
</span>}
</pre>
        <p>A function with a variadic argument is considered less
        specialized than a function without.
        </p>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>Functions defined with non-D linkage cannot be overloaded.
        This is because the name mangling might not take the parameter types
        into account.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="overload-sets" href="#overload-sets">Overload Sets</a></h3>
<div class="blankline"></div>
        <p>Functions declared at the same scope overload against each
        other, and are called an <i>Overload Set</i>.
        A typical example of an overload set are functions defined
        at module level:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">module</span> A;
<span class="d_keyword">void</span> foo() { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">long</span> i) { }
</pre>

</div>
<div class="blankline"></div>
        <p><span class="d_inlinecode donthyphenate notranslate">A.foo()</span> and <span class="d_inlinecode donthyphenate notranslate">A.foo(long)</span> form an overload set.
        A different module can also define functions with the same name:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">module</span> B;
<span class="d_keyword">class</span> C { }
<span class="d_keyword">void</span> foo(C) { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> i) { }
</pre>

</div>
<div class="blankline"></div>
        <p>and A and B can be imported by a third module, C.
        Both overload sets, the <span class="d_inlinecode donthyphenate notranslate">A.foo</span> overload set and the <span class="d_inlinecode donthyphenate notranslate">B.foo</span>
        overload set, are found. An instance of <span class="d_inlinecode donthyphenate notranslate">foo</span> is selected
        based on it matching in exactly one overload set:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">void</span> bar(C c)
{
    foo();    <span class="d_comment">// calls A.foo()
</span>    foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>    foo(c);   <span class="d_comment">// calls B.foo(C)
</span>    foo(1,2); <span class="d_comment">// error, does not match any foo
</span>    foo(1);   <span class="d_comment">// error, matches A.foo(long) and B.foo(int)
</span>    A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</pre>
<div class="blankline"></div>
        <p>Even though <span class="d_inlinecode donthyphenate notranslate">B.foo(int)</span> is a better match than <span class="d_inlinecode donthyphenate notranslate">        A.foo(long)</span> for <span class="d_inlinecode donthyphenate notranslate">foo(1)</span>,
        it is an error because the two matches are in
        different overload sets.
        </p>
<div class="blankline"></div>
        <p>Overload sets can be merged with an alias declaration:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">alias</span> foo = A.foo;
<span class="d_keyword">alias</span> foo = B.foo;

<span class="d_keyword">void</span> bar(C c)
{
    foo();    <span class="d_comment">// calls A.foo()
</span>    foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>    foo(c);   <span class="d_comment">// calls B.foo(C)
</span>    foo(1,2); <span class="d_comment">// error, does not match any foo
</span>    foo(1);   <span class="d_comment">// calls B.foo(int)
</span>    A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="parameters" href="#parameters">Function Parameters</a></h2>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="param-storage" href="#param-storage">Parameter Storage Classes</a></h3>
<div class="blankline"></div>
        <p>Parameter storage classes are <span class="d_inlinecode donthyphenate notranslate">in</span>, <span class="d_inlinecode donthyphenate notranslate">out</span>,
        <span class="d_inlinecode donthyphenate notranslate">ref</span>, <span class="d_inlinecode donthyphenate notranslate">lazy</span>, <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span>, <span class="d_inlinecode donthyphenate notranslate">shared</span>,
        <span class="d_inlinecode donthyphenate notranslate">inout</span> or
        <span class="d_inlinecode donthyphenate notranslate">scope</span>.
        For example:
        </p>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">in</span> <span class="d_keyword">int</span> x, <span class="d_keyword">out</span> <span class="d_keyword">int</span> y, <span class="d_keyword">ref</span> <span class="d_keyword">int</span> z, <span class="d_keyword">int</span> q);
</pre>
<div class="blankline"></div>
        <p>x is <span class="d_inlinecode donthyphenate notranslate">in</span>, y is <span class="d_inlinecode donthyphenate notranslate">out</span>, z is <span class="d_inlinecode donthyphenate notranslate">ref</span>, and q is none.
        </p>
<div class="blankline"></div>
        <ul>        <li>The function declaration makes it clear what the inputs and
        outputs to the function are.</li>
        <li>It eliminates the need for IDL (interface description language) as a separate language.</li>
        <li>It provides more information to the compiler, enabling more
        error checking and
        possibly better code generation.</li>
        </ul>
<div class="blankline"></div>
    <center><table><caption>Parameter Storage Classes</caption>    <tr><th class="donthyphenate"><b>Storage Class</b></th><th class="donthyphenate"><b>Description</b></th></tr>
    <tr><td><i>none</i></td><td>parameter becomes a mutable copy of its argument</td></tr>
<div class="blankline"></div>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">in</span></td><td>defined as <span class="d_inlinecode donthyphenate notranslate">scope const</span>.  However <span class="d_inlinecode donthyphenate notranslate">in</span> has not yet been properly
    implemented so it's current implementation is equivalent to <span class="d_inlinecode donthyphenate notranslate">const</span>.  It is recommended
    to avoid using <span class="d_inlinecode donthyphenate notranslate">in</span> until it is properly defined and implemented.  Use <span class="d_inlinecode donthyphenate notranslate">scope const</span>
    or <span class="d_inlinecode donthyphenate notranslate">const</span> explicitly instead.</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">out</span></td><td>parameter is initialized upon function entry with the default value
    for its type</td></tr>
<div class="blankline"></div>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">ref</span></td><td>  parameter is passed by reference</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">scope</span></td><td>references in the parameter
    cannot be escaped (e.g. assigned to a global variable).
    Ignored for parameters with no references</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">return</span></td><td>Parameter may be returned or copied to the first parameter,
    but otherwise does not escape from the function.
    Such copies are required not to outlive the argument(s) they were derived from.
    Ignored for parameters with no references.
    See <a href="../spec/memory-safe-d.html#scope-return-params">Scope Parameters</a>.</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">lazy</span></td><td>argument is evaluated by the called function and not by the caller</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">const</span></td><td>argument is implicitly converted to a const type</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable</span></td><td>argument is implicitly converted to an immutable type</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">shared</span></td><td>argument is implicitly converted to a shared type</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">inout</span></td><td>argument is implicitly converted to an inout type</td></tr>
    </table></center>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x)
{
    <span class="d_comment">// x is set to int.init,
</span>    <span class="d_comment">// which is 0, at start of foo()
</span>}

<span class="d_keyword">int</span> a = 3;
foo(a);
<span class="d_comment">// a is now 0
</span>
<span class="d_keyword">void</span> abc(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x)
{
    x = 2;
}

<span class="d_keyword">int</span> y = 3;
abc(y);
<span class="d_comment">// y is now 2
</span>
<span class="d_keyword">void</span> def(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x)
{
    x += 1;
}

<span class="d_keyword">int</span> z = 3;
def(z);
<span class="d_comment">// z is now 4
</span></pre>

</div>
<div class="blankline"></div>
        <p>For dynamic array and object parameters, which are passed
        by reference, in/out/ref
        apply only to the reference and not the contents.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="lazy-params" href="#lazy-params">Lazy Parameters</a></h3>
<div class="blankline"></div>
        <p>An argument to a <span class="d_inlinecode donthyphenate notranslate">lazy</span> parameter is not evaluated before the function is called.
        The argument is only evaluated if/when the parameter is evaluated within the function. Hence,
        a <span class="d_inlinecode donthyphenate notranslate">lazy</span> argument can be executed 0 or more times. </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio : writeln;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> x;
    3.times(writeln(x++));
    writeln(<span class="d_string">"-"</span>);
    writeln(x);
}

<span class="d_keyword">void</span> times(<span class="d_keyword">int</span> n, <span class="d_keyword">lazy</span> <span class="d_keyword">void</span> exp)
{
    <span class="d_keyword">while</span> (n--)
        exp();
}
</pre>

</div>
<div class="blankline"></div>
        <p>prints to the console:</p>
<div class="blankline"></div>
<pre class="console notranslate">0
1
2
&minus;
3
</pre>
<div class="blankline"></div>
        <p>A <span class="d_inlinecode donthyphenate notranslate">lazy</span> parameter cannot be an lvalue.</p>
<div class="blankline"></div>
        <p>The underlying delegate of the <span class="d_inlinecode donthyphenate notranslate">lazy</span> parameter may be extracted
        by using the <span class="d_inlinecode donthyphenate notranslate">&amp;</span> operator:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> test(<span class="d_keyword">lazy</span> <span class="d_keyword">int</span> dg)
{
    <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg_ = &amp;dg;
    <span class="d_keyword">assert</span>(dg_() == 7);
    <span class="d_keyword">assert</span>(dg == dg_());
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> a = 7;
    test(a);
}
</pre>

</div>
<div class="blankline"></div>
        <p>A <span class="d_inlinecode donthyphenate notranslate">lazy</span> parameter of type <span class="d_inlinecode donthyphenate notranslate">void</span> can accept an argument
        of any type.</p>
<div class="blankline"></div>
        <p>See Also: <a href="#lazy_variadic_functions">Lazy Variadic Functions</a></p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function-default-args" href="#function-default-args">Function Default Arguments</a></h3>
<div class="blankline"></div>
        <p>Function parameter declarations can have default values:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y = 3)
{
    ...
}
...
foo(4);   <span class="d_comment">// same as foo(4, 3);
</span></pre>
<div class="blankline"></div>
        <p>Default parameters are resolved and semantically checked in the context of the
        function declaration.</p>
<pre class="d_code notranslate"><span class="d_keyword">module</span> m;
<span class="d_keyword">private</span> <span class="d_keyword">immutable</span> <span class="d_keyword">int</span> b;
<span class="d_keyword">pure</span> <span class="d_keyword">void</span> g(<span class="d_keyword">int</span> a=b){}
</pre>
<pre class="d_code notranslate"><span class="d_keyword">import</span> m;
<span class="d_keyword">int</span> b;
<span class="d_keyword">pure</span> <span class="d_keyword">void</span> f()
{
  g();  <span class="d_comment">// ok, uses m.b
</span>}
</pre>
<div class="blankline"></div>
        <p>The attributes of the <a href="../spec/expression.html#AssignExpression"><i>AssignExpression</i></a> are applied where the default expression
        is used.</p>
<pre class="d_code notranslate"><span class="d_keyword">module</span> m;
<span class="d_keyword">int</span> b;
<span class="d_keyword">pure</span> <span class="d_keyword">void</span> g(<span class="d_keyword">int</span> a=b){}
</pre>
<pre class="d_code notranslate"><span class="d_keyword">import</span> m;
<span class="d_keyword">enum</span> <span class="d_keyword">int</span> b = 3;
<span class="d_keyword">pure</span> <span class="d_keyword">void</span> f()
{
  g();  <span class="d_comment">// error, cannot access mutable global `m.b` in pure function
</span>}
</pre>
<div class="blankline"></div>
        <p>If the default value for a parameter is given, all following
        parameters must also have default values.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="return-ref-parameters" href="#return-ref-parameters">Return Ref Parameters</a></h3>
<div class="blankline"></div>
        <p>Note: The <span class="d_inlinecode donthyphenate notranslate">return</span> attribute is currently only enforced by <span class="d_inlinecode donthyphenate notranslate">dmd</span>
        when the <span class="d_inlinecode donthyphenate notranslate">-dip25</span> switch is passed.
        </p>
<div class="blankline"></div>
        <p>Return ref parameters are used with
        <a href="#ref-functions">ref functions</a> to ensure that the
        returned reference will not outlive the matching argument's lifetime.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">ref</span> <span class="d_keyword">int</span> identity(<span class="d_keyword">return</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) {
  <span class="d_keyword">return</span> x; <span class="d_comment">// pass-through function that does nothing
</span>}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> fun() {
  <span class="d_keyword">int</span> x;
  <span class="d_keyword">return</span> identity(x); <span class="d_comment">// Error: escaping reference to local variable x
</span>}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> gun(<span class="d_keyword">return</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) {
  <span class="d_keyword">return</span> identity(x); <span class="d_comment">// OK
</span>}
</pre>
<div class="blankline"></div>
        <p>Struct non-static methods marked with the <span class="d_inlinecode donthyphenate notranslate">return</span> attribute ensure the returned
        reference will not outlive the struct instance.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">private</span> <span class="d_keyword">int</span> x;
    <span class="d_keyword">ref</span> <span class="d_keyword">int</span> get() <span class="d_keyword">return</span> { <span class="d_keyword">return</span> x; }
}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> escape()
{
    S s;
    <span class="d_keyword">return</span> s.get(); <span class="d_comment">// Error: escaping reference to local variable s
</span>}
</pre>
<div class="blankline"></div>
        <p>Returning the address of a <span class="d_inlinecode donthyphenate notranslate">ref</span> variable is also checked.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>* pluto(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> &amp;i; <span class="d_comment">// error: returning &amp;i escapes a reference to parameter i
</span>}

<span class="d_keyword">int</span>* mars(<span class="d_keyword">return</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> &amp;i;  <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
<p>If the function returns <span class="d_inlinecode donthyphenate notranslate">void</span>, and the first parameter is <span class="d_inlinecode donthyphenate notranslate">ref</span> or <span class="d_inlinecode donthyphenate notranslate">out</span>, then
all subsequent <span class="d_inlinecode donthyphenate notranslate">return ref</span> parameters are considered as being assigned to
the first parameter for lifetime checking.
The <span class="d_inlinecode donthyphenate notranslate">this</span> reference parameter to a struct non-static member function is
considered the first parameter.</p>
<div class="blankline"></div>
<p>If there are multiple <span class="d_inlinecode donthyphenate notranslate">return ref</span> parameters, the lifetime of the return
value is the smallest lifetime of the corresponding arguments.</p>
<div class="blankline"></div>
<p>Neither the type of the <span class="d_inlinecode donthyphenate notranslate">return ref</span> parameter(s) nor the type of the return
value is considered when determining the lifetime of the return value.</p>
<div class="blankline"></div>
<p>It is not an error if the return type does not contain any indirections.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> mercury(<span class="d_keyword">return</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> i; <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
<p>Template functions, auto functions, nested functions and lambdas can deduce the <span class="d_inlinecode donthyphenate notranslate">return</span> attribute.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">ref</span> <span class="d_keyword">int</span> templateFunction()(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> i; <span class="d_comment">// ok
</span>}

<span class="d_keyword">ref</span> <span class="d_keyword">auto</span> autoFunction(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> i; <span class="d_comment">// ok
</span>}

<span class="d_keyword">void</span> uranus()
{
    <span class="d_keyword">ref</span> <span class="d_keyword">int</span> nestedFunction(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
    {
        <span class="d_keyword">return</span> i; <span class="d_comment">// ok
</span>    }
}

<span class="d_keyword">void</span> venus()
{
    <span class="d_keyword">auto</span> lambdaFunction =
        (<span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
        {
            <span class="d_keyword">return</span> &amp;i; <span class="d_comment">// ok
</span>        };
}
</pre>
<div class="blankline"></div>
<p><span class="d_inlinecode donthyphenate notranslate">inout ref</span> parameters imply the <span class="d_inlinecode donthyphenate notranslate">return</span> attribute.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)* neptune(<span class="d_keyword">inout</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> &amp;i;  <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="return-scope-parameters" href="#return-scope-parameters">Return Scope Parameters</a></h3>
<div class="blankline"></div>
        <p>Parameters marked as <span class="d_inlinecode donthyphenate notranslate">return scope</span> that contain indirections
        can only escape those indirections via the function's return value.</p>
<div class="blankline"></div>
<pre class="d_code notranslate">@safe:

<span class="d_keyword">int</span>* gp;
<span class="d_keyword">void</span> thorin(<span class="d_keyword">scope</span> <span class="d_keyword">int</span>*);
<span class="d_keyword">void</span> gloin(<span class="d_keyword">int</span>*);
<span class="d_keyword">int</span>* balin(<span class="d_keyword">return</span> <span class="d_keyword">scope</span> <span class="d_keyword">int</span>* p, <span class="d_keyword">scope</span> <span class="d_keyword">int</span>* q, <span class="d_keyword">int</span>* r)
{
     gp = p; <span class="d_comment">// error, p escapes to global gp
</span>     gp = q; <span class="d_comment">// error, q escapes to global gp
</span>     gp = r; <span class="d_comment">// ok
</span>
     thorin(p); <span class="d_comment">// ok, p does not escape thorin()
</span>     thorin(q); <span class="d_comment">// ok
</span>     thorin(r); <span class="d_comment">// ok
</span>
     gloin(p); <span class="d_comment">// error, gloin() escapes p
</span>     gloin(q); <span class="d_comment">// error, gloin() escapes q
</span>     gloin(r); <span class="d_comment">// ok that gloin() escapes r
</span>
     <span class="d_keyword">return</span> p; <span class="d_comment">// ok
</span>     <span class="d_keyword">return</span> q; <span class="d_comment">// error, cannot return 'scope' q
</span>     <span class="d_keyword">return</span> r; <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
        <p>Class references are considered pointers that are subject to <span class="d_inlinecode donthyphenate notranslate">scope</span>.</p>
<div class="blankline"></div>
<pre class="d_code notranslate">@safe:

<span class="d_keyword">class</span> C { }
C gp;
<span class="d_keyword">void</span> thorin(<span class="d_keyword">scope</span> C);
<span class="d_keyword">void</span> gloin(C);
C balin(<span class="d_keyword">return</span> <span class="d_keyword">scope</span> C p, <span class="d_keyword">scope</span> C q, C r)
{
     gp = p; <span class="d_comment">// error, p escapes to global gp
</span>     gp = q; <span class="d_comment">// error, q escapes to global gp
</span>     gp = r; <span class="d_comment">// ok
</span>
     thorin(p); <span class="d_comment">// ok, p does not escape thorin()
</span>     thorin(q); <span class="d_comment">// ok
</span>     thorin(r); <span class="d_comment">// ok
</span>
     gloin(p); <span class="d_comment">// error, gloin() escapes p
</span>     gloin(q); <span class="d_comment">// error, gloin() escapes q
</span>     gloin(r); <span class="d_comment">// ok that gloin() escapes r
</span>
     <span class="d_keyword">return</span> p; <span class="d_comment">// ok
</span>     <span class="d_keyword">return</span> q; <span class="d_comment">// error, cannot return 'scope' q
</span>     <span class="d_keyword">return</span> r; <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
        <p><span class="d_inlinecode donthyphenate notranslate">return scope</span> can be applied to the <span class="d_inlinecode donthyphenate notranslate">this</span> of class and interface member functions.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C
{
    C bofur() <span class="d_keyword">return</span> <span class="d_keyword">scope</span> { <span class="d_keyword">return</span> <span class="d_keyword">this</span>; }
}
</pre>
<div class="blankline"></div>
        <p>Template functions, auto functions, nested functions and lambdas can deduce
        the <span class="d_inlinecode donthyphenate notranslate">return scope</span> attribute.</p>
<div class="blankline"></div>
        <p><b>Note:</b> Checks for <span class="d_inlinecode donthyphenate notranslate">scope</span> parameters are currently enabled
        only for <span class="d_inlinecode donthyphenate notranslate">@safe</span> functions when compiled with the <span class="d_inlinecode donthyphenate notranslate">-dip1000</span> flag.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="ref-return-scope-parameters" href="#ref-return-scope-parameters">Ref Return Scope Parameters</a></h3>
<div class="blankline"></div>
        <p>Parameters marked as <span class="d_inlinecode donthyphenate notranslate">ref return scope</span> come in two forms:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">U xerxes(<span class="d_keyword">ref</span> <span class="d_keyword">return</span> <span class="d_keyword">scope</span> V v);      <span class="d_comment">// (1) ref and return scope
</span><span class="d_keyword">ref</span> U xerxes(<span class="d_keyword">ref</span> <span class="d_keyword">return</span> <span class="d_keyword">scope</span> V v);  <span class="d_comment">// (2) return ref and scope
</span></pre>
<div class="blankline"></div>
        <p>The first form attaches the <span class="d_inlinecode donthyphenate notranslate">return</span> to the <span class="d_inlinecode donthyphenate notranslate">scope</span>, and has
        <a href="#return-scope-parameters">return scope parameter</a> semantics
        for the value of the <span class="d_inlinecode donthyphenate notranslate">ref</span> parameter.</p>
<div class="blankline"></div>
        <p>The second form attaches the <span class="d_inlinecode donthyphenate notranslate">return</span> to the <span class="d_inlinecode donthyphenate notranslate">ref</span>, and has
        <a href="#return-ref-parameters">return ref parameter</a> semantics
        with additional
        <a href="https://dlang.org/spec/memory-safe-d.html#scope-return-params">scope parameter</a>
        semantics.</p>
<div class="blankline"></div>
        <p>Although a struct constructor returns a reference to the instance
        being constructed, it is treated as form (1).</p>
<div class="blankline"></div>
        <p>The lexical order of the attributes <span class="d_inlinecode donthyphenate notranslate">ref</span>, <span class="d_inlinecode donthyphenate notranslate">return</span>, and <span class="d_inlinecode donthyphenate notranslate">scope</span> is not significant.</p>
<div class="blankline"></div>
        <p>It is not possible to have both <span class="d_inlinecode donthyphenate notranslate">return ref</span> and <span class="d_inlinecode donthyphenate notranslate">return scope</span> semantics
        for the same parameter.</p>
<div class="blankline"></div>
<pre class="d_code notranslate">@safe:

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">this</span>(<span class="d_keyword">return</span> <span class="d_keyword">scope</span>   <span class="d_keyword">ref</span> <span class="d_keyword">int</span>* p) { ptr = p; }

    <span class="d_keyword">int</span>  val;
    <span class="d_keyword">int</span>* ptr;
}

<span class="d_keyword">int</span>* foo1(<span class="d_keyword">return</span> <span class="d_keyword">scope</span>   <span class="d_keyword">ref</span> S s);
<span class="d_keyword">int</span>  foo2(<span class="d_keyword">return</span> <span class="d_keyword">scope</span>   <span class="d_keyword">ref</span> S s);

<span class="d_keyword">ref</span> <span class="d_keyword">int</span>* foo3(<span class="d_keyword">return</span> <span class="d_keyword">ref</span>   <span class="d_keyword">scope</span> S s);
<span class="d_keyword">ref</span> <span class="d_keyword">int</span>  foo4(<span class="d_keyword">return</span> <span class="d_keyword">ref</span>   <span class="d_keyword">scope</span> S s);

<span class="d_keyword">int</span>* test1(<span class="d_keyword">scope</span> S s)
{
    <span class="d_keyword">return</span> foo1(s);  <span class="d_comment">// Error: scope variable `s` may not be returned
</span>    <span class="d_keyword">return</span> foo3(s);  <span class="d_comment">// Error: scope variable `s` may not be returned
</span>}

<span class="d_keyword">int</span> test2(S s)
{
    <span class="d_keyword">return</span> foo2(s);
    <span class="d_keyword">return</span> foo4(s);
}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span>* test3(S s)
{
    <span class="d_keyword">return</span> foo3(s);  <span class="d_comment">// Error: returning `foo3(s)` escapes a reference to parameter `s`
</span>}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> test4(S s)
{
    <span class="d_keyword">return</span> foo4(s);  <span class="d_comment">// Error: returning `foo4(s)` escapes a reference to parameter `s`
</span>}

S test5(<span class="d_keyword">ref</span> <span class="d_keyword">scope</span> <span class="d_keyword">int</span>* p)
{
    <span class="d_keyword">return</span> S(p); <span class="d_comment">// Error: scope variable `p` may not be returned
</span>}

S test6(<span class="d_keyword">ref</span> <span class="d_keyword">return</span> <span class="d_keyword">scope</span> <span class="d_keyword">int</span>* p)
{
    <span class="d_keyword">return</span> S(p);
}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="udas-parameters" href="#udas-parameters">User-Defined Attributes for Parameters</a></h3>
<div class="blankline"></div>
See also: <a href="../spec/attribute.html#UserDefinedAttribute"><i>User-Defined Attributes</i></a>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="variadic" href="#variadic">Variadic Functions</a></h3>
<div class="blankline"></div>
        <p>Functions taking a variable number of arguments are called
        variadic functions. A variadic function can take one of
        three forms:</p>
<div class="blankline"></div>
        <ol>        <li>C-style variadic functions</li>
        <li>Variadic functions with type info</li>
        <li>Typesafe variadic functions</li>
        </ol>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="c_style_cariadic_functions" href="#c_style_cariadic_functions">C-style Variadic Functions</a></h4>
<div class="blankline"></div>
        <p>A C-style variadic function is declared as taking
        a parameter of ... after the required function parameters.
        It has non-D linkage, such as <span class="d_inlinecode donthyphenate notranslate">extern (C)</span>:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C) <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...);

foo(3, 4);      <span class="d_comment">// ok
</span>foo(3, 4, 6.8); <span class="d_comment">// ok, one variadic argument
</span>foo(2);         <span class="d_comment">// error, y is a required argument
</span></pre>
<div class="blankline"></div>
        <p>There must be at least one non-variadic parameter declared.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> def(...); <span class="d_comment">// error, must have at least one parameter
</span></pre>
<div class="blankline"></div>
        <p>        C-style variadic functions match the C calling convention for
        variadic functions, and is most useful for calling C library
        functions like <span class="d_inlinecode donthyphenate notranslate">printf</span>.
    </p>
<div class="blankline"></div>
    <p>C-style variadic functions cannot be marked as <span class="d_inlinecode donthyphenate notranslate">@safe</span>.</p>
<div class="blankline"></div>
    <p>Access to variadic arguments is done using the standard library
    module <span class="d_inlinecode donthyphenate notranslate">core.stdc.stdarg</span>.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.stdc.stdarg;

<span class="d_keyword">void</span> test()
{
    foo(3, 4, 5);   <span class="d_comment">// first variadic argument is 5
</span>}

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{
    va_list args;

    va_start(args, y);  <span class="d_comment">// y is the last named parameter
</span>
    <span class="d_keyword">int</span> z;
    va_arg(args, z);  <span class="d_comment">// z is set to 5
</span>}
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="d_style_variadic_functions" href="#d_style_variadic_functions">D-style Variadic Functions</a></h4>
<div class="blankline"></div>
        <p>Variadic functions with argument and type info are declared as taking
        a parameter of ... after the required function parameters.
        It has D linkage, and need not have any non-variadic parameters
        declared:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">char</span> c, ...);   <span class="d_comment">// one required parameter: c
</span><span class="d_keyword">int</span> def(...);           <span class="d_comment">// ok
</span></pre>

</div>
<div class="blankline"></div>
    <p>To access them, the following import is required:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.vararg;
</pre>
<div class="blankline"></div>
        <p>These variadic functions have a special local variable declared for
        them,
        <span class="d_inlinecode donthyphenate notranslate">_argptr</span>, which is a <span class="d_inlinecode donthyphenate notranslate">core.vararg</span>
    reference to the first of the variadic
        arguments. To access the arguments, <span class="d_inlinecode donthyphenate notranslate">_argptr</span> must be used
    in conjunction with <span class="d_inlinecode donthyphenate notranslate">va_arg</span>:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.vararg;

<span class="d_keyword">void</span> test()
{
    foo(3, 4, 5);   <span class="d_comment">// first variadic argument is 5
</span>}

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{
    <span class="d_keyword">int</span> z;

    z = va_arg!<span class="d_keyword">int</span>(_argptr); <span class="d_comment">// z is set to 5
</span>}
</pre>
<div class="blankline"></div>
        <p>An additional hidden argument
        with the name <span class="d_inlinecode donthyphenate notranslate">_arguments</span> and type <span class="d_inlinecode donthyphenate notranslate">TypeInfo[]</span>
        is passed to the function.
        <span class="d_inlinecode donthyphenate notranslate">_arguments</span> gives the number of arguments and the type
        of each, enabling type safety to be checked at run time.</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> core.vararg;

<span class="d_keyword">class</span> Foo { <span class="d_keyword">int</span> x = 3; }
<span class="d_keyword">class</span> Bar { <span class="d_keyword">long</span> y = 4; }

<span class="d_keyword">void</span> printargs(<span class="d_keyword">int</span> x, ...)
{
    writefln(<span class="d_string">"%d arguments"</span>, _arguments.length);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; _arguments.length; i++)
    {
        writeln(_arguments[i]);

        <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
        {
            <span class="d_keyword">int</span> j = va_arg!(<span class="d_keyword">int</span>)(_argptr);
            writefln(<span class="d_string">"\t%d"</span>, j);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
        {
            <span class="d_keyword">long</span> j = va_arg!(<span class="d_keyword">long</span>)(_argptr);
            writefln(<span class="d_string">"\t%d"</span>, j);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
        {
            <span class="d_keyword">double</span> d = va_arg!(<span class="d_keyword">double</span>)(_argptr);
            writefln(<span class="d_string">"\t%g"</span>, d);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(Foo))
        {
            Foo f = va_arg!(Foo)(_argptr);
            writefln(<span class="d_string">"\t%s"</span>, f);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(Bar))
        {
            Bar b = va_arg!(Bar)(_argptr);
            writefln(<span class="d_string">"\t%s"</span>, b);
        }
        <span class="d_keyword">else</span>
            <span class="d_keyword">assert</span>(0);
    }
}

<span class="d_keyword">void</span> main()
{
    Foo f = <span class="d_keyword">new</span> Foo();
    Bar b = <span class="d_keyword">new</span> Bar();

    writefln(<span class="d_string">"%s"</span>, f);
    printargs(1, 2, 3L, 4.5, f, b);
}
</pre>

</div>
<div class="blankline"></div>
        which prints:
<div class="blankline"></div>
<pre class="d_code notranslate">0x00870FE0
5 arguments
<span class="d_keyword">int</span>
        2
<span class="d_keyword">long</span>
        3
<span class="d_keyword">double</span>
        4.5
Foo
        0x00870FE0
Bar
        0x00870FD0
</pre>
<div class="blankline"></div>
    <p>D-style variadic functions cannot be marked as <span class="d_inlinecode donthyphenate notranslate">@safe</span>.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="typesafe_variadic_functions" href="#typesafe_variadic_functions">Typesafe Variadic Functions</a></h4>
<div class="blankline"></div>
        <p>Typesafe variadic functions are used when the variable argument
        portion of the arguments are used to construct an array or
        class object.</p>
<div class="blankline"></div>
        <p>For arrays:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> main()
{
    <span class="d_keyword">return</span> sum(1, 2, 3) + sum(); <span class="d_comment">// returns 6+0
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">return</span> sum(ii);             <span class="d_comment">// returns 15
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
        s += x;
    <span class="d_keyword">return</span> s;
}
</pre>

</div>
<div class="blankline"></div>
        <p>For static arrays:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> test()
{
    <span class="d_keyword">return</span> sum(2, 3);   <span class="d_comment">// error, need 3 values for array
</span>    <span class="d_keyword">return</span> sum(1, 2, 3); <span class="d_comment">// returns 6
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">int</span>[] jj = ii;
    <span class="d_keyword">return</span> sum(ii); <span class="d_comment">// returns 15
</span>    <span class="d_keyword">return</span> sum(jj); <span class="d_comment">// error, type mismatch
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[3] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
        s += x;
    <span class="d_keyword">return</span> s;
}
</pre>
<div class="blankline"></div>
        <p>For class objects:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">int</span> x;
    string s;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x, string s)
    {
        <span class="d_keyword">this</span>.x = x;
        <span class="d_keyword">this</span>.s = s;
    }
}

<span class="d_keyword">void</span> test(<span class="d_keyword">int</span> x, Foo f ...);

...

Foo g = <span class="d_keyword">new</span> Foo(3, <span class="d_string">"abc"</span>);
test(1, g);         <span class="d_comment">// ok, since g is an instance of Foo
</span>test(1, 4, <span class="d_string">"def"</span>);  <span class="d_comment">// ok
</span>test(1, 5);         <span class="d_comment">// error, no matching constructor for Foo
</span></pre>
<div class="blankline"></div>
        <p>An implementation may construct the object or array instance
        on the stack. Therefore, it is an error to refer to that
        instance after the variadic function has returned:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">Foo test(Foo f ...)
{
    <span class="d_keyword">return</span> f;   <span class="d_comment">// error, f instance contents invalid after return
</span>}

<span class="d_keyword">int</span>[] test(<span class="d_keyword">int</span>[] a ...)
{
    <span class="d_keyword">return</span> a;       <span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a[0..1]; <span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a.dup;   <span class="d_comment">// ok, since copy is made
</span>}
</pre>
<div class="blankline"></div>
        <p>For other types, the argument is built with itself, as in:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> test(<span class="d_keyword">int</span> i ...)
{
    <span class="d_keyword">return</span> i;
}

...
test(3);    <span class="d_comment">// returns 3
</span>test(3, 4); <span class="d_comment">// error, too many arguments
</span><span class="d_keyword">int</span>[] x;
test(x);    <span class="d_comment">// error, type mismatch
</span></pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="lazy_variadic_functions" href="#lazy_variadic_functions">Lazy Variadic Functions</a></h4>
<div class="blankline"></div>
        <p>If the variadic parameter is an array of delegates
        with no parameters:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>()[] dgs ...);
</pre>
<div class="blankline"></div>
        <p>Then each of the arguments whose type does not match that
        of the delegate is converted to a delegate.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
foo(1, 3+x, dg, <span class="d_keyword">cast</span>(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>())<span class="d_keyword">null</span>);
</pre>
<div class="blankline"></div>
        <p>is the same as:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">foo( { <span class="d_keyword">return</span> 1; }, { <span class="d_keyword">return</span> 3+x; }, dg, <span class="d_keyword">null</span> );
</pre>
<div class="blankline"></div>
        <p>The lazy variadic delegate solution is preferable to using a lazy
        variadic array, because each array index would evaluate every element:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> foo(<span class="d_keyword">lazy</span> <span class="d_keyword">int</span>[] arr...)
{
    writeln(arr[0]); <span class="d_comment">// 1
</span>    writeln(arr[1]); <span class="d_comment">// 4, not 2
</span>}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> x;
    foo(++x, ++x);
}
</pre>
<div class="blankline"></div>
<h2><span id="Local Variables"><a class="anchor" title="Permalink to this section" id="local-variables" href="#local-variables">Local Variables</a></span></h2>
<div class="blankline"></div>
        <p>It is an error to use a local variable without first assigning it a
        value. The implementation may not always be able to detect these
        cases. Other language compilers sometimes issue a warning for this,
        but since it is always a bug, it should be an error.
        </p>
<div class="blankline"></div>
        <p>It is an error to declare a local variable that hides another local
        variable in the same function:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> func(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">int</span> x;       <span class="d_comment">// error, hides previous definition of x
</span>    <span class="d_keyword">double</span> y;
    ...
    {
        <span class="d_keyword">char</span> y;  <span class="d_comment">// error, hides previous definition of y
</span>        <span class="d_keyword">int</span> z;
    }
    {
        <span class="d_keyword">wchar</span> z; <span class="d_comment">// legal, previous z is out of scope
</span>    }
}
</pre>
<div class="blankline"></div>
        <p>While this might look unreasonable, in practice whenever
        this is done it either is a
        bug or at least looks like a bug.
        </p>
<div class="blankline"></div>
        <p>It is an error to return the address of or a reference to a
        local variable.
        </p>
<div class="blankline"></div>
        <p>It is an error to have a local variable and a label with the same
        name.
        </p>
<div class="blankline"></div>
<h3><span id="Local Static Variables"><a class="anchor" title="Permalink to this section" id="local-static-variables" href="#local-static-variables">Local Static Variables</a></span></h3>
<div class="blankline"></div>
    <p>Local variables in functions can be declared as static
    or <span class="d_inlinecode donthyphenate notranslate">__gshared</span> in which case they are statically allocated
    rather than being allocated on the stack.
    As such, their value persists beyond the exit of the function.
    </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> n;
    <span class="d_keyword">if</span> (++n == 100)
        writeln(<span class="d_string">"called 100 times"</span>);
}
</pre>

</div>
<div class="blankline"></div>
    <p>The initializer for a static variable must be evaluatable at
    compile time, and they are initialized upon the start of the thread
    (or the start of the program for <span class="d_inlinecode donthyphenate notranslate">__gshared</span>).
    There are no static constructors or static destructors
    for static local variables.
    </p>
<div class="blankline"></div>
    <p>Although static variable name visibility follows the usual scoping
    rules, the names of them must be unique within a particular function.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    { <span class="d_keyword">static</span> <span class="d_keyword">int</span> x; }
    { <span class="d_keyword">static</span> <span class="d_keyword">int</span> x; } <span class="d_comment">// error
</span>    { <span class="d_keyword">int</span> i; }
    { <span class="d_keyword">int</span> i; } <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="nested" href="#nested">Nested Functions</a></h2>
<div class="blankline"></div>
        <p>Functions may be nested within other functions:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> 1; }

        <span class="d_keyword">return</span> b + abc();
    }
    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3); <span class="d_comment">// i is assigned 4
</span>}
</pre>

</div>
<div class="blankline"></div>
        <p>Nested functions can be accessed only if the name is in scope.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">void</span> A()
    {
        B(); <span class="d_comment">// error, B() is forward referenced
</span>        C(); <span class="d_comment">// error, C undefined
</span>    }
    <span class="d_keyword">void</span> B()
    {
        A(); <span class="d_comment">// ok, in scope
</span>        <span class="d_keyword">void</span> C()
        {
            <span class="d_keyword">void</span> D()
            {
                A();      <span class="d_comment">// ok
</span>                B();      <span class="d_comment">// ok
</span>                C();      <span class="d_comment">// ok
</span>                D();      <span class="d_comment">// ok
</span>            }
        }
    }
    A(); <span class="d_comment">// ok
</span>    B(); <span class="d_comment">// ok
</span>    C(); <span class="d_comment">// error, C undefined
</span>}
</pre>
<div class="blankline"></div>
        and:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> b + 1; }
    <span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> foo(b); }   <span class="d_comment">// ok
</span>    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);     <span class="d_comment">// ok
</span>    <span class="d_keyword">int</span> j = bar.foo(3); <span class="d_comment">// error, bar.foo not visible
</span>}
</pre>
<div class="blankline"></div>
        <p>Nested functions have access to the variables and other symbols
        defined by the lexically enclosing function.
        This access includes both the ability to read and write them.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        b += c;       <span class="d_comment">// 4 is added to b
</span>        c++;          <span class="d_comment">// bar.c is now 5
</span>        <span class="d_keyword">return</span> b + c; <span class="d_comment">// 12 is returned
</span>    }
    c = 4;
    <span class="d_keyword">int</span> i = foo(a); <span class="d_comment">// i is set to 12
</span>    <span class="d_keyword">return</span> i + c;   <span class="d_comment">// returns 17
</span>}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3); <span class="d_comment">// i is assigned 17
</span>}
</pre>

</div>
<div class="blankline"></div>
        <p>This access can span multiple nesting levels:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        <span class="d_keyword">int</span> abc()
        {
            <span class="d_keyword">return</span> c;   <span class="d_comment">// access bar.c
</span>        }
        <span class="d_keyword">return</span> b + c + abc();
    }
    <span class="d_keyword">return</span> foo(3);
}
</pre>

</div>
<div class="blankline"></div>
        <p>Static nested functions cannot access any stack variables of
        any lexically enclosing function, but can access static variables.
        This is analogous to how static member functions behave.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> c;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> d;

    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        b = d;          <span class="d_comment">// ok
</span>        b = c;          <span class="d_comment">// error, foo() cannot access frame of bar()
</span>        <span class="d_keyword">return</span> b + 1;
    }
    <span class="d_keyword">return</span> foo(a);
}
</pre>
<div class="blankline"></div>
        <p>Functions can be nested within member functions:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
    <span class="d_keyword">int</span> a;

    <span class="d_keyword">int</span> bar()
    {
        <span class="d_keyword">int</span> c;

        <span class="d_keyword">int</span> foo()
        {
            <span class="d_keyword">return</span> c + a;
        }
        <span class="d_keyword">return</span> 0;
    }
}
</pre>

</div>
<div class="blankline"></div>
        <p>Nested functions always have the D function linkage type.
        </p>
<div class="blankline"></div>
        <p>Unlike module level declarations, declarations within function
        scope are processed in order. This means that two nested functions
        cannot mutually call each other:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> foo() { bar(); } <span class="d_comment">// error, bar not defined
</span>    <span class="d_keyword">void</span> bar() { foo(); } <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
        <p>There are several workarounds for this limitation:</p>
<div class="blankline"></div>
<ul><div class="blankline"></div>
        <li>Declare the functions to be static members of a nested struct:</li>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">struct</span> S
    {
        <span class="d_keyword">static</span> <span class="d_keyword">void</span> foo() { bar(); } <span class="d_comment">// ok
</span>        <span class="d_keyword">static</span> <span class="d_keyword">void</span> bar() { foo(); } <span class="d_comment">// ok
</span>    }

    S.foo();  <span class="d_comment">// compiles (but note the infinite runtime loop)
</span>}
</pre>
<div class="blankline"></div>
        <li>Declare one or more of the functions to be function templates
        even if they take no specific template arguments:</li>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> foo()() { bar(); } <span class="d_comment">// ok (foo is a function template)
</span>    <span class="d_keyword">void</span> bar()   { foo(); } <span class="d_comment">// ok
</span>}
</pre>

</div>
<div class="blankline"></div>
        <li>Declare the functions inside of a mixin template:</li>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">mixin</span> <span class="d_keyword">template</span> T()
{
    <span class="d_keyword">void</span> foo() { bar(); } <span class="d_comment">// ok
</span>    <span class="d_keyword">void</span> bar() { foo(); } <span class="d_comment">// ok
</span>}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">mixin</span> T!();
}
</pre>

</div>
<div class="blankline"></div>
        <li>Use a delegate:</li>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() fp;
    <span class="d_keyword">void</span> foo() { fp(); }
    <span class="d_keyword">void</span> bar() { foo(); }
    fp = &amp;bar;
}
</pre>

</div>
<div class="blankline"></div>
    </ul>
<div class="blankline"></div>
    <p>Nested functions cannot be overloaded.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="closures" href="#closures">Delegates, Function Pointers, and  Closures</a></h2>
<div class="blankline"></div>
        <p>A function pointer can point to a static nested function:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    fp = &amp;foo;
}

<span class="d_keyword">void</span> bar()
{
    test();
    <span class="d_keyword">int</span> i = fp();       <span class="d_comment">// i is set to 10
</span>}
</pre>

</div>
<div class="blankline"></div>
        <p><b>Note:</b> Two functions with identical bodies, or two functions
        that compile to identical assembly code, are not guaranteed to have
        distinct function pointer values. The compiler is free to merge
        functions bodies into one if they compile to identical code.</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x + 1; }
<span class="d_keyword">int</span> def(<span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> y + 1; }

<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span>) fp1 = &amp;abc;
<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span>) fp2 = &amp;def;
<span class="d_comment">// Do not rely on fp1 and fp2 being different values; the compiler may merge
</span><span class="d_comment">// them.
</span></pre>

</div>
<div class="blankline"></div>
        <p>A delegate can be set to a non-static nested function:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    dg = &amp;foo;
    <span class="d_keyword">int</span> i = dg(); <span class="d_comment">// i is set to 10
</span>}
</pre>

</div>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>The stack variables referenced by a nested function are
        still valid even after the function exits (this is different
        from D 1.0). This is called a <i>closure</i>.
        Returning addresses of stack variables, however, is not
        a closure and is an error.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>* bar()
{
    <span class="d_keyword">int</span> b;
    test();
    <span class="d_keyword">int</span> i = dg(); <span class="d_comment">// ok, test.a is in a closure and still exists
</span>    <span class="d_keyword">return</span> &amp;b;    <span class="d_comment">// error, bar.b not valid after bar() exits
</span>}
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>Delegates to non-static nested functions contain two pieces of
        data: the pointer to the stack frame of the lexically enclosing
        function (called the <i>frame pointer</i>) and the address of the
        function. This is analogous to struct/class non-static member
        function delegates consisting of a <i>this</i> pointer and
        the address of the member function.
        Both forms of delegates are interchangeable, and are actually
        the same type:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
    <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> a; }
}

<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg)
{
    <span class="d_keyword">return</span> dg() + 1;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> x = 27;
    <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> x; }
    Foo f;
    <span class="d_keyword">int</span> i;

    i = foo(&amp;abc);   <span class="d_comment">// i is set to 28
</span>    i = foo(&amp;f.bar); <span class="d_comment">// i is set to 8
</span>}
</pre>

</div>
<div class="blankline"></div>
        <p>This combining of the environment and the function is called
        a <i>dynamic closure</i>.
        </p>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">.ptr</span> property of a delegate will return the
        <i>frame pointer</i> value as a <span class="d_inlinecode donthyphenate notranslate">void*</span>.
        </p>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">.funcptr</span> property of a delegate will return the
        <i>function pointer</i> value as a function type.
        </p>
        <p>Functions and delegates declared at module scope are zero-initialized by default.
        However both can be initialized to any function pointer (including a function literal).
        For delegates, the context pointer <span class="d_inlinecode donthyphenate notranslate">.ptr</span> is initialized to null.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>() foo = { <span class="d_keyword">return</span> 42; };
<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() bar = { <span class="d_keyword">return</span> 43; };
<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() baz;
<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">assert</span>(foo() == 42);
    <span class="d_keyword">assert</span>(bar() == 43);
    <span class="d_keyword">assert</span>(baz <span class="d_keyword">is</span> <span class="d_keyword">null</span>);
}
</pre>

</div>
<div class="blankline"></div>
        <p>Function pointers can be passed to functions taking a delegate argument by passing
        them through the <a href="../phobos/std_functional.html#.toDelegate"><span class="d_inlinecode donthyphenate notranslate">std.functional.toDelegate</span></a> template, which converts any callable
        to a delegate without context.
        </p>
<div class="blankline"></div>
        <p><b>Future directions:</b> Function pointers and delegates may merge
        into a common syntax and be interchangeable with each other.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="anonymous" href="#anonymous">Anonymous Functions and Anonymous Delegates</a></h3>
<div class="blankline"></div>
        <p>See <a href="../spec/expression.html#FunctionLiteral"><i>FunctionLiteral</i></a>s.
        </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="main" href="#main"><span class="d_inlinecode donthyphenate notranslate">main()</span> Function</a></h2>
<div class="blankline"></div>
        <p>For console programs, <span class="d_inlinecode donthyphenate notranslate">main()</span> serves as the entry point.
        It gets called after all the module initializers are run, and
        after any unittests are run.
        After it returns, all the module destructors are run.
        <span class="d_inlinecode donthyphenate notranslate">main()</span> must be declared using one of the following forms:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main() { ... }
<span class="d_keyword">void</span> main(string[] args) { ... }
<span class="d_keyword">int</span> main() { ... }
<span class="d_keyword">int</span> main(string[] args) { ... }
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="function-templates" href="#function-templates">Function Templates</a></h2>
<div class="blankline"></div>
    <p>Template functions are useful for avoiding code duplication -
    instead of writing several copies of a function, each with a
    different parameter type, a single function template can be sufficient.
    For example:
    </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_comment">// Only one copy of func needs to be written
</span><span class="d_keyword">void</span> func(T)(T x)
{
    writeln(x);
}
<span class="d_keyword">void</span> main()
{
    func!(<span class="d_keyword">int</span>)(1); <span class="d_comment">// pass an int
</span>    func(1);    <span class="d_comment">// pass an int, inferring T = int
</span>    func(<span class="d_string">"x"</span>);  <span class="d_comment">// pass a string
</span>    func(1.0);  <span class="d_comment">// pass a float
</span>    <span class="d_keyword">struct</span> S {}
    S s;
    func(s);    <span class="d_comment">// pass a struct
</span>}
</pre>

</div>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">func</span> takes a template parameter <span class="d_inlinecode donthyphenate notranslate">T</span> and a runtime
    parameter, <span class="d_inlinecode donthyphenate notranslate">x</span>. <span class="d_inlinecode donthyphenate notranslate">T</span> is a placeholder identifier that can accept
    any type. In this case <span class="d_inlinecode donthyphenate notranslate">T</span> can be inferred from the runtime argument
    type.</p>
<div class="blankline"></div>
    <p><b>Note:</b> Using the name <span class="d_inlinecode donthyphenate notranslate">T</span> is just a convention. The name
    <span class="d_inlinecode donthyphenate notranslate">TypeOfX</span> could have been used instead.</p>
<div class="blankline"></div>
    <p>For more information, see
    <a href="../spec/template.html#function-templates">function templates</a>.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="interpretation" href="#interpretation">Compile Time Function Execution (CTFE)</a></h2>
<div class="blankline"></div>
    <p>Functions which are both portable and free of global side-effects can be
    executed at compile time. In certain contexts, such compile time execution
    is guaranteed. It is called Compile Time Function Execution (CTFE) then.
    The contexts that trigger CTFE are:</p>
<div class="blankline"></div>
    <ul>    <li>initialization of a static variable or a
        <a href="../spec/enum.html#manifest_constants">manifest constant</a></li>
    <li>static initializers of struct/class members</li>
    <li>dimension of a <a href="../spec/arrays.html#static-arrays">static array</a></li>
    <li>argument for a <a href="../spec/template.html#template_value_parameter">        template value parameter</a></li>
    <li><a href="../spec/version.html#staticif"><span class="d_inlinecode donthyphenate notranslate">static if</span></a></li>
    <li><a href="../spec/version.html#staticforeach"><span class="d_inlinecode donthyphenate notranslate">static foreach</span></a></li>
    <li><a href="../spec/version.html#static-assert"><span class="d_inlinecode donthyphenate notranslate">static assert</span></a></li>
    <li><a href="../spec/statement.html#mixin-statement">        <span class="d_inlinecode donthyphenate notranslate">mixin</span> statement</a></li>
    <li><a href="../spec/pragma.html"><span class="d_inlinecode donthyphenate notranslate">pragma</span> argument</a></li>
    </ul>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">enum</span> eval(Args...) = Args[0];

<span class="d_keyword">int</span> square(<span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> i * i;
}

<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> j = square(3);      <span class="d_comment">// CTFE
</span>    writeln(j);
    <span class="d_keyword">assert</span>(square(4));         <span class="d_comment">// run time
</span>    writeln(eval!(square(5))); <span class="d_comment">// CTFE
</span>}
</pre>

</div>
<div class="blankline"></div>
    <p>CTFE is subject to the following restrictions:</p>
<div class="blankline"></div>
    <ol>    <li>The function source code must be available to the compiler. Functions
        which exist in the source code only as <span class="d_keyword">extern</span> declarations
        cannot be executed in CTFE.</li>
<div class="blankline"></div>
    <li>Executed expressions may not reference any global or local
        static variables.</li>
<div class="blankline"></div>
    <li><span class="d_keyword">asm</span> statements are not permitted</li>
<div class="blankline"></div>
    <li>Non-portable casts (eg, from <span class="d_inlinecode donthyphenate notranslate">int[]</span> to <span class="d_inlinecode donthyphenate notranslate">float[]</span>), including
        casts which depend on endianness, are not permitted.
        Casts between signed and unsigned types are permitted</li>
    <li>Reinterpretation of overlapped fields in a Union is not permitted.</li>
    </ol>
<div class="blankline"></div>
    <p>Pointers are permitted in CTFE, provided they are used safely:</p>
<div class="blankline"></div>
    <ul>        <li>        C-style semantics on pointer arithmetic are strictly enforced.
        Pointer arithmetic is permitted only on pointers which point to static
        or dynamic array elements. Such pointers must point to an element of
        the array, or to the first element past the array.
        Pointer arithmetic is completely forbidden on pointers which are null,
        or which point to a non-array.
        </li>
<div class="blankline"></div>
        <li>        The memory location of different memory blocks is not defined.
        Ordered comparison (<span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;=</span>) between two pointers is permitted
        when both pointers point to the same array, or when at least one
        pointer is <span class="d_inlinecode donthyphenate notranslate">null</span>.
        </li>
<div class="blankline"></div>
        <li>        Pointer comparisons between independent memory blocks will generate
        a compile-time error, unless two such comparisons are combined
        using <span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> or <span class="d_inlinecode donthyphenate notranslate">|</span><span class="d_inlinecode donthyphenate notranslate">|</span> to yield a result which is independent of the
        ordering of memory blocks. Each comparison must consist of two pointer
        expressions compared with <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span>,
        or <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, and may optionally be
        negated with <span class="d_inlinecode donthyphenate notranslate">!</span>.
<div class="blankline"></div>
        <p>        For example, the expression <span class="d_inlinecode donthyphenate notranslate">(p1 &gt; q1 &amp;&amp; p2 &lt;= q2)</span>
        is permitted when <span class="d_inlinecode donthyphenate notranslate">p1</span>, <span class="d_inlinecode donthyphenate notranslate">p2</span> are expressions yielding pointers
        to memory block <i>P</i>, and <span class="d_inlinecode donthyphenate notranslate">q1</span>, <span class="d_inlinecode donthyphenate notranslate">q2</span> are expressions yielding
        pointers to memory block <i>Q</i>, even when <i>P</i> and <i>Q</i> are
        unrelated memory blocks.
        It returns true if <span class="d_inlinecode donthyphenate notranslate">[p1..p2]</span> lies inside <span class="d_inlinecode donthyphenate notranslate">[q1..q2]</span>, and false otherwise.
        Similarly, the expression <span class="d_inlinecode donthyphenate notranslate">(p1 &lt; q1 || p2 &gt; q2)</span> is true if
        <span class="d_inlinecode donthyphenate notranslate">[p1..p2]</span> lies outside <span class="d_inlinecode donthyphenate notranslate">[q1..q2]</span>, and false otherwise.
        </p>
        </li>
<div class="blankline"></div>
        <li>        Equality comparisons (==, !=, <span class="d_keyword">is</span>, <span class="d_keyword">!is</span>) are
        permitted between all pointers, without restriction.
        </li>
<div class="blankline"></div>
        <li>        Any pointer may be cast to <span class="d_inlinecode donthyphenate notranslate">void*</span> and from <span class="d_inlinecode donthyphenate notranslate">void*</span> back to
        its original type. Casting between pointer and non-pointer types is
        prohibited.
        </li>
    </ul>
<div class="blankline"></div>
    <p>Note that the above restrictions apply only to expressions which are
        actually executed. For example:
    </p>
<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">int</span> y = 0;

<span class="d_keyword">int</span> countTen(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">if</span> (x &gt; 10)
        ++y;
    <span class="d_keyword">return</span> x;
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(countTen(6) == 6);    <span class="d_comment">// OK
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(countTen(12) == 12);  <span class="d_comment">// invalid, modifies y.
</span></pre>
    <p>The <span class="d_inlinecode donthyphenate notranslate">__ctfe</span> boolean pseudo-variable, which evaluates to <span class="d_keyword">true</span>
        in CTFE, but <span class="d_keyword">false</span> otherwise, can be used to provide
        an alternative execution path to avoid operations which are forbidden
        in CTFE. Every usage of <span class="d_inlinecode donthyphenate notranslate">__ctfe</span> is evaluated before
        code generation and therefore has no run-time cost, even if no optimizer
        is used.
    </p>
<div class="blankline"></div>
    <p>Executing functions via CTFE can take considerably
    longer than executing it at run time.
    If the function goes into an infinite loop, it will hang at
    compile time (rather than hanging at run time).
    </p>
<div class="blankline"></div>
    <p>Non-recoverable errors (such as <span class="d_keyword">assert</span> failures) do not
    throw exceptions; instead, they end interpretation immediately.
    </p>
<div class="blankline"></div>
    <p>Functions executed via CTFE can give different results
    from run time in the following scenarios:
    </p>
<div class="blankline"></div>
    <ul><div class="blankline"></div>
    <li>floating point computations may be done at a higher
    precision than run time</li>
    <li>dependency on implementation defined order of evaluation</li>
    <li>use of uninitialized variables</li>
<div class="blankline"></div>
    </ul>
<div class="blankline"></div>
    <p>These are the same kinds of scenarios where different
    optimization settings affect the results.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="string-mixins" href="#string-mixins">String Mixins and Compile Time Function Execution</a></h3>
<div class="blankline"></div>
        <p>Any functions that execute in CTFE must also
        be executable at run time. The compile time evaluation of
        a function does the equivalent of running the function at
        run time. This means that the semantics of a function cannot
        depend on compile time values of the function. For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo(string s)
{
    <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(s);
}

<span class="d_keyword">const</span> <span class="d_keyword">int</span> x = foo(<span class="d_string">"1"</span>);
</pre>
<div class="blankline"></div>
        
        is illegal, because the runtime code for <span class="d_inlinecode donthyphenate notranslate">foo</span> cannot be
        generated. A function template would be the appropriate
        method to implement this sort of thing.
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="nogc-functions" href="#nogc-functions">No-GC Functions</a></h2>
<div class="blankline"></div>
        <p>No-GC functions are functions marked with the <span class="d_inlinecode donthyphenate notranslate">@nogc</span> attribute.
            Those functions do not allocate memory on the GC heap,
            through the following language features:
        </p>
<div class="blankline"></div>
        <ul>        <li><a href="../expression.html#ArrayLiteral">constructing an array</a> on the heap</li>
        <li>resizing an array by writing to its <span class="d_inlinecode donthyphenate notranslate">.length</span> property</li>
        <li>array <a href="../expression.html#CatExpression">concatenation</a> and appending</li>
        <li><a href="../expression.html#AssocArrayLiteral">constructing an associative array</a> on the heap</li>
        <li><a href="../expression.html#IndexExpression">indexing</a> an associative array
            (because it may throw <span class="d_inlinecode donthyphenate notranslate">RangeError</span> if the specified key is not present)</li>
        <li><a href="../expression.html#NewExpression">allocating an object</a> on the heap</li>
        </ul>
<div class="blankline"></div>
<pre class="d_code notranslate">@nogc <span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">auto</span> a = ['a'];    <span class="d_comment">// error, allocates
</span>    a.length = 1;      <span class="d_comment">// error, array resizing allocates
</span>    a = a ~ a;         <span class="d_comment">// error, arrays concatenation allocates
</span>    a ~= 'c';          <span class="d_comment">// error, appending to arrays allocates
</span>
    <span class="d_keyword">auto</span> aa = [<span class="d_string">"x"</span>:1]; <span class="d_comment">// error, allocates
</span>    aa[<span class="d_string">"abc"</span>];         <span class="d_comment">// error, indexing may allocate and throws
</span>
    <span class="d_keyword">auto</span> p = <span class="d_keyword">new</span> <span class="d_keyword">int</span>;  <span class="d_comment">// error, operator new allocates
</span>}
</pre>
<div class="blankline"></div>
        <p>No-GC functions cannot call functions that are not <span class="d_inlinecode donthyphenate notranslate">@nogc</span>.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate">@nogc <span class="d_keyword">void</span> foo()
{
    bar();             <span class="d_comment">// error, bar() may allocate
</span>}

<span class="d_keyword">void</span> bar() { }
</pre>
<div class="blankline"></div>
        <p>No-GC functions cannot be closures.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate">@nogc <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() foo()
{
    <span class="d_keyword">int</span> n;              <span class="d_comment">// error, variable n cannot be allocated on heap
</span>    <span class="d_keyword">return</span> (){ <span class="d_keyword">return</span> n; }
}
</pre>
<div class="blankline"></div>
        <p><span class="d_inlinecode donthyphenate notranslate">@nogc</span> affects the type of the function. A <span class="d_inlinecode donthyphenate notranslate">@nogc</span>
            function is covariant with a non-<span class="d_inlinecode donthyphenate notranslate">@nogc</span> function.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> <span class="d_keyword">function</span>() fp;
<span class="d_keyword">void</span> <span class="d_keyword">function</span>() @nogc gp;  <span class="d_comment">// pointer to @nogc function
</span>
<span class="d_keyword">void</span> foo();
@nogc <span class="d_keyword">void</span> bar();

<span class="d_keyword">void</span> test()
{
    fp = &amp;foo; <span class="d_comment">// ok
</span>    fp = &amp;bar; <span class="d_comment">// ok, it's covariant
</span>    gp = &amp;foo; <span class="d_comment">// error, not contravariant
</span>    gp = &amp;bar; <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
        <p>To ease debugging,
            in a <a href="../spec/version.html#ConditionalStatement"><i>ConditionalStatement</i></a>
            controlled by a <a href="../spec/version.html#DebugCondition"><i>DebugCondition</i></a>
            <span class="d_inlinecode donthyphenate notranslate">@nogc</span> functions can call functions that are not <span class="d_inlinecode donthyphenate notranslate">@nogc</span>.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="function-safety" href="#function-safety">Function Safety</a></h2>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="safe-functions" href="#safe-functions">Safe Functions</a></h3>
<div class="blankline"></div>
        <p>Safe functions are marked with the <span class="d_inlinecode donthyphenate notranslate">@safe</span> attribute.</p>
<div class="blankline"></div>
        <p>Safe functions have <a href="#safe-interfaces">safe
        interfaces</a>. An implementation must enforce this by restricting the
        function's body to operations that are known safe.</p>
<div class="blankline"></div>
        <p>The following operations are not allowed in safe
        functions:</p>
<div class="blankline"></div>
        <ul>        <li>No casting from a pointer type to any type with pointers other than <span class="d_inlinecode donthyphenate notranslate">void*</span>.</li>
        <li>No casting from any non-pointer type to a pointer type.</li>
        <li>No pointer arithmetic (including pointer indexing).</li>
        <li>Cannot access unions that have pointers or references overlapping
        with other types.</li>
        <li>Calling any system functions.</li>
        <li>No catching of exceptions that are not derived from <span class="d_inlinecode donthyphenate notranslate">class Exception</span>.</li>
        <li>Disallow <span class="d_inlinecode donthyphenate notranslate">@system</span> asm statements.</li>
        <li>No explicit casting of mutable objects to immutable.</li>
        <li>No explicit casting of immutable objects to mutable.</li>
        <li>No explicit casting of thread local objects to shared.</li>
        <li>No explicit casting of shared objects to thread local.</li>
        <li>No taking the address of a local variable or function parameter.</li>
        <li>Cannot access <span class="d_inlinecode donthyphenate notranslate">__gshared</span> variables.</li>
        <li>Cannot use <span class="d_inlinecode donthyphenate notranslate">void</span> initializers for pointers.</li>
        <li>Cannot use <span class="d_inlinecode donthyphenate notranslate">void</span> initializers for class or interface references.</li>
        </ul>
<div class="blankline"></div>
        <p>When indexing and slicing an array, an out of bounds access
            will cause a runtime error, in order to prevent undefined behavior.
        </p>
<div class="blankline"></div>
        <p>Functions nested inside safe functions default to being
        safe functions.
        </p>
<div class="blankline"></div>
        <p>Safe functions are covariant with trusted or system functions.</p>
<div class="blankline"></div>
        <p><b>Note:</b> The verifiable safety of functions may be compromised by
        bugs in the compiler and specification. Please report all such errors
        so they can be corrected.
        </p>
<div class="blankline"></div>
<h4>Safe External Functions</h4>
<div class="blankline"></div>
        <p>External functions don't have a function body visible to the compiler:
        </p>
<pre class="d_code notranslate">@safe <span class="d_keyword">extern</span> (C) <span class="d_keyword">void</span> play();
</pre>
        and so safety cannot be verified automatically.
<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b> Explicitly set an attribute for external functions rather
        than relying on default settings.</div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="trusted-functions" href="#trusted-functions">Trusted Functions</a></h3>
<div class="blankline"></div>
        <p>Trusted functions are marked with the <span class="d_inlinecode donthyphenate notranslate">@trusted</span> attribute.</p>
<div class="blankline"></div>
        <p>Like <a href="#safe-functions">safe functions</a>, trusted
        functions have <a href="#safe-interfaces">safe interfaces</a>.
        Unlike safe functions, this is not enforced by restrictions on the
        function body. Instead, it is the responsibility of the programmer to
        ensure that the interface of a trusted function is safe.</p>
<div class="blankline"></div>
        <p>Example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)* f(<span class="d_keyword">int</span>* p) @trusted
{
    <span class="d_keyword">version</span> (none) p[2] = 13;
    <span class="d_comment">// Invalid. p[2] is out of bounds. This line would exhibit undefined
</span>    <span class="d_comment">// behavior.
</span>
    <span class="d_keyword">version</span> (none) p[1] = 13;
    <span class="d_comment">// Invalid. In this program, p[1] happens to be in-bounds, so the
</span>    <span class="d_comment">// line would not exhibit undefined behavior, but a trusted function
</span>    <span class="d_comment">// is not allowed to rely on this.
</span>
    <span class="d_keyword">version</span> (none) <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span>) p;
    <span class="d_comment">// Invalid. @safe code still has mutable access and could trigger
</span>    <span class="d_comment">// undefined behavior by overwriting the value later on.
</span>
    <span class="d_keyword">int</span>* p2 = <span class="d_keyword">new</span> <span class="d_keyword">int</span>;
    *p2 = 42;
    <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span>) p2;
    <span class="d_comment">// Valid. After f returns, no mutable aliases of p2 can exist.
</span>}

<span class="d_keyword">void</span> main() @safe
{
    <span class="d_keyword">int</span>[2] a = [10, 20];
    <span class="d_keyword">int</span>* mp = &amp;a[0];
    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)* ip = f(mp);
    <span class="d_keyword">assert</span>(a[1] == 20); <span class="d_comment">// Guaranteed. f cannot access a[1].
</span>    <span class="d_keyword">assert</span>(ip !<span class="d_keyword">is</span> mp); <span class="d_comment">// Guaranteed. f cannot introduce unsafe aliasing.
</span>}
</pre>
<div class="blankline"></div>
        <p>Trusted functions may call safe, trusted, or system functions.
        </p>
<div class="blankline"></div>
        <p>Trusted functions are covariant with safe or system functions.</p>
<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b> Trusted functions should be kept small so
        that they are easier to manually verify.
        </div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="system-functions" href="#system-functions">System Functions</a></h3>
<div class="blankline"></div>
        <p>System functions are functions not marked with <span class="d_inlinecode donthyphenate notranslate">@safe</span> or
        <span class="d_inlinecode donthyphenate notranslate">@trusted</span>
        and are not nested inside <span class="d_inlinecode donthyphenate notranslate">@safe</span> functions.
        System functions may be marked with the <span class="d_inlinecode donthyphenate notranslate">@system</span> attribute.
        A function being system does not mean it actually is unsafe, it just
        means that the compiler is unable to verify that it cannot exhibit
        undefined behavior.
        </p>
<div class="blankline"></div>
        <p>System functions are <b>not</b> covariant with trusted or safe functions.
        </p>
<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b> When in doubt, mark <span class="d_inlinecode donthyphenate notranslate">extern (C)</span> and <span class="d_inlinecode donthyphenate notranslate">extern (C++)</span> functions as
        <span class="d_inlinecode donthyphenate notranslate">@system</span> when their implementations are not in D, as the D compiler will be
        unable to check them. Most of them are <span class="d_inlinecode donthyphenate notranslate">@safe</span>, but will need to be manually
        checked.</div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="safe-interfaces" href="#safe-interfaces">Safe Interfaces</a></h3>
<div class="blankline"></div>
        <p>Given that it is only called with <a href="#safe-values">safe
        values</a> and <a href="#safe-aliasing">safe aliasing</a>, a
        function has a safe interface when:</p>
        <ol>            <li>it cannot possibly exhibit
                <a href="../glossary.html#undefined_behavior">undefined behavior</a>,
                and</li>
            <li>it cannot create unsafe values that are accessible from other
                parts of the program (e.g., via return values, global variables,
                or <span class="d_inlinecode donthyphenate notranslate">ref</span> parameters), and</li>
            <li>it cannot introduce unsafe aliasing that is accessible from
                other parts of the program.</li>
        </ol>
<div class="blankline"></div>
        <p>Functions that meet these requirements may be
        <a href="#safe-functions"><span class="d_inlinecode donthyphenate notranslate">@safe</span></a> or
        <a href="#trusted-functions"><span class="d_inlinecode donthyphenate notranslate">@trusted</span></a>. Function that do not
        meet these requirements can only be
        <a href="#system-functions"><span class="d_inlinecode donthyphenate notranslate">@system</span></a>.</p>
<div class="blankline"></div>
        <p>Examples:</p>
<div class="blankline"></div>
        <ul>            <li>                C's <span class="d_inlinecode donthyphenate notranslate">free</span> does not have a safe interface:
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C) @system <span class="d_keyword">void</span> free(<span class="d_keyword">void</span>* ptr);
</pre>
                because <span class="d_inlinecode donthyphenate notranslate">free(p)</span> invalidates <span class="d_inlinecode donthyphenate notranslate">p</span>, making its value unsafe.
                <span class="d_inlinecode donthyphenate notranslate">free</span> can only be <span class="d_inlinecode donthyphenate notranslate">@system</span>.
            </li>
            <li>                C's <span class="d_inlinecode donthyphenate notranslate">strlen</span> and <span class="d_inlinecode donthyphenate notranslate">memcpy</span> do not have safe interfaces:
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C) @system size_t strlen(<span class="d_keyword">char</span>* s);
<span class="d_keyword">extern</span> (C) @system <span class="d_keyword">void</span>* memcpy(<span class="d_keyword">void</span>* dst, <span class="d_keyword">void</span>* src, size_t nbytes);
</pre>
                because they iterate pointers based on unverified assumptions
                (<span class="d_inlinecode donthyphenate notranslate">strlen</span> assumes that <span class="d_inlinecode donthyphenate notranslate">s</span> is zero-terminated; <span class="d_inlinecode donthyphenate notranslate">memcpy</span> assumes
                that <span class="d_inlinecode donthyphenate notranslate">dst</span> and <span class="d_inlinecode donthyphenate notranslate">src</span> are at least <span class="d_inlinecode donthyphenate notranslate">nbytes</span> long). Any function
                that traverses a C string passed as an argument can only be
                <span class="d_inlinecode donthyphenate notranslate">@system</span>. Any function that trusts a seperate parameter for
                array bounds can only be <span class="d_inlinecode donthyphenate notranslate">@system</span>.
            </li>
            <li>                C's <span class="d_inlinecode donthyphenate notranslate">malloc</span> does have a safe interface:
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C) @trusted <span class="d_keyword">void</span>* malloc(size_t sz);
</pre>
                It does not exhibit undefined behavior for any input. It returns
                either a valid pointer, which is safe, or <span class="d_inlinecode donthyphenate notranslate">null</span> which is also
                safe. It returns a pointer to a fresh allocation, so it cannot
                introduce any unsafe aliasing.
            </li>
            <li>                A D version of <span class="d_inlinecode donthyphenate notranslate">memcpy</span> can have a safe interface:
                <div class="runnable-examples">
<pre class="d_code notranslate">@safe <span class="d_keyword">void</span> memcpy(E)(E[] src, E[] dst)
{
    <span class="d_keyword">import</span> std.math : min;
    <span class="d_keyword">foreach</span> (i; 0 .. min(src.length, dst.length))
    {
        dst[i] = src[i];
    }
}
</pre>
                
</div>
                because the rules for safe <a href="#safe-values">safe
                values</a> ensure that the lengths of the arrays are correct.
            </li>
        </ul>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="safe-values" href="#safe-values">Safe Values</a></h3>
<div class="blankline"></div>
        <p>For <a href="../spec/type.html#basic-data-types">basic data types</a>, all
        possible bit patterns are safe.</p>
<div class="blankline"></div>
        <p>A pointer is safe when:</p>
        <ol>            <li>it can be dereferenced validly, and</li>
            <li>the value of the pointee is safe.</li>
        </ol>
        <p>Examples:</p>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>* n = <span class="d_keyword">null</span>; <span class="d_comment">/* n is safe because dereferencing null is a well-defined
    crash. */</span>
<span class="d_keyword">int</span>* x = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*) 0xDEADBEEF; <span class="d_comment">/* x is (most likely) unsafe because it
    is not a valid pointer and cannot be dereferenced. */</span>

<span class="d_keyword">import</span> core.stdc.stdlib: malloc, free;
<span class="d_keyword">int</span>* p1 = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*) malloc(<span class="d_keyword">int</span>.sizeof); <span class="d_comment">/* p1 is safe because the
    pointer is valid and *p1 is safe regardless of its actual value. */</span>
free(p1); <span class="d_comment">/* This makes p1 unsafe. */</span>
<span class="d_keyword">int</span>** p2 = &amp;p1; <span class="d_comment">/* While it can be dereferenced, p2 is unsafe because p1
    is unsafe. */</span>
p1 = <span class="d_keyword">null</span>; <span class="d_comment">/* This makes p1 and p2 safe. */</span>
</pre>
        
</div>
<div class="blankline"></div>
        <p>A dynamic array is safe when:</p>
        <ol>            <li>its pointer is safe, and</li>
            <li>its length is in-bounds with the corresponding memory object,
            and</li>
            <li>all its elements are safe.</li>
        </ol>
<div class="blankline"></div>
        <p>Examples:</p>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] f() @system
{
    <span class="d_keyword">int</span>[3] a;
    <span class="d_keyword">int</span>[] d1 = a[0 .. 2]; <span class="d_comment">/* d1 is safe. */</span>
    <span class="d_keyword">int</span>[] d2 = a.ptr[0 .. 3]; <span class="d_comment">/* d2 is unsafe because it goes beyond a's
        bounds. */</span>
    <span class="d_keyword">int</span>*[] d3 = [<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*) 0xDEADBEEF]; <span class="d_comment">/* d3 is unsafe because the
        element is unsafe. */</span>
    <span class="d_keyword">return</span> d1; <span class="d_comment">/* Up to here, d1 was safe, but its pointer becomes
        invalid when the function returns, so the returned dynamic array
        is unsafe. */</span>
}
</pre>
        
</div>
<div class="blankline"></div>
        <p>A static array is safe when all its elements are safe. Regardless
        of the element type, a static array with length zero is always safe.</p>
<div class="blankline"></div>
        <p>An associative array is safe when all its keys and elements are
        safe.</p>
<div class="blankline"></div>
        <p>A struct/union instance is safe when:</p>
        <ol>            <li>the values of its accessible fields are safe, and</li>
            <li>it does not introduce <a href="#safe-aliasing">unsafe
            aliasing</a> with unions.</li>
        </ol>
<div class="blankline"></div>
        <p>Examples:</p>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span>* p; }
S s1 = S(<span class="d_keyword">new</span> <span class="d_keyword">int</span>); <span class="d_comment">/* s1 is safe. */</span>
S s2 = S(<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*) 0xDEADBEEF); <span class="d_comment">/* s2 is unsafe, because s2.p is
    unsafe. */</span>

<span class="d_keyword">union</span> U { <span class="d_keyword">int</span>* p; size_t x; }
U u = U(<span class="d_keyword">new</span> <span class="d_keyword">int</span>); <span class="d_comment">/* Even though both u.p and u.x are safe, u is unsafe
    because of unsafe aliasing. */</span>
</pre>
        
</div>
<div class="blankline"></div>
        <p>A class reference is safe when it is <span class="d_inlinecode donthyphenate notranslate">null</span> or:</p>
        <ol>            <li>it refers to a valid class instance of the stated type or a
            subtype, and</li>
            <li>the values of the instance's accessible fields are safe, and</li>
            <li>it does not introduce unsafe aliasing with unions.</li>
        </ol>
<div class="blankline"></div>
        <p>A function pointer is safe when it is <span class="d_inlinecode donthyphenate notranslate">null</span> or it refers to a valid
        function that has the same or a covariant signature.</p>
<div class="blankline"></div>
        <p>A <span class="d_inlinecode donthyphenate notranslate">delegate</span> is safe when:</p>
        <ol>            <li>its <span class="d_inlinecode donthyphenate notranslate">.funcptr</span> is <span class="d_inlinecode donthyphenate notranslate">null</span> or refers to a function that matches
            the delegate type, and</li>
            <li>its <span class="d_inlinecode donthyphenate notranslate">.ptr</span> is <span class="d_inlinecode donthyphenate notranslate">null</span> or refers to a context that is in a format
            expected by the function.</li>
        </ol>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="safe-aliasing" href="#safe-aliasing">Safe Aliasing</a></h3>
<div class="blankline"></div>
    <p>When one memory location is accessible with two different types, that
    aliasing is considered safe in these cases:</p>
    <ol>        <li>both types are <span class="d_inlinecode donthyphenate notranslate">const</span> or <span class="d_inlinecode donthyphenate notranslate">immutable</span>; or</li>
        <li>one of the types is mutable while the other is a <span class="d_inlinecode donthyphenate notranslate">const</span>-qualified
            <a href="../spec/type.html#basic-data-types">basic data type</a>; or</li>
        <li>both types are mutable basic data types; or</li>
        <li>one of the types is a static array type with length zero; or</li>
        <li>one of the types is a static array type with non-zero length, and
            aliasing of the array's element type and the other type is safe; or</li>
        <li>both types are pointer types, and aliasing of the target types is
            safe, and the target types have the same size.</li>
    </ol>
<div class="blankline"></div>
    <p>All other cases of aliasing are considered unsafe.</p>
<div class="blankline"></div>
    <p><b>Note:</b> Safe aliasing may be exposed to functions with
    <a href="#safe-interfaces">safe interfaces</a> without affecting their
    guaranteed safety. But when unsafe aliasing is exposed to such functions,
    their safety is no longer guaranteed.</p>
<div class="blankline"></div>
    <p><b>Note:</b> An aliasing relation being safe does not imply that both
    views of the data have <a href="#safe-values">safe values</a>. That must
    be examined separately when safety is of concern.</p>
<div class="blankline"></div>
    <p>Examples:</p>
    <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> f1(<span class="d_keyword">ref</span> <span class="d_keyword">ubyte</span> x, <span class="d_keyword">ref</span> <span class="d_keyword">float</span> y) @safe { x = 0; y = <span class="d_keyword">float</span>.init; }
<span class="d_keyword">union</span> U1 { <span class="d_keyword">ubyte</span> x; <span class="d_keyword">float</span> y; } <span class="d_comment">/* This aliasing is safe. */</span>
U1 u1;
f1(u1.x, u1.y); <span class="d_comment">/* So calling f1 like this is ok. */</span>

<span class="d_keyword">void</span> f2(<span class="d_keyword">ref</span> <span class="d_keyword">int</span>* x, <span class="d_keyword">ref</span> <span class="d_keyword">int</span> y) @trusted { x = <span class="d_keyword">new</span> <span class="d_keyword">int</span>; y = 0xDEADBEEF; }
<span class="d_keyword">union</span> U2 { <span class="d_keyword">int</span>* x; <span class="d_keyword">int</span> y; } <span class="d_comment">/* This aliasing is unsafe. */</span>
U2 u2;
<span class="d_keyword">version</span> (none) f1(u2.x, u2.y); <span class="d_comment">/* So calling f2 like this is not ok. */</span>
</pre>
    
</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="function-attribute-inference" href="#function-attribute-inference">Function Attribute Inference</a></h2>
<div class="blankline"></div>
        <p><a href="../spec/expression.html#FunctionLiteral"><i>FunctionLiteral</i></a>s and
        <a href="../spec/template.html#function-templates">function template</a>s, since their function bodies
        are always present, infer the
        <a href="#pure-functions"><span class="d_inlinecode donthyphenate notranslate">pure</span></a>,
        <a href="#nothrow-functions"><span class="d_inlinecode donthyphenate notranslate">nothrow</span></a>,
        <a href="#safe-functions"><span class="d_inlinecode donthyphenate notranslate">@safe</span></a>, and
        <a href="#nogc-functions"><span class="d_inlinecode donthyphenate notranslate">@nogc</span></a>
        attributes unless specifically overridden.
        </p>
<div class="blankline"></div>
        <p>Attribute inference is not done for other functions, even if the function
        body is present.
        </p>
<div class="blankline"></div>
        <p>The inference is done by determining if the function body follows the
        rules of the particular attribute.
        </p>
<div class="blankline"></div>
        <p>Cyclic functions (i.e. functions that wind up directly or indirectly
        calling themselves) are inferred as being impure, throwing, and @system.
        </p>
<div class="blankline"></div>
        <p>If a function attempts to test itself for those attributes, then
        the function is inferred as not having those attributes.
        </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="pseudo-member" href="#pseudo-member">Uniform Function Call Syntax (UFCS)</a></h2>
<div class="blankline"></div>
        <p>A free function can be called with a syntax that looks as if the function
        were a member function of its first parameter type.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> func(X thisObj);

X obj;
obj.func();
<span class="d_comment">// If 'obj' does not have regular member 'func',
</span><span class="d_comment">// it's automatically rewritten to 'func(obj)'
</span></pre>
<div class="blankline"></div>
    <p>This provides a way to add functions to a class externally as if they were
    public final member functions, which enables
    <a href="http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321">    function chaining and component programming</a>.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate">stdin.byLine(KeepTerminator.yes)
    .map!(a =&gt; a.idup)
    .array
    .sort
    .copy(stdout.lockingTextWriter());
</pre>
<div class="blankline"></div>
        <p>It also works with <span class="d_inlinecode donthyphenate notranslate">@property</span> functions:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">@property prop(X thisObj);
@property prop(X thisObj, <span class="d_keyword">int</span> value);

X obj;
obj.prop;      <span class="d_comment">// Rewrites to: prop(obj);
</span>obj.prop = 1;  <span class="d_comment">// Rewrites to: prop(obj, 1);
</span></pre>
<div class="blankline"></div>
        <p>Syntactically parenthesis-less check for <span class="d_inlinecode donthyphenate notranslate">@property</span>
        functions is done at the same time as UFCS rewrite.</p>
<div class="blankline"></div>
        <p>When UFCS rewrite is necessary, compiler searches the name
        on accessible module level scope, in order from the innermost scope.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">module</span> a;
<span class="d_keyword">void</span> foo(X);
<span class="d_keyword">alias</span> boo = foo;
<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">void</span> bar(X);
    <span class="d_keyword">import</span> b : baz;  <span class="d_comment">// void baz(X);
</span>
    X obj;
    obj.foo();    <span class="d_comment">// OK, calls a.foo;
</span>    <span class="d_comment">//obj.bar();  // NG, UFCS does not see nested functions
</span>    obj.baz();    <span class="d_comment">// OK, calls b.baz, because it is declared at the
</span>                  <span class="d_comment">// top level scope of module b
</span>
    <span class="d_keyword">import</span> b : boo = baz;
    obj.boo();    <span class="d_comment">// OK, calls aliased b.baz instead of a.boo (== a.foo),
</span>                  <span class="d_comment">// because the declared alias name 'boo' in local scope
</span>                  <span class="d_comment">// overrides module scope name
</span>}
<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> mfoo(X);
    <span class="d_keyword">static</span> <span class="d_keyword">void</span> sbar(X);
    <span class="d_keyword">import</span> b : ibaz = baz;  <span class="d_comment">// void baz(X);
</span>    <span class="d_keyword">void</span> test()
    {
        X obj;
        <span class="d_comment">//obj.mfoo();  // NG, UFCS does not see member functions
</span>        <span class="d_comment">//obj.sbar();  // NG, UFCS does not see static member functions
</span>        obj.ibaz();    <span class="d_comment">// OK, ibaz is an alias of baz which declared at
</span>                       <span class="d_comment">//     the top level scope of module b
</span>    }
}
</pre>
<div class="blankline"></div>
        <p>The reason why local symbols are not considered by UFCS, is
        to avoid unexpected name conflicts. See below problematic examples.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> front(<span class="d_keyword">int</span>[] arr) { <span class="d_keyword">return</span> arr[0]; }

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[] a = [1,2,3];
    <span class="d_keyword">auto</span> x = a.front();   <span class="d_comment">// call .front by UFCS
</span>
    <span class="d_keyword">auto</span> front = x;       <span class="d_comment">// front is now a variable
</span>    <span class="d_keyword">auto</span> y = a.front();   <span class="d_comment">// Error, front is not a function
</span>}

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span>[] arr;
    <span class="d_keyword">int</span> front()
    {
        <span class="d_keyword">return</span> arr.front(); <span class="d_comment">// Error, C.front is not callable
</span>                            <span class="d_comment">// using argument types (int[])
</span>    }
}
</pre>
<div class="blankline"></div>

<div style="float: left"><i class="fa fa-angle-left" aria-hidden="true"></i> <a href="../spec/const3.html">Type Qualifiers</a></div>
<div style="float: right"><a href="../spec/operatoroverloading.html">Operator Overloading</a> <i class="fa fa-angle-right" aria-hidden="true"></i></div>
<div style="clear:both"></div>



        <div class="smallprint" id="copyright">Copyright &copy; 1999-2022 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(addVersionSelector);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

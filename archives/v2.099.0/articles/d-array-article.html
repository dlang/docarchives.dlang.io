
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2022 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>D Slices - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='D Slices' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    
    <div class="head">        <h2>Articles</h2>
        <p class="Articles, ../articles/index.html, overview">            <a href="../articles/index.html">overview</a></p>
    </div>
    <ul><li><a href='        ../articles/faq.html'>FAQ</a></li><li><a href='        ../articles/const-faq.html'>const(FAQ)</a></li><li><a href='        ../articles/d-floating-point.html'>Floating Point</a></li><li><a href='        ../articles/warnings.html'>Warnings</a></li><li><a href='        ../articles/rationale.html'>Rationale</a></li><li><a href='        ../articles/builtin.html'>Builtin Rationale</a></li><li><a href='        ../articles/ctod.html'>C to D</a></li><li><a href='        ../articles/cpptod.html'>C++ to D</a></li><li><a href='        ../articles/pretod.html'>C Preprocessor vs D</a></li><li><a href='        ../articles/code_coverage.html'>Code coverage analysis</a></li><li><a href='        ../articles/exception-safe.html'>Exception Safety</a></li><li><a href='        ../articles/hijack.html'>Hijacking</a></li><li><a href='        ../articles/intro-to-datetime.html'>Introduction to std.datetime</a></li><li><a href='        ../articles/lazy-evaluation.html'>Lazy Evaluation</a></li><li><a href='        ../articles/migrate-to-shared.html'>Migrating to Shared</a></li><li><a href='        ../articles/mixin.html'>String Mixins</a></li><li><a href='        ../articles/regular-expression.html'>Regular Expressions</a></li><li><a href='        ../articles/safed.html'>SafeD</a></li><li><a href='        ../articles/templates-revisited.html'>Templates Revisited</a></li><li><a href='        ../articles/ctarguments.html'>Compile-time Sequences</a></li><li><a href='        ../articles/variadic-function-templates.html'>Variadic Templates</a></li><li><a href='        ../articles/d-array-article.html'>D Slices</a></li><li><a href='        ../articles/cppcontracts.html'>D's Contract Programming</a></li><li><a href='        ../articles/template-comparison.html'>Template Comparison</a></li><li><a href='        ../articles/dll-linux.html'>Writing Shared Libraries
    </a></li></ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BD Slices%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/articles/d-array-article.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>D Slices</h1>
        
        


<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#an-overflowing-problem">An Overflowing Problem</a></li>
    <li><a href="#introducing-slices">Introducing Slices</a></li>
    <li><a href="#responsibility">Who's Responsible?</a></li>
    <li><a href="#append-on">A Slice You Can Append On</a></li>
    <li><a href="#how-it-works">How it Works</a></li>
    <li><a href="#determinism">Determinism</a></li>
    <li><a href="#caching">Caching</a></li>
    <li><a href="#slice-members-appender">Slice Members and the Appender</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
</ol>
</div>

<p><i>by Steven Schveighoffer</i></p>

<p>One of the most pleasant features of the D language is its implementation of slices.  Every time I use a programming language that isn't D, I find myself lamenting for D's slice syntax.  Not only is it concise and efficient, but things "just work" when you are dealing with slices.
</p>

<p>I'll go over some of the background and internals of D slices and arrays, and hopefully after reading this, you will have a clearer understanding of the proper ways to use D slices, as well as an idea of how fundamentally different they are than normal arrays!
</p>

<h2><a class="anchor" title="Permalink to this section" id="an-overflowing-problem" href="#an-overflowing-problem">An Overflowing Problem</a></h2>

<p>In most languages, an array is a built-in type which manages its own data, and is passed around by reference.  One refers to the entire thing as an "Array", and associates all the operations for the array (such as setting values, appending data for dynamic arrays, obtaining the length) to that type.
</p>

<p>However, D takes its lineage from C, where an array is simply a chunk of contiguous data.  In C, a reference to an array or array segment is as simple as a pointer (an explicit reference).  C's arrays are distinctly unmanaged by the type that refers to them -- the pointer.  The only operations supported are to retrieve and set data using an offset from the pointer.
</p>

<p>For those of you unfamiliar with C, here are some examples of array usage in C (these also work in D):
</p>

<pre class="d_code notranslate">arr[0] = 4; <span class="d_comment">/* sets the first element of the array 'arr' to 4 */</span>
x = arr[1]; <span class="d_comment">/* retrieves the second element of the array 'arr' into x */</span>
</pre>

<p>Everything else (length, appending, allocation, destruction) is left up to library functions and assumption/documentation.  So what is so wrong with this concept?  One of the largest problems with C arrays is the ability to access any data via the pointer, even data that doesn't belong to the array.  You can even use negative indexes!  Not to mention that the array uses the exact same type as a pointer to a single item.  When you get a pointer as a parameter to a function, that could be an array, or it could be just a pointer to a single item.  Cue buffer overflow attacks.  You can read more about this in Walter Bright's article, <a href="http://drdobbs.com/blogs/cpp/228701625">"C's biggest mistake"</a>
</p>

<h2><a class="anchor" title="Permalink to this section" id="introducing-slices" href="#introducing-slices">Introducing Slices</a></h2>

<p>So how does D improve things?  In many ways, D's arrays are similar to C's arrays.  In fact, D supports C's array syntax using pointers.  However, D provides a new type that builds on C array syntax called a slice.  A slice is a segment of an array (dynamic or otherwise) that tracks both the pointer <i>and</i> the length of the segment.  With the combined protection of having the length of the data, and the garbage collector to manage the memory backing the data, slices are an extremely powerful, dynamic concept that is safe from most memory corruption issues.  In addition, D slices support extending with simple functions which take a slice as the first parameter.  This allows one to add any functionality you want to a built-in type via properties or methods. With D slices, one can write high-performance code with elegant and concise syntax that is awkward or inefficient in almost any other language.
</p>

<p>Let's see some D slices in action:</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[] a;             <span class="d_comment">// a is a slice
</span>
    a = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[5];      <span class="d_comment">// allocate a dynamic array of integers that has at least 5
</span>                         <span class="d_comment">// elements, and give me a slice to the first 5.  Note
</span>                         <span class="d_comment">// that all data in D is default assigned, int's are
</span>                         <span class="d_comment">// defaulted to 0, so this array contains five 0's
</span>
    <span class="d_keyword">int</span>[] b = a[0..2];   <span class="d_comment">// This is a 'slicing' operation.  b now refers to the
</span>                         <span class="d_comment">// first two elements of a.  Note that D uses open interval
</span>                         <span class="d_comment">// for the upper limit, so a[2] is not included in b.
</span>
    <span class="d_keyword">int</span>[] c = a[$-2..$]; <span class="d_comment">// c refers to the last two elements of a
</span>                         <span class="d_comment">// (&dollar; stands for length inside a slice or index operation).
</span>
    c[0] = 4;            <span class="d_comment">// this also assigns a[3]
</span>    c[1] = 5;            <span class="d_comment">// this also assigns a[4]
</span>
    b[] = c[];           <span class="d_comment">// assign the first two elements of a[] to the value from
</span>                         <span class="d_comment">// the last two elements (4, 5).
</span>
    writeln(a);          <span class="d_comment">// prints "[4, 5, 0, 4, 5]"
</span>
    <span class="d_keyword">int</span>[5] d;            <span class="d_comment">// d is a fixed sized array, allocated on the stack
</span>    b = d[0..2];         <span class="d_comment">// slices can point at fixed sized arrays too!
</span>}
</pre>

<p>You may notice something puzzling about the description of the allocation of the array: "allocate a dynamic array of integers that has at least 5 elements, and give me a slice to the first 5."  Why isn't it just "allocate a dynamic array of 5 elements"?  Even experienced D coders have trouble with D's array concepts sometimes, and for quite good reason.  D's slices are <i>not</i> proper dynamic array types (at least not under the hood) even though they appear to be.  What they do is provide a safe and easy <i>interface</i> to arrays of any type (dynamic or otherwise).  So let's discuss probably the most common misconception of D slices.
</p>

<h2><a class="anchor" title="Permalink to this section" id="responsibility" href="#responsibility">Who's Responsible?</a></h2>

<p>A slice in D seems like a dynamic array in almost all aspects of the concept -- when passed without adornments, the data referred to is passed by reference, and it supports all the properties and functions one would expect a dynamic array type to support.  But there is one very important difference.  A slice does not <i>own</i> the array, it <i>references</i> the array.  That is, the slice is not responsible for allocation or deallocation of its data.  The responsible party for managing a dynamic array's memory is the D runtime.
</p>

<p>So where is the true dynamic array type in D?  It's hidden by the runtime, and in fact, has no formal type.  Slices are good enough, and as it turns out, the runtime is smart enough about what you want to do with the data, that you almost never notice dynamic arrays are missing as a full-fledged type.  In fact, most D coders consider the D slice to <i>be</i> the dynamic array type -- it's even listed as a dynamic array type in the spec!  The lack of ownership is very subtle and easy to miss.
</p>

<p>Another consequence of this is that the length is not an array property, it's a slice property.  This means the length field is not necessarily the length of the array, it's the length of the slice.  This can be confusing to newcomers to the language.  For instance, this code has a large flaw in it:
</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> shrinkTo2(<span class="d_keyword">int</span>[] arr)
{
    <span class="d_keyword">if</span> (arr.length &gt; 2)
        arr.length = 2;
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[] arr = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[5];
    arr.shrinkTo2();     <span class="d_comment">// note the ability to call shrinkTo2 as a method
</span>    writeln(arr.length); <span class="d_comment">// outputs 5
</span>}
</pre>

<p>This might look like you changed the passed <span class="d_inlinecode donthyphenate notranslate">arr</span>'s length to 2, but it actually did not affect anything (as is proven by the output from <span class="d_inlinecode donthyphenate notranslate">writeln</span>).  This is because even though the data is passed by reference, the actual pointer and length are passed by value.  Many languages have an array type whose properties are all passed by reference.  Notably, C# and Java arrays are actually fully referenced Objects.  C++'s vector either passes both its data and properties by reference or by value.</p>

<p>To fix this problem, you can do one of two things.  Either you explicitly pass the slice by reference via the <span class="d_inlinecode donthyphenate notranslate">ref</span> keyword, or you return the resulting slice to be reassigned.  For example, here is how the signature would look if the slice is passed by reference:</p>

<pre class="d_code notranslate"><span class="d_keyword">void</span> shrinkTo2(<span class="d_keyword">ref</span> <span class="d_keyword">int</span>[] arr)
</pre>

<p>Let's say you make this change, what happens to the data beyond the second element?  In D, since slices don't own the data, it's still there, managed by the nebulous dynamic array type.  The reason is fundamental: some other slice may still be referencing that data!  The fact that no <i>single</i> slice is the true owner of the data means no single slice can make any assumptions about what else references the array data.</p>

<p>What happens when no slices reference that data?  Enter D's garbage collector.  The garbage collector is responsible for cleaning up dynamic arrays that no longer are referenced by any slices.  In fact, it is the garbage collector that makes much of D's slice usage possible.  You can slice and serve up segments of dynamic arrays, and never have to worry that you are leaking memory, clobbering other slices, or worry about managing the lifetime of the array.</p>

<h2><a class="anchor" title="Permalink to this section" id="append-on" href="#append-on">A Slice You Can Append On</a></h2>

<p>D's slices support appending more data to the end of the slice, much like a true dynamic array type.  The language has a specific operator used for concatenation and appending, the tilde (<span class="d_inlinecode donthyphenate notranslate">~</span>).  Here are some operations that append and concatenate arrays:</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a;     <span class="d_comment">// an empty slice references no data, but still can be appended to
</span>a ~= 1;      <span class="d_comment">// append some integers, this automatically allocates a new
</span>a ~= 2;      <span class="d_comment">// array to hold the elements.
</span>
a ~= [3, 4]; <span class="d_comment">// append another array (this time, an array literal)
</span>a = a ~ a;   <span class="d_comment">// concatenate a with itself, a is now [1, 2, 3, 4, 1, 2, 3, 4]
</span>
<span class="d_keyword">int</span>[5] b;    <span class="d_comment">// a fixed-size array on the stack
</span>a = b[1..$]; <span class="d_comment">// a is a slice of b
</span>a ~= 5;      <span class="d_comment">// since a was pointing to stack data, appending always reallocates,
</span>             <span class="d_comment">// but works!
</span></pre>

<p>Anyone who cares about performance will wonder what happens when you append the four elements.  The slice does not own its data, so how does one avoid reallocating a new array on each append operation?  One of the main requirements of D slices are that they are efficient.  Otherwise, coders would not use them.  D has solved this problem in a way that is virtually transparent to the programmer, and this is one of the reasons slices seem more like true dynamic arrays.</p>

<h2><a class="anchor" title="Permalink to this section" id="how-it-works" href="#how-it-works">How it Works</a></h2>

<p>Remember before when we allocated a new array, I said <i>allocate a dynamic array of <b>at least</b> n elements and give me a slice</i>?  Here is where the runtime earns its keep.  The allocator only allocates blocks in powers of 2 up to a page of data (in 32-bit x86, a page of data is 4096 bytes), or in multiples of pages.  So when you allocate an array, you can easily get a block that's larger than requested. For instance, allocating a block of five 32 bit integers (which consumes 20 bytes) provides you a block of 32 bytes.  This leaves space for 3 more integers.</p>

<p>It's clearly possible to append more integers into the array without reallocating, but the trick is to prevent "stomping" on data that is valid and in use.  Remember, the slice doesn't know what other slices refer to that data, or really where it is in the array (it could be a segment at the beginning or the middle).  To make the whole thing work, the runtime stores the number of <i>used</i> bytes inside the block itself (a minor drawback is that the usable space in the block is not as big as it could be.  In our example, for instance, we can truly only store 7 integers before needing to reallocate into another block).
</p>

<p>When we request the runtime to append to a slice, it first checks to see that both the block is appendable (which means the <i>used</i> field is valid), and the slice <i>ends</i> at the same point valid data ends (it is not important where the slice begins).  The runtime then checks to see if the new data will fit into the unused block space.  If all of these checks pass, the data is written into the array block, and the stored <i>used</i> field is updated to include the new data.  If any of these checks fail, a new array block is allocated that will hold the existing and new data, which is then populated with all the data.  What happens to the old block?  If there were other slices referencing it, it stays in place without being changed.  If nothing else is referencing it, it becomes garbage and is reclaimed on the next collection cycle.  This allows you to safely reallocate one slice without invalidating any others.  This is a huge departure from C/C++, where reallocating an array, or appending to a vector can invalidate other references to that data (pointers or iterators).</p>

<p>The result is an append operation which is not only efficient, but universally handy.  Whenever you want to append a slice, you can, without worry about performance or corruption issues.  You don't even have to worry about whether a slice's data is heap allocated, stack allocated, in ROM, or even if it's null.  The append operation always succeeds (given you have enough memory), and the runtime takes care of all the dirty work in the background.</p>

<h2><a class="anchor" title="Permalink to this section" id="determinism" href="#determinism">Determinism</a></h2>

<p>There is one caveat with slice appending that can bite inexperienced, and even experienced D coders: the apparent non-deterministic behavior of appending.</p>

<p>Let's say we have a function which is passed a buffer, and writes some number of 'A's to the buffer (appending if necessary), returning the filled buffer:</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">char</span>[] fillAs(<span class="d_keyword">char</span>[] buf, size_t num)
{
    <span class="d_keyword">if</span> (buf.length &lt; num)
        buf.length = num; <span class="d_comment">// increase buffer length to be able to hold the 'A's
</span>    buf[0..num] = 'A';    <span class="d_comment">// assign A to all the elements
</span>    <span class="d_keyword">return</span> buf[0..num];   <span class="d_comment">// return the result
</span>}
</pre>

<p>What's wrong with the <span class="d_inlinecode donthyphenate notranslate">fillAs</span> function?  Nothing really, but what happens if increasing the length forces the buffer to be reallocated?  In that case, the buffer passed in is <i>not</i> overwritten with 'A's, only the reallocated buffer is.  This can be surprising if you were expecting to continue to use the same buffer in further operations, or if you expected the original buffer to be filled with 'A's.  The end result, depending on whether the block referenced by <span class="d_inlinecode donthyphenate notranslate">buf[]</span> can be appended in place, is the caller's slice might be overwritten with 'A's, or it might not be.</p>

<pre class="d_code notranslate"><span class="d_comment">// continued example...
</span><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">char</span>[] str = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[10]; <span class="d_comment">// Note, the block capacity allocated for this is
</span>                               <span class="d_comment">// 15 elements
</span>    str[] = 'B';
    fillAs(str, 20);           <span class="d_comment">// buffer must be reallocated (20 &gt; 15)
</span>    writeln(str);              <span class="d_comment">// "BBBBBBBBBB"
</span>    fillAs(str, 12);           <span class="d_comment">// buffer can be extended in place (12 &lt;= 15)!
</span>    writeln(str);              <span class="d_comment">// "AAAAAAAAAA";
</span>}
</pre>


<p>If you give this some thought, you should come to the conclusion that such a situation is unavoidable without costly copy-on-append semantics -- the system cannot keep track of every slice that references the data, and you have to put the new data somewhere.  However, there are a couple options we have to mitigate the problem:</p>

<ol><li>Re-assign the slice to the return value of the function.  Note that the most important result of this function is the return value, not whether the buffer was used or not.</li>
<li>Don't use the passed in buffer again.  If you don't use the source slice again, then you can't experience any issues with it.</li>
</ol>

<p>As the function author, there are some things we can do to avoid causing these problems.  It's important to note that the only time this situation can occur is when the function appends to, or increases the length of, a passed in slice <b>and then</b> writes data to the original portion of the slice.  Avoiding this specific situation where possible can reduce the perception of non-determinism.  Later we will discuss some properties you can use to predict how the runtime will affect your slice.  It is a good idea to note in the documentation how the passed in slice might or might not be overwritten.</p>

<p>A final option is to use <span class="d_inlinecode donthyphenate notranslate">ref</span> to make sure the source slice is updated.  This is sometimes not an option as a slice can easily be an rvalue (input only).  However, this does not fix the problem for any aliases to the same data elsewhere.</p>

<h2><a class="anchor" title="Permalink to this section" id="caching" href="#caching">Caching</a></h2>

<p>One of the issues with appending to a slice is that the operation is quick, but not quick enough.  Every time we append, we need to fetch the metadata for the block (its starting address, size, and <i>used</i> data).  Doing this means an O(lg(n)) lookup in the GC's memory pool for every append (not to mention acquiring the global GC lock).  However, what we want is amortized constant appending.  To achieve this lofty goal, we employ a caching technique that is, as far as I know, unique to D.</p>

<p>Since D has the concept of default thread local storage, the type system can tell us whether heap data is local to the thread (and most data is), or shared amongst all threads.  Using this knowledge, we can achieve lock-free caching of this metadata for thread-local appends, with one cache per thread.  The cache stores the most recent <span class="d_inlinecode donthyphenate notranslate">N</span> lookups of metadata, giving us quick access to whether a slice can be appended.</p>

<h2><a class="anchor" title="Permalink to this section" id="slice-members-appender" href="#slice-members-appender">Slice Members and the Appender</a></h2>

<p>With D slices having such interesting behavior, there is a need sometimes to be able to predict the behavior of slices and appending.  To that end, several properties and methods have been added to the slice.</p>

<p><a href="../phobos/object.html#.reserve""><span class="d_inlinecode donthyphenate notranslate">size_t reserve(size_t n)</span></a>: Reserves n elements for appending to a slice.  If a slice can already be appended in place, and there is already space in the array for at least n elements (n represents both existing slice elements and appendable space), nothing is modified.  It returns the resulting capacity.</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] slice;
slice.reserve(50);
<span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> i; 0..50)
    slice ~= i;        <span class="d_comment">// does not reallocate
</span></pre>

<p><a href="../phobos/object.html#.capacity""><span class="d_inlinecode donthyphenate notranslate">size_t capacity</span></a>: A property which gives you the number of elements the slice can hold via appending.  If the slice cannot be appended in place, this returns 0.  Note that capacity (if non-zero) includes the current slice elements.</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] slice = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[5];
<span class="d_keyword">assert</span>(slice.capacity == 7);  <span class="d_comment">// includes the 5 pre-allocated elements
</span><span class="d_keyword">int</span>[] slice2 = slice;
slice.length = 6;
<span class="d_keyword">assert</span>(slice.capacity == 7);  <span class="d_comment">// appending in place doesn't change the capacity.
</span><span class="d_keyword">assert</span>(slice2.capacity == 0); <span class="d_comment">// cannot append slice2 because it would stomp on
</span>                              <span class="d_comment">// slice's 6th element
</span></pre>

<p><a href="../phobos/object.html#.assumeSafeAppend""><span class="d_inlinecode donthyphenate notranslate">assumeSafeAppend()</span></a>: This method forces the runtime to assume it is safe to append a slice.  Essentially this adjusts the <i>used</i> field of the array to end at the same spot the slice ends.</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] slice = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[5];
slice = slice[0..2];
<span class="d_keyword">assert</span>(slice.capacity == 0); <span class="d_comment">// not safe to append, there is other valid data in the block.
</span>slice.assumeSafeAppend();
<span class="d_keyword">assert</span>(slice.capacity == 7); <span class="d_comment">// force the used data to 2 elements
</span></pre>

<p>If D slices' append performance just isn't up to snuff for your performance requirements, there is another alternative.  The <a href="../phobos/std_array.html#.Appender"><span class="d_inlinecode donthyphenate notranslate">std.array.Appender</span></a> type will append data to an array as fast as possible, without any need to look up metadata from the runtime.  <a href="../phobos/std_array.html#.Appender"><span class="d_inlinecode donthyphenate notranslate">std.array.Appender</span></a> also supports the output range idiom via an append operation (normal slices only support the output range by overwriting their own data).</p>

<h2><a class="anchor" title="Permalink to this section" id="conclusion" href="#conclusion">Conclusion</a></h2>

<p>Whether you are a seasoned programmer or a novice, the array and slice concepts in D provide an extremely rich feature set that allows for almost anything you would want to do with an array type.  With a large focus on performance and usability, the D slice type is one of those things that you don't notice how great it is until you work with another language that doesn't have it.</p>

<p><i>Thanks to David Gileadi, Andrej Mitrovic, Jesse Phillips, Alex Dovhal, Johann !MacDonagh, and Jonathan Davis for their reviews and suggestions for this article</i></p>

&copy; 2011-2012 by Steven Schveighoffer <br>
<a rel="license" href="https://creativecommons.org/licenses/by-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/3.0/88x31.png"></a><br>This <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" rel="dct:type">work</span> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nd/3.0/">Creative Commons Attribution-NoDerivs 3.0 Unported License</a>.




        <div class="smallprint" id="copyright">Copyright &copy; 1999-2022 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

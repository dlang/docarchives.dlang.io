
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2022 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Interfaces - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Interfaces' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BInterfaces%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/interface.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Interfaces</h1>
        
        



<p>The <code class="d_inline">interface</code> keyword is for defining interfaces in class hierarchies. <code class="d_inline">interface</code> is very similar to <code class="d_inline">class</code> with the following restrictions:
</p>

<ul>
<li>The member functions that it declares (but not implements) are abstract even without the <code class="d_inline">abstract</code> keyword.
</li>

<li>The member functions that it implements must be <code class="d_inline">static</code> or <code class="d_inline">final</code>. (<code class="d_inline">static</code> and <code class="d_inline">final</code> member functions are explained below.)
</li>

<li>Its member variables must be <code class="d_inline">static</code>.
</li>

<li>Interfaces can inherit only interfaces.
</li>

</ul>

<p>Despite these restrictions, there is no limit on the number of <code class="d_inline">interface</code>s that a class can inherit from. (In contrast, a class can inherit from up to one <code class="d_inline">class</code>.)
</p>

<h5 class="subsection">Definition</h5>

<p>Interfaces are defined by the <code class="d_inline">interface</code> keyword, the same way as classes:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">interface</span></span> SoundEmitter {
    <span class="d_comment">// ...
</span>}
</pre>

<p>An <code class="d_inline">interface</code> is for declaring member functions that are implicitly abstract:
</p>

<pre class="d_code"><span class="d_keyword">interface</span> SoundEmitter {
    string emitSound();    <span class="d_comment">// Declared (not implemented)
</span>}
</pre>

<p>Classes that inherit from that interface would have to provide the implementations of the abstract functions of the interface.
</p>

<p>Interface function declarations can have <code class="d_inline">in</code> and <code class="d_inline">out</code> contract blocks:
</p>

<pre class="d_code"><span class="d_keyword">interface</span> I {
    <span class="d_keyword">int</span> func(<span class="d_keyword">int</span> i)
    <span class="hilite"><span class="d_keyword">in</span></span> {
        <span class="d_comment">/* Strictest requirements that the callers of this
         * function must meet. (Derived interfaces and classes
         * can loosen these requirements.) */</span>

    } <span class="hilite"><span class="d_keyword">out</span></span> {    <span class="d_comment">// (optionally with (result) parameter)
</span>        <span class="d_comment">/* Exit guarantees that the implementations of this
         * function must give. (Derived interfaces and classes
         * can give additional guarantees.) */</span>
    }
}
</pre>

<p>We will see examples of contract inheritance later in <a href="invariant.html">the Contract Programming for Structs and Classes chapter</a>.
</p>

<h5 class="subsection">Inheriting from an <code class="d_inline">interface</code></h5>

<p>The <code class="d_inline">interface</code> inheritance syntax is the same as <code class="d_inline">class</code> inheritance:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Violin : <span class="hilite">SoundEmitter</span> {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"♩♪♪"</span>;
    }
}

<span class="d_keyword">class</span> Bell : <span class="hilite">SoundEmitter</span> {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"ding"</span>;
    }
}
</pre>

<p>Interfaces support polymorphism: Functions that take interface parameters can use those parameters without needing to know the actual types of objects. For example, the following function that takes a parameter of <code class="d_inline">SoundEmitter</code> calls <code class="d_inline">emitSound()</code> on that parameter without needing to know the actual type of the object:
</p>

<pre class="d_code"><span class="d_keyword">void</span> useSoundEmittingObject(SoundEmitter object) {
    <span class="d_comment">// ... some operations ...
</span>    writeln(object.emitSound());
    <span class="d_comment">// ... more operations ...
</span>}
</pre>

<p>Just like with classes, that function can be called with any type of object that inherits from the <code class="d_inline">SoundEmitter</code> interface:
</p>

<pre class="d_code">    useSoundEmittingObject(<span class="d_keyword">new</span> Violin);
    useSoundEmittingObject(<span class="d_keyword">new</span> Bell);
</pre>

<p>The special <code class="d_inline">emitSound()</code> function for each object would get called and the outputs of <code class="d_inline">Violin.emitSound</code> and <code class="d_inline">Bell.emitSound</code> would be printed:
</p>

<pre class="shell">♩♪♪
ding
</pre>

<h5 class="subsection">Inheriting from more than one <code class="d_inline">interface</code></h5>

<p>A class can be inherited from up to one <code class="d_inline">class</code>. There is no limit on the number of <code class="d_inline">interface</code>s to inherit from.
</p>

<p>Let's consider the following interface that represents communication devices:
</p>

<pre class="d_code"><span class="d_keyword">interface</span> CommunicationDevice {
    <span class="d_keyword">void</span> talk(string message);
    string listen();
}
</pre>

<p>If a <code class="d_inline">Phone</code> class needs to be used both as a sound emitter and a communication device, it can inherit both of those interfaces:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Phone : <span class="hilite">SoundEmitter, CommunicationDevice</span> {
    <span class="d_comment">// ...
</span>}
</pre>

<p>That definition represents both of these relationships: "phone is a sound emitter" and "phone is a communication device."
</p>

<p>In order to construct objects of this class, <code class="d_inline">Phone</code> must implement the abstract functions of both of the interfaces:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Phone : SoundEmitter, CommunicationDevice {
    string emitSound() {           <span class="d_comment">// for SoundEmitter
</span>        <span class="d_keyword">return</span> <span class="d_string">"rrring"</span>;
    }

    <span class="d_keyword">void</span> talk(string message) {    <span class="d_comment">// for CommunicationDevice
</span>        <span class="d_comment">// ... put the message on the line ...
</span>    }

    string listen() {              <span class="d_comment">// for CommunicationDevice
</span>        string soundOnTheLine;
        <span class="d_comment">// ... get the message from the line ...
</span>        <span class="d_keyword">return</span> soundOnTheLine;
    }
}
</pre>

<p>A class can inherit from any number of interfaces as it makes sense according to the design of the program.
</p>

<h5 class="subsection">Inheriting from <code class="d_inline">interface</code> and <code class="d_inline">class</code></h5>

<p>Classes can still inherit from up to one <code class="d_inline">class</code> as well:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">class</span></span> Clock {
    <span class="d_comment">// ... clock implementation ...
</span>}

<span class="d_keyword">class</span> AlarmClock : <span class="hilite">Clock</span>, SoundEmitter {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"beep"</span>;
    }
}
</pre>

<p><code class="d_inline">AlarmClock</code> inherits the members of <code class="d_inline">Clock</code>. Additionally, it also provides the <code class="d_inline">emitSound()</code> function that the <code class="d_inline">SoundEmitter</code> interface requires.
</p>

<h5 class="subsection">Inheriting <code class="d_inline">interface</code> from <code class="d_inline">interface</code></h5>

<p>An interface that is inherited from another interface effectively increases the number of functions that the subclasses must implement:
</p>

<pre class="d_code"><span class="d_keyword">interface</span> MusicalInstrument : SoundEmitter {
    <span class="d_keyword">void</span> adjustTuning();
}
</pre>

<p>According to the definition above, in order to be a <code class="d_inline">MusicalInstrument</code>, both the <code class="d_inline">emitSound()</code> function that <code class="d_inline">SoundEmitter</code> requires and the <code class="d_inline">adjustTuning()</code> function that <code class="d_inline">MusicalInstrument</code> requires must be implemented.
</p>

<p>For example, if <code class="d_inline">Violin</code> inherits from <code class="d_inline">MusicalInstrument</code> instead of <code class="d_inline">SoundEmitter</code>, it must now also implement <code class="d_inline">adjustTuning()</code>:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Violin : MusicalInstrument {
    string emitSound() {     <span class="d_comment">// for SoundEmitter
</span>        <span class="d_keyword">return</span> <span class="d_string">"♩♪♪"</span>;
    }

    <span class="d_keyword">void</span> adjustTuning() {    <span class="d_comment">// for MusicalInstrument
</span>        <span class="d_comment">// ... special tuning of the violin ...
</span>    }
}
</pre>

<h5 class="subsection"><a id="ix_Interfaces.static, member function" content="static, member function"></a> <code class="d_inline">static</code> member functions</h5>

<p>I have delayed explaining <code class="d_inline">static</code> member functions until this chapter to keep the earlier chapters shorter. <code class="d_inline">static</code> member functions are available for structs, classes, and interfaces.
</p>

<p>Regular member functions are always called on an object. The member variables that are referenced inside the member function are the members of a particular object:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Foo {
    <span class="d_keyword">int</span> i;

    <span class="d_keyword">void</span> modify(<span class="d_keyword">int</span> value) {
        <span class="hilite">i</span> = value;
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> object0 = Foo();
    <span class="d_keyword">auto</span> object1 = Foo();

    object0.modify(10);    <span class="d_comment">// object0.i changes
</span>    object1.modify(10);    <span class="d_comment">// object1.i changes
</span>}
</pre>

<p>The members can also be referenced by <code class="d_inline">this</code>:
</p>

<pre class="d_code">    <span class="d_keyword">void</span> modify(<span class="d_keyword">int</span> value) {
        <span class="d_keyword">this</span>.i = value;    <span class="d_comment">// equivalent of the previous one
</span>    }
</pre>

<p>A <code class="d_inline">static</code> member function does not operate on an object; there is no object that the <code class="d_inline">this</code> keyword would refer to, so <code class="d_inline">this</code> is not valid inside a <code class="d_inline">static</code> function. For that reason, none of the regular member variables are available inside <code class="d_inline">static</code> member functions:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Foo {
    <span class="d_keyword">int</span> i;

    <span class="hilite"><span class="d_keyword">static</span></span> <span class="d_keyword">void</span> commonFunction(<span class="d_keyword">int</span> value) {
        i = value;         <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
        <span class="d_keyword">this</span>.i = value;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    }
}
</pre>

<p><code class="d_inline">static</code> member functions can use only the <code class="d_inline">static</code> member variables.
</p>

<p>Let's redesign the <code class="d_inline">Point</code> struct that we have seen earlier in <a href="struct.html">the Structs chapter</a>, this time with a <code class="d_inline">static</code> member function. In the following code, every <code class="d_inline">Point</code> object gets a unique id, which is determined by a <code class="d_inline">static</code> member function:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> Point {
    size_t id;    <span class="d_comment">// Object id
</span>    <span class="d_keyword">int</span> line;
    <span class="d_keyword">int</span> column;

    <span class="d_comment">// The id to be used for the next object
</span>    <span class="hilite"><span class="d_keyword">static</span></span> size_t nextId;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> line, <span class="d_keyword">int</span> column) {
        <span class="d_keyword">this</span>.line = line;
        <span class="d_keyword">this</span>.column = column;
        <span class="d_keyword">this</span>.id = makeNewId();
    }

    <span class="hilite"><span class="d_keyword">static</span></span> size_t makeNewId() {
        <span class="d_keyword">immutable</span> newId = nextId;
        ++nextId;
        <span class="d_keyword">return</span> newId;
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> top = Point(7, 0);
    <span class="d_keyword">auto</span> middle = Point(8, 0);
    <span class="d_keyword">auto</span> bottom =  Point(9, 0);

    writeln(top.id);
    writeln(middle.id);
    writeln(bottom.id);
}
</pre>

<p>The <code class="d_inline">static</code> <code class="d_inline">makeNewId()</code> function can use the common variable <code class="d_inline">nextId</code>. As a result, every object gets a unique id:
</p>

<pre class="shell">0
1
2
</pre>

<p>Although the example above contains a <code class="d_inline">struct</code>, <code class="d_inline">static</code> member functions are available for classes and interfaces as well.
</p>

<h5 class="subsection"><a id="ix_Interfaces.final" content="final"></a> <code class="d_inline">final</code> member functions</h5>

<p>I have delayed explaining <code class="d_inline">final</code> member functions until this chapter to keep the earlier chapters shorter. <code class="d_inline">final</code> member functions are relevant only for classes and interfaces because structs do not support inheritance.
</p>

<p><code class="d_inline">final</code> specifies that a member function cannot be redefined by a subclass. In a sense, the implementation that this <code class="d_inline">class</code> or <code class="d_inline">interface</code> provides is the <i>final</i> implementation of that function. An example of a case where this feature is useful is where the general steps of an algorithm are defined by an interface and the finer details are left to subclasses.
</p>

<p>Let's see an example of this with a <code class="d_inline">Game</code> interface. The general steps of playing a game is being determined by the <code class="d_inline">play()</code> function of the following <code class="d_inline">interface</code>:
</p>

<pre class="d_code"><span class="d_keyword">interface</span> Game {
    <span class="hilite"><span class="d_keyword">final</span></span> <span class="d_keyword">void</span> play() {
        string name = gameName();
        writefln(<span class="d_string">"Starting %s"</span>, name);

        introducePlayers();
        prepare();
        begin();
        end();

        writefln(<span class="d_string">"Ending %s"</span>, name);
    }

    string gameName();
    <span class="d_keyword">void</span> introducePlayers();
    <span class="d_keyword">void</span> prepare();
    <span class="d_keyword">void</span> begin();
    <span class="d_keyword">void</span> end();
}
</pre>

<p>It is not possible for subclasses to modify the definition of the <code class="d_inline">play()</code> member function. The subclasses can (and must) provide the definitions of the five abstract member functions that are declared by the interface. By doing so, the subclasses complete the missing steps of the algorithm:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.random;
<span class="d_keyword">import</span> std.conv;

<span class="d_keyword">class</span> DiceSummingGame : Game {
    string player;
    size_t count;
    size_t sum;

    string gameName() {
        <span class="d_keyword">return</span> <span class="d_string">"Dice Summing Game"</span>;
    }

    <span class="d_keyword">void</span> introducePlayers() {
        write(<span class="d_string">"What is your name? "</span>);
        player = strip(readln());
    }

    <span class="d_keyword">void</span> prepare() {
        write(<span class="d_string">"How many times to throw the dice? "</span>);
        readf(<span class="d_string">" %s"</span>, &amp;count);
        sum = 0;
    }

    <span class="d_keyword">void</span> begin() {
        <span class="d_keyword">foreach</span> (i; 0 .. count) {
            <span class="d_keyword">immutable</span> dice = uniform(1, 7);
            writefln(<span class="d_string">"%s: %s"</span>, i, dice);
            sum += dice;
        }
    }

    <span class="d_keyword">void</span> end() {
        writefln(<span class="d_string">"Player: %s, Dice sum: %s, Average: %s"</span>,
                 player, sum, to!<span class="d_keyword">double</span>(sum) / count);
    }
}

<span class="d_keyword">void</span> useGame(Game game) {
    game.play();
}

<span class="d_keyword">void</span> main() {
    useGame(<span class="d_keyword">new</span> DiceSummingGame());
}
</pre>

<p>Although the example above contains an <code class="d_inline">interface</code>, <code class="d_inline">final</code> member functions are available for classes as well.
</p>

<h5 class="subsection">How to use</h5>

<p><code class="d_inline">interface</code> is a commonly used feature. There is one or more <code class="d_inline">interface</code> at the top of almost every class hierarchy. A kind of hierarchy that is commonly encountered in programs involves a single <code class="d_inline">interface</code> and a number of classes that implement that interface:
</p>

<pre class="mono">               <i>MusicalInstrument
                 (interface)</i>
               /    |     \     \
          Violin  Guitar  Flute  ...
</pre>

<p>Although there are more complicated hierarchies in practice, the simple hierarchy above solves many problems.
</p>

<p>It is also common to move common implementation details of class hierarchies to intermediate classes. The subclasses inherit from these intermediate classes. The <code class="d_inline">StringInstrument</code> and <code class="d_inline">WindInstrument</code> classes below can contain the common members of their respective subclasses:
</p>

<pre class="mono">               <i>MusicalInstrument
                 (interface)</i>
                 /         \
   StringInstrument       WindInstrument
     /    |     \         /      |     \
Violin  Viola    ...   Flute  Clarinet  ...
</pre>

<p>The subclasses would implement their respective special definitions of member functions.
</p>

<h5 class="subsection"><a id="ix_Interfaces.abstraction" content="abstraction"></a> Abstraction</h5>

<p>Interfaces help make parts of programs independent from each other. This is called <i>abstraction</i>. For example, a program that deals with musical instruments can be written primarily by using the <code class="d_inline">MusicalInstrument</code> interface, without ever specifying the actual types of the musical instruments.
</p>

<p>A <code class="d_inline">Musician</code> class can contain a <code class="d_inline">MusicalInstrument</code> without ever knowing the actual type of the instrument:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Musician {
    MusicalInstrument instrument;
    <span class="d_comment">// ...
</span>}
</pre>

<p>Different types of musical instruments can be combined in a collection without regard to the actual types of these instruments:
</p>

<pre class="d_code">    MusicalInstrument[] orchestraInstruments;
</pre>

<p>Most of the functions of the program can be written only by using this interface:
</p>

<pre class="d_code"><span class="d_keyword">bool</span> needsTuning(MusicalInstrument instrument) {
    <span class="d_keyword">bool</span> result;
    <span class="d_comment">// ...
</span>    <span class="d_keyword">return</span> result;
}

<span class="d_keyword">void</span> playInTune(MusicalInstrument instrument) {
    <span class="d_keyword">if</span> (needsTuning(instrument)) {
        instrument.adjustTuning();
    }

    writeln(instrument.emitSound());
}
</pre>

<p><i>Abstracting away</i> parts of a program from each other allows making changes in one part of the program without needing to modify the other parts. When implementations of certain parts of the program are <i>behind</i> a particular interface, the code that uses only that interface does not get affected.
</p>

<h5 class="subsection">Example</h5>

<p>The following program defines the <code class="d_inline">SoundEmitter</code>, <code class="d_inline">MusicalInstrument</code>, and <code class="d_inline">CommunicationDevice</code> interfaces:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_comment">/* This interface requires emitSound(). */</span>
<span class="d_keyword">interface</span> SoundEmitter {
    string emitSound();
}

<span class="d_comment">/* This class needs to implement only emitSound(). */</span>
<span class="d_keyword">class</span> Bell : SoundEmitter {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"ding"</span>;
    }
}

<span class="d_comment">/* This interface additionally requires adjustTuning(). */</span>
<span class="d_keyword">interface</span> MusicalInstrument : SoundEmitter {
    <span class="d_keyword">void</span> adjustTuning();
}

<span class="d_comment">/* This class needs to implement both emitSound() and
 * adjustTuning(). */</span>
<span class="d_keyword">class</span> Violin : MusicalInstrument {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"♩♪♪"</span>;
    }

    <span class="d_keyword">void</span> adjustTuning() {
        <span class="d_comment">// ... tuning of the violin ...
</span>    }
}

<span class="d_comment">/* This interface requires talk() and listen(). */</span>
<span class="d_keyword">interface</span> CommunicationDevice {
    <span class="d_keyword">void</span> talk(string message);
    string listen();
}

<span class="d_comment">/* This class needs to implement emitSound(), talk(), and
 * listen(). */</span>
<span class="d_keyword">class</span> Phone : SoundEmitter, CommunicationDevice {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"rrring"</span>;
    }

    <span class="d_keyword">void</span> talk(string message) {
        <span class="d_comment">// ... put the message on the line ...
</span>    }

    string listen() {
        string soundOnTheLine;
        <span class="d_comment">// ... get the message from the line ...
</span>        <span class="d_keyword">return</span> soundOnTheLine;
    }
}

<span class="d_keyword">class</span> Clock {
    <span class="d_comment">// ... the implementation of Clock ...
</span>}

<span class="d_comment">/* This class needs to implement only emitSound(). */</span>
<span class="d_keyword">class</span> AlarmClock : Clock, SoundEmitter {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"beep"</span>;
    }

    <span class="d_comment">// ... the implementation of AlarmClock ...
</span>}

<span class="d_keyword">void</span> main() {
    SoundEmitter[] devices;

    devices ~= <span class="d_keyword">new</span> Bell;
    devices ~= <span class="d_keyword">new</span> Violin;
    devices ~= <span class="d_keyword">new</span> Phone;
    devices ~= <span class="d_keyword">new</span> AlarmClock;

    <span class="d_keyword">foreach</span> (device; devices) {
        writeln(device.emitSound());
    }
}
</pre>

<p>Because <code class="d_inline">devices</code> is a <code class="d_inline">SoundEmitter</code> slice, it can contain objects of any type that inherits from <code class="d_inline">SoundEmitter</code> (i.e. types that have an "is a" relationship with <code class="d_inline">SoundEmitter</code>). As a result, the output of the program consists of different sounds that are emitted by the different types of objects:
</p>

<pre class="shell">ding
♩♪♪
rrring
beep
</pre>

<h5 class="subsection">Summary</h5>

<ul>
<li><code class="d_inline">interface</code> is similar to a <code class="d_inline">class</code> that consists only of abstract functions. <code class="d_inline">interface</code> can have <code class="d_inline">static</code> member variables and <code class="d_inline">static</code> or <code class="d_inline">final</code> member functions.
</li>

<li>For a class to be constructible, it must have implementations for all member functions of all interfaces that it inherits from.
</li>

<li>It is possible to inherit from unlimited number of <code class="d_inline">interface</code>s.
</li>

<li>A common hierarchy consists of a single <code class="d_inline">interface</code> and a number of subclasses that implement that interface.
</li>

</ul>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2022 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Sun May 15 14:08:35 2022
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

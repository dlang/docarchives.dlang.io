
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Classes - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Classes' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BClasses%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/class.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Classes</h1>
        
        



<p><a id="ix_Classes.OOP" content="OOP"></a> <a id="ix_Classes.object oriented programming" content="object oriented programming"></a> <a id="ix_Classes.user defined type" content="user defined type"></a> Similar to structs, <code class="d_inline">class</code> is a feature for defining new types. By this definition, classes are <i>user defined types</i>. Different from structs, classes provide the <i>object oriented programming</i> (OOP) paradigm in D. The major aspects of OOP are the following:
</p>

<ul>
<li><b>Encapsulation:</b> Controlling access to members (<i>Encapsulation is available for structs as well but it has not been mentioned until this chapter.</i>)
</li>

<li><b>Inheritance:</b> Acquiring members of another type
</li>

<li><b>Polymorphism:</b> Being able to use a more special type in place of a more general type
</li>

</ul>

<p>Encapsulation is achieved by <i>protection attributes</i>, which we will see in <a href="encapsulation.html">a later chapter</a>. Inheritance is for acquiring <i>implementations</i> of other types. <a href="inheritance.html">Polymorphism</a> is for abstracting parts of programs from each other and is achieved by class <i>interfaces</i>.
</p>

<p>This chapter will introduce classes at a high level, underlining the fact that they are reference types. Classes will be explained in more detail in later chapters.
</p>

<h5 class="subsection">Comparing with structs</h5>

<p>In general, classes are very similar to structs. Most of the features that we have seen for structs in the following chapters apply to classes as well:
</p>

<ul><li><a href="struct.html">Structs</a></li>
<li><a href="member_functions.html">Member Functions</a></li>
<li><a href="const_member_functions.html"><code class="d_inline">const ref</code> Parameters and <code class="d_inline">const</code> Member Functions</a></li>
<li><a href="special_functions.html">Constructor and Other Special Functions</a></li>
<li><a href="operator_overloading.html">Operator Overloading</a></li>
</ul>

<p>However, there are important differences between classes and structs.
</p>

<h6>Classes are reference types</h6>

<p>The biggest difference from structs is that structs are <i>value types</i> and classes are <i>reference types</i>. The other differences outlined below are mostly due to this fact.
</p>

<h6><a id="ix_Classes.null, class" content="null, class"></a>  Class variables may be <code class="d_inline">null</code></h6>

<p>As it has been mentioned briefly in <a href="null_is.html">The <code class="d_inline">null</code> Value and the <code class="d_inline">is</code> Operator chapter</a>, class variables can be <code class="d_inline">null</code>. In other words, class variables may not be providing access to any object. Class variables do not have values themselves; the actual class objects must be constructed by the <code class="d_inline">new</code> keyword.
</p>

<p>As you would also remember, comparing a reference to <code class="d_inline">null</code> by the <code class="d_inline">==</code> or the <code class="d_inline">!=</code> operator is an error. Instead, the comparison must be done by the <code class="d_inline">is</code> or the <code class="d_inline">!is</code> operator, accordingly:
</p>

<pre class="d_code">    MyClass referencesAnObject = <span class="d_keyword">new</span> MyClass;
    <span class="d_keyword">assert</span>(referencesAnObject <span class="hilite">!<span class="d_keyword">is</span></span> <span class="d_keyword">null</span>);

    MyClass variable;   <span class="d_comment">// does not reference an object
</span>    <span class="d_keyword">assert</span>(variable <span class="hilite"><span class="d_keyword">is</span></span> <span class="d_keyword">null</span>);
</pre>

<p>The reason is that, the <code class="d_inline">==</code> operator may need to consult the values of the members of the objects and that attempting to access the members through a potentially <code class="d_inline">null</code> variable would cause a memory access error. For that reason, class variables must always be compared by the <code class="d_inline">is</code> and <code class="d_inline">!is</code> operators.
</p>

<h6><a id="ix_Classes.variable, class" content="variable, class"></a> <a id="ix_Classes.object, class" content="object, class"></a> Class variables versus class objects</h6>

<p>Class variable and class object are separate concepts.
</p>

<p>Class objects are constructed by the <code class="d_inline">new</code> keyword; they do not have names. The actual concept that a class type represents in a program is provided by a class object. For example, assuming that a <code class="d_inline">Student</code> class represents students by their names and grades, such information would be stored by the members of <code class="d_inline">Student</code> <i>objects</i>. Partly because they are anonymous, it is not possible to access class objects directly.
</p>

<p>A class variable on the other hand is a language feature for accessing class objects. Although it may seem syntactically that operations are being performed on a class <i>variable</i>, the operations are actually dispatched to a class <i>object</i>.
</p>

<p>Let's consider the following code that we saw previously in the <a href="value_vs_reference.html">Value Types and Reference Types chapter</a>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> variable1 = <span class="d_keyword">new</span> MyClass;
    <span class="d_keyword">auto</span> variable2 = variable1;
</pre>

<p>The <code class="d_inline">new</code> keyword constructs an anonymous class object. <code class="d_inline">variable1</code> and <code class="d_inline">variable2</code> above merely provide access to that anonymous object:
</p>

<pre class="mono"> (anonymous MyClass object)    variable1    variable2
 ───┬───────────────────┬───  ───┬───┬───  ───┬───┬───
    │        ...        │        │ o │        │ o │
 ───┴───────────────────┴───  ───┴─│─┴───  ───┴─│─┴───
              ▲                    │            │
              │                    │            │
              └────────────────────┴────────────┘
</pre>

<h6><a id="ix_Classes.copy, class" content="copy, class"></a> Copying</h6>

<p>Copying affects only the variables, not the object.
</p>

<p>Because classes are reference types, defining a new class variable as a copy of another makes two variables that provide access to the same object. The actual object is not copied.
</p>

<p>Since no object gets copied, the postblit function <code class="d_inline">this(this)</code> is not available for classes.
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> variable2 = variable1;
</pre>

<p>In the code above, <code class="d_inline">variable2</code> is being initialized by <code class="d_inline">variable1</code>. The two variables start providing access to the same object.
</p>

<p>When the actual object needs to be copied, the class must have a member function for that purpose. To be compatible with arrays, this function may be named <code class="d_inline">dup()</code>. This function must create and return a new class object. Let's see this on a class that has various types of members:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Foo {
    S      o;  <span class="d_comment">// assume S is a struct type
</span>    <span class="d_keyword">char</span>[] s;
    <span class="d_keyword">int</span>    i;

<span class="d_comment">// ...
</span>
    <span class="d_keyword">this</span>(S o, <span class="d_keyword">const</span> <span class="d_keyword">char</span>[] s, <span class="d_keyword">int</span> i) {
        <span class="d_keyword">this</span>.o = o;
        <span class="d_keyword">this</span>.s = s.dup;
        <span class="d_keyword">this</span>.i = i;
    }

    Foo dup() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> <span class="d_keyword">new</span> Foo(o, s, i);
    }
}
</pre>

<p>The <code class="d_inline">dup()</code> member function makes a new object by taking advantage of the constructor of <code class="d_inline">Foo</code> and returns the new object. Note that the constructor copies the <code class="d_inline">s</code> member explicitly by the <code class="d_inline">.dup</code> property of arrays. Being value types, <code class="d_inline">o</code> and <code class="d_inline">i</code> are copied automatically.
</p>

<p>The following code makes use of <code class="d_inline">dup()</code> to create a new object:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> var1 = <span class="d_keyword">new</span> Foo(S(1.5), <span class="d_string">"hello"</span>, 42);
    <span class="d_keyword">auto</span> var2 = var1.dup();
</pre>

<p>As a result, the objects that are associated with <code class="d_inline">var1</code> and <code class="d_inline">var2</code> are different.
</p>

<p>Similarly, an <code class="d_inline">immutable</code> copy of an object can be provided by a member function appropriately named <code class="d_inline">idup()</code>. In this case, the constructor must be defined as <code class="d_inline">pure</code> as well. We will cover the <code class="d_inline">pure</code> keyword in <a href="functions_more.html">a later chapter</a>.
</p>

<pre class="d_code"><span class="d_keyword">class</span> Foo {
<span class="d_comment">// ...
</span>    <span class="d_keyword">this</span>(S o, <span class="d_keyword">const</span> <span class="d_keyword">char</span>[] s, <span class="d_keyword">int</span> i) <span class="hilite"><span class="d_keyword">pure</span></span> {
        <span class="d_comment">// ...
</span>
    }
    <span class="d_keyword">immutable</span>(Foo) idup() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> <span class="d_keyword">new</span> <span class="d_keyword">immutable</span>(Foo)(o, s, i);
    }
}

<span class="d_comment">// ...
</span>
    <span class="d_keyword">immutable</span>(Foo) imm = var1.idup();
</pre>

<h6><a id="ix_Classes.assignment, class" content="assignment, class"></a> Assignment</h6>

<p>Just like copying, assignment affects only the variables.
</p>

<p>Assigning to a class variable disassociates that variable from its current object and associates it with a new object.
</p>

<p>If there is no other class variable that still provides access to the object that has been disassociated from, then that object is going to be destroyed some time in the future by the garbage collector.
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> variable1 = <span class="d_keyword">new</span> MyClass();
    <span class="d_keyword">auto</span> variable2 = <span class="d_keyword">new</span> MyClass();
    variable1 <span class="hilite">=</span> variable2;
</pre>

<p>The assignment above makes <code class="d_inline">variable1</code> leave its object and start providing access to <code class="d_inline">variable2</code>'s object. Since there is no other variable for <code class="d_inline">variable1</code>'s original object, that object will be destroyed by the garbage collector.
</p>

<p>The behavior of assignment cannot be changed for classes. In other words, <code class="d_inline">opAssign</code> cannot be overloaded for them.
</p>

<h6>Definition</h6>

<p>Classes are defined by the <code class="d_inline">class</code> keyword instead of the <code class="d_inline">struct</code> keyword:
</p>

<pre class="d_code"><span class="hilite"><span class="d_keyword">class</span></span> ChessPiece {
    <span class="d_comment">// ...
</span>}
</pre>

<h6>Construction</h6>

<p>As with structs, the name of the constructor is <code class="d_inline">this</code>. Unlike structs, class objects cannot be constructed by the <code class="d_inline">{&nbsp;}</code> syntax.
</p>

<pre class="d_code"><span class="d_keyword">class</span> ChessPiece {
    <span class="d_keyword">dchar</span> shape;

    <span class="d_keyword">this</span>(<span class="d_keyword">dchar</span> shape) {
        <span class="d_keyword">this</span>.shape = shape;
    }
}
</pre>

<p>Unlike structs, there is no automatic object construction where the constructor parameters are assigned to members sequentially:
</p>

<pre class="d_code"><span class="d_keyword">class</span> ChessPiece {
    <span class="d_keyword">dchar</span> shape;
    size_t value;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> king = <span class="d_keyword">new</span> ChessPiece('♔', 100);  <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
}
</pre>

<pre class="shell">Error: no constructor for ChessPiece
</pre>

<p>For that syntax to work, a constructor must be defined explicitly by the programmer.
</p>

<h6>Destruction</h6>

<p>As with structs, the name of the destructor is <code class="d_inline">~this</code>:
</p>

<pre class="d_code">    ~<span class="d_keyword">this</span>() {
        <span class="d_comment">// ...
</span>    }
</pre>

<p><a id="ix_Classes.finalizer versus destructor" content="finalizer versus destructor"></a> However, different from structs, class destructors are not executed at the time when the lifetime of a class object ends. As we have seen above, the destructor is executed some time in the future during a garbage collection cycle. (By this distinction, class destructors should have more accurately been called <i>finalizers</i>).
</p>

<p>As we will see later in <a href="memory.html">the Memory Management chapter</a>, class destructors must observe the following rules:
</p>

<ul>
<li>A class destructor must not access a member that is managed by the garbage collector. This is because garbage collectors are not required to guarantee that the object and its members are finalized in any specific order. All members may have already been finalized when the destructor is executing.</li>

<li>A class destructor must not allocate new memory that is managed by the garbage collector. This is because garbage collectors are not required to guarantee that they can allocate new objects during a garbage collection cycle.</li>

</ul>

<p>Violating these rules is undefined behavior. It is easy to see an example of such a problem simply by trying to allocate an object in a class destructor:
</p>

<pre class="d_code"><span class="d_keyword">class</span> C {
    ~<span class="d_keyword">this</span>() {
        <span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C();    <span class="d_comment">// ← WRONG: Allocates explicitly
</span>                             <span class="d_comment">//          in a class destructor
</span>    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C();
}
</pre>

<p>The program is terminated with an exception:
</p>

<pre class="shell">core.exception.<span class="hilite">InvalidMemoryOperationError</span>@(0)
</pre>

<p>It is equally wrong to allocate new memory <i>indirectly</i> from the garbage collector in a destructor. For example, memory used for the elements of a dynamic array is allocated by the garbage collector as well. Using an array in a way that would require allocating a new memory block for the elements is undefined behavior as well:
</p>

<pre class="d_code">    ~<span class="d_keyword">this</span>() {
        <span class="d_keyword">auto</span> arr = [ 1 ];    <span class="d_comment">// ← WRONG: Allocates indirectly
</span>                             <span class="d_comment">//          in a class destructor
</span>    }
</pre>

<pre class="shell">core.exception.<span class="hilite">InvalidMemoryOperationError</span>@(0)
</pre>

<h6>Member access</h6>

<p>Same as structs, the members are accessed by the <i>dot</i> operator:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> king = <span class="d_keyword">new</span> ChessPiece('♔');
    writeln(king<span class="hilite">.shape</span>);
</pre>

<p>Although the syntax makes it look as if a member of the <i>variable</i> is being accessed, it is actually the member of the <i>object</i>. Class variables do not have members, the class objects do. The <code class="d_inline">king</code> variable does not have a <code class="d_inline">shape</code> member, the anonymous object does.
</p>

<p><i><b>Note:</b> It is usually not proper to access members directly as in the code above. When that exact syntax is desired, properties should be preferred, which will be explained in <a href="property.html">a later chapter</a>.</i>
</p>

<h6>Operator overloading</h6>

<p>Other than the fact that <code class="d_inline">opAssign</code> cannot be overloaded for classes, operator overloading is the same as structs. For classes, the meaning of <code class="d_inline">opAssign</code> is always <i>associating a class variable with a class object</i>.
</p>

<h6>Member functions</h6>

<p>Although member functions are defined and used the same way as structs, there is an important difference: Class member functions can be and by-default are <i>overridable</i>. We will see this concept later in <a href="inheritance.html">the Inheritance chapter</a>.
</p>

<p><a id="ix_Classes.final" content="final"></a> As overridable member functions have a runtime performance cost, without going into more detail, I recommend that you define all <code class="d_inline">class</code> functions that do not need to be overridden with the <code class="d_inline">final</code> keyword. You can apply this guideline blindly unless there are compilation errors:
</p>

<pre class="d_code"><span class="d_keyword">class</span> C {
    <span class="hilite"><span class="d_keyword">final</span></span> <span class="d_keyword">int</span> func() {    <span class="d_comment">// ← Recommended</span>
        <span class="d_comment">// ...
</span>    }
}
</pre>

<p>Another difference from structs is that some member functions are automatically inherited from the <code class="d_inline">Object</code> class. We will see in <a href="inheritance.html">the next chapter</a> how the definition of <code class="d_inline">toString</code> can be changed by the <code class="d_inline">override</code> keyword.
</p>

<h6><a id="ix_Classes.is, operator" content="is, operator"></a> <a id="ix_Classes.!is" content="!is"></a> The <code class="d_inline">is</code> and <code class="d_inline">!is</code> operators</h6>

<p>These operators operate on class variables.
</p>

<p><code class="d_inline">is</code> specifies whether two class variables provide access to the same class object. It returns <code class="d_inline">true</code> if the object is the same and <code class="d_inline">false</code> otherwise. <code class="d_inline">!is</code> is the opposite of <code class="d_inline">is</code>.
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> myKing = <span class="d_keyword">new</span> ChessPiece('♔');
    <span class="d_keyword">auto</span> yourKing = <span class="d_keyword">new</span> ChessPiece('♔');
    <span class="d_keyword">assert</span>(myKing !<span class="d_keyword">is</span> yourKing);
</pre>

<p>Since the objects of <code class="d_inline">myKing</code> and <code class="d_inline">yourKing</code> variables are different, the <code class="d_inline">!is</code> operator returns <code class="d_inline">true</code>. Even though the two objects are constructed by the same character <code class="d_inline">'♔'</code>, they are still two separate objects.
</p>

<p>When the variables provide access to the same object, <code class="d_inline">is</code> returns <code class="d_inline">true</code>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> myKing2 = myKing;
    <span class="d_keyword">assert</span>(myKing2 <span class="d_keyword">is</span> myKing);
</pre>

<p>Both of the variables above provide access to the same object.
</p>

<h5 class="subsection">Summary</h5>

<ul>
<li>Classes and structs share common features but have big differences.
</li>

<li>Classes are reference types. The <code class="d_inline">new</code> keyword constructs an anonymous <i>class object</i> and returns a <i>class variable</i>.
</li>

<li>Class variables that are not associated with any object are <code class="d_inline">null</code>. Checking against <code class="d_inline">null</code> must be done by <code class="d_inline">is</code> or <code class="d_inline">!is</code>, not by <code class="d_inline">==</code> or <code class="d_inline">!=</code>.
</li>

<li>The act of copying associates an additional variable with an object. In order to copy class objects, the type must have a special function likely named <code class="d_inline">dup()</code>.
</li>

<li>Assignment associates a variable with an object. This behavior cannot be changed.
</li>

</ul>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 20:32:06 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

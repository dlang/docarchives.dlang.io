
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2022 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Programming in D for C++ Programmers - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Programming in D for C++ Programmers' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    
    <div class="head">        <h2>Articles</h2>
        <p class="Articles, ../articles/index.html, overview">            <a href="../articles/index.html">overview</a></p>
    </div>
    <ul><li><a href='        ../articles/faq.html'>FAQ</a></li><li><a href='        ../articles/const-faq.html'>const(FAQ)</a></li><li><a href='        ../articles/d-floating-point.html'>Floating Point</a></li><li><a href='        ../articles/warnings.html'>Warnings</a></li><li><a href='        ../articles/rationale.html'>Rationale</a></li><li><a href='        ../articles/builtin.html'>Builtin Rationale</a></li><li><a href='        ../articles/ctod.html'>C to D</a></li><li><a href='        ../articles/cpptod.html'>C++ to D</a></li><li><a href='        ../articles/pretod.html'>C Preprocessor vs D</a></li><li><a href='        ../articles/code_coverage.html'>Code coverage analysis</a></li><li><a href='        ../articles/exception-safe.html'>Exception Safety</a></li><li><a href='        ../articles/hijack.html'>Hijacking</a></li><li><a href='        ../articles/intro-to-datetime.html'>Introduction to std.datetime</a></li><li><a href='        ../articles/lazy-evaluation.html'>Lazy Evaluation</a></li><li><a href='        ../articles/migrate-to-shared.html'>Migrating to Shared</a></li><li><a href='        ../articles/mixin.html'>Mixins</a></li><li><a href='        ../articles/regular-expression.html'>Regular Expressions</a></li><li><a href='        ../articles/safed.html'>SafeD</a></li><li><a href='        ../articles/templates-revisited.html'>Templates Revisited</a></li><li><a href='        ../articles/ctarguments.html'>Compile-time Sequences</a></li><li><a href='        ../articles/variadic-function-templates.html'>Variadic Templates</a></li><li><a href='        ../articles/d-array-article.html'>D Slices</a></li><li><a href='        ../articles/cppcontracts.html'>D's Contract Programming</a></li><li><a href='        ../articles/template-comparison.html'>Template Comparison</a></li><li><a href='        ../articles/dll-linux.html'>Writing Shared Libraries
    </a></li></ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BProgramming in D for C++ Programmers%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/articles/cpptod.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Programming in D for C++ Programmers</h1>
        
        




<p>Every experienced C++ programmer accumulates a series of idioms and techniques
which become second nature. Sometimes, when learning a new language, those
idioms can be so comfortable it's hard to see how to do the equivalent in the
new language. So here's a collection of common C++ techniques, and how to do the
corresponding task in D.</p>

See also: <a href="ctod.html">Programming in D for C Programmers</a>

<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#constructors">Defining constructors</a></li>
    <li><a href="#baseclass">Base class initialization</a></li>
    <li><a href="#structcmp">Comparing structs</a></li>
    <li><a href="#typedefs">Creating a new typedef'd type</a></li>
    <li><a href="#friends">Friends</a></li>
    <li><a href="#operatoroverloading">Operator overloading</a></li>
    <li><a href="#usingdeclaration">Namespace using declarations</a></li>
    <li><a href="#raii">RAII (Resource Acquisition Is Initialization)</a></li>
    <li><a href="#properties">Properties</a></li>
    <li><a href="#recursivetemplates">Recursive Templates</a></li>
    <li><a href="#metatemplates">Meta Templates</a></li>
    <li><a href="#typetraits">Type Traits</a></li>
    <li><a href="#interfaces">Interfaces</a></li>
    <li><a href="#references">References in D</a></li>
</ol>
</div>

<hr>

<h2><a class="anchor" title="Permalink to this section" id="constructors" href="#constructors">Defining constructors</a></h2>

<h4>The C++ Way</h4>

        Constructors have the same name as the class:

<pre class="cppcode notranslate">class Foo
{
    Foo(int x);
};
</pre>

<h4>The D Way</h4>

        Constructors are defined with the <span class="d_inlinecode donthyphenate notranslate">this</span> keyword:

<pre class="d_code notranslate"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x) { }
}
</pre>

        which reflects how they are used in D.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="baseclass" href="#baseclass">Base class initialization</a></h2>

<h4>The C++ Way</h4>

        Base constructors are called using the base initializer syntax.

<pre class="cppcode notranslate">class A { A() {... } };
class B : A
{
    B(int x)
        : A()   // call base constructor
    {
        ...
    }
};</pre>

<h4>The D Way</h4>

        The base class constructor is called with the <span class="d_inlinecode donthyphenate notranslate">super</span> syntax:

<pre class="d_code notranslate"><span class="d_keyword">class</span> A { <span class="d_keyword">this</span>() { ... } }
<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x)
    {
        ...
        <span class="d_keyword">super</span>();    <span class="d_comment">// call base constructor
</span>        ...
    }
}
</pre>

        It's superior to C++ in that the base constructor call can be flexibly placed anywhere in the derived
        constructor. D can also have one constructor call another one:

<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> a;
    <span class="d_keyword">int</span> b;
    <span class="d_keyword">this</span>() { a = 7; b = foo(); }
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x)
    {
        <span class="d_keyword">this</span>();
        a = x;
    }
}
</pre>

        Members can also be initialized to constants before the constructor is ever called, so the above example is
        equivalently written as:

<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> b;
    <span class="d_keyword">this</span>() { b = foo(); }
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x)
    {
        <span class="d_keyword">this</span>();
        a = x;
    }
}
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="structcmp" href="#structcmp">Comparing structs</a></h2>

<h4>The C++ Way</h4>

        While C++ defines struct assignment in a simple, convenient manner:

<pre class="cppcode notranslate">struct A x, y;
...
x = y;
</pre>

        it does not for struct comparisons. Hence, to compare two struct
        instances for equality:

<pre class="cppcode notranslate">#include &lt;string.h&gt;

struct A x, y;

inline bool operator==(const A&amp; x, const A&amp; y)
{
    return (memcmp(&amp;x, &amp;y, sizeof(struct A)) == 0);
}
...
if (x == y)
    ...
</pre>

        <p>Note that the operator overload must be done for every struct
        needing to be compared, and the implementation of that overloaded
        operator is free of any language help with type checking.
        The C++ way has an additional problem in that just inspecting the
        (x == y) does not give a clue what is actually happening, you have
        to go and find the particular overloaded operator==() that applies
        to verify what it really does.</p>

        <p>There's a nasty bug lurking in the memcmp() implementation of operator==().
        The layout of a struct, due to alignment, can have &lsquo;holes&rsquo; in it.
        C++ does not guarantee those holes are assigned any values, and so
        two different struct instances can have the same value for each member,
        but compare different because the holes contain different garbage.</p>

        <p>To address this, the operator==() can be implemented to do a memberwise
        compare. Unfortunately, this is unreliable because (1) if a member is added
        to the struct definition one may forget to add it to operator==(), and
        (2) floating point nan values compare unequal even if their bit patterns
        match.</p>

        There just is no robust solution in C++.

<h4>The D Way</h4>

        D does it the obvious, straightforward way:

<pre class="d_code notranslate">A x, y;
...
<span class="d_keyword">if</span> (x == y)
    ...
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="typedefs" href="#typedefs">Creating a new typedef'd type</a></h2>

<h4>The C++ Way</h4>

        Typedefs in C++ are weak, that is, they really do not introduce
        a new type. The compiler doesn't distinguish between a typedef
        and its underlying type.

<pre class="cppcode notranslate">#define HANDLE_INIT     ((Handle)(-1))
typedef void *Handle;
void foo(void *);
void bar(Handle);

Handle h = HANDLE_INIT;
foo(h);         // coding bug not caught
bar(h);         // ok
</pre>

        The C++ solution is to create a dummy struct whose sole
        purpose is to get type checking and overloading on the new type.

<pre class="cppcode notranslate">#define HANDLE_INIT     ((void *)(-1))
struct Handle
{
    void *ptr;

    // default initializer
    Handle() { ptr = HANDLE_INIT; }

    Handle(int i) { ptr = (void *)i; }

    // conversion to underlying type
    operator void*() { return ptr; }
};
void bar(Handle);

Handle h;
bar(h);
h = func();
if (h != HANDLE_INIT)
    ...
</pre>

<h4>The D Way</h4>

        No need for idiomatic constructions like the above.
        You can use <a href="../phobos/std_typecons.html#.Typedef"><span class="d_inlinecode donthyphenate notranslate">std.typecons.Typedef</span></a>:

<pre class="d_code notranslate"><span class="d_keyword">alias</span> Handle = Typedef!(<span class="d_keyword">void</span>*, <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)-1);
<span class="d_keyword">void</span> bar(Handle);

Handle h;
bar(h);
h = func();
<span class="d_keyword">if</span> (h != Handle.init)
    ...
</pre>

        Unlike a bare <span class="d_inlinecode donthyphenate notranslate">alias</span>, using <a href="../phobos/std_typecons.html#.Typedef"><span class="d_inlinecode donthyphenate notranslate">std.typecons.Typedef</span></a>
        ensures the two types are not considered as equals. Note how a
        default initializer can be supplied to <a href="../phobos/std_typecons.html#.Typedef"><span class="d_inlinecode donthyphenate notranslate">std.typecons.Typedef</span></a>
        as a value of the underlying type.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="friends" href="#friends">Friends</a></h2>

<h4>The C++ Way</h4>

        Sometimes two classes are tightly related but not by inheritance,
        but need to access each other's private members. This is done
        using <span class="d_inlinecode donthyphenate notranslate">friend</span> declarations:

<pre class="cppcode notranslate">class A
{
  private:
    int a;

  public:
    int foo(B *j);
    friend class B;
    friend int abc(A *);
};

class B
{
  private:
    int b;

  public:
    int bar(A *j);
    friend class A;
};

int A::foo(B *j) { return j-&gt;b; }
int B::bar(A *j) { return j-&gt;a; }

int abc(A *p) { return p-&gt;a; }
</pre>

<h4>The D Way</h4>

        In D, friend access is implicit in being a member of the same
        module. It makes sense that tightly related classes should be
        in the same module, so implicitly granting friend access to
        other module members solves the problem neatly:

<pre class="d_code notranslate"><span class="d_keyword">module</span> X;

<span class="d_keyword">class</span> A
{
  <span class="d_keyword">private</span>:
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> a;

  <span class="d_keyword">public</span>:
    <span class="d_keyword">int</span> foo(B j) { <span class="d_keyword">return</span> j.b; }
}

<span class="d_keyword">class</span> B
{
  <span class="d_keyword">private</span>:
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> b;

  <span class="d_keyword">public</span>:
    <span class="d_keyword">int</span> bar(A j) { <span class="d_keyword">return</span> j.a; }
}

<span class="d_keyword">int</span> abc(A p) { <span class="d_keyword">return</span> p.a; }
</pre>

        The <span class="d_inlinecode donthyphenate notranslate">private</span> attribute prevents other modules from
        accessing the members.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="operatoroverloading" href="#operatoroverloading">Operator overloading</a></h2>

<h4>The C++ Way</h4>

        Given a struct that creates a new arithmetic data type,
        it's convenient to overload the comparison operators so
        it can be compared against integers:

<pre class="cppcode notranslate">struct A
{
    int operator &lt;  (int i);
    int operator &lt;= (int i);
    int operator &gt;  (int i);
    int operator &gt;= (int i);
};

int operator &lt;  (int i, A &amp;a) { return a &gt;  i; }
int operator &lt;= (int i, A &amp;a) { return a &gt;= i; }
int operator &gt;  (int i, A &amp;a) { return a &lt;  i; }
int operator &gt;= (int i, A &amp;a) { return a &lt;= i; }
</pre>

        A total of 8 functions are necessary.

<h4>The D Way</h4>

        D recognizes that the comparison operators are all fundamentally
        related to each other. So only one function is necessary:

<pre class="d_code notranslate"><span class="d_keyword">struct</span> A
{
    <span class="d_keyword">int</span> opCmp(<span class="d_keyword">int</span> i);
}
</pre>

        <p>The compiler automatically interprets all the
        &lt;, &lt;=, &gt; and &gt;=
        operators in terms of the <span class="d_inlinecode donthyphenate notranslate">cmp</span> function, as well
        as handling the cases where the left operand is not an
        object reference.</p>

        <p>Similar sensible rules hold for other operator overloads,
        making using operator overloading in D much less tedious and less
        error prone. Far less code needs to be written to accomplish
        the same effect.</p>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="usingdeclaration" href="#usingdeclaration">Namespace using declarations</a></h2>

<h4>The C++ Way</h4>

        A <i>using-declaration</i> in C++ is used to bring a name from
        a namespace scope into the current scope:

<pre class="cppcode notranslate">namespace foo
{
    int x;
}
using foo::x;
</pre>

<h4>The D Way</h4>

        D uses modules instead of namespaces and #include files, and
        alias declarations take the place of using declarations:

<pre class="d_code notranslate"><span class="d_comment">/** Module foo.d **/</span>
<span class="d_keyword">module</span> foo;
<span class="d_keyword">int</span> x;

<span class="d_comment">/** Another module **/</span>
<span class="d_keyword">import</span> foo;
<span class="d_keyword">alias</span> x = foo.x;
</pre>

        Alias is a much more flexible than the single purpose using
        declaration. Alias can be used to rename symbols, refer to
        template members, refer to nested class types, etc.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="raii" href="#raii">RAII (Resource Acquisition Is Initialization)</a></h2>

<h4>The C++ Way</h4>

        In C++, resources like memory, etc., all need to be handled
        explicitly. Since destructors automatically get called when
        leaving a scope, RAII is implemented by putting the resource
        release code into the destructor:

<pre class="cppcode notranslate">class File
{
    Handle *h;

    ~File()
    {
        h-&gt;release();
    }
};
</pre>

<h4>The D Way</h4>

        <p>The bulk of resource release problems are simply keeping track
        of and freeing memory. This is handled automatically in D by
        the garbage collector. The second common resources used are semaphores
        and locks, handled automatically with D's <span class="d_inlinecode donthyphenate notranslate">synchronized</span>
        declarations and statements.</p>

        <p>The few RAII issues left are handled by <span class="d_inlinecode donthyphenate notranslate">struct</span>s.
        A <span class="d_inlinecode donthyphenate notranslate">struct</span> gets its destructor run when it goes out of scope.</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> File
{
    Handle h;

    ~<span class="d_keyword">this</span>()
    {
        h.release();
    }
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">if</span> (...)
    {
        <span class="d_keyword">auto</span> f = File();
        ...
    } <span class="d_comment">// f.~this() gets run at closing brace, even if
</span>      <span class="d_comment">// scope was exited via a thrown exception
</span>}
</pre>

<p><span class="d_inlinecode donthyphenate notranslate">class</span>es are typically managed by the garbage collector which doesn't
lend itself to RAII. If you need deterministic destruction with <span class="d_inlinecode donthyphenate notranslate">class</span>es
you can use <a href="../phobos/std_typecons.html#.scoped"><span class="d_inlinecode donthyphenate notranslate">std.typecons.scoped</span></a> (which will also allocate the
<span class="d_inlinecode donthyphenate notranslate">class</span> on the stack instead of the garbage collector managed heap).</p>

<p>See also <a href="../spec/statement.html#ScopeGuardStatement"><i>ScopeGuardStatement</i></a> for a more generalized
mechanism that lets you run arbitrary statements whenever leaving the current
scope.</p>


<hr>
<h2><a class="anchor" title="Permalink to this section" id="properties" href="#properties">Properties</a></h2>

<h4>The C++ Way</h4>

        It is common practice to define a field,
        along with object-oriented
        get and set functions for it:

<pre class="cppcode notranslate">class Abc
{
  public:
    void setProperty(int newproperty) { property = newproperty; }
    int getProperty() { return property; }

  private:
    int property;
};

Abc a;
a.setProperty(3);
int x = a.getProperty();
</pre>

        All this is quite a bit of typing, and it tends to make
        code unreadable by filling
        it with getProperty() and setProperty() calls.

<h4>The D Way</h4>

        Properties can be get and set using the normal field syntax,
        yet the get and set will invoke methods instead.

<pre class="d_code notranslate"><span class="d_keyword">class</span> Abc
{
    <span class="d_comment">// set
</span>    @property <span class="d_keyword">void</span> property(<span class="d_keyword">int</span> newproperty) { myprop = newproperty; }

    <span class="d_comment">// get
</span>    @property <span class="d_keyword">int</span> property() { <span class="d_keyword">return</span> myprop; }

  <span class="d_keyword">private</span>:
    <span class="d_keyword">int</span> myprop;
}
</pre>

        which is used as:

<pre class="d_code notranslate">Abc a = <span class="d_keyword">new</span> Abc;
a.property = 3;
<span class="d_keyword">int</span> x = a.property;
</pre>

        Thus, in D a property is treated like it was a simple field name.
        A property can start out actually being a simple field name,
        but if later it becomes
        necessary to make getting and setting it function calls,
        no code needs to be modified other
        than the class definition.
        It obviates the wordy practice of defining get and set properties
        &lsquo;just in case&rsquo; a derived class should need to override them.
        It's also a way to have interface classes, which do not have
        data fields, behave syntactically as if they did.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="recursivetemplates" href="#recursivetemplates">Recursive Templates</a></h2>

<h4>The C++ Way</h4>

        An advanced use of templates is to recursively expand
        them, relying on specialization to end it. A template
        to compute a factorial would be:

<pre class="cppcode notranslate">template&lt;int n&gt; class factorial
{
  public:
    enum { result = n * factorial&lt;n - 1&gt;::result };
};

template&lt;&gt; class factorial&lt;1&gt;
{
  public:
    enum { result = 1 };
};

void test()
{
    printf("%d\n", factorial&lt;4&gt;::result); // prints 24
}
</pre>

<h4>The D Way</h4>

        The D version is analogous, though a little simpler, taking
        advantage of
        <a href="https://dlang.org/spec/template.html#implicit_template_properties">        Eponymous Templates</a> - promotion of single template members to the
        enclosing name space:
<pre class="d_code notranslate"><span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n)
{
    <span class="d_keyword">enum</span> factorial = n * .factorial!(n-1);
}

<span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n : 1)
{
    <span class="d_keyword">enum</span> factorial = 1;
}

<span class="d_keyword">void</span> test()
{
    writeln(factorial!(4));  <span class="d_comment">// prints 24
</span>}
</pre>
        The template blocks can be made shorter using
        <a href="https://dlang.org/spec/template.html#variable-template">        Enum Template</a> syntax:
<pre class="d_code notranslate"><span class="d_keyword">enum</span> factorial(<span class="d_keyword">int</span> n) = n * .factorial!(n-1);

<span class="d_keyword">enum</span> factorial(<span class="d_keyword">int</span> n : 1) = 1;
</pre>

<hr>

<h2><a class="anchor" title="Permalink to this section" id="metatemplates" href="#metatemplates">Meta Templates</a></h2>

        The problem: create a typedef for a signed integral type that is at
        least <i>nbits</i> in size.

<h4>The C++ Way</h4>

        <p>This example is simplified and adapted from one written by
        Dr. Carlo Pescio in
        <a href="http://www.eptacom.net/pubblicazioni/pub_eng/paramint.html">
        Template Metaprogramming: Make parameterized integers portable with this novel technique</a>.</p>

        <p>There is no way in C++ to do conditional compilation based
        on the result of an expression based on template parameters, so
        all control flow follows from pattern matching of the template
        argument against various explicit template specializations.
        Even worse, there is no way to do template specializations based
        on relationships like "less than or equal to", so the example
        uses a clever technique where the template is recursively expanded,
        incrementing the template value argument by one each time, until
        a specialization matches.
        If there is no match, the result is an unhelpful recursive compiler
        stack overflow or internal error, or at best a strange syntax
        error.</p>

        A preprocessor macro is also needed to make up for the lack
        of template typedefs.

<pre class="cppcode notranslate">#include &lt;limits.h&gt;

template&lt; int nbits &gt; struct Integer
{
    typedef Integer&lt; nbits + 1 &gt; :: int_type int_type ;
};

struct Integer&lt; 8 &gt;
{
    typedef signed char int_type ;
};

struct Integer&lt; 16 &gt;
{
    typedef short int_type ;
};

struct Integer&lt; 32 &gt;
{
    typedef long int_type ;
};

struct Integer&lt; 64 &gt;
{
    typedef long long int_type ;
};

// If the required size is not supported, the metaprogram
// will increase the counter until an internal error is
// signaled, or INT_MAX is reached. The INT_MAX
// specialization does not define a int_type, so a
// compiling error is always generated
struct Integer&lt; INT_MAX &gt;
{
};

// A bit of syntactic sugar
#define Integer( nbits ) Integer&lt; nbits &gt; :: int_type

#include &lt;stdio.h&gt;

int main()
{
    Integer( 8 ) i ;
    Integer( 16 ) j ;
    Integer( 29 ) k ;
    Integer( 64 ) l ;
    printf("%d %d %d %d\n",
        sizeof(i), sizeof(j), sizeof(k), sizeof(l));
    return 0 ;
}
</pre>

<h4>The C++ Boost Way</h4>

        This version uses the C++ Boost library. It was provided
        by David Abrahams.

<pre class="cppcode notranslate">#include &lt;boost/mpl/if.hpp&gt;
#include &lt;boost/mpl/assert.hpp&gt;

template &lt;int nbits&gt; struct Integer
    : mpl::if_c&lt;(nbits &lt;= 8), signed char
    , mpl::if_c&lt;(nbits &lt;= 16), short
    , mpl::if_c&lt;(nbits &lt;= 32), long
    , long long&gt;::type &gt;::type &gt;
{
    BOOST_MPL_ASSERT_RELATION(nbits, &lt;=, 64);
}

#include &lt;stdio.h&gt;

int main()
{
    Integer&lt; 8 &gt; i ;
    Integer&lt; 16 &gt; j ;
    Integer&lt; 29 &gt; k ;
    Integer&lt; 64 &gt; l ;
    printf("%d %d %d %d\n", sizeof(i), sizeof(j), sizeof(k), sizeof(l));
    return 0 ;
}
</pre>

<h4>The D Way</h4>

        The D version could also be written with recursive templates,
        but there's a better way.
        Unlike the C++ example, this one is fairly easy to
        figure out what is going on.
        It compiles quickly, and gives a sensible compile time message
        if it fails.

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">template</span> Integer(<span class="d_keyword">int</span> nbits)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 8)
        <span class="d_keyword">alias</span> Integer = <span class="d_keyword">byte</span>;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 16)
        <span class="d_keyword">alias</span> Integer = <span class="d_keyword">short</span>;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 32)
        <span class="d_keyword">alias</span> Integer = <span class="d_keyword">int</span>;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 64)
        <span class="d_keyword">alias</span> Integer = <span class="d_keyword">long</span>;
    <span class="d_keyword">else</span>
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0);
}

<span class="d_keyword">int</span> main()
{
    Integer!(8) i ;
    Integer!(16) j ;
    Integer!(29) k ;
    Integer!(64) l ;
    writefln(<span class="d_string">"%d %d %d %d"</span>, i.sizeof, j.sizeof, k.sizeof, l.sizeof);
    <span class="d_keyword">return</span> 0;
}
</pre>

<hr>

<h2><a class="anchor" title="Permalink to this section" id="typetraits" href="#typetraits">Type Traits</a></h2>

        Type traits are another term for being able to find out
        properties of a type at compile time.

<h4>The C++ Way</h4>

        The following template comes from
        <a href="https://www.amazon.com/exec/obidos/ASIN/0201734842/ref=ase_classicempire/102-2957199-2585768">
        C++ Templates: The Complete Guide, David Vandevoorde, Nicolai M. Josuttis</a>
        pg. 353 which determines if the template's argument type
        is a function:

<pre class="cppcode notranslate">template&lt;typename T&gt; class IsFunctionT
{
  private:
    typedef char One;
    typedef struct { char a[2]; } Two;
    template&lt;typename U&gt; static One test(...);
    template&lt;typename U&gt; static Two test(U (*)[1]);
  public:
    enum { Yes = sizeof(IsFunctionT&lt;T&gt;::test&lt;T&gt;(0)) == 1 };
};

void test()
{
    typedef int (fp)(int);

    assert(IsFunctionT&lt;fp&gt;::Yes == 1);
}
</pre>

        This template relies on the <a href="http://dlang.org/glossary.html#sfinae"><acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)</a> principle.
        Why it works is a fairly advanced template topic.

<h4>The D Way</h4>

        <acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)
        can be done in D without resorting to template argument
        pattern matching:

<pre class="d_code notranslate"><span class="d_keyword">template</span> IsFunctionT(T)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(T[]) )
        <span class="d_keyword">const</span> <span class="d_keyword">int</span> IsFunctionT = 0;
    <span class="d_keyword">else</span>
        <span class="d_keyword">const</span> <span class="d_keyword">int</span> IsFunctionT = 1;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> <span class="d_keyword">int</span> fp(<span class="d_keyword">int</span>);

    <span class="d_keyword">assert</span>(IsFunctionT!(fp) == 1);
}
</pre>

        The task of discovering if a type is a function doesn't need a
        template at all, nor does it need the subterfuge of attempting to
        create the invalid array of functions type.
        The <a href="../spec/expression.html#IsExpression"><i>IsExpression</i></a> expression can test it directly:

<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> <span class="d_keyword">int</span> fp(<span class="d_keyword">int</span>);

    <span class="d_keyword">assert</span>( <span class="d_keyword">is</span>(fp == <span class="d_keyword">function</span>) );
}
</pre>

<hr>

<h2><a class="anchor" title="Permalink to this section" id="interfaces" href="#interfaces">Interfaces</a></h2>


Interfaces in C++ are used to describe the behaviour or capabilities of any class
that implements the interface, without committing to a particular implementation
of the interface's declared methods.

<h4>Interfaces in C++</h4>

        "C++ interfaces are implemented by means of <i>abstract classes</i>. An abstract class
        defines interface methods as pure virtual functions. A class implementing the interface
        inherits from the abstract class and implements its pure virtual functions."

<pre class="cppcode notranslate">class Interface {
  public:
    virtual int method() = 0;
};

class FirstVariant : public Interface {
  public:
    int method() {
      ...
    }
};

class SecondVariant : public Interface {
  public:
    int method() {
      ...
    }
};
</pre>

The interface is used as follows:

<pre class="cppcode notranslate">FirstVariant FirstVariant;
SecondVariant SecondVariant;

FirstVariant.method();
SecondVariant.method();
</pre>

<h4>Interfaces in D</h4>

        In D, interfaces <a href="https://wiki.dlang.org/Books">Alexandrescu 2010, p. 212; Cehreli 2017, p. 347</a>
        are implemented with the help of the <span class="d_inlinecode donthyphenate notranslate">interface</span> keyword, which introduces a class containing
        mainly unimplemented method declarations (non-static method definitions and non-static data
        members are not allowed). The implementation class inherits one or more interfaces and
        implements the interface methods.

<pre class="d_code notranslate"><span class="d_keyword">interface</span> Interface {
  <span class="d_keyword">int</span> method();
}

<span class="d_keyword">class</span> FirstVariant : Interface {
  <span class="d_keyword">int</span> method() {
    ...
  }
}

<span class="d_keyword">class</span> SecondVariant : Interface {
  <span class="d_keyword">int</span> method() {
    ...
  }
}
</pre>

  The interface is used as follows:

<pre class="d_code notranslate">FirstVariant FirstVariant = <span class="d_keyword">new</span> FirstVariant();
SecondVariant SecondVariant = <span class="d_keyword">new</span> SecondVariant();

FirstVariant.method();
SecondVariant.method();
</pre>


<hr>

<h2><a class="anchor" title="Permalink to this section" id="references" href="#references">References in D</a></h2>


        D doesn't have a (C++-style) concept of references as part of the type. Arguments can be passed by reference - hence the <span class="d_inlinecode donthyphenate notranslate">ref</span> keyword, but "free" references don't exist in the language.

        The <span class="d_inlinecode donthyphenate notranslate">ref</span> in <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop variables can be conceptually thought of as a parameter to the loop body as well. (For <span class="d_inlinecode donthyphenate notranslate">opApply</span> based iteration, the loop body indeed gets turned into a function; for "plain" iteration the compiler AST internally has special <span class="d_inlinecode donthyphenate notranslate">ref</span> variables, but they are not visible to the language.)

        In the below code, <span class="d_inlinecode donthyphenate notranslate">d2</span> is a value copy of <span class="d_inlinecode donthyphenate notranslate">gallery[0]</span> and is not a reference.

<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">module</span> test;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">struct</span> Data
    {
        <span class="d_keyword">int</span> id;
    }

    <span class="d_keyword">import</span> std.container.array : Array;
    Array!Data gallery;

    Data d1;
    gallery.insertBack(d1);

    <span class="d_keyword">auto</span> d2 = gallery[0];
    d2.id = 1;
    <span class="d_keyword">assert</span>(d2.id == gallery[0].id, <span class="d_string">"neither ref nor pointer"</span>);
}
</pre>

</div>

        Instead of trying to get a reference in such a case, get a pointer. After all, you don't have to use <span class="d_inlinecode donthyphenate notranslate">-&gt;</span> operator in D, which is nice in syntax.

<pre class="d_code notranslate">    <span class="d_keyword">auto</span> d2 = &amp;gallery[0];
</pre>




        <div class="smallprint" id="copyright">Copyright &copy; 1999-2022 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

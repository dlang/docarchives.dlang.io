
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>std.traits - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="stylesheet" href="../css/cssmenu.css">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='std.traits' class='std'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top">	<div id="header">		<img src="../images/hamburger.svg" id="mobile-hamburger">
		<a class="logo" href=".."><img id="logo" width="125" height="95" alt="D Logo" src="../images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href=".." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    
    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search" tabindex="1000"></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option  value="dlang.org/spec">Language Reference</option>
                    <option selected value="dlang.org/phobos">Library Reference</option>
                    <option  value="forum.dlang.org">Discussion Forums</option>
                    
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='index.html'><span>D Lib Prerelease</span></a></li>
    <li><a href='../phobos/index.html'><span>Current Release (2.070.0)</span></a></li>
    
<li><a href='object.html'><span><em class="tt">object</em></span></a></li>

<li class='has-sub'><a href='#'><span><em class="tt">std</em></span></a>
<ul><li>  <a href="std_algorithm.html" title="std.algorithm"><span class="d_inlinecode donthyphenate notranslate">algorithm</span></a><ul><li>    <a href="std_algorithm_comparison.html" title="std.algorithm.comparison"><span class="d_inlinecode donthyphenate notranslate">comparison</span></a></li><li>    <a href="std_algorithm_iteration.html" title="std.algorithm.iteration"><span class="d_inlinecode donthyphenate notranslate">iteration</span></a></li><li>    <a href="std_algorithm_mutation.html" title="std.algorithm.mutation"><span class="d_inlinecode donthyphenate notranslate">mutation</span></a></li><li>    <a href="std_algorithm_searching.html" title="std.algorithm.searching"><span class="d_inlinecode donthyphenate notranslate">searching</span></a></li><li>    <a href="std_algorithm_setops.html" title="std.algorithm.setops"><span class="d_inlinecode donthyphenate notranslate">setops</span></a></li><li>    <a href="std_algorithm_sorting.html" title="std.algorithm.sorting"><span class="d_inlinecode donthyphenate notranslate">sorting</span></a>
  </li></ul></li><li>  <a href="std_array.html" title="std.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>  <a href="std_ascii.html" title="std.ascii"><span class="d_inlinecode donthyphenate notranslate">ascii</span></a></li><li>  <a href="std_base64.html" title="std.base64"><span class="d_inlinecode donthyphenate notranslate">base64</span></a></li><li>  <a href="std_bigint.html" title="std.bigint"><span class="d_inlinecode donthyphenate notranslate">bigint</span></a></li><li>  <a href="std_bitmanip.html" title="std.bitmanip"><span class="d_inlinecode donthyphenate notranslate">bitmanip</span></a></li><li>  <a href="std_compiler.html" title="std.compiler"><span class="d_inlinecode donthyphenate notranslate">compiler</span></a></li><li>  <a href="std_complex.html" title="std.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>  <a href="std_concurrency.html" title="std.concurrency"><span class="d_inlinecode donthyphenate notranslate">concurrency</span></a></li><li>  <a href="std_concurrencybase.html" title="std.concurrencybase"><span class="d_inlinecode donthyphenate notranslate">concurrencybase</span></a></li><li>  <a href="std_container.html" title="std.container"><span class="d_inlinecode donthyphenate notranslate">container</span></a><ul><li>    <a href="std_container_array.html" title="std.container.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>    <a href="std_container_binaryheap.html" title="std.container.binaryheap"><span class="d_inlinecode donthyphenate notranslate">binaryheap</span></a></li><li>    <a href="std_container_dlist.html" title="std.container.dlist"><span class="d_inlinecode donthyphenate notranslate">dlist</span></a></li><li>    <a href="std_container_rbtree.html" title="std.container.rbtree"><span class="d_inlinecode donthyphenate notranslate">rbtree</span></a></li><li>    <a href="std_container_slist.html" title="std.container.slist"><span class="d_inlinecode donthyphenate notranslate">slist</span></a></li><li>    <a href="std_container_util.html" title="std.container.util"><span class="d_inlinecode donthyphenate notranslate">util</span></a>
  </li></ul></li><li>  <a href="std_conv.html" title="std.conv"><span class="d_inlinecode donthyphenate notranslate">conv</span></a></li><li>  <a href="std_csv.html" title="std.csv"><span class="d_inlinecode donthyphenate notranslate">csv</span></a></li><li>  <a href="std_datetime.html" title="std.datetime"><span class="d_inlinecode donthyphenate notranslate">datetime</span></a></li><li>  <a href="std_demangle.html" title="std.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">digest</span></h7><ul><li>    <a href="std_digest_crc.html" title="std.digest.crc"><span class="d_inlinecode donthyphenate notranslate">crc</span></a></li><li>    <a href="std_digest_digest.html" title="std.digest.digest"><span class="d_inlinecode donthyphenate notranslate">digest</span></a></li><li>    <a href="std_digest_hmac.html" title="std.digest.hmac"><span class="d_inlinecode donthyphenate notranslate">hmac</span></a></li><li>    <a href="std_digest_md.html" title="std.digest.md"><span class="d_inlinecode donthyphenate notranslate">md</span></a></li><li>    <a href="std_digest_ripemd.html" title="std.digest.ripemd"><span class="d_inlinecode donthyphenate notranslate">ripemd</span></a></li><li>    <a href="std_digest_sha.html" title="std.digest.sha"><span class="d_inlinecode donthyphenate notranslate">sha</span></a>
  </li></ul></li><li>  <a href="std_encoding.html" title="std.encoding"><span class="d_inlinecode donthyphenate notranslate">encoding</span></a></li><li>  <a href="std_exception.html" title="std.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">experimental</span></h7><ul><li>    <a href="std_experimental_allocator.html" title="std.experimental.allocator"><span class="d_inlinecode donthyphenate notranslate">allocator</span></a><ul><li>      <a href="std_experimental_allocator_building_blocks.html" title="std.experimental.allocator.building_blocks"><span class="d_inlinecode donthyphenate notranslate">building_blocks</span></a><ul><li>        <a href="std_experimental_allocator_building_blocks_affix_allocator.html" title="std.experimental.allocator.building_blocks.affix_allocator"><span class="d_inlinecode donthyphenate notranslate">affix_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_allocator_list.html" title="std.experimental.allocator.building_blocks.allocator_list"><span class="d_inlinecode donthyphenate notranslate">allocator_list</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_bitmapped_block.html" title="std.experimental.allocator.building_blocks.bitmapped_block"><span class="d_inlinecode donthyphenate notranslate">bitmapped_block</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_bucketizer.html" title="std.experimental.allocator.building_blocks.bucketizer"><span class="d_inlinecode donthyphenate notranslate">bucketizer</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_fallback_allocator.html" title="std.experimental.allocator.building_blocks.fallback_allocator"><span class="d_inlinecode donthyphenate notranslate">fallback_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_free_list.html" title="std.experimental.allocator.building_blocks.free_list"><span class="d_inlinecode donthyphenate notranslate">free_list</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_free_tree.html" title="std.experimental.allocator.building_blocks.free_tree"><span class="d_inlinecode donthyphenate notranslate">free_tree</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_kernighan_ritchie.html" title="std.experimental.allocator.building_blocks.kernighan_ritchie"><span class="d_inlinecode donthyphenate notranslate">kernighan_ritchie</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_null_allocator.html" title="std.experimental.allocator.building_blocks.null_allocator"><span class="d_inlinecode donthyphenate notranslate">null_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_quantizer.html" title="std.experimental.allocator.building_blocks.quantizer"><span class="d_inlinecode donthyphenate notranslate">quantizer</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_region.html" title="std.experimental.allocator.building_blocks.region"><span class="d_inlinecode donthyphenate notranslate">region</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_scoped_allocator.html" title="std.experimental.allocator.building_blocks.scoped_allocator"><span class="d_inlinecode donthyphenate notranslate">scoped_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_segregator.html" title="std.experimental.allocator.building_blocks.segregator"><span class="d_inlinecode donthyphenate notranslate">segregator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_stats_collector.html" title="std.experimental.allocator.building_blocks.stats_collector"><span class="d_inlinecode donthyphenate notranslate">stats_collector</span></a>
      </li></ul></li><li>      <a href="std_experimental_allocator_common.html" title="std.experimental.allocator.common"><span class="d_inlinecode donthyphenate notranslate">common</span></a></li><li>      <a href="std_experimental_allocator_gc_allocator.html" title="std.experimental.allocator.gc_allocator"><span class="d_inlinecode donthyphenate notranslate">gc_allocator</span></a></li><li>      <a href="std_experimental_allocator_mallocator.html" title="std.experimental.allocator.mallocator"><span class="d_inlinecode donthyphenate notranslate">mallocator</span></a></li><li>      <a href="std_experimental_allocator_mmap_allocator.html" title="std.experimental.allocator.mmap_allocator"><span class="d_inlinecode donthyphenate notranslate">mmap_allocator</span></a></li><li>      <a href="std_experimental_allocator_showcase.html" title="std.experimental.allocator.showcase"><span class="d_inlinecode donthyphenate notranslate">showcase</span></a></li><li>      <a href="std_experimental_allocator_typed.html" title="std.experimental.allocator.typed"><span class="d_inlinecode donthyphenate notranslate">typed</span></a>
    </li></ul></li><li>    <a href="std_experimental_logger.html" title="std.experimental.logger"><span class="d_inlinecode donthyphenate notranslate">logger</span></a><ul><li>      <a href="std_experimental_logger_core.html" title="std.experimental.logger.core"><span class="d_inlinecode donthyphenate notranslate">core</span></a></li><li>      <a href="std_experimental_logger_filelogger.html" title="std.experimental.logger.filelogger"><span class="d_inlinecode donthyphenate notranslate">filelogger</span></a></li><li>      <a href="std_experimental_logger_multilogger.html" title="std.experimental.logger.multilogger"><span class="d_inlinecode donthyphenate notranslate">multilogger</span></a></li><li>      <a href="std_experimental_logger_nulllogger.html" title="std.experimental.logger.nulllogger"><span class="d_inlinecode donthyphenate notranslate">nulllogger</span></a>
    </li></ul></li><li>    <a href="std_experimental_ndslice.html" title="std.experimental.ndslice"><span class="d_inlinecode donthyphenate notranslate">ndslice</span></a><ul><li>      <a href="std_experimental_ndslice_iteration.html" title="std.experimental.ndslice.iteration"><span class="d_inlinecode donthyphenate notranslate">iteration</span></a></li><li>      <a href="std_experimental_ndslice_selection.html" title="std.experimental.ndslice.selection"><span class="d_inlinecode donthyphenate notranslate">selection</span></a></li><li>      <a href="std_experimental_ndslice_slice.html" title="std.experimental.ndslice.slice"><span class="d_inlinecode donthyphenate notranslate">slice</span></a>
    </li></ul>
  </li></ul></li><li>  <a href="std_file.html" title="std.file"><span class="d_inlinecode donthyphenate notranslate">file</span></a></li><li>  <a href="std_format.html" title="std.format"><span class="d_inlinecode donthyphenate notranslate">format</span></a></li><li>  <a href="std_functional.html" title="std.functional"><span class="d_inlinecode donthyphenate notranslate">functional</span></a></li><li>  <a href="std_getopt.html" title="std.getopt"><span class="d_inlinecode donthyphenate notranslate">getopt</span></a></li><li>  <a href="std_json.html" title="std.json"><span class="d_inlinecode donthyphenate notranslate">json</span></a></li><li>  <a href="std_math.html" title="std.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="std_mathspecial.html" title="std.mathspecial"><span class="d_inlinecode donthyphenate notranslate">mathspecial</span></a></li><li>  <a href="std_meta.html" title="std.meta"><span class="d_inlinecode donthyphenate notranslate">meta</span></a></li><li>  <a href="std_mmfile.html" title="std.mmfile"><span class="d_inlinecode donthyphenate notranslate">mmfile</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">net</span></h7><ul><li>    <a href="std_net_curl.html" title="std.net.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="std_net_isemail.html" title="std.net.isemail"><span class="d_inlinecode donthyphenate notranslate">isemail</span></a>
  </li></ul></li><li>  <a href="std_numeric.html" title="std.numeric"><span class="d_inlinecode donthyphenate notranslate">numeric</span></a></li><li>  <a href="std_outbuffer.html" title="std.outbuffer"><span class="d_inlinecode donthyphenate notranslate">outbuffer</span></a></li><li>  <a href="std_parallelism.html" title="std.parallelism"><span class="d_inlinecode donthyphenate notranslate">parallelism</span></a></li><li>  <a href="std_path.html" title="std.path"><span class="d_inlinecode donthyphenate notranslate">path</span></a></li><li>  <a href="std_process.html" title="std.process"><span class="d_inlinecode donthyphenate notranslate">process</span></a></li><li>  <a href="std_random.html" title="std.random"><span class="d_inlinecode donthyphenate notranslate">random</span></a></li><li>  <a href="std_range.html" title="std.range"><span class="d_inlinecode donthyphenate notranslate">range</span></a><ul><li>    <a href="std_range_interfaces.html" title="std.range.interfaces"><span class="d_inlinecode donthyphenate notranslate">interfaces</span></a></li><li>    <a href="std_range_primitives.html" title="std.range.primitives"><span class="d_inlinecode donthyphenate notranslate">primitives</span></a>
  </li></ul></li><li>  <a href="std_regex.html" title="std.regex"><span class="d_inlinecode donthyphenate notranslate">regex</span></a></li><li>  <a href="std_signals.html" title="std.signals"><span class="d_inlinecode donthyphenate notranslate">signals</span></a></li><li>  <a href="std_socket.html" title="std.socket"><span class="d_inlinecode donthyphenate notranslate">socket</span></a></li><li>  <a href="std_stdint.html" title="std.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>  <a href="std_stdio.html" title="std.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>  <a href="std_stdiobase.html" title="std.stdiobase"><span class="d_inlinecode donthyphenate notranslate">stdiobase</span></a></li><li>  <a href="std_string.html" title="std.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>  <a href="std_syserror.html" title="std.syserror"><span class="d_inlinecode donthyphenate notranslate">syserror</span></a></li><li>  <a href="std_system.html" title="std.system"><span class="d_inlinecode donthyphenate notranslate">system</span></a></li><li>  <a href="std_traits.html" title="std.traits"><span class="d_inlinecode donthyphenate notranslate">traits</span></a></li><li>  <a href="std_typecons.html" title="std.typecons"><span class="d_inlinecode donthyphenate notranslate">typecons</span></a></li><li>  <a href="std_typetuple.html" title="std.typetuple"><span class="d_inlinecode donthyphenate notranslate">typetuple</span></a></li><li>  <a href="std_uni.html" title="std.uni"><span class="d_inlinecode donthyphenate notranslate">uni</span></a></li><li>  <a href="std_uri.html" title="std.uri"><span class="d_inlinecode donthyphenate notranslate">uri</span></a></li><li>  <a href="std_utf.html" title="std.utf"><span class="d_inlinecode donthyphenate notranslate">utf</span></a></li><li>  <a href="std_uuid.html" title="std.uuid"><span class="d_inlinecode donthyphenate notranslate">uuid</span></a></li><li>  <a href="std_variant.html" title="std.variant"><span class="d_inlinecode donthyphenate notranslate">variant</span></a></li><li>  <a href="std_xml.html" title="std.xml"><span class="d_inlinecode donthyphenate notranslate">xml</span></a></li><li>  <a href="std_zip.html" title="std.zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a></li><li>  <a href="std_zlib.html" title="std.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
</li></ul>
</li>

<li class='has-sub'><a href='#'><span><em class="tt">etc</em></span></a>
<ul><li>  <h7><span class="d_inlinecode donthyphenate notranslate">c</span></h7><ul><li>    <a href="etc_c_curl.html" title="etc.c.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <h7><span class="d_inlinecode donthyphenate notranslate">odbc</span></h7><ul><li>      <a href="etc_c_odbc_sql.html" title="etc.c.odbc.sql"><span class="d_inlinecode donthyphenate notranslate">sql</span></a></li><li>      <a href="etc_c_odbc_sqlext.html" title="etc.c.odbc.sqlext"><span class="d_inlinecode donthyphenate notranslate">sqlext</span></a></li><li>      <a href="etc_c_odbc_sqltypes.html" title="etc.c.odbc.sqltypes"><span class="d_inlinecode donthyphenate notranslate">sqltypes</span></a></li><li>      <a href="etc_c_odbc_sqlucode.html" title="etc.c.odbc.sqlucode"><span class="d_inlinecode donthyphenate notranslate">sqlucode</span></a>
    </li></ul></li><li>    <a href="etc_c_sqlite3.html" title="etc.c.sqlite3"><span class="d_inlinecode donthyphenate notranslate">sqlite3</span></a></li><li>    <a href="etc_c_zlib.html" title="etc.c.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
  </li></ul>
</li></ul>
</li>

<li class='has-sub'><a href='#'><span><em class="tt">core</em></span></a>
<ul><li>  <a href="core_atomic.html" title="core.atomic"><span class="d_inlinecode donthyphenate notranslate">atomic</span></a></li><li>  <a href="core_attribute.html" title="core.attribute"><span class="d_inlinecode donthyphenate notranslate">attribute</span></a></li><li>  <a href="core_bitop.html" title="core.bitop"><span class="d_inlinecode donthyphenate notranslate">bitop</span></a></li><li>  <a href="core_checkedint.html" title="core.checkedint"><span class="d_inlinecode donthyphenate notranslate">checkedint</span></a></li><li>  <a href="core_cpuid.html" title="core.cpuid"><span class="d_inlinecode donthyphenate notranslate">cpuid</span></a></li><li>  <a href="core_demangle.html" title="core.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <a href="core_exception.html" title="core.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="core_math.html" title="core.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="core_memory.html" title="core.memory"><span class="d_inlinecode donthyphenate notranslate">memory</span></a></li><li>  <a href="core_runtime.html" title="core.runtime"><span class="d_inlinecode donthyphenate notranslate">runtime</span></a></li><li>  <a href="core_simd.html" title="core.simd"><span class="d_inlinecode donthyphenate notranslate">simd</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">stdc</span></h7><ul><li>    <a href="core_stdc_complex.html" title="core.stdc.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>    <a href="core_stdc_ctype.html" title="core.stdc.ctype"><span class="d_inlinecode donthyphenate notranslate">ctype</span></a></li><li>    <a href="core_stdc_errno.html" title="core.stdc.errno"><span class="d_inlinecode donthyphenate notranslate">errno</span></a></li><li>    <a href="core_stdc_fenv.html" title="core.stdc.fenv"><span class="d_inlinecode donthyphenate notranslate">fenv</span></a></li><li>    <a href="core_stdc_float_.html" title="core.stdc.float_"><span class="d_inlinecode donthyphenate notranslate">float_</span></a></li><li>    <a href="core_stdc_inttypes.html" title="core.stdc.inttypes"><span class="d_inlinecode donthyphenate notranslate">inttypes</span></a></li><li>    <a href="core_stdc_limits.html" title="core.stdc.limits"><span class="d_inlinecode donthyphenate notranslate">limits</span></a></li><li>    <a href="core_stdc_locale.html" title="core.stdc.locale"><span class="d_inlinecode donthyphenate notranslate">locale</span></a></li><li>    <a href="core_stdc_math.html" title="core.stdc.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>    <a href="core_stdc_signal.html" title="core.stdc.signal"><span class="d_inlinecode donthyphenate notranslate">signal</span></a></li><li>    <a href="core_stdc_stdarg.html" title="core.stdc.stdarg"><span class="d_inlinecode donthyphenate notranslate">stdarg</span></a></li><li>    <a href="core_stdc_stddef.html" title="core.stdc.stddef"><span class="d_inlinecode donthyphenate notranslate">stddef</span></a></li><li>    <a href="core_stdc_stdint.html" title="core.stdc.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>    <a href="core_stdc_stdio.html" title="core.stdc.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>    <a href="core_stdc_stdlib.html" title="core.stdc.stdlib"><span class="d_inlinecode donthyphenate notranslate">stdlib</span></a></li><li>    <a href="core_stdc_string.html" title="core.stdc.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>    <a href="core_stdc_tgmath.html" title="core.stdc.tgmath"><span class="d_inlinecode donthyphenate notranslate">tgmath</span></a></li><li>    <a href="core_stdc_time.html" title="core.stdc.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>    <a href="core_stdc_wchar_.html" title="core.stdc.wchar_"><span class="d_inlinecode donthyphenate notranslate">wchar_</span></a></li><li>    <a href="core_stdc_wctype.html" title="core.stdc.wctype"><span class="d_inlinecode donthyphenate notranslate">wctype</span></a>
  </li></ul></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">sync</span></h7><ul><li>    <a href="core_sync_barrier.html" title="core.sync.barrier"><span class="d_inlinecode donthyphenate notranslate">barrier</span></a></li><li>    <a href="core_sync_condition.html" title="core.sync.condition"><span class="d_inlinecode donthyphenate notranslate">condition</span></a></li><li>    <a href="core_sync_config.html" title="core.sync.config"><span class="d_inlinecode donthyphenate notranslate">config</span></a></li><li>    <a href="core_sync_exception.html" title="core.sync.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>    <a href="core_sync_mutex.html" title="core.sync.mutex"><span class="d_inlinecode donthyphenate notranslate">mutex</span></a></li><li>    <a href="core_sync_rwmutex.html" title="core.sync.rwmutex"><span class="d_inlinecode donthyphenate notranslate">rwmutex</span></a></li><li>    <a href="core_sync_semaphore.html" title="core.sync.semaphore"><span class="d_inlinecode donthyphenate notranslate">semaphore</span></a>
  </li></ul></li><li>  <a href="core_thread.html" title="core.thread"><span class="d_inlinecode donthyphenate notranslate">thread</span></a></li><li>  <a href="core_time.html" title="core.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>  <a href="core_vararg.html" title="core.vararg"><span class="d_inlinecode donthyphenate notranslate">vararg</span></a>
</li></ul>
</li>
    <li><a href='http://code.dlang.org'><span>3rd Party Packages</span></a></li>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/phobos/&amp;bug_severity=enhancement&amp;component=phobos&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5Bstd.traits%5D&amp;version=D2" class="button">Report a bug</a>
		<span >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</span>
	</span>
	<span class="tip">		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/traits.d" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
</div>
    <h1><span class="d_inlinecode donthyphenate notranslate">std.traits</span></h1>
    <div class="quickindex" id="quickindex"></div>
    <div class="summary">Templates which extract information about types and symbols at compile time.
</div>
<div class="description"><script type="text/javascript">inhibitQuickIndex = 1;</script>
<p></p>

 <div class="quickindex"> <table class="book"><caption></caption> <tr><th scope="col">Category</th> <th scope="col">Templates</th></tr>
 <tr><td>Symbol Name traits</td> <td>           <a href="#fullyQualifiedName"><span class="d_inlinecode donthyphenate notranslate">fullyQualifiedName</span></a>
           <a href="#moduleName"><span class="d_inlinecode donthyphenate notranslate">moduleName</span></a>
           <a href="#packageName"><span class="d_inlinecode donthyphenate notranslate">packageName</span></a>
 </td></tr>
 <tr><td>Function traits</td> <td>           <a href="#arity"><span class="d_inlinecode donthyphenate notranslate">arity</span></a>
           <a href="#functionAttributes"><span class="d_inlinecode donthyphenate notranslate">functionAttributes</span></a>
           <a href="#functionLinkage"><span class="d_inlinecode donthyphenate notranslate">functionLinkage</span></a>
           <a href="#FunctionTypeOf"><span class="d_inlinecode donthyphenate notranslate">FunctionTypeOf</span></a>
           <a href="#isSafe"><span class="d_inlinecode donthyphenate notranslate">isSafe</span></a>
           <a href="#isUnsafe"><span class="d_inlinecode donthyphenate notranslate">isUnsafe</span></a>
           <a href="#ParameterDefaults"><span class="d_inlinecode donthyphenate notranslate">ParameterDefaults</span></a>
           <a href="#ParameterIdentifierTuple"><span class="d_inlinecode donthyphenate notranslate">ParameterIdentifierTuple</span></a>
           <a href="#ParameterStorageClassTuple"><span class="d_inlinecode donthyphenate notranslate">ParameterStorageClassTuple</span></a>
           <a href="#Parameters"><span class="d_inlinecode donthyphenate notranslate">Parameters</span></a>
           <a href="#ReturnType"><span class="d_inlinecode donthyphenate notranslate">ReturnType</span></a>
           <a href="#SetFunctionAttributes"><span class="d_inlinecode donthyphenate notranslate">SetFunctionAttributes</span></a>
           <a href="#variadicFunctionStyle"><span class="d_inlinecode donthyphenate notranslate">variadicFunctionStyle</span></a>
 </td></tr>
 <tr><td>Aggregate Type traits</td> <td>           <a href="#BaseClassesTuple"><span class="d_inlinecode donthyphenate notranslate">BaseClassesTuple</span></a>
           <a href="#BaseTypeTuple"><span class="d_inlinecode donthyphenate notranslate">BaseTypeTuple</span></a>
           <a href="#classInstanceAlignment"><span class="d_inlinecode donthyphenate notranslate">classInstanceAlignment</span></a>
           <a href="#EnumMembers"><span class="d_inlinecode donthyphenate notranslate">EnumMembers</span></a>
           <a href="#FieldNameTuple"><span class="d_inlinecode donthyphenate notranslate">FieldNameTuple</span></a>
           <a href="#Fields"><span class="d_inlinecode donthyphenate notranslate">Fields</span></a>
           <a href="#hasAliasing"><span class="d_inlinecode donthyphenate notranslate">hasAliasing</span></a>
           <a href="#hasElaborateAssign"><span class="d_inlinecode donthyphenate notranslate">hasElaborateAssign</span></a>
           <a href="#hasElaborateCopyConstructor"><span class="d_inlinecode donthyphenate notranslate">hasElaborateCopyConstructor</span></a>
           <a href="#hasElaborateDestructor"><span class="d_inlinecode donthyphenate notranslate">hasElaborateDestructor</span></a>
           <a href="#hasIndirections"><span class="d_inlinecode donthyphenate notranslate">hasIndirections</span></a>
           <a href="#hasMember"><span class="d_inlinecode donthyphenate notranslate">hasMember</span></a>
           <a href="#hasNested"><span class="d_inlinecode donthyphenate notranslate">hasNested</span></a>
           <a href="#hasUnsharedAliasing"><span class="d_inlinecode donthyphenate notranslate">hasUnsharedAliasing</span></a>
           <a href="#InterfacesTuple"><span class="d_inlinecode donthyphenate notranslate">InterfacesTuple</span></a>
           <a href="#isNested"><span class="d_inlinecode donthyphenate notranslate">isNested</span></a>
           <a href="#MemberFunctionsTuple"><span class="d_inlinecode donthyphenate notranslate">MemberFunctionsTuple</span></a>
           <a href="#RepresentationTypeTuple"><span class="d_inlinecode donthyphenate notranslate">RepresentationTypeTuple</span></a>
           <a href="#TemplateArgsOf"><span class="d_inlinecode donthyphenate notranslate">TemplateArgsOf</span></a>
           <a href="#TemplateOf"><span class="d_inlinecode donthyphenate notranslate">TemplateOf</span></a>
           <a href="#TransitiveBaseTypeTuple"><span class="d_inlinecode donthyphenate notranslate">TransitiveBaseTypeTuple</span></a>
 </td></tr>
 <tr><td>Type Conversion</td> <td>           <a href="#CommonType"><span class="d_inlinecode donthyphenate notranslate">CommonType</span></a>
           <a href="#ImplicitConversionTargets"><span class="d_inlinecode donthyphenate notranslate">ImplicitConversionTargets</span></a>
           <a href="#CopyTypeQualifiers"><span class="d_inlinecode donthyphenate notranslate">CopyTypeQualifiers</span></a>
           <a href="#CopyConstness"><span class="d_inlinecode donthyphenate notranslate">CopyConstness</span></a>
           <a href="#isAssignable"><span class="d_inlinecode donthyphenate notranslate">isAssignable</span></a>
           <a href="#isCovariantWith"><span class="d_inlinecode donthyphenate notranslate">isCovariantWith</span></a>
           <a href="#isImplicitlyConvertible"><span class="d_inlinecode donthyphenate notranslate">isImplicitlyConvertible</span></a>
 </td></tr>
 <!--<tr><td>SomethingTypeOf</td> <td>           <a href="#BooleanTypeOf"><span class="d_inlinecode donthyphenate notranslate">BooleanTypeOf</span></a>
           <a href="#IntegralTypeOf"><span class="d_inlinecode donthyphenate notranslate">IntegralTypeOf</span></a>
           <a href="#FloatingPointTypeOf"><span class="d_inlinecode donthyphenate notranslate">FloatingPointTypeOf</span></a>
           <a href="#NumericTypeOf"><span class="d_inlinecode donthyphenate notranslate">NumericTypeOf</span></a>
           <a href="#UnsignedTypeOf"><span class="d_inlinecode donthyphenate notranslate">UnsignedTypeOf</span></a>
           <a href="#SignedTypeOf"><span class="d_inlinecode donthyphenate notranslate">SignedTypeOf</span></a>
           <a href="#CharTypeOf"><span class="d_inlinecode donthyphenate notranslate">CharTypeOf</span></a>
           <a href="#StaticArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">StaticArrayTypeOf</span></a>
           <a href="#DynamicArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">DynamicArrayTypeOf</span></a>
           <a href="#ArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">ArrayTypeOf</span></a>
           <a href="#StringTypeOf"><span class="d_inlinecode donthyphenate notranslate">StringTypeOf</span></a>
           <a href="#AssocArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">AssocArrayTypeOf</span></a>
           <a href="#BuiltinTypeOf"><span class="d_inlinecode donthyphenate notranslate">BuiltinTypeOf</span></a>
 </td></tr>-->
 <tr><td>Categories of types</td> <td>           <a href="#isAggregateType"><span class="d_inlinecode donthyphenate notranslate">isAggregateType</span></a>
           <a href="#isArray"><span class="d_inlinecode donthyphenate notranslate">isArray</span></a>
           <a href="#isAssociativeArray"><span class="d_inlinecode donthyphenate notranslate">isAssociativeArray</span></a>
           <a href="#isAutodecodableString"><span class="d_inlinecode donthyphenate notranslate">isAutodecodableString</span></a>
           <a href="#isBasicType"><span class="d_inlinecode donthyphenate notranslate">isBasicType</span></a>
           <a href="#isBoolean"><span class="d_inlinecode donthyphenate notranslate">isBoolean</span></a>
           <a href="#isBuiltinType"><span class="d_inlinecode donthyphenate notranslate">isBuiltinType</span></a>
           <a href="#isDynamicArray"><span class="d_inlinecode donthyphenate notranslate">isDynamicArray</span></a>
           <a href="#isFloatingPoint"><span class="d_inlinecode donthyphenate notranslate">isFloatingPoint</span></a>
           <a href="#isIntegral"><span class="d_inlinecode donthyphenate notranslate">isIntegral</span></a>
           <a href="#isNarrowString"><span class="d_inlinecode donthyphenate notranslate">isNarrowString</span></a>
           <a href="#isNumeric"><span class="d_inlinecode donthyphenate notranslate">isNumeric</span></a>
           <a href="#isPointer"><span class="d_inlinecode donthyphenate notranslate">isPointer</span></a>
           <a href="#isScalarType"><span class="d_inlinecode donthyphenate notranslate">isScalarType</span></a>
           <a href="#isSigned"><span class="d_inlinecode donthyphenate notranslate">isSigned</span></a>
           <a href="#isSomeChar"><span class="d_inlinecode donthyphenate notranslate">isSomeChar</span></a>
           <a href="#isSomeString"><span class="d_inlinecode donthyphenate notranslate">isSomeString</span></a>
           <a href="#isStaticArray"><span class="d_inlinecode donthyphenate notranslate">isStaticArray</span></a>
           <a href="#isUnsigned"><span class="d_inlinecode donthyphenate notranslate">isUnsigned</span></a>
 </td></tr>
 <tr><td>Type behaviours</td> <td>           <a href="#isAbstractClass"><span class="d_inlinecode donthyphenate notranslate">isAbstractClass</span></a>
           <a href="#isAbstractFunction"><span class="d_inlinecode donthyphenate notranslate">isAbstractFunction</span></a>
           <a href="#isCallable"><span class="d_inlinecode donthyphenate notranslate">isCallable</span></a>
           <a href="#isDelegate"><span class="d_inlinecode donthyphenate notranslate">isDelegate</span></a>
           <a href="#isExpressions"><span class="d_inlinecode donthyphenate notranslate">isExpressions</span></a>
           <a href="#isFinalClass"><span class="d_inlinecode donthyphenate notranslate">isFinalClass</span></a>
           <a href="#isFinalFunction"><span class="d_inlinecode donthyphenate notranslate">isFinalFunction</span></a>
           <a href="#isFunctionPointer"><span class="d_inlinecode donthyphenate notranslate">isFunctionPointer</span></a>
           <a href="#isInstanceOf"><span class="d_inlinecode donthyphenate notranslate">isInstanceOf</span></a>
           <a href="#isIterable"><span class="d_inlinecode donthyphenate notranslate">isIterable</span></a>
           <a href="#isMutable"><span class="d_inlinecode donthyphenate notranslate">isMutable</span></a>
           <a href="#isSomeFunction"><span class="d_inlinecode donthyphenate notranslate">isSomeFunction</span></a>
           <a href="#isTypeTuple"><span class="d_inlinecode donthyphenate notranslate">isTypeTuple</span></a>
 </td></tr>
 <tr><td>General Types</td> <td>           <a href="#ForeachType"><span class="d_inlinecode donthyphenate notranslate">ForeachType</span></a>
           <a href="#KeyType"><span class="d_inlinecode donthyphenate notranslate">KeyType</span></a>
           <a href="#Largest"><span class="d_inlinecode donthyphenate notranslate">Largest</span></a>
           <a href="#mostNegative"><span class="d_inlinecode donthyphenate notranslate">mostNegative</span></a>
           <a href="#OriginalType"><span class="d_inlinecode donthyphenate notranslate">OriginalType</span></a>
           <a href="#PointerTarget"><span class="d_inlinecode donthyphenate notranslate">PointerTarget</span></a>
           <a href="#Signed"><span class="d_inlinecode donthyphenate notranslate">Signed</span></a>
           <a href="#Unqual"><span class="d_inlinecode donthyphenate notranslate">Unqual</span></a>
           <a href="#Unsigned"><span class="d_inlinecode donthyphenate notranslate">Unsigned</span></a>
           <a href="#ValueType"><span class="d_inlinecode donthyphenate notranslate">ValueType</span></a>
 </td></tr>
 <tr><td>Misc</td> <td>           <a href="#mangledName"><span class="d_inlinecode donthyphenate notranslate">mangledName</span></a>
           <a href="#Select"><span class="d_inlinecode donthyphenate notranslate">Select</span></a>
           <a href="#select"><span class="d_inlinecode donthyphenate notranslate">select</span></a>
 </td></tr>
 <tr><td>User-Defined Attributes</td> <td>           <a href="#hasUDA"><span class="d_inlinecode donthyphenate notranslate">hasUDA</span></a>
           <a href="#getUDAs"><span class="d_inlinecode donthyphenate notranslate">getUDAs</span></a>
           <a href="#getSymbolsByUDA"><span class="d_inlinecode donthyphenate notranslate">getSymbolsByUDA</span></a>
 </td></tr>
 </table>
 </div>

</div>
<div class="keyval License"><span class="key keyLicense">License:</span> <div class="val valLicense"><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
</div></div>
<div class="keyval Authors"><span class="key keyAuthors">Authors:</span> <div class="val valAuthors"><a href="http://digitalmars.com">Walter Bright</a>,
            Tomasz Stachowiak (<span class="d_inlinecode donthyphenate notranslate">isExpressions</span>),
            <a href="http://erdani.org">Andrei Alexandrescu</a>,
            Shin Fujishiro,
            <a href="http://octarineparrot.com">Robert Clipsham</a>,
            <a href="http://klickverbot.at">David Nadlinger</a>,
            Kenji Hara,
            Shoichi Kato
</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Source:</span>
<span class="phobos_src"><a class="https" href="https://github.com/D-Programming-Language/phobos/blob/master/std/traits.d">std/traits.d</a></span></p></div>

<dl><dt class="d_decl"><a name=".MutableOf"></a><div class="quickindex" id="quickindex.MutableOf"></div>template <a name="MutableOf"></a><span class="ddoc_psymbol">MutableOf</span>(T)</dt>
<dd><div class="summary">Add specific qualifier to the given type T.</div>

</dd>
<dt class="d_decl"><a name=".InoutOf"></a><div class="quickindex" id="quickindex.InoutOf"></div>template <a name="InoutOf"></a><span class="ddoc_psymbol">InoutOf</span>(T)</dt>
<dd><div class="summary">Add specific qualifier to the given type T.</div>

</dd>
<dt class="d_decl"><a name=".ConstOf"></a><div class="quickindex" id="quickindex.ConstOf"></div>template <a name="ConstOf"></a><span class="ddoc_psymbol">ConstOf</span>(T)</dt>
<dd><div class="summary">ditto.</div>

</dd>
<dt class="d_decl"><a name=".SharedOf"></a><div class="quickindex" id="quickindex.SharedOf"></div>template <a name="SharedOf"></a><span class="ddoc_psymbol">SharedOf</span>(T)</dt>
<dd><div class="summary">ditto.</div>

</dd>
<dt class="d_decl"><a name=".SharedInoutOf"></a><div class="quickindex" id="quickindex.SharedInoutOf"></div>template <a name="SharedInoutOf"></a><span class="ddoc_psymbol">SharedInoutOf</span>(T)</dt>
<dd><div class="summary">ditto.</div>

</dd>
<dt class="d_decl"><a name=".SharedConstOf"></a><div class="quickindex" id="quickindex.SharedConstOf"></div>template <a name="SharedConstOf"></a><span class="ddoc_psymbol">SharedConstOf</span>(T)</dt>
<dd><div class="summary">ditto.</div>

</dd>
<dt class="d_decl"><a name=".ImmutableOf"></a><div class="quickindex" id="quickindex.ImmutableOf"></div>template <a name="ImmutableOf"></a><span class="ddoc_psymbol">ImmutableOf</span>(T)</dt>
<dd><div class="summary">ditto.</div>

</dd>
<dt class="d_decl"><a name=".packageName"></a><div class="quickindex" id="quickindex.packageName"></div>template <a name="packageName"></a><span class="ddoc_psymbol">packageName</span>(alias T)</dt>
<dd><div class="summary">Get the full package name for the given symbol.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">packageName</span>!<span class="d_psymbol">packageName</span> == <span class="d_string">"std"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".moduleName"></a><div class="quickindex" id="quickindex.moduleName"></div>template <a name="moduleName"></a><span class="ddoc_psymbol">moduleName</span>(alias T)</dt>
<dd><div class="summary">Get the module name (including package) for the given symbol.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">moduleName</span>!<span class="d_psymbol">moduleName</span> == <span class="d_string">"std.traits"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".fullyQualifiedName"></a><div class="quickindex" id="quickindex.fullyQualifiedName"></div>template <a name="fullyQualifiedName"></a><span class="ddoc_psymbol">fullyQualifiedName</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string  converter.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">module</span> myModule;
<span class="d_keyword">struct</span> MyStruct {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">fullyQualifiedName</span>!(<span class="d_keyword">const</span> MyStruct[]) == <span class="d_string">"const(myModule.MyStruct[])"</span>);
</pre>
</p></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">fullyQualifiedName</span>!<span class="d_psymbol">fullyQualifiedName</span> == <span class="d_string">"std.traits.fullyQualifiedName"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ReturnType"></a><div class="quickindex" id="quickindex.ReturnType"></div>template <a name="ReturnType"></a><span class="ddoc_psymbol">ReturnType</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get the type of the return value from a function,
 a pointer to function, a delegate, a struct
 with an opCall, a pointer to a struct with an opCall,
 or a class with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>. Please note that <span class="d_keyword">ref</span>
 is not part of a type, but the attribute of the function
 (see template <a href="#functionAttributes"><span class="d_inlinecode donthyphenate notranslate">functionAttributes</span></a>).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo();
<span class="d_psymbol">ReturnType</span>!foo x;   <span class="d_comment">// x is declared as int
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Parameters"></a><div class="quickindex" id="quickindex.Parameters"></div>template <a name="Parameters"></a><span class="ddoc_psymbol">Parameters</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get, as a tuple, the types of the parameters to a function, a pointer
to function, a delegate, a struct with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>, a pointer to a
struct with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>, or a class with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>);
<span class="d_keyword">void</span> bar(<span class="d_psymbol">Parameters</span>!foo);      <span class="d_comment">// declares void bar(int, long);
</span><span class="d_keyword">void</span> abc(<span class="d_psymbol">Parameters</span>!foo[1]);   <span class="d_comment">// declares void abc(long);
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ParameterTypeTuple"></a><div class="quickindex" id="quickindex.ParameterTypeTuple"></div>alias <a name="ParameterTypeTuple"></a><span class="ddoc_psymbol">ParameterTypeTuple</span> = Parameters(func...) if (func.length == 1 &amp;&amp; isCallable!func);
</dt>
<dd><div class="summary">Alternate name for <a href="#Parameters"><span class="d_inlinecode donthyphenate notranslate">Parameters</span></a>, kept for legacy compatibility.</div>

</dd>
<dt class="d_decl"><a name=".arity"></a><div class="quickindex" id="quickindex.arity"></div>template <a name="arity"></a><span class="ddoc_psymbol">arity</span>(alias func) if (isCallable!func &amp;&amp; variadicFunctionStyle!func == Variadic.no)</dt>
<dd><div class="summary">Returns the number of arguments of function <span class="d_inlinecode donthyphenate notranslate">func</span>.
<a name="arity"></a><span class="ddoc_psymbol">arity</span> is undefined for variadic functions.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">void</span> foo(){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">arity</span>!foo==0);
<span class="d_keyword">void</span> bar(<span class="d_keyword">uint</span>){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">arity</span>!bar==1);
<span class="d_keyword">void</span> variadicFoo(<span class="d_keyword">uint</span>...){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, <span class="d_psymbol">arity</span>!variadicFoo));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ParameterStorageClass"></a><div class="quickindex" id="quickindex.ParameterStorageClass"></div>enum <a name="ParameterStorageClass"></a><span class="ddoc_psymbol">ParameterStorageClass</span>: uint;
<br><a name=".ParameterStorageClassTuple"></a><div class="quickindex" id="quickindex.ParameterStorageClassTuple"></div>template <a name="ParameterStorageClassTuple"></a><span class="ddoc_psymbol">ParameterStorageClassTuple</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Returns a tuple consisting of the storage classes of the parameters of a
function <span class="d_inlinecode donthyphenate notranslate">func</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> STC = <span class="d_psymbol">ParameterStorageClass</span>; <span class="d_comment">// shorten the enum name
</span>
<span class="d_keyword">void</span> func(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> ctx, <span class="d_keyword">out</span> <span class="d_keyword">real</span> result, <span class="d_keyword">real</span> param)
{
}
<span class="d_keyword">alias</span> pstc = <span class="d_psymbol">ParameterStorageClassTuple</span>!func;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc.length == 3); <span class="d_comment">// three parameters
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[0] == STC.ref_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[1] == STC.out_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[2] == STC.none);
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".ParameterStorageClass.none"></a><div class="quickindex" id="quickindex.ParameterStorageClass.none"></div><a name="none"></a><span class="ddoc_psymbol">none</span><br><a name=".ParameterStorageClass.scope_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.scope_"></div><a name="scope_"></a><span class="ddoc_psymbol">scope_</span><br><a name=".ParameterStorageClass.out_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.out_"></div><a name="out_"></a><span class="ddoc_psymbol">out_</span><br><a name=".ParameterStorageClass.ref_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.ref_"></div><a name="ref_"></a><span class="ddoc_psymbol">ref_</span><br><a name=".ParameterStorageClass.lazy_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.lazy_"></div><a name="lazy_"></a><span class="ddoc_psymbol">lazy_</span><br><a name=".ParameterStorageClass.return_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.return_"></div><a name="return_"></a><span class="ddoc_psymbol">return_</span></dt>
<dd><div class="summary">These flags can be bitwise OR-ed together to represent complex storage
 class.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ParameterIdentifierTuple"></a><div class="quickindex" id="quickindex.ParameterIdentifierTuple"></div>template <a name="ParameterIdentifierTuple"></a><span class="ddoc_psymbol">ParameterIdentifierTuple</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get, as a tuple, the identifiers of the parameters to a function symbol.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> num, string name, <span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([<span class="d_psymbol">ParameterIdentifierTuple</span>!foo] == [<span class="d_string">"num"</span>, <span class="d_string">"name"</span>, <span class="d_string">""</span>]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ParameterDefaults"></a><div class="quickindex" id="quickindex.ParameterDefaults"></div>template <a name="ParameterDefaults"></a><span class="ddoc_psymbol">ParameterDefaults</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get, as a tuple, the default value of the parameters to a function symbol.
If a parameter doesn't have the default value, <span class="d_inlinecode donthyphenate notranslate">void</span> is returned instead.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> num, string name = <span class="d_string">"hello"</span>, <span class="d_keyword">int</span>[] = [1,2,3]);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ParameterDefaults</span>!foo[0] == <span class="d_keyword">void</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(   <span class="d_psymbol">ParameterDefaults</span>!foo[1] == <span class="d_string">"hello"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(   <span class="d_psymbol">ParameterDefaults</span>!foo[2] == [1,2,3]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ParameterDefaultValueTuple"></a><div class="quickindex" id="quickindex.ParameterDefaultValueTuple"></div>alias <a name="ParameterDefaultValueTuple"></a><span class="ddoc_psymbol">ParameterDefaultValueTuple</span> = ParameterDefaults(func...) if (func.length == 1 &amp;&amp; isCallable!func);
</dt>
<dd><div class="summary">Alternate name for <a href="#ParameterDefaults"><span class="d_inlinecode donthyphenate notranslate">ParameterDefaults</span></a>, kept for legacy compatibility.</div>

</dd>
<dt class="d_decl"><a name=".FunctionAttribute"></a><div class="quickindex" id="quickindex.FunctionAttribute"></div>enum <a name="FunctionAttribute"></a><span class="ddoc_psymbol">FunctionAttribute</span>: uint;
<br><a name=".functionAttributes"></a><div class="quickindex" id="quickindex.functionAttributes"></div>template <a name="functionAttributes"></a><span class="ddoc_psymbol">functionAttributes</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Returns the attributes attached to a function <span class="d_inlinecode donthyphenate notranslate">func</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits : <span class="d_psymbol">functionAttributes</span>, <span class="d_psymbol">FunctionAttribute</span>;

<span class="d_keyword">alias</span> FA = <span class="d_psymbol">FunctionAttribute</span>; <span class="d_comment">// shorten the enum name
</span>
<span class="d_keyword">real</span> func(<span class="d_keyword">real</span> x) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @safe
{
    <span class="d_keyword">return</span> x;
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">functionAttributes</span>!func &amp; FA.pure_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">functionAttributes</span>!func &amp; FA.safe);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!(<span class="d_psymbol">functionAttributes</span>!func &amp; FA.trusted)); <span class="d_comment">// not @trusted
</span></pre>
</div></div>
<dl><dt class="d_decl"><a name=".FunctionAttribute.none"></a><div class="quickindex" id="quickindex.FunctionAttribute.none"></div><a name="none"></a><span class="ddoc_psymbol">none</span><br><a name=".FunctionAttribute.pure_"></a><div class="quickindex" id="quickindex.FunctionAttribute.pure_"></div><a name="pure_"></a><span class="ddoc_psymbol">pure_</span><br><a name=".FunctionAttribute.nothrow_"></a><div class="quickindex" id="quickindex.FunctionAttribute.nothrow_"></div><a name="nothrow_"></a><span class="ddoc_psymbol">nothrow_</span><br><a name=".FunctionAttribute.ref_"></a><div class="quickindex" id="quickindex.FunctionAttribute.ref_"></div><a name="ref_"></a><span class="ddoc_psymbol">ref_</span><br><a name=".FunctionAttribute.property"></a><div class="quickindex" id="quickindex.FunctionAttribute.property"></div><a name="property"></a><span class="ddoc_psymbol">property</span><br><a name=".FunctionAttribute.trusted"></a><div class="quickindex" id="quickindex.FunctionAttribute.trusted"></div><a name="trusted"></a><span class="ddoc_psymbol">trusted</span><br><a name=".FunctionAttribute.safe"></a><div class="quickindex" id="quickindex.FunctionAttribute.safe"></div><a name="safe"></a><span class="ddoc_psymbol">safe</span><br><a name=".FunctionAttribute.nogc"></a><div class="quickindex" id="quickindex.FunctionAttribute.nogc"></div><a name="nogc"></a><span class="ddoc_psymbol">nogc</span><br><a name=".FunctionAttribute.system"></a><div class="quickindex" id="quickindex.FunctionAttribute.system"></div><a name="system"></a><span class="ddoc_psymbol">system</span><br><a name=".FunctionAttribute.const_"></a><div class="quickindex" id="quickindex.FunctionAttribute.const_"></div><a name="const_"></a><span class="ddoc_psymbol">const_</span><br><a name=".FunctionAttribute.immutable_"></a><div class="quickindex" id="quickindex.FunctionAttribute.immutable_"></div><a name="immutable_"></a><span class="ddoc_psymbol">immutable_</span><br><a name=".FunctionAttribute.inout_"></a><div class="quickindex" id="quickindex.FunctionAttribute.inout_"></div><a name="inout_"></a><span class="ddoc_psymbol">inout_</span><br><a name=".FunctionAttribute.shared_"></a><div class="quickindex" id="quickindex.FunctionAttribute.shared_"></div><a name="shared_"></a><span class="ddoc_psymbol">shared_</span><br><a name=".FunctionAttribute.return_"></a><div class="quickindex" id="quickindex.FunctionAttribute.return_"></div><a name="return_"></a><span class="ddoc_psymbol">return_</span></dt>
<dd><div class="summary">These flags can be bitwise OR-ed together to represent a complex attribute.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".isSafe"></a><div class="quickindex" id="quickindex.isSafe"></div>template <a name="isSafe"></a><span class="ddoc_psymbol">isSafe</span>(alias func) if (isCallable!func)</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">func</span> is <span class="d_inlinecode donthyphenate notranslate">@safe</span> or <span class="d_inlinecode donthyphenate notranslate">@trusted</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isSafe</span>!add);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isSafe</span>!sub);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSafe</span>!mul);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isUnsafe"></a><div class="quickindex" id="quickindex.isUnsafe"></div>enum auto <a name="isUnsafe"></a><span class="ddoc_psymbol">isUnsafe</span>(alias func);
</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">func</span> is <span class="d_inlinecode donthyphenate notranslate">@system</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isUnsafe</span>!add);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isUnsafe</span>!sub);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isUnsafe</span>!mul);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".functionLinkage"></a><div class="quickindex" id="quickindex.functionLinkage"></div>template <a name="functionLinkage"></a><span class="ddoc_psymbol">functionLinkage</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Returns the calling convention of function as a string.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">extern</span>(D) <span class="d_keyword">void</span> Dfunc() {}
<span class="d_keyword">extern</span>(C) <span class="d_keyword">void</span> Cfunc() {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">functionLinkage</span>!Dfunc == <span class="d_string">"D"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">functionLinkage</span>!Cfunc == <span class="d_string">"C"</span>);

string a = <span class="d_psymbol">functionLinkage</span>!Dfunc;
<span class="d_keyword">assert</span>(a == <span class="d_string">"D"</span>);

<span class="d_keyword">auto</span> fp = &amp;Cfunc;
string b = <span class="d_psymbol">functionLinkage</span>!fp;
<span class="d_keyword">assert</span>(b == <span class="d_string">"C"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Variadic"></a><div class="quickindex" id="quickindex.Variadic"></div>enum <a name="Variadic"></a><span class="ddoc_psymbol">Variadic</span>: int;
<br><a name=".variadicFunctionStyle"></a><div class="quickindex" id="quickindex.variadicFunctionStyle"></div>template <a name="variadicFunctionStyle"></a><span class="ddoc_psymbol">variadicFunctionStyle</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Determines what kind of variadic parameters function has.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">void</span> func() {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">variadicFunctionStyle</span>!func == <span class="d_psymbol">Variadic</span>.no);

<span class="d_keyword">extern</span>(C) <span class="d_keyword">int</span> printf(<span class="d_keyword">in</span> <span class="d_keyword">char</span>*, ...);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">variadicFunctionStyle</span>!printf == <span class="d_psymbol">Variadic</span>.c);
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".Variadic.no"></a><div class="quickindex" id="quickindex.Variadic.no"></div><a name="no"></a><span class="ddoc_psymbol">no</span></dt>
<dd><div class="summary">Function is not variadic.</div>

</dd>
<dt class="d_decl"><a name=".Variadic.c"></a><div class="quickindex" id="quickindex.Variadic.c"></div><a name="c"></a><span class="ddoc_psymbol">c</span></dt>
<dd><div class="summary">Function is a C-style variadic function.</div>

</dd>
<dt class="d_decl"><a name=".Variadic.d"></a><div class="quickindex" id="quickindex.Variadic.d"></div><a name="d"></a><span class="ddoc_psymbol">d</span></dt>
<dd><div class="summary">Function is a D-style variadic function, which uses
</div>
<div class="description">_argptr and _arguments.</div>

</dd>
<dt class="d_decl"><a name=".Variadic.typesafe"></a><div class="quickindex" id="quickindex.Variadic.typesafe"></div><a name="typesafe"></a><span class="ddoc_psymbol">typesafe</span></dt>
<dd><div class="summary">Function is a <a name="typesafe"></a><span class="ddoc_psymbol">typesafe</span> variadic function.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".FunctionTypeOf"></a><div class="quickindex" id="quickindex.FunctionTypeOf"></div>template <a name="FunctionTypeOf"></a><span class="ddoc_psymbol">FunctionTypeOf</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get the function type from a callable object <span class="d_inlinecode donthyphenate notranslate">func</span>.
</div>
<div class="description">Using builtin <span class="d_inlinecode donthyphenate notranslate">typeof</span> on a property function yields the types of the
property value, not of the property function itself.  Still,
<span class="d_inlinecode donthyphenate notranslate"><a name="FunctionTypeOf"></a><span class="ddoc_psymbol">FunctionTypeOf</span></span> is able to obtain function types of properties.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Do not confuse function types with function pointer types; function types are
usually used for compile-time reflection purposes.</p></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> value() @property { <span class="d_keyword">return</span> 0; }
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( <span class="d_keyword">typeof</span>(C.value) == <span class="d_keyword">int</span> ));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( <span class="d_psymbol">FunctionTypeOf</span>!(C.value) == <span class="d_keyword">function</span> ));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SetFunctionAttributes"></a><div class="quickindex" id="quickindex.SetFunctionAttributes"></div>template <a name="SetFunctionAttributes"></a><span class="ddoc_psymbol">SetFunctionAttributes</span>(T, string linkage, uint attrs) if (isFunctionPointer!T || isDelegate!T)<br>template <a name="SetFunctionAttributes"></a><span class="ddoc_psymbol">SetFunctionAttributes</span>(T, string linkage, uint attrs) if (is(T == function))</dt>
<dd><div class="summary">Constructs a new function or delegate type with the same basic signature
 as the given one, but different attributes (including linkage).
</div>
<div class="description">This is especially useful for adding/removing attributes to/from types in
 generic code, where the actual type name cannot be spelt out.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T</td>
<td class="param_desc">The base type.</td></tr>
<tr class="param"><td class="param_id">linkage</td>
<td class="param_desc">The desired linkage of the result type.</td></tr>
<tr class="param"><td class="param_id">attrs</td>
<td class="param_desc">The desired <a href="#FunctionAttribute"><span class="d_inlinecode donthyphenate notranslate">FunctionAttribute</span></a>s of the result type.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> ExternC(T) = <span class="d_psymbol">SetFunctionAttributes</span>!(T, <span class="d_string">"C"</span>, functionAttributes!T);

<span class="d_keyword">auto</span> assumePure(T)(T t)
    <span class="d_keyword">if</span> (isFunctionPointer!T || isDelegate!T)
{
    <span class="d_keyword">enum</span> attrs = functionAttributes!T | FunctionAttribute.pure_;
    <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(<span class="d_psymbol">SetFunctionAttributes</span>!(T, functionLinkage!T, attrs)) t;
}
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isNested"></a><div class="quickindex" id="quickindex.isNested"></div>template <a name="isNested"></a><span class="ddoc_psymbol">isNested</span>(T) if (is(T == class) || is(T == struct) || is(T == union))</dt>
<dd><div class="summary">Determines whether <span class="d_inlinecode donthyphenate notranslate">T</span> has its own context pointer.
<span class="d_inlinecode donthyphenate notranslate">T</span> must be either <span class="d_inlinecode donthyphenate notranslate">class</span>, <span class="d_inlinecode donthyphenate notranslate">struct</span>, or <span class="d_inlinecode donthyphenate notranslate">union</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isNested</span>!S);

<span class="d_keyword">int</span> i;
<span class="d_keyword">struct</span> NestedStruct { <span class="d_keyword">void</span> f() { ++i; } }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isNested</span>!NestedStruct);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasNested"></a><div class="quickindex" id="quickindex.hasNested"></div>template <a name="hasNested"></a><span class="ddoc_psymbol">hasNested</span>(T)</dt>
<dd><div class="summary">Determines whether <span class="d_inlinecode donthyphenate notranslate">T</span> or any of its representation types
have a context pointer.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S { }

<span class="d_keyword">int</span> i;
<span class="d_keyword">struct</span> NS { <span class="d_keyword">void</span> f() { ++i; } }

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasNested</span>!(S[2]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasNested</span>!(NS[2]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Fields"></a><div class="quickindex" id="quickindex.Fields"></div>template <a name="Fields"></a><span class="ddoc_psymbol">Fields</span>(T)</dt>
<dd><div class="summary">Get as a tuple the types of the fields of a struct, class, or union.
 This consists of the fields that take up memory space,
 excluding the hidden fields like the virtual function
 table pointer or a context pointer for nested types.
 If <span class="d_inlinecode donthyphenate notranslate">T</span> isn't a struct, class, or union returns a tuple
 with one element <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> x; <span class="d_keyword">float</span> y; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Fields</span>!S == TypeTuple!(<span class="d_keyword">int</span>, <span class="d_keyword">float</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".FieldTypeTuple"></a><div class="quickindex" id="quickindex.FieldTypeTuple"></div>alias <a name="FieldTypeTuple"></a><span class="ddoc_psymbol">FieldTypeTuple</span> = Fields(T);
</dt>
<dd><div class="summary">Alternate name for <a href="#Fields"><span class="d_inlinecode donthyphenate notranslate">Fields</span></a>, kept for legacy compatibility.</div>

</dd>
<dt class="d_decl"><a name=".FieldNameTuple"></a><div class="quickindex" id="quickindex.FieldNameTuple"></div>template <a name="FieldNameTuple"></a><span class="ddoc_psymbol">FieldNameTuple</span>(T)</dt>
<dd><div class="summary">Get as an expression tuple the names of the fields of a struct, class, or
 union. This consists of the fields that take up memory space, excluding the
 hidden fields like the virtual function table pointer or a context pointer
 for nested types. If <span class="d_inlinecode donthyphenate notranslate">T</span> isn't a struct, class, or union returns an
 expression tuple with an empty string.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> x; <span class="d_keyword">float</span> y; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">FieldNameTuple</span>!S == TypeTuple!(<span class="d_string">"x"</span>, <span class="d_string">"y"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">FieldNameTuple</span>!<span class="d_keyword">int</span> == TypeTuple!<span class="d_string">""</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".RepresentationTypeTuple"></a><div class="quickindex" id="quickindex.RepresentationTypeTuple"></div>template <a name="RepresentationTypeTuple"></a><span class="ddoc_psymbol">RepresentationTypeTuple</span>(T)</dt>
<dd><div class="summary">Get the primitive types of the fields of a struct or class, in
topological order.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> a; <span class="d_keyword">float</span> b; }
<span class="d_keyword">struct</span> S2 { <span class="d_keyword">char</span>[] a; <span class="d_keyword">union</span> { S1 b; S1 * c; } }
<span class="d_keyword">alias</span> R = <span class="d_psymbol">RepresentationTypeTuple</span>!S2;
<span class="d_keyword">assert</span>(R.length == 4
    &amp;&amp; <span class="d_keyword">is</span>(R[0] == <span class="d_keyword">char</span>[]) &amp;&amp; <span class="d_keyword">is</span>(R[1] == <span class="d_keyword">int</span>)
    &amp;&amp; <span class="d_keyword">is</span>(R[2] == <span class="d_keyword">float</span>) &amp;&amp; <span class="d_keyword">is</span>(R[3] == S1*));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasAliasing"></a><div class="quickindex" id="quickindex.hasAliasing"></div>template <a name="hasAliasing"></a><span class="ddoc_psymbol">hasAliasing</span>(T...)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="d_inlinecode donthyphenate notranslate">U*</span> and <span class="d_inlinecode donthyphenate notranslate">U</span>
is not immutable;</li> <li>an array <span class="d_inlinecode donthyphenate notranslate">U[]</span> and <span class="d_inlinecode donthyphenate notranslate">U</span> is not
immutable;</li> <li>a reference to a class or interface type <span class="d_inlinecode donthyphenate notranslate">C</span> and <span class="d_inlinecode donthyphenate notranslate">C</span> is
not immutable.</li> <li>an associative array that is not immutable.</li>
<li>a delegate.</li></ol></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> a; Object b; }
<span class="d_keyword">struct</span> S2 { string a; }
<span class="d_keyword">struct</span> S3 { <span class="d_keyword">int</span> a; <span class="d_keyword">immutable</span> Object b; }
<span class="d_keyword">struct</span> S4 { <span class="d_keyword">float</span>[3] vals; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasAliasing</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAliasing</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAliasing</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAliasing</span>!S4);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasIndirections"></a><div class="quickindex" id="quickindex.hasIndirections"></div>template <a name="hasIndirections"></a><span class="ddoc_psymbol">hasIndirections</span>(T)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="d_inlinecode donthyphenate notranslate">U*</span>;</li> <li>an
array <span class="d_inlinecode donthyphenate notranslate">U[]</span>;</li> <li>a reference to a class type <span class="d_inlinecode donthyphenate notranslate">C</span>.</li>
<li>an associative array.</li> <li>a delegate.</li></ol></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">int</span>[string]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() <span class="d_keyword">immutable</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>())));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() <span class="d_keyword">immutable</span>)));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span> <span class="d_keyword">function</span>()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span>*[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">byte</span>[1]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasUnsharedAliasing"></a><div class="quickindex" id="quickindex.hasUnsharedAliasing"></div>template <a name="hasUnsharedAliasing"></a><span class="ddoc_psymbol">hasUnsharedAliasing</span>(T...)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="d_inlinecode donthyphenate notranslate">U*</span> and <span class="d_inlinecode donthyphenate notranslate">U</span>
is not immutable or shared;</li> <li>an array <span class="d_inlinecode donthyphenate notranslate">U[]</span> and <span class="d_inlinecode donthyphenate notranslate">U</span> is not
immutable or shared;</li> <li>a reference to a class type <span class="d_inlinecode donthyphenate notranslate">C</span> and
<span class="d_inlinecode donthyphenate notranslate">C</span> is not immutable or shared.</li> <li>an associative array that is not
immutable or shared.</li> <li>a delegate that is not shared.</li></ol></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> a; Object b; }
<span class="d_keyword">struct</span> S2 { string a; }
<span class="d_keyword">struct</span> S3 { <span class="d_keyword">int</span> a; <span class="d_keyword">immutable</span> Object b; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasUnsharedAliasing</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S3);

<span class="d_keyword">struct</span> S4 { <span class="d_keyword">int</span> a; <span class="d_keyword">shared</span> Object b; }
<span class="d_keyword">struct</span> S5 { <span class="d_keyword">char</span>[] a; }
<span class="d_keyword">struct</span> S6 { <span class="d_keyword">shared</span> <span class="d_keyword">char</span>[] b; }
<span class="d_keyword">struct</span> S7 { <span class="d_keyword">float</span>[3] vals; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S4);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasUnsharedAliasing</span>!S5);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S6);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S7);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasElaborateCopyConstructor"></a><div class="quickindex" id="quickindex.hasElaborateCopyConstructor"></div>template <a name="hasElaborateCopyConstructor"></a><span class="ddoc_psymbol">hasElaborateCopyConstructor</span>(S)</dt>
<dd><div class="summary">True if <span class="d_inlinecode donthyphenate notranslate">S</span> or any type embedded directly in the representation of <span class="d_inlinecode donthyphenate notranslate">S</span>
 defines an elaborate copy constructor. Elaborate copy constructors are
 introduced by defining <span class="d_inlinecode donthyphenate notranslate">this(this)</span> for a <span class="d_inlinecode donthyphenate notranslate">struct</span>.
</div>
<div class="description">Classes and unions never have elaborate copy constructors.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!<span class="d_keyword">int</span>);

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S1 { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S2 { <span class="d_keyword">this</span>(<span class="d_keyword">this</span>) {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S3 { S2 field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S4 { S3[1] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S5 { S3[] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S6 { S3[0] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S7 { @disable <span class="d_keyword">this</span>(); S3 field; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!(<span class="d_keyword">immutable</span> S2));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!(S3[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!(S3[0]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S4);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!S5);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!S6);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S7);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasElaborateAssign"></a><div class="quickindex" id="quickindex.hasElaborateAssign"></div>template <a name="hasElaborateAssign"></a><span class="ddoc_psymbol">hasElaborateAssign</span>(S)</dt>
<dd><div class="summary">True if <span class="d_inlinecode donthyphenate notranslate">S</span> or any type directly embedded in the representation of <span class="d_inlinecode donthyphenate notranslate">S</span>
   defines an elaborate assignment. Elaborate assignments are introduced by
   defining <span class="d_inlinecode donthyphenate notranslate">opAssign(typeof(this))</span> or <span class="d_inlinecode donthyphenate notranslate">opAssign(ref typeof(this))</span>
   for a <span class="d_inlinecode donthyphenate notranslate">struct</span> or when there is a compiler-generated <span class="d_inlinecode donthyphenate notranslate">opAssign</span>.
</div>
<div class="description">A type <span class="d_inlinecode donthyphenate notranslate">S</span> gets compiler-generated <span class="d_inlinecode donthyphenate notranslate">opAssign</span> in case it has
   an elaborate copy constructor or elaborate destructor.
<p></p>

   Classes and unions never have elaborate assignments.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Structs with (possibly nested) postblit operator(s) will have a
   hidden yet elaborate compiler generated assignment operator (unless
   explicitly disabled).</p></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!<span class="d_keyword">int</span>);

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S  { <span class="d_keyword">void</span> opAssign(S) {} }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!(<span class="d_keyword">const</span>(S)));

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S1 { <span class="d_keyword">void</span> opAssign(<span class="d_keyword">ref</span> S1) {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S2 { <span class="d_keyword">void</span> opAssign(<span class="d_keyword">int</span>) {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S3 { S s; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!(S3[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!(S3[0]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasElaborateDestructor"></a><div class="quickindex" id="quickindex.hasElaborateDestructor"></div>template <a name="hasElaborateDestructor"></a><span class="ddoc_psymbol">hasElaborateDestructor</span>(S)</dt>
<dd><div class="summary">True if <span class="d_inlinecode donthyphenate notranslate">S</span> or any type directly embedded in the representation
   of <span class="d_inlinecode donthyphenate notranslate">S</span> defines an elaborate destructor. Elaborate destructors
   are introduced by defining <span class="d_inlinecode donthyphenate notranslate">~this()</span> for a <span class="d_inlinecode donthyphenate notranslate">   struct</span>.
</div>
<div class="description">Classes and unions never have elaborate destructors, even
   though classes may define <span class="d_inlinecode donthyphenate notranslate">~this()</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!<span class="d_keyword">int</span>);

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S1 { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S2 { ~<span class="d_keyword">this</span>() {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S3 { S2 field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S4 { S3[1] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S5 { S3[] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S6 { S3[0] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S7 { @disable <span class="d_keyword">this</span>(); S3 field; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!(<span class="d_keyword">immutable</span> S2));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!(S3[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!(S3[0]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S4);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!S5);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!S6);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S7);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasMember"></a><div class="quickindex" id="quickindex.hasMember"></div>enum auto <a name="hasMember"></a><span class="ddoc_psymbol">hasMember</span>(T, string name);
</dt>
<dd><div class="summary">Yields <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span> is an aggregate that defines
   a symbol called <span class="d_inlinecode donthyphenate notranslate">name</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasMember</span>!(<span class="d_keyword">int</span>, <span class="d_string">"blah"</span>));
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> blah; }
<span class="d_keyword">struct</span> S2 { <span class="d_keyword">int</span> blah(){ <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">class</span> C1 { <span class="d_keyword">int</span> blah; }
<span class="d_keyword">class</span> C2 { <span class="d_keyword">int</span> blah(){ <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(S1, <span class="d_string">"blah"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(S2, <span class="d_string">"blah"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(C1, <span class="d_string">"blah"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(C2, <span class="d_string">"blah"</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".EnumMembers"></a><div class="quickindex" id="quickindex.EnumMembers"></div>template <a name="EnumMembers"></a><span class="ddoc_psymbol">EnumMembers</span>(E) if (is(E == enum))</dt>
<dd><div class="summary">Retrieves the members of an enumerated type <span class="d_inlinecode donthyphenate notranslate">enum E</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">E</td>
<td class="param_desc">An enumerated type. <span class="d_inlinecode donthyphenate notranslate">E</span> may have duplicated values.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">Static tuple composed of the members of the enumerated type <span class="d_inlinecode donthyphenate notranslate">E</span>.
 The members are arranged in the same order as declared in <span class="d_inlinecode donthyphenate notranslate">E</span>.

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
An enum can have multiple members which have the same value. If you want
 to use <a name="EnumMembers"></a><span class="ddoc_psymbol">EnumMembers</span> to e.g. generate switch cases at compile-time,
 you should use the <span class="libref"><a href="http://dlang.org/phobos/std_typetuple.html#NoDuplicates"><span class="d_inlinecode donthyphenate notranslate">std.typetuple.NoDuplicates</span></a></span> template to avoid
 generating duplicate switch cases.

</p></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
 Returned values are strictly typed with <span class="d_inlinecode donthyphenate notranslate">E</span>. Thus, the following code
 does not work without the explicit cast:
<pre class="d_code notranslate"><span class="d_keyword">enum</span> E : <span class="d_keyword">int</span> { a, b, c }
<span class="d_keyword">int</span>[] abc = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[]) [ <span class="d_psymbol">EnumMembers</span>!E ];
</pre>
 Cast is not necessary if the type of the variable is inferred. See the
 example below.

</p></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
 Creating an array of enumerated values:
<pre class="d_code notranslate"><span class="d_keyword">enum</span> Sqrts : <span class="d_keyword">real</span>
{
    one   = 1,
    two   = 1.41421,
    three = 1.73205,
}
<span class="d_keyword">auto</span> sqrts = [ <span class="d_psymbol">EnumMembers</span>!Sqrts ];
<span class="d_keyword">assert</span>(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);
</pre>
<p></p>

 A generic function <span class="d_inlinecode donthyphenate notranslate">rank(v)</span> in the following example uses this
 template for finding a member <span class="d_inlinecode donthyphenate notranslate">e</span> in an enumerated type <span class="d_inlinecode donthyphenate notranslate">E</span>.
<pre class="d_code notranslate"><span class="d_comment">// Returns i if e is the i-th enumerator of E.
</span>size_t rank(E)(E e)
    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(E == <span class="d_keyword">enum</span>))
{
    <span class="d_keyword">foreach</span> (i, member; <span class="d_psymbol">EnumMembers</span>!E)
    {
        <span class="d_keyword">if</span> (e == member)
            <span class="d_keyword">return</span> i;
    }
    <span class="d_keyword">assert</span>(0, <span class="d_string">"Not an enum member"</span>);
}

<span class="d_keyword">enum</span> Mode
{
    read  = 1,
    write = 2,
    map   = 4,
}
<span class="d_keyword">assert</span>(rank(Mode.read ) == 0);
<span class="d_keyword">assert</span>(rank(Mode.write) == 1);
<span class="d_keyword">assert</span>(rank(Mode.map  ) == 2);
</pre>
</p></div>

</dd>
<dt class="d_decl"><a name=".BaseTypeTuple"></a><div class="quickindex" id="quickindex.BaseTypeTuple"></div>template <a name="BaseTypeTuple"></a><span class="ddoc_psymbol">BaseTypeTuple</span>(A)</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of the base class and base interfaces of
 this class or interface. <span class="d_param"><a name="BaseTypeTuple"></a><span class="ddoc_psymbol">BaseTypeTuple</span>!Object</span> returns
 the empty type tuple.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I1 { }
<span class="d_keyword">interface</span> I2 { }
<span class="d_keyword">interface</span> I12 : I1, I2 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseTypeTuple</span>!I12 == TypeTuple!(I1, I2)));

<span class="d_keyword">interface</span> I3 : I1 { }
<span class="d_keyword">interface</span> I123 : I1, I2, I3 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseTypeTuple</span>!I123 == TypeTuple!(I1, I2, I3)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".BaseClassesTuple"></a><div class="quickindex" id="quickindex.BaseClassesTuple"></div>template <a name="BaseClassesTuple"></a><span class="ddoc_psymbol">BaseClassesTuple</span>(T) if (is(T == class))</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of <i>all</i> base classes of this class,
 in decreasing order. Interfaces are not included. <span class="d_param"> <a name="BaseClassesTuple"></a><span class="ddoc_psymbol">BaseClassesTuple</span>!Object</span> yields the empty type tuple.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C1 { }
<span class="d_keyword">class</span> C2 : C1 { }
<span class="d_keyword">class</span> C3 : C2 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">BaseClassesTuple</span>!Object.length);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseClassesTuple</span>!C1 == TypeTuple!(Object)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseClassesTuple</span>!C2 == TypeTuple!(C1, Object)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseClassesTuple</span>!C3 == TypeTuple!(C2, C1, Object)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".InterfacesTuple"></a><div class="quickindex" id="quickindex.InterfacesTuple"></div>template <a name="InterfacesTuple"></a><span class="ddoc_psymbol">InterfacesTuple</span>(T)</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of <i>all</i> interfaces directly or
 indirectly inherited by this class or interface. Interfaces do not
 repeat if multiply implemented. <span class="d_param"><a name="InterfacesTuple"></a><span class="ddoc_psymbol">InterfacesTuple</span>!Object</span>
 yields the empty type tuple.</div>

</dd>
<dt class="d_decl"><a name=".TransitiveBaseTypeTuple"></a><div class="quickindex" id="quickindex.TransitiveBaseTypeTuple"></div>template <a name="TransitiveBaseTypeTuple"></a><span class="ddoc_psymbol">TransitiveBaseTypeTuple</span>(T)</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of <i>all</i> base classes of <span class="d_param"> T</span>, in decreasing order, followed by <span class="d_param">T</span>'s
 interfaces. <span class="d_param"><a name="TransitiveBaseTypeTuple"></a><span class="ddoc_psymbol">TransitiveBaseTypeTuple</span>!Object</span> yields the
 empty type tuple.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> J1 {}
<span class="d_keyword">interface</span> J2 {}
<span class="d_keyword">class</span> B1 {}
<span class="d_keyword">class</span> B2 : B1, J1, J2 {}
<span class="d_keyword">class</span> B3 : B2, J1 {}
<span class="d_keyword">alias</span> TL = <span class="d_psymbol">TransitiveBaseTypeTuple</span>!B3;
<span class="d_keyword">assert</span>(TL.length == 5);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[0] == B2));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[1] == B1));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[2] == Object));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[3] == J1));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[4] == J2));

<span class="d_keyword">assert</span>(<span class="d_psymbol">TransitiveBaseTypeTuple</span>!Object.length == 0);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".MemberFunctionsTuple"></a><div class="quickindex" id="quickindex.MemberFunctionsTuple"></div>template <a name="MemberFunctionsTuple"></a><span class="ddoc_psymbol">MemberFunctionsTuple</span>(C, string name) if (is(C == class) || is(C == interface))</dt>
<dd><div class="summary">Returns a tuple of non-static functions with the name <span class="d_inlinecode donthyphenate notranslate">name</span> declared in the
class or interface <span class="d_inlinecode donthyphenate notranslate">C</span>.  Covariant duplicates are shrunk into the most
derived one.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I { I foo(); }
<span class="d_keyword">class</span> B
{
    <span class="d_keyword">real</span> foo(<span class="d_keyword">real</span> v) { <span class="d_keyword">return</span> v; }
}
<span class="d_keyword">class</span> C : B, I
{
    <span class="d_keyword">override</span> C foo() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>; } <span class="d_comment">// covariant overriding of I.foo()
</span>}
<span class="d_keyword">alias</span> foos = <span class="d_psymbol">MemberFunctionsTuple</span>!(C, <span class="d_string">"foo"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(foos.length == 2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, foos[0], C.foo));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, foos[1], B.foo));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".TemplateOf"></a><div class="quickindex" id="quickindex.TemplateOf"></div>template <a name="TemplateOf"></a><span class="ddoc_psymbol">TemplateOf</span>(alias T : Base!Args, alias Base, Args...)<br>template <a name="TemplateOf"></a><span class="ddoc_psymbol">TemplateOf</span>(T : Base!Args, alias Base, Args...)</dt>
<dd><div class="summary">Returns an alias to the template that <span class="d_inlinecode donthyphenate notranslate">T</span> is an instance of.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> Foo(T, U) {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, <span class="d_psymbol">TemplateOf</span>!(Foo!(<span class="d_keyword">int</span>, <span class="d_keyword">real</span>)), Foo));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".TemplateArgsOf"></a><div class="quickindex" id="quickindex.TemplateArgsOf"></div>template <a name="TemplateArgsOf"></a><span class="ddoc_psymbol">TemplateArgsOf</span>(alias T : Base!Args, alias Base, Args...)<br>template <a name="TemplateArgsOf"></a><span class="ddoc_psymbol">TemplateArgsOf</span>(T : Base!Args, alias Base, Args...)</dt>
<dd><div class="summary">Returns a <span class="d_inlinecode donthyphenate notranslate">TypeTuple</span> of the template arguments used to instantiate <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> Foo(T, U) {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">TemplateArgsOf</span>!(Foo!(<span class="d_keyword">int</span>, <span class="d_keyword">real</span>)) == TypeTuple!(<span class="d_keyword">int</span>, <span class="d_keyword">real</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".classInstanceAlignment"></a><div class="quickindex" id="quickindex.classInstanceAlignment"></div>template <a name="classInstanceAlignment"></a><span class="ddoc_psymbol">classInstanceAlignment</span>(T) if (is(T == class))</dt>
<dd><div class="summary">Returns class instance alignment.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> A { <span class="d_keyword">byte</span> b; }
<span class="d_keyword">class</span> B { <span class="d_keyword">long</span> l; }

<span class="d_comment">// As class instance always has a hidden pointer
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">classInstanceAlignment</span>!A == (<span class="d_keyword">void</span>*).alignof);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">classInstanceAlignment</span>!B == <span class="d_keyword">long</span>.alignof);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".CommonType"></a><div class="quickindex" id="quickindex.CommonType"></div>template <a name="CommonType"></a><span class="ddoc_psymbol">CommonType</span>(T...)</dt>
<dd><div class="summary">Get the type that all types can be implicitly converted to. Useful
e.g. in figuring out an array type from a bunch of initializing
values. Returns <span class="d_param">void</span> if passed an empty list, or if the
types have no common type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> X = <span class="d_psymbol">CommonType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>, <span class="d_keyword">short</span>);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(X == <span class="d_keyword">long</span>));
<span class="d_keyword">alias</span> Y = <span class="d_psymbol">CommonType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">char</span>[], <span class="d_keyword">short</span>);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Y == <span class="d_keyword">void</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ImplicitConversionTargets"></a><div class="quickindex" id="quickindex.ImplicitConversionTargets"></div>template <a name="ImplicitConversionTargets"></a><span class="ddoc_psymbol">ImplicitConversionTargets</span>(T)</dt>
<dd><div class="summary">Returns a tuple with all possible target types of an implicit
 conversion of a value of type <span class="d_param">T</span>.
</div>
<div class="description">Important note:
<p></p>

 The possible targets are computed more conservatively than the D
 2.005 compiler does, eliminating all dangerous conversions. For
 example, <span class="d_param"><a name="ImplicitConversionTargets"></a><span class="ddoc_psymbol">ImplicitConversionTargets</span>!double</span> does not
 include <span class="d_param">float</span>.</div>

</dd>
<dt class="d_decl"><a name=".isImplicitlyConvertible"></a><div class="quickindex" id="quickindex.isImplicitlyConvertible"></div>enum bool <a name="isImplicitlyConvertible"></a><span class="ddoc_psymbol">isImplicitlyConvertible</span>(From, To);
</dt>
<dd><div class="summary">Is <span class="d_inlinecode donthyphenate notranslate">From</span> implicitly convertible to <span class="d_inlinecode donthyphenate notranslate">To</span>?</div>

</dd>
<dt class="d_decl"><a name=".isAssignable"></a><div class="quickindex" id="quickindex.isAssignable"></div>enum auto <a name="isAssignable"></a><span class="ddoc_psymbol">isAssignable</span>(Lhs, Rhs = Lhs);
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> iff a value of type <span class="d_inlinecode donthyphenate notranslate">Rhs</span> can be assigned to a variable of
type <span class="d_inlinecode donthyphenate notranslate">Lhs</span>.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="isAssignable"></a><span class="ddoc_psymbol">isAssignable</span></span> returns whether both an lvalue and rvalue can be assigned.
<p></p>

If you omit <span class="d_inlinecode donthyphenate notranslate">Rhs</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="isAssignable"></a><span class="ddoc_psymbol">isAssignable</span></span> will check identity assignable of <span class="d_inlinecode donthyphenate notranslate">Lhs</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">long</span>, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[], string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAssignable</span>!(string, <span class="d_keyword">char</span>[]));

<span class="d_comment">// int is assignable to int
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAssignable</span>!<span class="d_keyword">int</span>);

<span class="d_comment">// immutable int is not assignable to immutable int
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isCovariantWith"></a><div class="quickindex" id="quickindex.isCovariantWith"></div>template <a name="isCovariantWith"></a><span class="ddoc_psymbol">isCovariantWith</span>(F, G) if (is(F == function) &amp;&amp; is(G == function))</dt>
<dd><div class="summary">Determines whether the function type <span class="d_inlinecode donthyphenate notranslate">F</span> is covariant with <span class="d_inlinecode donthyphenate notranslate">G</span>, i.e.,
functions of the type <span class="d_inlinecode donthyphenate notranslate">F</span> can override ones of the type <span class="d_inlinecode donthyphenate notranslate">G</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I { I clone(); }
<span class="d_keyword">interface</span> J { J clone(); }
<span class="d_keyword">class</span> C : I
{
    <span class="d_keyword">override</span> C clone()   <span class="d_comment">// covariant overriding of I.clone()
</span>    {
        <span class="d_keyword">return</span> <span class="d_keyword">new</span> C;
    }
}

<span class="d_comment">// C.clone() can override I.clone(), indeed.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isCovariantWith</span>!(<span class="d_keyword">typeof</span>(C.clone), <span class="d_keyword">typeof</span>(I.clone)));

<span class="d_comment">// C.clone() can't override J.clone(); the return type C is not implicitly
</span><span class="d_comment">// convertible to J.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isCovariantWith</span>!(<span class="d_keyword">typeof</span>(C.clone), <span class="d_keyword">typeof</span>(J.clone)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".rvalueOf"></a><div class="quickindex" id="quickindex.rvalueOf"></div>@property T <a name="rvalueOf"></a><span class="ddoc_psymbol">rvalueOf</span>(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init);
<br><a name=".lvalueOf"></a><div class="quickindex" id="quickindex.lvalueOf"></div>@property ref T <a name="lvalueOf"></a><span class="ddoc_psymbol">lvalueOf</span>(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init);
</dt>
<dd><div class="summary">Creates an lvalue or rvalue of type <span class="d_inlinecode donthyphenate notranslate">T</span> for <span class="d_inlinecode donthyphenate notranslate">typeof(...)</span> and
<span class="d_inlinecode donthyphenate notranslate">_traits(compiles, ...)</span> purposes. No actual value is returned.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Trying to use returned value will result in a
"Symbol Undefined" error at link time.

</p></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_comment">// Note that `f` doesn't have to be implemented
</span><span class="d_comment">// as is isn't called.
</span><span class="d_keyword">int</span> f(<span class="d_keyword">int</span>);
<span class="d_keyword">bool</span> f(<span class="d_keyword">ref</span> <span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(f(<span class="d_psymbol">rvalueOf</span>!<span class="d_keyword">int</span>)) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(f(<span class="d_psymbol">lvalueOf</span>!<span class="d_keyword">int</span>)) == <span class="d_keyword">bool</span>));

<span class="d_keyword">int</span> i = <span class="d_psymbol">rvalueOf</span>!<span class="d_keyword">int</span>; <span class="d_comment">// error, no actual value is returned
</span></pre>
</p></div>

</dd>
<dt class="d_decl"><a name=".isBoolean"></a><div class="quickindex" id="quickindex.isBoolean"></div>enum bool <a name="isBoolean"></a><span class="ddoc_psymbol">isBoolean</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in boolean type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBoolean</span>!<span class="d_keyword">bool</span>);
<span class="d_keyword">enum</span> EB : <span class="d_keyword">bool</span> { a = <span class="d_keyword">true</span> }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBoolean</span>!EB);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBoolean</span>!(SubTypeOf!<span class="d_keyword">bool</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isIntegral"></a><div class="quickindex" id="quickindex.isIntegral"></div>enum bool <a name="isIntegral"></a><span class="ddoc_psymbol">isIntegral</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in integral type. Types <span class="d_inlinecode donthyphenate notranslate">bool</span>,
 <span class="d_inlinecode donthyphenate notranslate">char</span>, <span class="d_inlinecode donthyphenate notranslate">wchar</span>, and <span class="d_inlinecode donthyphenate notranslate">dchar</span> are not considered integral.</div>

</dd>
<dt class="d_decl"><a name=".isFloatingPoint"></a><div class="quickindex" id="quickindex.isFloatingPoint"></div>enum bool <a name="isFloatingPoint"></a><span class="ddoc_psymbol">isFloatingPoint</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in floating point type.</div>

</dd>
<dt class="d_decl"><a name=".isNumeric"></a><div class="quickindex" id="quickindex.isNumeric"></div>enum bool <a name="isNumeric"></a><span class="ddoc_psymbol">isNumeric</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in numeric type (integral or floating
point).</div>

</dd>
<dt class="d_decl"><a name=".isScalarType"></a><div class="quickindex" id="quickindex.isScalarType"></div>enum bool <a name="isScalarType"></a><span class="ddoc_psymbol">isScalarType</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a scalar type (a built-in numeric, character or boolean type).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isScalarType</span>!<span class="d_keyword">void</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">float</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">bool</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">dchar</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isBasicType"></a><div class="quickindex" id="quickindex.isBasicType"></div>enum bool <a name="isBasicType"></a><span class="ddoc_psymbol">isBasicType</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a basic type (scalar type or void).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!<span class="d_keyword">void</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">float</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">bool</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">dchar</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isUnsigned"></a><div class="quickindex" id="quickindex.isUnsigned"></div>enum bool <a name="isUnsigned"></a><span class="ddoc_psymbol">isUnsigned</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in unsigned numeric type.</div>

</dd>
<dt class="d_decl"><a name=".isSigned"></a><div class="quickindex" id="quickindex.isSigned"></div>enum bool <a name="isSigned"></a><span class="ddoc_psymbol">isSigned</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in signed numeric type.</div>

</dd>
<dt class="d_decl"><a name=".isSomeChar"></a><div class="quickindex" id="quickindex.isSomeChar"></div>enum bool <a name="isSomeChar"></a><span class="ddoc_psymbol">isSomeChar</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is one of the built-in character types.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!<span class="d_keyword">byte</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!wstring);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!dstring);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!(<span class="d_keyword">char</span>[4]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isSomeString"></a><div class="quickindex" id="quickindex.isSomeString"></div>enum bool <a name="isSomeString"></a><span class="ddoc_psymbol">isSomeString</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is one of the built-in string types.
</div>
<div class="description">The built-in string types are <span class="d_inlinecode donthyphenate notranslate">Char[]</span>, where <span class="d_inlinecode donthyphenate notranslate">Char</span> is any of <span class="d_inlinecode donthyphenate notranslate">char</span>,
<span class="d_inlinecode donthyphenate notranslate">wchar</span> or <span class="d_inlinecode donthyphenate notranslate">dchar</span>, with or without qualifiers.
<p></p>

Static arrays of characters (like <span class="d_inlinecode donthyphenate notranslate">char[80]</span>) are not considered
built-in string types.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">byte</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">typeof</span>(<span class="d_keyword">null</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">char</span>[4]));

<span class="d_keyword">enum</span> ES : string { a = <span class="d_string">"aaa"</span>, b = <span class="d_string">"bbb"</span> }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isSomeString</span>!ES);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isNarrowString"></a><div class="quickindex" id="quickindex.isNarrowString"></div>enum bool <a name="isNarrowString"></a><span class="ddoc_psymbol">isNarrowString</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a narrow string.
</div>
<div class="description">All arrays that use char, wchar, and their qualified versions are narrow
 strings. (Those include string and wstring).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isNarrowString</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isNarrowString</span>!wstring);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isNarrowString</span>!(<span class="d_keyword">char</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isNarrowString</span>!(<span class="d_keyword">wchar</span>[]));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isNarrowString</span>!dstring);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isNarrowString</span>!(<span class="d_keyword">dchar</span>[]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isAutodecodableString"></a><div class="quickindex" id="quickindex.isAutodecodableString"></div>enum bool <a name="isAutodecodableString"></a><span class="ddoc_psymbol">isAutodecodableString</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a string that will be autodecoded.
</div>
<div class="description">All arrays that use char, wchar, and their qualified versions are narrow
 strings. (Those include string and wstring).
 Aggregates that implicitly cast to narrow strings are included.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T</td>
<td class="param_desc">type to be tested</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>true</b> if T represents a string that is subject to autodecoding
<p></p>

 See Also:
      <a href="#isNarrowString"><span class="d_inlinecode donthyphenate notranslate">isNarrowString</span></a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Stringish
{
    string s;
    <span class="d_keyword">alias</span> s <span class="d_keyword">this</span>;
}
<span class="d_keyword">assert</span>(<span class="d_psymbol">isAutodecodableString</span>!wstring);
<span class="d_keyword">assert</span>(<span class="d_psymbol">isAutodecodableString</span>!Stringish);
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isAutodecodableString</span>!dstring);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isStaticArray"></a><div class="quickindex" id="quickindex.isStaticArray"></div>enum bool <a name="isStaticArray"></a><span class="ddoc_psymbol">isStaticArray</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a static array.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[4][]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[<span class="d_keyword">char</span>]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[1][]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[<span class="d_keyword">int</span>]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!<span class="d_keyword">int</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isDynamicArray"></a><div class="quickindex" id="quickindex.isDynamicArray"></div>enum bool <a name="isDynamicArray"></a><span class="ddoc_psymbol">isDynamicArray</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a dynamic array.</div>

</dd>
<dt class="d_decl"><a name=".isArray"></a><div class="quickindex" id="quickindex.isArray"></div>enum bool <a name="isArray"></a><span class="ddoc_psymbol">isArray</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is an array (static or dynamic; for associative
  arrays see <a href="#isAssociativeArray"><span class="d_inlinecode donthyphenate notranslate">isAssociativeArray</span></a>).</div>

</dd>
<dt class="d_decl"><a name=".isAssociativeArray"></a><div class="quickindex" id="quickindex.isAssociativeArray"></div>enum bool <a name="isAssociativeArray"></a><span class="ddoc_psymbol">isAssociativeArray</span>(T);
</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is an associative array type</div>

</dd>
<dt class="d_decl"><a name=".isBuiltinType"></a><div class="quickindex" id="quickindex.isBuiltinType"></div>enum bool <a name="isBuiltinType"></a><span class="ddoc_psymbol">isBuiltinType</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a builtin type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C;
<span class="d_keyword">union</span> U;
<span class="d_keyword">struct</span> S;
<span class="d_keyword">interface</span> I;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBuiltinType</span>!<span class="d_keyword">void</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBuiltinType</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBuiltinType</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBuiltinType</span>!(C[string]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBuiltinType</span>!C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBuiltinType</span>!U);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBuiltinType</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBuiltinType</span>!I);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBuiltinType</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isSIMDVector"></a><div class="quickindex" id="quickindex.isSIMDVector"></div>enum bool <a name="isSIMDVector"></a><span class="ddoc_psymbol">isSIMDVector</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a SIMD vector type.</div>

</dd>
<dt class="d_decl"><a name=".isPointer"></a><div class="quickindex" id="quickindex.isPointer"></div>enum bool <a name="isPointer"></a><span class="ddoc_psymbol">isPointer</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a pointer.</div>

</dd>
<dt class="d_decl"><a name=".PointerTarget"></a><div class="quickindex" id="quickindex.PointerTarget"></div>template <a name="PointerTarget"></a><span class="ddoc_psymbol">PointerTarget</span>(T : T*)</dt>
<dd><div class="summary">Returns the target type of a pointer.</div>

</dd>
<dt class="d_decl"><a name=".isAggregateType"></a><div class="quickindex" id="quickindex.isAggregateType"></div>enum bool <a name="isAggregateType"></a><span class="ddoc_psymbol">isAggregateType</span>(T);
</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is an aggregate type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C;
<span class="d_keyword">union</span> U;
<span class="d_keyword">struct</span> S;
<span class="d_keyword">interface</span> I;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAggregateType</span>!C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAggregateType</span>!U);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAggregateType</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAggregateType</span>!I);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAggregateType</span>!<span class="d_keyword">void</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAggregateType</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAggregateType</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAggregateType</span>!(C[string]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAggregateType</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isIterable"></a><div class="quickindex" id="quickindex.isIterable"></div>enum bool <a name="isIterable"></a><span class="ddoc_psymbol">isIterable</span>(T);
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if T can be iterated over using a <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop with
 a single loop variable of automatically inferred type, regardless of how
 the <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop is implemented.  This includes ranges, structs/classes
 that define <span class="d_inlinecode donthyphenate notranslate">opApply</span> with a single loop variable, and builtin dynamic,
 static and associative arrays.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> OpApply
{
    <span class="d_keyword">int</span> opApply(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">ref</span> <span class="d_keyword">uint</span>) dg) { <span class="d_keyword">assert</span>(0); }
}

<span class="d_keyword">struct</span> Range
{
    @property <span class="d_keyword">uint</span> front() { <span class="d_keyword">assert</span>(0); }
    <span class="d_keyword">void</span> popFront() { <span class="d_keyword">assert</span>(0); }
    <span class="d_keyword">enum</span> <span class="d_keyword">bool</span> empty = <span class="d_keyword">false</span>;
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!(<span class="d_keyword">uint</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!OpApply);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!(<span class="d_keyword">uint</span>[string]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!Range);

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isIterable</span>!<span class="d_keyword">uint</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isMutable"></a><div class="quickindex" id="quickindex.isMutable"></div>enum bool <a name="isMutable"></a><span class="ddoc_psymbol">isMutable</span>(T);
</dt>
<dd><div class="summary">Returns <b>true</b> if T is not const or immutable.  Note that <a name="isMutable"></a><span class="ddoc_psymbol">isMutable</span> is <b>true</b> for
 string, or immutable(char)[], because the 'head' is mutable.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">inout</span> <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">inout</span> <span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">immutable</span> string));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isInstanceOf"></a><div class="quickindex" id="quickindex.isInstanceOf"></div>enum bool <a name="isInstanceOf"></a><span class="ddoc_psymbol">isInstanceOf</span>(alias S, T);
</dt>
<dd><div class="summary">Returns <b>true</b> if T is an instance of the template S.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Foo(T...) { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Bar(T...) { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Doo(T) { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> ABC(<span class="d_keyword">int</span> x) { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isInstanceOf</span>!(Foo, Foo!<span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isInstanceOf</span>!(Foo, Bar!<span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isInstanceOf</span>!(Foo, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isInstanceOf</span>!(Doo, Doo!<span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isInstanceOf</span>!(ABC, ABC!1));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, <span class="d_psymbol">isInstanceOf</span>!(Foo, Foo)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isExpressions"></a><div class="quickindex" id="quickindex.isExpressions"></div>template <a name="isExpressions"></a><span class="ddoc_psymbol">isExpressions</span>(T...)</dt>
<dd><div class="summary">Check whether the tuple T is an expression tuple.
 An expression tuple only contains expressions.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#isTypeTuple"><span class="d_inlinecode donthyphenate notranslate">isTypeTuple</span></a>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isExpressions</span>!(1, 2.0, <span class="d_string">"a"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isExpressions</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isExpressions</span>!(<span class="d_keyword">int</span>, 2.0, <span class="d_string">"a"</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isExpressionTuple"></a><div class="quickindex" id="quickindex.isExpressionTuple"></div>alias <a name="isExpressionTuple"></a><span class="ddoc_psymbol">isExpressionTuple</span> = isExpressions(T...);
</dt>
<dd><div class="summary">Alternate name for <a href="#isExpressions"><span class="d_inlinecode donthyphenate notranslate">isExpressions</span></a>, kept for legacy compatibility.</div>

</dd>
<dt class="d_decl"><a name=".isTypeTuple"></a><div class="quickindex" id="quickindex.isTypeTuple"></div>template <a name="isTypeTuple"></a><span class="ddoc_psymbol">isTypeTuple</span>(T...)</dt>
<dd><div class="summary">Check whether the tuple <span class="d_inlinecode donthyphenate notranslate">T</span> is a type tuple.
 A type tuple only contains types.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#isExpressions"><span class="d_inlinecode donthyphenate notranslate">isExpressions</span></a>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isTypeTuple</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">float</span>, string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isTypeTuple</span>!(1, 2.0, <span class="d_string">"a"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isTypeTuple</span>!(1, <span class="d_keyword">double</span>, string));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isFunctionPointer"></a><div class="quickindex" id="quickindex.isFunctionPointer"></div>template <a name="isFunctionPointer"></a><span class="ddoc_psymbol">isFunctionPointer</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether symbol or type <span class="d_inlinecode donthyphenate notranslate">T</span> is a function pointer.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">void</span> foo() {}
<span class="d_keyword">void</span> bar() {}

<span class="d_keyword">auto</span> fpfoo = &amp;foo;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFunctionPointer</span>!fpfoo);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFunctionPointer</span>!(<span class="d_keyword">void</span> <span class="d_keyword">function</span>()));

<span class="d_keyword">auto</span> dgbar = &amp;bar;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!dgbar);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!foo);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!bar);

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFunctionPointer</span>!((<span class="d_keyword">int</span> a) {}));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isDelegate"></a><div class="quickindex" id="quickindex.isDelegate"></div>template <a name="isDelegate"></a><span class="ddoc_psymbol">isDelegate</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether symbol or type <span class="d_inlinecode donthyphenate notranslate">T</span> is a delegate.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">void</span> sfunc() { }
<span class="d_keyword">int</span> x;
<span class="d_keyword">void</span> func() { x++; }

<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
<span class="d_keyword">assert</span>(<span class="d_psymbol">isDelegate</span>!dg);
<span class="d_keyword">assert</span>(<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>()));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">typeof</span>(&amp;func)));

<span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isDelegate</span>!fp);
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">int</span> <span class="d_keyword">function</span>()));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">typeof</span>(&amp;sfunc)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isSomeFunction"></a><div class="quickindex" id="quickindex.isSomeFunction"></div>template <a name="isSomeFunction"></a><span class="ddoc_psymbol">isSomeFunction</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether symbol or type <span class="d_inlinecode donthyphenate notranslate">T</span> is a function, a function pointer or a delegate.</div>

</dd>
<dt class="d_decl"><a name=".isCallable"></a><div class="quickindex" id="quickindex.isCallable"></div>template <a name="isCallable"></a><span class="ddoc_psymbol">isCallable</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a callable object, which can be called with the
function call operator <span class="d_inlinecode donthyphenate notranslate">(...)</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I { <span class="d_keyword">real</span> value() @property; }
<span class="d_keyword">struct</span> S { <span class="d_keyword">static</span> <span class="d_keyword">int</span> opCall(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">class</span> C { <span class="d_keyword">int</span> opCall(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!c);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!(c.opCall));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!(I.value));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!((<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> a; }));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isCallable</span>!I);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isAbstractFunction"></a><div class="quickindex" id="quickindex.isAbstractFunction"></div>template <a name="isAbstractFunction"></a><span class="ddoc_psymbol">isAbstractFunction</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a an abstract function.</div>

</dd>
<dt class="d_decl"><a name=".isFinalFunction"></a><div class="quickindex" id="quickindex.isFinalFunction"></div>template <a name="isFinalFunction"></a><span class="ddoc_psymbol">isFinalFunction</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a a final function.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { <span class="d_keyword">void</span> bar() { } }
<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC { <span class="d_keyword">void</span> foo(); }
<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> bar() { }
    <span class="d_keyword">final</span> <span class="d_keyword">void</span> foo();
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalFunction</span>!(S.bar));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalFunction</span>!(FC.foo));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalFunction</span>!(C.bar));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalFunction</span>!(C.foo));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isNestedFunction"></a><div class="quickindex" id="quickindex.isNestedFunction"></div>enum auto <a name="isNestedFunction"></a><span class="ddoc_psymbol">isNestedFunction</span>(alias f);
</dt>
<dd><div class="summary">Determines whether function <span class="d_inlinecode donthyphenate notranslate">f</span> requires a context pointer.</div>

</dd>
<dt class="d_decl"><a name=".isAbstractClass"></a><div class="quickindex" id="quickindex.isAbstractClass"></div>template <a name="isAbstractClass"></a><span class="ddoc_psymbol">isAbstractClass</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a an abstract class.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { }
<span class="d_keyword">class</span> C { }
<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> AC { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAbstractClass</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAbstractClass</span>!C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAbstractClass</span>!AC);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isFinalClass"></a><div class="quickindex" id="quickindex.isFinalClass"></div>template <a name="isFinalClass"></a><span class="ddoc_psymbol">isFinalClass</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a a final class.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C { }
<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> AC { }
<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC1 : C { }
<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC2 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalClass</span>!C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalClass</span>!AC);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalClass</span>!FC1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalClass</span>!FC2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Unqual"></a><div class="quickindex" id="quickindex.Unqual"></div>template <a name="Unqual"></a><span class="ddoc_psymbol">Unqual</span>(T)</dt>
<dd><div class="summary">Removes all qualifiers, if any, from type <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!<span class="d_keyword">int</span> == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">int</span>)) == <span class="d_keyword">int</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".CopyTypeQualifiers"></a><div class="quickindex" id="quickindex.CopyTypeQualifiers"></div>template <a name="CopyTypeQualifiers"></a><span class="ddoc_psymbol">CopyTypeQualifiers</span>(FromType, ToType)</dt>
<dd><div class="summary">Copies type qualifiers from <span class="d_inlinecode donthyphenate notranslate">FromType</span> to <span class="d_inlinecode donthyphenate notranslate">ToType</span>.
</div>
<div class="description">Supported type qualifiers:
 <ul>     <li><span class="d_inlinecode donthyphenate notranslate">const</span></li>
     <li><span class="d_inlinecode donthyphenate notranslate">inout</span></li>
     <li><span class="d_inlinecode donthyphenate notranslate">immutable</span></li>
     <li><span class="d_inlinecode donthyphenate notranslate">shared</span></li>
 </ul>
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">CopyTypeQualifiers</span>!(<span class="d_keyword">inout</span> <span class="d_keyword">const</span> <span class="d_keyword">real</span>, <span class="d_keyword">int</span>) == <span class="d_keyword">inout</span> <span class="d_keyword">const</span> <span class="d_keyword">int</span>));
</pre>
</p></div>

</dd>
<dt class="d_decl"><a name=".CopyConstness"></a><div class="quickindex" id="quickindex.CopyConstness"></div>template <a name="CopyConstness"></a><span class="ddoc_psymbol">CopyConstness</span>(FromType, ToType)</dt>
<dd><div class="summary">Returns the type of <span class="d_inlinecode donthyphenate notranslate">Target</span> with the "constness" of <span class="d_inlinecode donthyphenate notranslate">Source</span>. A type's <!--UNDEFINED MACRO: "BOLD"-->
refers to whether it is <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span>, or <span class="d_inlinecode donthyphenate notranslate">inout</span>. If <span class="d_inlinecode donthyphenate notranslate">source</span> has no constness, the
returned type will be the same as <span class="d_inlinecode donthyphenate notranslate">Target</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">const</span>(<span class="d_keyword">int</span>) i;
<span class="d_psymbol">CopyConstness</span>!(<span class="d_keyword">typeof</span>(i), <span class="d_keyword">float</span>) f;
<span class="d_keyword">assert</span>( <span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(f) == <span class="d_keyword">const</span> <span class="d_keyword">float</span>));

<span class="d_psymbol">CopyConstness</span>!(<span class="d_keyword">char</span>, <span class="d_keyword">uint</span>) u;
<span class="d_keyword">assert</span>( <span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(u) == <span class="d_keyword">uint</span>));

<span class="d_comment">//The 'shared' qualifier will not be copied
</span><span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_psymbol">CopyConstness</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">bool</span>, <span class="d_keyword">int</span>) == <span class="d_keyword">shared</span> <span class="d_keyword">int</span>));

<span class="d_comment">//But the constness will be
</span><span class="d_keyword">assert</span>( <span class="d_keyword">is</span>(<span class="d_psymbol">CopyConstness</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">const</span> <span class="d_keyword">real</span>, <span class="d_keyword">double</span>) == <span class="d_keyword">const</span> <span class="d_keyword">double</span>));

<span class="d_comment">//Careful, const(int)[] is a mutable array of const(int)
</span><span class="d_keyword">alias</span> MutT = <span class="d_psymbol">CopyConstness</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[], <span class="d_keyword">int</span>);
<span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(MutT == <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)));

<span class="d_comment">//Okay, const(int[]) applies to array and contained ints
</span><span class="d_keyword">alias</span> CstT = <span class="d_psymbol">CopyConstness</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>[]), <span class="d_keyword">int</span>);
<span class="d_keyword">assert</span>( <span class="d_keyword">is</span>(CstT == <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ForeachType"></a><div class="quickindex" id="quickindex.ForeachType"></div>template <a name="ForeachType"></a><span class="ddoc_psymbol">ForeachType</span>(T)</dt>
<dd><div class="summary">Returns the inferred type of the loop variable when a variable of type T
is iterated over using a <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop with a single loop variable and
automatically inferred return type.  Note that this may not be the same as
<span class="d_inlinecode donthyphenate notranslate">std.range.ElementType!Range</span> in the case of narrow strings, or if T
has both opApply and a range interface.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!(<span class="d_keyword">uint</span>[]) == <span class="d_keyword">uint</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!string == <span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!(string[string]) == string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]) == <span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".OriginalType"></a><div class="quickindex" id="quickindex.OriginalType"></div>template <a name="OriginalType"></a><span class="ddoc_psymbol">OriginalType</span>(T)</dt>
<dd><div class="summary">Strips off all <span class="d_inlinecode donthyphenate notranslate">enum</span>s from type <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">enum</span> E : <span class="d_keyword">real</span> { a }
<span class="d_keyword">enum</span> F : E    { a = E.a }
<span class="d_keyword">alias</span> G = <span class="d_keyword">const</span>(F);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">OriginalType</span>!E == <span class="d_keyword">real</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">OriginalType</span>!F == <span class="d_keyword">real</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">OriginalType</span>!G == <span class="d_keyword">const</span> <span class="d_keyword">real</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".KeyType"></a><div class="quickindex" id="quickindex.KeyType"></div>template <a name="KeyType"></a><span class="ddoc_psymbol">KeyType</span>(V : V[K], K)</dt>
<dd><div class="summary">Get the Key type of an Associative Array.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">alias</span> Hash = <span class="d_keyword">int</span>[string];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">KeyType</span>!Hash == string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(ValueType!Hash == <span class="d_keyword">int</span>));
<span class="d_psymbol">KeyType</span>!Hash str = <span class="d_string">"a"</span>; <span class="d_comment">// str is declared as string
</span>ValueType!Hash num = 1; <span class="d_comment">// num is declared as int
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ValueType"></a><div class="quickindex" id="quickindex.ValueType"></div>template <a name="ValueType"></a><span class="ddoc_psymbol">ValueType</span>(V : V[K], K)</dt>
<dd><div class="summary">Get the Value type of an Associative Array.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">alias</span> Hash = <span class="d_keyword">int</span>[string];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(KeyType!Hash == string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ValueType</span>!Hash == <span class="d_keyword">int</span>));
KeyType!Hash str = <span class="d_string">"a"</span>; <span class="d_comment">// str is declared as string
</span><span class="d_psymbol">ValueType</span>!Hash num = 1; <span class="d_comment">// num is declared as int
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Unsigned"></a><div class="quickindex" id="quickindex.Unsigned"></div>template <a name="Unsigned"></a><span class="ddoc_psymbol">Unsigned</span>(T)</dt>
<dd><div class="summary">Returns the corresponding unsigned type for T. T must be a numeric
 integral type, otherwise a compile-time error occurs.</div>

</dd>
<dt class="d_decl"><a name=".Largest"></a><div class="quickindex" id="quickindex.Largest"></div>template <a name="Largest"></a><span class="ddoc_psymbol">Largest</span>(T...) if (T.length &gt;= 1)</dt>
<dd><div class="summary">Returns the largest type, i.e. T such that T.sizeof is the largest.  If more
than one type is of the same size, the leftmost argument of these in will be
returned.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">uint</span>, <span class="d_keyword">ubyte</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">real</span>) == <span class="d_keyword">real</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">ulong</span>, <span class="d_keyword">double</span>) == <span class="d_keyword">ulong</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">double</span>, <span class="d_keyword">ulong</span>) == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">uint</span>, <span class="d_keyword">byte</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>) == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">ucent</span>))
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">uint</span>, <span class="d_keyword">ubyte</span>, <span class="d_keyword">ucent</span>, <span class="d_keyword">ushort</span>) == <span class="d_keyword">ucent</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Signed"></a><div class="quickindex" id="quickindex.Signed"></div>template <a name="Signed"></a><span class="ddoc_psymbol">Signed</span>(T)</dt>
<dd><div class="summary">Returns the corresponding signed type for T. T must be a numeric integral type,
otherwise a compile-time error occurs.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> S1 = <span class="d_psymbol">Signed</span>!<span class="d_keyword">uint</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S1 == <span class="d_keyword">int</span>));
<span class="d_keyword">alias</span> S2 = <span class="d_psymbol">Signed</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">uint</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S2 == <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)));
<span class="d_keyword">alias</span> S3 = <span class="d_psymbol">Signed</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">uint</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S3 == <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">ucent</span>))
{
    <span class="d_keyword">alias</span> S4 = <span class="d_psymbol">Signed</span>!<span class="d_keyword">ucent</span>;
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S4 == <span class="d_keyword">cent</span>));
}
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".mostNegative"></a><div class="quickindex" id="quickindex.mostNegative"></div>template <a name="mostNegative"></a><span class="ddoc_psymbol">mostNegative</span>(T) if (isNumeric!T || isSomeChar!T || isBoolean!T)</dt>
<dd><div class="summary">Returns the most negative value of the numeric type T.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">float</span> == -<span class="d_keyword">float</span>.max);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">double</span> == -<span class="d_keyword">double</span>.max);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">real</span> == -<span class="d_keyword">real</span>.max);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">bool</span> == <span class="d_keyword">false</span>);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">foreach</span>(T; TypeTuple!(<span class="d_keyword">bool</span>, <span class="d_keyword">byte</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>))
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!T == T.min);

<span class="d_keyword">foreach</span>(T; TypeTuple!(<span class="d_keyword">ubyte</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">ulong</span>, <span class="d_keyword">char</span>, <span class="d_keyword">wchar</span>, <span class="d_keyword">dchar</span>))
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!T == 0);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".mangledName"></a><div class="quickindex" id="quickindex.mangledName"></div>template <a name="mangledName"></a><span class="ddoc_psymbol">mangledName</span>(sth...) if (sth.length == 1)</dt>
<dd><div class="summary">Returns the mangled name of symbol or type <span class="d_inlinecode donthyphenate notranslate">sth</span>.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="mangledName"></a><span class="ddoc_psymbol">mangledName</span></span> is the same as builtin <span class="d_inlinecode donthyphenate notranslate">.mangleof</span> property, except that
the correct names of property functions are obtained.
<pre class="d_code notranslate"><span class="d_keyword">module</span> test;
<span class="d_keyword">import</span> std.traits : <span class="d_psymbol">mangledName</span>;

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> value() @property;
}
<span class="d_keyword">pragma</span>(msg, C.value.mangleof);      <span class="d_comment">// prints "i"
</span><span class="d_keyword">pragma</span>(msg, <span class="d_psymbol">mangledName</span>!(C.value)); <span class="d_comment">// prints "_D4test1C5valueMFNdZi"
</span></pre>
</div>

</dd>
<dt class="d_decl"><a name=".Select"></a><div class="quickindex" id="quickindex.Select"></div>template <a name="Select"></a><span class="ddoc_psymbol">Select</span>(bool condition, T...) if (T.length == 2)</dt>
<dd><div class="summary">Aliases itself to <span class="d_inlinecode donthyphenate notranslate">T[0]</span> if the boolean <span class="d_inlinecode donthyphenate notranslate">condition</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>
and to <span class="d_inlinecode donthyphenate notranslate">T[1]</span> otherwise.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// can select types
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Select</span>!(<span class="d_keyword">true</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Select</span>!(<span class="d_keyword">false</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) == <span class="d_keyword">long</span>));

<span class="d_comment">// can select symbols
</span><span class="d_keyword">int</span> a = 1;
<span class="d_keyword">int</span> b = 2;
<span class="d_keyword">alias</span> selA = <span class="d_psymbol">Select</span>!(<span class="d_keyword">true</span>, a, b);
<span class="d_keyword">alias</span> selB = <span class="d_psymbol">Select</span>!(<span class="d_keyword">false</span>, a, b);
<span class="d_keyword">assert</span>(selA == 1);
<span class="d_keyword">assert</span>(selB == 2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".select"></a><div class="quickindex" id="quickindex.select"></div>A <a name="select"></a><span class="ddoc_psymbol">select</span>(bool cond : true, A, B)(A <i>a</i>, lazy B <i>b</i>);
<br>B <a name="select"></a><span class="ddoc_psymbol">select</span>(bool cond : false, A, B)(lazy A <i>a</i>, B <i>b</i>);
</dt>
<dd><div class="summary">If <span class="d_inlinecode donthyphenate notranslate">cond</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>, returns <span class="d_inlinecode donthyphenate notranslate"><i>a</i></span> without evaluating <span class="d_inlinecode donthyphenate notranslate"><i>b</i></span>. Otherwise, returns <span class="d_inlinecode donthyphenate notranslate"><i>b</i></span> without evaluating <span class="d_inlinecode donthyphenate notranslate"><i>a</i></span>.</div>

</dd>
<dt class="d_decl"><a name=".hasUDA"></a><div class="quickindex" id="quickindex.hasUDA"></div>template <a name="hasUDA"></a><span class="ddoc_psymbol">hasUDA</span>(alias symbol, alias attribute)</dt>
<dd><div class="summary">Determine if a symbol has a given
 <a href="../spec/attribute.html#uda">user-defined attribute</a>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">enum</span> E;
<span class="d_keyword">struct</span> S;
<span class="d_keyword">struct</span> Named { string name; }

@(<span class="d_string">"alpha"</span>) <span class="d_keyword">int</span> a;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(a, <span class="d_string">"alpha"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(a, S));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(a, E));

@(E) <span class="d_keyword">int</span> b;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(b, <span class="d_string">"alpha"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(b, S));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(b, E));

@E <span class="d_keyword">int</span> c;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(c, <span class="d_string">"alpha"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(c, S));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(c, E));

@(S, E) <span class="d_keyword">int</span> d;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(d, <span class="d_string">"alpha"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(d, S));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(d, E));

@S <span class="d_keyword">int</span> e;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(e, <span class="d_string">"alpha"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(e, S));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUDA</span>!(e, E));

@(S, E, <span class="d_string">"alpha"</span>) <span class="d_keyword">int</span> f;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(f, <span class="d_string">"alpha"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(f, S));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(f, E));

@(100) <span class="d_keyword">int</span> g;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(g, 100));

@Named(<span class="d_string">"abc"</span>) <span class="d_keyword">int</span> h;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasUDA</span>!(h, Named));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".getUDAs"></a><div class="quickindex" id="quickindex.getUDAs"></div>template <a name="getUDAs"></a><span class="ddoc_psymbol">getUDAs</span>(alias symbol, alias attribute)</dt>
<dd><div class="summary">Gets the <a href="../spec/attribute.html#uda">user-defined attributes</a> of the
 given type from the given symbol.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> Attr
{
    string name;
    <span class="d_keyword">int</span> value;
}

@Attr(<span class="d_string">"Answer"</span>, 42) <span class="d_keyword">int</span> a;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(a, Attr)[0].name == <span class="d_string">"Answer"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(a, Attr)[0].value == 42);

@(Attr(<span class="d_string">"Answer"</span>, 42), <span class="d_string">"string"</span>, 9999) <span class="d_keyword">int</span> b;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(b, Attr)[0].name == <span class="d_string">"Answer"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(b, Attr)[0].value == 42);

@Attr(<span class="d_string">"Answer"</span>, 42) @Attr(<span class="d_string">"Pi"</span>, 3) <span class="d_keyword">int</span> c;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(c, Attr)[0].name == <span class="d_string">"Answer"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(c, Attr)[0].value == 42);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(c, Attr)[1].name == <span class="d_string">"Pi"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(c, Attr)[1].value == 3);

<span class="d_keyword">struct</span> AttrT(T)
{
    string name;
    T value;
}

@AttrT!<span class="d_keyword">uint</span>(<span class="d_string">"Answer"</span>, 42) @AttrT!<span class="d_keyword">int</span>(<span class="d_string">"Pi"</span>, 3) @AttrT <span class="d_keyword">int</span> d;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT)[0].name == <span class="d_string">"Answer"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT)[0].value == 42);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT)[1].name == <span class="d_string">"Pi"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT)[1].value == 3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT!<span class="d_keyword">uint</span>)[0].name == <span class="d_string">"Answer"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT!<span class="d_keyword">uint</span>)[0].value == 42);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT!<span class="d_keyword">int</span>)[0].name == <span class="d_string">"Pi"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getUDAs</span>!(d, AttrT!<span class="d_keyword">int</span>)[0].value == 3);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".getSymbolsByUDA"></a><div class="quickindex" id="quickindex.getSymbolsByUDA"></div>template <a name="getSymbolsByUDA"></a><span class="ddoc_psymbol">getSymbolsByUDA</span>(alias symbol, alias attribute)</dt>
<dd><div class="summary">Gets all symbols within <span class="d_inlinecode donthyphenate notranslate">symbol</span> that have the given user-defined attribute.
 This is not recursive; it will not search for symbols within symbols such as
 nested structs or unions.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">enum</span> Attr;

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> A
{
    @Attr <span class="d_keyword">int</span> a;
    <span class="d_keyword">int</span> b;
    @Attr <span class="d_keyword">void</span> doStuff() {}
    <span class="d_keyword">void</span> doOtherStuff() {}
    <span class="d_keyword">static</span> <span class="d_keyword">struct</span> Inner
    {
        <span class="d_comment">// Not found by getSymbolsByUDA
</span>        @Attr <span class="d_keyword">int</span> c;
    }
}

<span class="d_comment">// Finds both variables and functions with the attribute, but
</span><span class="d_comment">// doesn't include the variables and functions without it.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getSymbolsByUDA</span>!(A, Attr).length == 2);
<span class="d_comment">// Can access attributes on the symbols returned by getSymbolsByUDA.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(hasUDA!(<span class="d_psymbol">getSymbolsByUDA</span>!(A, Attr)[0], Attr));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(hasUDA!(<span class="d_psymbol">getSymbolsByUDA</span>!(A, Attr)[1], Attr));

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> UDA { string name; }

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> B
{
    @UDA(<span class="d_string">"X"</span>)
    <span class="d_keyword">int</span> x;
    @UDA(<span class="d_string">"Y"</span>)
    <span class="d_keyword">int</span> y;
    @(100)
    <span class="d_keyword">int</span> z;
}

<span class="d_comment">// Finds both UDA attributes.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getSymbolsByUDA</span>!(B, UDA).length == 2);
<span class="d_comment">// Finds one `100` attribute.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getSymbolsByUDA</span>!(B, 100).length == 1);
<span class="d_comment">// Can get the value of the UDA from the return value
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(getUDAs!(<span class="d_psymbol">getSymbolsByUDA</span>!(B, UDA)[0], UDA)[0].name == <span class="d_string">"X"</span>);

@UDA(<span class="d_string">"A"</span>)
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> C
{
    @UDA(<span class="d_string">"B"</span>)
    <span class="d_keyword">int</span> d;
}

<span class="d_comment">// Also checks the symbol itself
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getSymbolsByUDA</span>!(C, UDA).length == 2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getSymbolsByUDA</span>!(C, UDA)[0].stringof == <span class="d_string">"C"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">getSymbolsByUDA</span>!(C, UDA)[1].stringof == <span class="d_string">"d"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".allSameType"></a><div class="quickindex" id="quickindex.allSameType"></div>template <a name="allSameType"></a><span class="ddoc_psymbol">allSameType</span>(T...)</dt>
<dd><div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> iff all types <span class="d_inlinecode donthyphenate notranslate">T</span> are the same.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">allSameType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">allSameType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">allSameType</span>!(<span class="d_keyword">float</span>, <span class="d_keyword">float</span>, <span class="d_keyword">float</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">allSameType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">allSameType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">float</span>, <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">allSameType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">float</span>, <span class="d_keyword">double</span>, <span class="d_keyword">real</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">allSameType</span>!(<span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">float</span>, <span class="d_keyword">double</span>, <span class="d_keyword">real</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ifTestable"></a><div class="quickindex" id="quickindex.ifTestable"></div>enum auto <a name="ifTestable"></a><span class="ddoc_psymbol">ifTestable</span>(T, alias pred = (a) =&gt; a);
</dt>
<dd><div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> iff the type <span class="d_inlinecode donthyphenate notranslate">T</span> can be tested in an <span class="d_inlinecode donthyphenate notranslate">   if</span>-expression, that is if <span class="d_inlinecode donthyphenate notranslate">if (pred(T.init)) {}</span> is compilable.</div></div>

</dd>
</dl>

</div>
<div id="copyright">Copyright Digital Mars 2005 - 2009.
 | Page generated by <a href="http://dlang.org/spec/ddoc.html">Ddoc</a> on (no date time)</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>

<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(listanchors);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
</body>
</html>

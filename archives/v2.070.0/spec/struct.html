
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Structs, Unions - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="stylesheet" href="../css/cssmenu.css">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Structs, Unions' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top">	<div id="header">		<img src="../images/hamburger.svg" id="mobile-hamburger">
		<a class="logo" href=".."><img id="logo" width="125" height="95" alt="D Logo" src="../images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href=".." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    
    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search" tabindex="1000"></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option selected value="dlang.org/spec">Language Reference</option>
                    <option  value="dlang.org/phobos">Library Reference</option>
                    <option  value="forum.dlang.org">Discussion Forums</option>
                    
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='../index.html'><span>D 2.070.0</span></a></li>
    <li><a href='../download.html'><span><b>Download</b></span></a></li>
    <li><a href='../getstarted.html'><span>Getting Started</span></a></li>
    <li><a href='http://ddili.org/ders/d.en/index.html'><span>Official Tutorial</span></a></li>
    <li><a href='http://wiki.dlang.org'><span>Wiki</span></a></li>
    <li class='has-sub'><a href='#'><span>D Reference</span></a>
      <ul><li><a href='        ../spec/intro.html'>Introduction</a></li><li><a href='        ../spec/lex.html'>Lexical</a></li><li><a href='        ../spec/grammar.html'>Grammar</a></li><li><a href='        ../spec/module.html'>Modules</a></li><li><a href='        ../spec/declaration.html'>Declarations</a></li><li><a href='        ../spec/type.html'>Types</a></li><li><a href='        ../spec/property.html'>Properties</a></li><li><a href='        ../spec/attribute.html'>Attributes</a></li><li><a href='        ../spec/pragma.html'>Pragmas</a></li><li><a href='        ../spec/expression.html'>Expressions</a></li><li><a href='        ../spec/statement.html'>Statements</a></li><li><a href='        ../spec/arrays.html'>Arrays</a></li><li><a href='        ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='        ../spec/struct.html'>Structs and Unions</a></li><li><a href='        ../spec/class.html'>Classes</a></li><li><a href='        ../spec/interface.html'>Interfaces</a></li><li><a href='        ../spec/enum.html'>Enums</a></li><li><a href='        ../spec/const3.html'>Const and Immutable</a></li><li><a href='        ../spec/function.html'>Functions</a></li><li><a href='        ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='        ../spec/template.html'>Templates</a></li><li><a href='        ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='        ../spec/contracts.html'>Contract Programming</a></li><li><a href='        ../spec/version.html'>Conditional Compilation</a></li><li><a href='        ../spec/traits.html'>Traits</a></li><li><a href='        ../spec/errors.html'>Error Handling</a></li><li><a href='        ../spec/unittest.html'>Unit Tests</a></li><li><a href='        ../spec/garbage.html'>Garbage Collection</a></li><li><a href='        ../spec/float.html'>Floating Point</a></li><li><a href='        ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='        ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='        ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='        ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='        ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='        ../spec/portability.html'>Portability Guide</a></li><li><a href='        ../spec/entity.html'>Named Character Entities</a></li><li><a href='        ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='        ../spec/abi.html'>Application Binary Interface</a></li><li><a href='        ../spec/simd.html'>Vector Extensions
      </a></li></ul></li>
    <li><a href='../phobos/index.html'><span>Standard library</span></a></li>
    <li><a href='http://code.dlang.org'><span>DUB &ndash; The D package registry</span></a></li>
    <li class='has-sub'><a href='#'><span>Community</span></a>
      <ul><li><a href='        ../bugstats.php'>Bug Tracker</a></li><li><a href='        http://forum.dlang.org'>Forums</a></li><li><a href='        irc://irc.freenode.net/d'>IRC</a></li><li><a href='        http://github.com/D-Programming-Language'>D on GitHub</a></li><li><a href='        http://wiki.dlang.org'>Wiki</a></li><li><a href='        http://wiki.dlang.org/Review_Queue'>Review Queue</a></li><li><a href='        http://twitter.com/search?q=%23dlang'>Twitter</a></li><li><a href='        http://digitalmars.com/d/dlinks.html'>More Links
      </a></li></ul></li>
    <li class='has-sub'><a href='#'><span>Compilers &amp; Tools</span></a>
      <ul><li><a href='        ../dmd-windows.html'>dmd &ndash; reference compiler</a></li><li><a href='        http://gdcproject.org'>gdc &ndash; gcc-based compiler</a></li><li><a href='        http://wiki.dlang.org/LDC'>ldc &ndash; LLVM-based compiler</a></li><li><a href='        http://code.dlang.org/download'>DUB &ndash; D package manager</a></li><li><a href='        https://github.com/Hackerpilot/dfix'>dfix &ndash; D source code upgrade</a></li><li><a href='        https://github.com/Hackerpilot/dfmt'>dfmt &ndash; D source code formatting tool</a></li><li><a href='        ../rdmd.html'>rdmd &ndash; build tool</a></li><li><a href='        ../htod.html'>htod &ndash; .h to .d
      </a></li></ul></li>
    <li class='has-sub'><a href='#'><span>Books &amp; Articles</span></a>
      <ul><li><a href='        http://ddili.org/ders/d.en/index.html'>Online Book (free)</a></li><li><a href='        http://wiki.dlang.org/Books'>More Books</a></li><li><a href='        ../howtos.html'>How-tos</a></li><li><a href='        ../faq.html'>FAQ</a></li><li><a href='        ../const-faq.html'>const(FAQ)</a></li><li><a href='        ../comparison.html'>Feature Overview</a></li><li><a href='        ../d-floating-point.html'>Floating Point</a></li><li><a href='        ../warnings.html'>Warnings</a></li><li><a href='        ../rationale.html'>Rationale</a></li><li><a href='        ../builtin.html'>Builtin Rationale</a></li><li><a href='        ../ctod.html'>C to D</a></li><li><a href='        ../cpptod.html'>C++ to D</a></li><li><a href='        ../pretod.html'>C Preprocessor vs D</a></li><li><a href='        ../code_coverage.html'>Code coverage analysis</a></li><li><a href='        ../exception-safe.html'>Exception Safety</a></li><li><a href='        ../hijack.html'>Hijacking</a></li><li><a href='        ../intro-to-datetime.html'>Introduction to std.datetime</a></li><li><a href='        ../lazy-evaluation.html'>Lazy Evaluation</a></li><li><a href='        ../migrate-to-shared.html'>Migrating to Shared</a></li><li><a href='        ../mixin.html'>Mixins</a></li><li><a href='        ../regular-expression.html'>Regular Expressions</a></li><li><a href='        ../safed.html'>SafeD</a></li><li><a href='        ../templates-revisited.html'>Templates Revisited</a></li><li><a href='        ../tuple.html'>Tuples</a></li><li><a href='        ../ctarguments.html'>Compile-time Argument Lists</a></li><li><a href='        ../variadic-function-templates.html'>Variadic Templates</a></li><li><a href='        ../d-array-article.html'>D Slices
      </a></li></ul></li>
    <li class='has-sub'><a href='#'><span>Resources</span></a>
      <ul><li><a href='        ../library/index.html'>NEW Library Reference Preview</a></li><li><a href='        http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li><li><a href='        http://wiki.dlang.org/Editors'>Editors</a></li><li><a href='        http://wiki.dlang.org/IDEs'>IDEs</a></li><li><a href='        ../dstyle.html'>The D Style</a></li><li><a href='        ../glossary.html'>Glossary</a></li><li><a href='        ../acknowledgements.html'>Acknowledgments</a></li><li><a href='        ../sitemap.html'>Sitemap
      </a></li></ul></li>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;bug_severity=enhancement&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BStructs, Unions%5D&amp;version=D2" class="button">Report a bug</a>
		<span >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</span>
	</span>
	<span class="tip">		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/spec/struct.dd" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
</div>
    <h1>Structs, Unions</h1>
    
    


         <p>Whereas classes are reference types, structs are value types.
             Any C struct can be exactly represented as a D struct, except non-static
             <a href="#nested">function-nested D structs</a> which access the context of
             their enclosing scope.
             Structs and unions are meant as simple aggregations of data, or as a way
             to paint a data structure over hardware or an external type. External
             types can be defined by the operating system API, or by a file format.
             Object oriented features are provided with the class data type.
             </p>

         <p>A struct is defined to not have an identity; that is,
             the implementation is free to make bit copies of the struct
             as convenient.</p>

        <center><table><caption>Struct, Class Comparison Table</caption>        <tr><th class="donthyphenate"><b>Feature</b></th><th class="donthyphenate"><b><span class="d_inlinecode donthyphenate notranslate">struct</span></b></th><th class="donthyphenate"><b><span class="d_inlinecode donthyphenate notranslate">class</span></b></th><th class="donthyphenate"><b>C <span class="d_inlinecode donthyphenate notranslate">struct</span></b></th><th class="donthyphenate"><b>C++
        <span class="d_inlinecode donthyphenate notranslate">struct</span></b></th><th class="donthyphenate"><b>C++ <span class="d_inlinecode donthyphenate notranslate">class</span></b></th></tr>

        <tr><td>value type</td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td>reference type</td><td></td><td>&#10004;</td><td></td><td>        </td><td></td></tr>
        <tr><td>data members</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td>hidden members</td><td>&#10004;</td><td>        &#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td>static members</td><td>&#10004;</td><td>&#10004;</td><td></td><td>        &#10004;</td><td>&#10004;</td></tr>
        <tr><td>default member initializers</td><td>&#10004;</td><td>&#10004;</td><td>        </td><td></td><td></td></tr>
        <tr><td>bit fields</td><td></td><td></td><td>&#10004;</td><td>&#10004;</td><td>        &#10004;</td></tr>
        <tr><td>non-virtual member functions</td><td>&#10004;</td><td>&#10004;</td><td>        </td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td>virtual member functions</td><td></td><td>&#10004;</td><td>        </td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td><a href="#struct-constructor">constructors</a></td><td>&#10004;</td><td>        &#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td><a href="#struct-postblit">postblit</a>/copy constructors</td><td>        &#10004;</td><td></td><td></td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td><a href="#struct-destructor">destructors</a></td><td>&#10004;</td><td>        &#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td><a href="../spec/class.html#SharedStaticConstructor"><i>SharedStaticConstructor</i></a>s</td><td>&#10004;</td><td>        &#10004;</td><td></td><td></td><td></td></tr>
        <tr><td><a href="../spec/class.html#SharedStaticDestructor"><i>SharedStaticDestructor</i></a>s</td><td> &#10004;</td><td>        &#10004;</td><td></td><td></td><td></td></tr>
        <tr><td>RAII</td><td>&#10004;</td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td><a href="#assign-overload">identity assign overload</a></td><td>&#10004;</td><td>        </td><td></td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td><a href="#struct-literal">literals</a></td><td>&#10004;</td><td></td><td>        </td><td></td><td></td></tr>
        <tr><td>operator overloading</td><td>&#10004;</td><td>&#10004;</td><td></td><td>        &#10004;</td><td>&#10004;</td></tr>
        <tr><td>inheritance</td><td></td><td>&#10004;</td><td></td><td>        &#10004;</td><td>&#10004;</td></tr>
        <tr><td>invariants</td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td>        </td></tr>
        <tr><td>unit tests</td><td>&#10004;</td><td>&#10004;</td><td></td><td></td><td>        </td></tr>
        <tr><td>synchronizable</td><td></td><td>&#10004;</td><td></td><td></td><td>        </td></tr>
        <tr><td>parameterizable</td><td>&#10004;</td><td>&#10004;</td><td></td><td>        &#10004;</td><td>&#10004;</td></tr>
        <tr><td>alignment control</td><td>&#10004;</td><td>&#10004;</td><td></td><td>        </td><td></td></tr>
        <tr><td>member protection</td><td>&#10004;</td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td>default public</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td><td></td></tr>
        <tr><td>tag name space</td><td></td><td></td><td>&#10004;</td><td>        &#10004;</td><td>&#10004;</td></tr>
        <tr><td>anonymous</td><td>&#10004;</td><td></td><td>&#10004;</td><td>&#10004;</td><td>&#10004;</td></tr>
        <tr><td>static constructor</td><td>&#10004;</td><td>&#10004;</td><td></td><td>        </td><td></td></tr>
        <tr><td>static destructor</td><td>&#10004;</td><td>&#10004;</td><td></td><td>        </td><td></td></tr>
        <tr><td>const/immutable/shared</td><td>&#10004;</td><td>&#10004;</td><td></td><td>        </td><td></td></tr>
        <tr><td>inner nesting</td><td><a href="#nested">&#10004;</a></td><td>        <a href="../spec/class.html#nested">&#10004;</a></td><td></td><td></td><td></td></tr>
        </table></center>

<pre class="bnf notranslate"><a id="AggregateDeclaration"><span class="gname">AggregateDeclaration</span></a>:
    <a href="../spec/class.html#ClassDeclaration"><i>ClassDeclaration</i></a>
    <a href="../spec/interface.html#InterfaceDeclaration"><i>InterfaceDeclaration</i></a>
    <a href="#StructDeclaration"><i>StructDeclaration</i></a>
    <a href="#UnionDeclaration"><i>UnionDeclaration</i></a>

<a id="StructDeclaration"><span class="gname">StructDeclaration</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">struct</span> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">;</span>
    <span class="d_inlinecode donthyphenate notranslate">struct</span> <i>Identifier</i> <a href="#AggregateBody"><i>AggregateBody</i></a>
    <a href="../spec/template.html#StructTemplateDeclaration"><i>StructTemplateDeclaration</i></a>
    <a href="#AnonStructDeclaration"><i>AnonStructDeclaration</i></a>

<a id="AnonStructDeclaration"><span class="gname">AnonStructDeclaration</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">struct</span> <a href="#AggregateBody"><i>AggregateBody</i></a>

<a id="UnionDeclaration"><span class="gname">UnionDeclaration</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">union</span> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">;</span>
    <span class="d_inlinecode donthyphenate notranslate">union</span> <i>Identifier</i> <a href="#AggregateBody"><i>AggregateBody</i></a>
    <a href="../spec/template.html#UnionTemplateDeclaration"><i>UnionTemplateDeclaration</i></a>
    <a href="#AnonUnionDeclaration"><i>AnonUnionDeclaration</i></a>

<a id="AnonUnionDeclaration"><span class="gname">AnonUnionDeclaration</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">union</span> <a href="#AggregateBody"><i>AggregateBody</i></a>

<a id="AggregateBody"><span class="gname">AggregateBody</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">{</span> <a href="../spec/module.html#DeclDefs"><i>DeclDefs</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">}</span>
</pre>

<p>They work like they do in C, with the following exceptions:</p>

<ul>        <li>no bit fields</li>
        <li>alignment can be explicitly specified</li>
        <li>no separate tag name space - tag names go into the current scope</li>
        <li>declarations like:

<pre class="d_code notranslate"><span class="d_keyword">struct</span> ABC x;
</pre>
        are not allowed, replace with:

<pre class="d_code notranslate">ABC x;
</pre>
        </li>
        <li>anonymous structs/unions are allowed as members of other structs/unions</li>
        <li>Default initializers for members can be supplied.</li>
        <li>Member functions and static members are allowed.</li>
</ul>


<h3>Opaque Structs and Unions</h3>

    <p>Opaque struct and union declarations do not have a <a href="#AggregateBody"><i>AggregateBody</i></a>:</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S;
<span class="d_keyword">union</span> U;
</pre>

	<p>The members are completely hidden to the user, and so the only operations
	on those types are ones that do not require any knowledge of the contents
	of those types. For example:</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S;
S.sizeof; <span class="d_comment">// error, size is not known
</span>S s;      <span class="d_comment">// error, cannot initialize unknown contents
</span>S* p;     <span class="d_comment">// ok, knowledge of members is not necessary
</span></pre>

	<p>They can be used to implement the
	<a href="http://en.wikipedia.org/wiki/Opaque_pointer">PIMPL idiom</a>.</p>


<h3>Static Initialization of Structs</h3>

        Static struct members are by default initialized to whatever the
        default initializer for the member is, and if none supplied, to
        the default initializer for the member's type.
        If a static initializer is supplied, the
        members are initialized by the member name,
        colon, expression syntax. The members may be initialized in any order.
        Initializers for statics must be evaluatable at compile time.
        Members not specified in the initializer list are default initialized.

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; <span class="d_keyword">int</span> b; <span class="d_keyword">int</span> c; <span class="d_keyword">int</span> d = 7;}
<span class="d_keyword">static</span> S x = { a:1, b:2};            <span class="d_comment">// c is set to 0, d to 7
</span><span class="d_keyword">static</span> S z = { c:4, b:5, a:2 , d:5}; <span class="d_comment">// z.a = 2, z.b = 5, z.c = 4, z.d = 5
</span></pre>

        C-style initialization, based on the order of the members in the
        struct declaration, is also supported:

<pre class="d_code notranslate"><span class="d_keyword">static</span> S q = { 1, 2 }; <span class="d_comment">// q.a = 1, q.b = 2, q.c = 0, q.d = 7
</span></pre>

        <p>Struct literals can also be used to initialize statics, but
        they must be evaluable at compile time.</p>

<pre class="d_code notranslate"><span class="d_keyword">static</span> S q = S( 1, 2+3 ); <span class="d_comment">// q.a = 1, q.b = 5, q.c = 0, q.d = 7
</span></pre>

        <p>The static initializer syntax can also be used to initialize
        non-static variables, provided that the member names are not given.
        The initializer need not be evaluatable at compile time.</p>

<pre class="d_code notranslate"><span class="d_keyword">void</span> test(<span class="d_keyword">int</span> i)
{
    S q = { 1, i }; <span class="d_comment">// q.a = 1, q.b = i, q.c = 0, q.d = 7
</span>}
</pre>


<h3>Static Initialization of Unions</h3>

        Unions are initialized explicitly.

<pre class="d_code notranslate"><span class="d_keyword">union</span> U { <span class="d_keyword">int</span> a; <span class="d_keyword">double</span> b; }
<span class="d_keyword">static</span> U u = { b : 5.0 }; <span class="d_comment">// u.b = 5.0
</span></pre>

        Other members of the union that overlay the initializer,
        but occupy more storage, have
        the extra storage initialized to zero.

<h3>Dynamic Initialization of Structs</h3>

        <p>Structs can be dynamically initialized from another
        value of the same type:</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; }
S t;      <span class="d_comment">// default initialized
</span>t.a = 3;
S s = t;  <span class="d_comment">// s.a is set to 3
</span></pre>

        <p>If <span class="d_inlinecode donthyphenate notranslate">opCall</span> is overridden for the struct, and the struct
        is initialized with a value that is of a different type,
        then the <span class="d_inlinecode donthyphenate notranslate">opCall</span> operator is called:</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> a;

    <span class="d_keyword">static</span> S <b><i>opCall</i></b>(<span class="d_keyword">int</span> v)
    {
        S s;
        s.a = v;
        <span class="d_keyword">return</span> s;
    }

    <span class="d_keyword">static</span> S <b><i>opCall</i></b>(S v)
    {
        S s;
        s.a = v.a + 1;
        <span class="d_keyword">return</span> s;
    }
}

S s = 3; <span class="d_comment">// sets s.a to 3
</span>S t = s; <span class="d_comment">// sets t.a to 3, S.opCall(s) is not called
</span></pre>

<h3><span id="StructLiteral"><a class="anchor" title="Permalink to this section" id="struct-literal" href="#struct-literal">Struct Literals</a></span></h3>

        <p>Struct literals consist of the name of the struct followed
        by a parenthesized argument list:</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> x; <span class="d_keyword">float</span> y; }

<span class="d_keyword">int</span> foo(S s) { <span class="d_keyword">return</span> s.x; }

foo( S(1, 2) ); <span class="d_comment">// set field x to 1, field y to 2
</span></pre>

        <p>Struct literals are syntactically like function calls.
        If a struct has a member function named <span class="d_inlinecode donthyphenate notranslate">opCall</span>, then
        struct literals for that struct are not possible. See also
        <a href="../spec/operatoroverloading.html#FunctionCall">opCall operator overloading</a>
        for the issue workaround.
        It is an error if there are more arguments than fields of
        the struct.
        If there are fewer arguments than fields, the remaining
        fields are initialized with their respective default
        initializers.
        If there are anonymous unions in the struct, only the first
        member of the anonymous union can be initialized with a
        struct literal, and all subsequent non-overlapping fields are default
        initialized.
        </p>

<h3>Struct Properties</h3>

<center><table><caption>Struct Properties</caption><tr><th class="donthyphenate"><b>Name</b></th><th class="donthyphenate"><b>Description</b></th></tr>
<tr><td><span class="d_inlinecode donthyphenate notranslate">.sizeof</span></td><td>Size in bytes of struct</td></tr>
<tr><td><span class="d_inlinecode donthyphenate notranslate">.alignof</span></td><td>Size boundary struct needs to be aligned on</td></tr>
<tr><td><span class="d_inlinecode donthyphenate notranslate">.tupleof</span></td><td>Gets type tuple of fields</td></tr></table></center>

<h3>Struct Field Properties</h3>

<center><table><caption>Struct Field Properties</caption><tr><th class="donthyphenate"><b>Name</b></th><th class="donthyphenate"><b>Description</b></th></tr>
<tr><td><span class="d_inlinecode donthyphenate notranslate">.offsetof</span></td><td>Offset in bytes of field from beginning of struct</td></tr></table></center>

<h3><span id="ConstStruct"><a class="anchor" title="Permalink to this section" id="const-struct" href="#const-struct">Const, Immutable and Shared Structs</a></span></h3>
        <p>A struct declaration can have a storage class of
        <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span> or <span class="d_inlinecode donthyphenate notranslate">shared</span>. It has an equivalent
        effect as declaring each member of the struct as
        <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span> or <span class="d_inlinecode donthyphenate notranslate">shared</span>.
        </p>

<pre class="d_code notranslate"><span class="d_keyword">const</span> <span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; <span class="d_keyword">int</span> b = 2; }

<span class="d_keyword">void</span> main()
{
    S s = S(3); <span class="d_comment">// initializes s.a to 3
</span>    S t;        <span class="d_comment">// initializes t.a to 0
</span>    t = s;      <span class="d_comment">// error, t.a and t.b are const, so cannot modify them.
</span>    t.a = 4;    <span class="d_comment">// error, t.a is const
</span>}
</pre>


<h3><span id="Struct-Constructor"><a class="anchor" title="Permalink to this section" id="struct-constructor" href="#struct-constructor">Struct Constructors</a></span></h3>
        <p>Struct constructors are used to initialize an instance
        of a struct.
        The <i>ParameterList</i> may not be empty.
        Struct instances that are not instantiated with a constructor
        are default initialized to their <span class="d_inlinecode donthyphenate notranslate">.init</span> value.
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> x, y;

    <span class="d_keyword">this</span>()  <span class="d_comment">// error, cannot implement default ctor for structs
</span>    {
    }

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
    {
        x = a;
        y = b;
    }
}

<span class="d_keyword">void</span> main()
{
    S a = S(4, 5);
    <span class="d_keyword">auto</span> b = S();  <span class="d_comment">// same as auto b = S.init;
</span>}
</pre>

        <p>A constructor qualifier allows the object to be constructed with
        that specific qualifier.
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S1
{
    <span class="d_keyword">int</span>[] a;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) { a = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[](n); }
}
<span class="d_keyword">struct</span> S2
{
    <span class="d_keyword">int</span>[] a;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) <span class="d_keyword">immutable</span> { a = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[](n); }
}
<span class="d_keyword">void</span> main()
{
    <span class="d_comment">// Mutable constructor creates mutable object.
</span>    S1 m1 = S1(1);

    <span class="d_comment">// Constructed mutable object is implicitly convertible to const.
</span>    <span class="d_keyword">const</span> S1 c1 = S1(1);

    <span class="d_comment">// Constructed mutable object is not implicitly convertible to immutable.
</span>    <span class="d_comment">// immutable i1 = S1(1);
</span>
    <span class="d_comment">// Mutable constructor cannot construct immutable object.
</span>    <span class="d_comment">// auto x1 = immutable S1(1);
</span>
    <span class="d_comment">// Immutable constructor cannot construct mutable object.
</span>    <span class="d_comment">// auto x2 = S2(1);
</span>
    <span class="d_comment">// Constructed immutable object is not implicitly convertible to mutable.
</span>    <span class="d_comment">// S2 m2 = immutable S2(1);
</span>
    <span class="d_comment">// Constructed immutable object is implicitly convertible to const.
</span>    <span class="d_keyword">const</span> S2 c2 = <span class="d_keyword">immutable</span> S2(1);

    <span class="d_comment">// Immutable constructor creates immutable object.
</span>    <span class="d_keyword">immutable</span> i2 = <span class="d_keyword">immutable</span> S2(1);
}
</pre>

        <p>If struct constructor is annotated with <span class="d_inlinecode donthyphenate notranslate">@disable</span> and has
        empty parameter, the struct is disabled construction without calling
        other constructor.
        </p>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> x;

    <span class="d_comment">// Disables default construction, function body can be empty.
</span>    @disable <span class="d_keyword">this</span>();

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> v) { x = v; }
}
<span class="d_keyword">void</span> main()
{
    <span class="d_comment">//S s;        // default construction is disabled
</span>    <span class="d_comment">//S s = S();  // also disabled
</span>    S s = S(1);   <span class="d_comment">// construction with calling constructor
</span>}
</pre>


<h3><span id="StructPostblit"><a class="anchor" title="Permalink to this section" id="struct-postblit" href="#struct-postblit">Struct Postblits</a></span></h3>
<pre class="bnf notranslate"><a id="Postblit"><span class="gname">Postblit</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">this ( this )</span> <a href="../spec/function.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">;</span>
    <span class="d_inlinecode donthyphenate notranslate">this ( this )</span> <a href="../spec/function.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="../spec/function.html#FunctionBody"><i>FunctionBody</i></a>
</pre>

        <p><i>Copy construction</i> is defined as initializing
         a struct instance from another struct of the same type.
         Copy construction is divided into two parts:</p>

        <ol>        <li>blitting the fields, i.e. copying the bits</li>
        <li>running <i>postblit</i> on the result</li>
        </ol>

        <p>The first part is done automatically by the language,
        the second part is done if a postblit function is defined
        for the struct.
        The postblit has access only to the destination struct object,
        not the source.
        Its job is to &lsquo;fix up&rsquo; the destination as necessary, such as
        making copies of referenced data, incrementing reference counts,
        etc. For example:
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span>[] a;    <span class="d_comment">// array is privately owned by this instance
</span>    <span class="d_keyword">this</span>(<span class="d_keyword">this</span>)
    {
        a = a.dup;
    }
}
</pre>

        <p>Disabling struct postblit makes the object not copyable.
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> T
{
    @disable <span class="d_keyword">this</span>(<span class="d_keyword">this</span>);  <span class="d_comment">// disabling makes T not copyable
</span>}
<span class="d_keyword">struct</span> S
{
    T t;   <span class="d_comment">// uncopyable member makes S also not copyable
</span>}

<span class="d_keyword">void</span> main()
{
    S s;
    S t = s; <span class="d_comment">// error, S is not copyable
</span>}
</pre>

        <p>Unions may not have fields that have postblits.</p>


<h3><span id="StructDestructor"><a class="anchor" title="Permalink to this section" id="struct-destructor" href="#struct-destructor">Struct Destructors</a></span></h3>
        <p>Destructors are called when an object goes out of scope.
        Their purpose is to free up resources owned by the struct
        object.
        </p>

        <p>Unions may not have fields that have destructors.</p>


<h3><span id="AssignOverload"><a class="anchor" title="Permalink to this section" id="assign-overload" href="#assign-overload">Identity Assignment Overload</a></span></h3>
        <p>While copy construction takes care of initializing
        an object from another object of the same type,
        or elaborate destruction is needed for the type,
        assignment is defined as copying the contents of one
        object over another, already initialized, type:
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { ... }  <span class="d_comment">// S has postblit or destructor
</span>S s;      <span class="d_comment">// default construction of s
</span>S t = s;  <span class="d_comment">// t is copy-constructed from s
</span>t = s;    <span class="d_comment">// t is assigned from s
</span></pre>

        <p>Struct assignment <span class="d_inlinecode donthyphenate notranslate">t=s</span> is defined to be semantically
        equivalent to:
        </p>

<pre class="d_code notranslate">t.opAssign(s);
</pre>

        <p>where <span class="d_inlinecode donthyphenate notranslate">opAssign</span> is a member function of S:</p>

<pre class="d_code notranslate"><span class="d_keyword">ref</span> S opAssign(S s)
{
    S tmp = <span class="d_keyword">this</span>;   <span class="d_comment">// bitcopy this into tmp
</span>    <span class="d_keyword">this</span> = s;       <span class="d_comment">// bitcopy s into this
</span>    tmp.__dtor();   <span class="d_comment">// call destructor on tmp
</span>    <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
}
</pre>

        <p>While the compiler will generate a default <span class="d_inlinecode donthyphenate notranslate">opAssign</span>
        as needed, a user-defined one can be supplied. The user-defined
        one must still implement the equivalent semantics, but can
        be more efficient.
        </p>

        <p>One reason a custom <span class="d_inlinecode donthyphenate notranslate">opAssign</span> might be more efficient
        is if the struct has a reference to a local buffer:
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span>[] buf;
    <span class="d_keyword">int</span> a;

    <span class="d_keyword">ref</span> S opAssign(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s)
    {
        a = s.a;
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_keyword">this</span>(<span class="d_keyword">this</span>)
    {
        buf = buf.dup;
    }
}
</pre>

        <p>Here, <span class="d_inlinecode donthyphenate notranslate">S</span> has a temporary workspace <span class="d_inlinecode donthyphenate notranslate">buf[]</span>.
        The normal postblit
        will pointlessly free and reallocate it. The custom <span class="d_inlinecode donthyphenate notranslate">opAssign</span>
        will reuse the existing storage.
        </p>




<h2><a class="anchor" title="Permalink to this section" id="nested" href="#nested">Nested Structs</a></h2>

    <p>A <i>nested struct</i> is a struct that is declared inside the scope
        of a function or a templated struct that has aliases to local
        functions as a template argument.
        Nested structs have member functions.
        It has access to the context of its enclosing scope
        (via an added hidden field).

<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">int</span> i = 7;
    <span class="d_keyword">struct</span> SS
    {
        <span class="d_keyword">int</span> x,y;
        <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> x + i + 1; }
    }
    SS s;
    s.x = 3;
    s.bar(); <span class="d_comment">// returns 11
</span>}
</pre>
    </p>

    <p>A struct can be prevented from being nested by
        using the static attribute, but then of course it
        will not be able to access variables from its enclosing
        scope.

<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">int</span> i = 7;
    <span class="d_keyword">static</span> <span class="d_keyword">struct</span> SS
    {
        <span class="d_keyword">int</span> x, y;
        <span class="d_keyword">int</span> bar()
        {
            <span class="d_keyword">return</span> i; <span class="d_comment">// error, SS is not a nested struct
</span>        }
    }
}
</pre>
    </p>

<h2>Unions and Special Member Functions</h2>

    <p>Unions may not have postblits, destructors, or invariants.</p>




</div>
<div id="copyright">Copyright &copy; 1999-2017 by Digital Mars &reg;, All Rights Reserved | Page generated by <a href="http://dlang.org/spec/ddoc.html">Ddoc</a> on (no date time)</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
</body>
</html>

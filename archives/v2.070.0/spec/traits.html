
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Traits - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="stylesheet" href="../css/cssmenu.css">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Traits' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top">	<div id="header">		<img src="../images/hamburger.svg" id="mobile-hamburger">
		<a class="logo" href=".."><img id="logo" width="125" height="95" alt="D Logo" src="../images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href=".." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    
    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search" tabindex="1000"></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option selected value="dlang.org/spec">Language Reference</option>
                    <option  value="dlang.org/phobos">Library Reference</option>
                    <option  value="forum.dlang.org">Discussion Forums</option>
                    
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='../index.html'><span>D 2.070.0</span></a></li>
    <li><a href='../download.html'><span><b>Download</b></span></a></li>
    <li><a href='../getstarted.html'><span>Getting Started</span></a></li>
    <li><a href='http://ddili.org/ders/d.en/index.html'><span>Official Tutorial</span></a></li>
    <li><a href='http://wiki.dlang.org'><span>Wiki</span></a></li>
    <li class='has-sub'><a href='#'><span>D Reference</span></a>
      <ul><li><a href='        ../spec/intro.html'>Introduction</a></li><li><a href='        ../spec/lex.html'>Lexical</a></li><li><a href='        ../spec/grammar.html'>Grammar</a></li><li><a href='        ../spec/module.html'>Modules</a></li><li><a href='        ../spec/declaration.html'>Declarations</a></li><li><a href='        ../spec/type.html'>Types</a></li><li><a href='        ../spec/property.html'>Properties</a></li><li><a href='        ../spec/attribute.html'>Attributes</a></li><li><a href='        ../spec/pragma.html'>Pragmas</a></li><li><a href='        ../spec/expression.html'>Expressions</a></li><li><a href='        ../spec/statement.html'>Statements</a></li><li><a href='        ../spec/arrays.html'>Arrays</a></li><li><a href='        ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='        ../spec/struct.html'>Structs and Unions</a></li><li><a href='        ../spec/class.html'>Classes</a></li><li><a href='        ../spec/interface.html'>Interfaces</a></li><li><a href='        ../spec/enum.html'>Enums</a></li><li><a href='        ../spec/const3.html'>Const and Immutable</a></li><li><a href='        ../spec/function.html'>Functions</a></li><li><a href='        ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='        ../spec/template.html'>Templates</a></li><li><a href='        ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='        ../spec/contracts.html'>Contract Programming</a></li><li><a href='        ../spec/version.html'>Conditional Compilation</a></li><li><a href='        ../spec/traits.html'>Traits</a></li><li><a href='        ../spec/errors.html'>Error Handling</a></li><li><a href='        ../spec/unittest.html'>Unit Tests</a></li><li><a href='        ../spec/garbage.html'>Garbage Collection</a></li><li><a href='        ../spec/float.html'>Floating Point</a></li><li><a href='        ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='        ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='        ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='        ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='        ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='        ../spec/portability.html'>Portability Guide</a></li><li><a href='        ../spec/entity.html'>Named Character Entities</a></li><li><a href='        ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='        ../spec/abi.html'>Application Binary Interface</a></li><li><a href='        ../spec/simd.html'>Vector Extensions
      </a></li></ul></li>
    <li><a href='../phobos/index.html'><span>Standard library</span></a></li>
    <li><a href='http://code.dlang.org'><span>DUB &ndash; The D package registry</span></a></li>
    <li class='has-sub'><a href='#'><span>Community</span></a>
      <ul><li><a href='        ../bugstats.php'>Bug Tracker</a></li><li><a href='        http://forum.dlang.org'>Forums</a></li><li><a href='        irc://irc.freenode.net/d'>IRC</a></li><li><a href='        http://github.com/D-Programming-Language'>D on GitHub</a></li><li><a href='        http://wiki.dlang.org'>Wiki</a></li><li><a href='        http://wiki.dlang.org/Review_Queue'>Review Queue</a></li><li><a href='        http://twitter.com/search?q=%23dlang'>Twitter</a></li><li><a href='        http://digitalmars.com/d/dlinks.html'>More Links
      </a></li></ul></li>
    <li class='has-sub'><a href='#'><span>Compilers &amp; Tools</span></a>
      <ul><li><a href='        ../dmd-windows.html'>dmd &ndash; reference compiler</a></li><li><a href='        http://gdcproject.org'>gdc &ndash; gcc-based compiler</a></li><li><a href='        http://wiki.dlang.org/LDC'>ldc &ndash; LLVM-based compiler</a></li><li><a href='        http://code.dlang.org/download'>DUB &ndash; D package manager</a></li><li><a href='        https://github.com/Hackerpilot/dfix'>dfix &ndash; D source code upgrade</a></li><li><a href='        https://github.com/Hackerpilot/dfmt'>dfmt &ndash; D source code formatting tool</a></li><li><a href='        ../rdmd.html'>rdmd &ndash; build tool</a></li><li><a href='        ../htod.html'>htod &ndash; .h to .d
      </a></li></ul></li>
    <li class='has-sub'><a href='#'><span>Books &amp; Articles</span></a>
      <ul><li><a href='        http://ddili.org/ders/d.en/index.html'>Online Book (free)</a></li><li><a href='        http://wiki.dlang.org/Books'>More Books</a></li><li><a href='        ../howtos.html'>How-tos</a></li><li><a href='        ../faq.html'>FAQ</a></li><li><a href='        ../const-faq.html'>const(FAQ)</a></li><li><a href='        ../comparison.html'>Feature Overview</a></li><li><a href='        ../d-floating-point.html'>Floating Point</a></li><li><a href='        ../warnings.html'>Warnings</a></li><li><a href='        ../rationale.html'>Rationale</a></li><li><a href='        ../builtin.html'>Builtin Rationale</a></li><li><a href='        ../ctod.html'>C to D</a></li><li><a href='        ../cpptod.html'>C++ to D</a></li><li><a href='        ../pretod.html'>C Preprocessor vs D</a></li><li><a href='        ../code_coverage.html'>Code coverage analysis</a></li><li><a href='        ../exception-safe.html'>Exception Safety</a></li><li><a href='        ../hijack.html'>Hijacking</a></li><li><a href='        ../intro-to-datetime.html'>Introduction to std.datetime</a></li><li><a href='        ../lazy-evaluation.html'>Lazy Evaluation</a></li><li><a href='        ../migrate-to-shared.html'>Migrating to Shared</a></li><li><a href='        ../mixin.html'>Mixins</a></li><li><a href='        ../regular-expression.html'>Regular Expressions</a></li><li><a href='        ../safed.html'>SafeD</a></li><li><a href='        ../templates-revisited.html'>Templates Revisited</a></li><li><a href='        ../tuple.html'>Tuples</a></li><li><a href='        ../ctarguments.html'>Compile-time Argument Lists</a></li><li><a href='        ../variadic-function-templates.html'>Variadic Templates</a></li><li><a href='        ../d-array-article.html'>D Slices
      </a></li></ul></li>
    <li class='has-sub'><a href='#'><span>Resources</span></a>
      <ul><li><a href='        ../library/index.html'>NEW Library Reference Preview</a></li><li><a href='        http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li><li><a href='        http://wiki.dlang.org/Editors'>Editors</a></li><li><a href='        http://wiki.dlang.org/IDEs'>IDEs</a></li><li><a href='        ../dstyle.html'>The D Style</a></li><li><a href='        ../glossary.html'>Glossary</a></li><li><a href='        ../acknowledgements.html'>Acknowledgments</a></li><li><a href='        ../sitemap.html'>Sitemap
      </a></li></ul></li>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;bug_severity=enhancement&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BTraits%5D&amp;version=D2" class="button">Report a bug</a>
		<span >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</span>
	</span>
	<span class="tip">		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/spec/traits.dd" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
</div>
    <h1>Traits</h1>
    
    


	<p>Traits are extensions to the language to enable
	programs, at compile time, to get at information
	internal to the compiler. This is also known as
	compile time reflection.
	It is done as a special, easily extended syntax (similar
	to Pragmas) so that new capabilities can be added
	as required.
	</p>

<pre class="bnf notranslate"><a id="TraitsExpression"><span class="gname">TraitsExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">__traits</span> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#TraitsKeyword"><i>TraitsKeyword</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="#TraitsArguments"><i>TraitsArguments</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>

<a id="TraitsKeyword"><span class="gname">TraitsKeyword</span></a>:
    <a href="#isAbstractClass"><span class="d_inlinecode donthyphenate notranslate">isAbstractClass</span></a>
    <a href="#isArithmetic"><span class="d_inlinecode donthyphenate notranslate">isArithmetic</span></a>
    <a href="#isAssociativeArray"><span class="d_inlinecode donthyphenate notranslate">isAssociativeArray</span></a>
    <a href="#isFinalClass"><span class="d_inlinecode donthyphenate notranslate">isFinalClass</span></a>
    <a href="#isPOD"><span class="d_inlinecode donthyphenate notranslate">isPOD</span></a>
    <a href="#isNested"><span class="d_inlinecode donthyphenate notranslate">isNested</span></a>
    <a href="#isFloating"><span class="d_inlinecode donthyphenate notranslate">isFloating</span></a>
    <a href="#isIntegral"><span class="d_inlinecode donthyphenate notranslate">isIntegral</span></a>
    <a href="#isScalar"><span class="d_inlinecode donthyphenate notranslate">isScalar</span></a>
    <a href="#isStaticArray"><span class="d_inlinecode donthyphenate notranslate">isStaticArray</span></a>
    <a href="#isUnsigned"><span class="d_inlinecode donthyphenate notranslate">isUnsigned</span></a>
    <a href="#isVirtualFunction"><span class="d_inlinecode donthyphenate notranslate">isVirtualFunction</span></a>
    <a href="#isVirtualMethod"><span class="d_inlinecode donthyphenate notranslate">isVirtualMethod</span></a>
    <a href="#isAbstractFunction"><span class="d_inlinecode donthyphenate notranslate">isAbstractFunction</span></a>
    <a href="#isFinalFunction"><span class="d_inlinecode donthyphenate notranslate">isFinalFunction</span></a>
    <a href="#isStaticFunction"><span class="d_inlinecode donthyphenate notranslate">isStaticFunction</span></a>
    <a href="#isOverrideFunction"><span class="d_inlinecode donthyphenate notranslate">isOverrideFunction</span></a>
    <a href="#isTemplate"><span class="d_inlinecode donthyphenate notranslate">isTemplate</span></a>
    <a href="#isRef"><span class="d_inlinecode donthyphenate notranslate">isRef</span></a>
    <a href="#isOut"><span class="d_inlinecode donthyphenate notranslate">isOut</span></a>
    <a href="#isLazy"><span class="d_inlinecode donthyphenate notranslate">isLazy</span></a>
    <a href="#hasMember"><span class="d_inlinecode donthyphenate notranslate">hasMember</span></a>
    <a href="#identifier"><span class="d_inlinecode donthyphenate notranslate">identifier</span></a>
    <a href="#getAliasThis"><span class="d_inlinecode donthyphenate notranslate">getAliasThis</span></a>
    <a href="#getAttributes"><span class="d_inlinecode donthyphenate notranslate">getAttributes</span></a>
    <a href="#getFunctionAttributes"><span class="d_inlinecode donthyphenate notranslate">getFunctionAttributes</span></a>
    <a href="#getMember"><span class="d_inlinecode donthyphenate notranslate">getMember</span></a>
    <a href="#getOverloads"><span class="d_inlinecode donthyphenate notranslate">getOverloads</span></a>
    <a href="#getPointerBitmap"><span class="d_inlinecode donthyphenate notranslate">getPointerBitmap</span></a>
    <a href="#getProtection"><span class="d_inlinecode donthyphenate notranslate">getProtection</span></a>
    <a href="#getVirtualFunctions"><span class="d_inlinecode donthyphenate notranslate">getVirtualFunctions</span></a>
    <a href="#getVirtualMethods"><span class="d_inlinecode donthyphenate notranslate">getVirtualMethods</span></a>
    <a href="#getUnitTests"><span class="d_inlinecode donthyphenate notranslate">getUnitTests</span></a>
    <a href="#parent"><span class="d_inlinecode donthyphenate notranslate">parent</span></a>
    <a href="#classInstanceSize"><span class="d_inlinecode donthyphenate notranslate">classInstanceSize</span></a>
    <a href="#getVirtualIndex"><span class="d_inlinecode donthyphenate notranslate">getVirtualIndex</span></a>
    <a href="#allMembers"><span class="d_inlinecode donthyphenate notranslate">allMembers</span></a>
    <a href="#derivedMembers"><span class="d_inlinecode donthyphenate notranslate">derivedMembers</span></a>
    <a href="#isSame"><span class="d_inlinecode donthyphenate notranslate">isSame</span></a>
    <a href="#compiles"><span class="d_inlinecode donthyphenate notranslate">compiles</span></a>

<a id="TraitsArguments"><span class="gname">TraitsArguments</span></a>:
    <a href="#TraitsArgument"><i>TraitsArgument</i></a>
    <a href="#TraitsArgument"><i>TraitsArgument</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>TraitsArguments</i>

<a id="TraitsArgument"><span class="gname">TraitsArgument</span></a>:
    <a href="../spec/expression.html#AssignExpression"><i>AssignExpression</i></a>
    <a href="../spec/declaration.html#Type"><i>Type</i></a>
</pre>

<p>Additionally special keywords are provided for debugging purposes:</p>

<pre class="bnf notranslate"><a id="SpecialKeyword"><span class="gname">SpecialKeyword</span></a>:
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__FILE__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__MODULE__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__LINE__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__FUNCTION__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__PRETTY_FUNCTION__</a></span>
</pre>

<h2><a id="isArithmetic"><span class="gname">isArithmetic</span></a></h2>

	<p>If the arguments are all either types that are arithmetic types,
	or expressions that are typed as arithmetic types, then <span class="d_inlinecode donthyphenate notranslate">true</span>
	is returned.
	Otherwise, <span class="d_inlinecode donthyphenate notranslate">false</span> is returned.
	If there are no arguments, <span class="d_inlinecode donthyphenate notranslate">false</span> is returned.</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> i;
    writeln(<span class="d_keyword">__traits</span>(isArithmetic, <span class="d_keyword">int</span>));
    writeln(<span class="d_keyword">__traits</span>(isArithmetic, i, i+1, <span class="d_keyword">int</span>));
    writeln(<span class="d_keyword">__traits</span>(isArithmetic));
    writeln(<span class="d_keyword">__traits</span>(isArithmetic, <span class="d_keyword">int</span>*));
}
</pre>

	<p>Prints:</p>

<pre class="console notranslate">true
true
false
false
</pre>

<h2><a id="isFloating"><span class="gname">isFloating</span></a></h2>

	<p>Works like <span class="d_inlinecode donthyphenate notranslate">isArithmetic</span>, except it's for floating
	point types (including imaginary and complex types).</p>

<h2><a id="isIntegral"><span class="gname">isIntegral</span></a></h2>

	<p>Works like <span class="d_inlinecode donthyphenate notranslate">isArithmetic</span>, except it's for integral
	types (including character types).</p>

<h2><a id="isScalar"><span class="gname">isScalar</span></a></h2>

	<p>Works like <span class="d_inlinecode donthyphenate notranslate">isArithmetic</span>, except it's for scalar
	types.</p>

<h2><a id="isUnsigned"><span class="gname">isUnsigned</span></a></h2>

	<p>Works like <span class="d_inlinecode donthyphenate notranslate">isArithmetic</span>, except it's for unsigned
	types.</p>

<h2><a id="isStaticArray"><span class="gname">isStaticArray</span></a></h2>

	<p>Works like <span class="d_inlinecode donthyphenate notranslate">isArithmetic</span>, except it's for static array
	types.</p>

<h2><a id="isAssociativeArray"><span class="gname">isAssociativeArray</span></a></h2>

	<p>Works like <span class="d_inlinecode donthyphenate notranslate">isArithmetic</span>, except it's for associative array
	types.</p>

<h2><a id="isAbstractClass"><span class="gname">isAbstractClass</span></a></h2>

	<p>If the arguments are all either types that are abstract classes,
	or expressions that are typed as abstract classes, then <span class="d_inlinecode donthyphenate notranslate">true</span>
	is returned.
	Otherwise, <span class="d_inlinecode donthyphenate notranslate">false</span> is returned.
	If there are no arguments, <span class="d_inlinecode donthyphenate notranslate">false</span> is returned.</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> C { <span class="d_keyword">int</span> foo(); }

<span class="d_keyword">void</span> main()
{
    C c;
    writeln(<span class="d_keyword">__traits</span>(isAbstractClass, C));
    writeln(<span class="d_keyword">__traits</span>(isAbstractClass, c, C));
    writeln(<span class="d_keyword">__traits</span>(isAbstractClass));
    writeln(<span class="d_keyword">__traits</span>(isAbstractClass, <span class="d_keyword">int</span>*));
}
</pre>

	<p>Prints:</p>

<pre class="console notranslate">true
true
false
false
</pre>

<h2><a id="isFinalClass"><span class="gname">isFinalClass</span></a></h2>

	<p>Works like <span class="d_inlinecode donthyphenate notranslate">isAbstractClass</span>, except it's for final
	classes.</p>

<h2><a id="isPOD"><span class="gname">isPOD</span></a></h2>

	<p>Takes one argument, which must be a type. It returns
	<span class="d_inlinecode donthyphenate notranslate">true</span> if the type is a <a href="../glossary.html#pod">POD</a> type, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.</p>

<h2><a id="isNested"><span class="gname">isNested</span></a></h2>

    <p>Takes one argument.
    It returns <span class="d_inlinecode donthyphenate notranslate">true</span> if the argument is a nested type which internally
    stores a context pointer, otherwise it returns <span class="d_inlinecode donthyphenate notranslate">false</span>.
    Nested types can be  <a href="../spec/class.html#nested">classes</a>,
    <a href="../spec/struct.html#nested">structs</a>, and
    <a href="../spec/function.html#variadicnested">functions</a>.</p>

<h2><a id="isVirtualFunction"><span class="gname">isVirtualFunction</span></a></h2>

	<p>The same as <a href="#isVirtualMethod"><i>isVirtualMethod</i></a>, except
	that final functions that don't override anything return true.
	</p>

<h2><a id="isVirtualMethod"><span class="gname">isVirtualMethod</span></a></h2>

	<p>Takes one argument. If that argument is a virtual function,
	<span class="d_inlinecode donthyphenate notranslate">true</span> is returned, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	Final functions that don't override anything return false.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_keyword">__traits</span>(isVirtualMethod, C.bar));  <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(isVirtualMethod, S.bar));  <span class="d_comment">// false
</span>}
</pre>

<h2><a id="isAbstractFunction"><span class="gname">isAbstractFunction</span></a></h2>

	<p>Takes one argument. If that argument is an abstract function,
	<span class="d_inlinecode donthyphenate notranslate">true</span> is returned, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> AC
{
    <span class="d_keyword">abstract</span> <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_keyword">__traits</span>(isAbstractFunction, C.bar));   <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isAbstractFunction, S.bar));   <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isAbstractFunction, AC.foo));  <span class="d_comment">// true
</span>}
</pre>

<h2><a id="isFinalFunction"><span class="gname">isFinalFunction</span></a></h2>

	<p>Takes one argument. If that argument is a final function,
	<span class="d_inlinecode donthyphenate notranslate">true</span> is returned, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> bar() { }
    <span class="d_keyword">final</span> <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC
{
    <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_keyword">__traits</span>(isFinalFunction, C.bar));  <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isFinalFunction, S.bar));  <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isFinalFunction, C.foo));  <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(isFinalFunction, FC.foo)); <span class="d_comment">// true
</span>}
</pre>

<h2><a id="isOverrideFunction"><span class="gname">isOverrideFunction</span></a></h2>

	<p>Takes one argument. If that argument is a function marked with
	<span class="d_keyword">override</span>, <span class="d_inlinecode donthyphenate notranslate">true</span> is returned, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> Base
{
    <span class="d_keyword">void</span> foo() { }
}

<span class="d_keyword">class</span> Foo : Base
{
    <span class="d_keyword">override</span> <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_keyword">__traits</span>(isOverrideFunction, Base.foo)); <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isOverrideFunction, Foo.foo));  <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(isOverrideFunction, Foo.bar));  <span class="d_comment">// false
</span>}
</pre>

<h2><a id="isStaticFunction"><span class="gname">isStaticFunction</span></a></h2>

	<p>Takes one argument. If that argument is a static function,
	meaning it has no context pointer,
	<span class="d_inlinecode donthyphenate notranslate">true</span> is returned, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	</p>


<h2><a id="isRef"><span class="gname">isRef</span></a>, <a id="isOut"><span class="gname">isOut</span></a>, <a id="isLazy"><span class="gname">isLazy</span></a></h2>

	<p>Takes one argument. If that argument is a declaration,
	<span class="d_inlinecode donthyphenate notranslate">true</span> is returned if it is <span class="d_keyword">ref</span>, <span class="d_keyword">out</span>,
	or <span class="d_keyword">lazy</span>, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">void</span> fooref(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x)
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isRef, x));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isOut, x));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isLazy, x));
}

<span class="d_keyword">void</span> fooout(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x)
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isRef, x));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isOut, x));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isLazy, x));
}

<span class="d_keyword">void</span> foolazy(<span class="d_keyword">lazy</span> <span class="d_keyword">int</span> x)
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isRef, x));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isOut, x));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isLazy, x));
}
</pre>

<h2><a id="isTemplate"><span class="gname">isTemplate</span></a></h2>

	<p>Takes one argument. If that argument is a template then <span class="d_inlinecode donthyphenate notranslate">true</span> is returned,
	otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(T)(){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isTemplate,foo));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isTemplate,foo!<span class="d_keyword">int</span>()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isTemplate,<span class="d_string">"string"</span>));
</pre>

<h2><a id="hasMember"><span class="gname">hasMember</span></a></h2>

	<p>The first argument is a type that has members, or
	is an expression of a type that has members.
	The second argument is a string.
	If the string is a valid property of the type,
	<span class="d_inlinecode donthyphenate notranslate">true</span> is returned, otherwise <span class="d_inlinecode donthyphenate notranslate">false</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> m;
}

<span class="d_keyword">void</span> main()
{
    S s;

    writeln(<span class="d_keyword">__traits</span>(hasMember, S, <span class="d_string">"m"</span>)); <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(hasMember, s, <span class="d_string">"m"</span>)); <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(hasMember, S, <span class="d_string">"y"</span>)); <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(hasMember, <span class="d_keyword">int</span>, <span class="d_string">"sizeof"</span>)); <span class="d_comment">// true
</span>}
</pre>

<h2><a id="identifier"><span class="gname">identifier</span></a></h2>

	<p>Takes one argument, a symbol. Returns the identifier
	for that symbol as a string literal.
	</p>

<h2><a id="getAliasThis"><span class="gname">getAliasThis</span></a></h2>

    <p>Takes one argument, a symbol of aggregate type.
        If the given aggregate type has <span class="d_inlinecode donthyphenate notranslate">alias this</span>, returns a list of
        <span class="d_inlinecode donthyphenate notranslate">alias this</span> names, by a tuple of <span class="d_inlinecode donthyphenate notranslate">string</span>s.
        Otherwise returns an empty tuple.
    </p>

<h2><a id="getAttributes"><span class="gname">getAttributes</span></a></h2>    <p>        Takes one argument, a symbol. Returns a tuple of all attached user defined attributes.
        If no UDA's exist it will return an empty tuple.
    </p>

    <p>        For more information, see: <a href="../spec/attribute.html#uda">User Defined Attributes</a>
    </p>

<pre class="d_code notranslate">@(3) <span class="d_keyword">int</span> a;
@(<span class="d_string">"string"</span>, 7) <span class="d_keyword">int</span> b;

<span class="d_keyword">enum</span> Foo;
@Foo <span class="d_keyword">int</span> c;

<span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getAttributes, a));
<span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getAttributes, b));
<span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getAttributes, c));
</pre>

    <p>        Prints:
    </p>

<pre class="console notranslate">tuple(3)
tuple("string", 7)
tuple((Foo))
</pre>


<h2><a id="getFunctionAttributes"><span class="gname">getFunctionAttributes</span></a></h2>    <p>        Takes one argument which must either be a function symbol, function literal,
        or a function pointer. It returns a string tuple of all the attributes of
        that function <b>excluding</b> any user defined attributes (UDAs can be
        retrieved with the <a href="#get-attributes">getAttributes</a> trait).
        If no attributes exist it will return an empty tuple.
    </p>


    <p>        <b>Note:</b> The order of the attributes in the returned tuple is
        implementation-defined and should not be relied upon.
    </p>

        <p>            A list of currently supported attributes are:
            <ul><li><span class="d_inlinecode donthyphenate notranslate">pure</span>, <span class="d_inlinecode donthyphenate notranslate">nothrow</span>, <span class="d_inlinecode donthyphenate notranslate">@nogc</span>, <span class="d_inlinecode donthyphenate notranslate">@property</span>, <span class="d_inlinecode donthyphenate notranslate">@system</span>, <span class="d_inlinecode donthyphenate notranslate">@trusted</span>, <span class="d_inlinecode donthyphenate notranslate">@safe</span>, and <span class="d_inlinecode donthyphenate notranslate">ref</span></li></ul>
            <b>Note:</b> <span class="d_inlinecode donthyphenate notranslate">ref</span> is a function attribute even though it applies to the return type.
        </p>

        <p>            Additionally the following attributes are only valid for non-static member functions:
            <ul><li><span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span>, <span class="d_inlinecode donthyphenate notranslate">inout</span>, <span class="d_inlinecode donthyphenate notranslate">shared</span></li></ul>
        </p>

    <p>For example:</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span> sum(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> { <span class="d_keyword">return</span> x + y; }

<span class="d_comment">// prints ("pure", "nothrow", "@system")
</span><span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getFunctionAttributes, sum));

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">void</span> test() <span class="d_keyword">const</span> @system { }
}

<span class="d_comment">// prints ("const", "@system")
</span><span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getFunctionAttributes, S.test));
</pre>

    <p>Note that some attributes can be inferred. For example:</p>

<pre class="d_code notranslate"><span class="d_comment">// prints ("pure", "nothrow", "@nogc", "@trusted")
</span><span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getFunctionAttributes, (<span class="d_keyword">int</span> x) @trusted { <span class="d_keyword">return</span> x * 2; }));
</pre>


<h2><a id="getMember"><span class="gname">getMember</span></a></h2>

	<p>Takes two arguments, the second must be a string.
	The result is an expression formed from the first
	argument, followed by a &lsquo;.&rsquo;, followed by the second
	argument as an identifier.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> mx;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> my;
}

<span class="d_keyword">void</span> main()
{
    S s;

    <span class="d_keyword">__traits</span>(getMember, s, <span class="d_string">"mx"</span>) = 1;  <span class="d_comment">// same as s.mx=1;
</span>    writeln(<span class="d_keyword">__traits</span>(getMember, s, <span class="d_string">"m"</span> ~ <span class="d_string">"x"</span>)); <span class="d_comment">// 1
</span>
    <span class="d_keyword">__traits</span>(getMember, S, <span class="d_string">"mx"</span>) = 1;  <span class="d_comment">// error, no this for S.mx
</span>    <span class="d_keyword">__traits</span>(getMember, S, <span class="d_string">"my"</span>) = 2;  <span class="d_comment">// ok
</span>}
</pre>

<h2><a id="getOverloads"><span class="gname">getOverloads</span></a></h2>

	<p>The first argument is an aggregate (e.g. struct/class/module).
	The second argument is a string that matches the name of
	one of the functions in that aggregate.
	The result is a tuple of all the overloads of that function.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">this</span>() { }
    ~<span class="d_keyword">this</span>() { }
    <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 2; }
}

<span class="d_keyword">void</span> main()
{
    D d = <span class="d_keyword">new</span> D();

    <span class="d_keyword">foreach</span> (t; <span class="d_keyword">__traits</span>(getOverloads, D, <span class="d_string">"foo"</span>))
        writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(t)));

    <span class="d_keyword">alias</span> b = <span class="d_keyword">typeof</span>(<span class="d_keyword">__traits</span>(getOverloads, D, <span class="d_string">"foo"</span>));
    <span class="d_keyword">foreach</span> (t; b)
        writeln(<span class="d_keyword">typeid</span>(t));

    <span class="d_keyword">auto</span> i = <span class="d_keyword">__traits</span>(getOverloads, d, <span class="d_string">"foo"</span>)[1](1);
    writeln(i);
}
</pre>

	<p>Prints:</p>

<pre class="console notranslate">void()
int()
void()
int()
2
</pre>

<h2><a id="getPointerBitmap"><span class="gname">getPointerBitmap</span></a></h2>

    <p>The argument is a type.
    The result is an array of <span class="d_inlinecode donthyphenate notranslate">size_t</span> describing the memory used by an instance of the given type.
    </p>
    <p>The first element of the array is the size of the type (for classes it is
    the <a href="#classInstanceSize"><span class="d_inlinecode donthyphenate notranslate">classInstanceSize</span></a>).</p>
    <p>The following elements describe the locations of GC managed pointers within the
    memory occupied by an instance of the type.
    For type T, there are <span class="d_inlinecode donthyphenate notranslate">T.sizeof / size_t.sizeof</span> possible pointers represented
    by the bits of the array values.</p>
    <p>This array can be used by a precise GC to avoid false pointers.</p>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C
{
    <span class="d_comment">// implicit virtual function table pointer not marked
</span>    <span class="d_comment">// implicit monitor field not marked, usually managed manually
</span>    C next;
    size_t sz;
    <span class="d_keyword">void</span>* p;
    <span class="d_keyword">void</span> <span class="d_keyword">function</span> () fn; <span class="d_comment">// not a GC managed pointer
</span>}

<span class="d_keyword">struct</span> S
{
    size_t val1;
    <span class="d_keyword">void</span>* p;
    C c;
    <span class="d_keyword">byte</span>[] arr;          <span class="d_comment">// { length, ptr }
</span>    <span class="d_keyword">void</span> <span class="d_keyword">delegate</span> () dg; <span class="d_comment">// { context, func }
</span>}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span> (<span class="d_keyword">__traits</span>(getPointerBitmap, C) == [6*size_t.sizeof, 0b010100]);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span> (<span class="d_keyword">__traits</span>(getPointerBitmap, S) == [7*size_t.sizeof, 0b0110110]);
</pre>


<h2><a id="getProtection"><span class="gname">getProtection</span></a></h2>

	<p>The argument is a symbol.
	The result is a string giving its protection level: "public", "private", "protected", "export", or "package".
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">export</span> <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">public</span> <span class="d_keyword">int</span> bar;
}

<span class="d_keyword">void</span> main()
{
    D d = <span class="d_keyword">new</span> D();

    <span class="d_keyword">auto</span> i = <span class="d_keyword">__traits</span>(getProtection, d.foo);
    writeln(i);

    <span class="d_keyword">auto</span> j = <span class="d_keyword">__traits</span>(getProtection, d.bar);
    writeln(j);
}
</pre>

	<p>Prints:</p>

<pre class="console notranslate">export
public
</pre>


<h2><a id="getVirtualFunctions"><span class="gname">getVirtualFunctions</span></a></h2>

	<p>The same as <a href="#getVirtualMethods"><i>getVirtualMethods</i></a>, except that
	final functions that do not override anything are included.
	</p>

<h2><a id="getVirtualMethods"><span class="gname">getVirtualMethods</span></a></h2>

	<p>The first argument is a class type or an expression of
	class type.
	The second argument is a string that matches the name of
	one of the functions of that class.
	The result is a tuple of the virtual overloads of that function.
	It does not include final functions that do not override anything.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">this</span>() { }
    ~<span class="d_keyword">this</span>() { }
    <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 2; }
}

<span class="d_keyword">void</span> main()
{
    D d = <span class="d_keyword">new</span> D();

    <span class="d_keyword">foreach</span> (t; <span class="d_keyword">__traits</span>(getVirtualMethods, D, <span class="d_string">"foo"</span>))
        writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(t)));

    <span class="d_keyword">alias</span> b = <span class="d_keyword">typeof</span>(<span class="d_keyword">__traits</span>(getVirtualMethods, D, <span class="d_string">"foo"</span>));
    <span class="d_keyword">foreach</span> (t; b)
        writeln(<span class="d_keyword">typeid</span>(t));

    <span class="d_keyword">auto</span> i = <span class="d_keyword">__traits</span>(getVirtualMethods, d, <span class="d_string">"foo"</span>)[1](1);
    writeln(i);
}
</pre>

	<p>Prints:</p>

<pre class="console notranslate">void()
int()
void()
int()
2
</pre>

<h2><a id="getUnitTests"><span class="gname">getUnitTests</span></a></h2>

	<p>		Takes one argument, a symbol of an aggregate (e.g. struct/class/module).
		The result is a tuple of all the unit test functions of that aggregate.
		The functions returned are like normal nested static functions,
		<a href="../glossary.html#ctfe">CTEF</a> will work and
		<a href="../spec/attribute.html#uda">UDA's</a> will be accessible.
	</p>

	<h4>Note:</h4>

	<p>		The -unittest flag needs to be passed to the compiler. If the flag
		is not passed <span class="d_inlinecode donthyphenate notranslate">__traits(getUnitTests)</span> will always return an
		empty tuple.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">module</span> foo;

<span class="d_keyword">import</span> core.runtime;
<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> name { string name; }

<span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">unittest</span>
    {
        writeln(<span class="d_string">"foo.Foo.unittest"</span>);
    }
}

@name(<span class="d_string">"foo"</span>) <span class="d_keyword">unittest</span>
{
    writeln(<span class="d_string">"foo.unittest"</span>);
}

<span class="d_keyword">template</span> Tuple (T...)
{
    <span class="d_keyword">alias</span> Tuple = T;
}

<span class="d_keyword">shared</span> <span class="d_keyword">static</span> <span class="d_keyword">this</span>()
{
  <span class="d_comment">// Override the default unit test runner to do nothing. After that, "main" will
</span>  <span class="d_comment">// be called.
</span>  Runtime.moduleUnitTester = { <span class="d_keyword">return</span> <span class="d_keyword">true</span>; };
}

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_string">"start main"</span>);

    <span class="d_keyword">alias</span> tests = Tuple!(<span class="d_keyword">__traits</span>(getUnitTests, foo));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(tests.length == 1);

    <span class="d_keyword">alias</span> attributes = Tuple!(<span class="d_keyword">__traits</span>(getAttributes, tests[0]));
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(attributes.length == 1);

    <span class="d_keyword">foreach</span> (test; tests)
        test();

    <span class="d_keyword">foreach</span> (test; <span class="d_keyword">__traits</span>(getUnitTests, Foo))
        test();
}
</pre>

	<p>By default, the above will print:</p>

<pre class="console notranslate">start main
foo.unittest
foo.Foo.unittest
</pre>

<h2><a id="parent"><span class="gname">parent</span></a></h2>

	<p>Takes a single argument which must evaluate to a symbol.
	The result is the symbol that is the parent of it.
	</p>

<h2><a id="classInstanceSize"><span class="gname">classInstanceSize</span></a></h2>

	<p>Takes a single argument, which must evaluate to either
	a class type or an expression of class type.
	The result
	is of type <span class="d_inlinecode donthyphenate notranslate">size_t</span>, and the value is the number of
	bytes in the runtime instance of the class type.
	It is based on the static type of a class, not the
	polymorphic type.
	</p>

<h2><a id="getVirtualIndex"><span class="gname">getVirtualIndex</span></a></h2>

  <p>Takes a single argument which must evaluate to a function.
  The result is a <span class="d_inlinecode donthyphenate notranslate">ptrdiff_t</span> containing the index
  of that function within the vtable of the parent type.
  If the function passed in is final and does not override
  a virtual function, <span class="d_inlinecode donthyphenate notranslate">-1</span> is returned instead.
  </p>

<h2><a id="allMembers"><span class="gname">allMembers</span></a></h2>

	<p>Takes a single argument, which must evaluate to either
	a type or an expression of type.
	A tuple of string literals is returned, each of which
	is the name of a member of that type combined with all
	of the members of the base classes (if the type is a class).
	No name is repeated.
	Builtin properties are not included.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">this</span>() { }
    ~<span class="d_keyword">this</span>() { }
    <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> b = [ <span class="d_keyword">__traits</span>(allMembers, D) ];
    writeln(b);
    <span class="d_comment">// ["__ctor", "__dtor", "foo", "toString", "toHash", "opCmp", "opEquals", "Monitor", "factory"]
</span>}
</pre>

	<p>The order in which the strings appear in the result
	is not defined.</p>

<h2><a id="derivedMembers"><span class="gname">derivedMembers</span></a></h2>

	<p>Takes a single argument, which must evaluate to either
	a type or an expression of type.
	A tuple of string literals is returned, each of which
	is the name of a member of that type.
	No name is repeated.
	Base class member names are not included.
	Builtin properties are not included.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D
{
    <span class="d_keyword">this</span>() { }
    ~<span class="d_keyword">this</span>() { }
    <span class="d_keyword">void</span> foo() { }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; }
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> a = [<span class="d_keyword">__traits</span>(derivedMembers, D)];
    writeln(a);    <span class="d_comment">// ["__ctor", "__dtor", "foo"]
</span>}
</pre>

	<p>The order in which the strings appear in the result
	is not defined.</p>

<h2><a id="isSame"><span class="gname">isSame</span></a></h2>

	<p>Takes two arguments and returns bool <span class="d_inlinecode donthyphenate notranslate">true</span> if they
	are the same symbol, <span class="d_inlinecode donthyphenate notranslate">false</span> if not.</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S { }

<span class="d_keyword">int</span> foo();
<span class="d_keyword">int</span> bar();

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_keyword">__traits</span>(isSame, foo, foo)); <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(isSame, foo, bar)); <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isSame, foo, S));   <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isSame, S, S));     <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(isSame, std, S));   <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(isSame, std, std)); <span class="d_comment">// true
</span>}
</pre>

	<p>If the two arguments are expressions made up of literals
	or enums that evaluate to the same value, true is returned.</p>

<h2><a id="compiles"><span class="gname">compiles</span></a></h2>

	<p>Returns a bool <span class="d_inlinecode donthyphenate notranslate">true</span> if all of the arguments
	compile (are semantically correct).
	The arguments can be symbols, types, or expressions that
	are syntactically correct.
	The arguments cannot be statements or declarations.
	</p>

	<p>If there are no arguments, the result is <span class="d_inlinecode donthyphenate notranslate">false</span>.</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> s1;
    <span class="d_keyword">int</span> s2;
}

<span class="d_keyword">int</span> foo();
<span class="d_keyword">int</span> bar();

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_keyword">__traits</span>(compiles));                      <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, foo));                 <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, foo + 1));             <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, &amp;foo + 1));            <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, <span class="d_keyword">typeof</span>(1)));           <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, S.s1));                <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, S.s3));                <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, 1,2,3,<span class="d_keyword">int</span>,<span class="d_keyword">long</span>,std));  <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, 3[1]));                <span class="d_comment">// false
</span>    writeln(<span class="d_keyword">__traits</span>(compiles, 1,2,3,<span class="d_keyword">int</span>,<span class="d_keyword">long</span>,3[1])); <span class="d_comment">// false
</span>}
</pre>

	<p>This is useful for:</p>

	<ul>	<li>Giving better error messages inside generic code than
	the sometimes hard to follow compiler ones.</li>
	<li>Doing a finer grained specialization than template
	partial specialization allows for.</li>
	</ul>


<h2><a class="anchor" title="Permalink to this section" id="specialkeywords" href="#specialkeywords">Special Keywords</a></h2>

    <p><span class="d_inlinecode donthyphenate notranslate">__FILE__</span> and <span class="d_inlinecode donthyphenate notranslate">__LINE__</span> expand to the source
    file name and line number at the point of instantiation.</p>

    <p><span class="d_inlinecode donthyphenate notranslate">__MODULE__</span> expands to the module name at the point of
    instantiation.</p>

    <p><span class="d_inlinecode donthyphenate notranslate">__FUNCTION__</span> expands to the fully qualified name of the
    function at the point of instantiation.</p>

    <p><span class="d_inlinecode donthyphenate notranslate">__PRETTY_FUNCTION__</span> is similar to <span class="d_inlinecode donthyphenate notranslate">__FUNCTION__</span>,
    but also expands the function return type, its parameter types,
    and its attributes.</p>

    <p>Example usage:</p>

<pre class="d_code notranslate"><span class="d_keyword">module</span> test;
<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> test(string file = <span class="d_keyword">__FILE__</span>, size_t line = <span class="d_keyword">__LINE__</span>, string mod = <span class="d_keyword">__MODULE__</span>,
          string func = <span class="d_keyword">__FUNCTION__</span>, string pretty = <span class="d_keyword">__PRETTY_FUNCTION__</span>)
{
    writefln(<span class="d_string">"file: '%s', line: '%s', module: '%s',\nfunction: '%s', pretty function: '%s'"</span>,
             file, line, mod, func, pretty);
}

<span class="d_keyword">int</span> main(string[] args)
{
    test();
    <span class="d_keyword">return</span> 0;
}
</pre>

	<p>This will output:</p>

<pre class="console notranslate">file: 'test.d', line: '13', module: 'test',
function: 'test.main', pretty function: 'int test.main(string[] args)'
</pre>




</div>
<div id="copyright">Copyright &copy; 1999-2017 by Digital Mars &reg;, All Rights Reserved | Page generated by <a href="http://dlang.org/spec/ddoc.html">Ddoc</a> on (no date time)</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
</body>
</html>

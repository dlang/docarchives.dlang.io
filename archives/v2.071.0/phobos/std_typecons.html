
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>std.typecons - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='std.typecons' class='std'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='../getstarted.html'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'><li><a href='    ../spec/intro.html'>Language Reference</a></li><li><a href='    ../phobos/index.html'>Library Reference</a></li><li><a href='    ../comparison.html'>Feature Overview</a></li><li><a href='    ../dmd-windows.html'>DMD Manual</a></li><li><a href='    ../articles.html'>Articles
</a></li></ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'><li><a href='    ../bugstats.php'>Bug Tracker</a></li><li><a href='    https://forum.dlang.org'>Forums</a></li><li><a href='    irc://irc.freenode.net/d'>IRC</a></li><li><a href='    https://github.com/D-Programming-Language'>D on GitHub</a></li><li><a href='    https://wiki.dlang.org'>Wiki</a></li><li><a href='    https://wiki.dlang.org/Review_Queue'>Review Queue</a></li><li><a href='    https://twitter.com/search?q=%23dlang'>Twitter</a></li><li><a href='    http://digitalmars.com/d/dlinks.html'>More Links
</a></li></ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'><li><a href='    ../library/index.html'>NEW Library Reference Preview</a></li><li><a href='    ../tools.html'>D-Specific Tools</a></li><li><a href='    http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li><li><a href='    https://wiki.dlang.org/Editors'>Editors</a></li><li><a href='    https://wiki.dlang.org/IDEs'>IDEs</a></li><li><a href='    https://wiki.dlang.org/Tutorials'>Tutorials</a></li><li><a href='    https://wiki.dlang.org/Books'>Books</a></li><li><a href='    ../dstyle.html'>The D Style</a></li><li><a href='    ../glossary.html'>Glossary</a></li><li><a href='    ../acknowledgements.html'>Acknowledgments</a></li><li><a href='    ../sitemap.html'>Sitemap
</a></li></ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option selected value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    <div class="head">        <h2>Library Reference</h2>
        <p><span class="smallprint">pre-release version <span class="separator"><br></span>
            <a href="../phobos/index.html">switch to version 2.071.0</a></span></p>
        <p><a href="index.html">overview</a></p>
    </div>
    <ul>
<li><a href='object.html'><span><em class="tt">object</em></span></a></li>

<li class='expand-container'><a class='expand-toggle' href='#'><span><em class="tt">std</em></span></a>
<ul><li>  <a href="std_algorithm.html" title="std.algorithm"><span class="d_inlinecode donthyphenate notranslate">algorithm</span></a><ul><li>    <a href="std_algorithm_comparison.html" title="std.algorithm.comparison"><span class="d_inlinecode donthyphenate notranslate">comparison</span></a></li><li>    <a href="std_algorithm_iteration.html" title="std.algorithm.iteration"><span class="d_inlinecode donthyphenate notranslate">iteration</span></a></li><li>    <a href="std_algorithm_mutation.html" title="std.algorithm.mutation"><span class="d_inlinecode donthyphenate notranslate">mutation</span></a></li><li>    <a href="std_algorithm_searching.html" title="std.algorithm.searching"><span class="d_inlinecode donthyphenate notranslate">searching</span></a></li><li>    <a href="std_algorithm_setops.html" title="std.algorithm.setops"><span class="d_inlinecode donthyphenate notranslate">setops</span></a></li><li>    <a href="std_algorithm_sorting.html" title="std.algorithm.sorting"><span class="d_inlinecode donthyphenate notranslate">sorting</span></a>
  </li></ul></li><li>  <a href="std_array.html" title="std.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>  <a href="std_ascii.html" title="std.ascii"><span class="d_inlinecode donthyphenate notranslate">ascii</span></a></li><li>  <a href="std_base64.html" title="std.base64"><span class="d_inlinecode donthyphenate notranslate">base64</span></a></li><li>  <a href="std_bigint.html" title="std.bigint"><span class="d_inlinecode donthyphenate notranslate">bigint</span></a></li><li>  <a href="std_bitmanip.html" title="std.bitmanip"><span class="d_inlinecode donthyphenate notranslate">bitmanip</span></a></li><li>  <a href="std_compiler.html" title="std.compiler"><span class="d_inlinecode donthyphenate notranslate">compiler</span></a></li><li>  <a href="std_complex.html" title="std.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>  <a href="std_concurrency.html" title="std.concurrency"><span class="d_inlinecode donthyphenate notranslate">concurrency</span></a></li><li>  <a href="std_concurrencybase.html" title="std.concurrencybase"><span class="d_inlinecode donthyphenate notranslate">concurrencybase</span></a></li><li>  <a href="std_container.html" title="std.container"><span class="d_inlinecode donthyphenate notranslate">container</span></a><ul><li>    <a href="std_container_array.html" title="std.container.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>    <a href="std_container_binaryheap.html" title="std.container.binaryheap"><span class="d_inlinecode donthyphenate notranslate">binaryheap</span></a></li><li>    <a href="std_container_dlist.html" title="std.container.dlist"><span class="d_inlinecode donthyphenate notranslate">dlist</span></a></li><li>    <a href="std_container_rbtree.html" title="std.container.rbtree"><span class="d_inlinecode donthyphenate notranslate">rbtree</span></a></li><li>    <a href="std_container_slist.html" title="std.container.slist"><span class="d_inlinecode donthyphenate notranslate">slist</span></a></li><li>    <a href="std_container_util.html" title="std.container.util"><span class="d_inlinecode donthyphenate notranslate">util</span></a>
  </li></ul></li><li>  <a href="std_conv.html" title="std.conv"><span class="d_inlinecode donthyphenate notranslate">conv</span></a></li><li>  <a href="std_csv.html" title="std.csv"><span class="d_inlinecode donthyphenate notranslate">csv</span></a></li><li>  <a href="std_datetime.html" title="std.datetime"><span class="d_inlinecode donthyphenate notranslate">datetime</span></a></li><li>  <a href="std_demangle.html" title="std.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">digest</span></h7><ul><li>    <a href="std_digest_crc.html" title="std.digest.crc"><span class="d_inlinecode donthyphenate notranslate">crc</span></a></li><li>    <a href="std_digest_digest.html" title="std.digest.digest"><span class="d_inlinecode donthyphenate notranslate">digest</span></a></li><li>    <a href="std_digest_hmac.html" title="std.digest.hmac"><span class="d_inlinecode donthyphenate notranslate">hmac</span></a></li><li>    <a href="std_digest_md.html" title="std.digest.md"><span class="d_inlinecode donthyphenate notranslate">md</span></a></li><li>    <a href="std_digest_ripemd.html" title="std.digest.ripemd"><span class="d_inlinecode donthyphenate notranslate">ripemd</span></a></li><li>    <a href="std_digest_sha.html" title="std.digest.sha"><span class="d_inlinecode donthyphenate notranslate">sha</span></a>
  </li></ul></li><li>  <a href="std_encoding.html" title="std.encoding"><span class="d_inlinecode donthyphenate notranslate">encoding</span></a></li><li>  <a href="std_exception.html" title="std.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">experimental</span></h7><ul><li>    <a href="std_experimental_allocator.html" title="std.experimental.allocator"><span class="d_inlinecode donthyphenate notranslate">allocator</span></a><ul><li>      <a href="std_experimental_allocator_building_blocks.html" title="std.experimental.allocator.building_blocks"><span class="d_inlinecode donthyphenate notranslate">building_blocks</span></a><ul><li>        <a href="std_experimental_allocator_building_blocks_affix_allocator.html" title="std.experimental.allocator.building_blocks.affix_allocator"><span class="d_inlinecode donthyphenate notranslate">affix_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_allocator_list.html" title="std.experimental.allocator.building_blocks.allocator_list"><span class="d_inlinecode donthyphenate notranslate">allocator_list</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_bitmapped_block.html" title="std.experimental.allocator.building_blocks.bitmapped_block"><span class="d_inlinecode donthyphenate notranslate">bitmapped_block</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_bucketizer.html" title="std.experimental.allocator.building_blocks.bucketizer"><span class="d_inlinecode donthyphenate notranslate">bucketizer</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_fallback_allocator.html" title="std.experimental.allocator.building_blocks.fallback_allocator"><span class="d_inlinecode donthyphenate notranslate">fallback_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_free_list.html" title="std.experimental.allocator.building_blocks.free_list"><span class="d_inlinecode donthyphenate notranslate">free_list</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_free_tree.html" title="std.experimental.allocator.building_blocks.free_tree"><span class="d_inlinecode donthyphenate notranslate">free_tree</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_kernighan_ritchie.html" title="std.experimental.allocator.building_blocks.kernighan_ritchie"><span class="d_inlinecode donthyphenate notranslate">kernighan_ritchie</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_null_allocator.html" title="std.experimental.allocator.building_blocks.null_allocator"><span class="d_inlinecode donthyphenate notranslate">null_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_quantizer.html" title="std.experimental.allocator.building_blocks.quantizer"><span class="d_inlinecode donthyphenate notranslate">quantizer</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_region.html" title="std.experimental.allocator.building_blocks.region"><span class="d_inlinecode donthyphenate notranslate">region</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_scoped_allocator.html" title="std.experimental.allocator.building_blocks.scoped_allocator"><span class="d_inlinecode donthyphenate notranslate">scoped_allocator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_segregator.html" title="std.experimental.allocator.building_blocks.segregator"><span class="d_inlinecode donthyphenate notranslate">segregator</span></a></li><li>        <a href="std_experimental_allocator_building_blocks_stats_collector.html" title="std.experimental.allocator.building_blocks.stats_collector"><span class="d_inlinecode donthyphenate notranslate">stats_collector</span></a>
      </li></ul></li><li>      <a href="std_experimental_allocator_common.html" title="std.experimental.allocator.common"><span class="d_inlinecode donthyphenate notranslate">common</span></a></li><li>      <a href="std_experimental_allocator_gc_allocator.html" title="std.experimental.allocator.gc_allocator"><span class="d_inlinecode donthyphenate notranslate">gc_allocator</span></a></li><li>      <a href="std_experimental_allocator_mallocator.html" title="std.experimental.allocator.mallocator"><span class="d_inlinecode donthyphenate notranslate">mallocator</span></a></li><li>      <a href="std_experimental_allocator_mmap_allocator.html" title="std.experimental.allocator.mmap_allocator"><span class="d_inlinecode donthyphenate notranslate">mmap_allocator</span></a></li><li>      <a href="std_experimental_allocator_showcase.html" title="std.experimental.allocator.showcase"><span class="d_inlinecode donthyphenate notranslate">showcase</span></a></li><li>      <a href="std_experimental_allocator_typed.html" title="std.experimental.allocator.typed"><span class="d_inlinecode donthyphenate notranslate">typed</span></a>
    </li></ul></li><li>    <a href="std_experimental_logger.html" title="std.experimental.logger"><span class="d_inlinecode donthyphenate notranslate">logger</span></a><ul><li>      <a href="std_experimental_logger_core.html" title="std.experimental.logger.core"><span class="d_inlinecode donthyphenate notranslate">core</span></a></li><li>      <a href="std_experimental_logger_filelogger.html" title="std.experimental.logger.filelogger"><span class="d_inlinecode donthyphenate notranslate">filelogger</span></a></li><li>      <a href="std_experimental_logger_multilogger.html" title="std.experimental.logger.multilogger"><span class="d_inlinecode donthyphenate notranslate">multilogger</span></a></li><li>      <a href="std_experimental_logger_nulllogger.html" title="std.experimental.logger.nulllogger"><span class="d_inlinecode donthyphenate notranslate">nulllogger</span></a>
    </li></ul></li><li>    <a href="std_experimental_ndslice.html" title="std.experimental.ndslice"><span class="d_inlinecode donthyphenate notranslate">ndslice</span></a><ul><li>      <a href="std_experimental_ndslice_iteration.html" title="std.experimental.ndslice.iteration"><span class="d_inlinecode donthyphenate notranslate">iteration</span></a></li><li>      <a href="std_experimental_ndslice_selection.html" title="std.experimental.ndslice.selection"><span class="d_inlinecode donthyphenate notranslate">selection</span></a></li><li>      <a href="std_experimental_ndslice_slice.html" title="std.experimental.ndslice.slice"><span class="d_inlinecode donthyphenate notranslate">slice</span></a>
    </li></ul>
  </li></ul></li><li>  <a href="std_file.html" title="std.file"><span class="d_inlinecode donthyphenate notranslate">file</span></a></li><li>  <a href="std_format.html" title="std.format"><span class="d_inlinecode donthyphenate notranslate">format</span></a></li><li>  <a href="std_functional.html" title="std.functional"><span class="d_inlinecode donthyphenate notranslate">functional</span></a></li><li>  <a href="std_getopt.html" title="std.getopt"><span class="d_inlinecode donthyphenate notranslate">getopt</span></a></li><li>  <a href="std_json.html" title="std.json"><span class="d_inlinecode donthyphenate notranslate">json</span></a></li><li>  <a href="std_math.html" title="std.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="std_mathspecial.html" title="std.mathspecial"><span class="d_inlinecode donthyphenate notranslate">mathspecial</span></a></li><li>  <a href="std_meta.html" title="std.meta"><span class="d_inlinecode donthyphenate notranslate">meta</span></a></li><li>  <a href="std_mmfile.html" title="std.mmfile"><span class="d_inlinecode donthyphenate notranslate">mmfile</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">net</span></h7><ul><li>    <a href="std_net_curl.html" title="std.net.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="std_net_isemail.html" title="std.net.isemail"><span class="d_inlinecode donthyphenate notranslate">isemail</span></a>
  </li></ul></li><li>  <a href="std_numeric.html" title="std.numeric"><span class="d_inlinecode donthyphenate notranslate">numeric</span></a></li><li>  <a href="std_outbuffer.html" title="std.outbuffer"><span class="d_inlinecode donthyphenate notranslate">outbuffer</span></a></li><li>  <a href="std_parallelism.html" title="std.parallelism"><span class="d_inlinecode donthyphenate notranslate">parallelism</span></a></li><li>  <a href="std_path.html" title="std.path"><span class="d_inlinecode donthyphenate notranslate">path</span></a></li><li>  <a href="std_process.html" title="std.process"><span class="d_inlinecode donthyphenate notranslate">process</span></a></li><li>  <a href="std_random.html" title="std.random"><span class="d_inlinecode donthyphenate notranslate">random</span></a></li><li>  <a href="std_range.html" title="std.range"><span class="d_inlinecode donthyphenate notranslate">range</span></a><ul><li>    <a href="std_range_interfaces.html" title="std.range.interfaces"><span class="d_inlinecode donthyphenate notranslate">interfaces</span></a></li><li>    <a href="std_range_primitives.html" title="std.range.primitives"><span class="d_inlinecode donthyphenate notranslate">primitives</span></a>
  </li></ul></li><li>  <a href="std_regex.html" title="std.regex"><span class="d_inlinecode donthyphenate notranslate">regex</span></a></li><li>  <a href="std_signals.html" title="std.signals"><span class="d_inlinecode donthyphenate notranslate">signals</span></a></li><li>  <a href="std_socket.html" title="std.socket"><span class="d_inlinecode donthyphenate notranslate">socket</span></a></li><li>  <a href="std_stdint.html" title="std.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>  <a href="std_stdio.html" title="std.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>  <a href="std_stdiobase.html" title="std.stdiobase"><span class="d_inlinecode donthyphenate notranslate">stdiobase</span></a></li><li>  <a href="std_string.html" title="std.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>  <a href="std_system.html" title="std.system"><span class="d_inlinecode donthyphenate notranslate">system</span></a></li><li>  <a href="std_traits.html" title="std.traits"><span class="d_inlinecode donthyphenate notranslate">traits</span></a></li><li>  <a href="std_typecons.html" title="std.typecons"><span class="d_inlinecode donthyphenate notranslate">typecons</span></a></li><li>  <a href="std_typetuple.html" title="std.typetuple"><span class="d_inlinecode donthyphenate notranslate">typetuple</span></a></li><li>  <a href="std_uni.html" title="std.uni"><span class="d_inlinecode donthyphenate notranslate">uni</span></a></li><li>  <a href="std_uri.html" title="std.uri"><span class="d_inlinecode donthyphenate notranslate">uri</span></a></li><li>  <a href="std_utf.html" title="std.utf"><span class="d_inlinecode donthyphenate notranslate">utf</span></a></li><li>  <a href="std_uuid.html" title="std.uuid"><span class="d_inlinecode donthyphenate notranslate">uuid</span></a></li><li>  <a href="std_variant.html" title="std.variant"><span class="d_inlinecode donthyphenate notranslate">variant</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">windows</span></h7><ul><li>    <a href="std_windows_charset.html" title="std.windows.charset"><span class="d_inlinecode donthyphenate notranslate">charset</span></a></li><li>    <a href="std_windows_syserror.html" title="std.windows.syserror"><span class="d_inlinecode donthyphenate notranslate">syserror</span></a>
  </li></ul></li><li>  <a href="std_xml.html" title="std.xml"><span class="d_inlinecode donthyphenate notranslate">xml</span></a></li><li>  <a href="std_zip.html" title="std.zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a></li><li>  <a href="std_zlib.html" title="std.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
</li></ul>
</li>

<li class='expand-container'><a class='expand-toggle' href='#'><span><em class="tt">etc</em></span></a>
<ul><li>  <h7><span class="d_inlinecode donthyphenate notranslate">c</span></h7><ul><li>    <a href="etc_c_curl.html" title="etc.c.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <h7><span class="d_inlinecode donthyphenate notranslate">odbc</span></h7><ul><li>      <a href="etc_c_odbc_sql.html" title="etc.c.odbc.sql"><span class="d_inlinecode donthyphenate notranslate">sql</span></a></li><li>      <a href="etc_c_odbc_sqlext.html" title="etc.c.odbc.sqlext"><span class="d_inlinecode donthyphenate notranslate">sqlext</span></a></li><li>      <a href="etc_c_odbc_sqltypes.html" title="etc.c.odbc.sqltypes"><span class="d_inlinecode donthyphenate notranslate">sqltypes</span></a></li><li>      <a href="etc_c_odbc_sqlucode.html" title="etc.c.odbc.sqlucode"><span class="d_inlinecode donthyphenate notranslate">sqlucode</span></a>
    </li></ul></li><li>    <a href="etc_c_sqlite3.html" title="etc.c.sqlite3"><span class="d_inlinecode donthyphenate notranslate">sqlite3</span></a></li><li>    <a href="etc_c_zlib.html" title="etc.c.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
  </li></ul>
</li></ul>
</li>

<li class='expand-container'><a class='expand-toggle' href='#'><span><em class="tt">core</em></span></a>
<ul><li>  <a href="core_atomic.html" title="core.atomic"><span class="d_inlinecode donthyphenate notranslate">atomic</span></a></li><li>  <a href="core_attribute.html" title="core.attribute"><span class="d_inlinecode donthyphenate notranslate">attribute</span></a></li><li>  <a href="core_bitop.html" title="core.bitop"><span class="d_inlinecode donthyphenate notranslate">bitop</span></a></li><li>  <a href="core_checkedint.html" title="core.checkedint"><span class="d_inlinecode donthyphenate notranslate">checkedint</span></a></li><li>  <a href="core_cpuid.html" title="core.cpuid"><span class="d_inlinecode donthyphenate notranslate">cpuid</span></a></li><li>  <a href="core_demangle.html" title="core.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <a href="core_exception.html" title="core.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="core_math.html" title="core.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="core_memory.html" title="core.memory"><span class="d_inlinecode donthyphenate notranslate">memory</span></a></li><li>  <a href="core_runtime.html" title="core.runtime"><span class="d_inlinecode donthyphenate notranslate">runtime</span></a></li><li>  <a href="core_simd.html" title="core.simd"><span class="d_inlinecode donthyphenate notranslate">simd</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">stdc</span></h7><ul><li>    <a href="core_stdc_complex.html" title="core.stdc.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>    <a href="core_stdc_ctype.html" title="core.stdc.ctype"><span class="d_inlinecode donthyphenate notranslate">ctype</span></a></li><li>    <a href="core_stdc_errno.html" title="core.stdc.errno"><span class="d_inlinecode donthyphenate notranslate">errno</span></a></li><li>    <a href="core_stdc_fenv.html" title="core.stdc.fenv"><span class="d_inlinecode donthyphenate notranslate">fenv</span></a></li><li>    <a href="core_stdc_float_.html" title="core.stdc.float_"><span class="d_inlinecode donthyphenate notranslate">float_</span></a></li><li>    <a href="core_stdc_inttypes.html" title="core.stdc.inttypes"><span class="d_inlinecode donthyphenate notranslate">inttypes</span></a></li><li>    <a href="core_stdc_limits.html" title="core.stdc.limits"><span class="d_inlinecode donthyphenate notranslate">limits</span></a></li><li>    <a href="core_stdc_locale.html" title="core.stdc.locale"><span class="d_inlinecode donthyphenate notranslate">locale</span></a></li><li>    <a href="core_stdc_math.html" title="core.stdc.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>    <a href="core_stdc_signal.html" title="core.stdc.signal"><span class="d_inlinecode donthyphenate notranslate">signal</span></a></li><li>    <a href="core_stdc_stdarg.html" title="core.stdc.stdarg"><span class="d_inlinecode donthyphenate notranslate">stdarg</span></a></li><li>    <a href="core_stdc_stddef.html" title="core.stdc.stddef"><span class="d_inlinecode donthyphenate notranslate">stddef</span></a></li><li>    <a href="core_stdc_stdint.html" title="core.stdc.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>    <a href="core_stdc_stdio.html" title="core.stdc.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>    <a href="core_stdc_stdlib.html" title="core.stdc.stdlib"><span class="d_inlinecode donthyphenate notranslate">stdlib</span></a></li><li>    <a href="core_stdc_string.html" title="core.stdc.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>    <a href="core_stdc_tgmath.html" title="core.stdc.tgmath"><span class="d_inlinecode donthyphenate notranslate">tgmath</span></a></li><li>    <a href="core_stdc_time.html" title="core.stdc.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>    <a href="core_stdc_wchar_.html" title="core.stdc.wchar_"><span class="d_inlinecode donthyphenate notranslate">wchar_</span></a></li><li>    <a href="core_stdc_wctype.html" title="core.stdc.wctype"><span class="d_inlinecode donthyphenate notranslate">wctype</span></a>
  </li></ul></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">stdcpp</span></h7><ul><li>    <a href="core_stdcpp_exception.html" title="core.stdcpp.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>    <a href="core_stdcpp_typeinfo.html" title="core.stdcpp.typeinfo"><span class="d_inlinecode donthyphenate notranslate">typeinfo</span></a>
  </li></ul></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">sync</span></h7><ul><li>    <a href="core_sync_barrier.html" title="core.sync.barrier"><span class="d_inlinecode donthyphenate notranslate">barrier</span></a></li><li>    <a href="core_sync_condition.html" title="core.sync.condition"><span class="d_inlinecode donthyphenate notranslate">condition</span></a></li><li>    <a href="core_sync_config.html" title="core.sync.config"><span class="d_inlinecode donthyphenate notranslate">config</span></a></li><li>    <a href="core_sync_exception.html" title="core.sync.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>    <a href="core_sync_mutex.html" title="core.sync.mutex"><span class="d_inlinecode donthyphenate notranslate">mutex</span></a></li><li>    <a href="core_sync_rwmutex.html" title="core.sync.rwmutex"><span class="d_inlinecode donthyphenate notranslate">rwmutex</span></a></li><li>    <a href="core_sync_semaphore.html" title="core.sync.semaphore"><span class="d_inlinecode donthyphenate notranslate">semaphore</span></a>
  </li></ul></li><li>  <a href="core_thread.html" title="core.thread"><span class="d_inlinecode donthyphenate notranslate">thread</span></a></li><li>  <a href="core_time.html" title="core.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>  <a href="core_vararg.html" title="core.vararg"><span class="d_inlinecode donthyphenate notranslate">vararg</span></a>
</li></ul>
</li></ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/phobos/&amp;bug_severity=enhancement&amp;component=phobos&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5Bstd.typecons%5D&amp;version=D2">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/typecons.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1><span class="d_inlinecode donthyphenate notranslate">std.typecons</span></h1>
        <div class="quickindex" id="quickindex"></div>
        <div class="summary">This module implements a variety of type constructors, i.e., templates
that allow construction of new, useful general-purpose types.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Source:</span>
<span class="phobos_src"><a class="https" href="https://github.com/D-Programming-Language/phobos/blob/master/std/typecons.d">std/typecons.d</a></span>

</p></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Synopsis:</span>
<pre class="d_code notranslate"><span class="d_comment">// value tuples
</span><span class="d_keyword">alias</span> Coord = Tuple!(<span class="d_keyword">float</span>, <span class="d_string">"x"</span>, <span class="d_keyword">float</span>, <span class="d_string">"y"</span>, <span class="d_keyword">float</span>, <span class="d_string">"z"</span>);
Coord c;
c[1] = 1;       <span class="d_comment">// access by index
</span>c.z = 1;        <span class="d_comment">// access by given name
</span><span class="d_keyword">alias</span> DicEntry = Tuple!(string, string); <span class="d_comment">// names can be omitted
</span>
<span class="d_comment">// Rebindable references to const and immutable objects
</span><span class="d_keyword">void</span> bar()
{
    <span class="d_keyword">const</span> w1 = <span class="d_keyword">new</span> Widget, w2 = <span class="d_keyword">new</span> Widget;
    w1.foo();
    <span class="d_comment">// w1 = w2 would not work; can't rebind const object
</span>    <span class="d_keyword">auto</span> r = Rebindable!(<span class="d_keyword">const</span> Widget)(w1);
    <span class="d_comment">// invoke method as if r were a Widget object
</span>    r.foo();
    <span class="d_comment">// rebind r to refer to another object
</span>    r = w2;
}
</pre>

</p></div>
<div class="keyval License"><span class="key keyLicense">License:</span> <div class="val valLicense"><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
</div></div>
<div class="keyval Authors"><span class="key keyAuthors">Authors:</span> <div class="val valAuthors"><a href="http://erdani.org">Andrei Alexandrescu</a>,
           <a href="http://bartoszmilewski.wordpress.com">Bartosz Milewski</a>,
           Don Clugston,
           Shin Fujishiro,
           Kenji Hara</div></div>

<dl><dt class="d_decl"><div ><a name=".Unique"></a><div class="quickindex" id="quickindex.Unique"></div>struct <a name="Unique"></a><span class="ddoc_psymbol">Unique</span>(T);
<br></div></dt>
<dd><div class="summary">Encapsulates unique ownership of a resource.  Resource of type <span class="d_inlinecode donthyphenate notranslate">T</span> is
deleted at the end of the scope, unless it is transferred.  The
transfer can be explicit, by calling <span class="d_inlinecode donthyphenate notranslate">release</span>, or implicit, when
returning <a name="Unique"></a><span class="ddoc_psymbol">Unique</span> from a function. The resource can be a polymorphic
class object, in which case <a name="Unique"></a><span class="ddoc_psymbol">Unique</span> behaves polymorphically too.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> i;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> i){<span class="d_keyword">this</span>.i = i;}
}
<span class="d_psymbol">Unique</span>!S produce()
{
    <span class="d_comment">// Construct a unique instance of S on the heap
</span>    <span class="d_psymbol">Unique</span>!S ut = <span class="d_keyword">new</span> S(5);
    <span class="d_comment">// Implicit transfer of ownership
</span>    <span class="d_keyword">return</span> ut;
}
<span class="d_comment">// Borrow a unique resource by ref
</span><span class="d_keyword">void</span> increment(<span class="d_keyword">ref</span> <span class="d_psymbol">Unique</span>!S ur)
{
    ur.i++;
}
<span class="d_keyword">void</span> consume(<span class="d_psymbol">Unique</span>!S u2)
{
    <span class="d_keyword">assert</span>(u2.i == 6);
    <span class="d_comment">// Resource automatically deleted here
</span>}
<span class="d_psymbol">Unique</span>!S u1;
<span class="d_keyword">assert</span>(u1.isEmpty);
u1 = produce();
increment(u1);
<span class="d_keyword">assert</span>(u1.i == 6);
<span class="d_comment">//consume(u1); // Error: u1 is not copyable
</span><span class="d_comment">// Transfer ownership of the resource
</span>consume(u1.release);
<span class="d_keyword">assert</span>(u1.isEmpty);
</pre>
</div></div>
<dl><dt class="d_decl"><div ><a name=".Unique.RefT"></a><div class="quickindex" id="quickindex.Unique.RefT"></div>alias <a name="RefT"></a><span class="ddoc_psymbol">RefT</span> = T;
<br></div></dt>
<dd><div class="summary">Represents a reference to <span class="d_inlinecode donthyphenate notranslate">T</span>. Resolves to <span class="d_inlinecode donthyphenate notranslate">T*</span> if <span class="d_inlinecode donthyphenate notranslate">T</span> is a value type.</div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.create"></a><div class="quickindex" id="quickindex.Unique.create"></div>Unique!T <a name="create"></a><span class="ddoc_psymbol">create</span><span class="template_param_list" title="Template parameter list">(A...)</span>(auto ref A <i>args</i>)<br><span class="constraint">if (__traits(compiles, new T(<i>args</i>)))</span>;
<br></div></dt>
<dd><div class="summary">Allows safe construction of <span class="d_inlinecode donthyphenate notranslate">Unique</span>. It creates the resource and
    guarantees unique ownership of it (unless <span class="d_inlinecode donthyphenate notranslate">T</span> publishes aliases of
    <span class="d_inlinecode donthyphenate notranslate">this</span>).
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Nested structs/classes cannot be created.
</p></div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">A <i>args</i></td>
<td class="param_desc">Arguments to pass to <span class="d_inlinecode donthyphenate notranslate">T</span>'s constructor.
<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">class</span> C {}
<span class="d_keyword">auto</span> u = Unique!(C).<span class="d_psymbol">create</span>();
</pre>
</td></tr>
</table></div></div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.this"></a><div class="quickindex" id="quickindex.Unique.this"></div>this(RefT <i>p</i>);
<br></div></dt>
<dd><div class="summary">    Constructor that takes an rvalue.
    It will ensure uniqueness, as long as the rvalue
    isn't just a view on an lvalue (e.g., a cast).
    Typical usage:
<pre class="d_code notranslate">Unique!Foo f = <span class="d_keyword">new</span> Foo;
</pre>
</div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.this.2"></a><div class="quickindex" id="quickindex.Unique.this.2"></div>this(ref RefT <i>p</i>);
<br></div></dt>
<dd><div class="summary">Constructor that takes an lvalue. It nulls its source.
    The nulling will ensure uniqueness as long as there
    are no previous aliases to the source.</div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.this.3"></a><div class="quickindex" id="quickindex.Unique.this.3"></div>this<span class="template_param_list" title="Template parameter list">(U)</span>(Unique!U <i>u</i>)<br><span class="constraint">if (is(<i>u</i>.RefT : RefT))</span>;
<br></div></dt>
<dd><div class="summary">Constructor that takes a <span class="d_inlinecode donthyphenate notranslate">Unique</span> of a type that is convertible to our type.
</div>
<div class="description">Typically used to transfer a <span class="d_inlinecode donthyphenate notranslate">Unique</span> rvalue of derived type to
    a <span class="d_inlinecode donthyphenate notranslate">Unique</span> of base type.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C : Object {}

Unique!C uc = <span class="d_keyword">new</span> C;
Unique!Object uo = uc.release;
</pre>
</p></div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.opAssign"></a><div class="quickindex" id="quickindex.Unique.opAssign"></div>void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span><span class="template_param_list" title="Template parameter list">(U)</span>(Unique!U <i>u</i>)<br><span class="constraint">if (is(<i>u</i>.RefT : RefT))</span>;
<br></div></dt>
<dd><div class="summary">Transfer ownership from a <span class="d_inlinecode donthyphenate notranslate">Unique</span> of a type that is convertible to our type.</div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.isEmpty"></a><div class="quickindex" id="quickindex.Unique.isEmpty"></div>const @property bool <a name="isEmpty"></a><span class="ddoc_psymbol">isEmpty</span>();
<br></div></dt>
<dd><div class="summary">Returns whether the resource exists.</div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.release"></a><div class="quickindex" id="quickindex.Unique.release"></div>Unique <a name="release"></a><span class="ddoc_psymbol">release</span>();
<br></div></dt>
<dd><div class="summary">Transfer ownership to a <span class="d_inlinecode donthyphenate notranslate">Unique</span> rvalue. Nullifies the current contents.</div>

</dd>
<dt class="d_decl"><div ><a name=".Unique.opDot"></a><div class="quickindex" id="quickindex.Unique.opDot"></div>RefT <a name="opDot"></a><span class="ddoc_psymbol">opDot</span>();
<br></div></dt>
<dd><div class="summary">Forwards member access to contents.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".Tuple"></a><div class="quickindex" id="quickindex.Tuple"></div>struct <a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span>(Specs...);
<br></div></dt>
<dd><div class="summary"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span> of values, for example <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span>!(int, string)</span> is a record that
stores an <span class="d_inlinecode donthyphenate notranslate">int</span> and a <span class="d_inlinecode donthyphenate notranslate">string</span>. <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span> can be used to bundle
values together, notably when returning multiple values from a
function. If <span class="d_inlinecode donthyphenate notranslate">obj</span> is a <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span>, the individual members are
accessible with the syntax <span class="d_inlinecode donthyphenate notranslate">obj[0]</span> for the first field, <span class="d_inlinecode donthyphenate notranslate">obj[1]</span>
for the second, and so on.
</div>
<div class="description">The choice of zero-based indexing instead of one-base indexing was
motivated by the ability to use value <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span>s with various compile-time
loop constructs (e.g. <span class="libref"><a href="http://dlang.org/phobos/std_meta.html#AliasSeq"><span class="d_inlinecode donthyphenate notranslate">std.meta.AliasSeq</span></a></span> iteration), all of which use
zero-based indexing.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">Specs</td>
<td class="param_desc">A list of types (and optionally, member names) that the <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span> contains.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_psymbol">Tuple</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>) point;
<span class="d_comment">// assign coordinates
</span>point[0] = 5;
point[1] = 6;
<span class="d_comment">// read coordinates
</span><span class="d_keyword">auto</span> x = point[0];
<span class="d_keyword">auto</span> y = point[1];
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span> members can be named. It is legal to mix named and unnamed
    members. The method above is still applicable to all fields.
<pre class="d_code notranslate">
<span class="d_keyword">alias</span> Entry = <span class="d_psymbol">Tuple</span>!(<span class="d_keyword">int</span>, <span class="d_string">"index"</span>, string, <span class="d_string">"value"</span>);
Entry e;
e.index = 4;
e.value = <span class="d_string">"Hello"</span>;
<span class="d_keyword">assert</span>(e[1] == <span class="d_string">"Hello"</span>);
<span class="d_keyword">assert</span>(e[0] == 4);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">A <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span> with named fields is a distinct type from a <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span> with unnamed
    fields, i.e. each naming imparts a separate type for the <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span>. Two
    <span class="d_inlinecode donthyphenate notranslate"><a name="Tuple"></a><span class="ddoc_psymbol">Tuple</span></span>s differing in naming only are still distinct, even though they
    might have the same structure.
<pre class="d_code notranslate">
<span class="d_psymbol">Tuple</span>!(<span class="d_keyword">int</span>, <span class="d_string">"x"</span>, <span class="d_keyword">int</span>, <span class="d_string">"y"</span>) point1;
<span class="d_psymbol">Tuple</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>) point2;
<span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(point1) == <span class="d_keyword">typeof</span>(point2)));
</pre>
</div></div>
<dl><dt class="d_decl"><div ><a name=".Tuple.Types"></a><div class="quickindex" id="quickindex.Tuple.Types"></div>alias <a name="Types"></a><span class="ddoc_psymbol">Types</span> = staticMap!(extractType, fieldSpecs);
<br></div></dt>
<dd><div class="summary">The types of the <span class="d_inlinecode donthyphenate notranslate">Tuple</span>'s components.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> Fields = Tuple!(<span class="d_keyword">int</span>, <span class="d_string">"id"</span>, string, <span class="d_keyword">float</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Fields.<span class="d_psymbol">Types</span> == AliasSeq!(<span class="d_keyword">int</span>, string, <span class="d_keyword">float</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.fieldNames"></a><div class="quickindex" id="quickindex.Tuple.fieldNames"></div>alias <a name="fieldNames"></a><span class="ddoc_psymbol">fieldNames</span> = staticMap!(extractName, fieldSpecs);
<br></div></dt>
<dd><div class="summary">The names of the <span class="d_inlinecode donthyphenate notranslate">Tuple</span>'s components. Unnamed fields have empty names.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> Fields = Tuple!(<span class="d_keyword">int</span>, <span class="d_string">"id"</span>, string, <span class="d_keyword">float</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(Fields.<span class="d_psymbol">fieldNames</span> == AliasSeq!(<span class="d_string">"id"</span>, <span class="d_string">""</span>, <span class="d_string">""</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.expand"></a><div class="quickindex" id="quickindex.Tuple.expand"></div>Types <a name="expand"></a><span class="ddoc_psymbol">expand</span>;
<br></div></dt>
<dd><div class="summary">Use <span class="d_inlinecode donthyphenate notranslate">t.<a name="expand"></a><span class="ddoc_psymbol">expand</span></span> for a <span class="d_inlinecode donthyphenate notranslate">Tuple</span> <span class="d_inlinecode donthyphenate notranslate">t</span> to <a name="expand"></a><span class="ddoc_psymbol">expand</span> it into its
 components. The result of <span class="d_inlinecode donthyphenate notranslate"><a name="expand"></a><span class="ddoc_psymbol">expand</span></span> acts as if the <span class="d_inlinecode donthyphenate notranslate">Tuple</span>'s components
 were listed as a list of values. (Ordinarily, a <span class="d_inlinecode donthyphenate notranslate">Tuple</span> acts as a
 single value.)</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> t1 = tuple(1, <span class="d_string">" hello "</span>, 2.3);
<span class="d_keyword">assert</span>(t1.toString() == <span class="d_string">`Tuple!(int, string, double)(1, " hello ", 2.3)`</span>);

<span class="d_keyword">void</span> takeSeveralTypes(<span class="d_keyword">int</span> n, string s, <span class="d_keyword">bool</span> b)
{
    <span class="d_keyword">assert</span>(n == 4 &amp;&amp; s == <span class="d_string">"test"</span> &amp;&amp; b == <span class="d_keyword">false</span>);
}

<span class="d_keyword">auto</span> t2 = tuple(4, <span class="d_string">"test"</span>, <span class="d_keyword">false</span>);
<span class="d_comment">//t.expand acting as a list of values
</span>takeSeveralTypes(t2.<span class="d_psymbol">expand</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.this"></a><div class="quickindex" id="quickindex.Tuple.this"></div>this(Types <i>values</i>);
<br></div></dt>
<dd><div class="summary">Constructor taking one value for each field.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">Types <i>values</i></td>
<td class="param_desc">A list of <i>values</i> that are either the same
              types as those given by the <span class="d_inlinecode donthyphenate notranslate">Types</span> field
              of this <span class="d_inlinecode donthyphenate notranslate">Tuple</span>, or can implicitly convert
              to those types. They must be in the same
              order as they appear in <span class="d_inlinecode donthyphenate notranslate">Types</span>.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> ISD = Tuple!(<span class="d_keyword">int</span>, string, <span class="d_keyword">double</span>);
<span class="d_keyword">auto</span> tup = ISD(1, <span class="d_string">"test"</span>, 3.2);
<span class="d_keyword">assert</span>(tup.toString() == <span class="d_string">`Tuple!(int, string, double)(1, "test", 3.2)`</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.this.2"></a><div class="quickindex" id="quickindex.Tuple.this.2"></div>this<span class="template_param_list" title="Template parameter list">(U, size_t n)</span>(U[n] <i>values</i>)<br><span class="constraint">if (n == Types.length &amp;&amp; allSatisfy!(isBuildableFrom!U, Types))</span>;
<br></div></dt>
<dd><div class="summary">Constructor taking a compatible array.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">U[n] <i>values</i></td>
<td class="param_desc">A compatible static array to build the <span class="d_inlinecode donthyphenate notranslate">Tuple</span> from.
              Array slices are not supported.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[2] ints;
Tuple!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>) t = ints;
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.this.3"></a><div class="quickindex" id="quickindex.Tuple.this.3"></div>this<span class="template_param_list" title="Template parameter list">(U)</span>(U <i>another</i>)<br><span class="constraint">if (areBuildCompatibleTuples!(typeof(this), U))</span>;
<br></div></dt>
<dd><div class="summary">Constructor taking a compatible <span class="d_inlinecode donthyphenate notranslate">Tuple</span>. Two <span class="d_inlinecode donthyphenate notranslate">Tuple</span>s are compatible
 <b>iff</b> they are both of the same length, and, for each type <span class="d_inlinecode donthyphenate notranslate">T</span> on the
 left-hand side, the corresponding type <span class="d_inlinecode donthyphenate notranslate">U</span> on the right-hand side can
 implicitly convert to <span class="d_inlinecode donthyphenate notranslate">T</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">U <i>another</i></td>
<td class="param_desc">A compatible <span class="d_inlinecode donthyphenate notranslate">Tuple</span> to build from. Its type must be
               compatible with the target <span class="d_inlinecode donthyphenate notranslate">Tuple</span>'s type.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> IntVec = Tuple!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>, <span class="d_keyword">int</span>);
<span class="d_keyword">alias</span> DubVec = Tuple!(<span class="d_keyword">double</span>, <span class="d_keyword">double</span>, <span class="d_keyword">double</span>);

IntVec iv = tuple(1, 1, 1);

<span class="d_comment">//Ok, int can implicitly convert to double
</span>DubVec dv = iv;
<span class="d_comment">//Error: double cannot implicitly convert to int
</span><span class="d_comment">//IntVec iv2 = dv;
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.opEquals"></a><div class="quickindex" id="quickindex.Tuple.opEquals"></div>bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span><span class="template_param_list" title="Template parameter list">(R)</span>(R <i>rhs</i>)<br><span class="constraint">if (areCompatibleTuples!(typeof(this), R, "=="))</span>;
<br><br>const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span><span class="template_param_list" title="Template parameter list">(R)</span>(R <i>rhs</i>)<br><span class="constraint">if (areCompatibleTuples!(typeof(this), R, "=="))</span>;
<br></div></dt>
<dd><div class="summary">Comparison for equality. Two <span class="d_inlinecode donthyphenate notranslate">Tuple</span>s are considered equal
 <b>iff</b> they fulfill the following criteria:
</div>
<div class="description"><ul>   <li>Each <span class="d_inlinecode donthyphenate notranslate">Tuple</span> is the same length.</li>
   <li>For each type <span class="d_inlinecode donthyphenate notranslate">T</span> on the left-hand side and each type
        <span class="d_inlinecode donthyphenate notranslate">U</span> on the right-hand side, values of type <span class="d_inlinecode donthyphenate notranslate">T</span> can be
        compared with values of type <span class="d_inlinecode donthyphenate notranslate">U</span>.</li>
   <li>For each value <span class="d_inlinecode donthyphenate notranslate">v1</span> on the left-hand side and each value
        <span class="d_inlinecode donthyphenate notranslate">v2</span> on the right-hand side, the expression <span class="d_inlinecode donthyphenate notranslate">v1 == v2</span> is
        <b>true</b>.</li></ul>

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">R <i>rhs</i></td>
<td class="param_desc">The <span class="d_inlinecode donthyphenate notranslate">Tuple</span> to compare against. It must meeting the criteria
           for comparison between <span class="d_inlinecode donthyphenate notranslate">Tuple</span>s.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>true</b> if both <span class="d_inlinecode donthyphenate notranslate">Tuple</span>s are equal, otherwise <b>false</b>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
Tuple!(<span class="d_keyword">int</span>, string) t1 = tuple(1, <span class="d_string">"test"</span>);
Tuple!(<span class="d_keyword">double</span>, string) t2 =  tuple(1.0, <span class="d_string">"test"</span>);
<span class="d_comment">//Ok, int can be compared with double and
</span><span class="d_comment">//both have a value of 1
</span><span class="d_keyword">assert</span>(t1 == t2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.opCmp"></a><div class="quickindex" id="quickindex.Tuple.opCmp"></div>int <a name="opCmp"></a><span class="ddoc_psymbol">opCmp</span><span class="template_param_list" title="Template parameter list">(R)</span>(R <i>rhs</i>)<br><span class="constraint">if (areCompatibleTuples!(typeof(this), R, "&lt;"))</span>;
<br><br>const int <a name="opCmp"></a><span class="ddoc_psymbol">opCmp</span><span class="template_param_list" title="Template parameter list">(R)</span>(R <i>rhs</i>)<br><span class="constraint">if (areCompatibleTuples!(typeof(this), R, "&lt;"))</span>;
<br></div></dt>
<dd><div class="summary">Comparison for ordering.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">R <i>rhs</i></td>
<td class="param_desc">The <span class="d_inlinecode donthyphenate notranslate">Tuple</span> to compare against. It must meet the criteria
           for comparison between <span class="d_inlinecode donthyphenate notranslate">Tuple</span>s.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">For any values <span class="d_inlinecode donthyphenate notranslate">v1</span> on the right-hand side and <span class="d_inlinecode donthyphenate notranslate">v2</span> on the
 left-hand side:
<p></p>

 <ul>   <li>A negative integer if the expression <span class="d_inlinecode donthyphenate notranslate">v1 &lt; v2</span> is <b>true</b>.</li>
   <li>A positive integer if the expression <span class="d_inlinecode donthyphenate notranslate">v1 &gt; v2</span> is <b>true</b>.</li>
   <li>0 if the expression <span class="d_inlinecode donthyphenate notranslate">v1 == v2</span> is <b>true</b>.</li></ul></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">The first <span class="d_inlinecode donthyphenate notranslate">v1</span> for which <span class="d_inlinecode donthyphenate notranslate">v1 &gt; v2</span> is <b>true</b> determines
            the result. This could lead to unexpected behaviour.
<pre class="d_code notranslate">
<span class="d_keyword">auto</span> tup1 = tuple(1, 1, 1);
<span class="d_keyword">auto</span> tup2 = tuple(1, 100, 100);
<span class="d_keyword">assert</span>(tup1 &lt; tup2);

<span class="d_comment">//Only the first result matters for comparison
</span>tup1[0] = 2;
<span class="d_keyword">assert</span>(tup1 &gt; tup2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.opAssign"></a><div class="quickindex" id="quickindex.Tuple.opAssign"></div>void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span><span class="template_param_list" title="Template parameter list">(R)</span>(auto ref R <i>rhs</i>)<br><span class="constraint">if (areCompatibleTuples!(typeof(this), R, "="))</span>;
<br></div></dt>
<dd><div class="summary">Assignment from another <span class="d_inlinecode donthyphenate notranslate">Tuple</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">R <i>rhs</i></td>
<td class="param_desc">The source <span class="d_inlinecode donthyphenate notranslate">Tuple</span> to assign from. Each element of the
           source <span class="d_inlinecode donthyphenate notranslate">Tuple</span> must be implicitly assignable to each
           respective element of the target <span class="d_inlinecode donthyphenate notranslate">Tuple</span>.</td></tr>
</table></div></div>

</dd>
<dt class="d_decl"><div ><a name=".Tuple.slice"></a><div class="quickindex" id="quickindex.Tuple.slice"></div>@property ref @trusted Tuple!(sliceSpecs!(from, to)) <a name="slice"></a><span class="ddoc_psymbol">slice</span><span class="template_param_list" title="Template parameter list">(size_t from, size_t to)</span>()<br><span class="constraint">if (from &lt;= to &amp;&amp; to &lt;= Types.length)</span>;
<br></div></dt>
<dd><div class="summary">Takes a <a name="slice"></a><span class="ddoc_psymbol">slice</span> of this <span class="d_inlinecode donthyphenate notranslate">Tuple</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">from</td>
<td class="param_desc">A <span class="d_inlinecode donthyphenate notranslate">size_t</span> designating the starting position of the <a name="slice"></a><span class="ddoc_psymbol">slice</span>.</td></tr>
<tr class="param"><td class="param_id">to</td>
<td class="param_desc">A <span class="d_inlinecode donthyphenate notranslate">size_t</span> designating the ending position (exclusive) of the <a name="slice"></a><span class="ddoc_psymbol">slice</span>.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A new <span class="d_inlinecode donthyphenate notranslate">Tuple</span> that is a <a name="slice"></a><span class="ddoc_psymbol">slice</span> from <span class="d_inlinecode donthyphenate notranslate">[from, to)</span> of the original.
     It has the same types and values as the range <span class="d_inlinecode donthyphenate notranslate">[from, to)</span> in
     the original.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
Tuple!(<span class="d_keyword">int</span>, string, <span class="d_keyword">float</span>, <span class="d_keyword">double</span>) a;
a[1] = <span class="d_string">"abc"</span>;
a[2] = 4.5;
<span class="d_keyword">auto</span> s = a.<span class="d_psymbol">slice</span>!(1, 3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(s) == Tuple!(string, <span class="d_keyword">float</span>)));
<span class="d_keyword">assert</span>(s[0] == <span class="d_string">"abc"</span> &amp;&amp; s[1] == 4.5);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Tuple.toHash"></a><div class="quickindex" id="quickindex.Tuple.toHash"></div>const nothrow @trusted size_t <a name="toHash"></a><span class="ddoc_psymbol">toHash</span>();
<br></div></dt>
<dd><div class="summary">Creates a hash of this <span class="d_inlinecode donthyphenate notranslate">Tuple</span>.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A <span class="d_inlinecode donthyphenate notranslate">size_t</span> representing the hash of this <span class="d_inlinecode donthyphenate notranslate">Tuple</span>.</div></div>

</dd>
<dt class="d_decl"><div ><a name=".Tuple.toString"></a><div class="quickindex" id="quickindex.Tuple.toString"></div>template <a name="toString"></a><span class="ddoc_psymbol">toString</span>()<br></div></dt>
<dd><p></p>
<dl><dt class="d_decl"><div ><a name=".Tuple.toString.toString.toString"></a><div class="quickindex" id="quickindex.Tuple.toString.toString.toString"></div>const string <a name="toString"></a><span class="ddoc_psymbol">toString</span><span class="template_param_list" title="Template parameter list">()</span>();
<br></div></dt>
<dd><div class="summary">Converts to string.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The string representation of this <span class="d_inlinecode donthyphenate notranslate">Tuple</span>.</div></div>

</dd>
<dt class="d_decl"><div ><a name=".Tuple.toString.toString"></a><div class="quickindex" id="quickindex.Tuple.toString.toString"></div>const void <a name="toString"></a><span class="ddoc_psymbol">toString</span><span class="template_param_list" title="Template parameter list">(DG)</span>(scope DG <i>sink</i>);
<br><br>const void <a name="toString"></a><span class="ddoc_psymbol">toString</span><span class="template_param_list" title="Template parameter list">(DG, Char)</span>(scope DG <i>sink</i>, FormatSpec!Char <i>fmt</i>);
<br></div></dt>
<dd><div class="summary">Formats <span class="d_inlinecode donthyphenate notranslate">Tuple</span> with either <span class="d_inlinecode donthyphenate notranslate">%s</span>, <span class="d_inlinecode donthyphenate notranslate">%(inner%)</span> or <span class="d_inlinecode donthyphenate notranslate">%(inner%|sep%)</span>.
</div>
<div class="description"> <center><table><caption>Formats supported by Tuple</caption> <tr><th class="donthyphenate"><b>Format</b></th><th class="donthyphenate"><b>Description</b></th></tr>
 <tr><td><p><span class="d_inlinecode donthyphenate notranslate">%s</span></p></td><td><p>Format like <span class="d_inlinecode donthyphenate notranslate">Tuple!(types)(elements formatted with %s each)</span>.</p></td></tr>
 <tr><td><p><span class="d_inlinecode donthyphenate notranslate">%(inner%)</span></p></td><td><p>The format <span class="d_inlinecode donthyphenate notranslate">inner</span> is applied the expanded <span class="d_inlinecode donthyphenate notranslate">Tuple</span>, so
      it may contain as many formats as the <span class="d_inlinecode donthyphenate notranslate">Tuple</span> has fields.</p></td></tr>
 <tr><td><p><span class="d_inlinecode donthyphenate notranslate">%(inner%|sep%)</span></p></td><td><p>The format <span class="d_inlinecode donthyphenate notranslate">inner</span> is one format, that is applied
      on all fields of the <span class="d_inlinecode donthyphenate notranslate">Tuple</span>. The inner format must be compatible to all
      of them.</p></td></tr></table></center>
<pre class="d_code notranslate"> Tuple!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>)[3] tupList = [ tuple(1, 1.0), tuple(2, 4.0), tuple(3, 9.0) ];

 <span class="d_comment">// Default format
</span> <span class="d_keyword">assert</span>(format(<span class="d_string">"%s"</span>, tuple(<span class="d_string">"a"</span>, 1)) == <span class="d_string">`Tuple!(string, int)("a", 1)`</span>);

 <span class="d_comment">// One Format for each individual component
</span> <span class="d_keyword">assert</span>(format(<span class="d_string">"%(%#x v %.4f w %#x%)"</span>, tuple(1, 1.0, 10))         == <span class="d_string">`0x1 v 1.0000 w 0xa`</span>);
 <span class="d_keyword">assert</span>(format(  <span class="d_string">"%#x v %.4f w %#x"</span>  , tuple(1, 1.0, 10).expand)  == <span class="d_string">`0x1 v 1.0000 w 0xa`</span>);

 <span class="d_comment">// One Format for all components
</span> <span class="d_keyword">assert</span>(format(<span class="d_string">"%(&gt;%s&lt;%| &amp; %)"</span>, tuple(<span class="d_string">"abc"</span>, 1, 2.3, [4, 5])) == <span class="d_string">`&gt;abc&lt; &amp; &gt;1&lt; &amp; &gt;2.3&lt; &amp; &gt;[4, 5]&lt;`</span>);

 <span class="d_comment">// Array of Tuples
</span> <span class="d_keyword">assert</span>(format(<span class="d_string">"%(%(f(%d) = %.1f%);  %)"</span>, tupList) == <span class="d_string">`f(1) = 1.0;  f(2) = 4.0;  f(3) = 9.0`</span>);


 <span class="d_comment">// Error: %( %) missing.
</span> assertThrown!FormatException(
     format(<span class="d_string">"%d, %f"</span>, tuple(1, 2.0)) == <span class="d_string">`1, 2.0`</span>
 );

 <span class="d_comment">// Error: %( %| %) missing.
</span> assertThrown!FormatException(
     format(<span class="d_string">"%d"</span>, tuple(1, 2)) == <span class="d_string">`1, 2`</span>
 );

 <span class="d_comment">// Error: %d inadequate for double.
</span> assertThrown!FormatException(
     format(<span class="d_string">"%(%d%|, %)"</span>, tuple(1, 2.0)) == <span class="d_string">`1, 2.0`</span>
 );
</pre>
</div>

</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".reverse"></a><div class="quickindex" id="quickindex.reverse"></div>ReverseTupleType!T <a name="reverse"></a><span class="ddoc_psymbol">reverse</span><span class="template_param_list" title="Template parameter list">(T)</span>(T <i>t</i>)<br><span class="constraint">if (isTuple!T)</span>;
<br></div></dt>
<dd><div class="summary">Create a copy of a <span class="d_inlinecode donthyphenate notranslate">Tuple</span> with its fields in <a name="reverse"></a><span class="ddoc_psymbol">reverse</span> order.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>t</i></td>
<td class="param_desc">The <span class="d_inlinecode donthyphenate notranslate">Tuple</span> to copy.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A copy of <span class="d_inlinecode donthyphenate notranslate"><i>t</i></span> with its fields in <a name="reverse"></a><span class="ddoc_psymbol">reverse</span> order.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> tup = tuple(1, <span class="d_string">"2"</span>);
<span class="d_keyword">assert</span>(tup.<span class="d_psymbol">reverse</span> == tuple(<span class="d_string">"2"</span>, 1));
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".tuple"></a><div class="quickindex" id="quickindex.tuple"></div>template <a name="tuple"></a><span class="ddoc_psymbol">tuple</span>(Names...)<br></div></dt>
<dd><div class="summary">Constructs a <span class="d_inlinecode donthyphenate notranslate">Tuple</span> object instantiated and initialized according to
    the given arguments.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">Names</td>
<td class="param_desc">A list of strings naming each successive field of the <span class="d_inlinecode donthyphenate notranslate">Tuple</span>.
                Each name matches up with the corresponding field given by <span class="d_inlinecode donthyphenate notranslate">Args</span>.
                A name does not have to be provided for every field, but as
                the names must proceed in order, it is not possible to skip
                one field and name the next after it.</td></tr>
<tr class="param"><td class="param_id">args</td>
<td class="param_desc">Values to initialize the <span class="d_inlinecode donthyphenate notranslate">Tuple</span> with. The <span class="d_inlinecode donthyphenate notranslate">Tuple</span>'s type will
               be inferred from the types of the values given.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A new <span class="d_inlinecode donthyphenate notranslate">Tuple</span> with its type inferred from the arguments given.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> value = <span class="d_psymbol">tuple</span>(5, 6.7, <span class="d_string">"hello"</span>);
<span class="d_keyword">assert</span>(value[0] == 5);
<span class="d_keyword">assert</span>(value[1] == 6.7);
<span class="d_keyword">assert</span>(value[2] == <span class="d_string">"hello"</span>);

<span class="d_comment">// Field names can be provided.
</span><span class="d_keyword">auto</span> entry = <span class="d_psymbol">tuple</span>!(<span class="d_string">"index"</span>, <span class="d_string">"value"</span>)(4, <span class="d_string">"Hello"</span>);
<span class="d_keyword">assert</span>(entry.index == 4);
<span class="d_keyword">assert</span>(entry.value == <span class="d_string">"Hello"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".isTuple"></a><div class="quickindex" id="quickindex.isTuple"></div>enum auto <a name="isTuple"></a><span class="ddoc_psymbol">isTuple</span>(T);
<br></div></dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span> is an instance of <span class="d_inlinecode donthyphenate notranslate">std.typecons.Tuple</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T</td>
<td class="param_desc">The type to check.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>true</b> if <span class="d_inlinecode donthyphenate notranslate">T</span> is a <span class="d_inlinecode donthyphenate notranslate">Tuple</span> type, <b>false</b> otherwise.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isTuple</span>!(Tuple!()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isTuple</span>!(Tuple!(<span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isTuple</span>!(Tuple!(<span class="d_keyword">int</span>, <span class="d_keyword">real</span>, string)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isTuple</span>!(Tuple!(<span class="d_keyword">int</span>, <span class="d_string">"x"</span>, <span class="d_keyword">real</span>, <span class="d_string">"y"</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isTuple</span>!(Tuple!(<span class="d_keyword">int</span>, Tuple!(<span class="d_keyword">real</span>), string)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Rebindable"></a><div class="quickindex" id="quickindex.Rebindable"></div>template <a name="Rebindable"></a><span class="ddoc_psymbol">Rebindable</span>(T) if (is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T)<br></div></dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><a name="Rebindable"></a><span class="ddoc_psymbol">Rebindable</span>!(T)</span> is a simple, efficient wrapper that behaves just
like an object of type <span class="d_inlinecode donthyphenate notranslate">T</span>, except that you can reassign it to
refer to another object. For completeness, <span class="d_inlinecode donthyphenate notranslate"><a name="Rebindable"></a><span class="ddoc_psymbol">Rebindable</span>!(T)</span> aliases
itself away to <span class="d_inlinecode donthyphenate notranslate">T</span> if <span class="d_inlinecode donthyphenate notranslate">T</span> is a non-const object type.
</div>
<div class="description">You may want to use <span class="d_inlinecode donthyphenate notranslate"><a name="Rebindable"></a><span class="ddoc_psymbol">Rebindable</span></span> when you want to have mutable
storage referring to <span class="d_inlinecode donthyphenate notranslate">const</span> objects, for example an array of
references that must be sorted in place. <span class="d_inlinecode donthyphenate notranslate"><a name="Rebindable"></a><span class="ddoc_psymbol">Rebindable</span></span> does not
break the soundness of D's type system and does not incur any of the
risks usually associated with <span class="d_inlinecode donthyphenate notranslate">cast</span>.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T</td>
<td class="param_desc">An object, interface, array slice type, or associative array type.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Regular <span class="d_inlinecode donthyphenate notranslate">const</span> object references cannot be reassigned.
<pre class="d_code notranslate">
<span class="d_keyword">class</span> Widget { <span class="d_keyword">int</span> x; <span class="d_keyword">int</span> y() <span class="d_keyword">const</span> { <span class="d_keyword">return</span> x; } }
<span class="d_keyword">const</span> a = <span class="d_keyword">new</span> Widget;
<span class="d_comment">// Fine
</span>a.y();
<span class="d_comment">// error! can't modify const a
</span><span class="d_comment">// a.x = 5;
</span><span class="d_comment">// error! can't modify const a
</span><span class="d_comment">// a = new Widget;
</span></pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">However, <span class="d_inlinecode donthyphenate notranslate"><a name="Rebindable"></a><span class="ddoc_psymbol">Rebindable</span>!(Widget)</span> does allow reassignment,
    while otherwise behaving exactly like a <span class="d_inlinecode donthyphenate notranslate">const Widget</span>.
<pre class="d_code notranslate">
<span class="d_keyword">class</span> Widget { <span class="d_keyword">int</span> x; <span class="d_keyword">int</span> y() <span class="d_keyword">const</span> { <span class="d_keyword">return</span> x; } }
<span class="d_keyword">auto</span> a = <span class="d_psymbol">Rebindable</span>!(<span class="d_keyword">const</span> Widget)(<span class="d_keyword">new</span> Widget);
<span class="d_comment">// Fine
</span>a.y();
<span class="d_comment">// error! can't modify const a
</span><span class="d_comment">// a.x = 5;
</span><span class="d_comment">// Fine
</span>a = <span class="d_keyword">new</span> Widget;
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".rebindable"></a><div class="quickindex" id="quickindex.rebindable"></div>Rebindable!T <a name="rebindable"></a><span class="ddoc_psymbol">rebindable</span><span class="template_param_list" title="Template parameter list">(T)</span>(T <i>obj</i>)<br><span class="constraint">if (is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T)</span>;
<br></div></dt>
<dd><div class="summary">Convenience function for creating a <span class="d_inlinecode donthyphenate notranslate">Rebindable</span> using automatic type
inference.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>obj</i></td>
<td class="param_desc">A reference to an object, interface, associative array, or an array slice
          to initialize the <span class="d_inlinecode donthyphenate notranslate">Rebindable</span> with.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A newly constructed <span class="d_inlinecode donthyphenate notranslate">Rebindable</span> initialized with the given reference.</div></div>

</dd>
<dt class="d_decl"><div ><a name=".rebindable.2"></a><div class="quickindex" id="quickindex.rebindable.2"></div>Rebindable!T <a name="rebindable"></a><span class="ddoc_psymbol">rebindable</span><span class="template_param_list" title="Template parameter list">(T)</span>(Rebindable!T <i>obj</i>);
<br></div></dt>
<dd><div class="summary">This function simply returns the <span class="d_inlinecode donthyphenate notranslate">Rebindable</span> object passed in.  It's useful
in generic programming cases when a given object may be either a regular
<span class="d_inlinecode donthyphenate notranslate">class</span> or a <span class="d_inlinecode donthyphenate notranslate">Rebindable</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">Rebindable!T <i>obj</i></td>
<td class="param_desc">An instance of Rebindable!T.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><span class="d_inlinecode donthyphenate notranslate"><i>obj</i></span> without any modification.</div></div>

</dd>
<dt class="d_decl"><div ><a name=".UnqualRef"></a><div class="quickindex" id="quickindex.UnqualRef"></div>template <a name="UnqualRef"></a><span class="ddoc_psymbol">UnqualRef</span>(T) if (is(T == class) || is(T == interface))<br></div></dt>
<dd><div class="summary">Similar to <span class="d_inlinecode donthyphenate notranslate">Rebindable!(T)</span> but strips all qualifiers from the reference as
    opposed to just constness / immutability. Primary intended use case is with
    shared (having thread-local reference to shared class data)
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T</td>
<td class="param_desc">A class or interface type.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> Data {}

<span class="d_keyword">static</span> <span class="d_keyword">shared</span>(Data) a;
<span class="d_keyword">static</span> <span class="d_psymbol">UnqualRef</span>!(<span class="d_keyword">shared</span> Data) b;

<span class="d_keyword">import</span> core.thread;

<span class="d_keyword">auto</span> thread = <span class="d_keyword">new</span> core.thread.Thread({
    a = <span class="d_keyword">new</span> <span class="d_keyword">shared</span> Data();
    b = <span class="d_keyword">new</span> <span class="d_keyword">shared</span> Data();
});

thread.start();
thread.join();

<span class="d_keyword">assert</span>(a !<span class="d_keyword">is</span> <span class="d_keyword">null</span>);
<span class="d_keyword">assert</span>(b <span class="d_keyword">is</span> <span class="d_keyword">null</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".alignForSize"></a><div class="quickindex" id="quickindex.alignForSize"></div>string <a name="alignForSize"></a><span class="ddoc_psymbol">alignForSize</span><span class="template_param_list" title="Template parameter list">(E...)</span>(const char[][] <i>names</i>...);
<br></div></dt>
<dd><div class="summary">Order the provided members to minimize size while preserving alignment.
  Alignment is not always optimal for 80-bit reals, nor for structs declared
  as align(1).
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">E</td>
<td class="param_desc">A list of the types to be aligned, representing fields
          of an aggregate such as a <span class="d_inlinecode donthyphenate notranslate">struct</span> or <span class="d_inlinecode donthyphenate notranslate">class</span>.</td></tr>
<tr class="param"><td class="param_id">char[][] <i>names</i></td>
<td class="param_desc">The <i>names</i> of the fields that are to be aligned.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A string to be mixed in to an aggregate, such as a <span class="d_inlinecode donthyphenate notranslate">struct</span> or <span class="d_inlinecode donthyphenate notranslate">class</span>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> Banner {
    <span class="d_keyword">mixin</span>(<span class="d_psymbol">alignForSize</span>!(<span class="d_keyword">byte</span>[6], <span class="d_keyword">double</span>)([<span class="d_string">"name"</span>, <span class="d_string">"height"</span>]));
}
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Nullable"></a><div class="quickindex" id="quickindex.Nullable"></div>struct <a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>(T);
<br></div></dt>
<dd><div class="summary">Defines a value paired with a distinctive "<b>null</b>" state that denotes
the absence of a value. If default constructed, a <span class="d_inlinecode donthyphenate notranslate"><a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>!T</span> object starts in the <b>null</b> state. Assigning it renders it
non-<b>null</b>. Calling <span class="d_inlinecode donthyphenate notranslate">nullify</span> can nullify it again.
</div>
<div class="description">Practically <span class="d_inlinecode donthyphenate notranslate"><a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>!T</span> stores a <span class="d_inlinecode donthyphenate notranslate">T</span> and a <span class="d_inlinecode donthyphenate notranslate">bool</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> CustomerRecord
{
    string name;
    string address;
    <span class="d_keyword">int</span> customerNum;
}

<span class="d_psymbol">Nullable</span>!CustomerRecord getByName(string name)
{
    <span class="d_comment">//A bunch of hairy stuff
</span>
    <span class="d_keyword">return</span> <span class="d_psymbol">Nullable</span>!CustomerRecord.init;
}

<span class="d_keyword">auto</span> queryResult = getByName(<span class="d_string">"Doe, John"</span>);
<span class="d_keyword">if</span> (!queryResult.isNull)
{
    <span class="d_comment">//Process Mr. Doe's customer record
</span>    <span class="d_keyword">auto</span> address = queryResult.address;
    <span class="d_keyword">auto</span> customerNum = queryResult.customerNum;

    <span class="d_comment">//Do some things with this customer's info
</span>}
<span class="d_keyword">else</span>
{
    <span class="d_comment">//Add the customer to the database
</span>}
</pre>
</div></div>
<dl><dt class="d_decl"><div ><a name=".Nullable.this"></a><div class="quickindex" id="quickindex.Nullable.this"></div>inout this(inout T <i>value</i>);
<br></div></dt>
<dd><div class="summary">Constructor initializing <span class="d_inlinecode donthyphenate notranslate">this</span> with <span class="d_inlinecode donthyphenate notranslate"><i>value</i></span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>value</i></td>
<td class="param_desc">The <i>value</i> to initialize this <span class="d_inlinecode donthyphenate notranslate">Nullable</span> with.</td></tr>
</table></div></div>

</dd>
<dt class="d_decl"><div ><a name=".Nullable.isNull"></a><div class="quickindex" id="quickindex.Nullable.isNull"></div>const pure nothrow @property @safe bool <a name="isNull"></a><span class="ddoc_psymbol">isNull</span>();
<br></div></dt>
<dd><div class="summary">Check if <span class="d_inlinecode donthyphenate notranslate">this</span> is in the <b>null</b> state.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>true</b> <b>iff</b> <span class="d_inlinecode donthyphenate notranslate">this</span> is in the <b>null</b> state, otherwise <b>false</b>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
Nullable!<span class="d_keyword">int</span> ni;
<span class="d_keyword">assert</span>(ni.<span class="d_psymbol">isNull</span>);

ni = 0;
<span class="d_keyword">assert</span>(!ni.<span class="d_psymbol">isNull</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Nullable.nullify"></a><div class="quickindex" id="quickindex.Nullable.nullify"></div>void <a name="nullify"></a><span class="ddoc_psymbol">nullify</span><span class="template_param_list" title="Template parameter list">()</span>();
<br></div></dt>
<dd><div class="summary">Forces <span class="d_inlinecode donthyphenate notranslate">this</span> to the <b>null</b> state.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
Nullable!<span class="d_keyword">int</span> ni = 0;
<span class="d_keyword">assert</span>(!ni.isNull);

ni.<span class="d_psymbol">nullify</span>();
<span class="d_keyword">assert</span>(ni.isNull);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Nullable.opAssign"></a><div class="quickindex" id="quickindex.Nullable.opAssign"></div>void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span><span class="template_param_list" title="Template parameter list">()</span>(T <i>value</i>);
<br></div></dt>
<dd><div class="summary">Assigns <span class="d_inlinecode donthyphenate notranslate"><i>value</i></span> to the internally-held state. If the assignment
succeeds, <span class="d_inlinecode donthyphenate notranslate">this</span> becomes non-<b>null</b>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>value</i></td>
<td class="param_desc">A <i>value</i> of type <span class="d_inlinecode donthyphenate notranslate">T</span> to assign to this <span class="d_inlinecode donthyphenate notranslate">Nullable</span>.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">If this <span class="d_inlinecode donthyphenate notranslate">Nullable</span> wraps a type that already has a <b>null</b> <i>value</i>
    (such as a pointer), then assigning the <b>null</b> <i>value</i> to this
    <span class="d_inlinecode donthyphenate notranslate">Nullable</span> is no different than assigning any other <i>value</i> of
    type <span class="d_inlinecode donthyphenate notranslate">T</span>, and the resulting code will look very strange. It
    is strongly recommended that this be avoided by instead using
    the version of <span class="d_inlinecode donthyphenate notranslate">Nullable</span> that takes an additional <span class="d_inlinecode donthyphenate notranslate">nullValue</span>
    template argument.
<pre class="d_code notranslate">
<span class="d_comment">//Passes
</span>Nullable!(<span class="d_keyword">int</span>*) npi;
<span class="d_keyword">assert</span>(npi.isNull);

<span class="d_comment">//Passes?!
</span>npi = <span class="d_keyword">null</span>;
<span class="d_keyword">assert</span>(!npi.isNull);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Nullable.get"></a><div class="quickindex" id="quickindex.Nullable.get"></div>inout pure nothrow @property ref @safe inout(T) <a name="get"></a><span class="ddoc_psymbol">get</span>();
<br></div></dt>
<dd><div class="summary">Gets the value. <span class="d_inlinecode donthyphenate notranslate">this</span> must not be in the <b>null</b> state.
This function is also called for the implicit conversion to <span class="d_inlinecode donthyphenate notranslate">T</span>.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The value held internally by this <span class="d_inlinecode donthyphenate notranslate">Nullable</span>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.exception: assertThrown, assertNotThrown;

Nullable!<span class="d_keyword">int</span> ni;
<span class="d_comment">//`get` is implicitly called. Will throw
</span><span class="d_comment">//an AssertError in non-release mode
</span>assertThrown!Throwable(ni == 0);

ni = 0;
assertNotThrown!Throwable(ni == 0);
</pre>
</div></div>
</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".Nullable.2"></a><div class="quickindex" id="quickindex.Nullable.2"></div>struct <a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>(T, T nullValue);
<br></div></dt>
<dd><div class="summary">Just like <span class="d_inlinecode donthyphenate notranslate"><a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>!T</span>, except that the <b>null</b> state is defined as a
particular value. For example, <span class="d_inlinecode donthyphenate notranslate"><a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>!(uint, uint.max)</span> is an
<span class="d_inlinecode donthyphenate notranslate">uint</span> that sets aside the value <span class="d_inlinecode donthyphenate notranslate">uint.max</span> to denote a <b>null</b>
state. <span class="d_inlinecode donthyphenate notranslate"><a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>!(T, nullValue)</span> is more storage-efficient than <span class="d_inlinecode donthyphenate notranslate"><a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span>!T</span> because it does not need to store an extra <span class="d_inlinecode donthyphenate notranslate">bool</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T</td>
<td class="param_desc">The wrapped type for which <a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span> provides a <b>null</b> value.</td></tr>
<tr class="param"><td class="param_id">nullValue</td>
<td class="param_desc">The <b>null</b> value which denotes the <b>null</b> state of this
                <span class="d_inlinecode donthyphenate notranslate"><a name="Nullable"></a><span class="ddoc_psymbol">Nullable</span></span>. Must be of type <span class="d_inlinecode donthyphenate notranslate">T</span>.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_psymbol">Nullable</span>!(size_t, size_t.max) indexOf(string[] haystack, string needle)
{
    <span class="d_comment">//Find the needle, returning -1 if not found
</span>
    <span class="d_keyword">return</span> <span class="d_psymbol">Nullable</span>!(size_t, size_t.max).init;
}

<span class="d_keyword">void</span> sendLunchInvite(string name)
{
}

<span class="d_comment">//It's safer than C...
</span><span class="d_keyword">auto</span> coworkers = [<span class="d_string">"Jane"</span>, <span class="d_string">"Jim"</span>, <span class="d_string">"Marry"</span>, <span class="d_string">"Fred"</span>];
<span class="d_keyword">auto</span> pos = indexOf(coworkers, <span class="d_string">"Bob"</span>);
<span class="d_keyword">if</span> (!pos.isNull)
{
    <span class="d_comment">//Send Bob an invitation to lunch
</span>    sendLunchInvite(coworkers[pos]);
}
<span class="d_keyword">else</span>
{
    <span class="d_comment">//Bob not found; report the error
</span>}

<span class="d_comment">//And there's no overhead
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">Nullable</span>!(size_t, size_t.max).sizeof == size_t.sizeof);
</pre>
</div></div>
<dl><dt class="d_decl"><div ><a name=".Nullable.this.2"></a><div class="quickindex" id="quickindex.Nullable.this.2"></div>this(T <i>value</i>);
<br></div></dt>
<dd><div class="summary">Constructor initializing <span class="d_inlinecode donthyphenate notranslate">this</span> with <span class="d_inlinecode donthyphenate notranslate"><i>value</i></span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>value</i></td>
<td class="param_desc">The <i>value</i> to initialize this <span class="d_inlinecode donthyphenate notranslate">Nullable</span> with.</td></tr>
</table></div></div>

</dd>
<dt class="d_decl"><div ><a name=".Nullable.isNull.2"></a><div class="quickindex" id="quickindex.Nullable.isNull.2"></div>const @property bool <a name="isNull"></a><span class="ddoc_psymbol">isNull</span>();
<br></div></dt>
<dd><div class="summary">Check if <span class="d_inlinecode donthyphenate notranslate">this</span> is in the <b>null</b> state.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>true</b> <b>iff</b> <span class="d_inlinecode donthyphenate notranslate">this</span> is in the <b>null</b> state, otherwise <b>false</b>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
Nullable!(<span class="d_keyword">int</span>, -1) ni;
<span class="d_comment">//Initialized to "null" state
</span><span class="d_keyword">assert</span>(ni.<span class="d_psymbol">isNull</span>);

ni = 0;
<span class="d_keyword">assert</span>(!ni.<span class="d_psymbol">isNull</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Nullable.nullify.2"></a><div class="quickindex" id="quickindex.Nullable.nullify.2"></div>void <a name="nullify"></a><span class="ddoc_psymbol">nullify</span><span class="template_param_list" title="Template parameter list">()</span>();
<br></div></dt>
<dd><div class="summary">Forces <span class="d_inlinecode donthyphenate notranslate">this</span> to the <b>null</b> state.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
Nullable!(<span class="d_keyword">int</span>, -1) ni = 0;
<span class="d_keyword">assert</span>(!ni.isNull);

ni = -1;
<span class="d_keyword">assert</span>(ni.isNull);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Nullable.opAssign.2"></a><div class="quickindex" id="quickindex.Nullable.opAssign.2"></div>void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span><span class="template_param_list" title="Template parameter list">()</span>(T <i>value</i>);
<br></div></dt>
<dd><div class="summary">Assigns <span class="d_inlinecode donthyphenate notranslate"><i>value</i></span> to the internally-held state. If the assignment
succeeds, <span class="d_inlinecode donthyphenate notranslate">this</span> becomes non-<b>null</b>. No <b>null</b> checks are made. Note
that the assignment may leave <span class="d_inlinecode donthyphenate notranslate">this</span> in the <b>null</b> state.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>value</i></td>
<td class="param_desc">A <i>value</i> of type <span class="d_inlinecode donthyphenate notranslate">T</span> to assign to this <span class="d_inlinecode donthyphenate notranslate">Nullable</span>.
            If it is <span class="d_inlinecode donthyphenate notranslate">nullvalue</span>, then the internal state of
            this <span class="d_inlinecode donthyphenate notranslate">Nullable</span> will be set to <b>null</b>.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">If this <span class="d_inlinecode donthyphenate notranslate">Nullable</span> wraps a type that already has a <b>null</b> <i>value</i>
    (such as a pointer), and that <b>null</b> <i>value</i> is not given for
    <span class="d_inlinecode donthyphenate notranslate">nullValue</span>, then assigning the <b>null</b> <i>value</i> to this <span class="d_inlinecode donthyphenate notranslate">Nullable</span>
    is no different than assigning any other <i>value</i> of type <span class="d_inlinecode donthyphenate notranslate">T</span>,
    and the resulting code will look very strange. It is strongly
    recommended that this be avoided by using <span class="d_inlinecode donthyphenate notranslate">T</span>'s "built in"
    <b>null</b> <i>value</i> for <span class="d_inlinecode donthyphenate notranslate">nullValue</span>.
<pre class="d_code notranslate">
<span class="d_comment">//Passes
</span><span class="d_keyword">enum</span> nullVal = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)0xCAFEBABE;
Nullable!(<span class="d_keyword">int</span>*, nullVal) npi;
<span class="d_keyword">assert</span>(npi.isNull);

<span class="d_comment">//Passes?!
</span>npi = <span class="d_keyword">null</span>;
<span class="d_keyword">assert</span>(!npi.isNull);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Nullable.get.2"></a><div class="quickindex" id="quickindex.Nullable.get.2"></div>inout @property ref inout(T) <a name="get"></a><span class="ddoc_psymbol">get</span>();
<br></div></dt>
<dd><div class="summary">Gets the value. <span class="d_inlinecode donthyphenate notranslate">this</span> must not be in the <b>null</b> state.
This function is also called for the implicit conversion to <span class="d_inlinecode donthyphenate notranslate">T</span>.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The value held internally by this <span class="d_inlinecode donthyphenate notranslate">Nullable</span>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.exception: assertThrown, assertNotThrown;

Nullable!(<span class="d_keyword">int</span>, -1) ni;
<span class="d_comment">//`get` is implicitly called. Will throw
</span><span class="d_comment">//an error in non-release mode
</span>assertThrown!Throwable(ni == 0);

ni = 0;
assertNotThrown!Throwable(ni == 0);
</pre>
</div></div>
</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".NullableRef"></a><div class="quickindex" id="quickindex.NullableRef"></div>struct <a name="NullableRef"></a><span class="ddoc_psymbol">NullableRef</span>(T);
<br></div></dt>
<dd><div class="summary">Just like <span class="d_inlinecode donthyphenate notranslate">Nullable!T</span>, except that the object refers to a value
sitting elsewhere in memory. This makes assignments overwrite the
initially assigned value. Internally <span class="d_inlinecode donthyphenate notranslate"><a name="NullableRef"></a><span class="ddoc_psymbol">NullableRef</span>!T</span> only stores a
pointer to <span class="d_inlinecode donthyphenate notranslate">T</span> (i.e., <span class="d_inlinecode donthyphenate notranslate">Nullable!T.sizeof == (T*).sizeof</span>).</div>

<dl><dt class="d_decl"><div ><a name=".NullableRef.this"></a><div class="quickindex" id="quickindex.NullableRef.this"></div>pure nothrow @safe this(T* <i>value</i>);
<br></div></dt>
<dd><div class="summary">Constructor binding <span class="d_inlinecode donthyphenate notranslate">this</span> to <span class="d_inlinecode donthyphenate notranslate"><i>value</i></span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T* <i>value</i></td>
<td class="param_desc">The <i>value</i> to bind to.</td></tr>
</table></div></div>

</dd>
<dt class="d_decl"><div ><a name=".NullableRef.bind"></a><div class="quickindex" id="quickindex.NullableRef.bind"></div>pure nothrow @safe void <a name="bind"></a><span class="ddoc_psymbol">bind</span>(T* <i>value</i>);
<br></div></dt>
<dd><div class="summary">Binds the internal state to <span class="d_inlinecode donthyphenate notranslate"><i>value</i></span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T* <i>value</i></td>
<td class="param_desc">A pointer to a <i>value</i> of type <span class="d_inlinecode donthyphenate notranslate">T</span> to <a name="bind"></a><span class="ddoc_psymbol">bind</span> this <span class="d_inlinecode donthyphenate notranslate">NullableRef</span> to.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
NullableRef!<span class="d_keyword">int</span> nr = <span class="d_keyword">new</span> <span class="d_keyword">int</span>(42);
<span class="d_keyword">assert</span>(nr == 42);

<span class="d_keyword">int</span>* n = <span class="d_keyword">new</span> <span class="d_keyword">int</span>(1);
nr.<span class="d_psymbol">bind</span>(n);
<span class="d_keyword">assert</span>(nr == 1);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".NullableRef.isNull"></a><div class="quickindex" id="quickindex.NullableRef.isNull"></div>const pure nothrow @property @safe bool <a name="isNull"></a><span class="ddoc_psymbol">isNull</span>();
<br></div></dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">this</span> is in the <b>null</b> state.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>true</b> if <span class="d_inlinecode donthyphenate notranslate">this</span> is in the <b>null</b> state, otherwise <b>false</b>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
NullableRef!<span class="d_keyword">int</span> nr;
<span class="d_keyword">assert</span>(nr.<span class="d_psymbol">isNull</span>);

<span class="d_keyword">int</span>* n = <span class="d_keyword">new</span> <span class="d_keyword">int</span>(42);
nr.bind(n);
<span class="d_keyword">assert</span>(!nr.<span class="d_psymbol">isNull</span> &amp;&amp; nr == 42);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".NullableRef.nullify"></a><div class="quickindex" id="quickindex.NullableRef.nullify"></div>pure nothrow @safe void <a name="nullify"></a><span class="ddoc_psymbol">nullify</span>();
<br></div></dt>
<dd><div class="summary">Forces <span class="d_inlinecode donthyphenate notranslate">this</span> to the <b>null</b> state.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
NullableRef!<span class="d_keyword">int</span> nr = <span class="d_keyword">new</span> <span class="d_keyword">int</span>(42);
<span class="d_keyword">assert</span>(!nr.isNull);

nr.<span class="d_psymbol">nullify</span>();
<span class="d_keyword">assert</span>(nr.isNull);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".NullableRef.opAssign"></a><div class="quickindex" id="quickindex.NullableRef.opAssign"></div>void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span><span class="template_param_list" title="Template parameter list">()</span>(T <i>value</i>)<br><span class="constraint">if (isAssignable!T)</span>;
<br></div></dt>
<dd><div class="summary">Assigns <span class="d_inlinecode donthyphenate notranslate"><i>value</i></span> to the internally-held state.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>value</i></td>
<td class="param_desc">A <i>value</i> of type <span class="d_inlinecode donthyphenate notranslate">T</span> to assign to this <span class="d_inlinecode donthyphenate notranslate">NullableRef</span>.
            If the internal state of this <span class="d_inlinecode donthyphenate notranslate">NullableRef</span> has not
            been initialized, an error will be thrown in
            non-release mode.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.exception: assertThrown, assertNotThrown;

NullableRef!<span class="d_keyword">int</span> nr;
<span class="d_keyword">assert</span>(nr.isNull);
assertThrown!Throwable(nr = 42);

nr.bind(<span class="d_keyword">new</span> <span class="d_keyword">int</span>(0));
<span class="d_keyword">assert</span>(!nr.isNull);
assertNotThrown!Throwable(nr = 42);
<span class="d_keyword">assert</span>(nr == 42);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".NullableRef.get"></a><div class="quickindex" id="quickindex.NullableRef.get"></div>inout pure nothrow @property ref @safe inout(T) <a name="get"></a><span class="ddoc_psymbol">get</span>();
<br></div></dt>
<dd><div class="summary">Gets the value. <span class="d_inlinecode donthyphenate notranslate">this</span> must not be in the <b>null</b> state.
This function is also called for the implicit conversion to <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.exception: assertThrown, assertNotThrown;

NullableRef!<span class="d_keyword">int</span> nr;
<span class="d_comment">//`get` is implicitly called. Will throw
</span><span class="d_comment">//an error in non-release mode
</span>assertThrown!Throwable(nr == 0);

nr.bind(<span class="d_keyword">new</span> <span class="d_keyword">int</span>(0));
assertNotThrown!Throwable(nr == 0);
</pre>
</div></div>
</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".BlackHole"></a><div class="quickindex" id="quickindex.BlackHole"></div>template <a name="BlackHole"></a><span class="ddoc_psymbol">BlackHole</span>(Base)<br></div></dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><a name="BlackHole"></a><span class="ddoc_psymbol">BlackHole</span>!Base</span> is a subclass of <span class="d_inlinecode donthyphenate notranslate">Base</span> which automatically implements
all abstract member functions in <span class="d_inlinecode donthyphenate notranslate">Base</span> as do-nothing functions.  Each
auto-implemented function just returns the default value of the return type
without doing anything.
</div>
<div class="description">The name came from
<a href="http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm">Class::BlackHole</a>
Perl module by Sean M. Burke.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">Base</td>
<td class="param_desc">A non-final class for <span class="d_inlinecode donthyphenate notranslate"><a name="BlackHole"></a><span class="ddoc_psymbol">BlackHole</span></span> to inherit from.</td></tr>
</table></div></div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#AutoImplement"><span class="d_inlinecode donthyphenate notranslate">AutoImplement</span></a>, <a href="#generateEmptyFunction"><span class="d_inlinecode donthyphenate notranslate">generateEmptyFunction</span></a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.math: isNaN;

<span class="d_keyword">static</span> <span class="d_keyword">abstract</span> <span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> m_value;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> v) { m_value = v; }
    <span class="d_keyword">int</span> value() @property { <span class="d_keyword">return</span> m_value; }

    <span class="d_keyword">abstract</span> <span class="d_keyword">real</span> realValue() @property;
    <span class="d_keyword">abstract</span> <span class="d_keyword">void</span> doSomething();
}

<span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> <span class="d_psymbol">BlackHole</span>!C(42);
<span class="d_keyword">assert</span>(c.value == 42);

<span class="d_comment">// Returns real.init which is NaN
</span><span class="d_keyword">assert</span>(c.realValue.isNaN);
<span class="d_comment">// Abstract functions are implemented as do-nothing
</span>c.doSomething();
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".WhiteHole"></a><div class="quickindex" id="quickindex.WhiteHole"></div>template <a name="WhiteHole"></a><span class="ddoc_psymbol">WhiteHole</span>(Base)<br></div></dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><a name="WhiteHole"></a><span class="ddoc_psymbol">WhiteHole</span>!Base</span> is a subclass of <span class="d_inlinecode donthyphenate notranslate">Base</span> which automatically implements
all abstract member functions as functions that always fail. These functions
simply throw an <span class="d_inlinecode donthyphenate notranslate">Error</span> and never return. <span class="d_inlinecode donthyphenate notranslate">Whitehole</span> is useful for
trapping the use of class member functions that haven't been implemented.
</div>
<div class="description">The name came from
<a href="http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm">Class::WhiteHole</a>
Perl module by Michael G Schwern.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">Base</td>
<td class="param_desc">A non-final class for <span class="d_inlinecode donthyphenate notranslate"><a name="WhiteHole"></a><span class="ddoc_psymbol">WhiteHole</span></span> to inherit from.</td></tr>
</table></div></div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#AutoImplement"><span class="d_inlinecode donthyphenate notranslate">AutoImplement</span></a>, <a href="#generateAssertTrap"><span class="d_inlinecode donthyphenate notranslate">generateAssertTrap</span></a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.exception: assertThrown;

<span class="d_keyword">static</span> <span class="d_keyword">class</span> C
{
    <span class="d_keyword">abstract</span> <span class="d_keyword">void</span> notYetImplemented();
}

<span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> <span class="d_psymbol">WhiteHole</span>!C;
assertThrown!NotImplementedError(c.notYetImplemented()); <span class="d_comment">// throws an Error
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".AutoImplement"></a><div class="quickindex" id="quickindex.AutoImplement"></div>class <a name="AutoImplement"></a><span class="ddoc_psymbol">AutoImplement</span>(Base, alias how, alias what = isAbstractFunction): Base;
<br></div></dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><a name="AutoImplement"></a><span class="ddoc_psymbol">AutoImplement</span></span> automatically implements (by default) all abstract member
functions in the class or interface <span class="d_inlinecode donthyphenate notranslate">Base</span> in specified way.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">how</td>
<td class="param_desc">template which specifies how functions will be implemented/overridden.
<p></p>

         Two arguments are passed to <span class="d_inlinecode donthyphenate notranslate">how</span>: the type <span class="d_inlinecode donthyphenate notranslate">Base</span> and an alias
         to an implemented function.  Then <span class="d_inlinecode donthyphenate notranslate">how</span> must return an implemented
         function body as a string.
<p></p>

         The generated function body can use these keywords:
         <ul>            <li><span class="d_inlinecode donthyphenate notranslate">a0</span>, <span class="d_inlinecode donthyphenate notranslate">a1</span>, &hellip;: arguments passed to the function;</li>
            <li><span class="d_inlinecode donthyphenate notranslate">args</span>: a tuple of the arguments;</li>
            <li><span class="d_inlinecode donthyphenate notranslate">self</span>: an alias to the function itself;</li>
            <li><span class="d_inlinecode donthyphenate notranslate">parent</span>: an alias to the overridden function (if any).</li>
         </ul>
<p></p>

        You may want to use templated property functions (instead of Implicit
        Template Properties) to generate complex functions:
<pre class="d_code notranslate"><span class="d_comment">// Prints log messages for each call to overridden functions.
</span>string generateLogger(C, <span class="d_keyword">alias</span> fun)() @property
{
    <span class="d_keyword">import</span> std.traits;
    <span class="d_keyword">enum</span> qname = C.stringof ~ <span class="d_string">"."</span> ~ <span class="d_keyword">__traits</span>(identifier, fun);
    string stmt;

    stmt ~= <span class="d_string">q{ struct Importer { import std.stdio; } }</span>;
    stmt ~= <span class="d_string">`Importer.writeln("Log: `</span> ~ qname ~ <span class="d_string">`(", args, ")");`</span>;
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (!<span class="d_keyword">__traits</span>(isAbstractFunction, fun))
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(ReturnType!fun == <span class="d_keyword">void</span>))
            stmt ~= <span class="d_string">q{ parent(args); }</span>;
        <span class="d_keyword">else</span>
            stmt ~= <span class="d_string">q{
                auto r = parent(args);
                Importer.writeln("--&gt; ", r);
                return r;
            }</span>;
    }
    <span class="d_keyword">return</span> stmt;
}
</pre>
</td></tr>
<tr class="param"><td class="param_id">what</td>
<td class="param_desc">template which determines what functions should be
         implemented/overridden.
<p></p>

         An argument is passed to <span class="d_inlinecode donthyphenate notranslate">what</span>: an alias to a non-final member
         function in <span class="d_inlinecode donthyphenate notranslate">Base</span>.  Then <span class="d_inlinecode donthyphenate notranslate">what</span> must return a boolean value.
         Return <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> to indicate that the passed function should be
         implemented/overridden.
<p></p>

<pre class="d_code notranslate"><span class="d_comment">// Sees if fun returns something.
</span><span class="d_keyword">enum</span> <span class="d_keyword">bool</span> hasValue(<span class="d_keyword">alias</span> fun) = !<span class="d_keyword">is</span>(ReturnType!(fun) == <span class="d_keyword">void</span>);
</pre>
</td></tr>
</table></div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Generated code is inserted in the scope of <span class="d_inlinecode donthyphenate notranslate">std.typecons</span> module.  Thus,
any useful functions outside <span class="d_inlinecode donthyphenate notranslate">std.typecons</span> cannot be used in the generated
code.  To workaround this problem, you may <span class="d_inlinecode donthyphenate notranslate">import</span> necessary things in a
local struct, as done in the <span class="d_inlinecode donthyphenate notranslate">generateLogger()</span> template in the above
example.
<p></p>


</p></div>
<div class="keyval Bugs"><span class="key keyBugs">Bugs:</span> <div class="val valBugs"><ul> <li>Variadic arguments to constructors are not forwarded to super.</li>
 <li>Deep interface inheritance causes compile error with messages like
      "Error: function std.typecons.AutoImplement!(Foo).AutoImplement.bar
      does not override any function".  [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=2525">Bugzilla 2525</a></span>, <span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=3525">Bugzilla 3525</a></span>] </li>
 <li>The <span class="d_inlinecode donthyphenate notranslate">parent</span> keyword is actually a delegate to the super class'
      corresponding member function.  [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=2540">Bugzilla 2540</a></span>] </li>
 <li>Using alias template parameter in <span class="d_inlinecode donthyphenate notranslate">how</span> and/or <span class="d_inlinecode donthyphenate notranslate">what</span> may cause
     strange compile error.  Use template tuple parameter instead to workaround
     this problem.  [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=4217">Bugzilla 4217</a></span>] </li>
</ul></div></div>

</dd>
<dt class="d_decl"><div ><a name=".generateEmptyFunction"></a><div class="quickindex" id="quickindex.generateEmptyFunction"></div>template <a name="generateEmptyFunction"></a><span class="ddoc_psymbol">generateEmptyFunction</span>(C, func...)<br><br><a name=".generateAssertTrap"></a><div class="quickindex" id="quickindex.generateAssertTrap"></div>enum string <a name="generateAssertTrap"></a><span class="ddoc_psymbol">generateAssertTrap</span>(C, func...);
<br></div></dt>
<dd><div class="summary">Predefined how-policies for <span class="d_inlinecode donthyphenate notranslate">AutoImplement</span>.  These templates are also used by
<span class="d_inlinecode donthyphenate notranslate">BlackHole</span> and <span class="d_inlinecode donthyphenate notranslate">WhiteHole</span>, respectively.</div>

</dd>
<dt class="d_decl"><div ><a name=".wrap"></a><div class="quickindex" id="quickindex.wrap"></div>template <a name="wrap"></a><span class="ddoc_psymbol">wrap</span>(Targets...) if (Targets.length &gt;= 1 &amp;&amp; allSatisfy!(isMutable, Targets))<br><br>template <a name="wrap"></a><span class="ddoc_psymbol">wrap</span>(Targets...) if (Targets.length &gt;= 1 &amp;&amp; !allSatisfy!(isMutable, Targets))<br></div></dt>
<dd><div class="summary">Supports structural based typesafe conversion.
</div>
<div class="description">If <span class="d_inlinecode donthyphenate notranslate">Source</span> has structural conformance with the <span class="d_inlinecode donthyphenate notranslate">interface</span> <span class="d_inlinecode donthyphenate notranslate">Targets</span>,
 <a name="wrap"></a><span class="ddoc_psymbol">wrap</span> creates internal wrapper class which inherits <span class="d_inlinecode donthyphenate notranslate">Targets</span> and
 <a name="wrap"></a><span class="ddoc_psymbol">wrap</span> <span class="d_inlinecode donthyphenate notranslate">src</span> object, then return it.</div>

</dd>
<dt class="d_decl"><div ><a name=".unwrap"></a><div class="quickindex" id="quickindex.unwrap"></div>template <a name="unwrap"></a><span class="ddoc_psymbol">unwrap</span>(Target) if (isMutable!Target)<br><br>template <a name="unwrap"></a><span class="ddoc_psymbol">unwrap</span>(Target) if (!isMutable!Target)<br></div></dt>
<dd><div class="summary">Extract object which wrapped by <span class="d_inlinecode donthyphenate notranslate">wrap</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> Quack
{
    <span class="d_keyword">int</span> quack();
    @property <span class="d_keyword">int</span> height();
}
<span class="d_keyword">interface</span> Flyer
{
    @property <span class="d_keyword">int</span> height();
}
<span class="d_keyword">class</span> Duck : Quack
{
    <span class="d_keyword">int</span> quack() { <span class="d_keyword">return</span> 1; }
    @property <span class="d_keyword">int</span> height() { <span class="d_keyword">return</span> 10; }
}
<span class="d_keyword">class</span> Human
{
    <span class="d_keyword">int</span> quack() { <span class="d_keyword">return</span> 2; }
    @property <span class="d_keyword">int</span> height() { <span class="d_keyword">return</span> 20; }
}

Duck d1 = <span class="d_keyword">new</span> Duck();
Human h1 = <span class="d_keyword">new</span> Human();

<span class="d_keyword">interface</span> Refleshable
{
    <span class="d_keyword">int</span> reflesh();
}
<span class="d_comment">// does not have structural conformance
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, d1.wrap!Refleshable));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, h1.wrap!Refleshable));

<span class="d_comment">// strict upcast
</span>Quack qd = d1.wrap!Quack;
<span class="d_keyword">assert</span>(qd <span class="d_keyword">is</span> d1);
<span class="d_keyword">assert</span>(qd.quack() == 1);    <span class="d_comment">// calls Duck.quack
</span><span class="d_comment">// strict downcast
</span>Duck d2 = qd.<span class="d_psymbol">unwrap</span>!Duck;
<span class="d_keyword">assert</span>(d2 <span class="d_keyword">is</span> d1);

<span class="d_comment">// structural upcast
</span>Quack qh = h1.wrap!Quack;
<span class="d_keyword">assert</span>(qh.quack() == 2);    <span class="d_comment">// calls Human.quack
</span><span class="d_comment">// structural downcast
</span>Human h2 = qh.<span class="d_psymbol">unwrap</span>!Human;
<span class="d_keyword">assert</span>(h2 <span class="d_keyword">is</span> h1);

<span class="d_comment">// structural upcast (two steps)
</span>Quack qx = h1.wrap!Quack;   <span class="d_comment">// Human -&gt; Quack
</span>Flyer fx = qx.wrap!Flyer;   <span class="d_comment">// Quack -&gt; Flyer
</span><span class="d_keyword">assert</span>(fx.height == 20);    <span class="d_comment">// calls Human.height
</span><span class="d_comment">// strucural downcast (two steps)
</span>Quack qy = fx.<span class="d_psymbol">unwrap</span>!Quack; <span class="d_comment">// Flyer -&gt; Quack
</span>Human hy = qy.<span class="d_psymbol">unwrap</span>!Human; <span class="d_comment">// Quack -&gt; Human
</span><span class="d_keyword">assert</span>(hy <span class="d_keyword">is</span> h1);
<span class="d_comment">// strucural downcast (one step)
</span>Human hz = fx.<span class="d_psymbol">unwrap</span>!Human; <span class="d_comment">// Flyer -&gt; Human
</span><span class="d_keyword">assert</span>(hz <span class="d_keyword">is</span> h1);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> A { <span class="d_keyword">int</span> run(); }
<span class="d_keyword">interface</span> B { <span class="d_keyword">int</span> stop(); @property <span class="d_keyword">int</span> status(); }
<span class="d_keyword">class</span> X
{
    <span class="d_keyword">int</span> run() { <span class="d_keyword">return</span> 1; }
    <span class="d_keyword">int</span> stop() { <span class="d_keyword">return</span> 2; }
    @property <span class="d_keyword">int</span> status() { <span class="d_keyword">return</span> 3; }
}

<span class="d_keyword">auto</span> x = <span class="d_keyword">new</span> X();
<span class="d_keyword">auto</span> ab = x.wrap!(A, B);
A a = ab;
B b = ab;
<span class="d_keyword">assert</span>(a.run() == 1);
<span class="d_keyword">assert</span>(b.stop() == 2);
<span class="d_keyword">assert</span>(b.status == 3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(functionAttributes!(<span class="d_keyword">typeof</span>(ab).status) &amp; FunctionAttribute.property);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".RefCountedAutoInitialize"></a><div class="quickindex" id="quickindex.RefCountedAutoInitialize"></div>enum <a name="RefCountedAutoInitialize"></a><span class="ddoc_psymbol">RefCountedAutoInitialize</span>: int;
<br></div></dt>
<dd><div class="summary">Options regarding auto-initialization of a <span class="d_inlinecode donthyphenate notranslate">RefCounted</span> object (see
the definition of <span class="d_inlinecode donthyphenate notranslate">RefCounted</span> below).</div>

<dl><dt class="d_decl"><div ><a name=".RefCountedAutoInitialize.no"></a><div class="quickindex" id="quickindex.RefCountedAutoInitialize.no"></div><a name="no"></a><span class="ddoc_psymbol">no</span><br></div></dt>
<dd><div class="summary">Do not auto-initialize the object</div>

</dd>
<dt class="d_decl"><div ><a name=".RefCountedAutoInitialize.yes"></a><div class="quickindex" id="quickindex.RefCountedAutoInitialize.yes"></div><a name="yes"></a><span class="ddoc_psymbol">yes</span><br></div></dt>
<dd><div class="summary">Auto-initialize the object</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".RefCounted"></a><div class="quickindex" id="quickindex.RefCounted"></div>struct <a name="RefCounted"></a><span class="ddoc_psymbol">RefCounted</span>(T, RefCountedAutoInitialize autoInit = RefCountedAutoInitialize.yes) if (!is(T == class) &amp;&amp; !is(T == interface));
<br></div></dt>
<dd><div class="summary">Defines a reference-counted object containing a <span class="d_inlinecode donthyphenate notranslate">T</span> value as
payload. <span class="d_inlinecode donthyphenate notranslate"><a name="RefCounted"></a><span class="ddoc_psymbol">RefCounted</span></span> keeps track of all references of an object,
and when the reference count goes down to zero, frees the underlying
store. <span class="d_inlinecode donthyphenate notranslate"><a name="RefCounted"></a><span class="ddoc_psymbol">RefCounted</span></span> uses <span class="d_inlinecode donthyphenate notranslate">malloc</span> and <span class="d_inlinecode donthyphenate notranslate">free</span> for operation.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="RefCounted"></a><span class="ddoc_psymbol">RefCounted</span></span> is unsafe and should be used with care. No references
to the payload should be escaped outside the <span class="d_inlinecode donthyphenate notranslate"><a name="RefCounted"></a><span class="ddoc_psymbol">RefCounted</span></span> object.
<p></p>

The <span class="d_inlinecode donthyphenate notranslate">autoInit</span> option makes the object ensure the store is
automatically initialized. Leaving <span class="d_inlinecode donthyphenate notranslate">autoInit ==
RefCountedAutoInitialize.yes</span> (the default option) is convenient but
has the cost of a test whenever the payload is accessed. If <span class="d_inlinecode donthyphenate notranslate">autoInit == RefCountedAutoInitialize.no</span>, user code must call either
<span class="d_inlinecode donthyphenate notranslate">refCountedStore.isInitialized</span> or <span class="d_inlinecode donthyphenate notranslate">refCountedStore.ensureInitialized</span>
before attempting to access the payload. Not doing so results in <b>null</b>
pointer dereference.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// A pair of an $(D int) and a $(D size_t) - the latter being the
</span><span class="d_comment">// reference count - will be dynamically allocated
</span><span class="d_keyword">auto</span> rc1 = <span class="d_psymbol">RefCounted</span>!<span class="d_keyword">int</span>(5);
<span class="d_keyword">assert</span>(rc1 == 5);
<span class="d_comment">// No more allocation, add just one extra reference count
</span><span class="d_keyword">auto</span> rc2 = rc1;
<span class="d_comment">// Reference semantics
</span>rc2 = 42;
<span class="d_keyword">assert</span>(rc1 == 42);
<span class="d_comment">// the pair will be freed when rc1 and rc2 go out of scope
</span></pre>
</div></div>
<dl><dt class="d_decl"><div ><a name=".RefCounted.RefCountedStore"></a><div class="quickindex" id="quickindex.RefCounted.RefCountedStore"></div>struct <a name="RefCountedStore"></a><span class="ddoc_psymbol">RefCountedStore</span>;
<br></div></dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate">RefCounted</span> storage implementation.</div>

<dl><dt class="d_decl"><div ><a name=".RefCounted.RefCountedStore.isInitialized"></a><div class="quickindex" id="quickindex.RefCounted.RefCountedStore.isInitialized"></div>const pure nothrow @nogc @property @safe bool <a name="isInitialized"></a><span class="ddoc_psymbol">isInitialized</span>();
<br></div></dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if the underlying store has been
           allocated and initialized.</div>

</dd>
<dt class="d_decl"><div ><a name=".RefCounted.RefCountedStore.refCount"></a><div class="quickindex" id="quickindex.RefCounted.RefCountedStore.refCount"></div>const pure nothrow @nogc @property @safe size_t <a name="refCount"></a><span class="ddoc_psymbol">refCount</span>();
<br></div></dt>
<dd><div class="summary">Returns underlying reference count if it is allocated and initialized
           (a positive integer), and <span class="d_inlinecode donthyphenate notranslate">0</span> otherwise.</div>

</dd>
<dt class="d_decl"><div ><a name=".RefCounted.RefCountedStore.ensureInitialized"></a><div class="quickindex" id="quickindex.RefCounted.RefCountedStore.ensureInitialized"></div>void <a name="ensureInitialized"></a><span class="ddoc_psymbol">ensureInitialized</span>();
<br></div></dt>
<dd><div class="summary">Makes sure the payload was properly initialized. Such a
           call is typically inserted before using the payload.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".RefCounted.refCountedStore"></a><div class="quickindex" id="quickindex.RefCounted.refCountedStore"></div>inout nothrow @property ref @safe inout(RefCountedStore) <a name="refCountedStore"></a><span class="ddoc_psymbol">refCountedStore</span>();
<br></div></dt>
<dd><div class="summary">Returns storage implementation struct.</div>

</dd>
<dt class="d_decl"><div ><a name=".RefCounted.this"></a><div class="quickindex" id="quickindex.RefCounted.this"></div>this<span class="template_param_list" title="Template parameter list">(A...)</span>(auto ref A <i>args</i>)<br><span class="constraint">if (A.length &gt; 0)</span>;
<br><br>this(T <i>val</i>);
<br></div></dt>
<dd><div class="summary">Constructor that initializes the payload.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Postcondition:</span>
<span class="d_inlinecode donthyphenate notranslate">refCountedStore.isInitialized</span></p></div>

</dd>
<dt class="d_decl"><div ><a name=".RefCounted.opAssign"></a><div class="quickindex" id="quickindex.RefCounted.opAssign"></div>void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span>(typeof(this) <i>rhs</i>);
<br><br>void <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span>(T <i>rhs</i>);
<br></div></dt>
<dd><div class="summary">Assignment operators</div>

</dd>
<dt class="d_decl"><div ><a name=".RefCounted.refCountedPayload"></a><div class="quickindex" id="quickindex.RefCounted.refCountedPayload"></div>@property ref return T <a name="refCountedPayload"></a><span class="ddoc_psymbol">refCountedPayload</span>();
<br><br>inout pure nothrow @nogc @property ref return @safe inout(T) <a name="refCountedPayload"></a><span class="ddoc_psymbol">refCountedPayload</span>();
<br></div></dt>
<dd><div class="summary">Returns a reference to the payload. If (autoInit ==
        RefCountedAutoInitialize.yes), calls <span class="d_inlinecode donthyphenate notranslate">        refCountedStore.ensureInitialized</span>. Otherwise, just issues <span class="d_inlinecode donthyphenate notranslate">        assert(refCountedStore.isInitialized)</span>. Used with <span class="d_inlinecode donthyphenate notranslate">alias
        <a name="refCountedPayload"></a><span class="ddoc_psymbol">refCountedPayload</span> this;</span>, so callers can just use the <span class="d_inlinecode donthyphenate notranslate">RefCounted</span>
        object as a <span class="d_inlinecode donthyphenate notranslate">T</span>.
</div>
<div class="description"><span class="blue">The first overload exists only if <span class="d_inlinecode donthyphenate notranslate">autoInit == RefCountedAutoInitialize.yes</span>.</span>
        So if <span class="d_inlinecode donthyphenate notranslate">autoInit == RefCountedAutoInitialize.no</span>
        or called for a constant or immutable object, then
        <span class="d_inlinecode donthyphenate notranslate"><a name="refCountedPayload"></a><span class="ddoc_psymbol">refCountedPayload</span></span> will also be qualified as safe and nothrow
        (but will still assert if not initialized).</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".refCounted"></a><div class="quickindex" id="quickindex.refCounted"></div>RefCounted!(T, RefCountedAutoInitialize.no) <a name="refCounted"></a><span class="ddoc_psymbol">refCounted</span><span class="template_param_list" title="Template parameter list">(T)</span>(T <i>val</i>);
<br></div></dt>
<dd><div class="summary">Initializes a <span class="d_inlinecode donthyphenate notranslate">RefCounted</span> with <span class="d_inlinecode donthyphenate notranslate"><i>val</i></span>. The template parameter
 <span class="d_inlinecode donthyphenate notranslate">T</span> of <span class="d_inlinecode donthyphenate notranslate">RefCounted</span> is inferred from <span class="d_inlinecode donthyphenate notranslate"><i>val</i></span>.
 This function can be used to move non-copyable values to the heap.
 It also disables the <span class="d_inlinecode donthyphenate notranslate">autoInit</span> option of <span class="d_inlinecode donthyphenate notranslate">RefCounted</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">T <i>val</i></td>
<td class="param_desc">The value to be reference counted</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">An initialized <span class="d_inlinecode donthyphenate notranslate">RefCounted</span> containing <span class="d_inlinecode donthyphenate notranslate"><i>val</i></span>.
</div></div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">C++'s make_shared</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> File
{
    string name;
    @disable <span class="d_keyword">this</span>(<span class="d_keyword">this</span>); <span class="d_comment">// not copyable
</span>    ~<span class="d_keyword">this</span>() { name = <span class="d_keyword">null</span>; }
}

<span class="d_keyword">auto</span> file = File(<span class="d_string">"name"</span>);
<span class="d_keyword">assert</span>(file.name == <span class="d_string">"name"</span>);
<span class="d_comment">// file cannot be copied and has unique ownership
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, {<span class="d_keyword">auto</span> file2 = file;}));

<span class="d_comment">// make the file refcounted to share ownership
</span><span class="d_keyword">import</span> std.algorithm.mutation : move;
<span class="d_keyword">auto</span> rcFile = <span class="d_psymbol">refCounted</span>(move(file));
<span class="d_keyword">assert</span>(rcFile.name == <span class="d_string">"name"</span>);
<span class="d_keyword">assert</span>(file.name == <span class="d_keyword">null</span>);
<span class="d_keyword">auto</span> rcFile2 = rcFile;
<span class="d_keyword">assert</span>(rcFile.refCountedStore.refCount == 2);
<span class="d_comment">// file gets properly closed when last reference is dropped
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Proxy"></a><div class="quickindex" id="quickindex.Proxy"></div>template <a name="Proxy"></a><span class="ddoc_psymbol">Proxy</span>(alias a)<br></div></dt>
<dd><div class="summary">Creates a proxy for the value <span class="d_inlinecode donthyphenate notranslate">a</span> that will forward all operations
    while disabling implicit conversions. The aliased item <span class="d_inlinecode donthyphenate notranslate">a</span> must be
    an <b>lvalue</b>. This is useful for creating a new type from the
    "base" type (though this is <b>not</b> a subtype-supertype
    relationship; the new type is not related to the old type in any way,
    by design).
</div>
<div class="description">The new type supports all operations that the underlying type does,
    including all operators such as <span class="d_inlinecode donthyphenate notranslate">+</span>, <span class="d_inlinecode donthyphenate notranslate">--</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">[]</span>, etc.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">a</td>
<td class="param_desc">The value to act as a proxy for all operations. It must
            be an lvalue.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> MyInt
{
    <span class="d_keyword">private</span> <span class="d_keyword">int</span> value;
    <span class="d_keyword">mixin</span> <span class="d_psymbol">Proxy</span>!value;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n){ value = n; }
}

MyInt n = 10;

<span class="d_comment">// Enable operations that original type has.
</span>++n;
<span class="d_keyword">assert</span>(n == 11);
<span class="d_keyword">assert</span>(n * 2 == 22);

<span class="d_keyword">void</span> func(<span class="d_keyword">int</span> n) { }

<span class="d_comment">// Disable implicit conversions to original type.
</span><span class="d_comment">//int x = n;
</span><span class="d_comment">//func(n);
</span></pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">The proxied value must be an <b>lvalue</b>.
<pre class="d_code notranslate">
<span class="d_keyword">struct</span> NewIntType
{
    <span class="d_comment">//Won't work; the literal '1' is
</span>    <span class="d_comment">//is an rvalue, not an lvalue
</span>    <span class="d_comment">//mixin Proxy!1;
</span>
    <span class="d_comment">//Okay, n is an lvalue
</span>    <span class="d_keyword">int</span> n;
    <span class="d_keyword">mixin</span> <span class="d_psymbol">Proxy</span>!n;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) { <span class="d_keyword">this</span>.n = n; }
}

NewIntType nit = 0;
nit++;
<span class="d_keyword">assert</span>(nit == 1);


<span class="d_keyword">struct</span> NewObjectType
{
    Object obj;
    <span class="d_comment">//Ok, obj is an lvalue
</span>    <span class="d_keyword">mixin</span> <span class="d_psymbol">Proxy</span>!obj;

    <span class="d_keyword">this</span> (Object o) { obj = o; }
}

NewObjectType not = <span class="d_keyword">new</span> Object();
<span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(compiles, not.toHash()));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">There is one exception to the fact that the new type is not related to the
    old type. <a href="../spec/function.html#pseudo-member">Pseudo-member</a>
    functions are usable with the new type; they will be forwarded on to the
    proxied value.
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.math;

<span class="d_keyword">float</span> f = 1.0;
<span class="d_keyword">assert</span>(!f.isInfinity);

<span class="d_keyword">struct</span> NewFloat
{
    <span class="d_keyword">float</span> _;
    <span class="d_keyword">mixin</span> <span class="d_psymbol">Proxy</span>!_;

    <span class="d_keyword">this</span>(<span class="d_keyword">float</span> f) { _ = f; }
}

NewFloat nf = 1.0f;
<span class="d_keyword">assert</span>(!nf.isInfinity);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".Typedef"></a><div class="quickindex" id="quickindex.Typedef"></div>struct <a name="Typedef"></a><span class="ddoc_psymbol">Typedef</span>(T, T init = T.init, string cookie = null);
<br></div></dt>
<dd><div class="summary"><b><a name="Typedef"></a><span class="ddoc_psymbol">Typedef</span></b> allows the creation of a unique type which is
based on an existing type. Unlike the <span class="d_inlinecode donthyphenate notranslate">alias</span> feature,
<b><a name="Typedef"></a><span class="ddoc_psymbol">Typedef</span></b> ensures the two types are not considered as equals.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> MyInt = <span class="d_psymbol">Typedef</span>!<span class="d_keyword">int</span>;
<span class="d_keyword">static</span> <span class="d_keyword">void</span> takeInt(<span class="d_keyword">int</span>) { }
<span class="d_keyword">static</span> <span class="d_keyword">void</span> takeMyInt(MyInt) { }

<span class="d_keyword">int</span> i;
takeInt(i);    <span class="d_comment">// ok
</span>takeMyInt(i);  <span class="d_comment">// fails
</span>
MyInt myInt;
takeInt(myInt);    <span class="d_comment">// fails
</span>takeMyInt(myInt);  <span class="d_comment">// ok
</span></pre>

</p></div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class="params"><tr class="param"><td class="param_id">init</td>
<td class="param_desc">Optional initial value for the new type. For example:
<p></p>

<pre class="d_code notranslate"><span class="d_keyword">alias</span> MyInt = <span class="d_psymbol">Typedef</span>!(<span class="d_keyword">int</span>, 10);
MyInt myInt;
<span class="d_keyword">assert</span>(myInt == 10);  <span class="d_comment">// default-initialized to 10
</span></pre>
</td></tr>
<tr class="param"><td class="param_id">cookie</td>
<td class="param_desc">Optional, used to create multiple unique types which are
based on the same origin type <span class="d_inlinecode donthyphenate notranslate">T</span>. For example:
<p></p>

<pre class="d_code notranslate"><span class="d_keyword">alias</span> TypeInt1 = <span class="d_psymbol">Typedef</span>!<span class="d_keyword">int</span>;
<span class="d_keyword">alias</span> TypeInt2 = <span class="d_psymbol">Typedef</span>!<span class="d_keyword">int</span>;

<span class="d_comment">// The two Typedefs are the same type.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(TypeInt1 == TypeInt2));

<span class="d_keyword">alias</span> MoneyEuros = <span class="d_psymbol">Typedef</span>!(<span class="d_keyword">float</span>, <span class="d_keyword">float</span>.init, <span class="d_string">"euros"</span>);
<span class="d_keyword">alias</span> MoneyDollars = <span class="d_psymbol">Typedef</span>!(<span class="d_keyword">float</span>, <span class="d_keyword">float</span>.init, <span class="d_string">"dollars"</span>);

<span class="d_comment">// The two Typedefs are _not_ the same type.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(MoneyEuros == MoneyDollars));
</pre>
</td></tr>
</table></div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
If a library routine cannot handle the <a name="Typedef"></a><span class="ddoc_psymbol">Typedef</span> type,
you can use the <span class="d_inlinecode donthyphenate notranslate">TypedefType</span> template to extract the
type which the <a name="Typedef"></a><span class="ddoc_psymbol">Typedef</span> wraps.</p></div>

</dd>
<dt class="d_decl"><div ><a name=".TypedefType"></a><div class="quickindex" id="quickindex.TypedefType"></div>template <a name="TypedefType"></a><span class="ddoc_psymbol">TypedefType</span>(T)<br></div></dt>
<dd><div class="summary">Get the underlying type which a <span class="d_inlinecode donthyphenate notranslate">Typedef</span> wraps.
If <span class="d_inlinecode donthyphenate notranslate">T</span> is not a <span class="d_inlinecode donthyphenate notranslate">Typedef</span> it will alias itself to <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.typecons: Typedef, <span class="d_psymbol">TypedefType</span>;
<span class="d_keyword">import</span> std.conv: to;

<span class="d_keyword">alias</span> MyInt = Typedef!<span class="d_keyword">int</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">TypedefType</span>!MyInt == <span class="d_keyword">int</span>));

<span class="d_comment">/// Instantiating with a non-Typedef will return that type
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">TypedefType</span>!<span class="d_keyword">int</span> == <span class="d_keyword">int</span>));

string num = <span class="d_string">"5"</span>;

<span class="d_comment">// extract the needed type
</span>MyInt myInt = MyInt( num.to!(<span class="d_psymbol">TypedefType</span>!MyInt) );
<span class="d_keyword">assert</span>(myInt == 5);

<span class="d_comment">// cast to the underlying type to get the value that's being wrapped
</span><span class="d_keyword">int</span> x = <span class="d_keyword">cast</span>(<span class="d_psymbol">TypedefType</span>!MyInt)myInt;

<span class="d_keyword">alias</span> MyIntInit = Typedef!(<span class="d_keyword">int</span>, 42);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">TypedefType</span>!MyIntInit == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(MyIntInit() == 42);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".scoped"></a><div class="quickindex" id="quickindex.scoped"></div>template <a name="scoped"></a><span class="ddoc_psymbol">scoped</span>(T) if (is(T == class))<br></div></dt>
<dd><div class="summary">Allocates a <span class="d_inlinecode donthyphenate notranslate">class</span> object right inside the current scope,
therefore avoiding the overhead of <span class="d_inlinecode donthyphenate notranslate">new</span>. This facility is unsafe;
it is the responsibility of the user to not escape a reference to the
object outside the scope.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
it's illegal to move a class reference even if you are sure there
are no pointers to it. As such, it is illegal to move a <a name="scoped"></a><span class="ddoc_psymbol">scoped</span> object.</p></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">this</span>()     {x = 0;}
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> i){x = i;}
}

<span class="d_comment">// Standard usage
</span><span class="d_keyword">auto</span> a1 = <span class="d_psymbol">scoped</span>!A();
<span class="d_keyword">auto</span> a2 = <span class="d_psymbol">scoped</span>!A(1);
a1.x = 42;
<span class="d_keyword">assert</span>(a1.x == 42);
<span class="d_keyword">assert</span>(a2.x ==  1);

<span class="d_comment">// Restrictions
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>({
    <span class="d_keyword">auto</span> e1 = a1; <span class="d_comment">// illegal, scoped objects can't be copied
</span>    <span class="d_keyword">assert</span>([a2][0].x == 42); <span class="d_comment">// ditto
</span>    <span class="d_keyword">alias</span> ScopedObject = <span class="d_keyword">typeof</span>(a1);
    <span class="d_keyword">auto</span> e2 = ScopedObject();  <span class="d_comment">//Illegal, must be built via scoped!A
</span>    <span class="d_keyword">auto</span> e3 = ScopedObject(1); <span class="d_comment">//Illegal, must be built via scoped!A
</span>})));

<span class="d_comment">// Use as member variable
</span><span class="d_keyword">struct</span> B
{
    <span class="d_keyword">typeof</span>(<span class="d_psymbol">scoped</span>!A()) a; <span class="d_comment">// note the trailing parentheses
</span>}

<span class="d_comment">// Use with alias
</span><span class="d_keyword">alias</span> makeScopedA = <span class="d_psymbol">scoped</span>!A;
<span class="d_keyword">auto</span> a6 = makeScopedA();
<span class="d_keyword">auto</span> a7 = makeScopedA();
</pre>
</div></div>
<dl><dt class="d_decl"><div ><a name=".scoped.scoped"></a><div class="quickindex" id="quickindex.scoped.scoped"></div>@system auto <a name="scoped"></a><span class="ddoc_psymbol">scoped</span><span class="template_param_list" title="Template parameter list">(Args...)</span>(auto ref Args <i>args</i>);
<br></div></dt>
<dd><div class="summary">Returns the <a name="scoped"></a><span class="ddoc_psymbol">scoped</span> object</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".Flag"></a><div class="quickindex" id="quickindex.Flag"></div>template <a name="Flag"></a><span class="ddoc_psymbol">Flag</span>(string name)<br></div></dt>
<dd><div class="summary">Defines a simple, self-documenting yes/no flag. This makes it easy for
APIs to define functions accepting flags without resorting to <span class="d_inlinecode donthyphenate notranslate">bool</span>, which is opaque in calls, and without needing to define an
enumerated type separately. Using <span class="d_inlinecode donthyphenate notranslate"><a name="Flag"></a><span class="ddoc_psymbol">Flag</span>!"Name"</span> instead of <span class="d_inlinecode donthyphenate notranslate">bool</span> makes the flag's meaning visible in calls. Each yes/no flag has
its own type, which makes confusions and mix-ups impossible.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
Code calling <span class="d_inlinecode donthyphenate notranslate">getLine</span> (usually far away from its definition) can't be
understood without looking at the documentation, even by users familiar with
the API:
<pre class="d_code notranslate">string getLine(<span class="d_keyword">bool</span> keepTerminator)
{
    ...
    <span class="d_keyword">if</span> (keepTerminator) ...
    ...
}
...
<span class="d_keyword">auto</span> line = getLine(<span class="d_keyword">false</span>);
</pre>
<p></p>

Assuming the reverse meaning (i.e. "ignoreTerminator") and inserting the wrong
code compiles and runs with erroneous results.
<p></p>

After replacing the boolean parameter with an instantiation of <span class="d_inlinecode donthyphenate notranslate"><a name="Flag"></a><span class="ddoc_psymbol">Flag</span></span>, code
calling <span class="d_inlinecode donthyphenate notranslate">getLine</span> can be easily read and understood even by people not
fluent with the API:
<p></p>

<pre class="d_code notranslate">string getLine(<span class="d_psymbol">Flag</span>!<span class="d_string">"keepTerminator"</span> keepTerminator)
{
    ...
    <span class="d_keyword">if</span> (keepTerminator) ...
    ...
}
...
<span class="d_keyword">auto</span> line = getLine(Yes.keepTerminator);
</pre>
<p></p>

The structs <span class="d_inlinecode donthyphenate notranslate">Yes</span> and <span class="d_inlinecode donthyphenate notranslate">No</span> are provided as shorthand for
<span class="d_inlinecode donthyphenate notranslate"><a name="Flag"></a><span class="ddoc_psymbol">Flag</span>!"Name".yes</span> and <span class="d_inlinecode donthyphenate notranslate"><a name="Flag"></a><span class="ddoc_psymbol">Flag</span>!"Name".no</span> and are preferred for brevity and
readability. These convenience structs mean it is usually unnecessary and
counterproductive to create an alias of a <span class="d_inlinecode donthyphenate notranslate"><a name="Flag"></a><span class="ddoc_psymbol">Flag</span></span> as a way of avoiding typing
out the full type while specifying the affirmative or negative options.
<p></p>

Passing categorical data by means of unstructured <span class="d_inlinecode donthyphenate notranslate">bool</span>
parameters is classified under "simple-data coupling" by Steve
McConnell in the <a href="https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Code Complete">Code Complete</a> book, along with three other
kinds of coupling. The author argues citing several studies that
coupling has a negative effect on code quality. <span class="d_inlinecode donthyphenate notranslate"><a name="Flag"></a><span class="ddoc_psymbol">Flag</span></span> offers a
simple structuring method for passing yes/no flags to APIs.</p></div>

<dl><dt class="d_decl"><div ><a name=".Flag.Flag"></a><div class="quickindex" id="quickindex.Flag.Flag"></div>enum <a name="Flag"></a><span class="ddoc_psymbol">Flag</span>: bool;
<br></div></dt>
<dd><p></p>
<dl><dt class="d_decl"><div ><a name=".Flag.Flag.no"></a><div class="quickindex" id="quickindex.Flag.Flag.no"></div><a name="no"></a><span class="ddoc_psymbol">no</span><br></div></dt>
<dd><div class="summary">When creating a value of type <span class="d_inlinecode donthyphenate notranslate">Flag!"Name"</span>, use <span class="d_inlinecode donthyphenate notranslate">         Flag!"Name".<a name="no"></a><span class="ddoc_psymbol">no</span></span> for the negative option. When using a value
         of type <span class="d_inlinecode donthyphenate notranslate">Flag!"Name"</span>, compare it against <span class="d_inlinecode donthyphenate notranslate">         Flag!"Name".<a name="no"></a><span class="ddoc_psymbol">no</span></span> or just <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> or <span class="d_inlinecode donthyphenate notranslate">0</span>.</div>

</dd>
<dt class="d_decl"><div ><a name=".Flag.Flag.yes"></a><div class="quickindex" id="quickindex.Flag.Flag.yes"></div><a name="yes"></a><span class="ddoc_psymbol">yes</span><br></div></dt>
<dd><div class="summary">When creating a value of type <span class="d_inlinecode donthyphenate notranslate">Flag!"Name"</span>, use <span class="d_inlinecode donthyphenate notranslate">         Flag!"Name".<a name="yes"></a><span class="ddoc_psymbol">yes</span></span> for the affirmative option. When using a
         value of type <span class="d_inlinecode donthyphenate notranslate">Flag!"Name"</span>, compare it against <span class="d_inlinecode donthyphenate notranslate">         Flag!"Name".<a name="yes"></a><span class="ddoc_psymbol">yes</span></span>.</div>

</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="d_decl"><div ><a name=".Yes"></a><div class="quickindex" id="quickindex.Yes"></div>struct <a name="Yes"></a><span class="ddoc_psymbol">Yes</span>;
<br><br><a name=".No"></a><div class="quickindex" id="quickindex.No"></div>struct <a name="No"></a><span class="ddoc_psymbol">No</span>;
<br></div></dt>
<dd><div class="summary">Convenience names that allow using e.g. <span class="d_inlinecode donthyphenate notranslate"><a name="Yes"></a><span class="ddoc_psymbol">Yes</span>.encryption</span> instead of
<span class="d_inlinecode donthyphenate notranslate">Flag!"encryption".yes</span> and <span class="d_inlinecode donthyphenate notranslate"><a name="No"></a><span class="ddoc_psymbol">No</span>.encryption</span> instead of <span class="d_inlinecode donthyphenate notranslate">Flag!"encryption".no</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
Flag!<span class="d_string">"abc"</span> flag1;
<span class="d_keyword">assert</span>(flag1 == Flag!<span class="d_string">"abc"</span>.no);
<span class="d_keyword">assert</span>(flag1 == <span class="d_psymbol">No</span>.abc);
<span class="d_keyword">assert</span>(!flag1);
<span class="d_keyword">if</span> (flag1) <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
flag1 = <span class="d_psymbol">Yes</span>.abc;
<span class="d_keyword">assert</span>(flag1);
<span class="d_keyword">if</span> (!flag1) <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
<span class="d_keyword">if</span> (flag1) {} <span class="d_keyword">else</span> <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(flag1 == <span class="d_psymbol">Yes</span>.abc);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".isBitFlagEnum"></a><div class="quickindex" id="quickindex.isBitFlagEnum"></div>template <a name="isBitFlagEnum"></a><span class="ddoc_psymbol">isBitFlagEnum</span>(E)<br></div></dt>
<dd><div class="summary">Detect whether an enum is of integral type and has only "flag" values
(i.e. values with a bit count of exactly 1).
Additionally, a zero value is allowed for compatibility with enums including
a "None" value.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">enum</span> A
{
    None,
    A = 1&lt;&lt;0,
    B = 1&lt;&lt;1,
    C = 1&lt;&lt;2,
    D = 1&lt;&lt;3,
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBitFlagEnum</span>!A);

<span class="d_keyword">enum</span> B
{
    A,
    B,
    C,
    D <span class="d_comment">// D == 3
</span>}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBitFlagEnum</span>!B);

<span class="d_keyword">enum</span> C: <span class="d_keyword">double</span>
{
    A = 1&lt;&lt;0,
    B = 1&lt;&lt;1
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBitFlagEnum</span>!C);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".BitFlags"></a><div class="quickindex" id="quickindex.BitFlags"></div>struct <a name="BitFlags"></a><span class="ddoc_psymbol">BitFlags</span>(E, Flag!"unsafe" unsafe = No.unsafe) if (unsafe || isBitFlagEnum!E);
<br></div></dt>
<dd><div class="summary">A typesafe structure for storing combinations of enum values.
</div>
<div class="description">This template defines a simple struct to represent bitwise OR combinations of
enum values. It can be used if all the enum values are integral constants with
a bit count of at most 1, or if the <span class="d_inlinecode donthyphenate notranslate">unsafe</span> parameter is explicitly set to
Yes.
This is much safer than using the enum itself to store
the OR combination, which can produce surprising effects like this:
<pre class="d_code notranslate"><span class="d_keyword">enum</span> E
{
    A = 1&lt;&lt;0,
    B = 1&lt;&lt;1
}
E e = E.A | E.B;
<span class="d_comment">// will throw SwitchError
</span><span class="d_keyword">final</span> <span class="d_keyword">switch</span>(e)
{
    <span class="d_keyword">case</span> E.A:
        <span class="d_keyword">return</span>;
    <span class="d_keyword">case</span> E.B:
        <span class="d_keyword">return</span>;
}
</pre>
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><a name="BitFlags"></a><span class="ddoc_psymbol">BitFlags</span> can be manipulated with the usual operators
<pre class="d_code notranslate">
<span class="d_comment">// You can use such an enum with BitFlags straight away
</span><span class="d_keyword">enum</span> Enum
{
    None,
    A = 1&lt;&lt;0,
    B = 1&lt;&lt;1,
    C = 1&lt;&lt;2
}
<span class="d_psymbol">BitFlags</span>!Enum flags1;
<span class="d_keyword">assert</span>(!(flags1 &amp; (Enum.A | Enum.B | Enum.C)));

<span class="d_comment">// You need to specify the $(D unsafe) parameter for enum with custom values
</span><span class="d_keyword">enum</span> UnsafeEnum
{
    A,
    B,
    C,
    D = B|C
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, { <span class="d_psymbol">BitFlags</span>!UnsafeEnum flags2; }));
<span class="d_psymbol">BitFlags</span>!(UnsafeEnum, Yes.unsafe) flags3;

<span class="d_keyword">immutable</span> <span class="d_psymbol">BitFlags</span>!Enum flags_empty;
<span class="d_comment">// A default constructed BitFlags has no value set
</span><span class="d_keyword">assert</span>(!(flags_empty &amp; Enum.A) &amp;&amp; !(flags_empty &amp; Enum.B) &amp;&amp; !(flags_empty &amp; Enum.C));

<span class="d_comment">// Value can be set with the | operator
</span><span class="d_keyword">immutable</span> <span class="d_psymbol">BitFlags</span>!Enum flags_A = flags_empty | Enum.A;

<span class="d_comment">// And tested with the &amp; operator
</span><span class="d_keyword">assert</span>(flags_A &amp; Enum.A);

<span class="d_comment">// Which commutes
</span><span class="d_keyword">assert</span>(Enum.A &amp; flags_A);

<span class="d_comment">// BitFlags can be variadically initialized
</span><span class="d_keyword">immutable</span> <span class="d_psymbol">BitFlags</span>!Enum flags_AB = <span class="d_psymbol">BitFlags</span>!Enum(Enum.A, Enum.B);
<span class="d_keyword">assert</span>((flags_AB &amp; Enum.A) &amp;&amp; (flags_AB &amp; Enum.B) &amp;&amp; !(flags_AB &amp; Enum.C));

<span class="d_comment">// Use the ~ operator for subtracting flags
</span><span class="d_keyword">immutable</span> <span class="d_psymbol">BitFlags</span>!Enum flags_B = flags_AB &amp; ~<span class="d_psymbol">BitFlags</span>!Enum(Enum.A);
<span class="d_keyword">assert</span>(!(flags_B &amp; Enum.A) &amp;&amp; (flags_B &amp; Enum.B) &amp;&amp; !(flags_B &amp; Enum.C));

<span class="d_comment">// You can use the EnumMembers template to set all flags
</span><span class="d_keyword">immutable</span> <span class="d_psymbol">BitFlags</span>!Enum flags_all = EnumMembers!Enum;

<span class="d_comment">// use &amp; between BitFlags for intersection
</span><span class="d_keyword">immutable</span> <span class="d_psymbol">BitFlags</span>!Enum flags_BC = <span class="d_psymbol">BitFlags</span>!Enum(Enum.B, Enum.C);
<span class="d_keyword">assert</span> (flags_B == (flags_BC &amp; flags_AB));

<span class="d_comment">// All the binary operators work in their assignment version
</span><span class="d_psymbol">BitFlags</span>!Enum temp = flags_empty;
temp |= flags_AB;
<span class="d_keyword">assert</span>(temp == (flags_empty | flags_AB));
temp = flags_empty;
temp |= Enum.B;
<span class="d_keyword">assert</span>(temp == (flags_empty | Enum.B));
temp = flags_empty;
temp &amp;= flags_AB;
<span class="d_keyword">assert</span>(temp == (flags_empty &amp; flags_AB));
temp = flags_empty;
temp &amp;= Enum.A;
<span class="d_keyword">assert</span>(temp == (flags_empty &amp; Enum.A));

<span class="d_comment">// BitFlags with no value set evaluate to false
</span><span class="d_keyword">assert</span>(!flags_empty);

<span class="d_comment">// BitFlags with at least one value set evaluate to true
</span><span class="d_keyword">assert</span>(flags_A);

<span class="d_comment">// This can be useful to check intersection between BitFlags
</span><span class="d_keyword">assert</span>(flags_A &amp; flags_AB);
<span class="d_keyword">assert</span>(flags_AB &amp; Enum.A);

<span class="d_comment">// Finally, you can of course get you raw value out of flags
</span><span class="d_keyword">auto</span> value = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>)flags_A;
<span class="d_keyword">assert</span>(value == Enum.A);
</pre>
</div></div>
</dd>
<dt class="d_decl"><div ><a name=".ReplaceType"></a><div class="quickindex" id="quickindex.ReplaceType"></div>template <a name="ReplaceType"></a><span class="ddoc_psymbol">ReplaceType</span>(From, To, T...)<br></div></dt>
<dd><div class="summary">Replaces all occurrences of <span class="d_inlinecode donthyphenate notranslate">From</span> into <span class="d_inlinecode donthyphenate notranslate">To</span>, in one or more types <span class="d_inlinecode donthyphenate notranslate">T</span>. For
example, <span class="d_inlinecode donthyphenate notranslate"><a name="ReplaceType"></a><span class="ddoc_psymbol">ReplaceType</span>!(int, uint, Tuple!(int, float)[string])</span> yields
<span class="d_inlinecode donthyphenate notranslate">Tuple!(uint, float)[string]</span>. The types in which replacement is performed
may be arbitrarily complex, including qualifiers, built-in type constructors
(pointers, arrays, associative arrays, functions, and delegates), and template
instantiations; replacement proceeds transitively through the type definition.
However, member types in <span class="d_inlinecode donthyphenate notranslate">struct</span>s or <span class="d_inlinecode donthyphenate notranslate">class</span>es are not replaced because there
are no ways to express the types resulting after replacement.
</div>
<div class="description">This is an advanced type manipulation necessary e.g. for replacing the
placeholder type <span class="d_inlinecode donthyphenate notranslate">This</span> in <span class="libref"><a href="http://dlang.org/phobos/std_variant.html#Algebraic"><span class="d_inlinecode donthyphenate notranslate">std.variant.Algebraic</span></a></span>.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><span class="d_inlinecode donthyphenate notranslate"><a name="ReplaceType"></a><span class="ddoc_psymbol">ReplaceType</span></span> aliases itself to the type(s) that result after
replacement.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(
    <span class="d_keyword">is</span>(<span class="d_psymbol">ReplaceType</span>!(<span class="d_keyword">int</span>, string, <span class="d_keyword">int</span>[]) == string[]) &amp;&amp;
    <span class="d_keyword">is</span>(<span class="d_psymbol">ReplaceType</span>!(<span class="d_keyword">int</span>, string, <span class="d_keyword">int</span>[<span class="d_keyword">int</span>]) == string[string]) &amp;&amp;
    <span class="d_keyword">is</span>(<span class="d_psymbol">ReplaceType</span>!(<span class="d_keyword">int</span>, string, <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]) == <span class="d_keyword">const</span>(string)[]) &amp;&amp;
    <span class="d_keyword">is</span>(<span class="d_psymbol">ReplaceType</span>!(<span class="d_keyword">int</span>, string, Tuple!(<span class="d_keyword">int</span>[], <span class="d_keyword">float</span>))
        == Tuple!(string[], <span class="d_keyword">float</span>))
);
</pre>
</div></div>
</dd>
</dl>

        <div class="smallprint" id="copyright">Copyright the respective authors, 2008-
 | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>

<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(listanchors);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
</body>
</html>

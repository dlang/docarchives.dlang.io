
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>std.range - D Programming Language</title>
<link rel="stylesheet" href="../css/codemirror.css" />
<link rel="stylesheet" href="../css/style.css" />
<link rel="stylesheet" href="../css/print.css" media="print" />
<link rel="stylesheet" href="../css/cssmenu.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="shortcut icon" href="../favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0" />
</head>
<body id='std.range' class='std'>
<script type="text/javascript">document.body.className += ' have-javascript';</script>
<div id="top">	<div id="header">		<a class="logo" href=".."><img id="logo" width="125" height="95" alt="D Logo" src="../images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href=".." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <span id="search-query"><input id="q" name="q" placeholder="Search" /></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option selected value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='../index.html'><span>D Lib Prerelease</span></a></li>
    <li><a href='../phobos/index.html'><span>Current Release (2.067.0)</span></a></li>
    
<li><a href='object.html'><span><em class="tt">object</em></span></a></li>
<li class='has-sub'><a href='#'><span><em class="tt">std</em></span></a>
<ul><li>  <a href="std_algorithm.html" title="std.algorithm"><span class="d_inlinecode donthyphenate notranslate">algorithm</span></a></li><li>  <a href="std_array.html" title="std.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>  <a href="std_ascii.html" title="std.ascii"><span class="d_inlinecode donthyphenate notranslate">ascii</span></a></li><li>  <a href="std_base64.html" title="std.base64"><span class="d_inlinecode donthyphenate notranslate">base64</span></a></li><li>  <a href="std_bigint.html" title="std.bigint"><span class="d_inlinecode donthyphenate notranslate">bigint</span></a></li><li>  <a href="std_bitmanip.html" title="std.bitmanip"><span class="d_inlinecode donthyphenate notranslate">bitmanip</span></a></li><li>  <a href="std_compiler.html" title="std.compiler"><span class="d_inlinecode donthyphenate notranslate">compiler</span></a></li><li>  <a href="std_complex.html" title="std.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>  <a href="std_concurrency.html" title="std.concurrency"><span class="d_inlinecode donthyphenate notranslate">concurrency</span></a></li><li>  <a href="std_container.html" title="std.container"><span class="d_inlinecode donthyphenate notranslate">container</span></a><ul><li>    <a href="std_container_array.html" title="std.container.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>    <a href="std_container_binaryheap.html" title="std.container.binaryheap"><span class="d_inlinecode donthyphenate notranslate">binaryheap</span></a></li><li>    <a href="std_container_dlist.html" title="std.container.dlist"><span class="d_inlinecode donthyphenate notranslate">dlist</span></a></li><li>    <a href="std_container_rbtree.html" title="std.container.rbtree"><span class="d_inlinecode donthyphenate notranslate">rbtree</span></a></li><li>    <a href="std_container_slist.html" title="std.container.slist"><span class="d_inlinecode donthyphenate notranslate">slist</span></a></li><li>    <a href="std_container_util.html" title="std.container.util"><span class="d_inlinecode donthyphenate notranslate">util</span></a>
  </li></ul></li><li>  <a href="std_conv.html" title="std.conv"><span class="d_inlinecode donthyphenate notranslate">conv</span></a></li><li>  <a href="std_csv.html" title="std.csv"><span class="d_inlinecode donthyphenate notranslate">csv</span></a></li><li>  <a href="std_datetime.html" title="std.datetime"><span class="d_inlinecode donthyphenate notranslate">datetime</span></a></li><li>  <a href="std_demangle.html" title="std.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">digest</span></h7><ul><li>    <a href="std_digest_crc.html" title="std.digest.crc"><span class="d_inlinecode donthyphenate notranslate">crc</span></a></li><li>    <a href="std_digest_digest.html" title="std.digest.digest"><span class="d_inlinecode donthyphenate notranslate">digest</span></a></li><li>    <a href="std_digest_md.html" title="std.digest.md"><span class="d_inlinecode donthyphenate notranslate">md</span></a></li><li>    <a href="std_digest_ripemd.html" title="std.digest.ripemd"><span class="d_inlinecode donthyphenate notranslate">ripemd</span></a></li><li>    <a href="std_digest_sha.html" title="std.digest.sha"><span class="d_inlinecode donthyphenate notranslate">sha</span></a>
  </li></ul></li><li>  <a href="std_encoding.html" title="std.encoding"><span class="d_inlinecode donthyphenate notranslate">encoding</span></a></li><li>  <a href="std_exception.html" title="std.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="std_file.html" title="std.file"><span class="d_inlinecode donthyphenate notranslate">file</span></a></li><li>  <a href="std_format.html" title="std.format"><span class="d_inlinecode donthyphenate notranslate">format</span></a></li><li>  <a href="std_functional.html" title="std.functional"><span class="d_inlinecode donthyphenate notranslate">functional</span></a></li><li>  <a href="std_getopt.html" title="std.getopt"><span class="d_inlinecode donthyphenate notranslate">getopt</span></a></li><li>  <a href="std_json.html" title="std.json"><span class="d_inlinecode donthyphenate notranslate">json</span></a></li><li>  <a href="std_math.html" title="std.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="std_mathspecial.html" title="std.mathspecial"><span class="d_inlinecode donthyphenate notranslate">mathspecial</span></a></li><li>  <a href="std_mmfile.html" title="std.mmfile"><span class="d_inlinecode donthyphenate notranslate">mmfile</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">net</span></h7><ul><li>    <a href="std_net_curl.html" title="std.net.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="std_net_isemail.html" title="std.net.isemail"><span class="d_inlinecode donthyphenate notranslate">isemail</span></a>
  </li></ul></li><li>  <a href="std_numeric.html" title="std.numeric"><span class="d_inlinecode donthyphenate notranslate">numeric</span></a></li><li>  <a href="std_outbuffer.html" title="std.outbuffer"><span class="d_inlinecode donthyphenate notranslate">outbuffer</span></a></li><li>  <a href="std_parallelism.html" title="std.parallelism"><span class="d_inlinecode donthyphenate notranslate">parallelism</span></a></li><li>  <a href="std_path.html" title="std.path"><span class="d_inlinecode donthyphenate notranslate">path</span></a></li><li>  <a href="std_process.html" title="std.process"><span class="d_inlinecode donthyphenate notranslate">process</span></a></li><li>  <a href="std_random.html" title="std.random"><span class="d_inlinecode donthyphenate notranslate">random</span></a></li><li>  <a href="std_range.html" title="std.range"><span class="d_inlinecode donthyphenate notranslate">range</span></a></li><li>  <a href="std_regex.html" title="std.regex"><span class="d_inlinecode donthyphenate notranslate">regex</span></a></li><li>  <a href="std_signals.html" title="std.signals"><span class="d_inlinecode donthyphenate notranslate">signals</span></a></li><li>  <a href="std_socket.html" title="std.socket"><span class="d_inlinecode donthyphenate notranslate">socket</span></a></li><li>  <a href="std_stdint.html" title="std.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>  <a href="std_stdio.html" title="std.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>  <a href="std_stdiobase.html" title="std.stdiobase"><span class="d_inlinecode donthyphenate notranslate">stdiobase</span></a></li><li>  <a href="std_string.html" title="std.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>  <a href="std_syserror.html" title="std.syserror"><span class="d_inlinecode donthyphenate notranslate">syserror</span></a></li><li>  <a href="std_system.html" title="std.system"><span class="d_inlinecode donthyphenate notranslate">system</span></a></li><li>  <a href="std_traits.html" title="std.traits"><span class="d_inlinecode donthyphenate notranslate">traits</span></a></li><li>  <a href="std_typecons.html" title="std.typecons"><span class="d_inlinecode donthyphenate notranslate">typecons</span></a></li><li>  <a href="std_typetuple.html" title="std.typetuple"><span class="d_inlinecode donthyphenate notranslate">typetuple</span></a></li><li>  <a href="std_uni.html" title="std.uni"><span class="d_inlinecode donthyphenate notranslate">uni</span></a></li><li>  <a href="std_uri.html" title="std.uri"><span class="d_inlinecode donthyphenate notranslate">uri</span></a></li><li>  <a href="std_utf.html" title="std.utf"><span class="d_inlinecode donthyphenate notranslate">utf</span></a></li><li>  <a href="std_uuid.html" title="std.uuid"><span class="d_inlinecode donthyphenate notranslate">uuid</span></a></li><li>  <a href="std_variant.html" title="std.variant"><span class="d_inlinecode donthyphenate notranslate">variant</span></a></li><li>  <a href="std_xml.html" title="std.xml"><span class="d_inlinecode donthyphenate notranslate">xml</span></a></li><li>  <a href="std_zip.html" title="std.zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a></li><li>  <a href="std_zlib.html" title="std.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">etc</em></span></a>
<ul><li>  <h7><span class="d_inlinecode donthyphenate notranslate">c</span></h7><ul><li>    <a href="etc_c_curl.html" title="etc.c.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="etc_c_sqlite3.html" title="etc.c.sqlite3"><span class="d_inlinecode donthyphenate notranslate">sqlite3</span></a></li><li>    <a href="etc_c_zlib.html" title="etc.c.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
  </li></ul>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">core</em></span></a>
<ul><li>  <a href="core_atomic.html" title="core.atomic"><span class="d_inlinecode donthyphenate notranslate">atomic</span></a></li><li>  <a href="core_bitop.html" title="core.bitop"><span class="d_inlinecode donthyphenate notranslate">bitop</span></a></li><li>  <a href="core_checkedint.html" title="core.checkedint"><span class="d_inlinecode donthyphenate notranslate">checkedint</span></a></li><li>  <a href="core_cpuid.html" title="core.cpuid"><span class="d_inlinecode donthyphenate notranslate">cpuid</span></a></li><li>  <a href="core_demangle.html" title="core.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <a href="core_exception.html" title="core.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="core_math.html" title="core.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="core_memory.html" title="core.memory"><span class="d_inlinecode donthyphenate notranslate">memory</span></a></li><li>  <a href="core_runtime.html" title="core.runtime"><span class="d_inlinecode donthyphenate notranslate">runtime</span></a></li><li>  <a href="core_simd.html" title="core.simd"><span class="d_inlinecode donthyphenate notranslate">simd</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">stdc</span></h7><ul><li>    <a href="core_stdc_complex.html" title="core.stdc.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>    <a href="core_stdc_ctype.html" title="core.stdc.ctype"><span class="d_inlinecode donthyphenate notranslate">ctype</span></a></li><li>    <a href="core_stdc_errno.html" title="core.stdc.errno"><span class="d_inlinecode donthyphenate notranslate">errno</span></a></li><li>    <a href="core_stdc_fenv.html" title="core.stdc.fenv"><span class="d_inlinecode donthyphenate notranslate">fenv</span></a></li><li>    <a href="core_stdc_float_.html" title="core.stdc.float_"><span class="d_inlinecode donthyphenate notranslate">float_</span></a></li><li>    <a href="core_stdc_inttypes.html" title="core.stdc.inttypes"><span class="d_inlinecode donthyphenate notranslate">inttypes</span></a></li><li>    <a href="core_stdc_limits.html" title="core.stdc.limits"><span class="d_inlinecode donthyphenate notranslate">limits</span></a></li><li>    <a href="core_stdc_locale.html" title="core.stdc.locale"><span class="d_inlinecode donthyphenate notranslate">locale</span></a></li><li>    <a href="core_stdc_math.html" title="core.stdc.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>    <a href="core_stdc_signal.html" title="core.stdc.signal"><span class="d_inlinecode donthyphenate notranslate">signal</span></a></li><li>    <a href="core_stdc_stdarg.html" title="core.stdc.stdarg"><span class="d_inlinecode donthyphenate notranslate">stdarg</span></a></li><li>    <a href="core_stdc_stddef.html" title="core.stdc.stddef"><span class="d_inlinecode donthyphenate notranslate">stddef</span></a></li><li>    <a href="core_stdc_stdint.html" title="core.stdc.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>    <a href="core_stdc_stdio.html" title="core.stdc.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>    <a href="core_stdc_stdlib.html" title="core.stdc.stdlib"><span class="d_inlinecode donthyphenate notranslate">stdlib</span></a></li><li>    <a href="core_stdc_string.html" title="core.stdc.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>    <a href="core_stdc_tgmath.html" title="core.stdc.tgmath"><span class="d_inlinecode donthyphenate notranslate">tgmath</span></a></li><li>    <a href="core_stdc_time.html" title="core.stdc.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>    <a href="core_stdc_wchar_.html" title="core.stdc.wchar_"><span class="d_inlinecode donthyphenate notranslate">wchar_</span></a></li><li>    <a href="core_stdc_wctype.html" title="core.stdc.wctype"><span class="d_inlinecode donthyphenate notranslate">wctype</span></a>
  </li></ul></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">sync</span></h7><ul><li>    <a href="core_sync_barrier.html" title="core.sync.barrier"><span class="d_inlinecode donthyphenate notranslate">barrier</span></a></li><li>    <a href="core_sync_condition.html" title="core.sync.condition"><span class="d_inlinecode donthyphenate notranslate">condition</span></a></li><li>    <a href="core_sync_config.html" title="core.sync.config"><span class="d_inlinecode donthyphenate notranslate">config</span></a></li><li>    <a href="core_sync_exception.html" title="core.sync.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>    <a href="core_sync_mutex.html" title="core.sync.mutex"><span class="d_inlinecode donthyphenate notranslate">mutex</span></a></li><li>    <a href="core_sync_rwmutex.html" title="core.sync.rwmutex"><span class="d_inlinecode donthyphenate notranslate">rwmutex</span></a></li><li>    <a href="core_sync_semaphore.html" title="core.sync.semaphore"><span class="d_inlinecode donthyphenate notranslate">semaphore</span></a>
  </li></ul></li><li>  <a href="core_thread.html" title="core.thread"><span class="d_inlinecode donthyphenate notranslate">thread</span></a></li><li>  <a href="core_time.html" title="core.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>  <a href="core_vararg.html" title="core.vararg"><span class="d_inlinecode donthyphenate notranslate">vararg</span></a>
</li></ul>
    <li><a href='http://code.dlang.org'><span>3rd Party Packages</span></a></li>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/range.d" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">		<a href="http://wiki.dlang.org/DocComments/Phobos/StdRange" class="button">Page wiki</a>
		<span >			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.range</h1>
    <div class="quickindex" id="quickindex"></div>
    <!--Generated by Ddoc from std/range.d-->
<div class="summary">This module defines the notion of a <a name="range"></a><span class="ddoc_psymbol">range</span>. Ranges generalize the concept of
arrays, lists, or anything that involves sequential access. This abstraction
enables the same set of algorithms (see <a href="std_algorithm.html">std.algorithm</a>) to be used with a vast variety of different concrete types. For
example, a linear search algorithm such as <a href="std_algorithm.html#find">std.algorithm.find</a> works not just for arrays, but for linked-lists, input
files, incoming network data, etc.
</div>
<div class="description">For more detailed information about the conceptual aspect of ranges and the
motivation behind them, see Andrei Alexandrescu's article
<a href="http://www.informit.com/articles/printerfriendly.aspx?p=1407357&rll=1"><i>On Iteration</i></a>.
<p></p>

This module defines several templates for testing whether a given object is a
range, and what kind of range it is:
<table class="book"><caption></caption>    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#isInputRange"><span class="d_inlinecode donthyphenate notranslate">isInputRange</span></a></span></td>
        <td>Tests if something is an <i>input range</i>, defined to be
        something from which one can sequentially read data using the
        primitives <span class="d_inlinecode donthyphenate notranslate">front</span>, <span class="d_inlinecode donthyphenate notranslate">popFront</span>, and <span class="d_inlinecode donthyphenate notranslate">empty</span>.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#isOutputRange"><span class="d_inlinecode donthyphenate notranslate">isOutputRange</span></a></span></td>
        <td>Tests if something is an <i>output range</i>, defined to be
        something to which one can sequentially write data using the
        <span class="d_inlinecode donthyphenate notranslate"><a href="#put"><span class="d_inlinecode donthyphenate notranslate">put</span></a></span> primitive.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#isForwardRange"><span class="d_inlinecode donthyphenate notranslate">isForwardRange</span></a></span></td>
        <td>Tests if something is a <i>forward range</i>, defined to be an
        input range with the additional capability that one can save one's
        current position with the <span class="d_inlinecode donthyphenate notranslate">save</span> primitive, thus allowing one to
        iterate over the same range multiple times.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#isBidirectionalRange"><span class="d_inlinecode donthyphenate notranslate">isBidirectionalRange</span></a></span></td>
        <td>Tests if something is a <i>bidirectional range</i>, that is, a
        forward range that allows reverse traversal using the primitives <span class="d_inlinecode donthyphenate notranslate">        back</span> and <span class="d_inlinecode donthyphenate notranslate">popBack</span>.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#isRandomAccessRange"><span class="d_inlinecode donthyphenate notranslate">isRandomAccessRange</span></a></span></td>
        <td>Tests if something is a <i>random access range</i>, which is a
        bidirectional range that also supports the array subscripting
        operation via the primitive <span class="d_inlinecode donthyphenate notranslate">opIndex</span>.
    </td></tr>
</table>
<p></p>

A number of templates are provided that test for various range capabilities:
<p></p>

<table class="book"><caption></caption>    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#hasMobileElements"><span class="d_inlinecode donthyphenate notranslate">hasMobileElements</span></a></span></td>
        <td>Tests if a given range's elements can be moved around using the
        primitives <span class="d_inlinecode donthyphenate notranslate">moveFront</span>, <span class="d_inlinecode donthyphenate notranslate">moveBack</span>, or <span class="d_inlinecode donthyphenate notranslate">moveAt</span>.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#ElementType"><span class="d_inlinecode donthyphenate notranslate">ElementType</span></a></span></td>
        <td>Returns the element type of a given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#ElementEncodingType"><span class="d_inlinecode donthyphenate notranslate">ElementEncodingType</span></a></span></td>
        <td>Returns the encoding element type of a given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#hasSwappableElements"><span class="d_inlinecode donthyphenate notranslate">hasSwappableElements</span></a></span></td>
        <td>Tests if a range is a forward range with swappable elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#hasAssignableElements"><span class="d_inlinecode donthyphenate notranslate">hasAssignableElements</span></a></span></td>
        <td>Tests if a range is a forward range with mutable elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#hasLvalueElements"><span class="d_inlinecode donthyphenate notranslate">hasLvalueElements</span></a></span></td>
        <td>Tests if a range is a forward range with elements that can be
        passed by reference and have their address taken.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#hasLength"><span class="d_inlinecode donthyphenate notranslate">hasLength</span></a></span></td>
        <td>Tests if a given range has the <span class="d_inlinecode donthyphenate notranslate">length</span> attribute.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#isInfinite"><span class="d_inlinecode donthyphenate notranslate">isInfinite</span></a></span></td>
        <td>Tests if a given range is an <i>infinite range</i>.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#hasSlicing"><span class="d_inlinecode donthyphenate notranslate">hasSlicing</span></a></span></td>
        <td>Tests if a given range supports the array slicing operation <span class="d_inlinecode donthyphenate notranslate">        R[x..y]</span>.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#walkLength"><span class="d_inlinecode donthyphenate notranslate">walkLength</span></a></span></td>
        <td>Computes the length of any range in O(n) time.
    </td></tr>
</table>
<p></p>

A rich set of range creation and composition templates are provided that let
you construct new ranges out of existing ranges:
<p></p>

<table class="book"><caption></caption>    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#retro"><span class="d_inlinecode donthyphenate notranslate">retro</span></a></span></td>
        <td>Iterates a bidirectional range backwards.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#stride"><span class="d_inlinecode donthyphenate notranslate">stride</span></a></span></td>
        <td>Iterates a range with stride <i>n</i>.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#chain"><span class="d_inlinecode donthyphenate notranslate">chain</span></a></span></td>
        <td>Concatenates several ranges into a single range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#roundRobin"><span class="d_inlinecode donthyphenate notranslate">roundRobin</span></a></span></td>
        <td>Given <i>n</i> ranges, creates a new range that return the <i>n</i>
        first elements of each range, in turn, then the second element of each
        range, and so on, in a round-robin fashion.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#radial"><span class="d_inlinecode donthyphenate notranslate">radial</span></a></span></td>
        <td>Given a random-access range and a starting point, creates a
        range that alternately returns the next left and next right element to
        the starting point.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#take"><span class="d_inlinecode donthyphenate notranslate">take</span></a></span></td>
        <td>Creates a sub-range consisting of only up to the first <i>n</i>
        elements of the given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#takeExactly"><span class="d_inlinecode donthyphenate notranslate">takeExactly</span></a></span></td>
        <td>Like <span class="d_inlinecode donthyphenate notranslate">take</span>, but assumes the given range actually has <i>n</i>
        elements, and therefore also defines the <span class="d_inlinecode donthyphenate notranslate">length</span> property.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#takeOne"><span class="d_inlinecode donthyphenate notranslate">takeOne</span></a></span></td>
        <td>Creates a random-access range consisting of exactly the first
        element of the given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#takeNone"><span class="d_inlinecode donthyphenate notranslate">takeNone</span></a></span></td>
        <td>Creates a random-access range consisting of zero elements of the
        given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#drop"><span class="d_inlinecode donthyphenate notranslate">drop</span></a></span></td>
        <td>Creates the range that results from discarding the first <i>n</i>
        elements from the given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#dropExactly"><span class="d_inlinecode donthyphenate notranslate">dropExactly</span></a></span></td>
        <td>Creates the range that results from discarding exactly <i>n</i>
        of the first elements from the given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#dropOne"><span class="d_inlinecode donthyphenate notranslate">dropOne</span></a></span></td>
        <td>Creates the range that results from discarding
        the first elements from the given range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#repeat"><span class="d_inlinecode donthyphenate notranslate">repeat</span></a></span></td>
        <td>Creates a range that consists of a single element repeated <i>n</i>
        times, or an infinite range repeating that element indefinitely.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#cycle"><span class="d_inlinecode donthyphenate notranslate">cycle</span></a></span></td>
        <td>Creates an infinite range that repeats the given forward range
        indefinitely. Good for implementing circular buffers.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a></span></td>
        <td>Given <i>n</i> ranges, creates a range that successively returns a
        tuple of all the first elements, a tuple of all the second elements,
        etc.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#lockstep"><span class="d_inlinecode donthyphenate notranslate">lockstep</span></a></span></td>
        <td>Iterates <i>n</i> ranges in lockstep, for use in a <span class="d_inlinecode donthyphenate notranslate">foreach</span>
        loop. Similar to <span class="d_inlinecode donthyphenate notranslate">zip</span>, except that <span class="d_inlinecode donthyphenate notranslate">lockstep</span> is designed
        especially for <span class="d_inlinecode donthyphenate notranslate">foreach</span> loops.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#recurrence"><span class="d_inlinecode donthyphenate notranslate">recurrence</span></a></span></td>
        <td>Creates a forward range whose values are defined by a
        mathematical recurrence relation.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#sequence"><span class="d_inlinecode donthyphenate notranslate">sequence</span></a></span></td>
        <td>Similar to <span class="d_inlinecode donthyphenate notranslate">recurrence</span>, except that a random-access range is
        created.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#iota"><span class="d_inlinecode donthyphenate notranslate">iota</span></a></span></td>
        <td>Creates a range consisting of numbers between a starting point
        and ending point, spaced apart by a given interval.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#frontTransversal"><span class="d_inlinecode donthyphenate notranslate">frontTransversal</span></a></span></td>
        <td>Creates a range that iterates over the first elements of the
        given ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#transversal"><span class="d_inlinecode donthyphenate notranslate">transversal</span></a></span></td>
        <td>Creates a range that iterates over the <i>n</i>'th elements of the
        given random-access ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#indexed"><span class="d_inlinecode donthyphenate notranslate">indexed</span></a></span></td>
        <td>Creates a range that offers a view of a given range as though
        its elements were reordered according to a given range of indices.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#chunks"><span class="d_inlinecode donthyphenate notranslate">chunks</span></a></span></td>
        <td>Creates a range that returns fixed-size chunks of the original
        range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#only"><span class="d_inlinecode donthyphenate notranslate">only</span></a></span></td>
        <td>Creates a range that iterates over the given arguments.
    </td></tr>
</table>
<p></p>

These range-construction tools are implemented using templates; but sometimes
an object-based interface for ranges is needed. For this purpose, this module
provides a number of object and <span class="d_inlinecode donthyphenate notranslate">interface</span> definitions that can be used to
wrap around range objects created by the above templates.
<p></p>

<table class="book"><caption></caption>    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#InputRange"><span class="d_inlinecode donthyphenate notranslate">InputRange</span></a></span></td>
        <td>Wrapper for input ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#InputAssignable"><span class="d_inlinecode donthyphenate notranslate">InputAssignable</span></a></span></td>
        <td>Wrapper for input ranges with assignable elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#ForwardRange"><span class="d_inlinecode donthyphenate notranslate">ForwardRange</span></a></span></td>
        <td>Wrapper for forward ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#ForwardAssignable"><span class="d_inlinecode donthyphenate notranslate">ForwardAssignable</span></a></span></td>
        <td>Wrapper for forward ranges with assignable elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#BidirectionalRange"><span class="d_inlinecode donthyphenate notranslate">BidirectionalRange</span></a></span></td>
        <td>Wrapper for bidirectional ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#BidirectionalAssignable"><span class="d_inlinecode donthyphenate notranslate">BidirectionalAssignable</span></a></span></td>
        <td>Wrapper for bidirectional ranges with assignable elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#RandomAccessFinite"><span class="d_inlinecode donthyphenate notranslate">RandomAccessFinite</span></a></span></td>
        <td>Wrapper for finite random-access ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#RandomAccessAssignable"><span class="d_inlinecode donthyphenate notranslate">RandomAccessAssignable</span></a></span></td>
        <td>Wrapper for finite random-access ranges with assignable elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#RandomAccessInfinite"><span class="d_inlinecode donthyphenate notranslate">RandomAccessInfinite</span></a></span></td>
        <td>Wrapper for infinite random-access ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#OutputRange"><span class="d_inlinecode donthyphenate notranslate">OutputRange</span></a></span></td>
        <td>Wrapper for output ranges.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#OutputRangeObject"><span class="d_inlinecode donthyphenate notranslate">OutputRangeObject</span></a></span></td>
        <td>Class that implements the <span class="d_inlinecode donthyphenate notranslate">OutputRange</span> interface and wraps the
        <span class="d_inlinecode donthyphenate notranslate">put</span> methods in virtual functions.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#InputRangeObject"><span class="d_inlinecode donthyphenate notranslate">InputRangeObject</span></a></span></td>
        <td>Class that implements the <span class="d_inlinecode donthyphenate notranslate">InputRange</span> interface and wraps the
        input range methods in virtual functions.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#RefRange"><span class="d_inlinecode donthyphenate notranslate">RefRange</span></a></span></td>
        <td>Wrapper around a forward range that gives it reference semantics.
    </td></tr>
</table>
<p></p>

Ranges whose elements are sorted afford better efficiency with certain
operations. For this, the <span class="d_inlinecode donthyphenate notranslate"><a href="#assumeSorted"><span class="d_inlinecode donthyphenate notranslate">assumeSorted</span></a></span> function can be used to
construct a <span class="d_inlinecode donthyphenate notranslate"><a href="#SortedRange"><span class="d_inlinecode donthyphenate notranslate">SortedRange</span></a></span> from a pre-sorted range. The <a href="std_algorithm.html#sort"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.sort</span></a> function also conveniently
returns a <span class="d_inlinecode donthyphenate notranslate">SortedRange</span>. <span class="d_inlinecode donthyphenate notranslate">SortedRange</span> objects provide some additional
range operations that take advantage of the fact that the range is sorted.
<p></p>

Finally, this module also defines some convenience functions for
manipulating ranges:
<p></p>

<table class="book"><caption></caption>    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#popFrontN"><span class="d_inlinecode donthyphenate notranslate">popFrontN</span></a></span></td>
        <td>Advances a given range by up to <i>n</i> elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#popBackN"><span class="d_inlinecode donthyphenate notranslate">popBackN</span></a></span></td>
        <td>Advances a given bidirectional range from the right by up to
        <i>n</i> elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#popFrontExactly"><span class="d_inlinecode donthyphenate notranslate">popFrontExactly</span></a></span></td>
        <td>Advances a given range by up exactly <i>n</i> elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#popBackExactly"><span class="d_inlinecode donthyphenate notranslate">popBackExactly</span></a></span></td>
        <td>Advances a given bidirectional range from the right by exactly
        <i>n</i> elements.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#moveFront"><span class="d_inlinecode donthyphenate notranslate">moveFront</span></a></span></td>
        <td>Removes the front element of a range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#moveBack"><span class="d_inlinecode donthyphenate notranslate">moveBack</span></a></span></td>
        <td>Removes the back element of a bidirectional range.
    </td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate"><a href="#moveAt"><span class="d_inlinecode donthyphenate notranslate">moveAt</span></a></span></td>
        <td>Removes the <i>i</i>'th element of a random-access range.
    </td></tr>
</table>

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Source:</span>
<span class="phobos_src"><a class="https" href="https://github.com/D-Programming-Language/phobos/blob/master/std/range.d">std/range.d</a></span>

</div>
<div class="keyval License"><span class="key keyLicense">License:</span> <div class="val valLicense"><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

</div></div>
<div class="keyval Authors"><span class="key keyAuthors">Authors:</span> <div class="val valAuthors"><a href="http://erdani.com">Andrei Alexandrescu</a>, David Simcha,
and Jonathan M Davis. Credit for some of the ideas in building this module goes
to <a href="http://fantascienza.net/leonardo/so/">Leonardo Maffi</a>.</div></div>

<dl><dt class="d_decl"><a name=".isInputRange"></a><div class="quickindex" id="quickindex.isInputRange"></div>template <a name="isInputRange"></a><span class="ddoc_psymbol">isInputRange</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is an input range. An input range must
define the primitives <span class="d_inlinecode donthyphenate notranslate">empty</span>, <span class="d_inlinecode donthyphenate notranslate">popFront</span>, and <span class="d_inlinecode donthyphenate notranslate">front</span>. The
following code should compile for any input range.
</div>
<div class="description"><pre class="d_code notranslate">R r;              <span class="d_comment">// can define a range object
</span><span class="d_keyword">if</span> (r.empty) {}   <span class="d_comment">// can test for empty
</span>r.popFront();     <span class="d_comment">// can invoke popFront()
</span><span class="d_keyword">auto</span> h = r.front; <span class="d_comment">// can get the front of the range of non-void type
</span></pre>
<p></p>

The semantics of an input range (not checkable during compilation) are
assumed to be the following (<span class="d_inlinecode donthyphenate notranslate">r</span> is an object of type <span class="d_inlinecode donthyphenate notranslate">R</span>):
<p></p>

<ul><li><span class="d_inlinecode donthyphenate notranslate">r.empty</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> iff there is more data
available in the range.</li>  <li><span class="d_inlinecode donthyphenate notranslate">r.front</span> returns the current
element in the range. It may return by value or by reference. Calling
<span class="d_inlinecode donthyphenate notranslate">r.front</span> is allowed only if calling <span class="d_inlinecode donthyphenate notranslate">r.empty</span> has, or would
have, returned <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>.</li> <li><span class="d_inlinecode donthyphenate notranslate">r.popFront</span> advances to the next
element in the range. Calling <span class="d_inlinecode donthyphenate notranslate">r.popFront</span> is allowed only if
calling <span class="d_inlinecode donthyphenate notranslate">r.empty</span> has, or would have, returned <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>.</li></ul></div>

</dd>
<dt class="d_decl"><a name=".put"></a><div class="quickindex" id="quickindex.put"></div>void <a name="put"></a><span class="ddoc_psymbol">put</span>(R, E)(ref R <i>r</i>, E <i>e</i>);
</dt>
<dd><div class="summary">Outputs <span class="d_inlinecode donthyphenate notranslate">e</span> to <span class="d_inlinecode donthyphenate notranslate">r</span>. The exact effect is dependent upon the two
types. Several cases are accepted, as described below. The code snippets
are attempted in order, and the first to compile "wins" and gets
evaluated.
</div>
<div class="description">In this table "doPut" is a method that places <span class="d_inlinecode donthyphenate notranslate">e</span> into <span class="d_inlinecode donthyphenate notranslate">r</span>, using the
correct primitive: <span class="d_inlinecode donthyphenate notranslate">r.<a name="put"></a><span class="ddoc_psymbol">put</span>(e)</span> if <span class="d_inlinecode donthyphenate notranslate">R</span> defines <span class="d_inlinecode donthyphenate notranslate"><a name="put"></a><span class="ddoc_psymbol">put</span></span>, <span class="d_inlinecode donthyphenate notranslate">r.front = e</span>
if <span class="d_inlinecode donthyphenate notranslate">r</span> is an input range (followed by <span class="d_inlinecode donthyphenate notranslate">r.popFront()</span>), or <span class="d_inlinecode donthyphenate notranslate">r(e)</span>
otherwise.
<p></p>

<table class="book"><caption></caption>    <tr>        <th scope="col">Code Snippet</th>
        <th scope="col">Scenario</th>
    </tr>
    <tr>        <td><span class="d_inlinecode donthyphenate notranslate">r.doPut(e);</span></td>
        <td><span class="d_inlinecode donthyphenate notranslate">R</span> specifically accepts an <span class="d_inlinecode donthyphenate notranslate">E</span>.</td>
    </tr>
    <tr>        <td><span class="d_inlinecode donthyphenate notranslate">r.doPut([ e ]);</span></td>
        <td><span class="d_inlinecode donthyphenate notranslate">R</span> specifically accepts an <span class="d_inlinecode donthyphenate notranslate">E[]</span>.</td>
    </tr>
    <tr>        <td><span class="d_inlinecode donthyphenate notranslate">r.putChar(e);</span></td>
        <td><span class="d_inlinecode donthyphenate notranslate">R</span> accepts some form of string or character. <a name="put"></a><span class="ddoc_psymbol">put</span> will
            transcode the character <span class="d_inlinecode donthyphenate notranslate">e</span> accordingly.</td>
    </tr>
    <tr>        <td><span class="d_inlinecode donthyphenate notranslate">for (; !e.empty; e.popFront()) <a name="put"></a><span class="ddoc_psymbol">put</span>(r, e.front);</span></td>
        <td>Copying range <span class="d_inlinecode donthyphenate notranslate">E</span> into <span class="d_inlinecode donthyphenate notranslate">R</span>.</td>
    </tr>
</table>

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Tip:</span>
<span class="d_inlinecode donthyphenate notranslate"><a name="put"></a><span class="ddoc_psymbol">put</span></span> should <i>not</i> be used "UFCS-style", e.g. <span class="d_inlinecode donthyphenate notranslate">r.<a name="put"></a><span class="ddoc_psymbol">put</span>(e)</span>.
Doing this may call <span class="d_inlinecode donthyphenate notranslate">R.<a name="put"></a><span class="ddoc_psymbol">put</span></span> directly, by-passing any transformation
feature provided by <span class="d_inlinecode donthyphenate notranslate">Range.<a name="put"></a><span class="ddoc_psymbol">put</span></span>. <span class="d_inlinecode donthyphenate notranslate"><a name="put"></a><span class="ddoc_psymbol">put</span>(r, e)</span> is prefered.</div>

</dd>
<dt class="d_decl"><a name=".isOutputRange"></a><div class="quickindex" id="quickindex.isOutputRange"></div>template <a name="isOutputRange"></a><span class="ddoc_psymbol">isOutputRange</span>(R, E)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is an output range for elements of type
<span class="d_inlinecode donthyphenate notranslate">E</span>. An output range is defined functionally as a range that
supports the operation <span class="d_inlinecode donthyphenate notranslate">put(r, e)</span> as defined above.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">void</span> myprint(<span class="d_keyword">in</span> <span class="d_keyword">char</span>[] s) { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isOutputRange</span>!(<span class="d_keyword">typeof</span>(&amp;myprint), <span class="d_keyword">char</span>));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isOutputRange</span>!(<span class="d_keyword">char</span>[], <span class="d_keyword">char</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isOutputRange</span>!(<span class="d_keyword">dchar</span>[], <span class="d_keyword">wchar</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isOutputRange</span>!(<span class="d_keyword">dchar</span>[], <span class="d_keyword">dchar</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isForwardRange"></a><div class="quickindex" id="quickindex.isForwardRange"></div>template <a name="isForwardRange"></a><span class="ddoc_psymbol">isForwardRange</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is a forward range. A forward range is an
input range <span class="d_inlinecode donthyphenate notranslate">r</span> that can save "checkpoints" by saving <span class="d_inlinecode donthyphenate notranslate">r.save</span>
to another value of type <span class="d_inlinecode donthyphenate notranslate">R</span>. Notable examples of input ranges that
are <i>not</i> forward ranges are file/socket ranges; copying such a
range will not save the position in the stream, and they most likely
reuse an internal buffer as the entire stream does not sit in
memory. Subsequently, advancing either the original or the copy will
advance the stream, so the copies are not independent.
</div>
<div class="description">The following code should compile for any forward range.
<p></p>

<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isInputRange!R);
R r1;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span> (<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r1.save) == R));
</pre>
<p></p>

Saving a range is not duplicating it; in the example above, <span class="d_inlinecode donthyphenate notranslate">r1</span>
and <span class="d_inlinecode donthyphenate notranslate">r2</span> still refer to the same underlying data. They just
navigate that data independently.
<p></p>

The semantics of a forward range (not checkable during compilation)
are the same as for an input range, with the additional requirement
that backtracking must be possible by saving a copy of the range
object with <span class="d_inlinecode donthyphenate notranslate">save</span> and using it later.</div>

</dd>
<dt class="d_decl"><a name=".isBidirectionalRange"></a><div class="quickindex" id="quickindex.isBidirectionalRange"></div>template <a name="isBidirectionalRange"></a><span class="ddoc_psymbol">isBidirectionalRange</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is a bidirectional range. A bidirectional
range is a forward range that also offers the primitives <span class="d_inlinecode donthyphenate notranslate">back</span> and
<span class="d_inlinecode donthyphenate notranslate">popBack</span>. The following code should compile for any bidirectional
range.
</div>
<div class="description"><pre class="d_code notranslate">R r;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!R);           <span class="d_comment">// is forward range
</span>r.popBack();                               <span class="d_comment">// can invoke popBack
</span><span class="d_keyword">auto</span> t = r.back;                           <span class="d_comment">// can get the back of the range
</span><span class="d_keyword">auto</span> w = r.front;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(t) == <span class="d_keyword">typeof</span>(w))); <span class="d_comment">// same type for front and back
</span></pre>
<p></p>

The semantics of a bidirectional range (not checkable during
compilation) are assumed to be the following (<span class="d_inlinecode donthyphenate notranslate">r</span> is an object of
type <span class="d_inlinecode donthyphenate notranslate">R</span>):
<p></p>

<ul><li><span class="d_inlinecode donthyphenate notranslate">r.back</span> returns (possibly a reference to) the last
element in the range. Calling <span class="d_inlinecode donthyphenate notranslate">r.back</span> is allowed only if calling
<span class="d_inlinecode donthyphenate notranslate">r.empty</span> has, or would have, returned <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>.</li></ul></div>

</dd>
<dt class="d_decl"><a name=".isRandomAccessRange"></a><div class="quickindex" id="quickindex.isRandomAccessRange"></div>template <a name="isRandomAccessRange"></a><span class="ddoc_psymbol">isRandomAccessRange</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is a random-access range. A random-access
range is a bidirectional range that also offers the primitive <span class="d_inlinecode donthyphenate notranslate">opIndex</span>, OR an infinite forward range that offers <span class="d_inlinecode donthyphenate notranslate">opIndex</span>. In
either case, the range must either offer <span class="d_inlinecode donthyphenate notranslate">length</span> or be
infinite. The following code should compile for any random-access
range.
</div>
<div class="description"><pre class="d_code notranslate"><span class="d_comment">// range is finite and bidirectional or infinite and forward.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isBidirectionalRange!R ||
              isForwardRange!R &amp;&amp; isInfinite!R);

R r = <span class="d_keyword">void</span>;
<span class="d_keyword">auto</span> e = r[1]; <span class="d_comment">// can index
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(e) == <span class="d_keyword">typeof</span>(r.front))); <span class="d_comment">// same type for indexed and front
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isNarrowString!R); <span class="d_comment">// narrow strings cannot be indexed as ranges
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(hasLength!R || isInfinite!R); <span class="d_comment">// must have length or be infinite
</span>
<span class="d_comment">// $ must work as it does with arrays if opIndex works with $
</span><span class="d_keyword">static</span> <span class="d_keyword">if</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r[$])))
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r.front) == <span class="d_keyword">typeof</span>(r[$])));

    <span class="d_comment">// $ - 1 doesn't make sense with infinite ranges but needs to work
</span>    <span class="d_comment">// with finite ones.
</span>    <span class="d_keyword">static</span> <span class="d_keyword">if</span>(!isInfinite!R)
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r.front) == <span class="d_keyword">typeof</span>(r[$ - 1])));
}
</pre>
<p></p>

The semantics of a random-access range (not checkable during
compilation) are assumed to be the following (<span class="d_inlinecode donthyphenate notranslate">r</span> is an object of
type <span class="d_inlinecode donthyphenate notranslate">R</span>): <ul><li><span class="d_inlinecode donthyphenate notranslate">r.opIndex(n)</span> returns a reference to the
<span class="d_inlinecode donthyphenate notranslate">n</span>th element in the range.</li></ul>
<p></p>

Although <span class="d_inlinecode donthyphenate notranslate">char[]</span> and <span class="d_inlinecode donthyphenate notranslate">wchar[]</span> (as well as their qualified
versions including <span class="d_inlinecode donthyphenate notranslate">string</span> and <span class="d_inlinecode donthyphenate notranslate">wstring</span>) are arrays, <span class="d_inlinecode donthyphenate notranslate"><a name="isRandomAccessRange"></a><span class="ddoc_psymbol">isRandomAccessRange</span></span> yields <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> for them because they use
variable-length encodings (UTF-8 and UTF-16 respectively). These types
are bidirectional ranges only.</div>

</dd>
<dt class="d_decl"><a name=".hasMobileElements"></a><div class="quickindex" id="quickindex.hasMobileElements"></div>template <a name="hasMobileElements"></a><span class="ddoc_psymbol">hasMobileElements</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> iff <span class="d_inlinecode donthyphenate notranslate">R</span> supports the <span class="d_inlinecode donthyphenate notranslate">moveFront</span> primitive,
as well as <span class="d_inlinecode donthyphenate notranslate">moveBack</span> and <span class="d_inlinecode donthyphenate notranslate">moveAt</span> if it's a bidirectional or
random access range.  These may be explicitly implemented, or may work
via the default behavior of the module level functions <span class="d_inlinecode donthyphenate notranslate">moveFront</span>
and friends.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> HasPostblit
{
    <span class="d_keyword">this</span>(<span class="d_keyword">this</span>) {}
}

<span class="d_keyword">auto</span> nonMobile = map!<span class="d_string">"a"</span>(repeat(HasPostblit.init));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasMobileElements</span>!(<span class="d_keyword">typeof</span>(nonMobile)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasMobileElements</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasMobileElements</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasMobileElements</span>!(<span class="d_keyword">typeof</span>(iota(1000))));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ElementType"></a><div class="quickindex" id="quickindex.ElementType"></div>template <a name="ElementType"></a><span class="ddoc_psymbol">ElementType</span>(R)</dt>
<dd><div class="summary">The element type of <span class="d_inlinecode donthyphenate notranslate">R</span>. <span class="d_inlinecode donthyphenate notranslate">R</span> does not have to be a range. The
element type is determined as the type yielded by <span class="d_inlinecode donthyphenate notranslate">r.front</span> for an
object <span class="d_inlinecode donthyphenate notranslate">r</span> of type <span class="d_inlinecode donthyphenate notranslate">R</span>. For example, <span class="d_inlinecode donthyphenate notranslate"><a name="ElementType"></a><span class="ddoc_psymbol">ElementType</span>!(T[])</span> is
<span class="d_inlinecode donthyphenate notranslate">T</span> if <span class="d_inlinecode donthyphenate notranslate">T[]</span> isn't a narrow string; if it is, the element type is
<span class="d_inlinecode donthyphenate notranslate">dchar</span>. If <span class="d_inlinecode donthyphenate notranslate">R</span> doesn't have <span class="d_inlinecode donthyphenate notranslate">front</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="ElementType"></a><span class="ddoc_psymbol">ElementType</span>!R</span> is
<span class="d_inlinecode donthyphenate notranslate">void</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// Standard arrays: returns the type of the elements of the array
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementType</span>!(<span class="d_keyword">int</span>[]) == <span class="d_keyword">int</span>));

<span class="d_comment">// Accessing .front retrieves the decoded dchar
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementType</span>!(<span class="d_keyword">char</span>[])  == <span class="d_keyword">dchar</span>)); <span class="d_comment">// rvalue
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementType</span>!(<span class="d_keyword">dchar</span>[]) == <span class="d_keyword">dchar</span>)); <span class="d_comment">// lvalue
</span>
<span class="d_comment">// Ditto
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementType</span>!(string) == <span class="d_keyword">dchar</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementType</span>!(dstring) == <span class="d_keyword">immutable</span>(<span class="d_keyword">dchar</span>)));

<span class="d_comment">// For ranges it gets the type of .front.
</span><span class="d_keyword">auto</span> range = iota(0, 10);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementType</span>!(<span class="d_keyword">typeof</span>(range)) == <span class="d_keyword">int</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ElementEncodingType"></a><div class="quickindex" id="quickindex.ElementEncodingType"></div>template <a name="ElementEncodingType"></a><span class="ddoc_psymbol">ElementEncodingType</span>(R)</dt>
<dd><div class="summary">The encoding element type of <span class="d_inlinecode donthyphenate notranslate">R</span>. For narrow strings (<span class="d_inlinecode donthyphenate notranslate">char[]</span>,
<span class="d_inlinecode donthyphenate notranslate">wchar[]</span> and their qualified variants including <span class="d_inlinecode donthyphenate notranslate">string</span> and
<span class="d_inlinecode donthyphenate notranslate">wstring</span>), <span class="d_inlinecode donthyphenate notranslate"><a name="ElementEncodingType"></a><span class="ddoc_psymbol">ElementEncodingType</span></span> is the character type of the
string. For all other types, <span class="d_inlinecode donthyphenate notranslate"><a name="ElementEncodingType"></a><span class="ddoc_psymbol">ElementEncodingType</span></span> is the same as
<span class="d_inlinecode donthyphenate notranslate">ElementType</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// internally the range stores the encoded type
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementEncodingType</span>!(<span class="d_keyword">char</span>[])  == <span class="d_keyword">char</span>));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementEncodingType</span>!(wstring) == <span class="d_keyword">immutable</span>(<span class="d_keyword">wchar</span>)));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementEncodingType</span>!(<span class="d_keyword">byte</span>[]) == <span class="d_keyword">byte</span>));

<span class="d_keyword">auto</span> range = iota(0, 10);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ElementEncodingType</span>!(<span class="d_keyword">typeof</span>(range)) == <span class="d_keyword">int</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasSwappableElements"></a><div class="quickindex" id="quickindex.hasSwappableElements"></div>template <a name="hasSwappableElements"></a><span class="ddoc_psymbol">hasSwappableElements</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is a forward range and has swappable
elements. The following code should compile for any range
with swappable elements.
</div>
<div class="description"><pre class="d_code notranslate">R r;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!(R));   <span class="d_comment">// range is forward
</span>swap(r.front, r.front);              <span class="d_comment">// can swap elements of the range
</span></pre>
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSwappableElements</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSwappableElements</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSwappableElements</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSwappableElements</span>!(<span class="d_keyword">int</span>[]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasAssignableElements"></a><div class="quickindex" id="quickindex.hasAssignableElements"></div>template <a name="hasAssignableElements"></a><span class="ddoc_psymbol">hasAssignableElements</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is a forward range and has mutable
elements. The following code should compile for any range
with assignable elements.
</div>
<div class="description"><pre class="d_code notranslate">R r;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!R);  <span class="d_comment">// range is forward
</span><span class="d_keyword">auto</span> e = r.front;
r.front = e;                      <span class="d_comment">// can assign elements of the range
</span></pre>
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAssignableElements</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAssignableElements</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasAssignableElements</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAssignableElements</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasLvalueElements"></a><div class="quickindex" id="quickindex.hasLvalueElements"></div>template <a name="hasLvalueElements"></a><span class="ddoc_psymbol">hasLvalueElements</span>(R)</dt>
<dd><div class="summary">Tests whether <span class="d_inlinecode donthyphenate notranslate">R</span> has lvalue elements.  These are defined as elements that
can be passed by reference and have their address taken.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLvalueElements</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLvalueElements</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLvalueElements</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLvalueElements</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasLvalueElements</span>!(<span class="d_keyword">typeof</span>(iota(3))));

<span class="d_keyword">auto</span> c = chain([1, 2, 3], [4, 5, 6]);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLvalueElements</span>!(<span class="d_keyword">typeof</span>(c)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasLength"></a><div class="quickindex" id="quickindex.hasLength"></div>template <a name="hasLength"></a><span class="ddoc_psymbol">hasLength</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> has a <span class="d_inlinecode donthyphenate notranslate">length</span> member that returns an
integral type. <span class="d_inlinecode donthyphenate notranslate">R</span> does not have to be a range. Note that <span class="d_inlinecode donthyphenate notranslate">length</span> is an optional primitive as no range must implement it. Some
ranges do not store their length explicitly, some cannot compute it
without actually exhausting the range (e.g. socket streams), and some
other ranges may be infinite.
</div>
<div class="description">Although narrow string types (<span class="d_inlinecode donthyphenate notranslate">char[]</span>, <span class="d_inlinecode donthyphenate notranslate">wchar[]</span>, and their
qualified derivatives) do define a <span class="d_inlinecode donthyphenate notranslate">length</span> property, <span class="d_inlinecode donthyphenate notranslate"><a name="hasLength"></a><span class="ddoc_psymbol">hasLength</span></span> yields <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> for them. This is because a narrow
string's length does not reflect the number of characters, but instead
the number of encoding units, and as such is not useful with
range-oriented algorithms.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasLength</span>!(<span class="d_keyword">char</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLength</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLength</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]));

<span class="d_keyword">struct</span> A { <span class="d_keyword">ulong</span> length; }
<span class="d_keyword">struct</span> B { size_t length() { <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">struct</span> C { @property size_t length() { <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLength</span>!(A));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasLength</span>!(B));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasLength</span>!(C));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isInfinite"></a><div class="quickindex" id="quickindex.isInfinite"></div>template <a name="isInfinite"></a><span class="ddoc_psymbol">isInfinite</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> is an infinite input range. An
infinite input range is an input range that has a statically-defined
enumerated member called <span class="d_inlinecode donthyphenate notranslate">empty</span> that is always <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>,
for example:
</div>
<div class="description"><pre class="d_code notranslate"><span class="d_keyword">struct</span> MyInfiniteRange
{
    <span class="d_keyword">enum</span> <span class="d_keyword">bool</span> empty = <span class="d_keyword">false</span>;
    ...
}
</pre>
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isInfinite</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isInfinite</span>!(Repeat!(<span class="d_keyword">int</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasSlicing"></a><div class="quickindex" id="quickindex.hasSlicing"></div>template <a name="hasSlicing"></a><span class="ddoc_psymbol">hasSlicing</span>(R)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">R</span> offers a slicing operator with integral boundaries
that returns a forward range type.
</div>
<div class="description">For finite ranges, the result of <span class="d_inlinecode donthyphenate notranslate">opSlice</span> must be of the same type as the
original range type. If the range defines <span class="d_inlinecode donthyphenate notranslate">opDollar</span>, then it must support
subtraction.
<p></p>

For infinite ranges, when <i>not</i> using <span class="d_inlinecode donthyphenate notranslate">opDollar</span>, the result of
<span class="d_inlinecode donthyphenate notranslate">opSlice</span> must be the result of <a href="#take"><span class="d_inlinecode donthyphenate notranslate">take</span></a> or <a href="#takeExactly"><span class="d_inlinecode donthyphenate notranslate">takeExactly</span></a> on the
original range (they both return the same type for infinite ranges). However,
when using <span class="d_inlinecode donthyphenate notranslate">opDollar</span>, the result of <span class="d_inlinecode donthyphenate notranslate">opSlice</span> must be that of the
original range type.
<p></p>

The following code must compile for <span class="d_inlinecode donthyphenate notranslate"><a name="hasSlicing"></a><span class="ddoc_psymbol">hasSlicing</span></span> to be <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>:
<p></p>

<pre class="d_code notranslate">R r = <span class="d_keyword">void</span>;

<span class="d_keyword">static</span> <span class="d_keyword">if</span>(isInfinite!R)
    <span class="d_keyword">typeof</span>(take(r, 1)) s = r[1 .. 2];
<span class="d_keyword">else</span>
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r[1 .. 2]) == R));
    R s = r[1 .. 2];
}

s = r[1 .. 2];

<span class="d_keyword">static</span> <span class="d_keyword">if</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r[0 .. $])))
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r[0 .. $]) == R));
    R t = r[0 .. $];
    t = r[0 .. $];

    <span class="d_keyword">static</span> <span class="d_keyword">if</span>(!isInfinite!R)
    {
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(r[0 .. $ - 1]) == R));
        R u = r[0 .. $ - 1];
        u = r[0 .. $ - 1];
    }
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!(<span class="d_keyword">typeof</span>(r[1 .. 2])));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(hasLength!(<span class="d_keyword">typeof</span>(r[1 .. 2])));
</pre>
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSlicing</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSlicing</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSlicing</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSlicing</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSlicing</span>!(<span class="d_keyword">inout</span> <span class="d_keyword">int</span> []));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSlicing</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSlicing</span>!(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSlicing</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSlicing</span>!dstring);

<span class="d_keyword">enum</span> rangeFuncs = <span class="d_string">"@property int front();"</span> ~
                  <span class="d_string">"void popFront();"</span> ~
                  <span class="d_string">"@property bool empty();"</span> ~
                  <span class="d_string">"@property auto save() { return this; }"</span> ~
                  <span class="d_string">"@property size_t length();"</span>;

<span class="d_keyword">struct</span> A { <span class="d_keyword">mixin</span>(rangeFuncs); <span class="d_keyword">int</span> opSlice(size_t, size_t); }
<span class="d_keyword">struct</span> B { <span class="d_keyword">mixin</span>(rangeFuncs); B opSlice(size_t, size_t); }
<span class="d_keyword">struct</span> C { <span class="d_keyword">mixin</span>(rangeFuncs); @disable <span class="d_keyword">this</span>(); C opSlice(size_t, size_t); }
<span class="d_keyword">struct</span> D { <span class="d_keyword">mixin</span>(rangeFuncs); <span class="d_keyword">int</span>[] opSlice(size_t, size_t); }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSlicing</span>!(A));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSlicing</span>!(B));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasSlicing</span>!(C));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasSlicing</span>!(D));

<span class="d_keyword">struct</span> InfOnes
{
    <span class="d_keyword">enum</span> empty = <span class="d_keyword">false</span>;
    <span class="d_keyword">void</span> popFront() {}
    @property <span class="d_keyword">int</span> front() { <span class="d_keyword">return</span> 1; }
    @property InfOnes save() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>; }
    <span class="d_keyword">auto</span> opSlice(size_t i, size_t j) { <span class="d_keyword">return</span> takeExactly(<span class="d_keyword">this</span>, j - i); }
    <span class="d_keyword">auto</span> opSlice(size_t i, Dollar d) { <span class="d_keyword">return</span> <span class="d_keyword">this</span>; }

    <span class="d_keyword">struct</span> Dollar {}
    Dollar opDollar() <span class="d_keyword">const</span> { <span class="d_keyword">return</span> Dollar.init; }
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasSlicing</span>!InfOnes);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".walkLength"></a><div class="quickindex" id="quickindex.walkLength"></div>auto <a name="walkLength"></a><span class="ddoc_psymbol">walkLength</span>(Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; !isInfinite!Range);
<br><a name=".walkLength"></a><div class="quickindex" id="quickindex.walkLength"></div>auto <a name="walkLength"></a><span class="ddoc_psymbol">walkLength</span>(Range)(Range <i>range</i>, const size_t <i>upTo</i>) if (isInputRange!Range);
</dt>
<dd><div class="summary">This is a best-effort implementation of <span class="d_inlinecode donthyphenate notranslate">length</span> for any kind of
range.
</div>
<div class="description">If <span class="d_inlinecode donthyphenate notranslate">hasLength!Range</span>, simply returns <span class="d_inlinecode donthyphenate notranslate">range.length</span> without
checking <span class="d_inlinecode donthyphenate notranslate">upTo</span> (when specified).
<p></p>

Otherwise, walks the range through its length and returns the number
of elements seen. Performes <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">n</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">range.empty</span>
and <span class="d_inlinecode donthyphenate notranslate">range.popFront()</span>, where <span class="d_inlinecode donthyphenate notranslate">n</span> is the effective length of <span class="d_inlinecode donthyphenate notranslate">range</span>.
<p></p>

The <span class="d_inlinecode donthyphenate notranslate">upTo</span> parameter is useful to "cut the losses" in case
the interest is in seeing whether the range has at least some number
of elements. If the parameter <span class="d_inlinecode donthyphenate notranslate">upTo</span> is specified, stops if <span class="d_inlinecode donthyphenate notranslate">upTo</span> steps have been taken and returns <span class="d_inlinecode donthyphenate notranslate">upTo</span>.
<p></p>

Infinite ranges are compatible, provided the parameter <span class="d_inlinecode donthyphenate notranslate">upTo</span> is
specified, in which case the implementation simply returns upTo.</div>

</dd>
<dt class="d_decl"><a name=".retro"></a><div class="quickindex" id="quickindex.retro"></div>auto <a name="retro"></a><span class="ddoc_psymbol">retro</span>(Range)(Range <i>r</i>) if (isBidirectionalRange!(Unqual!Range));
</dt>
<dd><div class="summary">Iterates a bidirectional range backwards. The original range can be
accessed by using the <span class="d_inlinecode donthyphenate notranslate">source</span> property. Applying <a name="retro"></a><span class="ddoc_psymbol">retro</span> twice to
the same range yields the original range.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">retro</span>(a), [ 5, 4, 3, 2, 1 ][]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">retro</span>(a).source <span class="d_keyword">is</span> a);
<span class="d_keyword">assert</span>(<span class="d_psymbol">retro</span>(<span class="d_psymbol">retro</span>(a)) <span class="d_keyword">is</span> a);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".stride"></a><div class="quickindex" id="quickindex.stride"></div>auto <a name="stride"></a><span class="ddoc_psymbol">stride</span>(Range)(Range <i>r</i>, size_t <i>n</i>) if (isInputRange!(Unqual!Range));
</dt>
<dd><div class="summary">Iterates range <span class="d_inlinecode donthyphenate notranslate">r</span> with <a name="stride"></a><span class="ddoc_psymbol">stride</span> <span class="d_inlinecode donthyphenate notranslate">n</span>. If the range is a
random-access range, moves by indexing into the range; otherwise,
moves by successive calls to <span class="d_inlinecode donthyphenate notranslate">popFront</span>. Applying <a name="stride"></a><span class="ddoc_psymbol">stride</span> twice to
the same range results in a <a name="stride"></a><span class="ddoc_psymbol">stride</span> with a step that is the
product of the two applications.
</div>
<div class="keyval Throws"><span class="key keyThrows">Throws:</span> <div class="val valThrows"><span class="d_inlinecode donthyphenate notranslate">Exception</span> if <span class="d_inlinecode donthyphenate notranslate">n == 0</span>.

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">stride</span>(a, 3), [ 1, 4, 7, 10 ][]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">stride</span>(<span class="d_psymbol">stride</span>(a, 2), 3) == <span class="d_psymbol">stride</span>(a, 6));
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".chain"></a><div class="quickindex" id="quickindex.chain"></div>auto <a name="chain"></a><span class="ddoc_psymbol">chain</span>(Ranges...)(Ranges <i>rs</i>) if (Ranges.length &gt; 0 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Ranges)) &amp;&amp; !is(CommonType!(staticMap!(ElementType, staticMap!(Unqual, Ranges))) == void));
</dt>
<dd><div class="summary">Spans multiple ranges in sequence. The function <span class="d_inlinecode donthyphenate notranslate"><a name="chain"></a><span class="ddoc_psymbol">chain</span></span> takes any
number of ranges and returns a <span class="d_inlinecode donthyphenate notranslate">Chain!(R1, R2,...)</span> object. The
ranges may be different, but they must have the same element type. The
result is a range that offers the <span class="d_inlinecode donthyphenate notranslate">front</span>, <span class="d_inlinecode donthyphenate notranslate">popFront</span>, and <span class="d_inlinecode donthyphenate notranslate">empty</span> primitives. If all input ranges offer random access and <span class="d_inlinecode donthyphenate notranslate">length</span>, <span class="d_inlinecode donthyphenate notranslate">Chain</span> offers them as well.
</div>
<div class="description">If only one range is offered to <span class="d_inlinecode donthyphenate notranslate">Chain</span> or <span class="d_inlinecode donthyphenate notranslate"><a name="chain"></a><span class="ddoc_psymbol">chain</span></span>, the <span class="d_inlinecode donthyphenate notranslate">Chain</span> type exits the picture by aliasing itself directly to that
range's type.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] arr1 = [ 1, 2, 3, 4 ];
<span class="d_keyword">int</span>[] arr2 = [ 5, 6 ];
<span class="d_keyword">int</span>[] arr3 = [ 7 ];
<span class="d_keyword">auto</span> s = <span class="d_psymbol">chain</span>(arr1, arr2, arr3);
<span class="d_keyword">assert</span>(s.length == 7);
<span class="d_keyword">assert</span>(s[5] == 6);
<span class="d_keyword">assert</span>(equal(s, [1, 2, 3, 4, 5, 6, 7][]));
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".roundRobin"></a><div class="quickindex" id="quickindex.roundRobin"></div>auto <a name="roundRobin"></a><span class="ddoc_psymbol">roundRobin</span>(Rs...)(Rs <i>rs</i>) if (Rs.length &gt; 1 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Rs)));
</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><a name="roundRobin"></a><span class="ddoc_psymbol">roundRobin</span>(r1, r2, r3)</span> yields <span class="d_inlinecode donthyphenate notranslate">r1.front</span>, then <span class="d_inlinecode donthyphenate notranslate">r2.front</span>,
then <span class="d_inlinecode donthyphenate notranslate">r3.front</span>, after which it pops off one element from each and
continues again from <span class="d_inlinecode donthyphenate notranslate">r1</span>. For example, if two ranges are involved,
it alternately yields elements off the two ranges. <span class="d_inlinecode donthyphenate notranslate"><a name="roundRobin"></a><span class="ddoc_psymbol">roundRobin</span></span>
stops after it has consumed all ranges (skipping over the ones that
finish early).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3 ];
<span class="d_keyword">int</span>[] b = [ 10, 20, 30, 40 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">roundRobin</span>(a, b);
<span class="d_keyword">assert</span>(equal(r, [ 1, 10, 2, 20, 3, 30, 40 ]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".radial"></a><div class="quickindex" id="quickindex.radial"></div>auto <a name="radial"></a><span class="ddoc_psymbol">radial</span>(Range, I)(Range <i>r</i>, I <i>startingIndex</i>) if (isRandomAccessRange!(Unqual!Range) &amp;&amp; hasLength!(Unqual!Range) &amp;&amp; isIntegral!I);
<br><a name=".radial"></a><div class="quickindex" id="quickindex.radial"></div>auto <a name="radial"></a><span class="ddoc_psymbol">radial</span>(R)(R <i>r</i>) if (isRandomAccessRange!(Unqual!R) &amp;&amp; hasLength!(Unqual!R));
</dt>
<dd><div class="summary">Iterates a random-access range starting from a given point and
progressively extending left and right from that point. If no initial
point is given, iteration starts from the middle of the
range. Iteration spans the entire range.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">radial</span>(a), [ 3, 4, 2, 5, 1 ]));
a = [ 1, 2, 3, 4 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">radial</span>(a), [ 2, 3, 1, 4 ]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Take"></a><div class="quickindex" id="quickindex.Take"></div>struct <a name="Take"></a><span class="ddoc_psymbol">Take</span>(Range) if (isInputRange!(Unqual!Range) &amp;&amp; !(!isInfinite!(Unqual!Range) &amp;&amp; hasSlicing!(Unqual!Range) || is(Range T == <a name="Take"></a><span class="ddoc_psymbol">Take</span>!T)));
<br><a name=".take"></a><div class="quickindex" id="quickindex.take"></div>Take!R <a name="take"></a><span class="ddoc_psymbol">take</span>(R)(R <i>input</i>, size_t <i>n</i>) if (isInputRange!(Unqual!R) &amp;&amp; !isInfinite!(Unqual!R) &amp;&amp; hasSlicing!(Unqual!R));
</dt>
<dd><div class="summary">Lazily takes only up to <span class="d_inlinecode donthyphenate notranslate">n</span> elements of a range. This is
particularly useful when using with infinite ranges. If the range
offers random access and <span class="d_inlinecode donthyphenate notranslate">length</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="Take"></a><span class="ddoc_psymbol">Take</span></span> offers them as well.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] arr1 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
<span class="d_keyword">auto</span> s = <span class="d_psymbol">take</span>(arr1, 5);
<span class="d_keyword">assert</span>(s.length == 5);
<span class="d_keyword">assert</span>(s[4] == 5);
<span class="d_keyword">assert</span>(equal(s, [ 1, 2, 3, 4, 5 ][]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".takeExactly"></a><div class="quickindex" id="quickindex.takeExactly"></div>auto <a name="takeExactly"></a><span class="ddoc_psymbol">takeExactly</span>(R)(R <i>range</i>, size_t <i>n</i>) if (isInputRange!R);
</dt>
<dd><div class="summary">Similar to <a href="#take"><span class="d_inlinecode donthyphenate notranslate">take</span></a>, but assumes that <span class="d_inlinecode donthyphenate notranslate">range</span> has at least <span class="d_inlinecode donthyphenate notranslate">n</span> elements. Consequently, the result of <span class="d_inlinecode donthyphenate notranslate"><a name="takeExactly"></a><span class="ddoc_psymbol">takeExactly</span>(range, n)</span>
always defines the <span class="d_inlinecode donthyphenate notranslate">length</span> property (and initializes it to <span class="d_inlinecode donthyphenate notranslate">n</span>)
even when <span class="d_inlinecode donthyphenate notranslate">range</span> itself does not define <span class="d_inlinecode donthyphenate notranslate">length</span>.
</div>
<div class="description">The result of <span class="d_inlinecode donthyphenate notranslate"><a name="takeExactly"></a><span class="ddoc_psymbol">takeExactly</span></span> is identical to that of <a href="#take"><span class="d_inlinecode donthyphenate notranslate">take</span></a> in
cases where the original range defines <span class="d_inlinecode donthyphenate notranslate">length</span> or is infinite.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [ 1, 2, 3, 4, 5 ];

<span class="d_keyword">auto</span> b = <span class="d_psymbol">takeExactly</span>(a, 3);
<span class="d_keyword">assert</span>(equal(b, [1, 2, 3]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(b.length) == size_t));
<span class="d_keyword">assert</span>(b.length == 3);
<span class="d_keyword">assert</span>(b.front == 1);
<span class="d_keyword">assert</span>(b.back == 3);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".takeOne"></a><div class="quickindex" id="quickindex.takeOne"></div>auto <a name="takeOne"></a><span class="ddoc_psymbol">takeOne</span>(R)(R <i>source</i>) if (isInputRange!R);
</dt>
<dd><div class="summary">Returns a range with at most one element; for example, <span class="d_inlinecode donthyphenate notranslate"><a name="takeOne"></a><span class="ddoc_psymbol">takeOne</span>([42, 43, 44])</span> returns a range consisting of the integer <span class="d_inlinecode donthyphenate notranslate">42</span>. Calling <span class="d_inlinecode donthyphenate notranslate">popFront()</span> off that range renders it empty.
</div>
<div class="description">In effect <span class="d_inlinecode donthyphenate notranslate"><a name="takeOne"></a><span class="ddoc_psymbol">takeOne</span>(r)</span> is somewhat equivalent to <span class="d_inlinecode donthyphenate notranslate">take(r, 1)</span> but in
certain interfaces it is important to know statically that the range may only
have at most one element.
<p></p>

The type returned by <span class="d_inlinecode donthyphenate notranslate"><a name="takeOne"></a><span class="ddoc_psymbol">takeOne</span></span> is a random-access range with length
regardless of <span class="d_inlinecode donthyphenate notranslate">R</span>'s capabilities (another feature that distinguishes
<span class="d_inlinecode donthyphenate notranslate"><a name="takeOne"></a><span class="ddoc_psymbol">takeOne</span></span> from <span class="d_inlinecode donthyphenate notranslate">take</span>).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> s = <span class="d_psymbol">takeOne</span>([42, 43, 44]);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isRandomAccessRange!(<span class="d_keyword">typeof</span>(s)));
<span class="d_keyword">assert</span>(s.length == 1);
<span class="d_keyword">assert</span>(!s.empty);
<span class="d_keyword">assert</span>(s.front == 42);
s.front = 43;
<span class="d_keyword">assert</span>(s.front == 43);
<span class="d_keyword">assert</span>(s.back == 43);
<span class="d_keyword">assert</span>(s[0] == 43);
s.popFront();
<span class="d_keyword">assert</span>(s.length == 0);
<span class="d_keyword">assert</span>(s.empty);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".takeNone"></a><div class="quickindex" id="quickindex.takeNone"></div>auto <a name="takeNone"></a><span class="ddoc_psymbol">takeNone</span>(R)() if (isInputRange!R);
</dt>
<dd><div class="summary">Returns an empty range which is statically known to be empty and is
    guaranteed to have <span class="d_inlinecode donthyphenate notranslate">length</span> and be random access regardless of <span class="d_inlinecode donthyphenate notranslate">R</span>'s
    capabilities.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> range = <span class="d_psymbol">takeNone</span>!(<span class="d_keyword">int</span>[])();
<span class="d_keyword">assert</span>(range.length == 0);
<span class="d_keyword">assert</span>(range.empty);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".takeNone"></a><div class="quickindex" id="quickindex.takeNone"></div>auto <a name="takeNone"></a><span class="ddoc_psymbol">takeNone</span>(R)(R <i>range</i>) if (isInputRange!R);
</dt>
<dd><div class="summary">Creates an empty range from the given range in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">1</span>)</span>. If it can, it
    will return the same range type. If not, it will return
    <span class="d_inlinecode donthyphenate notranslate">takeExactly(range, 0)</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_psymbol">takeNone</span>([42, 27, 19]).empty);
<span class="d_keyword">assert</span>(<span class="d_psymbol">takeNone</span>(<span class="d_string">"dlang.org"</span>).empty);
<span class="d_keyword">assert</span>(<span class="d_psymbol">takeNone</span>(filter!<span class="d_string">"true"</span>([42, 27, 19])).empty);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".drop"></a><div class="quickindex" id="quickindex.drop"></div>R <a name="drop"></a><span class="ddoc_psymbol">drop</span>(R)(R <i>range</i>, size_t <i>n</i>) if (isInputRange!R);
<br><a name=".dropBack"></a><div class="quickindex" id="quickindex.dropBack"></div>R <a name="dropBack"></a><span class="ddoc_psymbol">dropBack</span>(R)(R <i>range</i>, size_t <i>n</i>) if (isBidirectionalRange!R);
</dt>
<dd><div class="summary">Convenience function which calls
    <span class="d_inlinecode donthyphenate notranslate">range.<a href="#popFrontN"><span class="d_inlinecode donthyphenate notranslate">popFrontN</span></a>(n)</span> and returns <span class="d_inlinecode donthyphenate notranslate">range</span>. <span class="d_inlinecode donthyphenate notranslate"><a name="drop"></a><span class="ddoc_psymbol">drop</span></span>
    makes it easier to pop elements from a range
    and then pass it to another function within a single expression,
    whereas <span class="d_inlinecode donthyphenate notranslate">popFrontN</span> would require multiple statements.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate">dropBack</span> provides the same functionality but instead calls
    <span class="d_inlinecode donthyphenate notranslate">range.popBackN(n)</span>.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
<span class="d_inlinecode donthyphenate notranslate"><a name="drop"></a><span class="ddoc_psymbol">drop</span></span> and <span class="d_inlinecode donthyphenate notranslate">dropBack</span> will only pop <i>up to</i>
    <span class="d_inlinecode donthyphenate notranslate">n</span> elements but will stop if the range is empty first.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>([0, 2, 1, 5, 0, 3].drop(3) == [5, 0, 3]);
<span class="d_keyword">assert</span>(<span class="d_string">"hello world"</span>.drop(6) == <span class="d_string">"world"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"hello world"</span>.drop(50).empty);
<span class="d_keyword">assert</span>(<span class="d_string">"hello world"</span>.take(6).drop(3).equal(<span class="d_string">"lo "</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".dropExactly"></a><div class="quickindex" id="quickindex.dropExactly"></div>R <a name="dropExactly"></a><span class="ddoc_psymbol">dropExactly</span>(R)(R <i>range</i>, size_t <i>n</i>) if (isInputRange!R);
<br><a name=".dropBackExactly"></a><div class="quickindex" id="quickindex.dropBackExactly"></div>R <a name="dropBackExactly"></a><span class="ddoc_psymbol">dropBackExactly</span>(R)(R <i>range</i>, size_t <i>n</i>) if (isBidirectionalRange!R);
</dt>
<dd><div class="summary">Similar to <a href="#drop"><span class="d_inlinecode donthyphenate notranslate">drop</span></a> and <span class="d_inlinecode donthyphenate notranslate">dropBack</span> but they call
    <span class="d_inlinecode donthyphenate notranslate">range.<a href="#popFrontExactly"><span class="d_inlinecode donthyphenate notranslate">popFrontExactly</span></a>(n)</span> and <span class="d_inlinecode donthyphenate notranslate">range.popBackExactly(n)</span>
    instead.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Unlike <span class="d_inlinecode donthyphenate notranslate">drop</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="dropExactly"></a><span class="ddoc_psymbol">dropExactly</span></span> will assume that the
    range holds at least <span class="d_inlinecode donthyphenate notranslate">n</span> elements. This makes <span class="d_inlinecode donthyphenate notranslate"><a name="dropExactly"></a><span class="ddoc_psymbol">dropExactly</span></span>
    faster than <span class="d_inlinecode donthyphenate notranslate">drop</span>, but it also means that if <span class="d_inlinecode donthyphenate notranslate">range</span> does
    not contain at least <span class="d_inlinecode donthyphenate notranslate">n</span> elements, it will attempt to call <span class="d_inlinecode donthyphenate notranslate">popFront</span>
    on an empty range, which is undefined behavior. So, only use
    <span class="d_inlinecode donthyphenate notranslate">popFrontExactly</span> when it is guaranteed that <span class="d_inlinecode donthyphenate notranslate">range</span> holds at least
    <span class="d_inlinecode donthyphenate notranslate">n</span> elements.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [1, 2, 3];
<span class="d_keyword">assert</span>(a.dropExactly(2) == [3]);
<span class="d_keyword">assert</span>(a.<span class="d_psymbol">dropBackExactly</span>(2) == [1]);

string s = <span class="d_string">""</span>;
<span class="d_keyword">assert</span>(s.dropExactly(2) == <span class="d_string">""</span>);
<span class="d_keyword">assert</span>(s.<span class="d_psymbol">dropBackExactly</span>(2) == <span class="d_string">""</span>);

<span class="d_keyword">auto</span> bd = filterBidirectional!<span class="d_string">"true"</span>([1, 2, 3]);
<span class="d_keyword">assert</span>(bd.dropExactly(2).equal([3]));
<span class="d_keyword">assert</span>(bd.<span class="d_psymbol">dropBackExactly</span>(2).equal([1]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".dropOne"></a><div class="quickindex" id="quickindex.dropOne"></div>R <a name="dropOne"></a><span class="ddoc_psymbol">dropOne</span>(R)(R <i>range</i>) if (isInputRange!R);
<br><a name=".dropBackOne"></a><div class="quickindex" id="quickindex.dropBackOne"></div>R <a name="dropBackOne"></a><span class="ddoc_psymbol">dropBackOne</span>(R)(R <i>range</i>) if (isBidirectionalRange!R);
</dt>
<dd><div class="summary">Convenience function which calls
    <span class="d_inlinecode donthyphenate notranslate">range.popFront()</span> and returns <span class="d_inlinecode donthyphenate notranslate">range</span>. <span class="d_inlinecode donthyphenate notranslate"><a name="dropOne"></a><span class="ddoc_psymbol">dropOne</span></span>
    makes it easier to pop an element from a range
    and then pass it to another function within a single expression,
    whereas <span class="d_inlinecode donthyphenate notranslate">popFront</span> would require multiple statements.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate">dropBackOne</span> provides the same functionality but instead calls
    <span class="d_inlinecode donthyphenate notranslate">range.popBack()</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.container : DList;

<span class="d_keyword">auto</span> dl = DList!<span class="d_keyword">int</span>(9, 1, 2, 3, 9);
<span class="d_keyword">assert</span>(dl[].dropOne().<span class="d_psymbol">dropBackOne</span>().equal([1, 2, 3]));

<span class="d_keyword">auto</span> a = [1, 2, 3];
<span class="d_keyword">assert</span>(a.dropOne() == [2, 3]);
<span class="d_keyword">assert</span>(a.<span class="d_psymbol">dropBackOne</span>() == [1, 2]);

string s = <span class="d_string">""</span>;
<span class="d_keyword">assert</span>(s.dropOne() == <span class="d_string">""</span>);
<span class="d_keyword">assert</span>(s.<span class="d_psymbol">dropBackOne</span>() == <span class="d_string">""</span>);

<span class="d_keyword">auto</span> bd = filterBidirectional!<span class="d_string">"true"</span>([1, 2, 3]);
<span class="d_keyword">assert</span>(bd.dropOne().equal([2, 3]));
<span class="d_keyword">assert</span>(bd.<span class="d_psymbol">dropBackOne</span>().equal([1, 2]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".popFrontN"></a><div class="quickindex" id="quickindex.popFrontN"></div>size_t <a name="popFrontN"></a><span class="ddoc_psymbol">popFrontN</span>(Range)(ref Range <i>r</i>, size_t <i>n</i>) if (isInputRange!Range);
<br><a name=".popBackN"></a><div class="quickindex" id="quickindex.popBackN"></div>size_t <a name="popBackN"></a><span class="ddoc_psymbol">popBackN</span>(Range)(ref Range <i>r</i>, size_t <i>n</i>) if (isBidirectionalRange!Range);
</dt>
<dd><div class="summary">Eagerly advances <span class="d_inlinecode donthyphenate notranslate">r</span> itself (not a copy) up to <span class="d_inlinecode donthyphenate notranslate">n</span> times (by
    calling <span class="d_inlinecode donthyphenate notranslate">r.popFront</span>). <span class="d_inlinecode donthyphenate notranslate"><a name="popFrontN"></a><span class="ddoc_psymbol">popFrontN</span></span> takes <span class="d_inlinecode donthyphenate notranslate">r</span> by <span class="d_inlinecode donthyphenate notranslate">ref</span>,
    so it mutates the original range. Completes in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">1</span>)</span> steps for ranges
    that support slicing and have length.
    Completes in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">n</span>)</span> time for all other ranges.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">How much <span class="d_inlinecode donthyphenate notranslate">r</span> was actually advanced, which may be less than <span class="d_inlinecode donthyphenate notranslate">n</span> if
    <span class="d_inlinecode donthyphenate notranslate">r</span> did not have at least <span class="d_inlinecode donthyphenate notranslate">n</span> elements.
<p></p>

    <span class="d_inlinecode donthyphenate notranslate">popBackN</span> will behave the same but instead removes elements from
    the back of the (bidirectional) range instead of the front.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5 ];
a.popFrontN(2);
<span class="d_keyword">assert</span>(a == [ 3, 4, 5 ]);
a.popFrontN(7);
<span class="d_keyword">assert</span>(a == [ ]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> LL = iota(1L, 7L);
<span class="d_keyword">auto</span> r = popFrontN(LL, 2);
<span class="d_keyword">assert</span>(equal(LL, [3L, 4L, 5L, 6L]));
<span class="d_keyword">assert</span>(r == 2);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5 ];
a.<span class="d_psymbol">popBackN</span>(2);
<span class="d_keyword">assert</span>(a == [ 1, 2, 3 ]);
a.<span class="d_psymbol">popBackN</span>(7);
<span class="d_keyword">assert</span>(a == [ ]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> LL = iota(1L, 7L);
<span class="d_keyword">auto</span> r = <span class="d_psymbol">popBackN</span>(LL, 2);
<span class="d_keyword">assert</span>(equal(LL, [1L, 2L, 3L, 4L]));
<span class="d_keyword">assert</span>(r == 2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".popFrontExactly"></a><div class="quickindex" id="quickindex.popFrontExactly"></div>void <a name="popFrontExactly"></a><span class="ddoc_psymbol">popFrontExactly</span>(Range)(ref Range <i>r</i>, size_t <i>n</i>) if (isInputRange!Range);
<br><a name=".popBackExactly"></a><div class="quickindex" id="quickindex.popBackExactly"></div>void <a name="popBackExactly"></a><span class="ddoc_psymbol">popBackExactly</span>(Range)(ref Range <i>r</i>, size_t <i>n</i>) if (isBidirectionalRange!Range);
</dt>
<dd><div class="summary">Eagerly advances <span class="d_inlinecode donthyphenate notranslate">r</span> itself (not a copy) exactly <span class="d_inlinecode donthyphenate notranslate">n</span> times (by
    calling <span class="d_inlinecode donthyphenate notranslate">r.popFront</span>). <span class="d_inlinecode donthyphenate notranslate"><a name="popFrontExactly"></a><span class="ddoc_psymbol">popFrontExactly</span></span> takes <span class="d_inlinecode donthyphenate notranslate">r</span> by <span class="d_inlinecode donthyphenate notranslate">ref</span>,
    so it mutates the original range. Completes in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">1</span>)</span> steps for ranges
    that support slicing, and have either length or are infinite.
    Completes in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">n</span>)</span> time for all other ranges.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Unlike <a href="#popFrontN"><span class="d_inlinecode donthyphenate notranslate">popFrontN</span></a>, <span class="d_inlinecode donthyphenate notranslate"><a name="popFrontExactly"></a><span class="ddoc_psymbol">popFrontExactly</span></span> will assume that the
    range holds at least <span class="d_inlinecode donthyphenate notranslate">n</span> elements. This makes <span class="d_inlinecode donthyphenate notranslate"><a name="popFrontExactly"></a><span class="ddoc_psymbol">popFrontExactly</span></span>
    faster than <span class="d_inlinecode donthyphenate notranslate">popFrontN</span>, but it also means that if <span class="d_inlinecode donthyphenate notranslate">range</span> does
    not contain at least <span class="d_inlinecode donthyphenate notranslate">n</span> elements, it will attempt to call <span class="d_inlinecode donthyphenate notranslate">popFront</span>
    on an empty range, which is undefined behavior. So, only use
    <span class="d_inlinecode donthyphenate notranslate"><a name="popFrontExactly"></a><span class="ddoc_psymbol">popFrontExactly</span></span> when it is guaranteed that <span class="d_inlinecode donthyphenate notranslate">range</span> holds at least
    <span class="d_inlinecode donthyphenate notranslate">n</span> elements.
<p></p>

    <span class="d_inlinecode donthyphenate notranslate">popBackExactly</span> will behave the same but instead removes elements from
    the back of the (bidirectional) range instead of the front.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [1, 2, 3];
a.popFrontExactly(1);
<span class="d_keyword">assert</span>(a == [2, 3]);
a.<span class="d_psymbol">popBackExactly</span>(1);
<span class="d_keyword">assert</span>(a == [2]);

string s = <span class="d_string">""</span>;
s.popFrontExactly(1);
<span class="d_keyword">assert</span>(s == <span class="d_string">""</span>);
s.<span class="d_psymbol">popBackExactly</span>(1);
<span class="d_keyword">assert</span>(s == <span class="d_string">""</span>);

<span class="d_keyword">auto</span> bd = filterBidirectional!<span class="d_string">"true"</span>([1, 2, 3]);
bd.popFrontExactly(1);
<span class="d_keyword">assert</span>(bd.equal([2, 3]));
bd.<span class="d_psymbol">popBackExactly</span>(1);
<span class="d_keyword">assert</span>(bd.equal([2]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Repeat"></a><div class="quickindex" id="quickindex.Repeat"></div>struct <a name="Repeat"></a><span class="ddoc_psymbol">Repeat</span>(T);
<br><a name=".repeat"></a><div class="quickindex" id="quickindex.repeat"></div>Repeat!T <a name="repeat"></a><span class="ddoc_psymbol">repeat</span>(T)(T <i>value</i>);
</dt>
<dd><div class="summary">Repeats one value forever.
</div>
<div class="description">Models an infinite bidirectional and random access range, with slicing.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(equal(5.<span class="d_psymbol">repeat</span>().take(4), [ 5, 5, 5, 5 ]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".repeat"></a><div class="quickindex" id="quickindex.repeat"></div>Take!(Repeat!T) <a name="repeat"></a><span class="ddoc_psymbol">repeat</span>(T)(T <i>value</i>, size_t <i>n</i>);
</dt>
<dd><div class="summary">Repeats <span class="d_inlinecode donthyphenate notranslate">value</span> exactly <span class="d_inlinecode donthyphenate notranslate">n</span> times. Equivalent to <span class="d_inlinecode donthyphenate notranslate">   take(<a name="repeat"></a><span class="ddoc_psymbol">repeat</span>(value), n)</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(equal(5.<span class="d_psymbol">repeat</span>(4), 5.<span class="d_psymbol">repeat</span>().take(4)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Cycle"></a><div class="quickindex" id="quickindex.Cycle"></div>struct <a name="Cycle"></a><span class="ddoc_psymbol">Cycle</span>(R) if (isForwardRange!R &amp;&amp; !isInfinite!R);
<br><a name=".cycle"></a><div class="quickindex" id="quickindex.cycle"></div>Cycle!R <a name="cycle"></a><span class="ddoc_psymbol">cycle</span>(R)(R <i>input</i>) if (isForwardRange!R &amp;&amp; !isInfinite!R);
<br><a name=".cycle"></a><div class="quickindex" id="quickindex.cycle"></div>Cycle!R <a name="cycle"></a><span class="ddoc_psymbol">cycle</span>(R)(R <i>input</i>, size_t <i>index</i> = 0) if (isRandomAccessRange!R &amp;&amp; !isInfinite!R);
</dt>
<dd><div class="summary">Repeats the given forward range ad infinitum. If the original range is
infinite (fact that would make <span class="d_inlinecode donthyphenate notranslate"><a name="Cycle"></a><span class="ddoc_psymbol">Cycle</span></span> the identity application),
<span class="d_inlinecode donthyphenate notranslate"><a name="Cycle"></a><span class="ddoc_psymbol">Cycle</span></span> detects that and aliases itself to the range type
itself. If the original range has random access, <span class="d_inlinecode donthyphenate notranslate"><a name="Cycle"></a><span class="ddoc_psymbol">Cycle</span></span> offers
random access and also offers a constructor taking an initial position
<span class="d_inlinecode donthyphenate notranslate">index</span>. <span class="d_inlinecode donthyphenate notranslate"><a name="Cycle"></a><span class="ddoc_psymbol">Cycle</span></span> works with static arrays in addition to ranges,
mostly for performance reasons.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Tip:</span>
This is a great way to implement simple circular buffers.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(equal(take(<span class="d_psymbol">cycle</span>([1, 2][]), 5), [ 1, 2, 1, 2, 1 ][]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Zip"></a><div class="quickindex" id="quickindex.Zip"></div>struct <a name="Zip"></a><span class="ddoc_psymbol">Zip</span>(Ranges...) if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges));
<br><a name=".zip"></a><div class="quickindex" id="quickindex.zip"></div>auto <a name="zip"></a><span class="ddoc_psymbol">zip</span>(Ranges...)(Ranges <i>ranges</i>) if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges));
<br><a name=".zip"></a><div class="quickindex" id="quickindex.zip"></div>auto <a name="zip"></a><span class="ddoc_psymbol">zip</span>(Ranges...)(StoppingPolicy <i>sp</i>, Ranges <i>ranges</i>) if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges));
</dt>
<dd><div class="summary">Iterate several ranges in lockstep. The element type is a proxy tuple
   that allows accessing the current element in the <span class="d_inlinecode donthyphenate notranslate">n</span>th range by
   using <span class="d_inlinecode donthyphenate notranslate">e[n]</span>.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [ 1, 2, 3 ];
string[] b = [ <span class="d_string">"a"</span>, <span class="d_string">"b"</span>, <span class="d_string">"c"</span> ];
<span class="d_comment">// prints 1:a 2:b 3:c
</span><span class="d_keyword">foreach</span> (e; zip(a, b))
{
write(e[0], ':', e[1], ' ');
}
</pre>
<p></p>

   <span class="d_inlinecode donthyphenate notranslate"><a name="Zip"></a><span class="ddoc_psymbol">Zip</span></span> offers the lowest range facilities of all components, e.g. it
   offers random access iff all ranges offer random access, and also
   offers mutation and swapping if all ranges offer it. Due to this, <span class="d_inlinecode donthyphenate notranslate">   <a name="Zip"></a><span class="ddoc_psymbol">Zip</span></span> is extremely powerful because it allows manipulating several
   ranges in lockstep. For example, the following code sorts two arrays
   in parallel:</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3 ];
string[] b = [ <span class="d_string">"a"</span>, <span class="d_string">"b"</span>, <span class="d_string">"c"</span> ];
sort!(<span class="d_string">"a[0] &gt; b[0]"</span>)(<span class="d_psymbol">zip</span>(a, b));
<span class="d_keyword">assert</span>(a == [ 3, 2, 1 ]);
<span class="d_keyword">assert</span>(b == [ <span class="d_string">"c"</span>, <span class="d_string">"b"</span>, <span class="d_string">"a"</span> ]);
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".Zip.this"></a><div class="quickindex" id="quickindex.Zip.this"></div>this(R <i>rs</i>, StoppingPolicy <i>s</i> = StoppingPolicy.shortest);
</dt>
<dd><div class="summary">Builds an object. Usually this is invoked indirectly by using the
   <a href="#zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a> function.</div>

</dd>
<dt class="d_decl"><a name=".Zip.empty"></a><div class="quickindex" id="quickindex.Zip.empty"></div>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>;
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if the range is at end. The test depends on the
   stopping policy.</div>

</dd>
<dt class="d_decl"><a name=".Zip.front"></a><div class="quickindex" id="quickindex.Zip.front"></div>@property ElementType <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd><div class="summary">Returns the current iterated element.</div>

</dd>
<dt class="d_decl"><a name=".Zip.front"></a><div class="quickindex" id="quickindex.Zip.front"></div>@property void <a name="front"></a><span class="ddoc_psymbol">front</span>(ElementType <i>v</i>);
</dt>
<dd><div class="summary">Sets the <a name="front"></a><span class="ddoc_psymbol">front</span> of all iterated ranges.</div>

</dd>
<dt class="d_decl"><a name=".Zip.moveFront"></a><div class="quickindex" id="quickindex.Zip.moveFront"></div>ElementType <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
</dt>
<dd><div class="summary">Moves out the front.</div>

</dd>
<dt class="d_decl"><a name=".Zip.back"></a><div class="quickindex" id="quickindex.Zip.back"></div>@property ElementType <a name="back"></a><span class="ddoc_psymbol">back</span>();
</dt>
<dd><div class="summary">Returns the rightmost element.</div>

</dd>
<dt class="d_decl"><a name=".Zip.moveBack"></a><div class="quickindex" id="quickindex.Zip.moveBack"></div>ElementType <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
</dt>
<dd><div class="summary">Moves out the back.
</div>
<div class="description">Returns the rightmost element.</div>

</dd>
<dt class="d_decl"><a name=".Zip.back"></a><div class="quickindex" id="quickindex.Zip.back"></div>@property void <a name="back"></a><span class="ddoc_psymbol">back</span>(ElementType <i>v</i>);
</dt>
<dd><div class="summary">Returns the current iterated element.
</div>
<div class="description">Returns the rightmost element.</div>

</dd>
<dt class="d_decl"><a name=".Zip.popFront"></a><div class="quickindex" id="quickindex.Zip.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><div class="summary">Advances to the next element in all controlled ranges.</div>

</dd>
<dt class="d_decl"><a name=".Zip.popBack"></a><div class="quickindex" id="quickindex.Zip.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</dt>
<dd><div class="summary">Calls <span class="d_inlinecode donthyphenate notranslate"><a name="popBack"></a><span class="ddoc_psymbol">popBack</span></span> for all controlled ranges.</div>

</dd>
<dt class="d_decl"><a name=".Zip.length"></a><div class="quickindex" id="quickindex.Zip.length"></div>@property auto <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd><div class="summary">Returns the <a name="length"></a><span class="ddoc_psymbol">length</span> of this range. Defined only if all ranges define
   <span class="d_inlinecode donthyphenate notranslate"><a name="length"></a><span class="ddoc_psymbol">length</span></span>.</div>

</dd>
<dt class="d_decl"><a name=".Zip.opDollar"></a><div class="quickindex" id="quickindex.Zip.opDollar"></div>alias <a name="opDollar"></a><span class="ddoc_psymbol">opDollar</span> = length;
</dt>
<dd><div class="summary">Returns the length of this range. Defined only if all ranges define
   <span class="d_inlinecode donthyphenate notranslate">length</span>.</div>

</dd>
<dt class="d_decl"><a name=".Zip.opSlice"></a><div class="quickindex" id="quickindex.Zip.opSlice"></div>auto <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>from</i>, size_t <i>to</i>);
</dt>
<dd><div class="summary">Returns a slice of the range. Defined only if all range define
   slicing.</div>

</dd>
<dt class="d_decl"><a name=".Zip.opIndex"></a><div class="quickindex" id="quickindex.Zip.opIndex"></div>ElementType <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>n</i>);
</dt>
<dd><div class="summary">Returns the <span class="d_inlinecode donthyphenate notranslate"><i>n</i></span>th element in the composite range. Defined if all
   ranges offer random access.</div>

</dd>
<dt class="d_decl"><a name=".Zip.opIndexAssign"></a><div class="quickindex" id="quickindex.Zip.opIndexAssign"></div>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(ElementType <i>v</i>, size_t <i>n</i>);
</dt>
<dd><div class="summary">Assigns to the <span class="d_inlinecode donthyphenate notranslate"><i>n</i></span>th element in the composite range. Defined if
   all ranges offer random access.
</div>
<div class="description">Returns the <span class="d_inlinecode donthyphenate notranslate"><i>n</i></span>th element in the composite range. Defined if all
   ranges offer random access.</div>

</dd>
<dt class="d_decl"><a name=".Zip.moveAt"></a><div class="quickindex" id="quickindex.Zip.moveAt"></div>ElementType <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>n</i>);
</dt>
<dd><div class="summary">Destructively reads the <span class="d_inlinecode donthyphenate notranslate"><i>n</i></span>th element in the composite
   range. Defined if all ranges offer random access.
</div>
<div class="description">Returns the <span class="d_inlinecode donthyphenate notranslate"><i>n</i></span>th element in the composite range. Defined if all
   ranges offer random access.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".StoppingPolicy"></a><div class="quickindex" id="quickindex.StoppingPolicy"></div>enum <a name="StoppingPolicy"></a><span class="ddoc_psymbol">StoppingPolicy</span>: int;
</dt>
<dd><div class="summary">Dictates how iteration in a <span class="d_inlinecode donthyphenate notranslate">Zip</span> should stop. By default stop at
   the end of the shortest of all ranges.</div>

<dl><dt class="d_decl"><a name=".StoppingPolicy.shortest"></a><div class="quickindex" id="quickindex.StoppingPolicy.shortest"></div><a name="shortest"></a><span class="ddoc_psymbol">shortest</span></dt>
<dd><div class="summary">Stop when the <a name="shortest"></a><span class="ddoc_psymbol">shortest</span> range is exhausted</div>

</dd>
<dt class="d_decl"><a name=".StoppingPolicy.longest"></a><div class="quickindex" id="quickindex.StoppingPolicy.longest"></div><a name="longest"></a><span class="ddoc_psymbol">longest</span></dt>
<dd><div class="summary">Stop when the <a name="longest"></a><span class="ddoc_psymbol">longest</span> range is exhausted</div>

</dd>
<dt class="d_decl"><a name=".StoppingPolicy.requireSameLength"></a><div class="quickindex" id="quickindex.StoppingPolicy.requireSameLength"></div><a name="requireSameLength"></a><span class="ddoc_psymbol">requireSameLength</span></dt>
<dd><div class="summary">Require that all ranges are equal</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Lockstep"></a><div class="quickindex" id="quickindex.Lockstep"></div>struct <a name="Lockstep"></a><span class="ddoc_psymbol">Lockstep</span>(Ranges...) if (Ranges.length &gt; 1 &amp;&amp; allSatisfy!(isInputRange, Ranges));
<br><a name=".lockstep"></a><div class="quickindex" id="quickindex.lockstep"></div>Lockstep!Ranges <a name="lockstep"></a><span class="ddoc_psymbol">lockstep</span>(Ranges...)(Ranges <i>ranges</i>) if (allSatisfy!(isInputRange, Ranges));
<br><a name=".lockstep"></a><div class="quickindex" id="quickindex.lockstep"></div>Lockstep!Ranges <a name="lockstep"></a><span class="ddoc_psymbol">lockstep</span>(Ranges...)(Ranges <i>ranges</i>, StoppingPolicy <i>s</i>) if (allSatisfy!(isInputRange, Ranges));
</dt>
<dd><div class="summary">Iterate multiple ranges in lockstep using a <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop.  If only a single
   range is passed in, the <span class="d_inlinecode donthyphenate notranslate"><a name="Lockstep"></a><span class="ddoc_psymbol">Lockstep</span></span> aliases itself away.  If the
   ranges are of different lengths and <span class="d_inlinecode donthyphenate notranslate">s</span> == <span class="d_inlinecode donthyphenate notranslate">StoppingPolicy.shortest</span>
   stop after the shortest range is empty.  If the ranges are of different
   lengths and <span class="d_inlinecode donthyphenate notranslate">s</span> == <span class="d_inlinecode donthyphenate notranslate">StoppingPolicy.requireSameLength</span>, throw an
   exception.  <span class="d_inlinecode donthyphenate notranslate">s</span> may not be <span class="d_inlinecode donthyphenate notranslate">StoppingPolicy.longest</span>, and passing this
   will throw an exception.
</div>
<div class="description">By default <span class="d_inlinecode donthyphenate notranslate">StoppingPolicy</span> is set to <span class="d_inlinecode donthyphenate notranslate">StoppingPolicy.shortest</span>.

</div>
<div class="keyval Bugs"><span class="key keyBugs">Bugs:</span> <div class="val valBugs">If a range does not offer lvalue access, but <span class="d_inlinecode donthyphenate notranslate">ref</span> is used in the
   <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop, it will be silently accepted but any modifications
   to the variable will not be propagated to the underlying range.
<p></p>

   // <a name="Lockstep"></a><span class="ddoc_psymbol">Lockstep</span> also supports iterating with an index variable:
</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">foreach</span>(index, a, b; lockstep(arr1, arr2)) {
    writefln(<span class="d_string">"Index %s:  a = %s, b = %s"</span>, index, a, b);
}
</pre>
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> arr1 = [1,2,3,4,5];
<span class="d_keyword">auto</span> arr2 = [6,7,8,9,10];

<span class="d_keyword">foreach</span>(<span class="d_keyword">ref</span> a, <span class="d_keyword">ref</span> b; <span class="d_psymbol">lockstep</span>(arr1, arr2))
{
    a += b;
}

<span class="d_keyword">assert</span>(arr1 == [7,9,11,13,15]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Recurrence"></a><div class="quickindex" id="quickindex.Recurrence"></div>struct <a name="Recurrence"></a><span class="ddoc_psymbol">Recurrence</span>(alias fun, StateType, size_t stateSize);
<br><a name=".recurrence"></a><div class="quickindex" id="quickindex.recurrence"></div>Recurrence!(fun, CommonType!State, State.length) <a name="recurrence"></a><span class="ddoc_psymbol">recurrence</span>(alias fun, State...)(State <i>initial</i>);
</dt>
<dd><div class="summary">Creates a mathematical sequence given the initial values and a
recurrence function that computes the next value from the existing
values. The sequence comes in the form of an infinite forward
range. The type <span class="d_inlinecode donthyphenate notranslate"><a name="Recurrence"></a><span class="ddoc_psymbol">Recurrence</span></span> itself is seldom used directly; most
often, recurrences are obtained by calling the function <span class="d_inlinecode donthyphenate notranslate">recurrence</span>.
</div>
<div class="description">When calling <span class="d_inlinecode donthyphenate notranslate">recurrence</span>, the function that computes the next
value is specified as a template argument, and the initial values in
the recurrence are passed as regular arguments. For example, in a
Fibonacci sequence, there are two initial values (and therefore a
state size of 2) because computing the next Fibonacci value needs the
past two values.
<p></p>

If the function is passed in string form, the state has name <span class="d_inlinecode donthyphenate notranslate">"a"</span>
and the zero-based index in the recurrence has name <span class="d_inlinecode donthyphenate notranslate">"n"</span>. The
given string must return the desired value for <span class="d_inlinecode donthyphenate notranslate">a[n]</span> given <span class="d_inlinecode donthyphenate notranslate">a[n
- 1]</span>, <span class="d_inlinecode donthyphenate notranslate">a[n - 2]</span>, <span class="d_inlinecode donthyphenate notranslate">a[n - 3]</span>,..., <span class="d_inlinecode donthyphenate notranslate">a[n - stateSize]</span>. The
state size is dictated by the number of arguments passed to the call
to <span class="d_inlinecode donthyphenate notranslate">recurrence</span>. The <span class="d_inlinecode donthyphenate notranslate"><a name="Recurrence"></a><span class="ddoc_psymbol">Recurrence</span></span> struct itself takes care of
managing the recurrence's state and shifting it appropriately.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_comment">// a[0] = 1, a[1] = 1, and compute a[n+1] = a[n-1] + a[n]
</span><span class="d_keyword">auto</span> fib = recurrence!(<span class="d_string">"a[n-1] + a[n-2]"</span>)(1, 1);
<span class="d_comment">// print the first 10 Fibonacci numbers
</span><span class="d_keyword">foreach</span> (e; take(fib, 10)) { writeln(e); }
<span class="d_comment">// print the first 10 factorials
</span><span class="d_keyword">foreach</span> (e; take(recurrence!(<span class="d_string">"a[n-1] * n"</span>)(1), 10)) { writeln(e); }
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".Sequence"></a><div class="quickindex" id="quickindex.Sequence"></div>struct <a name="Sequence"></a><span class="ddoc_psymbol">Sequence</span>(alias fun, State);
<br><a name=".sequence"></a><div class="quickindex" id="quickindex.sequence"></div>auto <a name="sequence"></a><span class="ddoc_psymbol">sequence</span>(alias fun, State...)(State <i>args</i>);
</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><a name="Sequence"></a><span class="ddoc_psymbol">Sequence</span></span> is similar to <span class="d_inlinecode donthyphenate notranslate">Recurrence</span> except that iteration is
   presented in the so-called <a href="http://en.wikipedia.org/wiki/Closed_form">   closed form</a>. This means that the <span class="d_inlinecode donthyphenate notranslate">n</span>th element in the series is
   computable directly from the initial values and <span class="d_inlinecode donthyphenate notranslate">n</span> itself. This
   implies that the interface offered by <span class="d_inlinecode donthyphenate notranslate"><a name="Sequence"></a><span class="ddoc_psymbol">Sequence</span></span> is a random-access
   range, as opposed to the regular <span class="d_inlinecode donthyphenate notranslate">Recurrence</span>, which only offers
   forward iteration.
</div>
<div class="description">The state of the sequence is stored as a <span class="d_inlinecode donthyphenate notranslate">Tuple</span> so it can be
   heterogeneous.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> odds = <span class="d_psymbol">sequence</span>!(<span class="d_string">"a[0] + n * a[1]"</span>)(1, 2);
<span class="d_keyword">assert</span>(odds.front == 1);
odds.popFront();
<span class="d_keyword">assert</span>(odds.front == 3);
odds.popFront();
<span class="d_keyword">assert</span>(odds.front == 5);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".iota"></a><div class="quickindex" id="quickindex.iota"></div>auto <a name="iota"></a><span class="ddoc_psymbol">iota</span>(B, E, S)(B <i>begin</i>, E <i>end</i>, S <i>step</i>) if ((isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))) &amp;&amp; isIntegral!S);
<br><a name=".iota"></a><div class="quickindex" id="quickindex.iota"></div>auto <a name="iota"></a><span class="ddoc_psymbol">iota</span>(B, E)(B <i>begin</i>, E <i>end</i>) if (isFloatingPoint!(CommonType!(B, E)));
<br><a name=".iota"></a><div class="quickindex" id="quickindex.iota"></div>auto <a name="iota"></a><span class="ddoc_psymbol">iota</span>(B, E)(B <i>begin</i>, E <i>end</i>) if (isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E)));
<br><a name=".iota"></a><div class="quickindex" id="quickindex.iota"></div>auto <a name="iota"></a><span class="ddoc_psymbol">iota</span>(E)(E <i>end</i>);
</dt>
<dd><div class="summary">Returns a range that goes through the numbers <span class="d_inlinecode donthyphenate notranslate">begin</span>, <span class="d_inlinecode donthyphenate notranslate">begin +
   step</span>, <span class="d_inlinecode donthyphenate notranslate">begin + 2 * step</span>, <span class="d_inlinecode donthyphenate notranslate">...</span>, up to and excluding <span class="d_inlinecode donthyphenate notranslate">   end</span>. The range offered is a random access range. The two-arguments
   version has <span class="d_inlinecode donthyphenate notranslate">step = 1</span>. If <span class="d_inlinecode donthyphenate notranslate">begin &lt; end &amp;&amp; step &lt; 0</span> or <span class="d_inlinecode donthyphenate notranslate">   begin &gt; end &amp;&amp; step &gt; 0</span> or <span class="d_inlinecode donthyphenate notranslate">begin == end</span>, then an empty range is
   returned.
</div>
<div class="keyval Throws"><span class="key keyThrows">Throws:</span> <div class="val valThrows"><span class="d_inlinecode donthyphenate notranslate">Exception</span> if <span class="d_inlinecode donthyphenate notranslate">begin != end &amp;&amp; step == 0</span>, an exception is
   thrown.</div></div>

</dd>
<dt class="d_decl"><a name=".TransverseOptions"></a><div class="quickindex" id="quickindex.TransverseOptions"></div>enum <a name="TransverseOptions"></a><span class="ddoc_psymbol">TransverseOptions</span>: int;
</dt>
<dd><div class="summary">Options for the <a href="#FrontTransversal"><span class="d_inlinecode donthyphenate notranslate">FrontTransversal</span></a> and <a href="#Transversal"><span class="d_inlinecode donthyphenate notranslate">Transversal</span></a> ranges
   (below).</div>

<dl><dt class="d_decl"><a name=".TransverseOptions.assumeJagged"></a><div class="quickindex" id="quickindex.TransverseOptions.assumeJagged"></div><a name="assumeJagged"></a><span class="ddoc_psymbol">assumeJagged</span></dt>
<dd><div class="summary">When transversed, the elements of a range of ranges are assumed to
   have different lengths (e.g. a jagged array).</div>

</dd>
<dt class="d_decl"><a name=".TransverseOptions.enforceNotJagged"></a><div class="quickindex" id="quickindex.TransverseOptions.enforceNotJagged"></div><a name="enforceNotJagged"></a><span class="ddoc_psymbol">enforceNotJagged</span></dt>
<dd><div class="summary">The transversal enforces that the elements of a range of ranges have
       all the same length (e.g. an array of arrays, all having the same
       length). Checking is done once upon construction of the transversal
       range.</div>

</dd>
<dt class="d_decl"><a name=".TransverseOptions.assumeNotJagged"></a><div class="quickindex" id="quickindex.TransverseOptions.assumeNotJagged"></div><a name="assumeNotJagged"></a><span class="ddoc_psymbol">assumeNotJagged</span></dt>
<dd><div class="summary">The transversal assumes, without verifying, that the elements of a
       range of ranges have all the same length. This option is useful if
       checking was already done from the outside of the range.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".FrontTransversal"></a><div class="quickindex" id="quickindex.FrontTransversal"></div>struct <a name="FrontTransversal"></a><span class="ddoc_psymbol">FrontTransversal</span>(Ror, TransverseOptions opt = TransverseOptions.assumeJagged);
<br><a name=".frontTransversal"></a><div class="quickindex" id="quickindex.frontTransversal"></div>FrontTransversal!(RangeOfRanges, opt) <a name="frontTransversal"></a><span class="ddoc_psymbol">frontTransversal</span>(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges <i>rr</i>);
</dt>
<dd><div class="summary">Given a range of ranges, iterate transversally through the first
   elements of each of the enclosed ranges.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[][] x = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][2];
x[0] = [1, 2];
x[1] = [3, 4];
<span class="d_keyword">auto</span> ror = <span class="d_psymbol">frontTransversal</span>(x);
<span class="d_keyword">assert</span>(equal(ror, [ 1, 3 ][]));
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".FrontTransversal.this"></a><div class="quickindex" id="quickindex.FrontTransversal.this"></div>this(RangeOfRanges <i>input</i>);
</dt>
<dd><div class="summary">Construction from an <i>input</i>.</div>

</dd>
<dt class="d_decl"><a name=".FrontTransversal.empty"></a><div class="quickindex" id="quickindex.FrontTransversal.empty"></div>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>;
<br><a name=".FrontTransversal.front"></a><div class="quickindex" id="quickindex.FrontTransversal.front"></div>@property ref auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".FrontTransversal.moveFront"></a><div class="quickindex" id="quickindex.FrontTransversal.moveFront"></div>ElementType <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
<br><a name=".FrontTransversal.popFront"></a><div class="quickindex" id="quickindex.FrontTransversal.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><div class="summary">Forward range primitives.</div>

</dd>
<dt class="d_decl"><a name=".FrontTransversal.save"></a><div class="quickindex" id="quickindex.FrontTransversal.save"></div>@property FrontTransversal <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><div class="summary">Duplicates this <span class="d_inlinecode donthyphenate notranslate">frontTransversal</span>. Note that only the encapsulating
   range of range will be duplicated. Underlying ranges will not be
   duplicated.</div>

</dd>
<dt class="d_decl"><a name=".FrontTransversal.back"></a><div class="quickindex" id="quickindex.FrontTransversal.back"></div>@property ref auto <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".FrontTransversal.popBack"></a><div class="quickindex" id="quickindex.FrontTransversal.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br><a name=".FrontTransversal.moveBack"></a><div class="quickindex" id="quickindex.FrontTransversal.moveBack"></div>ElementType <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
</dt>
<dd><div class="summary">Bidirectional primitives. They are offered if <span class="d_inlinecode donthyphenate notranslate">   isBidirectionalRange!RangeOfRanges</span>.</div>

</dd>
<dt class="d_decl"><a name=".FrontTransversal.opIndex"></a><div class="quickindex" id="quickindex.FrontTransversal.opIndex"></div>ref auto <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>n</i>);
<br><a name=".FrontTransversal.moveAt"></a><div class="quickindex" id="quickindex.FrontTransversal.moveAt"></div>ElementType <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>n</i>);
<br><a name=".FrontTransversal.opIndexAssign"></a><div class="quickindex" id="quickindex.FrontTransversal.opIndexAssign"></div>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(ElementType <i>val</i>, size_t <i>n</i>);
</dt>
<dd><div class="summary">Random-access primitive. It is offered if <span class="d_inlinecode donthyphenate notranslate">   isRandomAccessRange!RangeOfRanges &amp;&amp; (opt ==
   TransverseOptions.assumeNotJagged || opt ==
   TransverseOptions.enforceNotJagged)</span>.</div>

</dd>
<dt class="d_decl"><a name=".FrontTransversal.opSlice"></a><div class="quickindex" id="quickindex.FrontTransversal.opSlice"></div>typeof(this) <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>lower</i>, size_t <i>upper</i>);
</dt>
<dd><div class="summary">Slicing if offered if <span class="d_inlinecode donthyphenate notranslate">RangeOfRanges</span> supports slicing and all the
   conditions for supporting indexing are met.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Transversal"></a><div class="quickindex" id="quickindex.Transversal"></div>struct <a name="Transversal"></a><span class="ddoc_psymbol">Transversal</span>(Ror, TransverseOptions opt = TransverseOptions.assumeJagged);
<br><a name=".transversal"></a><div class="quickindex" id="quickindex.transversal"></div>Transversal!(RangeOfRanges, opt) <a name="transversal"></a><span class="ddoc_psymbol">transversal</span>(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges <i>rr</i>, size_t <i>n</i>);
</dt>
<dd><div class="summary">Given a range of ranges, iterate transversally through the the <span class="d_inlinecode donthyphenate notranslate">   n</span>th element of each of the enclosed ranges. All elements of the
   enclosing range must offer random access.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[][] x = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][2];
x[0] = [1, 2];
x[1] = [3, 4];
<span class="d_keyword">auto</span> ror = <span class="d_psymbol">transversal</span>(x, 1);
<span class="d_keyword">assert</span>(equal(ror, [ 2, 4 ][]));
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".Transversal.this"></a><div class="quickindex" id="quickindex.Transversal.this"></div>this(RangeOfRanges <i>input</i>, size_t <i>n</i>);
</dt>
<dd><div class="summary">Construction from an <i>input</i> and an index.</div>

</dd>
<dt class="d_decl"><a name=".Transversal.empty"></a><div class="quickindex" id="quickindex.Transversal.empty"></div>bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>;
<br><a name=".Transversal.front"></a><div class="quickindex" id="quickindex.Transversal.front"></div>@property ref auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Transversal.moveFront"></a><div class="quickindex" id="quickindex.Transversal.moveFront"></div>E <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
<br><a name=".Transversal.front"></a><div class="quickindex" id="quickindex.Transversal.front"></div>@property auto <a name="front"></a><span class="ddoc_psymbol">front</span>(E <i>val</i>);
<br><a name=".Transversal.popFront"></a><div class="quickindex" id="quickindex.Transversal.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".Transversal.save"></a><div class="quickindex" id="quickindex.Transversal.save"></div>@property typeof(this) <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><div class="summary">Forward range primitives.</div>

</dd>
<dt class="d_decl"><a name=".Transversal.back"></a><div class="quickindex" id="quickindex.Transversal.back"></div>@property ref auto <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".Transversal.popBack"></a><div class="quickindex" id="quickindex.Transversal.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br><a name=".Transversal.moveBack"></a><div class="quickindex" id="quickindex.Transversal.moveBack"></div>E <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
<br><a name=".Transversal.back"></a><div class="quickindex" id="quickindex.Transversal.back"></div>@property auto <a name="back"></a><span class="ddoc_psymbol">back</span>(E <i>val</i>);
</dt>
<dd><div class="summary">Bidirectional primitives. They are offered if <span class="d_inlinecode donthyphenate notranslate">   isBidirectionalRange!RangeOfRanges</span>.</div>

</dd>
<dt class="d_decl"><a name=".Transversal.opIndex"></a><div class="quickindex" id="quickindex.Transversal.opIndex"></div>ref auto <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>n</i>);
<br><a name=".Transversal.moveAt"></a><div class="quickindex" id="quickindex.Transversal.moveAt"></div>E <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>n</i>);
<br><a name=".Transversal.opIndexAssign"></a><div class="quickindex" id="quickindex.Transversal.opIndexAssign"></div>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(E <i>val</i>, size_t <i>n</i>);
<br><a name=".Transversal.length"></a><div class="quickindex" id="quickindex.Transversal.length"></div>@property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
<br><a name=".Transversal.opDollar"></a><div class="quickindex" id="quickindex.Transversal.opDollar"></div>alias <a name="opDollar"></a><span class="ddoc_psymbol">opDollar</span> = length;
</dt>
<dd><div class="summary">Random-access primitive. It is offered if <span class="d_inlinecode donthyphenate notranslate">   isRandomAccessRange!RangeOfRanges &amp;&amp; (opt ==
   TransverseOptions.assumeNotJagged || opt ==
   TransverseOptions.enforceNotJagged)</span>.</div>

</dd>
<dt class="d_decl"><a name=".Transversal.opSlice"></a><div class="quickindex" id="quickindex.Transversal.opSlice"></div>typeof(this) <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>lower</i>, size_t <i>upper</i>);
</dt>
<dd><div class="summary">Slicing if offered if <span class="d_inlinecode donthyphenate notranslate">RangeOfRanges</span> supports slicing and all the
   conditions for supporting indexing are met.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Indexed"></a><div class="quickindex" id="quickindex.Indexed"></div>struct <a name="Indexed"></a><span class="ddoc_psymbol">Indexed</span>(Source, Indices) if (isRandomAccessRange!Source &amp;&amp; isInputRange!Indices &amp;&amp; is(typeof(Source.init[ElementType!Indices.init])));
<br><a name=".indexed"></a><div class="quickindex" id="quickindex.indexed"></div>Indexed!(Source, Indices) <a name="indexed"></a><span class="ddoc_psymbol">indexed</span>(Source, Indices)(Source <i>source</i>, Indices <i>indices</i>);
</dt>
<dd><div class="summary">This struct takes two ranges, <span class="d_inlinecode donthyphenate notranslate">source</span> and <span class="d_inlinecode donthyphenate notranslate">indices</span>, and creates a view
of <span class="d_inlinecode donthyphenate notranslate">source</span> as if its elements were reordered according to <span class="d_inlinecode donthyphenate notranslate">indices</span>.
<span class="d_inlinecode donthyphenate notranslate">indices</span> may include only a subset of the elements of <span class="d_inlinecode donthyphenate notranslate">source</span> and
may also repeat elements.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate">Source</span> must be a random access range.  The returned range will be
bidirectional or random-access if <span class="d_inlinecode donthyphenate notranslate">Indices</span> is bidirectional or
random-access, respectively.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> source = [1, 2, 3, 4, 5];
<span class="d_keyword">auto</span> indices = [4, 3, 1, 2, 0, 4];
<span class="d_keyword">auto</span> ind = <span class="d_psymbol">indexed</span>(source, indices);
<span class="d_keyword">assert</span>(equal(ind, [5, 4, 2, 3, 1, 5]));
<span class="d_keyword">assert</span>(equal(retro(ind), [5, 1, 3, 2, 4, 5]));
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".Indexed.front"></a><div class="quickindex" id="quickindex.Indexed.front"></div>@property ref auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Indexed.popFront"></a><div class="quickindex" id="quickindex.Indexed.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".Indexed.save"></a><div class="quickindex" id="quickindex.Indexed.save"></div>@property typeof(this) <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br><a name=".Indexed.front"></a><div class="quickindex" id="quickindex.Indexed.front"></div>@property ref auto <a name="front"></a><span class="ddoc_psymbol">front</span>(ElementType!Source <i>newVal</i>);
<br><a name=".Indexed.moveFront"></a><div class="quickindex" id="quickindex.Indexed.moveFront"></div>auto <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
<br><a name=".Indexed.back"></a><div class="quickindex" id="quickindex.Indexed.back"></div>@property ref auto <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".Indexed.popBack"></a><div class="quickindex" id="quickindex.Indexed.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br><a name=".Indexed.back"></a><div class="quickindex" id="quickindex.Indexed.back"></div>@property ref auto <a name="back"></a><span class="ddoc_psymbol">back</span>(ElementType!Source <i>newVal</i>);
<br><a name=".Indexed.moveBack"></a><div class="quickindex" id="quickindex.Indexed.moveBack"></div>auto <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
<br><a name=".Indexed.length"></a><div class="quickindex" id="quickindex.Indexed.length"></div>@property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
<br><a name=".Indexed.opIndex"></a><div class="quickindex" id="quickindex.Indexed.opIndex"></div>ref auto <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>index</i>);
<br><a name=".Indexed.opSlice"></a><div class="quickindex" id="quickindex.Indexed.opSlice"></div>typeof(this) <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>a</i>, size_t <i>b</i>);
<br><a name=".Indexed.opIndexAssign"></a><div class="quickindex" id="quickindex.Indexed.opIndexAssign"></div>auto <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(ElementType!Source <i>newVal</i>, size_t <i>index</i>);
<br><a name=".Indexed.moveAt"></a><div class="quickindex" id="quickindex.Indexed.moveAt"></div>auto <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t <i>index</i>);
</dt>
<dd><div class="summary">Range primitives</div>

</dd>
<dt class="d_decl"><a name=".Indexed.source"></a><div class="quickindex" id="quickindex.Indexed.source"></div>@property Source <a name="source"></a><span class="ddoc_psymbol">source</span>();
</dt>
<dd><div class="summary">Returns the <a name="source"></a><span class="ddoc_psymbol">source</span> range.</div>

</dd>
<dt class="d_decl"><a name=".Indexed.indices"></a><div class="quickindex" id="quickindex.Indexed.indices"></div>@property Indices <a name="indices"></a><span class="ddoc_psymbol">indices</span>();
</dt>
<dd><div class="summary">Returns the <a name="indices"></a><span class="ddoc_psymbol">indices</span> range.</div>

</dd>
<dt class="d_decl"><a name=".Indexed.physicalIndex"></a><div class="quickindex" id="quickindex.Indexed.physicalIndex"></div>size_t <a name="physicalIndex"></a><span class="ddoc_psymbol">physicalIndex</span>(size_t <i>logicalIndex</i>);
</dt>
<dd><div class="summary">Returns the physical index into the source range corresponding to a
        given logical index.  This is useful, for example, when indexing
        an <span class="d_inlinecode donthyphenate notranslate">Indexed</span> without adding another layer of indirection.
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_keyword">auto</span> ind = indexed([1, 2, 3, 4, 5], [1, 3, 4]);
<span class="d_keyword">assert</span>(ind.<span class="d_psymbol">physicalIndex</span>(0) == 1);
</pre>
</div></div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Chunks"></a><div class="quickindex" id="quickindex.Chunks"></div>struct <a name="Chunks"></a><span class="ddoc_psymbol">Chunks</span>(Source) if (isForwardRange!Source);
<br><a name=".chunks"></a><div class="quickindex" id="quickindex.chunks"></div>Chunks!Source <a name="chunks"></a><span class="ddoc_psymbol">chunks</span>(Source)(Source <i>source</i>, size_t <i>chunkSize</i>) if (isForwardRange!Source);
</dt>
<dd><div class="summary">This range iterates over fixed-sized chunks of size <span class="d_inlinecode donthyphenate notranslate">chunkSize</span> of a
<span class="d_inlinecode donthyphenate notranslate">source</span> range. <span class="d_inlinecode donthyphenate notranslate">Source</span> must be a forward range.
</div>
<div class="description">If <span class="d_inlinecode donthyphenate notranslate">!isInfinite!Source</span> and <span class="d_inlinecode donthyphenate notranslate">source.walkLength</span> is not evenly
divisible by <span class="d_inlinecode donthyphenate notranslate">chunkSize</span>, the back element of this range will contain
fewer than <span class="d_inlinecode donthyphenate notranslate">chunkSize</span> elements.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
<span class="d_keyword">auto</span> <span class="d_psymbol">chunks</span> = <span class="d_psymbol">chunks</span>(source, 4);
<span class="d_keyword">assert</span>(<span class="d_psymbol">chunks</span>[0] == [1, 2, 3, 4]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">chunks</span>[1] == [5, 6, 7, 8]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">chunks</span>[2] == [9, 10]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">chunks</span>.back == <span class="d_psymbol">chunks</span>[2]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">chunks</span>.front == <span class="d_psymbol">chunks</span>[0]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">chunks</span>.length == 3);
<span class="d_keyword">assert</span>(equal(retro(array(<span class="d_psymbol">chunks</span>)), array(retro(<span class="d_psymbol">chunks</span>))));
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".Chunks.this"></a><div class="quickindex" id="quickindex.Chunks.this"></div>this(Source <i>source</i>, size_t <i>chunkSize</i>);
</dt>
<dd><div class="summary">Standard constructor</div>

</dd>
<dt class="d_decl"><a name=".Chunks.front"></a><div class="quickindex" id="quickindex.Chunks.front"></div>@property auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".Chunks.popFront"></a><div class="quickindex" id="quickindex.Chunks.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".Chunks.empty"></a><div class="quickindex" id="quickindex.Chunks.empty"></div>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".Chunks.save"></a><div class="quickindex" id="quickindex.Chunks.save"></div>@property typeof(this) <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><div class="summary">Forward range primitives. Always present.</div>

</dd>
<dt class="d_decl"><a name=".Chunks.length"></a><div class="quickindex" id="quickindex.Chunks.length"></div>@property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd><div class="summary">Length. Only if <span class="d_inlinecode donthyphenate notranslate">hasLength!Source</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span></div>

</dd>
<dt class="d_decl"><a name=".Chunks.opIndex"></a><div class="quickindex" id="quickindex.Chunks.opIndex"></div>auto <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>index</i>);
<br><a name=".Chunks.opSlice"></a><div class="quickindex" id="quickindex.Chunks.opSlice"></div>typeof(this) <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>lower</i>, size_t <i>upper</i>);
</dt>
<dd><div class="summary">Indexing and slicing operations. Provided only if
        <span class="d_inlinecode donthyphenate notranslate">hasSlicing!Source</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
<dt class="d_decl"><a name=".Chunks.back"></a><div class="quickindex" id="quickindex.Chunks.back"></div>@property auto <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".Chunks.popBack"></a><div class="quickindex" id="quickindex.Chunks.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</dt>
<dd><div class="summary">Bidirectional range primitives. Provided only if both
        <span class="d_inlinecode donthyphenate notranslate">hasSlicing!Source</span> and <span class="d_inlinecode donthyphenate notranslate">hasLength!Source</span> are <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".only"></a><div class="quickindex" id="quickindex.only"></div>auto <a name="only"></a><span class="ddoc_psymbol">only</span>(Values...)(auto ref Values <i>values</i>) if (!is(CommonType!Values == void) || Values.length == 0);
</dt>
<dd><div class="summary">Assemble <span class="d_inlinecode donthyphenate notranslate">values</span> into a range that carries all its
elements in-situ.
</div>
<div class="description">Useful when a single value or multiple disconnected values
must be passed to an algorithm expecting a range, without
having to perform dynamic memory allocation.
<p></p>

As copying the range means copying all elements, it can be
safely returned from functions. For the same reason, copying
the returned range may be expensive for a large number of arguments.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.uni;
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">only</span>(''), <span class="d_string">""</span>));
<span class="d_keyword">assert</span>([1, 2, 3, 4].findSplitBefore(<span class="d_psymbol">only</span>(3))[0] == [1, 2]);

<span class="d_keyword">assert</span>(<span class="d_psymbol">only</span>(<span class="d_string">"one"</span>, <span class="d_string">"two"</span>, <span class="d_string">"three"</span>).joiner(<span class="d_string">" "</span>).equal(<span class="d_string">"one two three"</span>));

string title = <span class="d_string">"The D Programming Language"</span>;
<span class="d_keyword">assert</span>(filter!isUpper(title).map!<span class="d_psymbol">only</span>().join(<span class="d_string">"."</span>) == <span class="d_string">"T.D.P.L"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".moveFront"></a><div class="quickindex" id="quickindex.moveFront"></div>ElementType!R <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>(R)(R <i>r</i>);
</dt>
<dd><div class="summary">Moves the front of <span class="d_inlinecode donthyphenate notranslate">r</span> out and returns it. Leaves <span class="d_inlinecode donthyphenate notranslate">r.front</span> in a
   destroyable state that does not allocate any resources (usually equal
   to its <span class="d_inlinecode donthyphenate notranslate">.init</span> value).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [ 1, 2, 3 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">moveFront</span>(a) == 1);

<span class="d_comment">// define a perfunctory input range
</span><span class="d_keyword">struct</span> InputRange
{
    @property <span class="d_keyword">bool</span> empty() { <span class="d_keyword">return</span> <span class="d_keyword">false</span>; }
    @property <span class="d_keyword">int</span> front() { <span class="d_keyword">return</span> 42; }
    <span class="d_keyword">void</span> popFront() {}
    <span class="d_keyword">int</span> <span class="d_psymbol">moveFront</span>() { <span class="d_keyword">return</span> 43; }
}
InputRange r;
<span class="d_keyword">assert</span>(<span class="d_psymbol">moveFront</span>(r) == 43);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".moveBack"></a><div class="quickindex" id="quickindex.moveBack"></div>ElementType!R <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>(R)(R <i>r</i>);
</dt>
<dd><div class="summary">Moves the back of <span class="d_inlinecode donthyphenate notranslate">r</span> out and returns it. Leaves <span class="d_inlinecode donthyphenate notranslate">r.back</span> in a
   destroyable state that does not allocate any resources (usually equal
   to its <span class="d_inlinecode donthyphenate notranslate">.init</span> value).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> TestRange
{
    <span class="d_keyword">int</span> payload = 5;
    @property <span class="d_keyword">bool</span> empty() { <span class="d_keyword">return</span> <span class="d_keyword">false</span>; }
    @property TestRange save() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>; }
    @property <span class="d_keyword">ref</span> <span class="d_keyword">int</span> front() { <span class="d_keyword">return</span> payload; }
    @property <span class="d_keyword">ref</span> <span class="d_keyword">int</span> back() { <span class="d_keyword">return</span> payload; }
    <span class="d_keyword">void</span> popFront() { }
    <span class="d_keyword">void</span> popBack() { }
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isBidirectionalRange!TestRange);
TestRange r;
<span class="d_keyword">auto</span> x = <span class="d_psymbol">moveBack</span>(r);
<span class="d_keyword">assert</span>(x == 5);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".moveAt"></a><div class="quickindex" id="quickindex.moveAt"></div>ElementType!R <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(R, I)(R <i>r</i>, I <i>i</i>) if (isIntegral!I);
</dt>
<dd><div class="summary">Moves element at index <span class="d_inlinecode donthyphenate notranslate">i</span> of <span class="d_inlinecode donthyphenate notranslate">r</span> out and returns it. Leaves <span class="d_inlinecode donthyphenate notranslate">   r.front</span> in a destroyable state that does not allocate any resources
   (usually equal to its <span class="d_inlinecode donthyphenate notranslate">.init</span> value).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [1,2,3,4];
<span class="d_keyword">foreach</span>(idx, it; a)
{
    <span class="d_keyword">assert</span>(it == <span class="d_psymbol">moveAt</span>(a, idx));
}
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".InputRange"></a><div class="quickindex" id="quickindex.InputRange"></div>interface <a name="InputRange"></a><span class="ddoc_psymbol">InputRange</span>(E);
</dt>
<dd><div class="summary">These interfaces are intended to provide virtual function-based wrappers
 around input ranges with element type E.  This is useful where a well-defined
 binary interface is required, such as when a DLL function or virtual function
 needs to accept a generic range as a parameter.  Note that
 <a href="#isInputRange"><span class="d_inlinecode donthyphenate notranslate">isInputRange</span></a> and friends check for conformance to structural
 interfaces, not for implementation of these <span class="d_inlinecode donthyphenate notranslate">interface</span> types.
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_keyword">void</span> useRange(<span class="d_psymbol">InputRange</span>!<span class="d_keyword">int</span> range) {
    <span class="d_comment">// Function body.
</span>}

<span class="d_comment">// Create a range type.
</span><span class="d_keyword">auto</span> squares = map!<span class="d_string">"a * a"</span>(iota(10));

<span class="d_comment">// Wrap it in an interface.
</span><span class="d_keyword">auto</span> squaresWrapped = inputRangeObject(squares);

<span class="d_comment">// Use it.
</span>useRange(squaresWrapped);
</pre>

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Limitations:</span>
These interfaces are not capable of forwarding <span class="d_inlinecode donthyphenate notranslate">ref</span> access to elements.
<p></p>

 Infiniteness of the wrapped range is not propagated.
<p></p>

 Length is not propagated in the case of non-random access ranges.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#inputRangeObject"><span class="d_inlinecode donthyphenate notranslate">inputRangeObject</span></a></div></div>

<dl><dt class="d_decl"><a name=".InputRange.front"></a><div class="quickindex" id="quickindex.InputRange.front"></div>@property E <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".InputRange.moveFront"></a><div class="quickindex" id="quickindex.InputRange.moveFront"></div>E <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".InputRange.popFront"></a><div class="quickindex" id="quickindex.InputRange.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".InputRange.empty"></a><div class="quickindex" id="quickindex.InputRange.empty"></div>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".InputRange.opApply"></a><div class="quickindex" id="quickindex.InputRange.opApply"></div>int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(int delegate(E));
<br><a name=".InputRange.opApply"></a><div class="quickindex" id="quickindex.InputRange.opApply"></div>int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(int delegate(size_t, E));
</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate">foreach</span> iteration uses <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>, since one delegate call per loop
 iteration is faster than three virtual function calls.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ForwardRange"></a><div class="quickindex" id="quickindex.ForwardRange"></div>interface <a name="ForwardRange"></a><span class="ddoc_psymbol">ForwardRange</span>(E): InputRange!E;
</dt>
<dd><div class="summary">Interface for a forward range of type <span class="d_inlinecode donthyphenate notranslate">E</span>.</div>

<dl><dt class="d_decl"><a name=".ForwardRange.save"></a><div class="quickindex" id="quickindex.ForwardRange.save"></div>@property ForwardRange!E <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".BidirectionalRange"></a><div class="quickindex" id="quickindex.BidirectionalRange"></div>interface <a name="BidirectionalRange"></a><span class="ddoc_psymbol">BidirectionalRange</span>(E): ForwardRange!E;
</dt>
<dd><div class="summary">Interface for a bidirectional range of type <span class="d_inlinecode donthyphenate notranslate">E</span>.</div>

<dl><dt class="d_decl"><a name=".BidirectionalRange.save"></a><div class="quickindex" id="quickindex.BidirectionalRange.save"></div>@property BidirectionalRange!E <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".BidirectionalRange.back"></a><div class="quickindex" id="quickindex.BidirectionalRange.back"></div>@property E <a name="back"></a><span class="ddoc_psymbol">back</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".BidirectionalRange.moveBack"></a><div class="quickindex" id="quickindex.BidirectionalRange.moveBack"></div>E <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".BidirectionalRange.popBack"></a><div class="quickindex" id="quickindex.BidirectionalRange.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".RandomAccessFinite"></a><div class="quickindex" id="quickindex.RandomAccessFinite"></div>interface <a name="RandomAccessFinite"></a><span class="ddoc_psymbol">RandomAccessFinite</span>(E): BidirectionalRange!E;
</dt>
<dd><div class="summary">Interface for a finite random access range of type <span class="d_inlinecode donthyphenate notranslate">E</span>.</div>

<dl><dt class="d_decl"><a name=".RandomAccessFinite.save"></a><div class="quickindex" id="quickindex.RandomAccessFinite.save"></div>@property RandomAccessFinite!E <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomAccessFinite.opIndex"></a><div class="quickindex" id="quickindex.RandomAccessFinite.opIndex"></div>E <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomAccessFinite.moveAt"></a><div class="quickindex" id="quickindex.RandomAccessFinite.moveAt"></div>E <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomAccessFinite.length"></a><div class="quickindex" id="quickindex.RandomAccessFinite.length"></div>@property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomAccessFinite.opDollar"></a><div class="quickindex" id="quickindex.RandomAccessFinite.opDollar"></div>alias <a name="opDollar"></a><span class="ddoc_psymbol">opDollar</span> = length;
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomAccessFinite.opSlice"></a><div class="quickindex" id="quickindex.RandomAccessFinite.opSlice"></div>RandomAccessFinite!E <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t, size_t);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".RandomAccessInfinite"></a><div class="quickindex" id="quickindex.RandomAccessInfinite"></div>interface <a name="RandomAccessInfinite"></a><span class="ddoc_psymbol">RandomAccessInfinite</span>(E): ForwardRange!E;
</dt>
<dd><div class="summary">Interface for an infinite random access range of type <span class="d_inlinecode donthyphenate notranslate">E</span>.</div>

<dl><dt class="d_decl"><a name=".RandomAccessInfinite.moveAt"></a><div class="quickindex" id="quickindex.RandomAccessInfinite.moveAt"></div>E <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(size_t);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomAccessInfinite.save"></a><div class="quickindex" id="quickindex.RandomAccessInfinite.save"></div>@property RandomAccessInfinite!E <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomAccessInfinite.opIndex"></a><div class="quickindex" id="quickindex.RandomAccessInfinite.opIndex"></div>E <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".InputAssignable"></a><div class="quickindex" id="quickindex.InputAssignable"></div>interface <a name="InputAssignable"></a><span class="ddoc_psymbol">InputAssignable</span>(E): InputRange!E;
</dt>
<dd><div class="summary">Adds assignable elements to InputRange.</div>

<dl><dt class="d_decl"><a name=".InputAssignable.front"></a><div class="quickindex" id="quickindex.InputAssignable.front"></div>@property void <a name="front"></a><span class="ddoc_psymbol">front</span>(E <i>newVal</i>);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ForwardAssignable"></a><div class="quickindex" id="quickindex.ForwardAssignable"></div>interface <a name="ForwardAssignable"></a><span class="ddoc_psymbol">ForwardAssignable</span>(E): InputAssignable!E, ForwardRange!E;
</dt>
<dd><div class="summary">Adds assignable elements to ForwardRange.</div>

<dl><dt class="d_decl"><a name=".ForwardAssignable.save"></a><div class="quickindex" id="quickindex.ForwardAssignable.save"></div>@property ForwardAssignable!E <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".BidirectionalAssignable"></a><div class="quickindex" id="quickindex.BidirectionalAssignable"></div>interface <a name="BidirectionalAssignable"></a><span class="ddoc_psymbol">BidirectionalAssignable</span>(E): ForwardAssignable!E, BidirectionalRange!E;
</dt>
<dd><div class="summary">Adds assignable elements to BidirectionalRange.</div>

<dl><dt class="d_decl"><a name=".BidirectionalAssignable.save"></a><div class="quickindex" id="quickindex.BidirectionalAssignable.save"></div>@property BidirectionalAssignable!E <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".BidirectionalAssignable.back"></a><div class="quickindex" id="quickindex.BidirectionalAssignable.back"></div>@property void <a name="back"></a><span class="ddoc_psymbol">back</span>(E <i>newVal</i>);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".RandomFiniteAssignable"></a><div class="quickindex" id="quickindex.RandomFiniteAssignable"></div>interface <a name="RandomFiniteAssignable"></a><span class="ddoc_psymbol">RandomFiniteAssignable</span>(E): RandomAccessFinite!E, BidirectionalAssignable!E;
</dt>
<dd><div class="summary">Adds assignable elements to RandomAccessFinite.</div>

<dl><dt class="d_decl"><a name=".RandomFiniteAssignable.save"></a><div class="quickindex" id="quickindex.RandomFiniteAssignable.save"></div>@property RandomFiniteAssignable!E <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RandomFiniteAssignable.opIndexAssign"></a><div class="quickindex" id="quickindex.RandomFiniteAssignable.opIndexAssign"></div>void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(E <i>val</i>, size_t <i>index</i>);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".OutputRange"></a><div class="quickindex" id="quickindex.OutputRange"></div>interface <a name="OutputRange"></a><span class="ddoc_psymbol">OutputRange</span>(E);
</dt>
<dd><div class="summary">Interface for an output range of type <span class="d_inlinecode donthyphenate notranslate">E</span>.  Usage is similar to the
 <span class="d_inlinecode donthyphenate notranslate">InputRange</span> interface and descendants.</div>

<dl><dt class="d_decl"><a name=".OutputRange.put"></a><div class="quickindex" id="quickindex.OutputRange.put"></div>void <a name="put"></a><span class="ddoc_psymbol">put</span>(E);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".OutputRangeObject"></a><div class="quickindex" id="quickindex.OutputRangeObject"></div>class <a name="OutputRangeObject"></a><span class="ddoc_psymbol">OutputRangeObject</span>(R, E...): staticMap!(OutputRange, E);
</dt>
<dd><div class="summary">Implements the <span class="d_inlinecode donthyphenate notranslate">OutputRange</span> interface for all types E and wraps the
 <span class="d_inlinecode donthyphenate notranslate">put</span> method for each type <span class="d_inlinecode donthyphenate notranslate">E</span> in a virtual function.</div>

</dd>
<dt class="d_decl"><a name=".MostDerivedInputRange"></a><div class="quickindex" id="quickindex.MostDerivedInputRange"></div>template <a name="MostDerivedInputRange"></a><span class="ddoc_psymbol">MostDerivedInputRange</span>(R) if (isInputRange!(Unqual!R))</dt>
<dd><div class="summary">Returns the interface type that best matches <span class="d_inlinecode donthyphenate notranslate">R</span>.</div>

</dd>
<dt class="d_decl"><a name=".InputRangeObject"></a><div class="quickindex" id="quickindex.InputRangeObject"></div>template <a name="InputRangeObject"></a><span class="ddoc_psymbol">InputRangeObject</span>(R) if (isInputRange!(Unqual!R))</dt>
<dd><div class="summary">Implements the most derived interface that <span class="d_inlinecode donthyphenate notranslate">R</span> works with and wraps
 all relevant range primitives in virtual functions.  If <span class="d_inlinecode donthyphenate notranslate">R</span> is already
 derived from the <span class="d_inlinecode donthyphenate notranslate">InputRange</span> interface, aliases itself away.</div>

</dd>
<dt class="d_decl"><a name=".inputRangeObject"></a><div class="quickindex" id="quickindex.inputRangeObject"></div>InputRangeObject!R <a name="inputRangeObject"></a><span class="ddoc_psymbol">inputRangeObject</span>(R)(R <i>range</i>) if (isInputRange!R);
</dt>
<dd><div class="summary">Convenience function for creating an <span class="d_inlinecode donthyphenate notranslate">InputRangeObject</span> of the proper type.
 See <a href="#InputRange"><span class="d_inlinecode donthyphenate notranslate">InputRange</span></a> for an example.</div>

</dd>
<dt class="d_decl"><a name=".outputRangeObject"></a><div class="quickindex" id="quickindex.outputRangeObject"></div>template <a name="outputRangeObject"></a><span class="ddoc_psymbol">outputRangeObject</span>(E...)</dt>
<dd><div class="summary">Convenience function for creating an <span class="d_inlinecode donthyphenate notranslate">OutputRangeObject</span> with a base range
 of type <span class="d_inlinecode donthyphenate notranslate">R</span> that accepts types <span class="d_inlinecode donthyphenate notranslate">E</span>.
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_keyword">uint</span>[] outputArray;
<span class="d_keyword">auto</span> app = appender(&amp;outputArray);
<span class="d_keyword">auto</span> appWrapped = <span class="d_psymbol">outputRangeObject</span>!(<span class="d_keyword">uint</span>, <span class="d_keyword">uint</span>[])(app);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(appWrapped) : OutputRange!(<span class="d_keyword">uint</span>[])));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(appWrapped) : OutputRange!(<span class="d_keyword">uint</span>)));
</pre>
</div></div>

<dl><dt class="d_decl"><a name=".outputRangeObject"></a><div class="quickindex" id="quickindex.outputRangeObject"></div>OutputRangeObject!(R, E) <a name="outputRangeObject"></a><span class="ddoc_psymbol">outputRangeObject</span>(R)(R <i>range</i>);
</dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".isTwoWayCompatible"></a><div class="quickindex" id="quickindex.isTwoWayCompatible"></div>template <a name="isTwoWayCompatible"></a><span class="ddoc_psymbol">isTwoWayCompatible</span>(alias fn, T1, T2)</dt>
<dd><div class="summary">  Returns <b>true</b> if <span class="d_inlinecode donthyphenate notranslate">fn</span> accepts variables of type T1 and T2 in any order.
  The following code should compile:
<pre class="d_code notranslate">T1 foo();
T2 bar();

fn(foo(), bar());
fn(bar(), foo());
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".SearchPolicy"></a><div class="quickindex" id="quickindex.SearchPolicy"></div>enum <a name="SearchPolicy"></a><span class="ddoc_psymbol">SearchPolicy</span>: int;
</dt>
<dd><div class="summary">Policy used with the searching primitives <span class="d_inlinecode donthyphenate notranslate">lowerBound</span>, <span class="d_inlinecode donthyphenate notranslate">   upperBound</span>, and <span class="d_inlinecode donthyphenate notranslate">equalRange</span> of <a href="#SortedRange"><span class="d_inlinecode donthyphenate notranslate">SortedRange</span></a> below.</div>

<dl><dt class="d_decl"><a name=".SearchPolicy.linear"></a><div class="quickindex" id="quickindex.SearchPolicy.linear"></div><a name="linear"></a><span class="ddoc_psymbol">linear</span></dt>
<dd><div class="summary">Searches in a <a name="linear"></a><span class="ddoc_psymbol">linear</span> fashion.</div>

</dd>
<dt class="d_decl"><a name=".SearchPolicy.trot"></a><div class="quickindex" id="quickindex.SearchPolicy.trot"></div><a name="trot"></a><span class="ddoc_psymbol">trot</span></dt>
<dd><div class="summary">Searches with a step that is grows linearly (1, 2, 3,...)
       leading to a quadratic search schedule (indexes tried are 0, 1,
       3, 6, 10, 15, 21, 28,...) Once the search overshoots its target,
       the remaining interval is searched using binary search. The
       search is completed in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">sqrt(n)</span>)</span> time. Use it when you
       are reasonably confident that the value is around the beginning
       of the range.</div>

</dd>
<dt class="d_decl"><a name=".SearchPolicy.gallop"></a><div class="quickindex" id="quickindex.SearchPolicy.gallop"></div><a name="gallop"></a><span class="ddoc_psymbol">gallop</span></dt>
<dd><div class="summary">Performs a <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=galloping search algorithm">galloping search algorithm</a>, i.e. searches
       with a step that doubles every time, (1, 2, 4, 8, ...)  leading
       to an exponential search schedule (indexes tried are 0, 1, 3,
       7, 15, 31, 63,...) Once the search overshoots its target, the
       remaining interval is searched using binary search. A value is
       found in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">log(n)</span>)</span> time.</div>

</dd>
<dt class="d_decl"><a name=".SearchPolicy.binarySearch"></a><div class="quickindex" id="quickindex.SearchPolicy.binarySearch"></div><a name="binarySearch"></a><span class="ddoc_psymbol">binarySearch</span></dt>
<dd><div class="summary">Searches using a classic interval halving policy. The search
       starts in the middle of the range, and each search step cuts
       the range in half. This policy finds a value in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">log(n)</span>)</span>
       time but is less cache friendly than <span class="d_inlinecode donthyphenate notranslate">gallop</span> for large
       ranges. The <span class="d_inlinecode donthyphenate notranslate"><a name="binarySearch"></a><span class="ddoc_psymbol">binarySearch</span></span> policy is used as the last step
       of <span class="d_inlinecode donthyphenate notranslate">trot</span>, <span class="d_inlinecode donthyphenate notranslate">gallop</span>, <span class="d_inlinecode donthyphenate notranslate">trotBackwards</span>, and <span class="d_inlinecode donthyphenate notranslate">       gallopBackwards</span> strategies.</div>

</dd>
<dt class="d_decl"><a name=".SearchPolicy.trotBackwards"></a><div class="quickindex" id="quickindex.SearchPolicy.trotBackwards"></div><a name="trotBackwards"></a><span class="ddoc_psymbol">trotBackwards</span></dt>
<dd><div class="summary">Similar to <span class="d_inlinecode donthyphenate notranslate">trot</span> but starts backwards. Use it when
       confident that the value is around the end of the range.</div>

</dd>
<dt class="d_decl"><a name=".SearchPolicy.gallopBackwards"></a><div class="quickindex" id="quickindex.SearchPolicy.gallopBackwards"></div><a name="gallopBackwards"></a><span class="ddoc_psymbol">gallopBackwards</span></dt>
<dd><div class="summary">Similar to <span class="d_inlinecode donthyphenate notranslate">gallop</span> but starts backwards. Use it when
       confident that the value is around the end of the range.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SortedRange"></a><div class="quickindex" id="quickindex.SortedRange"></div>struct <a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span>(Range, alias pred = "a &lt; b") if (isInputRange!Range);
</dt>
<dd><div class="summary">Represents a sorted range. In addition to the regular range
primitives, supports additional operations that take advantage of the
ordering, such as merge and binary search. To obtain a <span class="d_inlinecode donthyphenate notranslate"><a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span></span> from an unsorted range <span class="d_inlinecode donthyphenate notranslate">r</span>, use <span class="libref"><a href="http://dlang.org/phobos/std_algorithm.html#sort"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.sort</span></a></span> which sorts <span class="d_inlinecode donthyphenate notranslate">r</span> in place and returns the corresponding <span class="d_inlinecode donthyphenate notranslate"><a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span></span>. To construct a <span class="d_inlinecode donthyphenate notranslate"><a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span></span> from a range <span class="d_inlinecode donthyphenate notranslate">r</span> that
is known to be already sorted, use <a href="#assumeSorted"><span class="d_inlinecode donthyphenate notranslate">assumeSorted</span></a> described
below.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [ 1, 2, 3, 42, 52, 64 ];
<span class="d_keyword">auto</span> r = assumeSorted(a);
<span class="d_keyword">assert</span>(r.contains(3));
<span class="d_keyword">assert</span>(!r.contains(32));
<span class="d_keyword">auto</span> r1 = sort!<span class="d_string">"a &gt; b"</span>(a);
<span class="d_keyword">assert</span>(r1.contains(3));
<span class="d_keyword">assert</span>(!r1.contains(32));
<span class="d_keyword">assert</span>(r1.release() == [ 64, 52, 42, 3, 2, 1 ]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><span class="d_inlinecode donthyphenate notranslate"><a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span></span> could accept ranges weaker than random-access, but it
is unable to provide interesting functionality for them. Therefore,
<span class="d_inlinecode donthyphenate notranslate"><a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span></span> is currently restricted to random-access ranges.
<p></p>

No copy of the original range is ever made. If the underlying range is
changed concurrently with its corresponding <span class="d_inlinecode donthyphenate notranslate"><a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span></span> in ways
that break its sortedness, <span class="d_inlinecode donthyphenate notranslate"><a name="SortedRange"></a><span class="ddoc_psymbol">SortedRange</span></span> will work erratically.
<pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [ 1, 2, 3, 42, 52, 64 ];
<span class="d_keyword">auto</span> r = assumeSorted(a);
<span class="d_keyword">assert</span>(r.contains(42));
swap(a[3], a[5]);         <span class="d_comment">// illegal to break sortedness of original range
</span><span class="d_keyword">assert</span>(!r.contains(42));  <span class="d_comment">// passes although it shouldn't
</span></pre>
</div></div>
<dl><dt class="d_decl"><a name=".SortedRange.empty"></a><div class="quickindex" id="quickindex.SortedRange.empty"></div>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".SortedRange.save"></a><div class="quickindex" id="quickindex.SortedRange.save"></div>@property auto <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br><a name=".SortedRange.front"></a><div class="quickindex" id="quickindex.SortedRange.front"></div>@property ref auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".SortedRange.popFront"></a><div class="quickindex" id="quickindex.SortedRange.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
<br><a name=".SortedRange.back"></a><div class="quickindex" id="quickindex.SortedRange.back"></div>@property ref auto <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".SortedRange.popBack"></a><div class="quickindex" id="quickindex.SortedRange.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
<br><a name=".SortedRange.opIndex"></a><div class="quickindex" id="quickindex.SortedRange.opIndex"></div>ref auto <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(size_t <i>i</i>);
<br><a name=".SortedRange.opSlice"></a><div class="quickindex" id="quickindex.SortedRange.opSlice"></div>auto <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(size_t <i>a</i>, size_t <i>b</i>);
<br><a name=".SortedRange.length"></a><div class="quickindex" id="quickindex.SortedRange.length"></div>@property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
<br><a name=".SortedRange.opDollar"></a><div class="quickindex" id="quickindex.SortedRange.opDollar"></div>alias <a name="opDollar"></a><span class="ddoc_psymbol">opDollar</span> = length;
</dt>
<dd><div class="summary">Range primitives.</div>

</dd>
<dt class="d_decl"><a name=".SortedRange.release"></a><div class="quickindex" id="quickindex.SortedRange.release"></div>auto <a name="release"></a><span class="ddoc_psymbol">release</span>();
</dt>
<dd><div class="summary">Releases the controlled range and returns it.</div>

</dd>
<dt class="d_decl"><a name=".SortedRange.lowerBound"></a><div class="quickindex" id="quickindex.SortedRange.lowerBound"></div>auto <a name="lowerBound"></a><span class="ddoc_psymbol">lowerBound</span>(SearchPolicy sp = SearchPolicy.binarySearch, V)(V <i>value</i>) if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; hasSlicing!Range);
</dt>
<dd><div class="summary">This function uses a search with policy <span class="d_inlinecode donthyphenate notranslate">sp</span> to find the
   largest left subrange on which <span class="d_inlinecode donthyphenate notranslate">pred(x, value)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> for
   all <span class="d_inlinecode donthyphenate notranslate">x</span> (e.g., if <span class="d_inlinecode donthyphenate notranslate">pred</span> is "less than", returns the portion of
   the range with elements strictly smaller than <span class="d_inlinecode donthyphenate notranslate">value</span>). The search
   schedule and its complexity are documented in
   <a href="#SearchPolicy"><span class="d_inlinecode donthyphenate notranslate">SearchPolicy</span></a>.  See also STL's
   <a href="http://sgi.com/tech/stl/lower_bound.html">lower_bound</a>.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
<span class="d_keyword">auto</span> p = a.<span class="d_psymbol">lowerBound</span>(4);
<span class="d_keyword">assert</span>(equal(p, [ 0, 1, 2, 3 ]));
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".SortedRange.upperBound"></a><div class="quickindex" id="quickindex.SortedRange.upperBound"></div>auto <a name="upperBound"></a><span class="ddoc_psymbol">upperBound</span>(SearchPolicy sp = SearchPolicy.binarySearch, V)(V <i>value</i>) if (isTwoWayCompatible!(predFun, ElementType!Range, V));
</dt>
<dd><div class="summary">This function searches with policy <span class="d_inlinecode donthyphenate notranslate">sp</span> to find the largest right
subrange on which <span class="d_inlinecode donthyphenate notranslate">pred(value, x)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> for all <span class="d_inlinecode donthyphenate notranslate">x</span>
(e.g., if <span class="d_inlinecode donthyphenate notranslate">pred</span> is "less than", returns the portion of the range
with elements strictly greater than <span class="d_inlinecode donthyphenate notranslate">value</span>). The search schedule
and its complexity are documented in <a href="#SearchPolicy"><span class="d_inlinecode donthyphenate notranslate">SearchPolicy</span></a>.
</div>
<div class="description">For ranges that do not offer random access, <span class="d_inlinecode donthyphenate notranslate">SearchPolicy.linear</span>
is the only policy allowed (and it must be specified explicitly lest it exposes
user code to unexpected inefficiencies). For random-access searches, all
policies are allowed, and <span class="d_inlinecode donthyphenate notranslate">SearchPolicy.binarySearch</span> is the default.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso">STL's <a href="http://sgi.com/tech/stl/lower_bound.html">upper_bound</a>.

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);
<span class="d_keyword">auto</span> p = a.<span class="d_psymbol">upperBound</span>(3);
<span class="d_keyword">assert</span>(equal(p, [4, 4, 5, 6]));
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".SortedRange.equalRange"></a><div class="quickindex" id="quickindex.SortedRange.equalRange"></div>auto <a name="equalRange"></a><span class="ddoc_psymbol">equalRange</span>(V)(V <i>value</i>) if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; isRandomAccessRange!Range);
</dt>
<dd><div class="summary">Returns the subrange containing all elements <span class="d_inlinecode donthyphenate notranslate">e</span> for which both <span class="d_inlinecode donthyphenate notranslate">   pred(e, value)</span> and <span class="d_inlinecode donthyphenate notranslate">pred(value, e)</span> evaluate to <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> (e.g.,
   if <span class="d_inlinecode donthyphenate notranslate">pred</span> is "less than", returns the portion of the range with
   elements equal to <span class="d_inlinecode donthyphenate notranslate">value</span>). Uses a classic binary search with
   interval halving until it finds a value that satisfies the condition,
   then uses <span class="d_inlinecode donthyphenate notranslate">SearchPolicy.gallopBackwards</span> to find the left boundary
   and <span class="d_inlinecode donthyphenate notranslate">SearchPolicy.gallop</span> to find the right boundary. These
   policies are justified by the fact that the two boundaries are likely
   to be near the first found value (i.e., equal ranges are relatively
   small). Completes the entire search in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">log(n)</span>)</span> time. See also
   STL's <a href="http://sgi.com/tech/stl/equal_range.html">equal_range</a>.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">equalRange</span>(a, 3);
<span class="d_keyword">assert</span>(equal(r, [ 3, 3, 3 ]));
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".SortedRange.trisect"></a><div class="quickindex" id="quickindex.SortedRange.trisect"></div>auto <a name="trisect"></a><span class="ddoc_psymbol">trisect</span>(V)(V <i>value</i>) if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; isRandomAccessRange!Range);
</dt>
<dd><div class="summary">Returns a tuple <span class="d_inlinecode donthyphenate notranslate">r</span> such that <span class="d_inlinecode donthyphenate notranslate">r[0]</span> is the same as the result
of <span class="d_inlinecode donthyphenate notranslate">lowerBound(value)</span>, <span class="d_inlinecode donthyphenate notranslate">r[1]</span> is the same as the result of <span class="d_inlinecode donthyphenate notranslate">equalRange(value)</span>, and <span class="d_inlinecode donthyphenate notranslate">r[2]</span> is the same as the result of <span class="d_inlinecode donthyphenate notranslate">upperBound(value)</span>. The call is faster than computing all three
separately. Uses a search schedule similar to <span class="d_inlinecode donthyphenate notranslate">equalRange</span>. Completes the entire search in <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">log(n)</span>)</span> time.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
<span class="d_keyword">auto</span> r = assumeSorted(a).<span class="d_psymbol">trisect</span>(3);
<span class="d_keyword">assert</span>(equal(r[0], [ 1, 2 ]));
<span class="d_keyword">assert</span>(equal(r[1], [ 3, 3, 3 ]));
<span class="d_keyword">assert</span>(equal(r[2], [ 4, 4, 5, 6 ]));
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".SortedRange.contains"></a><div class="quickindex" id="quickindex.SortedRange.contains"></div>bool <a name="contains"></a><span class="ddoc_psymbol">contains</span>(V)(V <i>value</i>) if (isRandomAccessRange!Range);
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">value</span> can be found in <span class="d_inlinecode donthyphenate notranslate">range</span>, which is assumed to be sorted. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">log(r.length)</span>)</span>
evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>. See also STL's <a href="http://sgi.com/tech/stl/binary_search.html">binary_search</a>.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".assumeSorted"></a><div class="quickindex" id="quickindex.assumeSorted"></div>auto <a name="assumeSorted"></a><span class="ddoc_psymbol">assumeSorted</span>(alias pred = "a &lt; b", R)(R <i>r</i>) if (isInputRange!(Unqual!R));
</dt>
<dd><div class="summary">Assumes <span class="d_inlinecode donthyphenate notranslate">r</span> is sorted by predicate <span class="d_inlinecode donthyphenate notranslate">pred</span> and returns the
corresponding <span class="d_inlinecode donthyphenate notranslate">SortedRange!(pred, R)</span> having <span class="d_inlinecode donthyphenate notranslate">r</span> as support. To
keep the checking costs low, the cost is <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">1</span>)</span> in release mode
(no checks for sortedness are performed). In debug mode, a few random
elements of <span class="d_inlinecode donthyphenate notranslate">r</span> are checked for sortedness. The size of the sample
is proportional <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">log(r.length)</span>)</span>. That way, checking has no
effect on the complexity of subsequent operations specific to sorted
ranges (such as binary search). The probability of an arbitrary
unsorted range failing the test is very high (however, an
almost-sorted range is likely to pass it). To check for sortedness at
cost <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">n</span>)</span>, use <span class="libref"><a href="http://dlang.org/phobos/std_algorithm.html#isSorted"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.isSorted</span></a></span>.</div>

</dd>
<dt class="d_decl"><a name=".RefRange"></a><div class="quickindex" id="quickindex.RefRange"></div>struct <a name="RefRange"></a><span class="ddoc_psymbol">RefRange</span>(R) if (isForwardRange!R);
</dt>
<dd><div class="summary">Wrapper which effectively makes it possible to pass a range by reference.
    Both the original range and the <a name="RefRange"></a><span class="ddoc_psymbol">RefRange</span> will always have the exact same
    elements. Any operation done on one will affect the other. So, for instance,
    if it's passed to a function which would implicitly copy the original range
    if it were passed to it, the original range is <i>not</i> copied but is
    consumed as if it were a reference type.
</div>
<div class="description">Note that <span class="d_inlinecode donthyphenate notranslate">save</span> works as normal and operates on a new range, so if
    <span class="d_inlinecode donthyphenate notranslate">save</span> is ever called on the <a name="RefRange"></a><span class="ddoc_psymbol">RefRange</span>, then no operations on the saved
    range will affect the original.

</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_keyword">import</span> std.algorithm;
<span class="d_keyword">ubyte</span>[] buffer = [1, 9, 45, 12, 22];
<span class="d_keyword">auto</span> found1 = find(buffer, 45);
<span class="d_keyword">assert</span>(found1 == [45, 12, 22]);
<span class="d_keyword">assert</span>(buffer == [1, 9, 45, 12, 22]);

<span class="d_keyword">auto</span> wrapped1 = refRange(&amp;buffer);
<span class="d_keyword">auto</span> found2 = find(wrapped1, 45);
<span class="d_keyword">assert</span>(*found2.ptr == [45, 12, 22]);
<span class="d_keyword">assert</span>(buffer == [45, 12, 22]);

<span class="d_keyword">auto</span> found3 = find(wrapped2.save, 22);
<span class="d_keyword">assert</span>(*found3.ptr == [22]);
<span class="d_keyword">assert</span>(buffer == [45, 12, 22]);

string str = <span class="d_string">"hello world"</span>;
<span class="d_keyword">auto</span> wrappedStr = refRange(&amp;str);
<span class="d_keyword">assert</span>(str.front == 'h');
str.popFrontN(5);
<span class="d_keyword">assert</span>(str == <span class="d_string">" world"</span>);
<span class="d_keyword">assert</span>(wrappedStr.front == ' ');
<span class="d_keyword">assert</span>(*wrappedStr.ptr == <span class="d_string">" world"</span>);
</pre>
</div></div>

<dl><dt class="d_decl"><a name=".RefRange.this"></a><div class="quickindex" id="quickindex.RefRange.this"></div>pure nothrow @safe this(R* <i>range</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RefRange.opAssign"></a><div class="quickindex" id="quickindex.RefRange.opAssign"></div>auto <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span>(RefRange <i>rhs</i>);
</dt>
<dd><div class="summary">This does not assign the pointer of <span class="d_inlinecode donthyphenate notranslate"><i>rhs</i></span> to this <span class="d_inlinecode donthyphenate notranslate">RefRange</span>.
        Rather it assigns the range pointed to by <span class="d_inlinecode donthyphenate notranslate"><i>rhs</i></span> to the range pointed
        to by this <span class="d_inlinecode donthyphenate notranslate">RefRange</span>. This is because <i>any</i> operation on a
        <span class="d_inlinecode donthyphenate notranslate">RefRange</span> is the same is if it occurred to the original range. The
        one exception is when a <span class="d_inlinecode donthyphenate notranslate">RefRange</span> is assigned <span class="d_inlinecode donthyphenate notranslate"><b>null</b></span> either
        directly or because <span class="d_inlinecode donthyphenate notranslate"><i>rhs</i></span> is <span class="d_inlinecode donthyphenate notranslate"><b>null</b></span>. In that case, <span class="d_inlinecode donthyphenate notranslate">RefRange</span>
        no longer refers to the original range but is <span class="d_inlinecode donthyphenate notranslate"><b>null</b></span>.
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_keyword">ubyte</span>[] buffer1 = [1, 2, 3, 4, 5];
<span class="d_keyword">ubyte</span>[] buffer2 = [6, 7, 8, 9, 10];
<span class="d_keyword">auto</span> wrapped1 = refRange(&amp;buffer1);
<span class="d_keyword">auto</span> wrapped2 = refRange(&amp;buffer2);
<span class="d_keyword">assert</span>(wrapped1.ptr <span class="d_keyword">is</span> &amp;buffer1);
<span class="d_keyword">assert</span>(wrapped2.ptr <span class="d_keyword">is</span> &amp;buffer2);
<span class="d_keyword">assert</span>(wrapped1.ptr !<span class="d_keyword">is</span> wrapped2.ptr);
<span class="d_keyword">assert</span>(buffer1 != buffer2);

wrapped1 = wrapped2;

<span class="d_comment">//Everything points to the same stuff as before.
</span><span class="d_keyword">assert</span>(wrapped1.ptr <span class="d_keyword">is</span> &amp;buffer1);
<span class="d_keyword">assert</span>(wrapped2.ptr <span class="d_keyword">is</span> &amp;buffer2);
<span class="d_keyword">assert</span>(wrapped1.ptr !<span class="d_keyword">is</span> wrapped2.ptr);

<span class="d_comment">//But buffer1 has changed due to the assignment.
</span><span class="d_keyword">assert</span>(buffer1 == [6, 7, 8, 9, 10]);
<span class="d_keyword">assert</span>(buffer2 == [6, 7, 8, 9, 10]);

buffer2 = [11, 12, 13, 14, 15];

<span class="d_comment">//Everything points to the same stuff as before.
</span><span class="d_keyword">assert</span>(wrapped1.ptr <span class="d_keyword">is</span> &amp;buffer1);
<span class="d_keyword">assert</span>(wrapped2.ptr <span class="d_keyword">is</span> &amp;buffer2);
<span class="d_keyword">assert</span>(wrapped1.ptr !<span class="d_keyword">is</span> wrapped2.ptr);

<span class="d_comment">//But buffer2 has changed due to the assignment.
</span><span class="d_keyword">assert</span>(buffer1 == [6, 7, 8, 9, 10]);
<span class="d_keyword">assert</span>(buffer2 == [11, 12, 13, 14, 15]);

wrapped2 = <span class="d_keyword">null</span>;

<span class="d_comment">//The pointer changed for wrapped2 but not wrapped1.
</span><span class="d_keyword">assert</span>(wrapped1.ptr <span class="d_keyword">is</span> &amp;buffer1);
<span class="d_keyword">assert</span>(wrapped2.ptr <span class="d_keyword">is</span> <span class="d_keyword">null</span>);
<span class="d_keyword">assert</span>(wrapped1.ptr !<span class="d_keyword">is</span> wrapped2.ptr);

<span class="d_comment">//buffer2 is not affected by the assignment.
</span><span class="d_keyword">assert</span>(buffer1 == [6, 7, 8, 9, 10]);
<span class="d_keyword">assert</span>(buffer2 == [11, 12, 13, 14, 15]);
</pre>
</div></div>

</dd>
<dt class="d_decl"><a name=".RefRange.opAssign"></a><div class="quickindex" id="quickindex.RefRange.opAssign"></div>auto <a name="opAssign"></a><span class="ddoc_psymbol">opAssign</span>(typeof(null) <i>rhs</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RefRange.ptr"></a><div class="quickindex" id="quickindex.RefRange.ptr"></div>inout pure nothrow @property @safe inout(R*) <a name="ptr"></a><span class="ddoc_psymbol">ptr</span>();
</dt>
<dd><div class="summary">A pointer to the wrapped range.</div>

</dd>
<dt class="d_decl"><a name=".RefRange.front"></a><div class="quickindex" id="quickindex.RefRange.front"></div>@property auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".RefRange.front"></a><div class="quickindex" id="quickindex.RefRange.front"></div>const @property auto <a name="front"></a><span class="ddoc_psymbol">front</span>();
<br><a name=".RefRange.front"></a><div class="quickindex" id="quickindex.RefRange.front"></div>@property auto <a name="front"></a><span class="ddoc_psymbol">front</span>(ElementType!R <i>value</i>);
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RefRange.empty"></a><div class="quickindex" id="quickindex.RefRange.empty"></div>@property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
<br><a name=".RefRange.empty"></a><div class="quickindex" id="quickindex.RefRange.empty"></div>const @property bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RefRange.popFront"></a><div class="quickindex" id="quickindex.RefRange.popFront"></div>void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RefRange.save"></a><div class="quickindex" id="quickindex.RefRange.save"></div>@property auto <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br><a name=".RefRange.save"></a><div class="quickindex" id="quickindex.RefRange.save"></div>const @property auto <a name="save"></a><span class="ddoc_psymbol">save</span>();
<br><a name=".RefRange.opSlice"></a><div class="quickindex" id="quickindex.RefRange.opSlice"></div>auto <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
<br><a name=".RefRange.opSlice"></a><div class="quickindex" id="quickindex.RefRange.opSlice"></div>const auto <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>();
</dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".RefRange.back"></a><div class="quickindex" id="quickindex.RefRange.back"></div>@property auto <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".RefRange.back"></a><div class="quickindex" id="quickindex.RefRange.back"></div>const @property auto <a name="back"></a><span class="ddoc_psymbol">back</span>();
<br><a name=".RefRange.back"></a><div class="quickindex" id="quickindex.RefRange.back"></div>@property auto <a name="back"></a><span class="ddoc_psymbol">back</span>(ElementType!R <i>value</i>);
<br><a name=".RefRange.popBack"></a><div class="quickindex" id="quickindex.RefRange.popBack"></div>void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</dt>
<dd><div class="summary">Only defined if <span class="d_inlinecode donthyphenate notranslate">isBidirectionalRange!R</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
<dt class="d_decl"><a name=".RefRange.opIndex"></a><div class="quickindex" id="quickindex.RefRange.opIndex"></div>ref auto <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(IndexType)(IndexType <i>index</i>);
<br><a name=".RefRange.opIndex"></a><div class="quickindex" id="quickindex.RefRange.opIndex"></div>const ref auto <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(IndexType)(IndexType <i>index</i>);
</dt>
<dd><div class="summary">Only defined if <span class="d_inlinecode donthyphenate notranslate">isRandomAccesRange!R</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
<dt class="d_decl"><a name=".RefRange.moveFront"></a><div class="quickindex" id="quickindex.RefRange.moveFront"></div>auto <a name="moveFront"></a><span class="ddoc_psymbol">moveFront</span>();
</dt>
<dd><div class="summary">Only defined if <span class="d_inlinecode donthyphenate notranslate">hasMobileElements!R</span> and <span class="d_inlinecode donthyphenate notranslate">isForwardRange!R</span> are
        <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
<dt class="d_decl"><a name=".RefRange.moveBack"></a><div class="quickindex" id="quickindex.RefRange.moveBack"></div>auto <a name="moveBack"></a><span class="ddoc_psymbol">moveBack</span>();
</dt>
<dd><div class="summary">Only defined if <span class="d_inlinecode donthyphenate notranslate">hasMobileElements!R</span> and <span class="d_inlinecode donthyphenate notranslate">isBidirectionalRange!R</span>
        are <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
<dt class="d_decl"><a name=".RefRange.moveAt"></a><div class="quickindex" id="quickindex.RefRange.moveAt"></div>auto <a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(IndexType)(IndexType <i>index</i>) if (is(typeof((*_range).<a name="moveAt"></a><span class="ddoc_psymbol">moveAt</span>(<i>index</i>))));
</dt>
<dd><div class="summary">Only defined if <span class="d_inlinecode donthyphenate notranslate">hasMobileElements!R</span> and <span class="d_inlinecode donthyphenate notranslate">isRandomAccessRange!R</span>
        are <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
<dt class="d_decl"><a name=".RefRange.length"></a><div class="quickindex" id="quickindex.RefRange.length"></div>@property auto <a name="length"></a><span class="ddoc_psymbol">length</span>();
<br><a name=".RefRange.length"></a><div class="quickindex" id="quickindex.RefRange.length"></div>const @property auto <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd><div class="summary">Only defined if <span class="d_inlinecode donthyphenate notranslate">hasLength!R</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
<dt class="d_decl"><a name=".RefRange.opSlice"></a><div class="quickindex" id="quickindex.RefRange.opSlice"></div>auto <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(IndexType1, IndexType2)(IndexType1 <i>begin</i>, IndexType2 <i>end</i>);
<br><a name=".RefRange.opSlice"></a><div class="quickindex" id="quickindex.RefRange.opSlice"></div>const auto <a name="opSlice"></a><span class="ddoc_psymbol">opSlice</span>(IndexType1, IndexType2)(IndexType1 <i>begin</i>, IndexType2 <i>end</i>);
</dt>
<dd><div class="summary">Only defined if <span class="d_inlinecode donthyphenate notranslate">hasSlicing!R</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".refRange"></a><div class="quickindex" id="quickindex.refRange"></div>auto <a name="refRange"></a><span class="ddoc_psymbol">refRange</span>(R)(R* <i>range</i>) if (isForwardRange!R &amp;&amp; !is(R == class));
</dt>
<dd><div class="summary">Helper function for constructing a <a href="#RefRange"><span class="d_inlinecode donthyphenate notranslate">RefRange</span></a>.
</div>
<div class="description">If the given range is not a forward range or it is a class type (and thus is
    already a reference type), then the original range is returned rather than
    a <a href="#RefRange"><span class="d_inlinecode donthyphenate notranslate">RefRange</span></a>.</div>

</dd>
<dt class="d_decl"><a name=".NullSink"></a><div class="quickindex" id="quickindex.NullSink"></div>struct <a name="NullSink"></a><span class="ddoc_psymbol">NullSink</span>;
</dt>
<dd><div class="summary">An OutputRange that discards the data it receives.</div>

</dd>
</dl>

</div>
<div id="copyright">Copyright by authors 2008-.

 | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Tue Jul  4 02:55:20 2017
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('<script src="../js/jquery-1.7.2.min.js">\x3C/script>')</script>
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>
    <script type="text/javascript" src="../js/cssmenu.js"></script>

<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(listanchors);</script>
</body>
</html>

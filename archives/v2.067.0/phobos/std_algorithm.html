
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>std.algorithm - D Programming Language</title>
<link rel="stylesheet" href="../css/codemirror.css" />
<link rel="stylesheet" href="../css/style.css" />
<link rel="stylesheet" href="../css/print.css" media="print" />
<link rel="stylesheet" href="../css/cssmenu.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="shortcut icon" href="../favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0" />
</head>
<body id='std.algorithm' class='std'>
<script type="text/javascript">document.body.className += ' have-javascript';</script>
<div id="top">	<div id="header">		<a class="logo" href=".."><img id="logo" width="125" height="95" alt="D Logo" src="../images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href=".." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <span id="search-query"><input id="q" name="q" placeholder="Search" /></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option selected value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='../index.html'><span>D Lib Prerelease</span></a></li>
    <li><a href='../phobos/index.html'><span>Current Release (2.067.0)</span></a></li>
    
<li><a href='object.html'><span><em class="tt">object</em></span></a></li>
<li class='has-sub'><a href='#'><span><em class="tt">std</em></span></a>
<ul><li>  <a href="std_algorithm.html" title="std.algorithm"><span class="d_inlinecode donthyphenate notranslate">algorithm</span></a></li><li>  <a href="std_array.html" title="std.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>  <a href="std_ascii.html" title="std.ascii"><span class="d_inlinecode donthyphenate notranslate">ascii</span></a></li><li>  <a href="std_base64.html" title="std.base64"><span class="d_inlinecode donthyphenate notranslate">base64</span></a></li><li>  <a href="std_bigint.html" title="std.bigint"><span class="d_inlinecode donthyphenate notranslate">bigint</span></a></li><li>  <a href="std_bitmanip.html" title="std.bitmanip"><span class="d_inlinecode donthyphenate notranslate">bitmanip</span></a></li><li>  <a href="std_compiler.html" title="std.compiler"><span class="d_inlinecode donthyphenate notranslate">compiler</span></a></li><li>  <a href="std_complex.html" title="std.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>  <a href="std_concurrency.html" title="std.concurrency"><span class="d_inlinecode donthyphenate notranslate">concurrency</span></a></li><li>  <a href="std_container.html" title="std.container"><span class="d_inlinecode donthyphenate notranslate">container</span></a><ul><li>    <a href="std_container_array.html" title="std.container.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>    <a href="std_container_binaryheap.html" title="std.container.binaryheap"><span class="d_inlinecode donthyphenate notranslate">binaryheap</span></a></li><li>    <a href="std_container_dlist.html" title="std.container.dlist"><span class="d_inlinecode donthyphenate notranslate">dlist</span></a></li><li>    <a href="std_container_rbtree.html" title="std.container.rbtree"><span class="d_inlinecode donthyphenate notranslate">rbtree</span></a></li><li>    <a href="std_container_slist.html" title="std.container.slist"><span class="d_inlinecode donthyphenate notranslate">slist</span></a></li><li>    <a href="std_container_util.html" title="std.container.util"><span class="d_inlinecode donthyphenate notranslate">util</span></a>
  </li></ul></li><li>  <a href="std_conv.html" title="std.conv"><span class="d_inlinecode donthyphenate notranslate">conv</span></a></li><li>  <a href="std_csv.html" title="std.csv"><span class="d_inlinecode donthyphenate notranslate">csv</span></a></li><li>  <a href="std_datetime.html" title="std.datetime"><span class="d_inlinecode donthyphenate notranslate">datetime</span></a></li><li>  <a href="std_demangle.html" title="std.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">digest</span></h7><ul><li>    <a href="std_digest_crc.html" title="std.digest.crc"><span class="d_inlinecode donthyphenate notranslate">crc</span></a></li><li>    <a href="std_digest_digest.html" title="std.digest.digest"><span class="d_inlinecode donthyphenate notranslate">digest</span></a></li><li>    <a href="std_digest_md.html" title="std.digest.md"><span class="d_inlinecode donthyphenate notranslate">md</span></a></li><li>    <a href="std_digest_ripemd.html" title="std.digest.ripemd"><span class="d_inlinecode donthyphenate notranslate">ripemd</span></a></li><li>    <a href="std_digest_sha.html" title="std.digest.sha"><span class="d_inlinecode donthyphenate notranslate">sha</span></a>
  </li></ul></li><li>  <a href="std_encoding.html" title="std.encoding"><span class="d_inlinecode donthyphenate notranslate">encoding</span></a></li><li>  <a href="std_exception.html" title="std.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="std_file.html" title="std.file"><span class="d_inlinecode donthyphenate notranslate">file</span></a></li><li>  <a href="std_format.html" title="std.format"><span class="d_inlinecode donthyphenate notranslate">format</span></a></li><li>  <a href="std_functional.html" title="std.functional"><span class="d_inlinecode donthyphenate notranslate">functional</span></a></li><li>  <a href="std_getopt.html" title="std.getopt"><span class="d_inlinecode donthyphenate notranslate">getopt</span></a></li><li>  <a href="std_json.html" title="std.json"><span class="d_inlinecode donthyphenate notranslate">json</span></a></li><li>  <a href="std_math.html" title="std.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="std_mathspecial.html" title="std.mathspecial"><span class="d_inlinecode donthyphenate notranslate">mathspecial</span></a></li><li>  <a href="std_mmfile.html" title="std.mmfile"><span class="d_inlinecode donthyphenate notranslate">mmfile</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">net</span></h7><ul><li>    <a href="std_net_curl.html" title="std.net.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="std_net_isemail.html" title="std.net.isemail"><span class="d_inlinecode donthyphenate notranslate">isemail</span></a>
  </li></ul></li><li>  <a href="std_numeric.html" title="std.numeric"><span class="d_inlinecode donthyphenate notranslate">numeric</span></a></li><li>  <a href="std_outbuffer.html" title="std.outbuffer"><span class="d_inlinecode donthyphenate notranslate">outbuffer</span></a></li><li>  <a href="std_parallelism.html" title="std.parallelism"><span class="d_inlinecode donthyphenate notranslate">parallelism</span></a></li><li>  <a href="std_path.html" title="std.path"><span class="d_inlinecode donthyphenate notranslate">path</span></a></li><li>  <a href="std_process.html" title="std.process"><span class="d_inlinecode donthyphenate notranslate">process</span></a></li><li>  <a href="std_random.html" title="std.random"><span class="d_inlinecode donthyphenate notranslate">random</span></a></li><li>  <a href="std_range.html" title="std.range"><span class="d_inlinecode donthyphenate notranslate">range</span></a></li><li>  <a href="std_regex.html" title="std.regex"><span class="d_inlinecode donthyphenate notranslate">regex</span></a></li><li>  <a href="std_signals.html" title="std.signals"><span class="d_inlinecode donthyphenate notranslate">signals</span></a></li><li>  <a href="std_socket.html" title="std.socket"><span class="d_inlinecode donthyphenate notranslate">socket</span></a></li><li>  <a href="std_stdint.html" title="std.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>  <a href="std_stdio.html" title="std.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>  <a href="std_stdiobase.html" title="std.stdiobase"><span class="d_inlinecode donthyphenate notranslate">stdiobase</span></a></li><li>  <a href="std_string.html" title="std.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>  <a href="std_syserror.html" title="std.syserror"><span class="d_inlinecode donthyphenate notranslate">syserror</span></a></li><li>  <a href="std_system.html" title="std.system"><span class="d_inlinecode donthyphenate notranslate">system</span></a></li><li>  <a href="std_traits.html" title="std.traits"><span class="d_inlinecode donthyphenate notranslate">traits</span></a></li><li>  <a href="std_typecons.html" title="std.typecons"><span class="d_inlinecode donthyphenate notranslate">typecons</span></a></li><li>  <a href="std_typetuple.html" title="std.typetuple"><span class="d_inlinecode donthyphenate notranslate">typetuple</span></a></li><li>  <a href="std_uni.html" title="std.uni"><span class="d_inlinecode donthyphenate notranslate">uni</span></a></li><li>  <a href="std_uri.html" title="std.uri"><span class="d_inlinecode donthyphenate notranslate">uri</span></a></li><li>  <a href="std_utf.html" title="std.utf"><span class="d_inlinecode donthyphenate notranslate">utf</span></a></li><li>  <a href="std_uuid.html" title="std.uuid"><span class="d_inlinecode donthyphenate notranslate">uuid</span></a></li><li>  <a href="std_variant.html" title="std.variant"><span class="d_inlinecode donthyphenate notranslate">variant</span></a></li><li>  <a href="std_xml.html" title="std.xml"><span class="d_inlinecode donthyphenate notranslate">xml</span></a></li><li>  <a href="std_zip.html" title="std.zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a></li><li>  <a href="std_zlib.html" title="std.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">etc</em></span></a>
<ul><li>  <h7><span class="d_inlinecode donthyphenate notranslate">c</span></h7><ul><li>    <a href="etc_c_curl.html" title="etc.c.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="etc_c_sqlite3.html" title="etc.c.sqlite3"><span class="d_inlinecode donthyphenate notranslate">sqlite3</span></a></li><li>    <a href="etc_c_zlib.html" title="etc.c.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
  </li></ul>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">core</em></span></a>
<ul><li>  <a href="core_atomic.html" title="core.atomic"><span class="d_inlinecode donthyphenate notranslate">atomic</span></a></li><li>  <a href="core_bitop.html" title="core.bitop"><span class="d_inlinecode donthyphenate notranslate">bitop</span></a></li><li>  <a href="core_checkedint.html" title="core.checkedint"><span class="d_inlinecode donthyphenate notranslate">checkedint</span></a></li><li>  <a href="core_cpuid.html" title="core.cpuid"><span class="d_inlinecode donthyphenate notranslate">cpuid</span></a></li><li>  <a href="core_demangle.html" title="core.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <a href="core_exception.html" title="core.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="core_math.html" title="core.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="core_memory.html" title="core.memory"><span class="d_inlinecode donthyphenate notranslate">memory</span></a></li><li>  <a href="core_runtime.html" title="core.runtime"><span class="d_inlinecode donthyphenate notranslate">runtime</span></a></li><li>  <a href="core_simd.html" title="core.simd"><span class="d_inlinecode donthyphenate notranslate">simd</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">stdc</span></h7><ul><li>    <a href="core_stdc_complex.html" title="core.stdc.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>    <a href="core_stdc_ctype.html" title="core.stdc.ctype"><span class="d_inlinecode donthyphenate notranslate">ctype</span></a></li><li>    <a href="core_stdc_errno.html" title="core.stdc.errno"><span class="d_inlinecode donthyphenate notranslate">errno</span></a></li><li>    <a href="core_stdc_fenv.html" title="core.stdc.fenv"><span class="d_inlinecode donthyphenate notranslate">fenv</span></a></li><li>    <a href="core_stdc_float_.html" title="core.stdc.float_"><span class="d_inlinecode donthyphenate notranslate">float_</span></a></li><li>    <a href="core_stdc_inttypes.html" title="core.stdc.inttypes"><span class="d_inlinecode donthyphenate notranslate">inttypes</span></a></li><li>    <a href="core_stdc_limits.html" title="core.stdc.limits"><span class="d_inlinecode donthyphenate notranslate">limits</span></a></li><li>    <a href="core_stdc_locale.html" title="core.stdc.locale"><span class="d_inlinecode donthyphenate notranslate">locale</span></a></li><li>    <a href="core_stdc_math.html" title="core.stdc.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>    <a href="core_stdc_signal.html" title="core.stdc.signal"><span class="d_inlinecode donthyphenate notranslate">signal</span></a></li><li>    <a href="core_stdc_stdarg.html" title="core.stdc.stdarg"><span class="d_inlinecode donthyphenate notranslate">stdarg</span></a></li><li>    <a href="core_stdc_stddef.html" title="core.stdc.stddef"><span class="d_inlinecode donthyphenate notranslate">stddef</span></a></li><li>    <a href="core_stdc_stdint.html" title="core.stdc.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>    <a href="core_stdc_stdio.html" title="core.stdc.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>    <a href="core_stdc_stdlib.html" title="core.stdc.stdlib"><span class="d_inlinecode donthyphenate notranslate">stdlib</span></a></li><li>    <a href="core_stdc_string.html" title="core.stdc.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>    <a href="core_stdc_tgmath.html" title="core.stdc.tgmath"><span class="d_inlinecode donthyphenate notranslate">tgmath</span></a></li><li>    <a href="core_stdc_time.html" title="core.stdc.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>    <a href="core_stdc_wchar_.html" title="core.stdc.wchar_"><span class="d_inlinecode donthyphenate notranslate">wchar_</span></a></li><li>    <a href="core_stdc_wctype.html" title="core.stdc.wctype"><span class="d_inlinecode donthyphenate notranslate">wctype</span></a>
  </li></ul></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">sync</span></h7><ul><li>    <a href="core_sync_barrier.html" title="core.sync.barrier"><span class="d_inlinecode donthyphenate notranslate">barrier</span></a></li><li>    <a href="core_sync_condition.html" title="core.sync.condition"><span class="d_inlinecode donthyphenate notranslate">condition</span></a></li><li>    <a href="core_sync_config.html" title="core.sync.config"><span class="d_inlinecode donthyphenate notranslate">config</span></a></li><li>    <a href="core_sync_exception.html" title="core.sync.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>    <a href="core_sync_mutex.html" title="core.sync.mutex"><span class="d_inlinecode donthyphenate notranslate">mutex</span></a></li><li>    <a href="core_sync_rwmutex.html" title="core.sync.rwmutex"><span class="d_inlinecode donthyphenate notranslate">rwmutex</span></a></li><li>    <a href="core_sync_semaphore.html" title="core.sync.semaphore"><span class="d_inlinecode donthyphenate notranslate">semaphore</span></a>
  </li></ul></li><li>  <a href="core_thread.html" title="core.thread"><span class="d_inlinecode donthyphenate notranslate">thread</span></a></li><li>  <a href="core_time.html" title="core.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>  <a href="core_vararg.html" title="core.vararg"><span class="d_inlinecode donthyphenate notranslate">vararg</span></a>
</li></ul>
    <li><a href='http://code.dlang.org'><span>3rd Party Packages</span></a></li>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/algorithm.d" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">		<a href="http://wiki.dlang.org/DocComments/Phobos/StdAlgorithm" class="button">Page wiki</a>
		<span >			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.algorithm</h1>
    <div class="quickindex" id="quickindex"></div>
    <!--Generated by Ddoc from std/algorithm.d-->
<div class="summary"><script type="text/javascript">inhibitQuickIndex = 1</script>
</div>
<div class="description"><table class="book"><caption></caption><tr><th scope="col">Category</th> <th scope="col">Functions</th>
</tr>
<tr><td class="donthyphenate" nowrap>Searching</td> <td><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.all">all</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.any">any</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.balancedParens">balancedParens</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.boyerMooreFinder">boyerMooreFinder</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.canFind">canFind</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.commonPrefix">commonPrefix</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.count">count</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.countUntil">countUntil</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.endsWith">endsWith</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.find">find</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.findAdjacent">findAdjacent</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.findAmong">findAmong</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.findSkip">findSkip</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.findSplit">findSplit</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.findSplitAfter">findSplitAfter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.findSplitBefore">findSplitBefore</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.minCount">minCount</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.minPos">minPos</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.mismatch">mismatch</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.skipOver">skipOver</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.startsWith">startsWith</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.until">until</a>&nbsp;</font> </td>
</tr>
<tr><td class="donthyphenate" nowrap>Comparison</td> <td><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.among">among</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.cmp">cmp</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.equal">equal</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.levenshteinDistance">levenshteinDistance</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.levenshteinDistanceAndPath">levenshteinDistanceAndPath</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.max">max</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.min">min</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.mismatch">mismatch</a>&nbsp;</font> </td>
</tr>
<tr><td class="donthyphenate" nowrap>Iteration</td> <td><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.filter">filter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.filterBidirectional">filterBidirectional</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.group">group</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.joiner">joiner</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.map">map</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.reduce">reduce</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.splitter">splitter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.sum">sum</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.uniq">uniq</a>&nbsp;</font> </td>
</tr>
<tr><td class="donthyphenate" nowrap>Sorting</td> <td><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.completeSort">completeSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.isPartitioned">isPartitioned</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.isSorted">isSorted</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.makeIndex">makeIndex</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.multiSort">multiSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.nextPermutation">nextPermutation</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.nextEvenPermutation">nextEvenPermutation</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.partialSort">partialSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.partition">partition</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.partition3">partition3</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.schwartzSort">schwartzSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.sort">sort</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.topN">topN</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.topNCopy">topNCopy</a>&nbsp;</font> </td>
</tr>
<tr><td class="donthyphenate" nowrap>Set&nbsp;operations</td> <td><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.cartesianProduct">cartesianProduct</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.largestPartialIntersection">largestPartialIntersection</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.largestPartialIntersectionWeighted">largestPartialIntersectionWeighted</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.nWayUnion">nWayUnion</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.setDifference">setDifference</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.setIntersection">setIntersection</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.setSymmetricDifference">setSymmetricDifference</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.setUnion">setUnion</a>&nbsp;</font> </td>
</tr>
<tr><td class="donthyphenate" nowrap>Mutation</td> <td><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.bringToFront">bringToFront</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.copy">copy</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.fill">fill</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.initializeAll">initializeAll</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.move">move</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.moveAll">moveAll</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.moveSome">moveSome</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.remove">remove</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.reverse">reverse</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.strip">strip</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.stripLeft">stripLeft</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.stripRight">stripRight</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.swap">swap</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.swapRanges">swapRanges</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.uninitializedFill">uninitializedFill</a>&nbsp;</font> </td>
</tr>
<tr><td class="donthyphenate" nowrap>Utility</td> <td><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.forward">forward</a>&nbsp;</font> </td></tr>
</table>
<p></p>

Implements algorithms oriented mainly towards processing of
sequences. Some functions are semantic equivalents or supersets of
those found in the <span class="d_inlinecode donthyphenate notranslate">&lt;algorithm&gt;</span> header in <a href="http://sgi.com/tech/stl/">Alexander Stepanov's Standard Template Library</a> for
C++. Sequences processed by these functions define range-based interfaces.
<p></p>

<a href="std_range.html">Reference on ranges</a><br>
<a href="http://ddili.org/ders/d.en/ranges.html">Tutorial on ranges</a>
<p></p>

Many functions in this module are parameterized with a function or a
<a href="http://dlang.org/glossary.html#predicate">predicate</a>. The predicate may be passed either as a
function name, a delegate name, a <a href="http://dlang.org/glossary.html#functor">functor</a> name, or a
compile-time string. The string may consist of <b>any</b> legal D
expression that uses the symbol <span class="d_inlinecode donthyphenate notranslate">a</span> (for unary functions) or the
symbols <span class="d_inlinecode donthyphenate notranslate">a</span> and <span class="d_inlinecode donthyphenate notranslate">b</span> (for binary functions). These names will NOT
interfere with other homonym symbols in user code because they are
evaluated in a different context. The default for all binary
comparison predicates is <span class="d_inlinecode donthyphenate notranslate">"a == b"</span> for unordered operations and
<span class="d_inlinecode donthyphenate notranslate">"a &lt; b"</span> for ordered operations.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = ...;
<span class="d_keyword">static</span> <span class="d_keyword">bool</span> greater(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
{
    <span class="d_keyword">return</span> a &gt; b;
}
sort!(greater)(a);  <span class="d_comment">// predicate as alias
</span>sort!(<span class="d_string">"a &gt; b"</span>)(a);  <span class="d_comment">// predicate as string
</span>                    <span class="d_comment">// (no ambiguity with array name)
</span>sort(a);            <span class="d_comment">// no predicate, "a &lt; b" is implicit
</span></pre>
<p></p>

<table class="book"><caption>Cheat Sheet</caption><tr><th scope="col">Function Name</th> <th scope="col">Description</th>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Searching
</em></b></td></tr>
<tr><td class="donthyphenate" nowrap><a href="#all"><span class="d_inlinecode donthyphenate notranslate">all</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">all!"a &gt; 0"([1, 2, 3, 4])</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> because all elements are positive</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#any"><span class="d_inlinecode donthyphenate notranslate">any</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">any!"a &gt; 0"([1, 2, -3, -4])</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> because at least one element is positive</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#balancedParens"><span class="d_inlinecode donthyphenate notranslate">balancedParens</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">balancedParens("((1 + 1) / 2)")</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> because the string
has balanced parentheses.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#boyerMooreFinder"><span class="d_inlinecode donthyphenate notranslate">boyerMooreFinder</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">find("hello
world", boyerMooreFinder("or"))</span> returns <span class="d_inlinecode donthyphenate notranslate">"orld"</span> using the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Boyer-Moore algorithm">Boyer-Moore algorithm</a>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#canFind"><span class="d_inlinecode donthyphenate notranslate">canFind</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">canFind("hello world",
"or")</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#count"><span class="d_inlinecode donthyphenate notranslate">count</span></a></td> <td>Counts elements that are equal
to a specified value or satisfy a predicate. <span class="d_inlinecode donthyphenate notranslate">count([1, 2, 1], 1)</span>
returns <span class="d_inlinecode donthyphenate notranslate">2</span> and <span class="d_inlinecode donthyphenate notranslate">count!"a &lt; 0"([1, -3, 0])</span> returns <span class="d_inlinecode donthyphenate notranslate">1</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#countUntil"><span class="d_inlinecode donthyphenate notranslate">countUntil</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">countUntil(a, b)</span>
returns the number of steps taken in <span class="d_inlinecode donthyphenate notranslate">a</span> to reach <span class="d_inlinecode donthyphenate notranslate">b</span>; for
example, <span class="d_inlinecode donthyphenate notranslate">countUntil("hello!", "o")</span> returns <span class="d_inlinecode donthyphenate notranslate">4</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#commonPrefix"><span class="d_inlinecode donthyphenate notranslate">commonPrefix</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">commonPrefix("parakeet",
"parachute")</span> returns <span class="d_inlinecode donthyphenate notranslate">"para"</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#endsWith"><span class="d_inlinecode donthyphenate notranslate">endsWith</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">endsWith("rocks", "ks")</span>
returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</td>
</tr>
<tr><td><a href="#find"><span class="d_inlinecode donthyphenate notranslate">find</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">find("hello world",
"or")</span> returns <span class="d_inlinecode donthyphenate notranslate">"orld"</span> using linear search. (For binary search refer
to <span class="libref"><a href="http://dlang.org/phobos/std_range.html#sortedRange"><span class="d_inlinecode donthyphenate notranslate">std.range.sortedRange</span></a></span>.)</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#findAdjacent"><span class="d_inlinecode donthyphenate notranslate">findAdjacent</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">findAdjacent([1, 2,
3, 3, 4])</span> returns the subrange starting with two equal adjacent
elements, i.e. <span class="d_inlinecode donthyphenate notranslate">[3, 3, 4]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#findAmong"><span class="d_inlinecode donthyphenate notranslate">findAmong</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">findAmong("abcd",
"qcx")</span> returns <span class="d_inlinecode donthyphenate notranslate">"cd"</span> because <span class="d_inlinecode donthyphenate notranslate">'c'</span> is among <span class="d_inlinecode donthyphenate notranslate">"qcx"</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#findSkip"><span class="d_inlinecode donthyphenate notranslate">findSkip</span></a></td> <td>If <span class="d_inlinecode donthyphenate notranslate">a = "abcde"</span>, then
<span class="d_inlinecode donthyphenate notranslate">findSkip(a, "x")</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> and leaves <span class="d_inlinecode donthyphenate notranslate">a</span> unchanged,
whereas <span class="d_inlinecode donthyphenate notranslate">findSkip(a, 'c')</span> advances <span class="d_inlinecode donthyphenate notranslate">a</span> to <span class="d_inlinecode donthyphenate notranslate">"cde"</span> and
returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#findSplit"><span class="d_inlinecode donthyphenate notranslate">findSplit</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">findSplit("abcdefg",
"de")</span> returns the three ranges <span class="d_inlinecode donthyphenate notranslate">"abc"</span>, <span class="d_inlinecode donthyphenate notranslate">"de"</span>, and <span class="d_inlinecode donthyphenate notranslate">"fg"</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#findSplitAfter"><span class="d_inlinecode donthyphenate notranslate">findSplitAfter</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">findSplitAfter("abcdefg", "de")</span> returns the two ranges <span class="d_inlinecode donthyphenate notranslate">"abcde"</span>
and <span class="d_inlinecode donthyphenate notranslate">"fg"</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#findSplitBefore"><span class="d_inlinecode donthyphenate notranslate">findSplitBefore</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">findSplitBefore("abcdefg", "de")</span> returns the two ranges <span class="d_inlinecode donthyphenate notranslate">"abc"</span> and
<span class="d_inlinecode donthyphenate notranslate">"defg"</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#minCount"><span class="d_inlinecode donthyphenate notranslate">minCount</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">minCount([2, 1, 1, 4,
1])</span> returns <span class="d_inlinecode donthyphenate notranslate">tuple(1, 3)</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#minPos"><span class="d_inlinecode donthyphenate notranslate">minPos</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">minPos([2, 3, 1, 3, 4,
1])</span> returns the subrange <span class="d_inlinecode donthyphenate notranslate">[1, 3, 4, 1]</span>, i.e., positions the range
at the first occurrence of its minimal element.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#mismatch"><span class="d_inlinecode donthyphenate notranslate">mismatch</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">mismatch("parakeet", "parachute")</span>
returns the two ranges <span class="d_inlinecode donthyphenate notranslate">"keet"</span> and <span class="d_inlinecode donthyphenate notranslate">"chute"</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#skipOver"><span class="d_inlinecode donthyphenate notranslate">skipOver</span></a></td> <td>Assume <span class="d_inlinecode donthyphenate notranslate">a = "blah"</span>. Then
<span class="d_inlinecode donthyphenate notranslate">skipOver(a, "bi")</span> leaves <span class="d_inlinecode donthyphenate notranslate">a</span> unchanged and returns <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>,
whereas <span class="d_inlinecode donthyphenate notranslate">skipOver(a, "bl")</span> advances <span class="d_inlinecode donthyphenate notranslate">a</span> to refer to <span class="d_inlinecode donthyphenate notranslate">"ah"</span>
and returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#startsWith"><span class="d_inlinecode donthyphenate notranslate">startsWith</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">startsWith("hello,
world", "hello")</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#until"><span class="d_inlinecode donthyphenate notranslate">until</span></a></td> <td>Lazily iterates a range
until a specific value is found.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Comparison
</em></b></td></tr>
<tr><td class="donthyphenate" nowrap><a href="#among"><span class="d_inlinecode donthyphenate notranslate">among</span></a></td> <td>Checks if a value is among a set
of values, e.g. <span class="d_inlinecode donthyphenate notranslate">if (v.among(1, 2, 3)) // `v` is 1, 2 or 3</span></td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#cmp"><span class="d_inlinecode donthyphenate notranslate">cmp</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">cmp("abc", "abcd")</span> is <span class="d_inlinecode donthyphenate notranslate">-1</span>, <span class="d_inlinecode donthyphenate notranslate">cmp("abc", "aba")</span> is <span class="d_inlinecode donthyphenate notranslate">1</span>, and <span class="d_inlinecode donthyphenate notranslate">cmp("abc", "abc")</span> is
<span class="d_inlinecode donthyphenate notranslate">0</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#equal"><span class="d_inlinecode donthyphenate notranslate">equal</span></a></td> <td>Compares ranges for
element-by-element equality, e.g. <span class="d_inlinecode donthyphenate notranslate">equal([1, 2, 3], [1.0, 2.0,
3.0])</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#levenshteinDistance"><span class="d_inlinecode donthyphenate notranslate">levenshteinDistance</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">levenshteinDistance("kitten", "sitting")</span> returns <span class="d_inlinecode donthyphenate notranslate">3</span> by using the
<a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Levenshtein distance algorithm">Levenshtein distance algorithm</a>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#levenshteinDistanceAndPath"><span class="d_inlinecode donthyphenate notranslate">levenshteinDistanceAndPath</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">levenshteinDistanceAndPath("kitten", "sitting")</span> returns <span class="d_inlinecode donthyphenate notranslate">tuple(3,
"snnnsni")</span> by using the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Levenshtein distance algorithm">Levenshtein distance algorithm</a>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#max"><span class="d_inlinecode donthyphenate notranslate">max</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">max(3, 4, 2)</span> returns <span class="d_inlinecode donthyphenate notranslate">4</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#min"><span class="d_inlinecode donthyphenate notranslate">min</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">min(3, 4, 2)</span> returns <span class="d_inlinecode donthyphenate notranslate">2</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#mismatch"><span class="d_inlinecode donthyphenate notranslate">mismatch</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">mismatch("oh hi",
"ohayo")</span> returns <span class="d_inlinecode donthyphenate notranslate">tuple(" hi", "ayo")</span>.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Iteration
</em></b></td></tr>
<tr><td class="donthyphenate" nowrap><a href="#filter"><span class="d_inlinecode donthyphenate notranslate">filter</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">filter!"a &gt; 0"([1, -1, 2,
0, -3])</span> iterates over elements <span class="d_inlinecode donthyphenate notranslate">1</span> and <span class="d_inlinecode donthyphenate notranslate">2</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#filterBidirectional"><span class="d_inlinecode donthyphenate notranslate">filterBidirectional</span></a></td> <td>Similar to <span class="d_inlinecode donthyphenate notranslate">filter</span>, but also provides <span class="d_inlinecode donthyphenate notranslate">back</span> and <span class="d_inlinecode donthyphenate notranslate">popBack</span> at a small
increase in cost.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#group"><span class="d_inlinecode donthyphenate notranslate">group</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">group([5, 2, 2, 3, 3])</span>
returns a range containing the tuples <span class="d_inlinecode donthyphenate notranslate">tuple(5, 1)</span>,
<span class="d_inlinecode donthyphenate notranslate">tuple(2, 2)</span>, and <span class="d_inlinecode donthyphenate notranslate">tuple(3, 2)</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#joiner"><span class="d_inlinecode donthyphenate notranslate">joiner</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">joiner(["hello",
"world!"], "; ")</span> returns a range that iterates over the characters <span class="d_inlinecode donthyphenate notranslate">"hello; world!"</span>. No new string is created - the existing inputs are
iterated.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#map"><span class="d_inlinecode donthyphenate notranslate">map</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">map!"2 * a"([1, 2, 3])</span>
lazily returns a range with the numbers <span class="d_inlinecode donthyphenate notranslate">2</span>, <span class="d_inlinecode donthyphenate notranslate">4</span>, <span class="d_inlinecode donthyphenate notranslate">6</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#reduce"><span class="d_inlinecode donthyphenate notranslate">reduce</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">reduce!"a + b"([1, 2, 3,
4])</span> returns <span class="d_inlinecode donthyphenate notranslate">10</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#splitter"><span class="d_inlinecode donthyphenate notranslate">splitter</span></a></td> <td>Lazily splits a range by a
separator.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#sum"><span class="d_inlinecode donthyphenate notranslate">sum</span></a></td> <td>Same as <span class="d_inlinecode donthyphenate notranslate">reduce</span>, but specialized for
accurate summation.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#uniq"><span class="d_inlinecode donthyphenate notranslate">uniq</span></a></td> <td>Iterates over the unique elements
in a range, which is assumed sorted.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Sorting
</em></b></td></tr>
<tr><td class="donthyphenate" nowrap><a href="#completeSort"><span class="d_inlinecode donthyphenate notranslate">completeSort</span></a></td> <td>If <span class="d_inlinecode donthyphenate notranslate">a = [10, 20, 30]</span>
and <span class="d_inlinecode donthyphenate notranslate">b = [40, 6, 15]</span>, then <span class="d_inlinecode donthyphenate notranslate">completeSort(a, b)</span> leaves <span class="d_inlinecode donthyphenate notranslate">a =
[6, 10, 15]</span> and <span class="d_inlinecode donthyphenate notranslate">b = [20, 30, 40]</span>. The range <span class="d_inlinecode donthyphenate notranslate">a</span> must be
sorted prior to the call, and as a result the combination <span class="d_inlinecode donthyphenate notranslate"><span class="libref"><a href="http://dlang.org/phobos/std_range.html#chain"><span class="d_inlinecode donthyphenate notranslate">std.range.chain</span></a></span>(a, b)</span> is sorted.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#isPartitioned"><span class="d_inlinecode donthyphenate notranslate">isPartitioned</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">isPartitioned!"a &lt;
0"([-1, -2, 1, 0, 2])</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> because the predicate is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> for a portion of the range and <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> afterwards.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#isSorted"><span class="d_inlinecode donthyphenate notranslate">isSorted</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">isSorted([1, 1, 2, 3])</span>
returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#makeIndex"><span class="d_inlinecode donthyphenate notranslate">makeIndex</span></a></td> <td>Creates a separate index
for a range.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#nextPermutation"><span class="d_inlinecode donthyphenate notranslate">nextPermutation</span></a></td> <td>Computes the next lexicographically
greater permutation of a range in-place.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#nextEvenPermutation"><span class="d_inlinecode donthyphenate notranslate">nextEvenPermutation</span></a></td> <td>Computes the next
lexicographically greater even permutation of a range in-place.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#partialSort"><span class="d_inlinecode donthyphenate notranslate">partialSort</span></a></td> <td>If <span class="d_inlinecode donthyphenate notranslate">a = [5, 4, 3, 2,
1]</span>, then <span class="d_inlinecode donthyphenate notranslate">partialSort(a, 3)</span> leaves <span class="d_inlinecode donthyphenate notranslate">a[0 .. 3] = [1, 2,
3]</span>. The other elements of <span class="d_inlinecode donthyphenate notranslate">a</span> are left in an unspecified order.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#partition"><span class="d_inlinecode donthyphenate notranslate">partition</span></a></td> <td>Partitions a range
according to a predicate.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#partition3"><span class="d_inlinecode donthyphenate notranslate">partition3</span></a></td> <td>Partitions a range
in three parts (less than, equal, greater than the given pivot).</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#schwartzSort"><span class="d_inlinecode donthyphenate notranslate">schwartzSort</span></a></td> <td>Sorts with the help of
the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Schwartzian transform">Schwartzian transform</a>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#sort"><span class="d_inlinecode donthyphenate notranslate">sort</span></a></td> <td>Sorts.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#topN"><span class="d_inlinecode donthyphenate notranslate">topN</span></a></td> <td>Separates the top elements in a
range.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#topNCopy"><span class="d_inlinecode donthyphenate notranslate">topNCopy</span></a></td> <td>Copies out the top elements
of a range.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Set operations
</em></b></td></tr>
<tr><td class="donthyphenate" nowrap><a href="#cartesianProduct"><span class="d_inlinecode donthyphenate notranslate">cartesianProduct</span></a></td> <td>Computes Cartesian product of two
ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#largestPartialIntersection"><span class="d_inlinecode donthyphenate notranslate">largestPartialIntersection</span></a></td> <td>Copies out
the values that occur most frequently in a range of ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#largestPartialIntersectionWeighted"><span class="d_inlinecode donthyphenate notranslate">largestPartialIntersectionWeighted</span></a></td> <td>Copies out the values that occur most frequently (multiplied by
per-value weights) in a range of ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#nWayUnion"><span class="d_inlinecode donthyphenate notranslate">nWayUnion</span></a></td> <td>Computes the union of a set
of sets implemented as a range of sorted ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#setDifference"><span class="d_inlinecode donthyphenate notranslate">setDifference</span></a></td> <td>Lazily computes the set
difference of two or more sorted ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#setIntersection"><span class="d_inlinecode donthyphenate notranslate">setIntersection</span></a></td> <td>Lazily computes the
intersection of two or more sorted ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#setSymmetricDifference"><span class="d_inlinecode donthyphenate notranslate">setSymmetricDifference</span></a></td> <td>Lazily
computes the symmetric set difference of two or more sorted ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#setUnion"><span class="d_inlinecode donthyphenate notranslate">setUnion</span></a></td> <td>Lazily computes the set
union of two or more sorted ranges.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Mutation
</em></b></td></tr>
<tr><td class="donthyphenate" nowrap><a href="#bringToFront"><span class="d_inlinecode donthyphenate notranslate">bringToFront</span></a></td> <td>If <span class="d_inlinecode donthyphenate notranslate">a = [1, 2, 3]</span>
and <span class="d_inlinecode donthyphenate notranslate">b = [4, 5, 6, 7]</span>, <span class="d_inlinecode donthyphenate notranslate">bringToFront(a, b)</span> leaves <span class="d_inlinecode donthyphenate notranslate">a = [4,
5, 6]</span> and <span class="d_inlinecode donthyphenate notranslate">b = [7, 1, 2, 3]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#copy"><span class="d_inlinecode donthyphenate notranslate">copy</span></a></td> <td>Copies a range to another. If
<span class="d_inlinecode donthyphenate notranslate">a = [1, 2, 3]</span> and <span class="d_inlinecode donthyphenate notranslate">b = new int[5]</span>, then <span class="d_inlinecode donthyphenate notranslate">copy(a, b)</span>
leaves <span class="d_inlinecode donthyphenate notranslate">b = [1, 2, 3, 0, 0]</span> and returns <span class="d_inlinecode donthyphenate notranslate">b[3 .. $]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#fill"><span class="d_inlinecode donthyphenate notranslate">fill</span></a></td> <td>Fills a range with a pattern,
e.g., if <span class="d_inlinecode donthyphenate notranslate">a = new int[3]</span>, then <span class="d_inlinecode donthyphenate notranslate">fill(a, 4)</span> leaves <span class="d_inlinecode donthyphenate notranslate">a = [4,
4, 4]</span> and <span class="d_inlinecode donthyphenate notranslate">fill(a, [3, 4])</span> leaves <span class="d_inlinecode donthyphenate notranslate">a = [3, 4, 3]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#initializeAll"><span class="d_inlinecode donthyphenate notranslate">initializeAll</span></a></td> <td>If <span class="d_inlinecode donthyphenate notranslate">a = [1.2, 3.4]</span>,
then <span class="d_inlinecode donthyphenate notranslate">initializeAll(a)</span> leaves <span class="d_inlinecode donthyphenate notranslate">a = [double.init,
double.init]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#move"><span class="d_inlinecode donthyphenate notranslate">move</span></a></td> <td><span class="d_inlinecode donthyphenate notranslate">move(a, b)</span> moves <span class="d_inlinecode donthyphenate notranslate">a</span>
into <span class="d_inlinecode donthyphenate notranslate">b</span>. <span class="d_inlinecode donthyphenate notranslate">move(a)</span> reads <span class="d_inlinecode donthyphenate notranslate">a</span> destructively.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#moveAll"><span class="d_inlinecode donthyphenate notranslate">moveAll</span></a></td> <td>Moves all elements from one
range to another.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#moveSome"><span class="d_inlinecode donthyphenate notranslate">moveSome</span></a></td> <td>Moves as many elements as
possible from one range to another.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#remove"><span class="d_inlinecode donthyphenate notranslate">remove</span></a></td> <td>Removes elements from a range
in-place, and returns the shortened range.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#reverse"><span class="d_inlinecode donthyphenate notranslate">reverse</span></a></td> <td>If <span class="d_inlinecode donthyphenate notranslate">a = [1, 2, 3]</span>, <span class="d_inlinecode donthyphenate notranslate">reverse(a)</span> changes it to <span class="d_inlinecode donthyphenate notranslate">[3, 2, 1]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#strip"><span class="d_inlinecode donthyphenate notranslate">strip</span></a></td> <td>Strips all leading and trailing
elements equal to a value, or that satisfy a predicate.
If <span class="d_inlinecode donthyphenate notranslate">a = [1, 1, 0, 1, 1]</span>, then <span class="d_inlinecode donthyphenate notranslate">strip(a, 1)</span> and <span class="d_inlinecode donthyphenate notranslate">strip!(e =&gt; e == 1)(a)</span>
returns <span class="d_inlinecode donthyphenate notranslate">[0]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#stripLeft"><span class="d_inlinecode donthyphenate notranslate">stripLeft</span></a></td> <td>Strips all leading elements equal to a value,
or that satisfy a predicate.
If <span class="d_inlinecode donthyphenate notranslate">a = [1, 1, 0, 1, 1]</span>, then <span class="d_inlinecode donthyphenate notranslate">stripLeft(a, 1)</span> and <span class="d_inlinecode donthyphenate notranslate">stripLeft!(e =&gt; e == 1)(a)</span>
returns <span class="d_inlinecode donthyphenate notranslate">[0, 1, 1]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#stripRight"><span class="d_inlinecode donthyphenate notranslate">stripRight</span></a></td> <td>Strips all trailing elements equal to a value,
or that satisfy a predicate.
If <span class="d_inlinecode donthyphenate notranslate">a = [1, 1, 0, 1, 1]</span>, then <span class="d_inlinecode donthyphenate notranslate">stripRight(a, 1)</span> and <span class="d_inlinecode donthyphenate notranslate">stripRight!(e =&gt; e == 1)(a)</span>
returns <span class="d_inlinecode donthyphenate notranslate">[1, 1, 0]</span>.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#swap"><span class="d_inlinecode donthyphenate notranslate">swap</span></a></td> <td>Swaps two values.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#swapRanges"><span class="d_inlinecode donthyphenate notranslate">swapRanges</span></a></td> <td>Swaps all elements of two
ranges.</td>
</tr>
<tr><td class="donthyphenate" nowrap><a href="#uninitializedFill"><span class="d_inlinecode donthyphenate notranslate">uninitializedFill</span></a></td> <td>Fills a range
(assumed uninitialized) with a value.</td>
</tr>
</table>

</div>
<div class="keyval License"><span class="key keyLicense">License:</span> <div class="val valLicense"><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

</div></div>
<div class="keyval Authors"><span class="key keyAuthors">Authors:</span> <div class="val valAuthors"><a href="http://erdani.com">Andrei Alexandrescu</a>

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Source:</span>
<span class="phobos_src"><a class="https" href="https://github.com/D-Programming-Language/phobos/blob/master/std/algorithm.d">std/algorithm.d</a></span></div>

<dl><dt class="d_decl"><a name=".map"></a><div class="quickindex" id="quickindex.map"></div>template <a name="map"></a><span class="ddoc_psymbol">map</span>(fun...) if (fun.length &gt;= 1)</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate">auto <a name="map"></a><span class="ddoc_psymbol">map</span>(Range)(Range r) if (isInputRange!(Unqual!Range));</span>
</div>
<div class="description">Implements the homonym function (also known as <span class="d_inlinecode donthyphenate notranslate">transform</span>) present
in many languages of functional flavor. The call <span class="d_inlinecode donthyphenate notranslate"><a name="map"></a><span class="ddoc_psymbol">map</span>!(fun)(range)</span>
returns a range of which elements are obtained by applying <span class="d_inlinecode donthyphenate notranslate">fun(x)</span>
left to right for all <span class="d_inlinecode donthyphenate notranslate">x</span> in <span class="d_inlinecode donthyphenate notranslate">range</span>. The original ranges are
not changed. Evaluation is done lazily.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] arr1 = [ 1, 2, 3, 4 ];
<span class="d_keyword">int</span>[] arr2 = [ 5, 6 ];
<span class="d_keyword">auto</span> squares = <span class="d_psymbol">map</span>!(a =&gt; a * a)(chain(arr1, arr2));
<span class="d_keyword">assert</span>(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Multiple functions can be passed to <span class="d_inlinecode donthyphenate notranslate"><a name="map"></a><span class="ddoc_psymbol">map</span></span>. In that case, the
element type of <span class="d_inlinecode donthyphenate notranslate"><a name="map"></a><span class="ddoc_psymbol">map</span></span> is a tuple containing one element for each
function.
<pre class="d_code notranslate">
<span class="d_keyword">auto</span> sums = [2, 4, 6, 8];
<span class="d_keyword">auto</span> products = [1, 4, 9, 16];

size_t i = 0;
<span class="d_keyword">foreach</span> (result; [ 1, 2, 3, 4 ].<span class="d_psymbol">map</span>!(<span class="d_string">"a + a"</span>, <span class="d_string">"a * a"</span>))
{
    <span class="d_keyword">assert</span>(result[0] == sums[i]);
    <span class="d_keyword">assert</span>(result[1] == products[i]);
    ++i;
}
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">You may alias <span class="d_inlinecode donthyphenate notranslate"><a name="map"></a><span class="ddoc_psymbol">map</span></span> with some function(s) to a symbol and use
it separately:
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.conv : to;

<span class="d_keyword">alias</span> stringize = <span class="d_psymbol">map</span>!(to!string);
<span class="d_keyword">assert</span>(equal(stringize([ 1, 2, 3, 4 ]), [ <span class="d_string">"1"</span>, <span class="d_string">"2"</span>, <span class="d_string">"3"</span>, <span class="d_string">"4"</span> ]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".reduce"></a><div class="quickindex" id="quickindex.reduce"></div>template <a name="reduce"></a><span class="ddoc_psymbol">reduce</span>(fun...) if (fun.length &gt;= 1)</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate">auto <a name="reduce"></a><span class="ddoc_psymbol">reduce</span>(Args...)(Args args)
    if (Args.length &gt; 0 &amp;&amp; Args.length &lt;= 2 &amp;&amp; isIterable!(Args[$ - 1]));</span>
</div>
<div class="description">Implements the homonym function (also known as <span class="d_inlinecode donthyphenate notranslate">accumulate</span>, <span class="d_inlinecode donthyphenate notranslate">compress</span>, <span class="d_inlinecode donthyphenate notranslate">inject</span>, or <span class="d_inlinecode donthyphenate notranslate">foldl</span>) present in various programming
languages of functional flavor. The call <span class="d_inlinecode donthyphenate notranslate"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span>!(fun)(seed,
range)</span> first assigns <span class="d_inlinecode donthyphenate notranslate">seed</span> to an internal variable <span class="d_inlinecode donthyphenate notranslate">result</span>,
also called the accumulator. Then, for each element <span class="d_inlinecode donthyphenate notranslate">x</span> in <span class="d_inlinecode donthyphenate notranslate">range</span>, <span class="d_inlinecode donthyphenate notranslate">result = fun(result, x)</span> gets evaluated. Finally, <span class="d_inlinecode donthyphenate notranslate">result</span> is returned. The one-argument version <span class="d_inlinecode donthyphenate notranslate"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span>!(fun)(range)</span>
works similarly, but it uses the first element of the range as the
seed (the range must be non-empty).
<p></p>

See also: <a href="#sum"><span class="d_inlinecode donthyphenate notranslate">sum</span></a> is similar to <span class="d_inlinecode donthyphenate notranslate"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span>!((a, b) =&gt; a + b)</span> that offers
precise summing of floating point numbers.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Many aggregate range operations turn out to be solved with <span class="d_inlinecode donthyphenate notranslate"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span>
quickly and easily. The example below illustrates <span class="d_inlinecode donthyphenate notranslate"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span>'s
remarkable power and flexibility.
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.math : approxEqual;

<span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];
<span class="d_comment">// Sum all elements
</span><span class="d_keyword">auto</span> sum = <span class="d_psymbol">reduce</span>!((a,b) =&gt; a + b)(0, arr);
<span class="d_keyword">assert</span>(sum == 15);

<span class="d_comment">// Sum again, using a string predicate with "a" and "b"
</span>sum = <span class="d_psymbol">reduce</span>!<span class="d_string">"a + b"</span>(0, arr);
<span class="d_keyword">assert</span>(sum == 15);

<span class="d_comment">// Compute the maximum of all elements
</span><span class="d_keyword">auto</span> largest = <span class="d_psymbol">reduce</span>!(max)(arr);
<span class="d_keyword">assert</span>(largest == 5);

<span class="d_comment">// Max again, but with Uniform Function Call Syntax (UFCS)
</span>largest = arr.<span class="d_psymbol">reduce</span>!(max);
<span class="d_keyword">assert</span>(largest == 5);

<span class="d_comment">// Compute the number of odd elements
</span><span class="d_keyword">auto</span> odds = <span class="d_psymbol">reduce</span>!((a,b) =&gt; a + (b &amp; 1))(0, arr);
<span class="d_keyword">assert</span>(odds == 3);

<span class="d_comment">// Compute the sum of squares
</span><span class="d_keyword">auto</span> ssquares = <span class="d_psymbol">reduce</span>!((a,b) =&gt; a + b * b)(0, arr);
<span class="d_keyword">assert</span>(ssquares == 55);

<span class="d_comment">// Chain multiple ranges into seed
</span><span class="d_keyword">int</span>[] a = [ 3, 4 ];
<span class="d_keyword">int</span>[] b = [ 100 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>)(chain(a, b));
<span class="d_keyword">assert</span>(r == 107);

<span class="d_comment">// Mixing convertible types is fair game, too
</span><span class="d_keyword">double</span>[] c = [ 2.5, 3.0 ];
<span class="d_keyword">auto</span> r1 = <span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>)(chain(a, b, c));
<span class="d_keyword">assert</span>(approxEqual(r1, 112.5));

<span class="d_comment">// To minimize nesting of parentheses, Uniform Function Call Syntax can be used
</span><span class="d_keyword">auto</span> r2 = chain(a, b, c).<span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>);
<span class="d_keyword">assert</span>(approxEqual(r2, 112.5));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Sometimes it is very useful to compute multiple aggregates in one pass.
One advantage is that the computation is faster because the looping overhead
is shared. That's why <span class="d_inlinecode donthyphenate notranslate"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span> accepts multiple functions.
If two or more functions are passed, <span class="d_inlinecode donthyphenate notranslate"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span> returns a
<span class="libref"><a href="http://dlang.org/phobos/std_typecons.html#Tuple"><span class="d_inlinecode donthyphenate notranslate">std.typecons.Tuple</span></a></span> object with one member per passed-in function.
The number of seeds must be correspondingly increased.
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.math : approxEqual, sqrt;

<span class="d_keyword">double</span>[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];
<span class="d_comment">// Compute minimum and maximum in one pass
</span><span class="d_keyword">auto</span> r = <span class="d_psymbol">reduce</span>!(min, max)(a);
<span class="d_comment">// The type of r is Tuple!(int, int)
</span><span class="d_keyword">assert</span>(approxEqual(r[0], 2));  <span class="d_comment">// minimum
</span><span class="d_keyword">assert</span>(approxEqual(r[1], 11)); <span class="d_comment">// maximum
</span>
<span class="d_comment">// Compute sum and sum of squares in one pass
</span>r = <span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>, <span class="d_string">"a + b * b"</span>)(tuple(0.0, 0.0), a);
<span class="d_keyword">assert</span>(approxEqual(r[0], 35));  <span class="d_comment">// sum
</span><span class="d_keyword">assert</span>(approxEqual(r[1], 233)); <span class="d_comment">// sum of squares
</span><span class="d_comment">// Compute average and standard deviation from the above
</span><span class="d_keyword">auto</span> avg = r[0] / a.length;
<span class="d_keyword">auto</span> stdev = sqrt(r[1] / a.length - avg * avg);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".sum"></a><div class="quickindex" id="quickindex.sum"></div>auto <a name="sum"></a><span class="ddoc_psymbol">sum</span>(R)(R <i>r</i>) if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; is(typeof(<i>r</i>.front + <i>r</i>.front)));
<br><a name=".sum"></a><div class="quickindex" id="quickindex.sum"></div>auto <a name="sum"></a><span class="ddoc_psymbol">sum</span>(R, E)(R <i>r</i>, E <i>seed</i>) if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; is(typeof(<i>seed</i> = <i>seed</i> + <i>r</i>.front)));
</dt>
<dd><div class="summary">Sums elements of <span class="d_inlinecode donthyphenate notranslate">r</span>, which must be a finite input range. Although
conceptually <span class="d_inlinecode donthyphenate notranslate"><a name="sum"></a><span class="ddoc_psymbol">sum</span>(r)</span> is equivalent to <span class="d_inlinecode donthyphenate notranslate">reduce!((a, b) =&gt; a +
b)(0, r)</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="sum"></a><span class="ddoc_psymbol">sum</span></span> uses specialized algorithms to maximize accuracy,
as follows.
</div>
<div class="description"><ul><li>If <span class="d_inlinecode donthyphenate notranslate">ElementType!R</span> is a floating-point type and <span class="d_inlinecode donthyphenate notranslate">R</span> is a
random-access range with length and slicing, then <span class="d_inlinecode donthyphenate notranslate"><a name="sum"></a><span class="ddoc_psymbol">sum</span></span> uses the
<a href="http://en.wikipedia.org/wiki/Pairwise_summation">pairwise summation</a>
algorithm.</li>
<li>If <span class="d_inlinecode donthyphenate notranslate">ElementType!R</span> is a floating-point type and <span class="d_inlinecode donthyphenate notranslate">R</span> is a
finite input range (but not a random-access range with slicing), then
<span class="d_inlinecode donthyphenate notranslate"><a name="sum"></a><span class="ddoc_psymbol">sum</span></span> uses the <a href="http://en.wikipedia.org/wiki/Kahan_summation">Kahan summation</a> algorithm.</li>
<li>In all other cases, a simple element by element addition is done.</li>
</ul>
<p></p>

For floating point inputs, calculations are made in <span class="d_inlinecode donthyphenate notranslate">real</span>
precision for <span class="d_inlinecode donthyphenate notranslate">real</span> inputs and in <span class="d_inlinecode donthyphenate notranslate">double</span> precision otherwise
(Note this is a special case that deviates from <span class="d_inlinecode donthyphenate notranslate">reduce</span>'s behavior,
which would have kept <span class="d_inlinecode donthyphenate notranslate">float</span> precision for a <span class="d_inlinecode donthyphenate notranslate">float</span> range).
For all other types, the calculations are done in the same type obtained
from from adding two elements of the range, which may be a different
type from the elements themselves (for example, in case of integral promotion).
<p></p>

A seed may be passed to <span class="d_inlinecode donthyphenate notranslate"><a name="sum"></a><span class="ddoc_psymbol">sum</span></span>. Not only will this seed be used as an initial
value, but its type will override all the above, and determine the algorithm
and precision used for sumation.
<p></p>

Note that these specialized summing algorithms execute more primitive operations
than vanilla summation. Therefore, if in certain cases maximum speed is required
at expense of precision, one can use <span class="d_inlinecode donthyphenate notranslate">reduce!((a, b) =&gt; a + b)(0, r)</span>, which
is not specialized for summation.</div>

</dd>
<dt class="d_decl"><a name=".fill"></a><div class="quickindex" id="quickindex.fill"></div>void <a name="fill"></a><span class="ddoc_psymbol">fill</span>(Range, Value)(Range <i>range</i>, Value <i>filler</i>) if (isInputRange!Range &amp;&amp; is(typeof(<i>range</i>.front = <i>filler</i>)));
</dt>
<dd><div class="summary">Fills <span class="d_inlinecode donthyphenate notranslate">range</span> with a <span class="d_inlinecode donthyphenate notranslate">filler</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4 ];
<span class="d_psymbol">fill</span>(a, 5);
<span class="d_keyword">assert</span>(a == [ 5, 5, 5, 5 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".fill"></a><div class="quickindex" id="quickindex.fill"></div>void <a name="fill"></a><span class="ddoc_psymbol">fill</span>(Range1, Range2)(Range1 <i>range</i>, Range2 <i>filler</i>) if (isInputRange!Range1 &amp;&amp; (isForwardRange!Range2 || isInputRange!Range2 &amp;&amp; isInfinite!Range2) &amp;&amp; is(typeof(Range1.init.front = Range2.init.front)));
</dt>
<dd><div class="summary">Fills <span class="d_inlinecode donthyphenate notranslate">range</span> with a pattern copied from <span class="d_inlinecode donthyphenate notranslate">filler</span>. The length of
<span class="d_inlinecode donthyphenate notranslate">range</span> does not have to be a multiple of the length of <span class="d_inlinecode donthyphenate notranslate">filler</span>. If <span class="d_inlinecode donthyphenate notranslate">filler</span> is empty, an exception is thrown.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">int</span>[] b = [ 8, 9 ];
<span class="d_psymbol">fill</span>(a, b);
<span class="d_keyword">assert</span>(a == [ 8, 9, 8, 9, 8 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".uninitializedFill"></a><div class="quickindex" id="quickindex.uninitializedFill"></div>void <a name="uninitializedFill"></a><span class="ddoc_psymbol">uninitializedFill</span>(Range, Value)(Range <i>range</i>, Value <i>filler</i>) if (isInputRange!Range &amp;&amp; hasLvalueElements!Range &amp;&amp; is(typeof(<i>range</i>.front = <i>filler</i>)));
</dt>
<dd><div class="summary">Fills a range with a value. Assumes that the range does not currently
contain meaningful content. This is of interest for structs that
define copy constructors (for all other types, fill and
<a name="uninitializedFill"></a><span class="ddoc_psymbol">uninitializedFill</span> are equivalent).
</div>
<div class="description"><a name="uninitializedFill"></a><span class="ddoc_psymbol">uninitializedFill</span> will only operate on ranges that expose references to its
members and have assignable elements.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { ... }
S[] s = (<span class="d_keyword">cast</span>(S*) malloc(5 * S.sizeof))[0 .. 5];
<span class="d_psymbol">uninitializedFill</span>(s, 42);
<span class="d_keyword">assert</span>(s == [ 42, 42, 42, 42, 42 ]);
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".initializeAll"></a><div class="quickindex" id="quickindex.initializeAll"></div>void <a name="initializeAll"></a><span class="ddoc_psymbol">initializeAll</span>(Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; hasLvalueElements!Range &amp;&amp; hasAssignableElements!Range);
</dt>
<dd><div class="summary">Initializes all elements of a range with their <span class="d_inlinecode donthyphenate notranslate">.init</span>
value. Assumes that the range does not currently contain meaningful
content.
</div>
<div class="description"><a name="initializeAll"></a><span class="ddoc_psymbol">initializeAll</span> will operate on ranges that expose references to its
members and have assignable elements, as well as on (mutable) strings.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { ... }
S[] s = (<span class="d_keyword">cast</span>(S*) malloc(5 * S.sizeof))[0 .. 5];
<span class="d_psymbol">initializeAll</span>(s);
<span class="d_keyword">assert</span>(s == [ 0, 0, 0, 0, 0 ]);
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".filter"></a><div class="quickindex" id="quickindex.filter"></div>template <a name="filter"></a><span class="ddoc_psymbol">filter</span>(alias pred) if (is(typeof(unaryFun!pred)))</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate">auto <a name="filter"></a><span class="ddoc_psymbol">filter</span>(Range)(Range rs) if (isInputRange!(Unqual!Range));</span>
</div>
<div class="description">Implements the homonym function present in various programming
languages of functional flavor. The call <span class="d_inlinecode donthyphenate notranslate"><a name="filter"></a><span class="ddoc_psymbol">filter</span>!(predicate)(range)</span>
returns a new range only containing elements <span class="d_inlinecode donthyphenate notranslate">x</span> in <span class="d_inlinecode donthyphenate notranslate">range</span> for
which <span class="d_inlinecode donthyphenate notranslate">predicate(x)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.math : approxEqual;

<span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];

<span class="d_comment">// Sum all elements
</span><span class="d_keyword">auto</span> small = <span class="d_psymbol">filter</span>!(a =&gt; a &lt; 3)(arr);
<span class="d_keyword">assert</span>(equal(small, [ 1, 2 ]));

<span class="d_comment">// Sum again, but with Uniform Function Call Syntax (UFCS)
</span><span class="d_keyword">auto</span> sum = arr.<span class="d_psymbol">filter</span>!(a =&gt; a &lt; 3);
<span class="d_keyword">assert</span>(equal(sum, [ 1, 2 ]));

<span class="d_comment">// In combination with chain() to span multiple ranges
</span><span class="d_keyword">int</span>[] a = [ 3, -2, 400 ];
<span class="d_keyword">int</span>[] b = [ 100, -101, 102 ];
<span class="d_keyword">auto</span> r = chain(a, b).<span class="d_psymbol">filter</span>!(a =&gt; a &gt; 0);
<span class="d_keyword">assert</span>(equal(r, [ 3, 400, 100, 102 ]));

<span class="d_comment">// Mixing convertible types is fair game, too
</span><span class="d_keyword">double</span>[] c = [ 2.5, 3.0 ];
<span class="d_keyword">auto</span> r1 = chain(c, a, b).<span class="d_psymbol">filter</span>!(a =&gt; <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) a != a);
<span class="d_keyword">assert</span>(approxEqual(r1, [ 2.5 ]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".filterBidirectional"></a><div class="quickindex" id="quickindex.filterBidirectional"></div>template <a name="filterBidirectional"></a><span class="ddoc_psymbol">filterBidirectional</span>(alias pred)</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate">auto <a name="filterBidirectional"></a><span class="ddoc_psymbol">filterBidirectional</span>(Range)(Range r) if (isBidirectionalRange!(Unqual!Range));</span>
</div>
<div class="description">Similar to <span class="d_inlinecode donthyphenate notranslate">filter</span>, except it defines a bidirectional
 range. There is a speed disadvantage - the constructor spends time
 finding the last element in the range that satisfies the filtering
 condition (in addition to finding the first one). The advantage is
 that the filtered range can be spanned from both directions. Also,
 <span class="libref"><a href="http://dlang.org/phobos/std_range.html#retro"><span class="d_inlinecode donthyphenate notranslate">std.range.retro</span></a></span> can be applied against the filtered range.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">auto</span> small = <span class="d_psymbol">filterBidirectional</span>!(<span class="d_string">"a &lt; 3"</span>)(arr);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isBidirectionalRange!(<span class="d_keyword">typeof</span>(small)));
<span class="d_keyword">assert</span>(small.back == 2);
<span class="d_keyword">assert</span>(equal(small, [ 1, 2 ]));
<span class="d_keyword">assert</span>(equal(retro(small), [ 2, 1 ]));
<span class="d_comment">// In combination with chain() to span multiple ranges
</span><span class="d_keyword">int</span>[] a = [ 3, -2, 400 ];
<span class="d_keyword">int</span>[] b = [ 100, -101, 102 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">filterBidirectional</span>!(<span class="d_string">"a &gt; 0"</span>)(chain(a, b));
<span class="d_keyword">assert</span>(r.back == 102);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".move"></a><div class="quickindex" id="quickindex.move"></div>void <a name="move"></a><span class="ddoc_psymbol">move</span>(T)(ref T <i>source</i>, ref T <i>target</i>);
<br><a name=".move"></a><div class="quickindex" id="quickindex.move"></div>T <a name="move"></a><span class="ddoc_psymbol">move</span>(T)(ref T <i>source</i>);
</dt>
<dd><div class="summary">Moves <span class="d_inlinecode donthyphenate notranslate">source</span> into <span class="d_inlinecode donthyphenate notranslate">target</span> via a destructive
copy.</div>

</dd>
<dt class="d_decl"><a name=".moveAll"></a><div class="quickindex" id="quickindex.moveAll"></div>Range2 <a name="moveAll"></a><span class="ddoc_psymbol">moveAll</span>(Range1, Range2)(Range1 <i>src</i>, Range2 <i>tgt</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(move(<i>src</i>.front, <i>tgt</i>.front))));
</dt>
<dd><div class="summary">For each element <span class="d_inlinecode donthyphenate notranslate">a</span> in <span class="d_inlinecode donthyphenate notranslate">src</span> and each element <span class="d_inlinecode donthyphenate notranslate">b</span> in <span class="d_inlinecode donthyphenate notranslate">tgt</span> in lockstep in increasing order, calls <span class="d_inlinecode donthyphenate notranslate">move(a, b)</span>. Returns
the leftover portion of <span class="d_inlinecode donthyphenate notranslate">tgt</span>. Throws an exception if there is not
enough room in <span class="d_inlinecode donthyphenate notranslate">tgt</span> to accommodate all of <span class="d_inlinecode donthyphenate notranslate">src</span>.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Preconditions:</span>
<span class="d_inlinecode donthyphenate notranslate">walkLength(src) &lt;= walkLength(tgt)</span></div>

</dd>
<dt class="d_decl"><a name=".moveSome"></a><div class="quickindex" id="quickindex.moveSome"></div>Tuple!(Range1, Range2) <a name="moveSome"></a><span class="ddoc_psymbol">moveSome</span>(Range1, Range2)(Range1 <i>src</i>, Range2 <i>tgt</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(move(<i>src</i>.front, <i>tgt</i>.front))));
</dt>
<dd><div class="summary">For each element <span class="d_inlinecode donthyphenate notranslate">a</span> in <span class="d_inlinecode donthyphenate notranslate">src</span> and each element <span class="d_inlinecode donthyphenate notranslate">b</span> in <span class="d_inlinecode donthyphenate notranslate">tgt</span> in lockstep in increasing order, calls <span class="d_inlinecode donthyphenate notranslate">move(a, b)</span>. Stops
when either <span class="d_inlinecode donthyphenate notranslate">src</span> or <span class="d_inlinecode donthyphenate notranslate">tgt</span> have been exhausted. Returns the
leftover portions of the two ranges.</div>

</dd>
<dt class="d_decl"><a name=".swap"></a><div class="quickindex" id="quickindex.swap"></div>pure nothrow @trusted void <a name="swap"></a><span class="ddoc_psymbol">swap</span>(T)(ref T <i>lhs</i>, ref T <i>rhs</i>) if (isBlitAssignable!T &amp;&amp; !is(typeof(<i>lhs</i>.proxySwap(<i>rhs</i>))));
</dt>
<dd><div class="summary">Swaps <span class="d_inlinecode donthyphenate notranslate">lhs</span> and <span class="d_inlinecode donthyphenate notranslate">rhs</span>. The instances <span class="d_inlinecode donthyphenate notranslate">lhs</span> and <span class="d_inlinecode donthyphenate notranslate">rhs</span> are moved in
memory, without ever calling <span class="d_inlinecode donthyphenate notranslate">opAssign</span>, nor any other function. <span class="d_inlinecode donthyphenate notranslate">T</span>
need not be assignable at all to be swapped.
</div>
<div class="description">If <span class="d_inlinecode donthyphenate notranslate">lhs</span> and <span class="d_inlinecode donthyphenate notranslate">rhs</span> reference the same instance, then nothing is done.
<p></p>

<span class="d_inlinecode donthyphenate notranslate">lhs</span> and <span class="d_inlinecode donthyphenate notranslate">rhs</span> must be mutable. If <span class="d_inlinecode donthyphenate notranslate">T</span> is a struct or union, then
its fields must also all be (recursivelly) mutable.</div>

</dd>
<dt class="d_decl"><a name=".forward"></a><div class="quickindex" id="quickindex.forward"></div>template <a name="forward"></a><span class="ddoc_psymbol">forward</span>(args...)</dt>
<dd><div class="summary">Forwards function arguments with saving ref-ness.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> n) { <span class="d_keyword">return</span> 1; }
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> n) { <span class="d_keyword">return</span> 2; }
}
<span class="d_keyword">int</span> bar()(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> C.foo(<span class="d_psymbol">forward</span>!x); }

<span class="d_keyword">assert</span>(bar(1) == 1);
<span class="d_keyword">int</span> i;
<span class="d_keyword">assert</span>(bar(i) == 2);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> n, <span class="d_keyword">ref</span> string s) { s = <span class="d_keyword">null</span>; <span class="d_keyword">foreach</span> (i; 0..n) s ~= <span class="d_string">"Hello"</span>; }

<span class="d_comment">// forwards all arguments which are bound to parameter tuple
</span><span class="d_keyword">void</span> bar(Args...)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> Args args) { <span class="d_keyword">return</span> foo(<span class="d_psymbol">forward</span>!args); }

<span class="d_comment">// forwards all arguments with swapping order
</span><span class="d_keyword">void</span> baz(Args...)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> Args args) { <span class="d_keyword">return</span> foo(<span class="d_psymbol">forward</span>!args[$/2..$], <span class="d_psymbol">forward</span>!args[0..$/2]); }

string s;
bar(1, s);
<span class="d_keyword">assert</span>(s == <span class="d_string">"Hello"</span>);
baz(s, 2);
<span class="d_keyword">assert</span>(s == <span class="d_string">"HelloHello"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".splitter"></a><div class="quickindex" id="quickindex.splitter"></div>auto <a name="splitter"></a><span class="ddoc_psymbol">splitter</span>(Range, Separator)(Range <i>r</i>, Separator <i>s</i>) if (is(typeof(ElementType!Range.init == Separator.init)) &amp;&amp; (hasSlicing!Range &amp;&amp; hasLength!Range || isNarrowString!Range));
</dt>
<dd><div class="summary">Splits a range using an element as a separator. This can be used with
any narrow string type or sliceable range type, but is most popular
with string types.
</div>
<div class="description">Two adjacent separators are considered to surround an empty element in
the split range. Use <span class="d_inlinecode donthyphenate notranslate">filter!(a =&gt; !a.empty)</span> on the result to compress
empty elements.
<p></p>

If the empty range is given, the result is a range with one empty
element. If a range with one separator is given, the result is a range
with two empty elements.
<p></p>

If splitting a string on whitespace and token compression is desired,
consider using <span class="d_inlinecode donthyphenate notranslate"><a name="splitter"></a><span class="ddoc_psymbol">splitter</span></span> without specifying a separator (see overload
below).
<p></p>

See also <span class="libref"><a href="http://dlang.org/phobos/std_regex.html#<a name="splitter"></a><span class="ddoc_psymbol">splitter</span>"><span class="d_inlinecode donthyphenate notranslate">std.regex.<a name="splitter"></a><span class="ddoc_psymbol">splitter</span></span></a></span> for a version that splits using a regular
expression defined separator.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(<span class="d_string">"hello  world"</span>, ' '), [ <span class="d_string">"hello"</span>, <span class="d_string">""</span>, <span class="d_string">"world"</span> ]));
<span class="d_keyword">int</span>[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];
<span class="d_keyword">int</span>[][] w = [ [1, 2], [], [3], [4, 5], [] ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a, 0), w));
a = [ 0 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a, 0), [ (<span class="d_keyword">int</span>[]).init, (<span class="d_keyword">int</span>[]).init ]));
a = [ 0, 1 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a, 0), [ [], [1] ]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".splitter"></a><div class="quickindex" id="quickindex.splitter"></div>auto <a name="splitter"></a><span class="ddoc_psymbol">splitter</span>(Range, Separator)(Range <i>r</i>, Separator <i>s</i>) if (is(typeof(Range.init.front == Separator.init.front) : bool) &amp;&amp; (hasSlicing!Range || isNarrowString!Range) &amp;&amp; isForwardRange!Separator &amp;&amp; (hasLength!Separator || isNarrowString!Separator));
<br><a name=".splitter"></a><div class="quickindex" id="quickindex.splitter"></div>auto <a name="splitter"></a><span class="ddoc_psymbol">splitter</span>(alias isTerminator, Range)(Range <i>input</i>) if (isForwardRange!Range &amp;&amp; is(typeof(unaryFun!isTerminator(<i>input</i>.front))));
</dt>
<dd><div class="summary">Splits a range using another range as a separator. This can be used
with any narrow string type or sliceable range type, but is most popular
with string types.
</div>
<div class="description">Two adjacent separators are considered to surround an empty element in
the split range. Use <span class="d_inlinecode donthyphenate notranslate">filter!(a =&gt; !a.empty)</span> on the result to compress
empty elements.
<p></p>

See also <span class="libref"><a href="http://dlang.org/phobos/std_regex.html#<a name="splitter"></a><span class="ddoc_psymbol">splitter</span>"><span class="d_inlinecode donthyphenate notranslate">std.regex.<a name="splitter"></a><span class="ddoc_psymbol">splitter</span></span></a></span> for a version that splits using a regular
expression defined separator.</div>

</dd>
<dt class="d_decl"><a name=".splitter"></a><div class="quickindex" id="quickindex.splitter"></div>auto <a name="splitter"></a><span class="ddoc_psymbol">splitter</span>(C)(C[] <i>s</i>) if (isSomeChar!C);
</dt>
<dd><div class="summary">Lazily splits the string <span class="d_inlinecode donthyphenate notranslate">s</span> into words, using whitespace as the delimiter.
</div>
<div class="description">This function is string specific and, contrary to
<span class="d_inlinecode donthyphenate notranslate"><a name="splitter"></a><span class="ddoc_psymbol">splitter</span>!(std.uni.isWhite)</span>, runs of whitespace will be merged together
(no empty tokens will be produced).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = <span class="d_string">" a     bcd   ef gh "</span>;
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a), [<span class="d_string">"a"</span>, <span class="d_string">"bcd"</span>, <span class="d_string">"ef"</span>, <span class="d_string">"gh"</span>][]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".joiner"></a><div class="quickindex" id="quickindex.joiner"></div>auto <a name="joiner"></a><span class="ddoc_psymbol">joiner</span>(RoR, Separator)(RoR <i>r</i>, Separator <i>sep</i>) if (isInputRange!RoR &amp;&amp; isInputRange!(ElementType!RoR) &amp;&amp; isForwardRange!Separator &amp;&amp; is(ElementType!Separator : ElementType!(ElementType!RoR)));
<br><a name=".joiner"></a><div class="quickindex" id="quickindex.joiner"></div>auto <a name="joiner"></a><span class="ddoc_psymbol">joiner</span>(RoR)(RoR <i>r</i>) if (isInputRange!RoR &amp;&amp; isInputRange!(ElementType!RoR));
</dt>
<dd><div class="summary">Lazily joins a range of ranges with a separator. The separator itself
is a range. If you do not provide a separator, then the ranges are
joined directly without anything in between them.
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.conv : text;

<span class="d_keyword">debug</span>(std_algorithm) <span class="d_keyword">scope</span>(success)
    writeln(<span class="d_string">"unittest @"</span>, <span class="d_keyword">__FILE__</span>, <span class="d_string">":"</span>, <span class="d_keyword">__LINE__</span>, <span class="d_string">" done."</span>);

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isInputRange!(<span class="d_keyword">typeof</span>(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>], <span class="d_string">""</span>))));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!(<span class="d_keyword">typeof</span>(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>], <span class="d_string">""</span>))));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">""</span>), text(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>], <span class="d_string">"xyz"</span>)));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>, <span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"xyz"</span>), text(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>, <span class="d_string">""</span>], <span class="d_string">"xyz"</span>)));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>, <span class="d_string">"abc"</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"xyzabc"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"abc"</span>, <span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"abcxyz"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"abcxyzdef"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"Mary"</span>, <span class="d_string">"has"</span>, <span class="d_string">"a"</span>, <span class="d_string">"little"</span>, <span class="d_string">"lamb"</span>], <span class="d_string">"..."</span>),
                <span class="d_string">"Mary...has...a...little...lamb"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>]), <span class="d_string">"abcdef"</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".uniq"></a><div class="quickindex" id="quickindex.uniq"></div>auto <a name="uniq"></a><span class="ddoc_psymbol">uniq</span>(alias pred = "a == b", Range)(Range <i>r</i>) if (isInputRange!Range &amp;&amp; is(typeof(binaryFun!pred(<i>r</i>.front, <i>r</i>.front)) == bool));
</dt>
<dd><div class="summary">Iterates unique consecutive elements of the given range (functionality
akin to the <a href="http://wikipedia.org/wiki/Uniq">uniq</a> system
utility). Equivalence of elements is assessed by using the predicate
<span class="d_inlinecode donthyphenate notranslate">pred</span>, by default <span class="d_inlinecode donthyphenate notranslate">"a == b"</span>. If the given range is
bidirectional, <span class="d_inlinecode donthyphenate notranslate"><a name="uniq"></a><span class="ddoc_psymbol">uniq</span></span> also yields a bidirectional range.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">uniq</span>(arr), [ 1, 2, 3, 4, 5 ][]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Group"></a><div class="quickindex" id="quickindex.Group"></div>struct <a name="Group"></a><span class="ddoc_psymbol">Group</span>(alias pred, R) if (isInputRange!R);
<br><a name=".group"></a><div class="quickindex" id="quickindex.group"></div>Group!(pred, Range) <a name="group"></a><span class="ddoc_psymbol">group</span>(alias pred = "a == b", Range)(Range <i>r</i>);
</dt>
<dd><div class="summary">Similarly to <span class="d_inlinecode donthyphenate notranslate">uniq</span>, <span class="d_inlinecode donthyphenate notranslate">group</span> iterates unique consecutive
elements of the given range. The element type is <span class="d_inlinecode donthyphenate notranslate">Tuple!(ElementType!R, uint)</span> because it includes the count of
equivalent elements seen. Equivalence of elements is assessed by using
the predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>, by default <span class="d_inlinecode donthyphenate notranslate">"a == b"</span>.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="Group"></a><span class="ddoc_psymbol">Group</span></span> is an input range if <span class="d_inlinecode donthyphenate notranslate">R</span> is an input range, and a
forward range in all other cases.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">group</span>(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),
    tuple(4, 3u), tuple(5, 1u) ][]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".find"></a><div class="quickindex" id="quickindex.find"></div>InputRange <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred = "a == b", InputRange, Element)(InputRange <i>haystack</i>, Element <i>needle</i>) if (isInputRange!InputRange &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>)) : bool));
</dt>
<dd><div class="summary">Finds an individual element in an input range. Elements of <span class="d_inlinecode donthyphenate notranslate">haystack</span> are compared with <span class="d_inlinecode donthyphenate notranslate">needle</span> by using predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">walkLength(haystack)</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.
</div>
<div class="description">To find the last occurrence of <span class="d_inlinecode donthyphenate notranslate">needle</span> in <span class="d_inlinecode donthyphenate notranslate">haystack</span>, call <span class="d_inlinecode donthyphenate notranslate"><a name="find"></a><span class="ddoc_psymbol">find</span>(retro(haystack), needle)</span>. See <span class="libref"><a href="http://dlang.org/phobos/std_range.html#retro"><span class="d_inlinecode donthyphenate notranslate">std.range.retro</span></a></span>.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">InputRange haystack</td>
<td class="param_desc">The range searched in.</td></tr>
<tr class="param"><td class="param_id">Element needle</td>
<td class="param_desc">The element searched for.</td></tr>
</table></div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Constraints:</span>
<span class="d_inlinecode donthyphenate notranslate">isInputRange!InputRange &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle)
: bool))</span>

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><span class="d_inlinecode donthyphenate notranslate">haystack</span> advanced such that <span class="d_inlinecode donthyphenate notranslate">binaryFun!pred(haystack.front,
needle)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> (if no such position exists, returns <span class="d_inlinecode donthyphenate notranslate">haystack</span> after exhaustion).

</div></div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/find.html">STL's find</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.container : SList;

<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(<span class="d_string">"hello, world"</span>, ',') == <span class="d_string">", world"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>([1, 2, 3, 5], 4) == []);
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">find</span>(SList!<span class="d_keyword">int</span>(1, 2, 3, 4, 5)[], 4), SList!<span class="d_keyword">int</span>(4, 5)[]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>!<span class="d_string">"a &gt; b"</span>([1, 2, 3, 5], 2) == [3, 5]);

<span class="d_keyword">auto</span> a = [ 1, 2, 3 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, 5).empty);       <span class="d_comment">// not found
</span><span class="d_keyword">assert</span>(!<span class="d_psymbol">find</span>(a, 2).empty);      <span class="d_comment">// found
</span>
<span class="d_comment">// Case-insensitive find of a string
</span>string[] s = [ <span class="d_string">"Hello"</span>, <span class="d_string">"world"</span>, <span class="d_string">"!"</span> ];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">find</span>!(<span class="d_string">"toLower(a) == b"</span>)(s, <span class="d_string">"hello"</span>).empty);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".find"></a><div class="quickindex" id="quickindex.find"></div>R1 <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>.front)) : bool) &amp;&amp; !isRandomAccessRange!R1);
</dt>
<dd><div class="summary">Finds a forward range in another. Elements are compared for
equality. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">walkLength(haystack) * walkLength(needle)</span>)</span>
comparisons in the worst case. Specializations taking advantage of
bidirectional or random access (where present) may accelerate search
depending on the statistics of the two ranges' content.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">R1 haystack</td>
<td class="param_desc">The range searched in.</td></tr>
<tr class="param"><td class="param_id">R2 needle</td>
<td class="param_desc">The range searched for.</td></tr>
</table></div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Constraints:</span>
<span class="d_inlinecode donthyphenate notranslate">isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp;
is(typeof(binaryFun!pred(haystack.front, needle.front) : bool))</span>

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><span class="d_inlinecode donthyphenate notranslate">haystack</span> advanced such that <span class="d_inlinecode donthyphenate notranslate">needle</span> is a prefix of it (if no
such position exists, returns <span class="d_inlinecode donthyphenate notranslate">haystack</span> advanced to termination).</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.container : SList;

<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(<span class="d_string">"hello, world"</span>, <span class="d_string">"World"</span>).empty);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(<span class="d_string">"hello, world"</span>, <span class="d_string">"wo"</span>) == <span class="d_string">"world"</span>);
<span class="d_keyword">assert</span>([1, 2, 3, 4].<span class="d_psymbol">find</span>(SList!<span class="d_keyword">int</span>(2, 3)[]) == [2, 3, 4]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".find"></a><div class="quickindex" id="quickindex.find"></div>Tuple!(Range, size_t) <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred = "a == b", Range, Ranges...)(Range <i>haystack</i>, Ranges <i>needles</i>) if (Ranges.length &gt; 1 &amp;&amp; is(typeof(startsWith!pred(<i>haystack</i>, <i>needles</i>))));
<br><a name=".BoyerMooreFinder"></a><div class="quickindex" id="quickindex.BoyerMooreFinder"></div>struct <a name="BoyerMooreFinder"></a><span class="ddoc_psymbol">BoyerMooreFinder</span>(alias pred, Range);
<br><a name=".boyerMooreFinder"></a><div class="quickindex" id="quickindex.boyerMooreFinder"></div>BoyerMooreFinder!(binaryFun!pred, Range) <a name="boyerMooreFinder"></a><span class="ddoc_psymbol">boyerMooreFinder</span>(alias pred = "a == b", Range)(Range <i>needle</i>) if (isRandomAccessRange!Range || isSomeString!Range);
</dt>
<dd><div class="summary">Finds two or more <span class="d_inlinecode donthyphenate notranslate">needles</span> into a <span class="d_inlinecode donthyphenate notranslate">haystack</span>. The predicate <span class="d_inlinecode donthyphenate notranslate">pred</span> is used throughout to compare elements. By default, elements are
compared for equality.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate">BoyerMooreFinder</span> allocates GC memory.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">Range haystack</td>
<td class="param_desc">The target of the search. Must be an <a href="http://dlang.org/glossary.html#input
range">input
range</a>. If any of <span class="d_inlinecode donthyphenate notranslate">needles</span> is a range with elements comparable to
elements in <span class="d_inlinecode donthyphenate notranslate">haystack</span>, then <span class="d_inlinecode donthyphenate notranslate">haystack</span> must be a <a href="http://dlang.org/glossary.html#forward range">forward range</a> such that the search can backtrack.</td></tr>
<tr class="param"><td class="param_id">Ranges needles</td>
<td class="param_desc">One or more items to search for. Each of <span class="d_inlinecode donthyphenate notranslate">needles</span> must
be either comparable to one element in <span class="d_inlinecode donthyphenate notranslate">haystack</span>, or be itself a
<a href="http://dlang.org/glossary.html#forward range">forward range</a> with elements comparable with elements in
<span class="d_inlinecode donthyphenate notranslate">haystack</span>.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A tuple containing <span class="d_inlinecode donthyphenate notranslate">haystack</span> positioned to match one of the
needles and also the 1-based index of the matching element in <span class="d_inlinecode donthyphenate notranslate">needles</span> (0 if none of <span class="d_inlinecode donthyphenate notranslate">needles</span> matched, 1 if <span class="d_inlinecode donthyphenate notranslate">needles[0]</span>
matched, 2 if <span class="d_inlinecode donthyphenate notranslate">needles[1]</span> matched...). The first needle to be found
will be the one that matches. If multiple needles are found at the
same spot in the range, then the shortest one is the one which matches
(if multiple needles of the same length are found at the same spot (e.g
<span class="d_inlinecode donthyphenate notranslate">"a"</span> and <span class="d_inlinecode donthyphenate notranslate">'a'</span>), then the left-most of them in the argument list
matches).
<p></p>

The relationship between <span class="d_inlinecode donthyphenate notranslate">haystack</span> and <span class="d_inlinecode donthyphenate notranslate">needles</span> simply means
that one can e.g. search for individual <span class="d_inlinecode donthyphenate notranslate">int</span>s or arrays of <span class="d_inlinecode donthyphenate notranslate">int</span>s in an array of <span class="d_inlinecode donthyphenate notranslate">int</span>s. In addition, if elements are
individually comparable, searches of heterogeneous types are allowed
as well: a <span class="d_inlinecode donthyphenate notranslate">double[]</span> can be searched for an <span class="d_inlinecode donthyphenate notranslate">int</span> or a <span class="d_inlinecode donthyphenate notranslate">short[]</span>, and conversely a <span class="d_inlinecode donthyphenate notranslate">long</span> can be searched for a <span class="d_inlinecode donthyphenate notranslate">float</span>
or a <span class="d_inlinecode donthyphenate notranslate">double[]</span>. This makes for efficient searches without the need
to coerce one side of the comparison into the other's side type.
<p></p>

The complexity of the search is <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">haystack.length *
max(needles.length)</span>)</span>. (For needles that are individual items, length
is considered to be 1.) The strategy used in searching several
subranges at once maximizes cache usage by moving in <span class="d_inlinecode donthyphenate notranslate">haystack</span> as
few times as possible.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 4, 2, 3 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, 4) == [ 4, 2, 3 ]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));
<span class="d_comment">// Mixed types allowed if comparable
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, 5, [ 1.2, 3.5 ], 2.0) == tuple([ 2, 3 ], 3));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".find"></a><div class="quickindex" id="quickindex.find"></div>InputRange <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred, InputRange)(InputRange <i>haystack</i>) if (isInputRange!InputRange);
</dt>
<dd><div class="summary">Advances the input range <span class="d_inlinecode donthyphenate notranslate">haystack</span> by calling <span class="d_inlinecode donthyphenate notranslate">haystack.popFront</span>
until either <span class="d_inlinecode donthyphenate notranslate">pred(haystack.front)</span>, or <span class="d_inlinecode donthyphenate notranslate">haystack.empty</span>. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">haystack.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.
</div>
<div class="description">To <a name="find"></a><span class="ddoc_psymbol">find</span> the last element of a bidirectional <span class="d_inlinecode donthyphenate notranslate">haystack</span> satisfying
<span class="d_inlinecode donthyphenate notranslate">pred</span>, call <span class="d_inlinecode donthyphenate notranslate"><a name="find"></a><span class="ddoc_psymbol">find</span>!(pred)(retro(haystack))</span>. See <span class="libref"><a href="http://dlang.org/phobos/std_range.html#retro"><span class="d_inlinecode donthyphenate notranslate">std.range.retro</span></a></span>.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/find_if.html">STL's find_if</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> arr = [ 1, 2, 3, 4, 1 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>!(<span class="d_string">"a &gt; 2"</span>)(arr) == [ 3, 4, 1 ]);

<span class="d_comment">// with predicate alias
</span><span class="d_keyword">bool</span> pred(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x + 1 &gt; 1.5; }
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>!(pred)(arr) == arr);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".findSkip"></a><div class="quickindex" id="quickindex.findSkip"></div>bool <a name="findSkip"></a><span class="ddoc_psymbol">findSkip</span>(alias pred = "a == b", R1, R2)(ref R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>.front))));
</dt>
<dd><div class="summary">If <span class="d_inlinecode donthyphenate notranslate">needle</span> occurs in <span class="d_inlinecode donthyphenate notranslate">haystack</span>, positions <span class="d_inlinecode donthyphenate notranslate">haystack</span>
 right after the first occurrence of <span class="d_inlinecode donthyphenate notranslate">needle</span> and returns <span class="d_inlinecode donthyphenate notranslate"> <b>true</b></span>. Otherwise, leaves <span class="d_inlinecode donthyphenate notranslate">haystack</span> as is and returns <span class="d_inlinecode donthyphenate notranslate"> <b>false</b></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
string s = <span class="d_string">"abcdef"</span>;
<span class="d_keyword">assert</span>(<span class="d_psymbol">findSkip</span>(s, <span class="d_string">"cd"</span>) &amp;&amp; s == <span class="d_string">"ef"</span>);
s = <span class="d_string">"abcdef"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">findSkip</span>(s, <span class="d_string">"cxd"</span>) &amp;&amp; s == <span class="d_string">"abcdef"</span>);
s = <span class="d_string">"abcdef"</span>;
<span class="d_keyword">assert</span>(<span class="d_psymbol">findSkip</span>(s, <span class="d_string">"def"</span>) &amp;&amp; s.empty);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".findSplit"></a><div class="quickindex" id="quickindex.findSplit"></div>auto <a name="findSplit"></a><span class="ddoc_psymbol">findSplit</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
<br><a name=".findSplitBefore"></a><div class="quickindex" id="quickindex.findSplitBefore"></div>auto <a name="findSplitBefore"></a><span class="ddoc_psymbol">findSplitBefore</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
<br><a name=".findSplitAfter"></a><div class="quickindex" id="quickindex.findSplitAfter"></div>auto <a name="findSplitAfter"></a><span class="ddoc_psymbol">findSplitAfter</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
</dt>
<dd><div class="summary">These functions find the first occurrence of <span class="d_inlinecode donthyphenate notranslate">needle</span> in <span class="d_inlinecode donthyphenate notranslate">haystack</span> and then split <span class="d_inlinecode donthyphenate notranslate">haystack</span> as follows.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="findSplit"></a><span class="ddoc_psymbol">findSplit</span></span> returns a tuple <span class="d_inlinecode donthyphenate notranslate">result</span> containing <i>three</i>
ranges. <span class="d_inlinecode donthyphenate notranslate">result[0]</span> is the portion of <span class="d_inlinecode donthyphenate notranslate">haystack</span> before <span class="d_inlinecode donthyphenate notranslate">needle</span>, <span class="d_inlinecode donthyphenate notranslate">result[1]</span> is the portion of <span class="d_inlinecode donthyphenate notranslate">haystack</span> that matches
<span class="d_inlinecode donthyphenate notranslate">needle</span>, and <span class="d_inlinecode donthyphenate notranslate">result[2]</span> is the portion of <span class="d_inlinecode donthyphenate notranslate">haystack</span> after
the match. If <span class="d_inlinecode donthyphenate notranslate">needle</span> was not found, <span class="d_inlinecode donthyphenate notranslate">result[0]</span>
comprehends <span class="d_inlinecode donthyphenate notranslate">haystack</span> entirely and <span class="d_inlinecode donthyphenate notranslate">result[1]</span> and <span class="d_inlinecode donthyphenate notranslate">result[2]</span>
are empty.
<p></p>

<span class="d_inlinecode donthyphenate notranslate">findSplitBefore</span> returns a tuple <span class="d_inlinecode donthyphenate notranslate">result</span> containing two
ranges. <span class="d_inlinecode donthyphenate notranslate">result[0]</span> is the portion of <span class="d_inlinecode donthyphenate notranslate">haystack</span> before <span class="d_inlinecode donthyphenate notranslate">needle</span>, and <span class="d_inlinecode donthyphenate notranslate">result[1]</span> is the balance of <span class="d_inlinecode donthyphenate notranslate">haystack</span> starting
with the match. If <span class="d_inlinecode donthyphenate notranslate">needle</span> was not found, <span class="d_inlinecode donthyphenate notranslate">result[0]</span>
comprehends <span class="d_inlinecode donthyphenate notranslate">haystack</span> entirely and <span class="d_inlinecode donthyphenate notranslate">result[1]</span> is empty.
<p></p>

<span class="d_inlinecode donthyphenate notranslate">findSplitAfter</span> returns a tuple <span class="d_inlinecode donthyphenate notranslate">result</span> containing two ranges.
<span class="d_inlinecode donthyphenate notranslate">result[0]</span> is the portion of <span class="d_inlinecode donthyphenate notranslate">haystack</span> up to and including the
match, and <span class="d_inlinecode donthyphenate notranslate">result[1]</span> is the balance of <span class="d_inlinecode donthyphenate notranslate">haystack</span> starting
after the match. If <span class="d_inlinecode donthyphenate notranslate">needle</span> was not found, <span class="d_inlinecode donthyphenate notranslate">result[0]</span> is empty
and <span class="d_inlinecode donthyphenate notranslate">result[1]</span> is <span class="d_inlinecode donthyphenate notranslate">haystack</span>.
<p></p>

In all cases, the concatenation of the returned ranges spans the
entire <span class="d_inlinecode donthyphenate notranslate">haystack</span>.
<p></p>

If <span class="d_inlinecode donthyphenate notranslate">haystack</span> is a random-access range, all three components of the
tuple have the same type as <span class="d_inlinecode donthyphenate notranslate">haystack</span>. Otherwise, <span class="d_inlinecode donthyphenate notranslate">haystack</span>
must be a forward range and the type of <span class="d_inlinecode donthyphenate notranslate">result[0]</span> and <span class="d_inlinecode donthyphenate notranslate">result[1]</span> is the same as <span class="libref"><a href="http://dlang.org/phobos/std_range.html#takeExactly"><span class="d_inlinecode donthyphenate notranslate">std.range.takeExactly</span></a></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = <span class="d_string">"Carl Sagan Memorial Station"</span>;
<span class="d_keyword">auto</span> r = findSplit(a, <span class="d_string">"Velikovsky"</span>);
<span class="d_keyword">assert</span>(r[0] == a);
<span class="d_keyword">assert</span>(r[1].empty);
<span class="d_keyword">assert</span>(r[2].empty);
r = findSplit(a, <span class="d_string">" "</span>);
<span class="d_keyword">assert</span>(r[0] == <span class="d_string">"Carl"</span>);
<span class="d_keyword">assert</span>(r[1] == <span class="d_string">" "</span>);
<span class="d_keyword">assert</span>(r[2] == <span class="d_string">"Sagan Memorial Station"</span>);
<span class="d_keyword">auto</span> r1 = findSplitBefore(a, <span class="d_string">"Sagan"</span>);
<span class="d_keyword">assert</span>(r1[0] == <span class="d_string">"Carl "</span>, r1[0]);
<span class="d_keyword">assert</span>(r1[1] == <span class="d_string">"Sagan Memorial Station"</span>);
<span class="d_keyword">auto</span> r2 = <span class="d_psymbol">findSplitAfter</span>(a, <span class="d_string">"Sagan"</span>);
<span class="d_keyword">assert</span>(r2[0] == <span class="d_string">"Carl Sagan"</span>);
<span class="d_keyword">assert</span>(r2[1] == <span class="d_string">" Memorial Station"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".countUntil"></a><div class="quickindex" id="quickindex.countUntil"></div>ptrdiff_t <a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>(alias pred = "a == b", R, Rs...)(R <i>haystack</i>, Rs <i>needles</i>) if (isForwardRange!R &amp;&amp; Rs.length &gt; 0 &amp;&amp; isForwardRange!(Rs[0]) == isInputRange!(Rs[0]) &amp;&amp; is(typeof(startsWith!pred(<i>haystack</i>, <i>needles</i>[0]))) &amp;&amp; (Rs.length == 1 || is(typeof(<a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>!pred(<i>haystack</i>, <i>needles</i>[1..$])))));
<br><a name=".countUntil"></a><div class="quickindex" id="quickindex.countUntil"></div>ptrdiff_t <a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>(alias pred = "a == b", R, N)(R <i>haystack</i>, N <i>needle</i>) if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>)) : bool));
</dt>
<dd><div class="summary">Returns the number of elements which must be popped from the front of
    <span class="d_inlinecode donthyphenate notranslate">haystack</span> before reaching an element for which
    <span class="d_inlinecode donthyphenate notranslate">startsWith!pred(haystack, needles)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>. If
    <span class="d_inlinecode donthyphenate notranslate">startsWith!pred(haystack, needles)</span> is not <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> for any element in
    <span class="d_inlinecode donthyphenate notranslate">haystack</span>, then <span class="d_inlinecode donthyphenate notranslate">-1</span> is returned.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate">needles</span> may be either an element or a range.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">"hello world"</span>, <span class="d_string">"world"</span>) == 6);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">"hello world"</span>, 'r') == 8);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">"hello world"</span>, <span class="d_string">"programming"</span>) == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, <span class="d_string">""</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, '')   == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, <span class="d_string">""</span>) == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, '') == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>([0, 7, 12, 22, 9], [12, 22]) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>([0, 7, 12, 22, 9], 9) == 4);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!<span class="d_string">"a &gt; b"</span>([0, 7, 12, 22, 9], 20) == 3);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".countUntil"></a><div class="quickindex" id="quickindex.countUntil"></div>ptrdiff_t <a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>(alias pred, R)(R <i>haystack</i>) if (isInputRange!R &amp;&amp; is(typeof(unaryFun!pred(<i>haystack</i>.front)) : bool));
</dt>
<dd><div class="summary">Returns the number of elements which must be popped from <span class="d_inlinecode donthyphenate notranslate">haystack</span>
    before <span class="d_inlinecode donthyphenate notranslate">pred(haystack.front)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.ascii : isDigit;
<span class="d_keyword">import</span> std.uni : isWhite;

<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!(std.uni.isWhite)(<span class="d_string">"hello world"</span>) == 5);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!(std.ascii.isDigit)(<span class="d_string">"hello world"</span>) == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!<span class="d_string">"a &gt; 20"</span>([0, 7, 12, 22, 9]) == 3);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".OpenRight"></a><div class="quickindex" id="quickindex.OpenRight"></div>enum <a name="OpenRight"></a><span class="ddoc_psymbol">OpenRight</span>: int;
</dt>
<dd><div class="summary">Interval option specifier for <span class="d_inlinecode donthyphenate notranslate">until</span> (below) and others.</div>

<dl><dt class="d_decl"><a name=".OpenRight.no"></a><div class="quickindex" id="quickindex.OpenRight.no"></div><a name="no"></a><span class="ddoc_psymbol">no</span></dt>
<dd><div class="summary">Interval is closed to the right (last element included)</div>

</dd>
<dt class="d_decl"><a name=".OpenRight.yes"></a><div class="quickindex" id="quickindex.OpenRight.yes"></div><a name="yes"></a><span class="ddoc_psymbol">yes</span></dt>
<dd><div class="summary">Interval is open to the right (last element is not included)</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Until"></a><div class="quickindex" id="quickindex.Until"></div>struct <a name="Until"></a><span class="ddoc_psymbol">Until</span>(alias pred, Range, Sentinel) if (isInputRange!Range);
<br><a name=".until"></a><div class="quickindex" id="quickindex.until"></div>Until!(pred, Range, Sentinel) <a name="until"></a><span class="ddoc_psymbol">until</span>(alias pred = "a == b", Range, Sentinel)(Range <i>range</i>, Sentinel <i>sentinel</i>, OpenRight <i>openRight</i> = OpenRight.yes) if (!is(Sentinel == OpenRight));
<br><a name=".until"></a><div class="quickindex" id="quickindex.until"></div>Until!(pred, Range, void) <a name="until"></a><span class="ddoc_psymbol">until</span>(alias pred, Range)(Range <i>range</i>, OpenRight <i>openRight</i> = OpenRight.yes);
</dt>
<dd><div class="summary">Lazily iterates <span class="d_inlinecode donthyphenate notranslate">range</span> until value <span class="d_inlinecode donthyphenate notranslate">sentinel</span> is found, at
which point it stops.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];
<span class="d_keyword">assert</span>(equal(a.<span class="d_psymbol">until</span>(7), [1, 2, 4][]));
<span class="d_keyword">assert</span>(equal(a.<span class="d_psymbol">until</span>(7, OpenRight.no), [1, 2, 4, 7][]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".startsWith"></a><div class="quickindex" id="quickindex.startsWith"></div>uint <a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>(alias pred = "a == b", Range, Needles...)(Range <i>doesThisStart</i>, Needles <i>withOneOfThese</i>) if (isInputRange!Range &amp;&amp; Needles.length &gt; 1 &amp;&amp; is(typeof(.<a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>!pred(<i>doesThisStart</i>, <i>withOneOfThese</i>[0])) : bool) &amp;&amp; is(typeof(.<a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>!pred(<i>doesThisStart</i>, <i>withOneOfThese</i>[1..$])) : uint));
<br><a name=".startsWith"></a><div class="quickindex" id="quickindex.startsWith"></div>bool <a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>(alias pred = "a == b", R1, R2)(R1 <i>doesThisStart</i>, R2 <i>withThis</i>) if (isInputRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisStart</i>.front, <i>withThis</i>.front)) : bool));
<br><a name=".startsWith"></a><div class="quickindex" id="quickindex.startsWith"></div>bool <a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>(alias pred = "a == b", R, E)(R <i>doesThisStart</i>, E <i>withThis</i>) if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisStart</i>.front, <i>withThis</i>)) : bool));
</dt>
<dd><div class="summary">If the range <span class="d_inlinecode donthyphenate notranslate">doesThisStart</span> starts with <i>any</i> of the <span class="d_inlinecode donthyphenate notranslate">withOneOfThese</span> ranges or elements, returns 1 if it starts with <span class="d_inlinecode donthyphenate notranslate">withOneOfThese[0]</span>, 2 if it starts with <span class="d_inlinecode donthyphenate notranslate">withOneOfThese[1]</span>, and so
on. If none match, returns 0. In the case where <span class="d_inlinecode donthyphenate notranslate">doesThisStart</span> starts
with multiple of the ranges or elements in <span class="d_inlinecode donthyphenate notranslate">withOneOfThese</span>, then the
shortest one matches (if there are two which match which are of the same
length (e.g. <span class="d_inlinecode donthyphenate notranslate">"a"</span> and <span class="d_inlinecode donthyphenate notranslate">'a'</span>), then the left-most of them in the argument
list matches).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>));
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, 'a', <span class="d_string">"b"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>, <span class="d_string">"a"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>, <span class="d_string">"a"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"ab"</span>, <span class="d_string">"a"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"a"</span>, <span class="d_string">"b"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aa"</span>, <span class="d_string">"ab"</span>) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"sab"</span>) == 0);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"a"</span>, <span class="d_string">"sab"</span>) == 3);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".skipOver"></a><div class="quickindex" id="quickindex.skipOver"></div>bool <a name="skipOver"></a><span class="ddoc_psymbol">skipOver</span>(alias pred = "a == b", R1, R2)(ref R1 <i>r1</i>, R2 <i>r2</i>) if (is(typeof(binaryFun!pred(<i>r1</i>.front, <i>r2</i>.front))));
</dt>
<dd><div class="summary">If <span class="d_inlinecode donthyphenate notranslate">startsWith(r1, r2)</span>, consume the corresponding elements off <span class="d_inlinecode donthyphenate notranslate">r1</span> and return <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>. Otherwise, leave <span class="d_inlinecode donthyphenate notranslate">r1</span> unchanged and
return <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> s1 = <span class="d_string">"Hello world"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">skipOver</span>(s1, <span class="d_string">"Ha"</span>));
<span class="d_keyword">assert</span>(s1 == <span class="d_string">"Hello world"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">skipOver</span>(s1, <span class="d_string">"Hell"</span>) &amp;&amp; s1 == <span class="d_string">"o world"</span>);

string[]  r1 = [<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>, <span class="d_string">"hij"</span>];
dstring[] r2 = [<span class="d_string">"abc"d</span>];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">skipOver</span>!((a, b) =&gt; a.equal(b))(r1, [<span class="d_string">"def"d</span>]));
<span class="d_keyword">assert</span>(r1 == [<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>, <span class="d_string">"hij"</span>]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">skipOver</span>!((a, b) =&gt; a.equal(b))(r1, r2));
<span class="d_keyword">assert</span>(r1 == [<span class="d_string">"def"</span>, <span class="d_string">"hij"</span>]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".skipOver"></a><div class="quickindex" id="quickindex.skipOver"></div>bool <a name="skipOver"></a><span class="ddoc_psymbol">skipOver</span>(alias pred = "a == b", R, E)(ref R <i>r</i>, E <i>e</i>) if (is(typeof(binaryFun!pred(<i>r</i>.front, <i>e</i>))));
</dt>
<dd><div class="summary">Checks whether a range starts with an element, and if so, consume that
element off <span class="d_inlinecode donthyphenate notranslate">r</span> and return <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>. Otherwise, leave <span class="d_inlinecode donthyphenate notranslate">r</span>
unchanged and return <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> s1 = <span class="d_string">"Hello world"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">skipOver</span>(s1, 'a'));
<span class="d_keyword">assert</span>(s1 == <span class="d_string">"Hello world"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">skipOver</span>(s1, 'H') &amp;&amp; s1 == <span class="d_string">"ello world"</span>);

string[] r = [<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>, <span class="d_string">"hij"</span>];
dstring e = <span class="d_string">"abc"d</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">skipOver</span>!((a, b) =&gt; a.equal(b))(r, <span class="d_string">"def"d</span>));
<span class="d_keyword">assert</span>(r == [<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>, <span class="d_string">"hij"</span>]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">skipOver</span>!((a, b) =&gt; a.equal(b))(r, e));
<span class="d_keyword">assert</span>(r == [<span class="d_string">"def"</span>, <span class="d_string">"hij"</span>]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".endsWith"></a><div class="quickindex" id="quickindex.endsWith"></div>uint <a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>(alias pred = "a == b", Range, Needles...)(Range <i>doesThisEnd</i>, Needles <i>withOneOfThese</i>) if (isBidirectionalRange!Range &amp;&amp; Needles.length &gt; 1 &amp;&amp; is(typeof(.<a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>!pred(<i>doesThisEnd</i>, <i>withOneOfThese</i>[0])) : bool) &amp;&amp; is(typeof(.<a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>!pred(<i>doesThisEnd</i>, <i>withOneOfThese</i>[1..$])) : uint));
<br><a name=".endsWith"></a><div class="quickindex" id="quickindex.endsWith"></div>bool <a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>(alias pred = "a == b", R1, R2)(R1 <i>doesThisEnd</i>, R2 <i>withThis</i>) if (isBidirectionalRange!R1 &amp;&amp; isBidirectionalRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisEnd</i>.back, <i>withThis</i>.back)) : bool));
<br><a name=".endsWith"></a><div class="quickindex" id="quickindex.endsWith"></div>bool <a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>(alias pred = "a == b", R, E)(R <i>doesThisEnd</i>, E <i>withThis</i>) if (isBidirectionalRange!R &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisEnd</i>.back, <i>withThis</i>)) : bool));
</dt>
<dd><div class="summary">The reciprocal of <span class="d_inlinecode donthyphenate notranslate">startsWith</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>));
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>, 'c') == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"c"</span>, <span class="d_string">"a"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"c"</span>, <span class="d_string">"c"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"bc"</span>, <span class="d_string">"c"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"c"</span>, <span class="d_string">"b"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aa"</span>, <span class="d_string">"bc"</span>) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"sab"</span>) == 0);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, 'c', <span class="d_string">"sab"</span>) == 3);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".commonPrefix"></a><div class="quickindex" id="quickindex.commonPrefix"></div>auto <a name="commonPrefix"></a><span class="ddoc_psymbol">commonPrefix</span>(alias pred = "a == b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>) if (isForwardRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; !isNarrowString!R1 &amp;&amp; is(typeof(binaryFun!pred(<i>r1</i>.front, <i>r2</i>.front))));
</dt>
<dd><div class="summary">Returns the common prefix of two ranges.
</div>
<div class="description">If the first argument is a string, then the result is a slice of <span class="d_inlinecode donthyphenate notranslate">r1</span> which
contains the characters that both ranges start with. For all other types, the
type of the result is the same as the result of <span class="d_inlinecode donthyphenate notranslate">takeExactly(r1, n)</span>, where
<span class="d_inlinecode donthyphenate notranslate">n</span> is the number of elements that both ranges start with.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><span class="libref"><a href="http://dlang.org/phobos/std_range.html#takeExactly"><span class="d_inlinecode donthyphenate notranslate">std.range.takeExactly</span></a></span></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_psymbol">commonPrefix</span>(<span class="d_string">"hello, world"</span>, <span class="d_string">"hello, there"</span>) == <span class="d_string">"hello, "</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".findAdjacent"></a><div class="quickindex" id="quickindex.findAdjacent"></div>Range <a name="findAdjacent"></a><span class="ddoc_psymbol">findAdjacent</span>(alias pred = "a == b", Range)(Range <i>r</i>) if (isForwardRange!Range);
</dt>
<dd><div class="summary">Advances <span class="d_inlinecode donthyphenate notranslate">r</span> until it finds the first two adjacent elements <span class="d_inlinecode donthyphenate notranslate">a</span>,
<span class="d_inlinecode donthyphenate notranslate">b</span> that satisfy <span class="d_inlinecode donthyphenate notranslate">pred(a, b)</span>. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length</span>)</span>
evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/adjacent_find.html">STL's adjacent_find</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">findAdjacent</span>(a);
<span class="d_keyword">assert</span>(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);
<span class="d_keyword">auto</span> p = <span class="d_psymbol">findAdjacent</span>!(<span class="d_string">"a &lt; b"</span>)(a);
<span class="d_keyword">assert</span>(p == [ 7, 8, 9 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".findAmong"></a><div class="quickindex" id="quickindex.findAmong"></div>Range1 <a name="findAmong"></a><span class="ddoc_psymbol">findAmong</span>(alias pred = "a == b", Range1, Range2)(Range1 <i>seq</i>, Range2 <i>choices</i>) if (isInputRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd><div class="summary">Advances <span class="d_inlinecode donthyphenate notranslate">seq</span> by calling <span class="d_inlinecode donthyphenate notranslate">seq.popFront</span> until either <span class="d_inlinecode donthyphenate notranslate">find!(pred)(choices, seq.front)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>, or <span class="d_inlinecode donthyphenate notranslate">seq</span> becomes
empty. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">seq.length * choices.length</span>)</span> evaluations of
<span class="d_inlinecode donthyphenate notranslate">pred</span>.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/find_first_of.html">STL's find_first_of</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
<span class="d_keyword">int</span>[] b = [ 3, 1, 2 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">findAmong</span>(a, b) == a[2 .. $]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".count"></a><div class="quickindex" id="quickindex.count"></div>size_t <a name="count"></a><span class="ddoc_psymbol">count</span>(alias pred = "a == b", Range, E)(Range <i>haystack</i>, E <i>needle</i>) if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>)) : bool));
<br><a name=".count"></a><div class="quickindex" id="quickindex.count"></div>size_t <a name="count"></a><span class="ddoc_psymbol">count</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; !isInfinite!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>.front)) : bool));
<br><a name=".count"></a><div class="quickindex" id="quickindex.count"></div>size_t <a name="count"></a><span class="ddoc_psymbol">count</span>(alias pred = "true", R)(R <i>haystack</i>) if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; is(typeof(unaryFun!pred(<i>haystack</i>.front)) : bool));
</dt>
<dd><div class="summary">The first version counts the number of elements <span class="d_inlinecode donthyphenate notranslate">x</span> in <span class="d_inlinecode donthyphenate notranslate">r</span> for
which <span class="d_inlinecode donthyphenate notranslate">pred(x, value)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>. <span class="d_inlinecode donthyphenate notranslate">pred</span> defaults to
equality. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">haystack.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.
</div>
<div class="description">The second version returns the number of times <span class="d_inlinecode donthyphenate notranslate">needle</span> occurs in
<span class="d_inlinecode donthyphenate notranslate">haystack</span>. Throws an exception if <span class="d_inlinecode donthyphenate notranslate">needle.empty</span>, as the count
of the empty range in any range would be infinite. Overlapped counts
are not considered, for example <span class="d_inlinecode donthyphenate notranslate"><a name="count"></a><span class="ddoc_psymbol">count</span>("aaa", "aa")</span> is <span class="d_inlinecode donthyphenate notranslate">1</span>, not
<span class="d_inlinecode donthyphenate notranslate">2</span>.
<p></p>

The third version counts the elements for which <span class="d_inlinecode donthyphenate notranslate">pred(x)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">haystack.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Regardless of the overload, <span class="d_inlinecode donthyphenate notranslate"><a name="count"></a><span class="ddoc_psymbol">count</span></span> will not accept
infinite ranges for <span class="d_inlinecode donthyphenate notranslate">haystack</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.uni : toLower;

<span class="d_comment">// count elements in range
</span><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(a, 2) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>!(<span class="d_string">"a &gt; b"</span>)(a, 2) == 5);
<span class="d_comment">// count range in range
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(<span class="d_string">"abcadfabf"</span>, <span class="d_string">"ab"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(<span class="d_string">"ababab"</span>, <span class="d_string">"abab"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(<span class="d_string">"ababab"</span>, <span class="d_string">"abx"</span>) == 0);
<span class="d_comment">// fuzzy count range in range
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>!((a, b) =&gt; std.uni.toLower(a) == std.uni.toLower(b))(<span class="d_string">"AbcAdFaBf"</span>, <span class="d_string">"ab"</span>) == 2);
<span class="d_comment">// count predicate in range
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>!(<span class="d_string">"a &gt; 1"</span>)(a) == 8);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".balancedParens"></a><div class="quickindex" id="quickindex.balancedParens"></div>bool <a name="balancedParens"></a><span class="ddoc_psymbol">balancedParens</span>(Range, E)(Range <i>r</i>, E <i>lPar</i>, E <i>rPar</i>, size_t <i>maxNestingLevel</i> = size_t.max) if (isInputRange!Range &amp;&amp; is(typeof(<i>r</i>.front == <i>lPar</i>)));
</dt>
<dd><div class="summary">Checks whether <span class="d_inlinecode donthyphenate notranslate">r</span> has "balanced parentheses", i.e. all instances
of <span class="d_inlinecode donthyphenate notranslate">lPar</span> are closed by corresponding instances of <span class="d_inlinecode donthyphenate notranslate">rPar</span>. The
parameter <span class="d_inlinecode donthyphenate notranslate">maxNestingLevel</span> controls the nesting level allowed. The
most common uses are the default or <span class="d_inlinecode donthyphenate notranslate">0</span>. In the latter case, no
nesting is allowed.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> s = <span class="d_string">"1 + (2 * (3 + 1 / 2)"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">balancedParens</span>(s, '(', ')'));
s = <span class="d_string">"1 + (2 * (3 + 1) / 2)"</span>;
<span class="d_keyword">assert</span>(<span class="d_psymbol">balancedParens</span>(s, '(', ')'));
s = <span class="d_string">"1 + (2 * (3 + 1) / 2)"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">balancedParens</span>(s, '(', ')', 0));
s = <span class="d_string">"1 + (2 * 3 + 1) / (2 - 5)"</span>;
<span class="d_keyword">assert</span>(<span class="d_psymbol">balancedParens</span>(s, '(', ')', 0));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".equal"></a><div class="quickindex" id="quickindex.equal"></div>template <a name="equal"></a><span class="ddoc_psymbol">equal</span>(alias pred = "a == b")</dt>
<dd><div class="summary">Compares two ranges for equality, as defined by predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>
(which is <span class="d_inlinecode donthyphenate notranslate">==</span> by default).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.math : approxEqual;
<span class="d_keyword">import</span> std.algorithm : <span class="d_psymbol">equal</span>;

<span class="d_keyword">int</span>[] a = [ 1, 2, 4, 3 ];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">equal</span>(a, a[1..$]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">equal</span>(a, a));

<span class="d_comment">// different types
</span><span class="d_keyword">double</span>[] b = [ 1.0, 2, 4, 3];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">equal</span>(a, b[1..$]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">equal</span>(a, b));

<span class="d_comment">// predicated: ensure that two vectors are approximately equal
</span><span class="d_keyword">double</span>[] c = [ 1.005, 2, 4, 3];
<span class="d_keyword">assert</span>(<span class="d_psymbol">equal</span>!approxEqual(b, c));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Tip: <span class="d_inlinecode donthyphenate notranslate"><a name="equal"></a><span class="ddoc_psymbol">equal</span></span> can itself be used as a predicate to other functions.
This can be very useful when the element type of a range is itself a
range. In particular, <span class="d_inlinecode donthyphenate notranslate"><a name="equal"></a><span class="ddoc_psymbol">equal</span></span> can be its own predicate, allowing
range of range (of range...) comparisons.
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.algorithm : <span class="d_psymbol">equal</span>;
<span class="d_keyword">import</span> std.range : iota, chunks;
<span class="d_keyword">assert</span>(<span class="d_psymbol">equal</span>!(<span class="d_psymbol">equal</span>!<span class="d_psymbol">equal</span>)(
    [[[0, 1], [2, 3]], [[4, 5], [6, 7]]],
    iota(0, 8).chunks(2).chunks(2)
));
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".equal"></a><div class="quickindex" id="quickindex.equal"></div>bool <a name="equal"></a><span class="ddoc_psymbol">equal</span>(Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(binaryFun!pred(<i>r1</i>.front, <i>r2</i>.front))));
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if the two ranges compare <a name="equal"></a><span class="ddoc_psymbol">equal</span> element
    for element, according to binary predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>. The ranges may
    have different element types, as long as <span class="d_inlinecode donthyphenate notranslate">pred(a, b)</span> evaluates to
    <span class="d_inlinecode donthyphenate notranslate">bool</span> for <span class="d_inlinecode donthyphenate notranslate">a</span> in <span class="d_inlinecode donthyphenate notranslate">r1</span> and <span class="d_inlinecode donthyphenate notranslate">b</span> in <span class="d_inlinecode donthyphenate notranslate">r2</span>. Performs
    <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">min(r1.length, r2.length)</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/equal.html">STL's equal</a></div></div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".cmp"></a><div class="quickindex" id="quickindex.cmp"></div>int <a name="cmp"></a><span class="ddoc_psymbol">cmp</span>(alias pred = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>) if (isInputRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; !(isSomeString!R1 &amp;&amp; isSomeString!R2));
</dt>
<dd><div class="summary">Performs three-way lexicographical comparison on two input ranges
according to predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>. Iterating <span class="d_inlinecode donthyphenate notranslate">r1</span> and <span class="d_inlinecode donthyphenate notranslate">r2</span> in
lockstep, <span class="d_inlinecode donthyphenate notranslate"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> compares each element <span class="d_inlinecode donthyphenate notranslate">e1</span> of <span class="d_inlinecode donthyphenate notranslate">r1</span> with the
corresponding element <span class="d_inlinecode donthyphenate notranslate">e2</span> in <span class="d_inlinecode donthyphenate notranslate">r2</span>. If <span class="d_inlinecode donthyphenate notranslate">binaryFun!pred(e1,
e2)</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> returns a negative value. If <span class="d_inlinecode donthyphenate notranslate">binaryFun!pred(e2,
e1)</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> returns a positive value. If one of the ranges has been
finished, <span class="d_inlinecode donthyphenate notranslate"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> returns a negative value if <span class="d_inlinecode donthyphenate notranslate">r1</span> has fewer
elements than <span class="d_inlinecode donthyphenate notranslate">r2</span>, a positive value if <span class="d_inlinecode donthyphenate notranslate">r1</span> has more elements
than <span class="d_inlinecode donthyphenate notranslate">r2</span>, and <span class="d_inlinecode donthyphenate notranslate">0</span> if the ranges have the same number of
elements.
</div>
<div class="description">If the ranges are strings, <span class="d_inlinecode donthyphenate notranslate"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> performs UTF decoding
appropriately and compares the ranges one code point at a time.</div>

</dd>
<dt class="d_decl"><a name=".min"></a><div class="quickindex" id="quickindex.min"></div>MinType!T <a name="min"></a><span class="ddoc_psymbol">min</span>(T...)(T <i>args</i>) if (T.length &gt;= 2);
</dt>
<dd><div class="summary">Returns the minimum of the passed-in values.</div>

</dd>
<dt class="d_decl"><a name=".max"></a><div class="quickindex" id="quickindex.max"></div>MaxType!T <a name="max"></a><span class="ddoc_psymbol">max</span>(T...)(T <i>args</i>) if (T.length &gt;= 2);
</dt>
<dd><div class="summary">Returns the maximum of the passed-in values.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> a = 5;
<span class="d_keyword">short</span> b = 6;
<span class="d_keyword">double</span> c = 2;
<span class="d_keyword">auto</span> d = <span class="d_psymbol">max</span>(a, b);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(d) == <span class="d_keyword">int</span>));
<span class="d_keyword">assert</span>(d == 6);
<span class="d_keyword">auto</span> e = min(a, b, c);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(e) == <span class="d_keyword">double</span>));
<span class="d_keyword">assert</span>(e == 2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".minCount"></a><div class="quickindex" id="quickindex.minCount"></div>Tuple!(ElementType!Range, size_t) <a name="minCount"></a><span class="ddoc_psymbol">minCount</span>(alias pred = "a &lt; b", Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(<i>range</i>.front, <i>range</i>.front))));
</dt>
<dd><div class="summary">Returns the minimum element of a range together with the number of
occurrences. The function can actually be used for counting the
maximum or any other ordering predicate (that's why <span class="d_inlinecode donthyphenate notranslate">maxCount</span> is
not provided).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.conv : text;

<span class="d_keyword">debug</span>(std_algorithm) <span class="d_keyword">scope</span>(success)
    writeln(<span class="d_string">"unittest @"</span>, <span class="d_keyword">__FILE__</span>, <span class="d_string">":"</span>, <span class="d_keyword">__LINE__</span>, <span class="d_string">" done."</span>);

<span class="d_keyword">int</span>[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
<span class="d_comment">// Minimum is 1 and occurs 3 times
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minCount</span>(a) == tuple(1, 3));
<span class="d_comment">// Maximum is 4 and occurs 2 times
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minCount</span>!(<span class="d_string">"a &gt; b"</span>)(a) == tuple(4, 2));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".minPos"></a><div class="quickindex" id="quickindex.minPos"></div>Range <a name="minPos"></a><span class="ddoc_psymbol">minPos</span>(alias pred = "a &lt; b", Range)(Range <i>range</i>) if (isForwardRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(<i>range</i>.front, <i>range</i>.front))));
</dt>
<dd><div class="summary">Returns the position of the minimum element of forward range <span class="d_inlinecode donthyphenate notranslate">range</span>, i.e. a subrange of <span class="d_inlinecode donthyphenate notranslate">range</span> starting at the position of its
smallest element and with the same ending as <span class="d_inlinecode donthyphenate notranslate">range</span>. The function
can actually be used for finding the maximum or any other ordering
predicate (that's why <span class="d_inlinecode donthyphenate notranslate">maxPos</span> is not provided).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
<span class="d_comment">// Minimum is 1 and first occurs in position 3
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minPos</span>(a) == [ 1, 2, 4, 1, 1, 2 ]);
<span class="d_comment">// Maximum is 4 and first occurs in position 2
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minPos</span>!(<span class="d_string">"a &gt; b"</span>)(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".mismatch"></a><div class="quickindex" id="quickindex.mismatch"></div>Tuple!(Range1, Range2) <a name="mismatch"></a><span class="ddoc_psymbol">mismatch</span>(alias pred = "a == b", Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2);
</dt>
<dd><div class="summary">Sequentially compares elements in <span class="d_inlinecode donthyphenate notranslate">r1</span> and <span class="d_inlinecode donthyphenate notranslate">r2</span> in lockstep, and
stops at the first <a name="mismatch"></a><span class="ddoc_psymbol">mismatch</span> (according to <span class="d_inlinecode donthyphenate notranslate">pred</span>, by default
equality). Returns a tuple with the reduced ranges that start with the
two mismatched values. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">min(r1.length, r2.length)</span>)</span>
evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/mismatch.html">STL's mismatch</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[]    x = [ 1,  5, 2, 7,   4, 3 ];
<span class="d_keyword">double</span>[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];
<span class="d_keyword">auto</span> m = <span class="d_psymbol">mismatch</span>(x, y);
<span class="d_keyword">assert</span>(m[0] == x[3 .. $]);
<span class="d_keyword">assert</span>(m[1] == y[3 .. $]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".EditOp"></a><div class="quickindex" id="quickindex.EditOp"></div>enum <a name="EditOp"></a><span class="ddoc_psymbol">EditOp</span>: char;
</dt>
<dd><div class="summary">Encodes <a href="http://realityinteractive.com/rgrzywinski/archives/000249.html">edit operations</a> necessary to transform one sequence into
another. Given sequences <span class="d_inlinecode donthyphenate notranslate">s</span> (source) and <span class="d_inlinecode donthyphenate notranslate">t</span> (target), a
sequence of <span class="d_inlinecode donthyphenate notranslate"><a name="EditOp"></a><span class="ddoc_psymbol">EditOp</span></span> encodes the steps that need to be taken to
convert <span class="d_inlinecode donthyphenate notranslate">s</span> into <span class="d_inlinecode donthyphenate notranslate">t</span>. For example, if <span class="d_inlinecode donthyphenate notranslate">s = "cat"</span> and <span class="d_inlinecode donthyphenate notranslate">"cars"</span>, the minimal sequence that transforms <span class="d_inlinecode donthyphenate notranslate">s</span> into <span class="d_inlinecode donthyphenate notranslate">t</span> is:
skip two characters, replace 't' with 'r', and insert an 's'. Working
with edit operations is useful in applications such as spell-checkers
(to find the closest word to a given misspelled word), approximate
searches, diff-style programs that compute the difference between
files, efficient encoding of patches, DNA sequence analysis, and
plagiarism detection.</div>

<dl><dt class="d_decl"><a name=".EditOp.none"></a><div class="quickindex" id="quickindex.EditOp.none"></div><a name="none"></a><span class="ddoc_psymbol">none</span></dt>
<dd><div class="summary">Current items are equal; no editing is necessary.</div>

</dd>
<dt class="d_decl"><a name=".EditOp.substitute"></a><div class="quickindex" id="quickindex.EditOp.substitute"></div><a name="substitute"></a><span class="ddoc_psymbol">substitute</span></dt>
<dd><div class="summary">Substitute current item in target with current item in source.</div>

</dd>
<dt class="d_decl"><a name=".EditOp.insert"></a><div class="quickindex" id="quickindex.EditOp.insert"></div><a name="insert"></a><span class="ddoc_psymbol">insert</span></dt>
<dd><div class="summary">Insert current item from the source into the target.</div>

</dd>
<dt class="d_decl"><a name=".EditOp.remove"></a><div class="quickindex" id="quickindex.EditOp.remove"></div><a name="remove"></a><span class="ddoc_psymbol">remove</span></dt>
<dd><div class="summary">Remove current item from the target.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".levenshteinDistance"></a><div class="quickindex" id="quickindex.levenshteinDistance"></div>size_t <a name="levenshteinDistance"></a><span class="ddoc_psymbol">levenshteinDistance</span>(alias equals = "a == b", Range1, Range2)(Range1 <i>s</i>, Range2 <i>t</i>) if (isForwardRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd><div class="summary">Returns the <a href="http://wikipedia.org/wiki/Levenshtein_distance">Levenshtein
distance</a> between <span class="d_inlinecode donthyphenate notranslate">s</span> and <span class="d_inlinecode donthyphenate notranslate">t</span>. The Levenshtein distance computes
the minimal amount of edit operations necessary to transform <span class="d_inlinecode donthyphenate notranslate">s</span>
into <span class="d_inlinecode donthyphenate notranslate">t</span>.  Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">s.length * t.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">equals</span> and occupies <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">s.length * t.length</span>)</span> storage.
</div>
<div class="description">Allocates GC memory.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.uni : toUpper;

<span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>(<span class="d_string">"cat"</span>, <span class="d_string">"rat"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>(<span class="d_string">"parks"</span>, <span class="d_string">"spark"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>(<span class="d_string">"kitten"</span>, <span class="d_string">"sitting"</span>) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>!((a, b) =&gt; std.uni.toUpper(a) == std.uni.toUpper(b))
    (<span class="d_string">"parks"</span>, <span class="d_string">"SPARK"</span>) == 2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".levenshteinDistanceAndPath"></a><div class="quickindex" id="quickindex.levenshteinDistanceAndPath"></div>Tuple!(size_t, EditOp[]) <a name="levenshteinDistanceAndPath"></a><span class="ddoc_psymbol">levenshteinDistanceAndPath</span>(alias equals = "a == b", Range1, Range2)(Range1 <i>s</i>, Range2 <i>t</i>) if (isForwardRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd><div class="summary">Returns the Levenshtein distance and the edit path between <span class="d_inlinecode donthyphenate notranslate">s</span> and
<span class="d_inlinecode donthyphenate notranslate">t</span>.
</div>
<div class="description">Allocates GC memory.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
string a = <span class="d_string">"Saturday"</span>, b = <span class="d_string">"Sunday"</span>;
<span class="d_keyword">auto</span> p = <span class="d_psymbol">levenshteinDistanceAndPath</span>(a, b);
<span class="d_keyword">assert</span>(p[0] == 3);
<span class="d_keyword">assert</span>(equal(p[1], <span class="d_string">"nrrnsnnn"</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".copy"></a><div class="quickindex" id="quickindex.copy"></div>Range2 <a name="copy"></a><span class="ddoc_psymbol">copy</span>(Range1, Range2)(Range1 <i>source</i>, Range2 <i>target</i>) if (isInputRange!Range1 &amp;&amp; isOutputRange!(Range2, ElementType!Range1));
</dt>
<dd><div class="summary">Copies the content of <span class="d_inlinecode donthyphenate notranslate">source</span> into <span class="d_inlinecode donthyphenate notranslate">target</span> and returns the
remaining (unfilled) part of <span class="d_inlinecode donthyphenate notranslate">target</span>.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Preconditions:</span>
<span class="d_inlinecode donthyphenate notranslate">target</span> shall have enough room to accomodate
<span class="d_inlinecode donthyphenate notranslate">source</span>.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/copy.html">STL's copy</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 5 ];
<span class="d_keyword">int</span>[] b = [ 9, 8 ];
<span class="d_keyword">int</span>[] c = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[a.length + b.length + 10];
<span class="d_keyword">auto</span> d = <span class="d_psymbol">copy</span>(b, <span class="d_psymbol">copy</span>(a, c));
<span class="d_keyword">assert</span>(c[0 .. a.length + b.length] == a ~ b);
<span class="d_keyword">assert</span>(d.length == 10);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">As long as the target range elements support assignment from source
range elements, different types of ranges are accepted.
<pre class="d_code notranslate">
<span class="d_keyword">float</span>[] a = [ 1.0f, 5 ];
<span class="d_keyword">double</span>[] b = <span class="d_keyword">new</span> <span class="d_keyword">double</span>[a.length];
<span class="d_keyword">auto</span> d = <span class="d_psymbol">copy</span>(a, b);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">To <a name="copy"></a><span class="ddoc_psymbol">copy</span> at most <span class="d_inlinecode donthyphenate notranslate">n</span> elements from range <span class="d_inlinecode donthyphenate notranslate">a</span> to range <span class="d_inlinecode donthyphenate notranslate">b</span>, you
may want to use <span class="d_inlinecode donthyphenate notranslate"><a name="copy"></a><span class="ddoc_psymbol">copy</span>(take(a, n), b)</span>. To <a name="copy"></a><span class="ddoc_psymbol">copy</span> those elements from
range <span class="d_inlinecode donthyphenate notranslate">a</span> that satisfy predicate <span class="d_inlinecode donthyphenate notranslate">pred</span> to range <span class="d_inlinecode donthyphenate notranslate">b</span>, you may
want to use <span class="d_inlinecode donthyphenate notranslate"><a name="copy"></a><span class="ddoc_psymbol">copy</span>(a.filter!(pred), b)</span>.
<pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[a.length];
<span class="d_keyword">auto</span> c = <span class="d_psymbol">copy</span>(a.filter!(a =&gt; (a &amp; 1) == 1), b);
<span class="d_keyword">assert</span>(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><span class="libref"><a href="http://dlang.org/phobos/std_range.html#retro"><span class="d_inlinecode donthyphenate notranslate">std.range.retro</span></a></span> can be used to achieve behavior similar to
<a href="http://sgi.com/tech/stl/copy_backward.html">STL's copy_backward'</a>.
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.algorithm, std.range;
<span class="d_keyword">int</span>[] src = [1, 2, 4];
<span class="d_keyword">int</span>[] dst = [0, 0, 0, 0, 0];
<span class="d_psymbol">copy</span>(src.retro, dst.retro);
<span class="d_keyword">assert</span>(dst == [0, 0, 1, 2, 4]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".swapRanges"></a><div class="quickindex" id="quickindex.swapRanges"></div>Tuple!(Range1, Range2) <a name="swapRanges"></a><span class="ddoc_psymbol">swapRanges</span>(Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; hasSwappableElements!Range1 &amp;&amp; hasSwappableElements!Range2 &amp;&amp; is(ElementType!Range1 == ElementType!Range2));
</dt>
<dd><div class="summary">Swaps all elements of <span class="d_inlinecode donthyphenate notranslate">r1</span> with successive elements in <span class="d_inlinecode donthyphenate notranslate">r2</span>.
Returns a tuple containing the remainder portions of <span class="d_inlinecode donthyphenate notranslate">r1</span> and <span class="d_inlinecode donthyphenate notranslate">r2</span> that were not swapped (one of them will be empty). The ranges may
be of different types but must have the same element type and support
swapping.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 100, 101, 102, 103 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 3 ];
<span class="d_keyword">auto</span> c = <span class="d_psymbol">swapRanges</span>(a[1 .. 3], b[2 .. 4]);
<span class="d_keyword">assert</span>(c[0].empty &amp;&amp; c[1].empty);
<span class="d_keyword">assert</span>(a == [ 100, 2, 3, 103 ]);
<span class="d_keyword">assert</span>(b == [ 0, 1, 101, 102 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".reverse"></a><div class="quickindex" id="quickindex.reverse"></div>void <a name="reverse"></a><span class="ddoc_psymbol">reverse</span>(Range)(Range <i>r</i>) if (isBidirectionalRange!Range &amp;&amp; !isRandomAccessRange!Range &amp;&amp; hasSwappableElements!Range);
<br><a name=".reverse"></a><div class="quickindex" id="quickindex.reverse"></div>void <a name="reverse"></a><span class="ddoc_psymbol">reverse</span>(Range)(Range <i>r</i>) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range);
</dt>
<dd><div class="summary">Reverses <span class="d_inlinecode donthyphenate notranslate">r</span> in-place.  Performs <span class="d_inlinecode donthyphenate notranslate">r.length / 2</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">swap</span>.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/reverse.html">STL's reverse</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] arr = [ 1, 2, 3 ];
<span class="d_psymbol">reverse</span>(arr);
<span class="d_keyword">assert</span>(arr == [ 3, 2, 1 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".reverse"></a><div class="quickindex" id="quickindex.reverse"></div>void <a name="reverse"></a><span class="ddoc_psymbol">reverse</span>(Char)(Char[] <i>s</i>) if (isNarrowString!(Char[]) &amp;&amp; !is(Char == const) &amp;&amp; !is(Char == immutable));
</dt>
<dd><div class="summary">Reverses <span class="d_inlinecode donthyphenate notranslate">r</span> in-place, where <span class="d_inlinecode donthyphenate notranslate">r</span> is a narrow string (having
elements of type <span class="d_inlinecode donthyphenate notranslate">char</span> or <span class="d_inlinecode donthyphenate notranslate">wchar</span>). UTF sequences consisting of
multiple code units are preserved properly.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">char</span>[] arr = <span class="d_string">"hello\U00010143\u0100\U00010143"</span>.dup;
<span class="d_psymbol">reverse</span>(arr);
<span class="d_keyword">assert</span>(arr == <span class="d_string">"\U00010143\u0100\U00010143olleh"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".strip"></a><div class="quickindex" id="quickindex.strip"></div>Range <a name="strip"></a><span class="ddoc_psymbol">strip</span>(Range, E)(Range <i>range</i>, E <i>element</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(<i>range</i>.front == <i>element</i>) : bool));
<br><a name=".strip"></a><div class="quickindex" id="quickindex.strip"></div>Range <a name="strip"></a><span class="ddoc_psymbol">strip</span>(alias pred, Range)(Range <i>range</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(pred(<i>range</i>.back)) : bool));
<br><a name=".stripLeft"></a><div class="quickindex" id="quickindex.stripLeft"></div>Range <a name="stripLeft"></a><span class="ddoc_psymbol">stripLeft</span>(Range, E)(Range <i>range</i>, E <i>element</i>) if (isInputRange!Range &amp;&amp; is(typeof(<i>range</i>.front == <i>element</i>) : bool));
<br><a name=".stripLeft"></a><div class="quickindex" id="quickindex.stripLeft"></div>Range <a name="stripLeft"></a><span class="ddoc_psymbol">stripLeft</span>(alias pred, Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; is(typeof(pred(<i>range</i>.front)) : bool));
<br><a name=".stripRight"></a><div class="quickindex" id="quickindex.stripRight"></div>Range <a name="stripRight"></a><span class="ddoc_psymbol">stripRight</span>(Range, E)(Range <i>range</i>, E <i>element</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(<i>range</i>.back == <i>element</i>) : bool));
<br><a name=".stripRight"></a><div class="quickindex" id="quickindex.stripRight"></div>Range <a name="stripRight"></a><span class="ddoc_psymbol">stripRight</span>(alias pred, Range)(Range <i>range</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(pred(<i>range</i>.back)) : bool));
</dt>
<dd><div class="summary">The <a name="strip"></a><span class="ddoc_psymbol">strip</span> group of functions allow stripping of either leading, trailing,
    or both leading and trailing elements.
</div>
<div class="description">The <span class="d_inlinecode donthyphenate notranslate">stripLeft</span> function will <a name="strip"></a><span class="ddoc_psymbol">strip</span> the <span class="d_inlinecode donthyphenate notranslate">front</span> of the range,
    the <span class="d_inlinecode donthyphenate notranslate">stripRight</span> function will <a name="strip"></a><span class="ddoc_psymbol">strip</span> the <span class="d_inlinecode donthyphenate notranslate">back</span> of the range,
    while the <span class="d_inlinecode donthyphenate notranslate"><a name="strip"></a><span class="ddoc_psymbol">strip</span></span> function will <a name="strip"></a><span class="ddoc_psymbol">strip</span> both the <span class="d_inlinecode donthyphenate notranslate">front</span> and <span class="d_inlinecode donthyphenate notranslate">back</span>
    of the range.
<p></p>

    Note that the <span class="d_inlinecode donthyphenate notranslate"><a name="strip"></a><span class="ddoc_psymbol">strip</span></span> and <span class="d_inlinecode donthyphenate notranslate">stripRight</span> functions require the range to
    be a <a href="#BidirectionalRange"><span class="d_inlinecode donthyphenate notranslate">BidirectionalRange</span></a> range.
<p></p>

    All of these functions come in two varieties: one takes a target element,
    where the range will be stripped as long as this element can be found.
    The other takes a lambda predicate, where the range will be stripped as
    long as the predicate returns <b>true</b>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Strip leading and trailing elements equal to the target element.
<pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.strip(' ') == <span class="d_string">"foobar"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.strip('0') == <span class="d_string">"223.4445"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"p"</span>.strip('') == <span class="d_string">"p"</span>);
<span class="d_keyword">assert</span>([1, 1, 0, 1, 1].strip(1) == [0]);
<span class="d_keyword">assert</span>([0.0, 0.01, 0.01, 0.0].strip(0).length == 2);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Strip leading and trailing elements while the predicate returns <b>true</b>.
<pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.strip!(a =&gt; a == ' ')() == <span class="d_string">"foobar"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.strip!(a =&gt; a == '0')() == <span class="d_string">"223.4445"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"p"</span>.strip!(a =&gt; a == '')() == <span class="d_string">"p"</span>);
<span class="d_keyword">assert</span>([1, 1, 0, 1, 1].strip!(a =&gt; a == 1)() == [0]);
<span class="d_keyword">assert</span>([0.0, 0.01, 0.5, 0.6, 0.01, 0.0].strip!(a =&gt; a &lt; 0.4)().length == 2);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Strip leading elements equal to the target element.
<pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.stripLeft(' ') == <span class="d_string">"foobar  "</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.stripLeft('0') == <span class="d_string">"223.444500"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.stripLeft('') == <span class="d_string">"niod"</span>);
<span class="d_keyword">assert</span>([1, 1, 0, 1, 1].stripLeft(1) == [0, 1, 1]);
<span class="d_keyword">assert</span>([0.0, 0.01, 0.01, 0.0].stripLeft(0).length == 3);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Strip leading elements while the predicate returns <b>true</b>.
<pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.stripLeft!(a =&gt; a == ' ')() == <span class="d_string">"foobar  "</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.stripLeft!(a =&gt; a == '0')() == <span class="d_string">"223.444500"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.stripLeft!(a =&gt; a == '')() == <span class="d_string">"niod"</span>);
<span class="d_keyword">assert</span>([1, 1, 0, 1, 1].stripLeft!(a =&gt; a == 1)() == [0, 1, 1]);
<span class="d_keyword">assert</span>([0.0, 0.01, 0.10, 0.5, 0.6].stripLeft!(a =&gt; a &lt; 0.4)().length == 2);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Strip trailing elements equal to the target element.
<pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.<span class="d_psymbol">stripRight</span>(' ') == <span class="d_string">"  foobar"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.<span class="d_psymbol">stripRight</span>('0') == <span class="d_string">"00223.4445"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.<span class="d_psymbol">stripRight</span>('') == <span class="d_string">"niod"</span>);
<span class="d_keyword">assert</span>([1, 1, 0, 1, 1].<span class="d_psymbol">stripRight</span>(1) == [1, 1, 0]);
<span class="d_keyword">assert</span>([0.0, 0.01, 0.01, 0.0].<span class="d_psymbol">stripRight</span>(0).length == 3);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Strip trailing elements while the predicate returns <b>true</b>.
<pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.<span class="d_psymbol">stripRight</span>!(a =&gt; a == ' ')() == <span class="d_string">"  foobar"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.<span class="d_psymbol">stripRight</span>!(a =&gt; a == '0')() == <span class="d_string">"00223.4445"</span>);
<span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.<span class="d_psymbol">stripRight</span>!(a =&gt; a == '')() == <span class="d_string">"niod"</span>);
<span class="d_keyword">assert</span>([1, 1, 0, 1, 1].<span class="d_psymbol">stripRight</span>!(a =&gt; a == 1)() == [1, 1, 0]);
<span class="d_keyword">assert</span>([0.0, 0.01, 0.10, 0.5, 0.6].<span class="d_psymbol">stripRight</span>!(a =&gt; a &gt; 0.4)().length == 3);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".bringToFront"></a><div class="quickindex" id="quickindex.bringToFront"></div>size_t <a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span>(Range1, Range2)(Range1 <i>front</i>, Range2 <i>back</i>) if (isInputRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd><div class="summary">The <span class="d_inlinecode donthyphenate notranslate"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> function has considerable flexibility and
usefulness. It can rotate elements in one buffer left or right, swap
buffers of equal length, and even move elements across disjoint
buffers of different types and different lengths.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> takes two ranges <span class="d_inlinecode donthyphenate notranslate">front</span> and <span class="d_inlinecode donthyphenate notranslate">back</span>, which may
be of different types. Considering the concatenation of <span class="d_inlinecode donthyphenate notranslate">front</span> and
<span class="d_inlinecode donthyphenate notranslate">back</span> one unified range, <span class="d_inlinecode donthyphenate notranslate"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> rotates that unified
range such that all elements in <span class="d_inlinecode donthyphenate notranslate">back</span> are brought to the beginning
of the unified range. The relative ordering of elements in <span class="d_inlinecode donthyphenate notranslate">front</span>
and <span class="d_inlinecode donthyphenate notranslate">back</span>, respectively, remains unchanged.
<p></p>

Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">max(front.length, back.length)</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">swap</span>.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Preconditions:</span>
Either <span class="d_inlinecode donthyphenate notranslate">front</span> and <span class="d_inlinecode donthyphenate notranslate">back</span> are disjoint, or <span class="d_inlinecode donthyphenate notranslate">back</span> is
reachable from <span class="d_inlinecode donthyphenate notranslate">front</span> and <span class="d_inlinecode donthyphenate notranslate">front</span> is not reachable from <span class="d_inlinecode donthyphenate notranslate">back</span>.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The number of elements brought to the front, i.e., the length of <span class="d_inlinecode donthyphenate notranslate">back</span>.

</div></div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/rotate.html">STL's rotate</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">The simplest use of <span class="d_inlinecode donthyphenate notranslate"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> is for rotating elements in a
buffer. For example:
<pre class="d_code notranslate">
<span class="d_keyword">auto</span> arr = [4, 5, 6, 7, 1, 2, 3];
<span class="d_keyword">auto</span> p = <span class="d_psymbol">bringToFront</span>(arr[0 .. 4], arr[4 .. $]);
<span class="d_keyword">assert</span>(p == arr.length - 4);
<span class="d_keyword">assert</span>(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">The <span class="d_inlinecode donthyphenate notranslate">front</span> range may actually "step over" the <span class="d_inlinecode donthyphenate notranslate">back</span>
range. This is very useful with forward ranges that cannot compute
comfortably right-bounded subranges like <span class="d_inlinecode donthyphenate notranslate">arr[0 .. 4]</span> above. In
the example below, <span class="d_inlinecode donthyphenate notranslate">r2</span> is a right subrange of <span class="d_inlinecode donthyphenate notranslate">r1</span>.
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.container : SList;

<span class="d_keyword">auto</span> list = SList!(<span class="d_keyword">int</span>)(4, 5, 6, 7, 1, 2, 3);
<span class="d_keyword">auto</span> r1 = list[];
<span class="d_keyword">auto</span> r2 = list[]; popFrontN(r2, 4);
<span class="d_keyword">assert</span>(equal(r2, [ 1, 2, 3 ]));
<span class="d_psymbol">bringToFront</span>(r1, r2);
<span class="d_keyword">assert</span>(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Elements can be swapped across ranges of different types:
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.container : SList;

<span class="d_keyword">auto</span> list = SList!(<span class="d_keyword">int</span>)(4, 5, 6, 7);
<span class="d_keyword">auto</span> vec = [ 1, 2, 3 ];
<span class="d_psymbol">bringToFront</span>(list[], vec);
<span class="d_keyword">assert</span>(equal(list[], [ 1, 2, 3, 4 ]));
<span class="d_keyword">assert</span>(equal(vec, [ 5, 6, 7 ]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SwapStrategy"></a><div class="quickindex" id="quickindex.SwapStrategy"></div>enum <a name="SwapStrategy"></a><span class="ddoc_psymbol">SwapStrategy</span>: int;
</dt>
<dd><div class="summary">Defines the swapping strategy for algorithms that need to swap
elements in a range (such as partition and sort). The strategy
concerns the swapping of elements that are not the core concern of the
algorithm. For example, consider an algorithm that sorts <span class="d_inlinecode donthyphenate notranslate">[ "abc",
"b", "aBc" ]</span> according to <span class="d_inlinecode donthyphenate notranslate">toUpper(a) &lt; toUpper(b)</span>. That
algorithm might choose to swap the two equivalent strings <span class="d_inlinecode donthyphenate notranslate">"abc"</span>
and <span class="d_inlinecode donthyphenate notranslate">"aBc"</span>. That does not affect the sorting since both <span class="d_inlinecode donthyphenate notranslate">[
"abc", "aBc", "b" ]</span> and <span class="d_inlinecode donthyphenate notranslate">[ "aBc", "abc", "b" ]</span> are valid
outcomes.
</div>
<div class="description">Some situations require that the algorithm must NOT ever change the
relative ordering of equivalent elements (in the example above, only
<span class="d_inlinecode donthyphenate notranslate">[ "abc", "aBc", "b" ]</span> would be the correct result). Such
algorithms are called <b>stable</b>. If the ordering algorithm may swap
equivalent elements discretionarily, the ordering is called <b>unstable</b>.
<p></p>

Yet another class of algorithms may choose an intermediate tradeoff by
being stable only on a well-defined subrange of the range. There is no
established terminology for such behavior; this library calls it <b>semistable</b>.
<p></p>

Generally, the <span class="d_inlinecode donthyphenate notranslate">stable</span> ordering strategy may be more costly in
time and/or space than the other two because it imposes additional
constraints. Similarly, <span class="d_inlinecode donthyphenate notranslate">semistable</span> may be costlier than <span class="d_inlinecode donthyphenate notranslate">unstable</span>. As (semi-)stability is not needed very often, the ordering
algorithms in this module parameterized by <span class="d_inlinecode donthyphenate notranslate"><a name="SwapStrategy"></a><span class="ddoc_psymbol">SwapStrategy</span></span> all
choose <span class="d_inlinecode donthyphenate notranslate"><a name="SwapStrategy"></a><span class="ddoc_psymbol">SwapStrategy</span>.unstable</span> as the default.</div>

<dl><dt class="d_decl"><a name=".SwapStrategy.unstable"></a><div class="quickindex" id="quickindex.SwapStrategy.unstable"></div><a name="unstable"></a><span class="ddoc_psymbol">unstable</span></dt>
<dd><div class="summary">Allows freely swapping of elements as long as the output
       satisfies the algorithm's requirements.</div>

</dd>
<dt class="d_decl"><a name=".SwapStrategy.semistable"></a><div class="quickindex" id="quickindex.SwapStrategy.semistable"></div><a name="semistable"></a><span class="ddoc_psymbol">semistable</span></dt>
<dd><div class="summary">In algorithms partitioning ranges in two, preserve relative
       ordering of elements only to the left of the partition point.</div>

</dd>
<dt class="d_decl"><a name=".SwapStrategy.stable"></a><div class="quickindex" id="quickindex.SwapStrategy.stable"></div><a name="stable"></a><span class="ddoc_psymbol">stable</span></dt>
<dd><div class="summary">Preserve the relative ordering of elements to the largest
       extent allowed by the algorithm's requirements.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".remove"></a><div class="quickindex" id="quickindex.remove"></div>Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(SwapStrategy s = SwapStrategy.stable, Range, Offset...)(Range <i>range</i>, Offset <i>offset</i>) if (s != SwapStrategy.stable &amp;&amp; isBidirectionalRange!Range &amp;&amp; hasLvalueElements!Range &amp;&amp; hasLength!Range &amp;&amp; Offset.length &gt;= 1);
</dt>
<dd><div class="summary">Eliminates elements at given offsets from <span class="d_inlinecode donthyphenate notranslate">range</span> and returns the
shortened range. In the simplest call, one element is removed.
</div>
<div class="description"><pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [ 3, 5, 7, 8 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>(a, 1) == [ 3, 7, 8 ]);
<span class="d_keyword">assert</span>(a == [ 3, 7, 8, 8 ]);
</pre>
<p></p>

In the case above the element at offset <span class="d_inlinecode donthyphenate notranslate">1</span> is removed and <span class="d_inlinecode donthyphenate notranslate"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span> returns the range smaller by one element. The original array
has remained of the same length because all functions in <span class="d_inlinecode donthyphenate notranslate">std.algorithm</span> only change <i>content</i>, not <i>topology</i>. The value
<span class="d_inlinecode donthyphenate notranslate">8</span> is repeated because <span class="libref"><a href="http://dlang.org/phobos/std_algorithm.html#move"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.move</span></a></span> was invoked to move
elements around and on integers <span class="d_inlinecode donthyphenate notranslate">move</span> simply copies the source to
the destination. To replace <span class="d_inlinecode donthyphenate notranslate">a</span> with the effect of the removal,
simply assign <span class="d_inlinecode donthyphenate notranslate">a = <a name="remove"></a><span class="ddoc_psymbol">remove</span>(a, 1)</span>. The slice will be rebound to the
shorter array and the operation completes with maximal efficiency.
<p></p>

Multiple indices can be passed into <span class="d_inlinecode donthyphenate notranslate"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span>. In that case,
elements at the respective indices are all removed. The indices must
be passed in increasing order, otherwise an exception occurs.
<p></p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>(a, 1, 3, 5) ==
    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);
</pre>
<p></p>

(Note how all indices refer to slots in the <i>original</i> array, not
in the array as it is being progressively shortened.) Finally, any
combination of integral offsets and tuples composed of two integral
offsets can be passed in.
<p></p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);
</pre>
<p></p>

In this case, the slots at positions 1, 3, 4, and 9 are removed from
the array. The tuple passes in a range closed to the left and open to
the right (consistent with built-in slices), e.g. <span class="d_inlinecode donthyphenate notranslate">tuple(3, 5)</span>
means indices <span class="d_inlinecode donthyphenate notranslate">3</span> and <span class="d_inlinecode donthyphenate notranslate">4</span> but not <span class="d_inlinecode donthyphenate notranslate">5</span>.
<p></p>

If the need is to <a name="remove"></a><span class="ddoc_psymbol">remove</span> some elements in the range but the order of
the remaining elements does not have to be preserved, you may want to
pass <span class="d_inlinecode donthyphenate notranslate">SwapStrategy.unstable</span> to <span class="d_inlinecode donthyphenate notranslate"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span>.
<p></p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);
</pre>
<p></p>

In the case above, the element at slot <span class="d_inlinecode donthyphenate notranslate">1</span> is removed, but replaced
with the last element of the range. Taking advantage of the relaxation
of the stability requirement, <span class="d_inlinecode donthyphenate notranslate"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span> moved elements from the end
of the array over the slots to be removed. This way there is less data
movement to be done which improves the execution time of the function.
<p></p>

The function <span class="d_inlinecode donthyphenate notranslate"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span> works on any forward range. The moving
strategy is (listed from fastest to slowest): <ul><li>If <span class="d_inlinecode donthyphenate notranslate">s ==
SwapStrategy.unstable &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasLength!Range
&amp;&amp; hasLvalueElements!Range</span>, then elements are moved from the end
of the range into the slots to be filled. In this case, the absolute
minimum of moves is performed.</li>  <li>Otherwise, if <span class="d_inlinecode donthyphenate notranslate">s ==
SwapStrategy.unstable &amp;&amp; isBidirectionalRange!Range &amp;&amp; hasLength!Range
&amp;&amp; hasLvalueElements!Range</span>, then elements are still moved from the
end of the range, but time is spent on advancing between slots by repeated
calls to <span class="d_inlinecode donthyphenate notranslate">range.popFront</span>.</li>  <li>Otherwise, elements are moved
incrementally towards the front of <span class="d_inlinecode donthyphenate notranslate">range</span>; a given element is never
moved several times, but more elements are moved than in the previous
cases.</li></ul></div>

</dd>
<dt class="d_decl"><a name=".remove"></a><div class="quickindex" id="quickindex.remove"></div>Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(alias pred, SwapStrategy s = SwapStrategy.stable, Range)(Range <i>range</i>) if (isBidirectionalRange!Range &amp;&amp; hasLvalueElements!Range);
</dt>
<dd><div class="summary">Reduces the length of the bidirectional range <span class="d_inlinecode donthyphenate notranslate">range</span> by removing
elements that satisfy <span class="d_inlinecode donthyphenate notranslate">pred</span>. If <span class="d_inlinecode donthyphenate notranslate">s = SwapStrategy.unstable</span>,
elements are moved from the right end of the range over the elements
to eliminate. If <span class="d_inlinecode donthyphenate notranslate">s = SwapStrategy.stable</span> (the default),
elements are moved progressively to front such that their relative
order is preserved. Returns the filtered range.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">immutable</span> base = [1, 2, 3, 2, 4, 2, 5, 2];

<span class="d_keyword">int</span>[] arr = base[].dup;

<span class="d_comment">// using a string-based predicate
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>!(<span class="d_string">"a == 2"</span>)(arr) == [ 1, 3, 4, 5 ]);

<span class="d_comment">// The original array contents have been modified,
</span><span class="d_comment">// so we need to reset it to its original state.
</span><span class="d_comment">// The length is unmodified however.
</span>arr[] = base[];

<span class="d_comment">// using a lambda predicate
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>!(a =&gt; a == 2)(arr) == [ 1, 3, 4, 5 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".partition"></a><div class="quickindex" id="quickindex.partition"></div>Range <a name="partition"></a><span class="ddoc_psymbol">partition</span>(alias predicate, SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>) if (ss == SwapStrategy.stable &amp;&amp; isRandomAccessRange!Range || ss != SwapStrategy.stable &amp;&amp; isForwardRange!Range);
</dt>
<dd><div class="summary">Partitions a range in two using <span class="d_inlinecode donthyphenate notranslate">pred</span> as a
predicate. Specifically, reorders the range <span class="d_inlinecode donthyphenate notranslate">r = [left,
right)</span> using <span class="d_inlinecode donthyphenate notranslate">swap</span> such that all elements <span class="d_inlinecode donthyphenate notranslate">i</span> for
which <span class="d_inlinecode donthyphenate notranslate">pred(i)</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> come before all elements <span class="d_inlinecode donthyphenate notranslate">j</span> for
which <span class="d_inlinecode donthyphenate notranslate">pred(j)</span> returns <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span>.
</div>
<div class="description">Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length</span>)</span> (if unstable or semistable) or <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length * log(r.length)</span>)</span> (if stable) evaluations of <span class="d_inlinecode donthyphenate notranslate">less</span> and <span class="d_inlinecode donthyphenate notranslate">swap</span>. The unstable version computes the minimum possible evaluations
of <span class="d_inlinecode donthyphenate notranslate">swap</span> (roughly half of those performed by the semistable
version).

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The right part of <span class="d_inlinecode donthyphenate notranslate">r</span> after partitioning.
<p></p>

If <span class="d_inlinecode donthyphenate notranslate">ss == SwapStrategy.stable</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="partition"></a><span class="ddoc_psymbol">partition</span></span> preserves the
relative ordering of all elements <span class="d_inlinecode donthyphenate notranslate">a</span>, <span class="d_inlinecode donthyphenate notranslate">b</span> in <span class="d_inlinecode donthyphenate notranslate">r</span> for which
<span class="d_inlinecode donthyphenate notranslate">pred(a) == pred(b)</span>. If <span class="d_inlinecode donthyphenate notranslate">ss == SwapStrategy.semistable</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="partition"></a><span class="ddoc_psymbol">partition</span></span> preserves the relative ordering of all elements <span class="d_inlinecode donthyphenate notranslate">a</span>, <span class="d_inlinecode donthyphenate notranslate">b</span> in the left part of <span class="d_inlinecode donthyphenate notranslate">r</span> for which <span class="d_inlinecode donthyphenate notranslate">pred(a) == pred(b)</span>.

</div></div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso">STL's <a href="http://sgi.com/tech/stl/partition.html">partition</a><br>
    STL's <a href="http://sgi.com/tech/stl/stable_partition.html">stable_partition</a></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.conv : text;

<span class="d_keyword">auto</span> Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
<span class="d_keyword">auto</span> arr = Arr.dup;
<span class="d_keyword">static</span> <span class="d_keyword">bool</span> even(<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> (a &amp; 1) == 0; }
<span class="d_comment">// Partition arr such that even numbers come first
</span><span class="d_keyword">auto</span> r = <span class="d_psymbol">partition</span>!(even)(arr);
<span class="d_comment">// Now arr is separated in evens and odds.
</span><span class="d_comment">// Numbers may have become shuffled due to instability
</span><span class="d_keyword">assert</span>(r == arr[5 .. $]);
<span class="d_keyword">assert</span>(count!(even)(arr[0 .. 5]) == 5);
<span class="d_keyword">assert</span>(find!(even)(r).empty);

<span class="d_comment">// Can also specify the predicate as a string.
</span><span class="d_comment">// Use 'a' as the predicate argument name
</span>arr[] = Arr[];
r = <span class="d_psymbol">partition</span>!(<span class="d_string">q{(a &amp; 1) == 0}</span>)(arr);
<span class="d_keyword">assert</span>(r == arr[5 .. $]);

<span class="d_comment">// Now for a stable partition:
</span>arr[] = Arr[];
r = <span class="d_psymbol">partition</span>!(<span class="d_string">q{(a &amp; 1) == 0}</span>, SwapStrategy.stable)(arr);
<span class="d_comment">// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1
</span><span class="d_keyword">assert</span>(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] &amp;&amp; r == arr[5 .. $]);

<span class="d_comment">// In case the predicate needs to hold its own state, use a delegate:
</span>arr[] = Arr[];
<span class="d_keyword">int</span> x = 3;
<span class="d_comment">// Put stuff greater than 3 on the left
</span><span class="d_keyword">bool</span> fun(<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> a &gt; x; }
r = <span class="d_psymbol">partition</span>!(fun, SwapStrategy.semistable)(arr);
<span class="d_comment">// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2
</span><span class="d_keyword">assert</span>(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] &amp;&amp; r == arr[7 .. $]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isPartitioned"></a><div class="quickindex" id="quickindex.isPartitioned"></div>bool <a name="isPartitioned"></a><span class="ddoc_psymbol">isPartitioned</span>(alias pred, Range)(Range <i>r</i>) if (isForwardRange!Range);
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">r</span> is partitioned according to predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] r = [ 1, 3, 5, 7, 8, 2, 4, ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">isPartitioned</span>!<span class="d_string">"a &amp; 1"</span>(r));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".partition3"></a><div class="quickindex" id="quickindex.partition3"></div>auto <a name="partition3"></a><span class="ddoc_psymbol">partition3</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, E)(Range <i>r</i>, E <i>pivot</i>) if (ss == SwapStrategy.unstable &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasSwappableElements!Range &amp;&amp; hasLength!Range &amp;&amp; is(typeof(binaryFun!less(<i>r</i>.front, <i>pivot</i>)) == bool) &amp;&amp; is(typeof(binaryFun!less(<i>pivot</i>, <i>r</i>.front)) == bool) &amp;&amp; is(typeof(binaryFun!less(<i>r</i>.front, <i>r</i>.front)) == bool));
</dt>
<dd><div class="summary">Rearranges elements in <span class="d_inlinecode donthyphenate notranslate">r</span> in three adjacent ranges and returns
them. The first and leftmost range only contains elements in <span class="d_inlinecode donthyphenate notranslate">r</span>
less than <span class="d_inlinecode donthyphenate notranslate">pivot</span>. The second and middle range only contains
elements in <span class="d_inlinecode donthyphenate notranslate">r</span> that are equal to <span class="d_inlinecode donthyphenate notranslate">pivot</span>. Finally, the third
and rightmost range only contains elements in <span class="d_inlinecode donthyphenate notranslate">r</span> that are greater
than <span class="d_inlinecode donthyphenate notranslate">pivot</span>. The less-than test is defined by the binary function
<span class="d_inlinecode donthyphenate notranslate">less</span>.
</div>
<div class="keyval Bugs"><span class="key keyBugs">Bugs:</span> <div class="val valBugs">stable <span class="d_inlinecode donthyphenate notranslate"><a name="partition3"></a><span class="ddoc_psymbol">partition3</span></span> has not been implemented yet.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> a = [ 8, 3, 4, 1, 4, 7, 4 ];
<span class="d_keyword">auto</span> pieces = <span class="d_psymbol">partition3</span>(a, 4);
<span class="d_keyword">assert</span>(pieces[0] == [ 1, 3 ]);
<span class="d_keyword">assert</span>(pieces[1] == [ 4, 4, 4 ]);
<span class="d_keyword">assert</span>(pieces[2] == [ 8, 7 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".topN"></a><div class="quickindex" id="quickindex.topN"></div>void <a name="topN"></a><span class="ddoc_psymbol">topN</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>, size_t <i>nth</i>) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range);
</dt>
<dd><div class="summary">Reorders the range <span class="d_inlinecode donthyphenate notranslate">r</span> using <span class="d_inlinecode donthyphenate notranslate">swap</span> such that <span class="d_inlinecode donthyphenate notranslate">r[nth]</span> refers
to the element that would fall there if the range were fully
sorted. In addition, it also partitions <span class="d_inlinecode donthyphenate notranslate">r</span> such that all elements
<span class="d_inlinecode donthyphenate notranslate">e1</span> from <span class="d_inlinecode donthyphenate notranslate">r[0]</span> to <span class="d_inlinecode donthyphenate notranslate">r[nth]</span> satisfy <span class="d_inlinecode donthyphenate notranslate">!less(r[nth], e1)</span>,
and all elements <span class="d_inlinecode donthyphenate notranslate">e2</span> from <span class="d_inlinecode donthyphenate notranslate">r[nth]</span> to <span class="d_inlinecode donthyphenate notranslate">r[r.length]</span> satisfy
<span class="d_inlinecode donthyphenate notranslate">!less(e2, r[nth])</span>. Effectively, it finds the nth smallest
(according to <span class="d_inlinecode donthyphenate notranslate">less</span>) elements in <span class="d_inlinecode donthyphenate notranslate">r</span>. Performs an expected
<span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length</span>)</span> (if unstable) or <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length * log(r.length)</span>)</span>
(if stable) evaluations of <span class="d_inlinecode donthyphenate notranslate">less</span> and <span class="d_inlinecode donthyphenate notranslate">swap</span>.
</div>
<div class="description">If <span class="d_inlinecode donthyphenate notranslate">n &gt;= r.length</span>, the algorithm has no effect.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="http://sgi.com/tech/stl/nth_element.html">STL's nth_element</a>

</div></div>
<div class="keyval Bugs"><span class="key keyBugs">Bugs:</span> <div class="val valBugs">Stable <a name="topN"></a><span class="ddoc_psymbol">topN</span> has not been implemented yet.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] v = [ 25, 7, 9, 2, 0, 5, 21 ];
<span class="d_keyword">auto</span> n = 4;
<span class="d_psymbol">topN</span>!<span class="d_string">"a &lt; b"</span>(v, n);
<span class="d_keyword">assert</span>(v[n] == 9);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".topN"></a><div class="quickindex" id="quickindex.topN"></div>void <a name="topN"></a><span class="ddoc_psymbol">topN</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isRandomAccessRange!Range1 &amp;&amp; hasLength!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(ElementType!Range1 == ElementType!Range2));
</dt>
<dd><div class="summary">Stores the smallest elements of the two ranges in the left-hand range.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 5, 7, 2, 6, 7 ];
<span class="d_keyword">int</span>[] b = [ 2, 1, 5, 6, 7, 3, 0 ];
<span class="d_psymbol">topN</span>(a, b);
sort(a);
<span class="d_keyword">assert</span>(a == [0, 1, 2, 2, 3]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".sort"></a><div class="quickindex" id="quickindex.sort"></div>SortedRange!(Range, less) <a name="sort"></a><span class="ddoc_psymbol">sort</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>) if ((ss == SwapStrategy.unstable &amp;&amp; (hasSwappableElements!Range || hasAssignableElements!Range) || ss != SwapStrategy.unstable &amp;&amp; hasAssignableElements!Range) &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasSlicing!Range &amp;&amp; hasLength!Range);
</dt>
<dd><div class="summary">Sorts a random-access range according to the predicate <span class="d_inlinecode donthyphenate notranslate">less</span>. Performs
<span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length * log(r.length)</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">less</span>. Stable sorting
requires <span class="d_inlinecode donthyphenate notranslate">hasAssignableElements!Range</span> to be <b>true</b>.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="sort"></a><span class="ddoc_psymbol">sort</span></span> returns a <span class="libref"><a href="http://dlang.org/phobos/std_range.html#SortedRange"><span class="d_inlinecode donthyphenate notranslate">std.range.SortedRange</span></a></span> over the original range, which
functions that can take advantage of sorted data can then use to know that the
range is sorted and adjust accordingly. The <span class="libref"><a href="http://dlang.org/phobos/std_range.html#SortedRange"><span class="d_inlinecode donthyphenate notranslate">std.range.SortedRange</span></a></span> is a
wrapper around the original range, so both it and the original range are sorted,
but other functions won't know that the original range has been sorted, whereas
they <i>can</i> know that <span class="libref"><a href="http://dlang.org/phobos/std_range.html#SortedRange"><span class="d_inlinecode donthyphenate notranslate">std.range.SortedRange</span></a></span> has been sorted.
<p></p>

The predicate is expected to satisfy certain rules in order for <span class="d_inlinecode donthyphenate notranslate"><a name="sort"></a><span class="ddoc_psymbol">sort</span></span> to
behave as expected - otherwise, the program may fail on certain inputs (but not
others) when not compiled in release mode, due to the cursory <span class="d_inlinecode donthyphenate notranslate">assumeSorted</span>
check. Specifically, <span class="d_inlinecode donthyphenate notranslate"><a name="sort"></a><span class="ddoc_psymbol">sort</span></span> expects <span class="d_inlinecode donthyphenate notranslate">less(a,b) &amp;&amp; less(b,c)</span> to imply
<span class="d_inlinecode donthyphenate notranslate">less(a,c)</span> (transitivity), and, conversely, <span class="d_inlinecode donthyphenate notranslate">!less(a,b) &amp;&amp; !less(b,c)</span> to
imply <span class="d_inlinecode donthyphenate notranslate">!less(a,c)</span>. Note that the default predicate (<span class="d_inlinecode donthyphenate notranslate">"a &lt; b"</span>) does not
always satisfy these conditions for floating point types, because the expression
will always be <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> when either <span class="d_inlinecode donthyphenate notranslate">a</span> or <span class="d_inlinecode donthyphenate notranslate">b</span> is NaN.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The initial range wrapped as a <span class="d_inlinecode donthyphenate notranslate">SortedRange</span> with the predicate
<span class="d_inlinecode donthyphenate notranslate">binaryFun!less</span>.

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Algorithms:</span>
<a href="http://en.wikipedia.org/wiki/Introsort">en.wikipedia.org/wiki/Introsort</a> is used for unstable sorting and
<a href="http://en.wikipedia.org/wiki/Timsort">Timsort</a> is used for stable sorting.
Each algorithm has benefits beyond stability. Introsort is generally faster but
Timsort may achieve greater speeds on data with low entropy or if predicate calls
are expensive. Introsort performs no allocations whereas Timsort will perform one
or more allocations per call. Both algorithms have <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">n log n</span>)</span> worst-case
time complexity.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><span class="libref"><a href="http://dlang.org/phobos/std_range.html#assumeSorted"><span class="d_inlinecode donthyphenate notranslate">std.range.assumeSorted</span></a></span><br>
    <span class="libref"><a href="http://dlang.org/phobos/std_range.html#SortedRange"><span class="d_inlinecode donthyphenate notranslate">std.range.SortedRange</span></a></span><br>
    <span class="libref"><a href="http://dlang.org/phobos/std_algorithm.html#SwapStrategy"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.SwapStrategy</span></a></span><br>
    <span class="libref"><a href="http://dlang.org/phobos/std_functional.html#binaryFun"><span class="d_inlinecode donthyphenate notranslate">std.functional.binaryFun</span></a></span></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] array = [ 1, 2, 3, 4 ];
<span class="d_comment">// sort in descending order
</span><span class="d_psymbol">sort</span>!(<span class="d_string">"a &gt; b"</span>)(array);
<span class="d_keyword">assert</span>(array == [ 4, 3, 2, 1 ]);
<span class="d_comment">// sort in ascending order
</span><span class="d_psymbol">sort</span>(array);
<span class="d_keyword">assert</span>(array == [ 1, 2, 3, 4 ]);
<span class="d_comment">// sort with a delegate
</span><span class="d_keyword">bool</span> myComp(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) @safe <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> { <span class="d_keyword">return</span> x &gt; y; }
<span class="d_psymbol">sort</span>!(myComp)(array);
<span class="d_keyword">assert</span>(array == [ 4, 3, 2, 1 ]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// Showcase stable sorting
</span>string[] words = [ <span class="d_string">"aBc"</span>, <span class="d_string">"a"</span>, <span class="d_string">"abc"</span>, <span class="d_string">"b"</span>, <span class="d_string">"ABC"</span>, <span class="d_string">"c"</span> ];
<span class="d_psymbol">sort</span>!(<span class="d_string">"toUpper(a) &lt; toUpper(b)"</span>, SwapStrategy.stable)(words);
<span class="d_keyword">assert</span>(words == [ <span class="d_string">"a"</span>, <span class="d_string">"aBc"</span>, <span class="d_string">"abc"</span>, <span class="d_string">"ABC"</span>, <span class="d_string">"b"</span>, <span class="d_string">"c"</span> ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".multiSort"></a><div class="quickindex" id="quickindex.multiSort"></div>template <a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span>(less...)</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate">void <a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span>(Range)(Range r)
    if (validPredicates!(ElementType!Range, less));</span>
</div>
<div class="description">Sorts a range by multiple keys. The call <span class="d_inlinecode donthyphenate notranslate"><a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span>!("a.id &lt; b.id",
"a.date &gt; b.date")(r)</span> sorts the range <span class="d_inlinecode donthyphenate notranslate">r</span> by <span class="d_inlinecode donthyphenate notranslate">id</span> ascending,
and sorts elements that have the same <span class="d_inlinecode donthyphenate notranslate">id</span> by <span class="d_inlinecode donthyphenate notranslate">date</span>
descending. Such a call is equivalent to <span class="d_inlinecode donthyphenate notranslate">sort!"a.id != b.id ? a.id
&lt; b.id : a.date &gt; b.date"(r)</span>, but <span class="d_inlinecode donthyphenate notranslate"><a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span></span> is faster because it
does fewer comparisons (in addition to being more convenient).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Point { <span class="d_keyword">int</span> x, y; }
<span class="d_keyword">auto</span> pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];
<span class="d_keyword">auto</span> pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];
<span class="d_psymbol">multiSort</span>!(<span class="d_string">"a.x &lt; b.x"</span>, <span class="d_string">"a.y &lt; b.y"</span>, SwapStrategy.unstable)(pts1);
<span class="d_keyword">assert</span>(pts1 == pts2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".schwartzSort"></a><div class="quickindex" id="quickindex.schwartzSort"></div>SortedRange!(R, (a, b) =&gt; binaryFun!less(unaryFun!transform(a), unaryFun!transform(b))) <a name="schwartzSort"></a><span class="ddoc_psymbol">schwartzSort</span>(alias transform, alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, R)(R <i>r</i>) if (isRandomAccessRange!R &amp;&amp; hasLength!R);
</dt>
<dd><div class="summary">Sorts a range using an algorithm akin to the <a href="http://wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a>, also
known as the decorate-sort-undecorate pattern in Python and Lisp. (Not
to be confused with <a href="http://youtube.com/watch?v=UHw6KXbvazs">the other
Schwartz</a>.) This function is helpful when the sort comparison includes
an expensive computation. The complexity is the same as that of the
corresponding <span class="d_inlinecode donthyphenate notranslate">sort</span>, but <span class="d_inlinecode donthyphenate notranslate"><a name="schwartzSort"></a><span class="ddoc_psymbol">schwartzSort</span></span> evaluates <span class="d_inlinecode donthyphenate notranslate">transform</span> only <span class="d_inlinecode donthyphenate notranslate">r.length</span> times (less than half when compared to
regular sorting). The usage can be best illustrated with an example.
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_keyword">uint</span> hashFun(string) { ... expensive computation ... }
string[] array = ...;
<span class="d_comment">// Sort strings by hash, slow
</span>sort!((a, b) =&gt; hashFun(a) &lt; hashFun(b))(array);
<span class="d_comment">// Sort strings by hash, fast (only computes arr.length hashes):
</span><span class="d_psymbol">schwartzSort</span>!(hashFun, <span class="d_string">"a &lt; b"</span>)(array);
</pre>
<p></p>

The <span class="d_inlinecode donthyphenate notranslate"><a name="schwartzSort"></a><span class="ddoc_psymbol">schwartzSort</span></span> function might require less temporary data and
be faster than the Perl idiom or the decorate-sort-undecorate idiom
present in Python and Lisp. This is because sorting is done in-place
and only minimal extra data (one array of transformed elements) is
created.
<p></p>

To check whether an array was sorted and benefit of the speedup of
Schwartz sorting, a function <span class="d_inlinecode donthyphenate notranslate">schwartzIsSorted</span> is not provided
because the effect can be achieved by calling <span class="d_inlinecode donthyphenate notranslate">isSorted!less(map!transform(r))</span>.

</div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The initial range wrapped as a <span class="d_inlinecode donthyphenate notranslate">SortedRange</span> with the
predicate <span class="d_inlinecode donthyphenate notranslate">(a, b) =&gt; binaryFun!less(transform(a),
transform(b))</span>.</div></div>

</dd>
<dt class="d_decl"><a name=".partialSort"></a><div class="quickindex" id="quickindex.partialSort"></div>void <a name="partialSort"></a><span class="ddoc_psymbol">partialSort</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>, size_t <i>n</i>) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range);
</dt>
<dd><div class="summary">Reorders the random-access range <span class="d_inlinecode donthyphenate notranslate">r</span> such that the range <span class="d_inlinecode donthyphenate notranslate">r[0
.. mid]</span> is the same as if the entire <span class="d_inlinecode donthyphenate notranslate">r</span> were sorted, and leaves
the range <span class="d_inlinecode donthyphenate notranslate">r[mid .. r.length]</span> in no particular order. Performs
<span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length * log(mid)</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>. The
implementation simply calls <span class="d_inlinecode donthyphenate notranslate">topN!(less, ss)(r, n)</span> and then <span class="d_inlinecode donthyphenate notranslate">sort!(less, ss)(r[0 .. n])</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];
<span class="d_psymbol">partialSort</span>(a, 5);
<span class="d_keyword">assert</span>(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".completeSort"></a><div class="quickindex" id="quickindex.completeSort"></div>void <a name="completeSort"></a><span class="ddoc_psymbol">completeSort</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(SortedRange!(Range1, less) <i>lhs</i>, Range2 <i>rhs</i>) if (hasLength!Range2 &amp;&amp; hasSlicing!Range2);
</dt>
<dd><div class="summary">Sorts the random-access range <span class="d_inlinecode donthyphenate notranslate">chain(lhs, rhs)</span> according to
predicate <span class="d_inlinecode donthyphenate notranslate">less</span>. The left-hand side of the range <span class="d_inlinecode donthyphenate notranslate">lhs</span> is
assumed to be already sorted; <span class="d_inlinecode donthyphenate notranslate">rhs</span> is assumed to be unsorted. The
exact strategy chosen depends on the relative sizes of <span class="d_inlinecode donthyphenate notranslate">lhs</span> and
<span class="d_inlinecode donthyphenate notranslate">rhs</span>.  Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">lhs.length + rhs.length * log(rhs.length)</span>)</span>
(best case) to <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">(lhs.length + rhs.length) * log(lhs.length +
rhs.length)</span>)</span> (worst-case) evaluations of <span class="d_inlinecode donthyphenate notranslate">swap</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 3 ];
<span class="d_keyword">int</span>[] b = [ 4, 0, 6, 5 ];
<span class="d_psymbol">completeSort</span>(assumeSorted(a), b);
<span class="d_keyword">assert</span>(a == [ 0, 1, 2 ]);
<span class="d_keyword">assert</span>(b == [ 3, 4, 5, 6 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isSorted"></a><div class="quickindex" id="quickindex.isSorted"></div>bool <a name="isSorted"></a><span class="ddoc_psymbol">isSorted</span>(alias less = "a &lt; b", Range)(Range <i>r</i>) if (isForwardRange!Range);
</dt>
<dd><div class="summary">Checks whether a forward range is sorted according to the comparison
operation <span class="d_inlinecode donthyphenate notranslate">less</span>. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">r.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">less</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] arr = [4, 3, 2, 1];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isSorted</span>(arr));
sort(arr);
<span class="d_keyword">assert</span>(<span class="d_psymbol">isSorted</span>(arr));
sort!(<span class="d_string">"a &gt; b"</span>)(arr);
<span class="d_keyword">assert</span>(<span class="d_psymbol">isSorted</span>!(<span class="d_string">"a &gt; b"</span>)(arr));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".makeIndex"></a><div class="quickindex" id="quickindex.makeIndex"></div>SortedRange!(RangeIndex, (a, b) =&gt; binaryFun!less(*a, *b)) <a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range <i>r</i>, RangeIndex <i>index</i>) if (isForwardRange!Range &amp;&amp; isRandomAccessRange!RangeIndex &amp;&amp; is(ElementType!RangeIndex : ElementType!Range*));
<br><a name=".makeIndex"></a><div class="quickindex" id="quickindex.makeIndex"></div>void <a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range <i>r</i>, RangeIndex <i>index</i>) if (isRandomAccessRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; isRandomAccessRange!RangeIndex &amp;&amp; !isInfinite!RangeIndex &amp;&amp; isIntegral!(ElementType!RangeIndex));
</dt>
<dd><div class="summary">Computes an index for <span class="d_inlinecode donthyphenate notranslate">r</span> based on the comparison <span class="d_inlinecode donthyphenate notranslate">less</span>. The
index is a sorted array of pointers or indices into the original
range. This technique is similar to sorting, but it is more flexible
because (1) it allows "sorting" of immutable collections, (2) allows
binary search even if the original collection does not offer random
access, (3) allows multiple indexes, each on a different predicate,
and (4) may be faster when dealing with large objects. However, using
an index may also be slower under certain circumstances due to the
extra indirection, and is always larger than a sorting-based solution
because it needs space for the index in addition to the original
collection. The complexity is the same as <span class="d_inlinecode donthyphenate notranslate">sort</span>'s.
</div>
<div class="description">The first overload of <span class="d_inlinecode donthyphenate notranslate"><a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span></span> writes to a range containing
pointers, and the second writes to a range containing offsets. The
first overload requires <span class="d_inlinecode donthyphenate notranslate">Range</span> to be a forward range, and the
latter requires it to be a random-access range.
<p></p>

<span class="d_inlinecode donthyphenate notranslate"><a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span></span> overwrites its second argument with the result, but
never reallocates it.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">The pointer-based version returns a <span class="d_inlinecode donthyphenate notranslate">SortedRange</span> wrapper
over index, of type <span class="d_inlinecode donthyphenate notranslate">SortedRange!(RangeIndex, (a, b) =&gt;
binaryFun!less(*a, *b))</span> thus reflecting the ordering of the
index. The index-based version returns <span class="d_inlinecode donthyphenate notranslate">void</span> because the ordering
relation involves not only <span class="d_inlinecode donthyphenate notranslate">index</span> but also <span class="d_inlinecode donthyphenate notranslate">r</span>.

</div></div>
<div class="keyval Throws"><span class="key keyThrows">Throws:</span> <div class="val valThrows">If the second argument's length is less than that of the range
indexed, an exception is thrown.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>[]) arr = [ 2, 3, 1, 5, 0 ];
<span class="d_comment">// index using pointers
</span><span class="d_keyword">auto</span> index1 = <span class="d_keyword">new</span> <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)*[arr.length];
<span class="d_psymbol">makeIndex</span>!(<span class="d_string">"a &lt; b"</span>)(arr, index1);
<span class="d_keyword">assert</span>(isSorted!(<span class="d_string">"*a &lt; *b"</span>)(index1));
<span class="d_comment">// index using offsets
</span><span class="d_keyword">auto</span> index2 = <span class="d_keyword">new</span> size_t[arr.length];
<span class="d_psymbol">makeIndex</span>!(<span class="d_string">"a &lt; b"</span>)(arr, index2);
<span class="d_keyword">assert</span>(isSorted!
    ((size_t a, size_t b){ <span class="d_keyword">return</span> arr[a] &lt; arr[b];})
    (index2));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SortOutput"></a><div class="quickindex" id="quickindex.SortOutput"></div>enum <a name="SortOutput"></a><span class="ddoc_psymbol">SortOutput</span>: int;
</dt>
<dd><div class="summary">Specifies whether the output of certain algorithm is desired in sorted
format.</div>

<dl><dt class="d_decl"><a name=".SortOutput.no"></a><div class="quickindex" id="quickindex.SortOutput.no"></div><a name="no"></a><span class="ddoc_psymbol">no</span></dt>
<dd><div class="summary">Don't sort output</div>

</dd>
<dt class="d_decl"><a name=".SortOutput.yes"></a><div class="quickindex" id="quickindex.SortOutput.yes"></div><a name="yes"></a><span class="ddoc_psymbol">yes</span></dt>
<dd><div class="summary">Sort output</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".canFind"></a><div class="quickindex" id="quickindex.canFind"></div>template <a name="canFind"></a><span class="ddoc_psymbol">canFind</span>(alias pred = "a == b")</dt>
<dd><div class="summary">Convenience function. Like find, but only returns whether or not the search
was successful.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_psymbol">canFind</span>([0, 1, 2, 3], 2) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">canFind</span>([0, 1, 2, 3], [1, 2], [2, 3]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">canFind</span>([0, 1, 2, 3], [1, 2], [2, 3]) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">canFind</span>([0, 1, 2, 3], [1, 7], [2, 3]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">canFind</span>([0, 1, 2, 3], [1, 7], [2, 3]) == 2);

<span class="d_keyword">assert</span>(<span class="d_psymbol">canFind</span>([0, 1, 2, 3], 4) == <span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(!<span class="d_psymbol">canFind</span>([0, 1, 2, 3], [1, 3], [2, 4]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">canFind</span>([0, 1, 2, 3], [1, 3], [2, 4]) == 0);
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".canFind"></a><div class="quickindex" id="quickindex.canFind"></div>bool <a name="canFind"></a><span class="ddoc_psymbol">canFind</span>(Range)(Range <i>haystack</i>) if (is(typeof(find!pred(<i>haystack</i>))));
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if any value <span class="d_inlinecode donthyphenate notranslate">v</span> found in the
    input range <span class="d_inlinecode donthyphenate notranslate">range</span> satisfies the predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>.
    Performs (at most) <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">haystack.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.</div>

</dd>
<dt class="d_decl"><a name=".canFind.canFind"></a><div class="quickindex" id="quickindex.canFind.canFind"></div>bool <a name="canFind"></a><span class="ddoc_psymbol">canFind</span>(Range, Element)(Range <i>haystack</i>, Element <i>needle</i>) if (is(typeof(find!pred(<i>haystack</i>, <i>needle</i>))));
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">needle</span> can be found in <span class="d_inlinecode donthyphenate notranslate">    range</span>. Performs <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">haystack.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.</div>

</dd>
<dt class="d_decl"><a name=".canFind.canFind"></a><div class="quickindex" id="quickindex.canFind.canFind"></div>size_t <a name="canFind"></a><span class="ddoc_psymbol">canFind</span>(Range, Ranges...)(Range <i>haystack</i>, Ranges <i>needles</i>) if (Ranges.length &gt; 1 &amp;&amp; allSatisfy!(isForwardRange, Ranges) &amp;&amp; is(typeof(find!pred(<i>haystack</i>, <i>needles</i>))));
</dt>
<dd><div class="summary">Returns the 1-based index of the first needle found in <span class="d_inlinecode donthyphenate notranslate">haystack</span>. If no
    needle is found, then <span class="d_inlinecode donthyphenate notranslate">0</span> is returned.
</div>
<div class="description">So, if used directly in the condition of an if statement or loop, the result
    will be <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if one of the needles is found and <span class="d_inlinecode donthyphenate notranslate"><b>false</b></span> if none are
    found, whereas if the result is used elsewhere, it can either be cast to
    <span class="d_inlinecode donthyphenate notranslate">bool</span> for the same effect or used to get which needle was found first
    without having to deal with the tuple that <span class="d_inlinecode donthyphenate notranslate">LREF find</span> returns for the
    same operation.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".any"></a><div class="quickindex" id="quickindex.any"></div>template <a name="any"></a><span class="ddoc_psymbol">any</span>(alias pred = "a")</dt>
<dd><div class="summary">Checks if <i>any</i> of the elements verifies <span class="d_inlinecode donthyphenate notranslate">pred</span>.
<span class="d_inlinecode donthyphenate notranslate">!<a name="any"></a><span class="ddoc_psymbol">any</span></span> can be used to verify that <i>none</i> of the elements verify
<span class="d_inlinecode donthyphenate notranslate">pred</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.ascii : isWhite;
<span class="d_keyword">assert</span>( all!(<span class="d_psymbol">any</span>!isWhite)([<span class="d_string">"a a"</span>, <span class="d_string">"b b"</span>]));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">any</span>!(all!isWhite)([<span class="d_string">"a a"</span>, <span class="d_string">"b b"</span>]));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><span class="d_inlinecode donthyphenate notranslate"><a name="any"></a><span class="ddoc_psymbol">any</span></span> can also be used without a predicate, if its items can be
evaluated to <b>true</b> or <b>false</b> in a conditional statement. <span class="d_inlinecode donthyphenate notranslate">!<a name="any"></a><span class="ddoc_psymbol">any</span></span> can be a
convenient way to quickly test that <i>none</i> of the elements of a range
evaluate to <b>true</b>.
<pre class="d_code notranslate">
<span class="d_keyword">int</span>[3] vals1 = [0, 0, 0];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">any</span>(vals1[])); <span class="d_comment">//none of vals1 evaluate to true
</span>
<span class="d_keyword">int</span>[3] vals2 = [2, 0, 2];
<span class="d_keyword">assert</span>( <span class="d_psymbol">any</span>(vals2[]));
<span class="d_keyword">assert</span>(!all(vals2[]));

<span class="d_keyword">int</span>[3] vals3 = [3, 3, 3];
<span class="d_keyword">assert</span>( <span class="d_psymbol">any</span>(vals3[]));
<span class="d_keyword">assert</span>( all(vals3[]));
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".any"></a><div class="quickindex" id="quickindex.any"></div>bool <a name="any"></a><span class="ddoc_psymbol">any</span>(Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; is(typeof(unaryFun!pred(<i>range</i>.front))));
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <i>any</i> value <span class="d_inlinecode donthyphenate notranslate">v</span> found in the
    input range <span class="d_inlinecode donthyphenate notranslate">range</span> satisfies the predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>.
    Performs (at most) <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">range.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".all"></a><div class="quickindex" id="quickindex.all"></div>template <a name="all"></a><span class="ddoc_psymbol">all</span>(alias pred = "a")</dt>
<dd><div class="summary">Checks if <i>all</i> of the elements verify <span class="d_inlinecode donthyphenate notranslate">pred</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>( <span class="d_psymbol">all</span>!<span class="d_string">"a &amp; 1"</span>([1, 3, 5, 7, 9]));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">all</span>!<span class="d_string">"a &amp; 1"</span>([1, 2, 3, 5, 7, 9]));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><span class="d_inlinecode donthyphenate notranslate"><a name="all"></a><span class="ddoc_psymbol">all</span></span> can also be used without a predicate, if its items can be
evaluated to <b>true</b> or <b>false</b> in a conditional statement. This can be a
convenient way to quickly evaluate that <i>all</i> of the elements of a range
are <b>true</b>.
<pre class="d_code notranslate">
<span class="d_keyword">int</span>[3] vals = [5, 3, 18];
<span class="d_keyword">assert</span>( <span class="d_psymbol">all</span>(vals[]));
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".all"></a><div class="quickindex" id="quickindex.all"></div>bool <a name="all"></a><span class="ddoc_psymbol">all</span>(Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; is(typeof(unaryFun!pred(<i>range</i>.front))));
</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <i>all</i> values <span class="d_inlinecode donthyphenate notranslate">v</span> found in the
    input range <span class="d_inlinecode donthyphenate notranslate">range</span> satisfy the predicate <span class="d_inlinecode donthyphenate notranslate">pred</span>.
    Performs (at most) <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">range.length</span>)</span> evaluations of <span class="d_inlinecode donthyphenate notranslate">pred</span>.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".topNCopy"></a><div class="quickindex" id="quickindex.topNCopy"></div>TRange <a name="topNCopy"></a><span class="ddoc_psymbol">topNCopy</span>(alias less = "a &lt; b", SRange, TRange)(SRange <i>source</i>, TRange <i>target</i>, SortOutput <i>sorted</i> = SortOutput.no) if (isInputRange!SRange &amp;&amp; isRandomAccessRange!TRange &amp;&amp; hasLength!TRange &amp;&amp; hasSlicing!TRange);
</dt>
<dd><div class="summary">Copies the top <span class="d_inlinecode donthyphenate notranslate">n</span> elements of the input range <span class="d_inlinecode donthyphenate notranslate">source</span> into the
random-access range <span class="d_inlinecode donthyphenate notranslate">target</span>, where <span class="d_inlinecode donthyphenate notranslate">n =
target.length</span>. Elements of <span class="d_inlinecode donthyphenate notranslate">source</span> are not touched. If <span class="d_inlinecode donthyphenate notranslate">sorted</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>, the target is sorted. Otherwise, the target
respects the <a href="http://en.wikipedia.org/wiki/Binary_heap">heap property</a>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 10, 16, 2, 3, 1, 5, 0 ];
<span class="d_keyword">int</span>[] b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[3];
<span class="d_psymbol">topNCopy</span>(a, b, SortOutput.yes);
<span class="d_keyword">assert</span>(b == [ 0, 1, 2 ]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SetUnion"></a><div class="quickindex" id="quickindex.SetUnion"></div>struct <a name="SetUnion"></a><span class="ddoc_psymbol">SetUnion</span>(alias less = "a &lt; b", Rs...) if (allSatisfy!(isInputRange, Rs));
<br><a name=".setUnion"></a><div class="quickindex" id="quickindex.setUnion"></div>SetUnion!(less, Rs) <a name="setUnion"></a><span class="ddoc_psymbol">setUnion</span>(alias less = "a &lt; b", Rs...)(Rs <i>rs</i>);
</dt>
<dd><div class="summary">Lazily computes the union of two or more ranges <span class="d_inlinecode donthyphenate notranslate">rs</span>. The ranges
are assumed to be sorted by <span class="d_inlinecode donthyphenate notranslate">less</span>. Elements in the output are not
unique; the length of the output is the sum of the lengths of the
inputs. (The <span class="d_inlinecode donthyphenate notranslate">length</span> member is offered if all ranges also have
length.) The element types of all ranges must have a common type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">int</span>[] c = [ 10 ];

<span class="d_keyword">assert</span>(<span class="d_psymbol">setUnion</span>(a, b).length == a.length + b.length);
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">setUnion</span>(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">setUnion</span>(a, c, b),
                [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9, 10][]));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!(<span class="d_keyword">typeof</span>(<span class="d_psymbol">setUnion</span>(a, b))));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SetIntersection"></a><div class="quickindex" id="quickindex.SetIntersection"></div>struct <a name="SetIntersection"></a><span class="ddoc_psymbol">SetIntersection</span>(alias less = "a &lt; b", Rs...) if (Rs.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, Rs) &amp;&amp; !is(CommonType!(staticMap!(ElementType, Rs)) == void));
<br><a name=".setIntersection"></a><div class="quickindex" id="quickindex.setIntersection"></div>SetIntersection!(less, Rs) <a name="setIntersection"></a><span class="ddoc_psymbol">setIntersection</span>(alias less = "a &lt; b", Rs...)(Rs <i>ranges</i>) if (Rs.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, Rs) &amp;&amp; !is(CommonType!(staticMap!(ElementType, Rs)) == void));
</dt>
<dd><div class="summary">Lazily computes the intersection of two or more input ranges <span class="d_inlinecode donthyphenate notranslate">ranges</span>. The ranges are assumed to be sorted by <span class="d_inlinecode donthyphenate notranslate">less</span>. The element
types of the ranges must have a common type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">int</span>[] c = [ 0, 1, 4, 5, 7, 8 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">setIntersection</span>(a, a), a));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">setIntersection</span>(a, b), [1, 2, 4, 7]));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">setIntersection</span>(a, b, c), [1, 4, 7]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SetDifference"></a><div class="quickindex" id="quickindex.SetDifference"></div>struct <a name="SetDifference"></a><span class="ddoc_psymbol">SetDifference</span>(alias less = "a &lt; b", R1, R2) if (isInputRange!R1 &amp;&amp; isInputRange!R2);
<br><a name=".setDifference"></a><div class="quickindex" id="quickindex.setDifference"></div>SetDifference!(less, R1, R2) <a name="setDifference"></a><span class="ddoc_psymbol">setDifference</span>(alias less = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</dt>
<dd><div class="summary">Lazily computes the difference of <span class="d_inlinecode donthyphenate notranslate">r1</span> and <span class="d_inlinecode donthyphenate notranslate">r2</span>. The two ranges
are assumed to be sorted by <span class="d_inlinecode donthyphenate notranslate">less</span>. The element types of the two
ranges must have a common type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">setDifference</span>(a, b), [5, 9][]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!(<span class="d_keyword">typeof</span>(<span class="d_psymbol">setDifference</span>(a, b))));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SetSymmetricDifference"></a><div class="quickindex" id="quickindex.SetSymmetricDifference"></div>struct <a name="SetSymmetricDifference"></a><span class="ddoc_psymbol">SetSymmetricDifference</span>(alias less = "a &lt; b", R1, R2) if (isInputRange!R1 &amp;&amp; isInputRange!R2);
<br><a name=".setSymmetricDifference"></a><div class="quickindex" id="quickindex.setSymmetricDifference"></div>SetSymmetricDifference!(less, R1, R2) <a name="setSymmetricDifference"></a><span class="ddoc_psymbol">setSymmetricDifference</span>(alias less = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</dt>
<dd><div class="summary">Lazily computes the symmetric difference of <span class="d_inlinecode donthyphenate notranslate">r1</span> and <span class="d_inlinecode donthyphenate notranslate">r2</span>,
i.e. the elements that are present in exactly one of <span class="d_inlinecode donthyphenate notranslate">r1</span> and <span class="d_inlinecode donthyphenate notranslate">r2</span>. The two ranges are assumed to be sorted by <span class="d_inlinecode donthyphenate notranslate">less</span>, and the
output is also sorted by <span class="d_inlinecode donthyphenate notranslate">less</span>. The element types of the two
ranges must have a common type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">setSymmetricDifference</span>(a, b), [0, 5, 8, 9][]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(isForwardRange!(<span class="d_keyword">typeof</span>(<span class="d_psymbol">setSymmetricDifference</span>(a, b))));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".NWayUnion"></a><div class="quickindex" id="quickindex.NWayUnion"></div>struct <a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span>(alias less, RangeOfRanges);
<br><a name=".nWayUnion"></a><div class="quickindex" id="quickindex.nWayUnion"></div>NWayUnion!(less, RangeOfRanges) <a name="nWayUnion"></a><span class="ddoc_psymbol">nWayUnion</span>(alias less = "a &lt; b", RangeOfRanges)(RangeOfRanges <i>ror</i>);
</dt>
<dd><div class="summary">Computes the union of multiple sets. The input sets are passed as a
range of ranges and each is assumed to be sorted by <span class="d_inlinecode donthyphenate notranslate">less</span>. Computation is done lazily, one union element at a time. The
complexity of one <span class="d_inlinecode donthyphenate notranslate">popFront</span> operation is <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">log(ror.length)</span>)</span>. However, the length of <span class="d_inlinecode donthyphenate notranslate">ror</span> decreases as ranges
in it are exhausted, so the complexity of a full pass through <span class="d_inlinecode donthyphenate notranslate"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> is dependent on the distribution of the lengths of ranges
contained within <span class="d_inlinecode donthyphenate notranslate">ror</span>. If all ranges have the same length <span class="d_inlinecode donthyphenate notranslate">n</span>
(worst case scenario), the complexity of a full pass through <span class="d_inlinecode donthyphenate notranslate"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> is <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">n * ror.length * log(ror.length)</span>)</span>, i.e., <span class="d_inlinecode donthyphenate notranslate">log(ror.length)</span> times worse than just spanning all ranges in
turn. The output comes sorted (unstably) by <span class="d_inlinecode donthyphenate notranslate">less</span>.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Warning:</span>
Because <span class="d_inlinecode donthyphenate notranslate"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> does not allocate extra memory, it
will leave <span class="d_inlinecode donthyphenate notranslate">ror</span> modified. Namely, <span class="d_inlinecode donthyphenate notranslate"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> assumes ownership
of <span class="d_inlinecode donthyphenate notranslate">ror</span> and discretionarily swaps and advances elements of it. If
you want <span class="d_inlinecode donthyphenate notranslate">ror</span> to preserve its contents after the call, you may
want to pass a duplicate to <span class="d_inlinecode donthyphenate notranslate"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> (and perhaps cache the
duplicate in between calls).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> witness = [
    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8
];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">nWayUnion</span>(a), witness));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".largestPartialIntersection"></a><div class="quickindex" id="quickindex.largestPartialIntersection"></div>void <a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span>(alias less = "a &lt; b", RangeOfRanges, Range)(RangeOfRanges <i>ror</i>, Range <i>tgt</i>, SortOutput <i>sorted</i> = SortOutput.no);
</dt>
<dd><div class="summary">Given a range of sorted forward ranges <span class="d_inlinecode donthyphenate notranslate">ror</span>, copies to <span class="d_inlinecode donthyphenate notranslate">tgt</span>
the elements that are common to most ranges, along with their number
of occurrences. All ranges in <span class="d_inlinecode donthyphenate notranslate">ror</span> are assumed to be sorted by <span class="d_inlinecode donthyphenate notranslate">less</span>. Only the most frequent <span class="d_inlinecode donthyphenate notranslate">tgt.length</span> elements are returned.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_comment">// Figure which number can be found in most arrays of the set of
</span><span class="d_comment">// arrays below.
</span><span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> Tuple!(<span class="d_keyword">double</span>, <span class="d_keyword">uint</span>)[1];
<span class="d_psymbol">largestPartialIntersection</span>(a, b);
<span class="d_comment">// First member is the item, second is the occurrence count
</span><span class="d_keyword">assert</span>(b[0] == tuple(7.0, 4u));
</pre>
<p></p>

<span class="d_inlinecode donthyphenate notranslate">7.0</span> is the correct answer because it occurs in <span class="d_inlinecode donthyphenate notranslate">4</span> out of the
<span class="d_inlinecode donthyphenate notranslate">5</span> inputs, more than any other number. The second member of the
resulting tuple is indeed <span class="d_inlinecode donthyphenate notranslate">4</span> (recording the number of occurrences
of <span class="d_inlinecode donthyphenate notranslate">7.0</span>). If more of the top-frequent numbers are needed, just
create a larger <span class="d_inlinecode donthyphenate notranslate">tgt</span> range. In the example above, creating <span class="d_inlinecode donthyphenate notranslate">b</span>
with length <span class="d_inlinecode donthyphenate notranslate">2</span> yields <span class="d_inlinecode donthyphenate notranslate">tuple(1.0, 3u)</span> in the second position.
<p></p>

The function <span class="d_inlinecode donthyphenate notranslate"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> is useful for
e.g. searching an <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=inverted index">inverted index</a> for the documents most
likely to contain some terms of interest. The complexity of the search
is <span class="bigoh">&Omicron;(<span class="d_inlinecode donthyphenate notranslate">n * log(tgt.length)</span>)</span>, where <span class="d_inlinecode donthyphenate notranslate">n</span> is the sum of lengths of
all input ranges. This approach is faster than keeping an associative
array of the occurrences and then selecting its top items, and also
requires less memory (<span class="d_inlinecode donthyphenate notranslate"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> builds its
result directly in <span class="d_inlinecode donthyphenate notranslate">tgt</span> and requires no extra memory).

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Warning:</span>
Because <span class="d_inlinecode donthyphenate notranslate"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> does not allocate
extra memory, it will leave <span class="d_inlinecode donthyphenate notranslate">ror</span> modified. Namely, <span class="d_inlinecode donthyphenate notranslate"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> assumes ownership of <span class="d_inlinecode donthyphenate notranslate">ror</span> and
discretionarily swaps and advances elements of it. If you want <span class="d_inlinecode donthyphenate notranslate">ror</span> to preserve its contents after the call, you may want to pass a
duplicate to <span class="d_inlinecode donthyphenate notranslate"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> (and perhaps cache the
duplicate in between calls).</div>

</dd>
<dt class="d_decl"><a name=".largestPartialIntersectionWeighted"></a><div class="quickindex" id="quickindex.largestPartialIntersectionWeighted"></div>void <a name="largestPartialIntersectionWeighted"></a><span class="ddoc_psymbol">largestPartialIntersectionWeighted</span>(alias less = "a &lt; b", RangeOfRanges, Range, WeightsAA)(RangeOfRanges <i>ror</i>, Range <i>tgt</i>, WeightsAA <i>weights</i>, SortOutput <i>sorted</i> = SortOutput.no);
</dt>
<dd><div class="summary">Similar to <span class="d_inlinecode donthyphenate notranslate">largestPartialIntersection</span>, but associates a weight
with each distinct element in the intersection.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_comment">// Figure which number can be found in most arrays of the set of
</span><span class="d_comment">// arrays below, with specific per-element weights
</span><span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> Tuple!(<span class="d_keyword">double</span>, <span class="d_keyword">uint</span>)[1];
<span class="d_keyword">double</span>[<span class="d_keyword">double</span>] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];
<span class="d_psymbol">largestPartialIntersectionWeighted</span>(a, b, weights);
<span class="d_comment">// First member is the item, second is the occurrence count
</span><span class="d_keyword">assert</span>(b[0] == tuple(4.0, 2u));
</pre>
<p></p>

The correct answer in this case is <span class="d_inlinecode donthyphenate notranslate">4.0</span>, which, although only
appears two times, has a total weight <span class="d_inlinecode donthyphenate notranslate">4.6</span> (three times its weight
<span class="d_inlinecode donthyphenate notranslate">2.3</span>). The value <span class="d_inlinecode donthyphenate notranslate">7</span> is weighted with <span class="d_inlinecode donthyphenate notranslate">1.1</span> and occurs four
times for a total weight <span class="d_inlinecode donthyphenate notranslate">4.4</span>.</div>

</dd>
<dt class="d_decl"><a name=".nextPermutation"></a><div class="quickindex" id="quickindex.nextPermutation"></div>bool <a name="nextPermutation"></a><span class="ddoc_psymbol">nextPermutation</span>(alias less = "a&lt;b", BidirectionalRange)(ref BidirectionalRange <i>range</i>) if (isBidirectionalRange!BidirectionalRange &amp;&amp; hasSwappableElements!BidirectionalRange);
</dt>
<dd><div class="summary">Permutes <span class="d_inlinecode donthyphenate notranslate">range</span> in-place to the next lexicographically greater
 permutation.
</div>
<div class="description"> The predicate <span class="d_inlinecode donthyphenate notranslate">less</span> defines the lexicographical ordering to be used on
 the range.
<p></p>

 If the range is currently the lexicographically greatest permutation, it is
 permuted back to the least permutation and <b>false</b> is returned.  Otherwise,
 <b>true</b> is returned. One can thus generate all permutations of a range by
 sorting it according to <span class="d_inlinecode donthyphenate notranslate">less</span>, which produces the lexicographically
 least permutation, and then calling <a name="nextPermutation"></a><span class="ddoc_psymbol">nextPermutation</span> until it returns <b>false</b>.
 This is guaranteed to generate all distinct permutations of the range
 exactly once.  If there are <i>N</i> elements in the range and all of them are
 unique, then <i>N</i>! permutations will be generated. Otherwise, if there are
 some duplicated elements, fewer permutations will be produced.
<pre class="d_code notranslate"><span class="d_comment">// Enumerate all permutations
</span><span class="d_keyword">int</span>[] a = [1,2,3,4,5];
<span class="d_keyword">do</span>
{
    <span class="d_comment">// use the current permutation and
</span>    <span class="d_comment">// proceed to the next permutation of the array.
</span>} <span class="d_keyword">while</span> (<span class="d_psymbol">nextPermutation</span>(a));
</pre>
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>false</b> if the range was lexicographically the greatest, in which
 case the range is reversed back to the lexicographically smallest
 permutation; otherwise returns <b>true</b>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// Step through all permutations of a sorted array in lexicographic order
</span><span class="d_keyword">int</span>[] a = [1,2,3];
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [1,3,2]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,1,3]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,3,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [3,1,2]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [3,2,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(a == [1,2,3]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// Step through permutations of an array containing duplicate elements:
</span><span class="d_keyword">int</span>[] a = [1,1,2];
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [1,2,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,1,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(a == [1,1,2]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".nextEvenPermutation"></a><div class="quickindex" id="quickindex.nextEvenPermutation"></div>bool <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span>(alias less = "a&lt;b", BidirectionalRange)(ref BidirectionalRange <i>range</i>) if (isBidirectionalRange!BidirectionalRange &amp;&amp; hasSwappableElements!BidirectionalRange);
</dt>
<dd><div class="summary">Permutes <span class="d_inlinecode donthyphenate notranslate">range</span> in-place to the next lexicographically greater <i>even</i>
 permutation.
</div>
<div class="description"> The predicate <span class="d_inlinecode donthyphenate notranslate">less</span> defines the lexicographical ordering to be used on
 the range.
<p></p>

 An even permutation is one which is produced by swapping an even number of
 pairs of elements in the original range. The set of <i>even</i> permutations
 is distinct from the set of <i>all</i> permutations only when there are no
 duplicate elements in the range. If the range has <i>N</i> unique elements,
 then there are exactly <i>N</i>!/2 even permutations.
<p></p>

 If the range is already the lexicographically greatest even permutation, it
 is permuted back to the least even permutation and <b>false</b> is returned.
 Otherwise, <b>true</b> is returned, and the range is modified in-place to be the
 lexicographically next even permutation.
<p></p>

 One can thus generate the even permutations of a range with unique elements
 by starting with the lexicographically smallest permutation, and repeatedly
 calling <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span> until it returns <b>false</b>.
<pre class="d_code notranslate"><span class="d_comment">// Enumerate even permutations
</span><span class="d_keyword">int</span>[] a = [1,2,3,4,5];
<span class="d_keyword">do</span>
{
    <span class="d_comment">// use the current permutation and
</span>    <span class="d_comment">// proceed to the next even permutation of the array.
</span>} <span class="d_keyword">while</span> (<span class="d_psymbol">nextEvenPermutation</span>(a));
</pre>
 One can also generate the <i>odd</i> permutations of a range by noting that
 permutations obey the rule that even + even = even, and odd + even = odd.
 Thus, by swapping the last two elements of a lexicographically least range,
 it is turned into the first odd permutation. Then calling
 <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span> on this first odd permutation will generate the next
 even permutation relative to this odd permutation, which is actually the
 next odd permutation of the original range. Thus, by repeatedly calling
 <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span> until it returns <b>false</b>, one enumerates the odd
 permutations of the original range.
<pre class="d_code notranslate"><span class="d_comment">// Enumerate odd permutations
</span><span class="d_keyword">int</span>[] a = [1,2,3,4,5];
swap(a[$-2], a[$-1]);    <span class="d_comment">// a is now the first odd permutation of [1,2,3,4,5]
</span><span class="d_keyword">do</span>
{
    <span class="d_comment">// use the current permutation and
</span>    <span class="d_comment">// proceed to the next odd permutation of the original array
</span>    <span class="d_comment">// (which is an even permutation of the first odd permutation).
</span>} <span class="d_keyword">while</span> (<span class="d_psymbol">nextEvenPermutation</span>(a));
</pre>

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Warning:</span>
Since even permutations are only distinct from all permutations
 when the range elements are unique, this function assumes that there are no
 duplicate elements under the specified ordering. If this is not true, some
 permutations may fail to be generated. When the range has non-unique
 elements, you should use <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#.nextPermutation">nextPermutation</a>&nbsp;</font> instead.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns"><b>false</b> if the range was lexicographically the greatest, in which
 case the range is reversed back to the lexicographically smallest
 permutation; otherwise returns <b>true</b>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// Step through even permutations of a sorted array in lexicographic order
</span><span class="d_keyword">int</span>[] a = [1,2,3];
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextEvenPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,3,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextEvenPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [3,1,2]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextEvenPermutation</span>(a) == <span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(a == [1,2,3]);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Even permutations are useful for generating coordinates of certain geometric
shapes. Here's a non-trivial example:
<pre class="d_code notranslate">
<span class="d_keyword">import</span> std.math : sqrt;

<span class="d_comment">// Print the 60 vertices of a uniform truncated icosahedron (soccer ball)
</span><span class="d_keyword">enum</span> <span class="d_keyword">real</span> Phi = (1.0 + sqrt(5.0)) / 2.0;    <span class="d_comment">// Golden ratio
</span><span class="d_keyword">real</span>[][] seeds = [
    [0.0, 1.0, 3.0*Phi],
    [1.0, 2.0+Phi, 2.0*Phi],
    [Phi, 2.0, Phi^^3]
];
size_t n;
<span class="d_keyword">foreach</span> (seed; seeds)
{
    <span class="d_comment">// Loop over even permutations of each seed
</span>    <span class="d_keyword">do</span>
    {
        <span class="d_comment">// Loop over all sign changes of each permutation
</span>        size_t i;
        <span class="d_keyword">do</span>
        {
            <span class="d_comment">// Generate all possible sign changes
</span>            <span class="d_keyword">for</span> (i=0; i &lt; seed.length; i++)
            {
                <span class="d_keyword">if</span> (seed[i] != 0.0)
                {
                    seed[i] = -seed[i];
                    <span class="d_keyword">if</span> (seed[i] &lt; 0.0)
                        <span class="d_keyword">break</span>;
                }
            }
            n++;
        } <span class="d_keyword">while</span> (i &lt; seed.length);
    } <span class="d_keyword">while</span> (<span class="d_psymbol">nextEvenPermutation</span>(seed));
}
<span class="d_keyword">assert</span>(n == 60);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".cartesianProduct"></a><div class="quickindex" id="quickindex.cartesianProduct"></div>auto <a name="cartesianProduct"></a><span class="ddoc_psymbol">cartesianProduct</span>(R1, R2)(R1 <i>range1</i>, R2 <i>range2</i>);
<br><a name=".cartesianProduct"></a><div class="quickindex" id="quickindex.cartesianProduct"></div>auto <a name="cartesianProduct"></a><span class="ddoc_psymbol">cartesianProduct</span>(R1, R2, RR...)(R1 <i>range1</i>, R2 <i>range2</i>, RR <i>otherRanges</i>);
</dt>
<dd><div class="summary">Lazily computes the Cartesian product of two or more ranges. The product is a
range of tuples of elements from each respective range.
</div>
<div class="description">The conditions for the two-range case are as follows:
<p></p>

If both ranges are finite, then one must be (at least) a forward range and the
other an input range.
<p></p>

If one range is infinite and the other finite, then the finite range must
be a forward range, and the infinite range can be an input range.
<p></p>

If both ranges are infinite, then both must be forward ranges.
<p></p>

When there are more than two ranges, the above conditions apply to each
adjacent pair of ranges.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> N = sequence!<span class="d_string">"n"</span>(0);         <span class="d_comment">// the range of natural numbers
</span><span class="d_keyword">auto</span> N2 = <span class="d_psymbol">cartesianProduct</span>(N, N); <span class="d_comment">// the range of all pairs of natural numbers
</span>
<span class="d_comment">// Various arbitrary number pairs can be found in the range in finite time.
</span><span class="d_keyword">assert</span>(canFind(N2, tuple(0, 0)));
<span class="d_keyword">assert</span>(canFind(N2, tuple(123, 321)));
<span class="d_keyword">assert</span>(canFind(N2, tuple(11, 35)));
<span class="d_keyword">assert</span>(canFind(N2, tuple(279, 172)));
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> B = [ 1, 2, 3 ];
<span class="d_keyword">auto</span> C = [ 4, 5, 6 ];
<span class="d_keyword">auto</span> BC = <span class="d_psymbol">cartesianProduct</span>(B, C);

<span class="d_keyword">foreach</span> (n; [[1, 4], [2, 4], [3, 4], [1, 5], [2, 5], [3, 5], [1, 6],
             [2, 6], [3, 6]])
{
    <span class="d_keyword">assert</span>(canFind(BC, tuple(n[0], n[1])));
}
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">auto</span> A = [ 1, 2, 3 ];
<span class="d_keyword">auto</span> B = [ 'a', 'b', 'c' ];
<span class="d_keyword">auto</span> C = [ <span class="d_string">"x"</span>, <span class="d_string">"y"</span>, <span class="d_string">"z"</span> ];
<span class="d_keyword">auto</span> ABC = <span class="d_psymbol">cartesianProduct</span>(A, B, C);

<span class="d_keyword">assert</span>(ABC.equal([
    tuple(1, 'a', <span class="d_string">"x"</span>), tuple(2, 'a', <span class="d_string">"x"</span>), tuple(3, 'a', <span class="d_string">"x"</span>),
    tuple(1, 'b', <span class="d_string">"x"</span>), tuple(2, 'b', <span class="d_string">"x"</span>), tuple(3, 'b', <span class="d_string">"x"</span>),
    tuple(1, 'c', <span class="d_string">"x"</span>), tuple(2, 'c', <span class="d_string">"x"</span>), tuple(3, 'c', <span class="d_string">"x"</span>),
    tuple(1, 'a', <span class="d_string">"y"</span>), tuple(2, 'a', <span class="d_string">"y"</span>), tuple(3, 'a', <span class="d_string">"y"</span>),
    tuple(1, 'b', <span class="d_string">"y"</span>), tuple(2, 'b', <span class="d_string">"y"</span>), tuple(3, 'b', <span class="d_string">"y"</span>),
    tuple(1, 'c', <span class="d_string">"y"</span>), tuple(2, 'c', <span class="d_string">"y"</span>), tuple(3, 'c', <span class="d_string">"y"</span>),
    tuple(1, 'a', <span class="d_string">"z"</span>), tuple(2, 'a', <span class="d_string">"z"</span>), tuple(3, 'a', <span class="d_string">"z"</span>),
    tuple(1, 'b', <span class="d_string">"z"</span>), tuple(2, 'b', <span class="d_string">"z"</span>), tuple(3, 'b', <span class="d_string">"z"</span>),
    tuple(1, 'c', <span class="d_string">"z"</span>), tuple(2, 'c', <span class="d_string">"z"</span>), tuple(3, 'c', <span class="d_string">"z"</span>),
]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".among"></a><div class="quickindex" id="quickindex.among"></div>uint <a name="among"></a><span class="ddoc_psymbol">among</span>(alias pred = (a, b) =&gt; a == b, Value, Values...)(Value <i>value</i>, Values <i>values</i>) if (Values.length != 0);
<br><a name=".among"></a><div class="quickindex" id="quickindex.among"></div>template <a name="among"></a><span class="ddoc_psymbol">among</span>(values...) if (isExpressionTuple!values)</dt>
<dd><div class="summary">Find <span class="d_inlinecode donthyphenate notranslate">value</span> among <span class="d_inlinecode donthyphenate notranslate">values</span>, returning the 1-based index
of the first matching value in <span class="d_inlinecode donthyphenate notranslate">values</span>, or <span class="d_inlinecode donthyphenate notranslate">0</span> if <span class="d_inlinecode donthyphenate notranslate">value</span>
is not among <span class="d_inlinecode donthyphenate notranslate">values</span>. The predicate <span class="d_inlinecode donthyphenate notranslate">pred</span> is used to
compare values, and uses equality by default.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><span class="libref"><a href="http://dlang.org/phobos/std_algorithm.html#find"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.find</span></a></span> for finding a value in a range.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(3.<span class="d_psymbol">among</span>(1, 42, 24, 3, 2));

<span class="d_keyword">if</span> (<span class="d_keyword">auto</span> pos = <span class="d_string">"bar"</span>.<span class="d_psymbol">among</span>(<span class="d_string">"foo"</span>, <span class="d_string">"bar"</span>, <span class="d_string">"baz"</span>))
    <span class="d_keyword">assert</span>(pos == 2);
<span class="d_keyword">else</span>
    <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);

<span class="d_comment">// 42 is larger than 24
</span><span class="d_keyword">assert</span>(42.<span class="d_psymbol">among</span>!((lhs, rhs) =&gt; lhs &gt; rhs)(43, 24, 100) == 2);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples">Alternatively, <span class="d_inlinecode donthyphenate notranslate">values</span> can be passed at compile-time, allowing for a more
efficient search, but one that only supports matching on equality:
<pre class="d_code notranslate">
<span class="d_keyword">assert</span>(3.<span class="d_psymbol">among</span>!(2, 3, 4));
<span class="d_keyword">assert</span>(<span class="d_string">"bar"</span>.<span class="d_psymbol">among</span>!(<span class="d_string">"foo"</span>, <span class="d_string">"bar"</span>, <span class="d_string">"baz"</span>) == 2);
</pre>
</div></div>
</dd>
</dl>

</div>
<div id="copyright">Andrei Alexandrescu 2008-.

 | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Tue Jul  4 02:55:17 2017
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('<script src="../js/jquery-1.7.2.min.js">\x3C/script>')</script>
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>
    <script type="text/javascript" src="../js/cssmenu.js"></script>

<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(listanchors);</script>
</body>
</html>

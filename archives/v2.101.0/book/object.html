
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Object - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Object' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BObject%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/object.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Object</h1>
        
        



<p>Classes that do not explicitly inherit any class, automatically inherit the <code class="d_inline">Object</code> class.
</p>

<p>By that definition, the topmost class in any class hierarchy inherits <code class="d_inline">Object</code>:
</p>

<pre class="d_code"><span class="d_comment">// ": Object" is not written; it is automatic
</span><span class="d_keyword">class</span> MusicalInstrument <span style="text-decoration:line-through">: Object </span> {
    <span class="d_comment">// ...
</span>}

<span class="d_comment">// Inherits Object indirectly
</span><span class="d_keyword">class</span> StringInstrument : MusicalInstrument {
    <span class="d_comment">// ...
</span>}
</pre>

<p>Since the topmost class inherits <code class="d_inline">Object</code>, every class indirectly inherits <code class="d_inline">Object</code> as well. In that sense, every class "is an" <code class="d_inline">Object</code>.
</p>

<p>Every class inherits the following member functions of <code class="d_inline">Object</code>:
</p>

<ul><li><code class="d_inline">toString</code>: The <code class="d_inline">string</code> representation of the object.</li>
<li><code class="d_inline">opEquals</code>: Equality comparison with another object.</li>
<li><code class="d_inline">opCmp</code>: Sort order comparison with another object.</li>
<li><code class="d_inline">toHash</code>: Associative array hash value.</li>
</ul>

<p>The last three of these functions emphasize the values of objects. They also make a class eligible for being the key type of associative arrays.
</p>

<p>Because these functions are inherited, their redefinitions for the subclasses require the <code class="d_inline">override</code> keyword.
</p>

<p><i><b>Note:</b> <code class="d_inline">Object</code> defines other members as well. This chapter will include only those four member functions of it.</i>
</p>

<h5 class="subsection"><a id="ix_Object.typeid" content="typeid"></a> <a id="ix_Object.TypeInfo" content="TypeInfo"></a> <code class="d_inline">typeid</code> and <code class="d_inline">TypeInfo</code></h5>

<p><code class="d_inline">Object</code> is defined in the <a href="http://dlang.org/phobos/object.html"><code class="d_inline">object</code> module</a> (which is not a part of the <code class="d_inline">std</code> package). The <code class="d_inline">object</code> module defines <code class="d_inline">TypeInfo</code> as well, a class that provides information about types. Every type has a distinct <code class="d_inline">TypeInfo</code> object. The <code class="d_inline">typeid</code> <i>expression</i> provides access to the <code class="d_inline">TypeInfo</code> object that is associated with a particular type. As we will see later below, the <code class="d_inline">TypeInfo</code> class can be used for determining whether two types are the same, as well as for accessing special functions of a type (<code class="d_inline">toHash</code>, <code class="d_inline">postblit</code>, etc., most of which are not covered in this book).
</p>

<p><code class="d_inline">TypeInfo</code> is always about the actual run-time type. For example, although both <code class="d_inline">Violin</code> and <code class="d_inline">Guitar</code> below inherit <code class="d_inline">StringInstrument</code> directly and <code class="d_inline">MusicalInstrument</code> indirectly, the <code class="d_inline">TypeInfo</code> instances of <code class="d_inline">Violin</code> and <code class="d_inline">Guitar</code> are different. They are exactly for <code class="d_inline">Violin</code> and <code class="d_inline">Guitar</code> types, respectively:
</p>

<pre class="d_code"><span class="d_keyword">class</span> MusicalInstrument {
}

<span class="d_keyword">class</span> StringInstrument : MusicalInstrument {
}

<span class="d_keyword">class</span> Violin : StringInstrument {
}

<span class="d_keyword">class</span> Guitar : StringInstrument {
}

<span class="d_keyword">void</span> main() {
    TypeInfo v = <span class="hilite"><span class="d_keyword">typeid</span></span>(Violin);
    TypeInfo g = <span class="hilite"><span class="d_keyword">typeid</span></span>(Guitar);
    <span class="d_keyword">assert</span>(v != g);    <span class="d_comment">// ← the two types are not the same</span>
}
</pre>

<p>The <code class="d_inline">typeid</code> expressions above are being used with <i>types</i> like <code class="d_inline">Violin</code> itself. <code class="d_inline">typeid</code> can take an <i>expression</i> as well, in which case it returns the <code class="d_inline">TypeInfo</code> object for the run-time type of that expression. For example, the following function takes two parameters of different but related types:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_comment">// ...
</span>
<span class="d_keyword">void</span> foo(<span class="hilite">MusicalInstrument</span> m, <span class="hilite">StringInstrument</span> s) {
    <span class="d_keyword">const</span> isSame = (<span class="d_keyword">typeid</span>(m) == <span class="d_keyword">typeid</span>(s));

    writefln(<span class="d_string">"The types of the arguments are %s."</span>,
             isSame ? <span class="d_string">"the same"</span> : <span class="d_string">"different"</span>);
}

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> a = <span class="d_keyword">new</span> <span class="hilite">Violin</span>();
    <span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> <span class="hilite">Violin</span>();
    foo(a, b);
</pre>

<p>Since both arguments to <code class="d_inline">foo()</code> are two <code class="d_inline">Violin</code> objects for that particular call, <code class="d_inline">foo()</code> determines that their types are the same:
</p>

<pre class="shell">The types of the arguments are <span class="hilite">the same</span>.
</pre>

<p>Unlike <code class="d_inline">.sizeof</code> and <code class="d_inline">typeof</code>, which never execute their expressions, <code class="d_inline">typeid</code> always executes the expression that it receives:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> foo(string when) {
    writefln(<span class="d_string">"Called during '%s'."</span>, when);
    <span class="d_keyword">return</span> 0;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">const</span> s = foo(<span class="d_string">"sizeof"</span>)<span class="hilite">.sizeof</span>;     <span class="d_comment">// foo() is not called
</span>    <span class="d_keyword">alias</span> T = <span class="hilite"><span class="d_keyword">typeof</span></span>(foo(<span class="d_string">"typeof"</span>));    <span class="d_comment">// foo() is not called
</span>    <span class="d_keyword">auto</span> ti = <span class="hilite"><span class="d_keyword">typeid</span></span>(foo(<span class="d_string">"typeid"</span>));    <span class="d_comment">// foo() is called
</span>}
</pre>

<p>The output indicates that only the expression of <code class="d_inline">typeid</code> is executed:
</p>

<pre class="shell">Called during 'typeid'.
</pre>

<p>The reason for this difference is because actual run-time types of expressions may not be known until those expressions are executed. For example, the exact return type of the following function would be either <code class="d_inline">Violin</code> or <code class="d_inline">Guitar</code> depending on the value of function argument <code class="d_inline">i</code>:
</p>

<pre class="d_code">MusicalInstrument foo(<span class="d_keyword">int</span> i) {
    <span class="d_keyword">return</span> (<span class="hilite">i</span> % 2) ? <span class="d_keyword">new</span> Violin() : <span class="d_keyword">new</span> Guitar();
}
</pre>

<p><a id="ix_Object.TypeInfo_Class" content="TypeInfo_Class"></a> <a id="ix_Object..classinfo" content=".classinfo"></a> There are various subclasses of <code class="d_inline">TypeInfo</code> for various kinds of types like arrays, structs, classes, etc. Of these, <code class="d_inline">TypeInfo_Class</code> can be particularly useful. For example, the name of the run-time type of an object can be obtained through its <code class="d_inline">TypeInfo_Class.name</code> property as a <code class="d_inline">string</code>. You can access the <code class="d_inline">TypeInfo_Class</code> instance of an object by its <code class="d_inline">.classinfo</code> property:
</p>

<pre class="d_code">    TypeInfo_Class info = a<span class="hilite">.classinfo</span>;
    string runtimeTypeName = info<span class="hilite">.name</span>;
</pre>

<h5 class="subsection"><a id="ix_Object.toString" content="toString"></a> <code class="d_inline">toString</code></h5>

<p>Same with structs, <code class="d_inline">toString</code> enables using class objects as strings:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> clock = <span class="d_keyword">new</span> Clock(20, 30, 0);
    writeln(clock);         <span class="d_comment">// Calls clock.toString()
</span></pre>

<p>The inherited <code class="d_inline">toString()</code> is usually not useful; it produces just the name of the type:
</p>

<pre class="shell">deneme.Clock
</pre>

<p>The part before the name of the type is the name of the module. The output above indicates that <code class="d_inline">Clock</code> has been defined in the <code class="d_inline">deneme</code> module.
</p>

<p>As we have seen in the previous chapter, this function is almost always overridden to produce a more meaningful <code class="d_inline">string</code> representation:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.string;

<span class="d_keyword">class</span> Clock {
    <span class="d_keyword">override</span> string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"%02s:%02s:%02s"</span>, hour, minute, second);
    }

    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_keyword">override</span> string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"%s ♫%02s:%02s"</span>, <span class="d_keyword">super</span>.toString(),
                      alarmHour, alarmMinute);
    }

    <span class="d_comment">// ...
</span>}

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> bedSideClock = <span class="d_keyword">new</span> AlarmClock(20, 30, 0, 7, 0);
    writeln(bedSideClock);
</pre>

<p>The output:
</p>

<pre class="shell">20:30:00 ♫07:00
</pre>

<h5 class="subsection"><a id="ix_Object.opEquals" content="opEquals"></a> <code class="d_inline">opEquals</code></h5>

<p>As we have seen in the <a href="operator_overloading.html">Operator Overloading chapter</a>, this member function is about the behavior of the <code class="d_inline">==</code> operator (and the <code class="d_inline">!=</code> operator indirectly). The return value of the operator must be <code class="d_inline">true</code> if the objects are considered to be equal and <code class="d_inline">false</code> otherwise.
</p>

<p><b>Warning:</b> The definition of this function must be consistent with <code class="d_inline">opCmp()</code>; for two objects that <code class="d_inline">opEquals()</code> returns <code class="d_inline">true</code>, <code class="d_inline">opCmp()</code> must return zero.
</p>

<p>Contrary to structs, the compiler does not call <code class="d_inline">a.opEquals(b)</code> right away when it sees the expression <code class="d_inline">a&nbsp;==&nbsp;b</code>. When two class objects are compared by the <code class="d_inline">==</code> operator, a four-step algorithm is executed:
</p>

<pre class="d_code"><span class="d_keyword">bool</span> opEquals(Object a, Object b) {
    <span class="d_keyword">if</span> (a <span class="d_keyword">is</span> b) <span class="d_keyword">return</span> <span class="d_keyword">true</span>;                          <span class="d_comment">// (1)
</span>    <span class="d_keyword">if</span> (a <span class="d_keyword">is</span> <span class="d_keyword">null</span> || b <span class="d_keyword">is</span> <span class="d_keyword">null</span>) <span class="d_keyword">return</span> <span class="d_keyword">false</span>;         <span class="d_comment">// (2)
</span>    <span class="d_keyword">if</span> (<span class="d_keyword">typeid</span>(a) == <span class="d_keyword">typeid</span>(b)) <span class="d_keyword">return</span> a.opEquals(b); <span class="d_comment">// (3)
</span>    <span class="d_keyword">return</span> a.opEquals(b) &amp;&amp; b.opEquals(a);            <span class="d_comment">// (4)
</span>}
</pre>

<ol>
<li>If the two variables provide access to the same object (or they are both <code class="d_inline">null</code>), then they are equal.</li>

<li>Following from the previous check, if only one is <code class="d_inline">null</code> then they are not equal.</li>

<li>If both of the objects are of the same type, then <code class="d_inline">a.opEquals(b)</code> is called to determine the equality.</li>

<li>Otherwise, for the two objects to be considered equal, <code class="d_inline">opEquals</code> must have been defined for both of their types and <code class="d_inline">a.opEquals(b)</code> and <code class="d_inline">b.opEquals(a)</code> must agree that the objects are equal.</li>

</ol>

<p>Accordingly, if <code class="d_inline">opEquals()</code> is not provided for a class type, then the values of the objects are not considered; rather, equality is determined by checking whether the two class variables provide access to the same object:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> variable0 = <span class="d_keyword">new</span> Clock(6, 7, 8);
    <span class="d_keyword">auto</span> variable1 = <span class="d_keyword">new</span> Clock(6, 7, 8);

    <span class="d_keyword">assert</span>(variable0 != variable1); <span class="d_comment">// They are not equal
</span>                                    <span class="d_comment">// because the objects are
</span>                                    <span class="d_comment">// different
</span></pre>

<p>Even though the two objects are constructed by the same arguments above, the variables are not equal because they are not associated with the same object.
</p>

<p>On the other hand, because the following two variables provide access to the same object, they are <i>equal</i>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> partner0 = <span class="d_keyword">new</span> Clock(9, 10, 11);
    <span class="d_keyword">auto</span> partner1 = partner0;

    <span class="d_keyword">assert</span>(partner0 == partner1);   <span class="d_comment">// They are equal because
</span>                                    <span class="d_comment">// the object is the same
</span></pre>

<p>Sometimes it makes more sense to compare objects by their values instead of their identities. For example, it is conceivable that <code class="d_inline">variable0</code> and <code class="d_inline">variable1</code> above compare equal because their values are the same.
</p>

<p>Different from structs, the type of the parameter of <code class="d_inline">opEquals</code> for classes is <code class="d_inline">Object</code>:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    <span class="d_keyword">override</span> <span class="d_keyword">bool</span> opEquals(<span class="hilite">Object o</span>) <span class="d_keyword">const</span> {
        <span class="d_comment">// ...
</span>    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>As you will see below, the parameter is almost never used directly. For that reason, it should be acceptable to name it simply as <code class="d_inline">o</code>. Most of the time the first thing to do with that parameter is to use it in a type conversion.
</p>

<p>The parameter of <code class="d_inline">opEquals</code> is the object that appears on the right-hand side of the <code class="d_inline">==</code> operator:
</p>

<pre class="d_code">    variable0 == variable1;    <span class="d_comment">// o represents variable1
</span></pre>

<p>Since the purpose of <code class="d_inline">opEquals()</code> is to compare two objects of this class type, the first thing to do is to convert <code class="d_inline">o</code> to a variable of the same type of this class. Since it would not be appropriate to modify the right-hand side object in an equality comparison, it is also proper to convert the type as <code class="d_inline">const</code>:
</p>

<pre class="d_code">    <span class="d_keyword">override</span> <span class="d_keyword">bool</span> opEquals(Object o) <span class="d_keyword">const</span> {
        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> Clock)o;

        <span class="d_comment">// ...
</span>    }
</pre>

<p>As you would remember, <code class="d_inline">rhs</code> is a common abbreviation for <i>right-hand side</i>. Also, <code class="d_inline">std.conv.to</code> can be used for the conversion as well:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.conv;
<span class="d_comment">// ...
</span>        <span class="d_keyword">auto</span> rhs = to!(<span class="d_keyword">const</span> Clock)(o);
</pre>

<p>If the original object on the right-hand side can be converted to <code class="d_inline">Clock</code>, then <code class="d_inline">rhs</code> becomes a non-<code class="d_inline">null</code> class variable. Otherwise, <code class="d_inline">rhs</code> is set to <code class="d_inline">null</code>, indicating that the objects are not of the same type.
</p>

<p>According to the design of a program, it may make sense to compare objects of two incompatible types. I will assume here that for the comparison to be valid, <code class="d_inline">rhs</code> must not be <code class="d_inline">null</code>; so, the first logical expression in the following <code class="d_inline">return</code> statement checks that it is not <code class="d_inline">null</code>. Otherwise, it would be an error to try to access the members of <code class="d_inline">rhs</code>:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;
    <span class="d_keyword">int</span> second;

    <span class="d_keyword">override</span> <span class="d_keyword">bool</span> opEquals(Object o) <span class="d_keyword">const</span> {
        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> Clock)o;

        <span class="d_keyword">return</span> (<span class="hilite">rhs</span> &amp;&amp;
                (hour == rhs.hour) &amp;&amp;
                (minute == rhs.minute) &amp;&amp;
                (second == rhs.second));
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>With that definition, <code class="d_inline">Clock</code> objects can now be compared by their values:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> variable0 = <span class="d_keyword">new</span> Clock(6, 7, 8);
    <span class="d_keyword">auto</span> variable1 = <span class="d_keyword">new</span> Clock(6, 7, 8);

    <span class="d_keyword">assert</span>(variable0 == variable1); <span class="d_comment">// Now they are equal
</span>                                    <span class="d_comment">// because their values
</span>                                    <span class="d_comment">// are equal
</span></pre>

<p>When defining <code class="d_inline">opEquals</code> it is important to remember the members of the superclass. For example, when comparing objects of <code class="d_inline">AlarmClock</code> it would make sense to also consider the inherited members:
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_keyword">int</span> alarmHour;
    <span class="d_keyword">int</span> alarmMinute;

    <span class="d_keyword">override</span> <span class="d_keyword">bool</span> opEquals(Object o) <span class="d_keyword">const</span> {
        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> AlarmClock)o;

        <span class="d_keyword">return</span> (rhs &amp;&amp;
                (alarmHour == rhs.alarmHour) &amp;&amp;
                (alarmMinute == rhs.alarmMinute) &amp;&amp;
                <span class="hilite"><span class="d_keyword">super</span>.opEquals(o)</span>);
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>That expression could be written as <code class="d_inline">super&nbsp;==&nbsp;o</code> as well. However, that would initiate the four-step algorithm again and as a result, the code might be a little slower.
</p>

<h5 class="subsection"><a id="ix_Object.opCmp" content="opCmp"></a> <code class="d_inline">opCmp</code></h5>

<p>This operator is used when sorting class objects. <code class="d_inline">opCmp</code> is the function that gets called behind the scenes for the <code class="d_inline">&lt;</code>, <code class="d_inline">&lt;=</code>, <code class="d_inline">&gt;</code>, and <code class="d_inline">&gt;=</code>.
</p>

<p>This operator must return a negative value when the left-hand object is before, a positive value when the left-hand object is after, and zero when both objects have the same sorting order.
</p>

<p><b>Warning:</b> The definition of this function must be consistent with <code class="d_inline">opEquals()</code>; for two objects that <code class="d_inline">opEquals()</code> returns <code class="d_inline">true</code>, <code class="d_inline">opCmp()</code> must return zero.
</p>

<p>Unlike <code class="d_inline">toString</code> and <code class="d_inline">opEquals</code>, there is no default implementation of this function in <code class="d_inline">Object</code>. If the implementation is not available, comparing objects for sort order causes an exception to be thrown:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> variable0 = <span class="d_keyword">new</span> Clock(6, 7, 8);
    <span class="d_keyword">auto</span> variable1 = <span class="d_keyword">new</span> Clock(6, 7, 8);

    <span class="d_keyword">assert</span>(variable0 &lt;= variable1);    <span class="d_comment">// ← Causes exception</span>
</pre>

<pre class="shell">object.Exception: need opCmp for class deneme.Clock
</pre>

<p>It is up to the design of the program what happens when the left-hand and right-hand objects are of different types. One way is to take advantage of the order of types that is maintained by the compiler automatically. This is achieved by calling the <code class="d_inline">opCmp</code> function on the <code class="d_inline">typeid</code> values of the two types:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;
    <span class="d_keyword">int</span> second;

    <span class="d_keyword">override</span> <span class="d_keyword">int</span> opCmp(Object o) <span class="d_keyword">const</span> {
        <span class="d_comment">/* Taking advantage of the automatically-maintained
         * order of the types. */</span>
        <span class="d_keyword">if</span> (<span class="d_keyword">typeid</span>(<span class="d_keyword">this</span>) != <span class="d_keyword">typeid</span>(o)) {
            <span class="d_keyword">return</span> <span class="d_keyword">typeid</span>(<span class="d_keyword">this</span>).opCmp(<span class="d_keyword">typeid</span>(o));
        }

        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> Clock)o;
        <span class="d_comment">/* No need to check whether rhs is null, because it is
         * known at this line that it has the same type as o. */</span>

        <span class="d_keyword">if</span> (hour != rhs.hour) {
            <span class="d_keyword">return</span> hour - rhs.hour;

        } <span class="d_keyword">else</span> <span class="d_keyword">if</span> (minute != rhs.minute) {
            <span class="d_keyword">return</span> minute - rhs.minute;

        } <span class="d_keyword">else</span> {
            <span class="d_keyword">return</span> second - rhs.second;
        }
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>The definition above first checks whether the types of the two objects are the same. If not, it uses the ordering of the types themselves. Otherwise, it compares the objects by the values of their <code class="d_inline">hour</code>, <code class="d_inline">minute</code>, and <code class="d_inline">second</code> members.
</p>

<p>A chain of ternary operators may also be used:
</p>

<pre class="d_code">    <span class="d_keyword">override</span> <span class="d_keyword">int</span> opCmp(Object o) <span class="d_keyword">const</span> {
        <span class="d_keyword">if</span> (<span class="d_keyword">typeid</span>(<span class="d_keyword">this</span>) != <span class="d_keyword">typeid</span>(o)) {
            <span class="d_keyword">return</span> <span class="d_keyword">typeid</span>(<span class="d_keyword">this</span>).opCmp(<span class="d_keyword">typeid</span>(o));
        }

        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> Clock)o;

        <span class="d_keyword">return</span> (hour != rhs.hour
                ? hour - rhs.hour
                : (minute != rhs.minute
                   ? minute - rhs.minute
                   : second - rhs.second));
    }
</pre>

<p>If important, the comparison of the members of the superclass must also be considered. The following <code class="d_inline">AlarmClock.opCmp</code> is calling <code class="d_inline">Clock.opCmp</code> first:
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> opCmp(Object o) <span class="d_keyword">const</span> {
        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(<span class="d_keyword">const</span> AlarmClock)o;

        <span class="d_keyword">const</span> <span class="d_keyword">int</span> superResult = <span class="hilite"><span class="d_keyword">super</span>.opCmp(o)</span>;

        <span class="d_keyword">if</span> (superResult != 0) {
            <span class="d_keyword">return</span> superResult;

        } <span class="d_keyword">else</span> <span class="d_keyword">if</span> (alarmHour != rhs.alarmHour) {
            <span class="d_keyword">return</span> alarmHour - rhs.alarmHour;

        } <span class="d_keyword">else</span> {
            <span class="d_keyword">return</span> alarmMinute - rhs.alarmMinute;
        }
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>Above, if the superclass comparison returns a nonzero value then that result is used because the sort order of the objects is already determined by that value.
</p>

<p><code class="d_inline">AlarmClock</code> objects can now be compared for their sort orders:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> ac0 = <span class="d_keyword">new</span> AlarmClock(8, 0, 0, 6, 30);
    <span class="d_keyword">auto</span> ac1 = <span class="d_keyword">new</span> AlarmClock(8, 0, 0, 6, 31);

    <span class="d_keyword">assert</span>(ac0 &lt; ac1);
</pre>

<p><code class="d_inline">opCmp</code> is used by other language features and libraries as well. For example, the <code class="d_inline">sort()</code> function takes advantage of <code class="d_inline">opCmp</code> when sorting elements.
</p>

<h6><code class="d_inline">opCmp</code> for string members</h6>

<p>When some of the members are strings, they can be compared explicitly to return a negative, positive, or zero value:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.exception;

<span class="d_keyword">class</span> Student {
    string name;

    <span class="d_keyword">override</span> <span class="d_keyword">int</span> opCmp(Object o) <span class="d_keyword">const</span> {
        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(Student)o;
        enforce(rhs);

        <span class="d_keyword">if</span> (name &lt; rhs.name) {
            <span class="d_keyword">return</span> -1;

        } <span class="d_keyword">else</span> <span class="d_keyword">if</span> (name &gt; rhs.name) {
            <span class="d_keyword">return</span> 1;

        } <span class="d_keyword">else</span> {
            <span class="d_keyword">return</span> 0;
        }
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>Instead, the existing <code class="d_inline">std.algorithm.cmp</code> function can be used, which happens to be faster as well:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.algorithm;

<span class="d_keyword">class</span> Student {
    string name;

    <span class="d_keyword">override</span> <span class="d_keyword">int</span> opCmp(Object o) <span class="d_keyword">const</span> {
        <span class="d_keyword">auto</span> rhs = <span class="d_keyword">cast</span>(Student)o;
        enforce(rhs);

        <span class="d_keyword">return</span> cmp(name, rhs.name);
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>Also note that <code class="d_inline">Student</code> does not support comparing incompatible types by enforcing that the conversion from <code class="d_inline">Object</code> to <code class="d_inline">Student</code> is possible.
</p>

<h5 class="subsection"><a id="ix_Object.toHash" content="toHash"></a> <code class="d_inline">toHash</code></h5>

<p>This function allows objects of a class type to be used as associative array <i>keys</i>. It does not affect the cases where the type is used as associative array <i>values</i>. If this function is defined, <code class="d_inline">opEquals</code> must be defined as well.
</p>

<h6><a id="ix_Object.hash table" content="hash table"></a> Hash table indexes</h6>

<p>Associative arrays are a hash table implementation. Hash table is a very fast data structure when it comes to searching elements in the table. (<i>Note: Like most other things in software, this speed comes at a cost: Hash tables must keep elements in an unordered way, and they may be taking up space that is more than exactly necessary.</i>)
</p>

<p>The high speed of hash tables comes from the fact that they first produce integer values for keys. These integers are called <i>hash values</i>. The hash values are then used for indexing into an internal array that is maintained by the table.
</p>

<p>A benefit of this method is that any type that can produce unique integer values for its objects can be used as the key type of associative arrays. <code class="d_inline">toHash</code> is the function that returns the hash value for an object.
</p>

<p>Even <code class="d_inline">Clock</code> objects can be used as associative array key values:
</p>

<pre class="d_code">    string[<span class="hilite">Clock</span>] timeTags;
    timeTags[<span class="d_keyword">new</span> Clock(12, 0, 0)] = <span class="d_string">"Noon"</span>;
</pre>

<p>The default definition of <code class="d_inline">toHash</code> that is inherited from <code class="d_inline">Clock</code> produces different hash values for different objects without regard to their values. This is similar to how the default behavior of <code class="d_inline">opEquals</code> considers different objects as being not equal.
</p>

<p>The code above compiles and runs even when there is no special definition of <code class="d_inline">toHash</code> for <code class="d_inline">Clock</code>. However, its default behavior is almost never what is desired. To see that default behavior, let's try to access an element by an object that is different from the one that has been used when inserting the element. Although the new <code class="d_inline">Clock</code> object below has the same value as the <code class="d_inline">Clock</code> object that has been used when inserting into the associative array above, the value cannot be found:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (<span class="d_keyword">new</span> Clock(12, 0, 0) <span class="d_keyword">in</span> timeTags) {
        writeln(<span class="d_string">"Exists"</span>);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"Missing"</span>);
    }
</pre>

<p>According to the <code class="d_inline">in</code> operator, there is no element in the table that corresponds to the value <code class="d_inline">Clock(12,&nbsp;0,&nbsp;0)</code>:
</p>

<pre class="shell">Missing
</pre>

<p>The reason for this surprising behavior is that the key object that has been used when inserting the element is not the same as the key object that has been used when accessing the element.
</p>

<h6>Selecting members for <code class="d_inline">toHash</code></h6>

<p>Although the hash value is calculated from the members of an object, not every member is suitable for this task.
</p>

<p>The candidates are the members that distinguish objects from each other. For example, the members <code class="d_inline">name</code> and <code class="d_inline">lastName</code> of a <code class="d_inline">Student</code> class would be suitable if those members can be used for identifying objects of that type.
</p>

<p>On the other hand, a <code class="d_inline">grades</code> array of a <code class="d_inline">Student</code> class would not be suitable both because many objects may have the same array and also it is likely that the <code class="d_inline">grades</code> array may change over time.
</p>

<h6>Calculating hash values</h6>

<p>The choice of hash values has a direct effect on the performance of associative arrays. Furthermore, a hash calculation that is effective on one type of data may not be as effective on another type of data. As <i>hash algorithms</i> are beyond the scope of this book, I will give just one guideline here: In general, it is better to produce different hash values for objects that are considered to have different values. However, it is not an error if two objects with different values produce the same index value; it is merely undesirable for performance reasons.
</p>

<p>It is conceivable that all of the members of <code class="d_inline">Clock</code> are significant to distinguish its objects from each other. For that reason, the hash values can be calculated from the values of its three members. <i>The number of seconds since midnight</i> would be effective hash values for objects that represent different points in time:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;
    <span class="d_keyword">int</span> second;

    <span class="d_keyword">override</span> size_t toHash() <span class="d_keyword">const</span> {
        <span class="d_comment">/* Because there are 3600 seconds in an hour and 60
         * seconds in a minute: */</span>
        <span class="d_keyword">return</span> (3600 * hour) + (60 * minute) + second;
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>Whenever <code class="d_inline">Clock</code> is used as the key type of associative arrays, that special definition of <code class="d_inline">toHash</code> would be used. As a result, even though the two key objects of <code class="d_inline">Clock(12,&nbsp;0,&nbsp;0)</code> above are distinct, they would now produce the same hash value.
</p>

<p>The new output:
</p>

<pre class="shell">Exists
</pre>

<p>Similar to the other member functions, the superclass may need to be considered as well. For example, <code class="d_inline">AlarmClock.toHash</code> can take advantage of <code class="d_inline">Clock.toHash</code> during its index calculation:
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_keyword">int</span> alarmHour;
    <span class="d_keyword">int</span> alarmMinute;

    <span class="d_keyword">override</span> size_t toHash() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> <span class="hilite"><span class="d_keyword">super</span>.toHash()</span> + alarmHour + alarmMinute;
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p><i><b>Note:</b> Take the calculation above just as an example. In general, adding integer values is not an effective way of generating hash values.</i>
</p>

<p>There are existing efficient algorithms for calculating hash values for variables of floating point, array, and struct types. These algorithms are available to the programmer as well.
</p>

<p><a id="ix_Object.getHash" content="getHash"></a> What needs to be done is to call <code class="d_inline">getHash()</code> on the <code class="d_inline">typeid</code> of each member. The syntax of this method is the same for floating point, array, and struct types.
</p>

<p>For example, hash values of a <code class="d_inline">Student</code> type can be calculated from its <code class="d_inline">name</code> member as in the following code:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Student {
    string name;

    <span class="d_keyword">override</span> size_t toHash() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> <span class="d_keyword">typeid</span>(name).getHash(&amp;name);
    }

    <span class="d_comment">// ...
</span>}
</pre>

<h6>Hash values for structs</h6>

<p>Since structs are value types, hash values for their objects are calculated automatically by an efficient algorithm. That algorithm takes all of the members of the object into consideration.
</p>

<p>When there is a specific reason like needing to exclude certain members from the hash calculation, <code class="d_inline">toHash()</code> can be overridden for structs as well.
</p>

<h5 class="subsection">Problemler</h5>
    <ol>
<li>Start with the following class, which represents colored points:

<pre class="d_code"><span class="d_keyword">enum</span> Color { blue, green, red }

<span class="d_keyword">class</span> Point {
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">int</span> y;
    Color color;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, Color color) {
        <span class="d_keyword">this</span>.x = x;
        <span class="d_keyword">this</span>.y = y;
        <span class="d_keyword">this</span>.color = color;
    }
}
</pre>

<p>Implement <code class="d_inline">opEquals</code> for this class in a way that ignores colors. When implemented in that way, the following <code class="d_inline">assert</code> check should pass:
</p>

<pre class="d_code">    <span class="d_comment">// Different colors
</span>    <span class="d_keyword">auto</span> bluePoint = <span class="d_keyword">new</span> Point(1, 2, Color.blue);
    <span class="d_keyword">auto</span> greenPoint = <span class="d_keyword">new</span> Point(1, 2, Color.green);

    <span class="d_comment">// They are still equal
</span>    <span class="d_keyword">assert</span>(bluePoint == greenPoint);
</pre>

</li>

<li>Implement <code class="d_inline">opCmp</code> by considering first <code class="d_inline">x</code> then <code class="d_inline">y</code>. The following <code class="d_inline">assert</code> checks should pass:

<pre class="d_code">    <span class="d_keyword">auto</span> redPoint1 = <span class="d_keyword">new</span> Point(-1, 10, Color.red);
    <span class="d_keyword">auto</span> redPoint2 = <span class="d_keyword">new</span> Point(-2, 10, Color.red);
    <span class="d_keyword">auto</span> redPoint3 = <span class="d_keyword">new</span> Point(-2,  7, Color.red);

    <span class="d_keyword">assert</span>(redPoint1 &lt; bluePoint);
    <span class="d_keyword">assert</span>(redPoint3 &lt; redPoint2);

    <span class="d_comment">/* Even though blue is before green in enum Color,
     * because color is being ignored, bluePoint must not be
     * before greenPoint. */</span>
    <span class="d_keyword">assert</span>(!(bluePoint &lt; greenPoint));
</pre>

<p>Like the <code class="d_inline">Student</code> class above, you can implement <code class="d_inline">opCmp</code> by excluding incompatible types by the help of <code class="d_inline">enforce</code>.
</p>

</li>

<li>Consider the following class that combines three <code class="d_inline">Point</code> objects in an array:

<pre class="d_code"><span class="d_keyword">class</span> TriangularArea {
    Point[3] points;

    <span class="d_keyword">this</span>(Point one, Point two, Point three) {
        points = [ one, two, three ];
    }
}
</pre>

<p>Implement <code class="d_inline">toHash</code> for that class. Again, the following <code class="d_inline">assert</code> checks should pass:
</p>

<pre class="d_code">    <span class="d_comment">/* area1 and area2 are constructed by distinct points that
     * happen to have the same values. (Remember that
     * bluePoint and greenPoint should be considered equal.) */</span>
    <span class="d_keyword">auto</span> area1 = <span class="d_keyword">new</span> TriangularArea(bluePoint, greenPoint, redPoint1);
    <span class="d_keyword">auto</span> area2 = <span class="d_keyword">new</span> TriangularArea(greenPoint, bluePoint, redPoint1);

    <span class="d_comment">// The areas should be equal
</span>    <span class="d_keyword">assert</span>(area1 == area2);

    <span class="d_comment">// An associative array
</span>    <span class="d_keyword">double</span>[TriangularArea] areas;

    <span class="d_comment">// A value is being entered by area1
</span>    areas[area1] = 1.25;

    <span class="d_comment">// The value is being accessed by area2
</span>    <span class="d_keyword">assert</span>(area2 <span class="d_keyword">in</span> areas);
    <span class="d_keyword">assert</span>(areas[area2] == 1.25);
</pre>

<p>Remember that <code class="d_inline">opEquals</code> must also be defined when <code class="d_inline">toHash</code> is defined.
</p>

</li>

</ol> <div class="cozum_link_cok"><p><a target="ddili_cozum" href="object.cozum.html"><i>... çözümler</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 20:41:04 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

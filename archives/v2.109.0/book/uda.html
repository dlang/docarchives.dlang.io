
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>uda - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='uda' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='../bugstats.html'>Issues</a></li>
    <li><a href='../contributing.html'>Contributing</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5Buda%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/uda.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>uda</h1>
        
        



<p>Any declaration (e.g. struct type, class type, variable, etc.) can be assigned attributes, which can then be accessed at compile time to alter the way the code is compiled. User defined attributes is purely a compile-time feature.
</p>

<p><a id="ix_uda.@" content="@"></a> The user defined attribute syntax consists of the <code class="d_inline">@</code> sign followed by the attribute and appear before the declaration that it is being assigned to. For example, the following code assigns the <code class="d_inline">Encrypted</code> attribute to the declaration of <code class="d_inline">name</code>:
</p>

<pre class="d_code">    <span class="hilite">@Encrypted</span> string name;
</pre>

<p>Multiple attributes can be specified separately or as a parenthesized list of attributes. For example, both of the following variables have the same attributes:
</p>

<pre class="d_code">    @Encrypted @Colored string lastName;     <span class="d_comment">// ← separately</span>
    @<span class="hilite">&#40;</span>Encrypted, Colored<span class="hilite">&#41;</span> string address;    <span class="d_comment">// ← together</span>
</pre>

<p>An attribute can be a type name as well as a value of a user defined or a fundamental type. However, because their meanings may not be clear, attributes consisting of literal values like <code class="d_inline">42</code> are discouraged:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Encrypted {
}

<span class="d_keyword">enum</span> Color { black, blue, red }

<span class="d_keyword">struct</span> Colored {
    Color color;
}

<span class="d_keyword">void</span> main() {
    @Encrypted           <span class="d_keyword">int</span> a;    <span class="d_comment">// ← type name</span>
    @Encrypted()         <span class="d_keyword">int</span> b;    <span class="d_comment">// ← object</span>
    @Colored(Color.blue) <span class="d_keyword">int</span> c;    <span class="d_comment">// ← object</span>
    @(42)                <span class="d_keyword">int</span> d;    <span class="d_comment">// ← literal (discouraged)</span>
}
</pre>

<p>The attributes of <code class="d_inline">a</code> and <code class="d_inline">b</code> above are of different kinds: The attribute of <code class="d_inline">a</code> is the type <code class="d_inline">Encrypted</code> itself, while the attribute of <code class="d_inline">b</code> is an <i>object</i> of type <code class="d_inline">Encrypted</code>. This is an important difference that affects the way attributes are used at compile time. We will see an example of this difference below.
</p>

<p><a id="ix_uda.__traits" content="__traits"></a> <a id="ix_uda.getAttributes" content="getAttributes"></a> The meaning of attributes is solely determined by the programmer for the needs of the program. The attributes are determined by <code class="d_inline">__traits(getAttributes)</code> at compile time and the code is compiled according to those attributes.
</p>

<p>The following code shows how the attributes of a specific <code class="d_inline">struct</code> member (e.g. <code class="d_inline">Person.name</code>) can be accessed by <code class="d_inline">__traits(getAttributes)</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_comment">// ...
</span>
<span class="d_keyword">struct</span> Person {
    @Encrypted @Colored(Color.blue) string name;
    string lastName;
    @Colored(Color.red) string address;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">foreach</span> (attr; <span class="d_keyword">__traits</span>(<span class="hilite">getAttributes</span>, Person.name)) {
        writeln(attr.stringof);
    }
}
</pre>

<p>The output of the program lists the attributes of <code class="d_inline">Person.name</code>:
</p>

<pre class="shell">Encrypted
Colored(cast(Color)1)
</pre>

<p>Two other <code class="d_inline">__traits</code> expressions are useful when dealing with user defined attributes:
</p>

<ul>
<li><a id="ix_uda.allMembers" content="allMembers"></a> <code class="d_inline">__traits(allMembers)</code> produces the members of a type (or a module) as strings.</li>

<li><a id="ix_uda.getMember" content="getMember"></a> <code class="d_inline">__traits(getMember)</code> produces a <i>symbol</i> useful when accessing a member. Its first argument is a symbol (e.g. a type or a variable name) and its second argument is a string. It produces a symbol by combining its first argument, a dot, and its second argument. For example, <code class="d_inline">__traits(getMember, Person, <code class="d_inline"><span class="d_string">"name"</span></code>)</code> produces the symbol <code class="d_inline">Person.name</code>.
</li>

</ul>

<pre class="d_code"><span class="d_keyword">import</span> std.string;

<span class="d_comment">// ...
</span>
<span class="d_keyword">void</span> main() {
    <span class="d_keyword">foreach</span> (memberName; <span class="d_keyword">__traits</span>(<span class="hilite">allMembers</span>, Person)) {
        writef(<span class="d_string">"The attributes of %-8s:"</span>, memberName);

        <span class="d_keyword">foreach</span> (attr; <span class="d_keyword">__traits</span>(getAttributes,
                                <span class="d_keyword">__traits</span>(<span class="hilite">getMember</span>,
                                         Person, memberName))) {
            writef(<span class="d_string">" %s"</span>, attr.stringof);
        }

        writeln();
    }
}
</pre>

<p>The output of the program lists all attributes of all members of <code class="d_inline">Person</code>:
</p>

<pre class="shell">The attributes of name    : Encrypted Colored(cast(Color)1)
The attributes of lastName:
The attributes of address : Colored(cast(Color)2)
</pre>

<p><a id="ix_uda.hasUDA, std.traits" content="hasUDA, std.traits"></a> Another useful tool is <code class="d_inline">std.traits.hasUDA</code>, which determines whether a symbol has a specific attribute. The following <code class="d_inline">static assert</code> passes because <code class="d_inline">Person.name</code> has <code class="d_inline">Encrypted</code> attribute:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.traits;

<span class="d_comment">// ...
</span>
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(hasUDA!(Person.name, Encrypted));
</pre>

<p><code class="d_inline">hasUDA</code> can be used with an attribute type as well as a specific value of that type. The following <code class="d_inline">static assert</code> checks both pass because <code class="d_inline">Person.name</code> has <code class="d_inline">Colored(Color.blue)</code> attribute:
</p>

<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(hasUDA!(Person.name, <span class="hilite">Colored</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(hasUDA!(Person.name, <span class="hilite">Colored(Color.blue)</span>));
</pre>

<h5 class="subsection">Example</h5>

<p>Let's design a function template that prints the values of all members of a <code class="d_inline">struct</code> object in XML format. The following function considers the <code class="d_inline">Encrypted</code> and <code class="d_inline">Colored</code> attributes of each member when producing the output:
</p>

<pre class="d_code"><span class="d_keyword">void</span> printAsXML(T)(T object) {
<span class="d_comment">// ...
</span>
    <span class="d_keyword">foreach</span> (member; <span class="d_keyword">__traits</span>(<span class="hilite">allMembers</span>, T)) {             <span class="d_comment">// (1)
</span>        string value =
            <span class="d_keyword">__traits</span>(<span class="hilite">getMember</span>, object, member).to!string;  <span class="d_comment">// (2)
</span>
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="hilite">hasUDA</span>!(<span class="d_keyword">__traits</span>(getMember, T, member),  <span class="d_comment">// (3)
</span>                           Encrypted)) {
            value = value.encrypted.to!string;
        }

        writefln(<span class="d_string">`  &lt;%1&dollar;s color="%2&dollar;s"&gt;%3&dollar;s&lt;/%1&dollar;s&gt;`</span>, member,
                 <span class="hilite">colorAttributeOf</span>!(T, member), value);      <span class="d_comment">// (4)
</span>    }
}
</pre>

<p>The highlighted parts of the code are explained below:
</p>

<ol>
<li>The members of the type are determined by <code class="d_inline">__traits(allMembers)</code>.</li>

<li>The value of each member is converted to <code class="d_inline">string</code> to be used later when printing to the output. For example, when the member is <code class="d_inline"><span class="d_string">"name"</span></code>, the right-hand side expression becomes <code class="d_inline">object.name.to!string</code>.</li>

<li>Each member is tested with <code class="d_inline">hasUDA</code> to determine whether it has the <code class="d_inline">Encrypted</code> attribute. The value of the member is encrypted if it has that attribute. (Because <code class="d_inline">hasUDA</code> requires <i>symbols</i> to work with, note how <code class="d_inline">__traits(getMember)</code> is used to get the member as a symbol (e.g. <code class="d_inline">Person.name</code>).)</li>

<li>The color attribute of each member is determined with <code class="d_inline">colorAttributeOf()</code>, which we will see below.</li>

</ol>

<p>The <code class="d_inline">colorAttributeOf()</code> function template can be implemented as in the following code:
</p>

<pre class="d_code">Color colorAttributeOf(T, string memberName)() {
    <span class="d_keyword">foreach</span> (attr; <span class="d_keyword">__traits</span>(getAttributes,
                            <span class="d_keyword">__traits</span>(getMember, T, memberName))) {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="hilite"><span class="d_keyword">typeof</span>(attr)</span> == Colored)) {
            <span class="d_keyword">return</span> attr.color;
        }
    }

    <span class="d_keyword">return</span> Color.black;
}
</pre>

<p>When the compile-time evaluations are completed, the <code class="d_inline">printAsXML()</code> function template would be instantiated for the <code class="d_inline">Person</code> type as the equivalent of the following function:
</p>

<pre class="d_code"><span class="d_comment">/* The equivalent of the printAsXML!Person instance. */</span>
<span class="d_keyword">void</span> printAsXML_Person(Person object) {
<span class="d_comment">// ...
</span>
    {
        string value = object.<span class="hilite">name</span>.to!string;
        <span class="hilite">value = value.encrypted.to!string;</span>
        writefln(<span class="d_string">`  &lt;%1&dollar;s color="%2&dollar;s"&gt;%3&dollar;s&lt;/%1&dollar;s&gt;`</span>,
                 <span class="d_string">"name"</span>, Color.blue, value);
    }
    {
        string value = object.<span class="hilite">lastName</span>.to!string;
        writefln(<span class="d_string">`  &lt;%1&dollar;s color="%2&dollar;s"&gt;%3&dollar;s&lt;/%1&dollar;s&gt;`</span>,
                 <span class="d_string">"lastName"</span>, Color.black, value);
    }
    {
        string value = object.<span class="hilite">address</span>.to!string;
        writefln(<span class="d_string">`  &lt;%1&dollar;s color="%2&dollar;s"&gt;%3&dollar;s&lt;/%1&dollar;s&gt;`</span>,
                 <span class="d_string">"address"</span>, Color.red, value);
    }
}
</pre>

<p>The complete program has more explanations:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.algorithm;
<span class="d_keyword">import</span> std.conv;
<span class="d_keyword">import</span> std.traits;

<span class="d_comment">/* Specifies that the symbol that it is assigned to should be
 * encrypted. */</span>
<span class="d_keyword">struct</span> Encrypted {
}

<span class="d_keyword">enum</span> Color { black, blue, red }

<span class="d_comment">/* Specifies the color of the symbol that it is assigned to.
 * The default color is Color.black. */</span>
<span class="d_keyword">struct</span> Colored {
    Color color;
}

<span class="d_keyword">struct</span> Person {
    <span class="d_comment">/* This member is specified to be encrypted and printed in
     * blue. */</span>
    @Encrypted @Colored(Color.blue) string name;

    <span class="d_comment">/* This member does not have any user defined
     * attributes. */</span>
    string lastName;

    <span class="d_comment">/* This member is specified to be printed in red. */</span>
    @Colored(Color.red) string address;
}

<span class="d_comment">/* Returns the value of the Colored attribute if the specified
 * member has that attribute, Color.black otherwise. */</span>
Color colorAttributeOf(T, string memberName)() {
    <span class="d_keyword">auto</span> result = Color.black;

    <span class="d_keyword">foreach</span> (attr;
             <span class="d_keyword">__traits</span>(getAttributes,
                      <span class="d_keyword">__traits</span>(getMember, T, memberName))) {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(attr) == Colored)) {
            result = attr.color;
        }
    }

    <span class="d_keyword">return</span> result;
}

<span class="d_comment">/* Returns the Caesar-encrypted version of the specified
 * string. (Warning: Caesar cipher is a very weak encryption
 * method.) */</span>
<span class="d_keyword">auto</span> encrypted(string value) {
    <span class="d_keyword">return</span> value.map!(a =&gt; <span class="d_keyword">dchar</span>(a + 1));
}

<span class="d_keyword">unittest</span> {
    <span class="d_keyword">assert</span>(<span class="d_string">"abcdefghij"</span>.encrypted.equal(<span class="d_string">"bcdefghijk"</span>));
}

<span class="d_comment">/* Prints the specified object in XML format according to the
 * attributes of its members. */</span>
<span class="d_keyword">void</span> printAsXML(T)(T object) {
    writefln(<span class="d_string">"&lt;%s&gt;"</span>, T.stringof);
    <span class="d_keyword">scope</span>(exit) writefln(<span class="d_string">"&lt;/%s&gt;"</span>, T.stringof);

    <span class="d_keyword">foreach</span> (member; <span class="d_keyword">__traits</span>(allMembers, T)) {
        string value =
            <span class="d_keyword">__traits</span>(getMember, object, member).to!string;

        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (hasUDA!(<span class="d_keyword">__traits</span>(getMember, T, member),
                           Encrypted)) {
            value = value.encrypted.to!string;
        }

        writefln(<span class="d_string">`  &lt;%1&dollar;s color="%2&dollar;s"&gt;%3&dollar;s&lt;/%1&dollar;s&gt;`</span>,
                 member, colorAttributeOf!(T, member), value);
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> people = [ Person(<span class="d_string">"Alice"</span>, <span class="d_string">"Davignon"</span>, <span class="d_string">"Avignon"</span>),
                    Person(<span class="d_string">"Ben"</span>, <span class="d_string">"de Bordeaux"</span>, <span class="d_string">"Bordeaux"</span>) ];

    <span class="d_keyword">foreach</span> (person; people) {
        printAsXML(person);
    }
}
</pre>

<p>The output of the program shows that the members have the correct color and that the <code class="d_inline">name</code> member is encrypted:
</p>

<pre class="shell">&lt;Person&gt;
  &lt;name color="blue"&gt;Bmjdf&lt;/name&gt;                <span class="shell_note">← blue and encrypted</span>
  &lt;lastName color="black"&gt;Davignon&lt;/lastName&gt;
  &lt;address color="red"&gt;Avignon&lt;/address&gt;         <span class="shell_note">← red</span>
&lt;/Person&gt;
&lt;Person&gt;
  &lt;name color="blue"&gt;Cfo&lt;/name&gt;                  <span class="shell_note">← blue and encrypted</span>
  &lt;lastName color="black"&gt;de Bordeaux&lt;/lastName&gt;
  &lt;address color="red"&gt;Bordeaux&lt;/address&gt;        <span class="shell_note">← red</span>
&lt;/Person&gt;
</pre>

<h5 class="subsection">The benefit of user defined attributes</h5>

<p>The benefit of user defined attributes is being able to change the attributes of declarations without needing to change any other part of the program. For example, all of the members of <code class="d_inline">Person</code> can become encrypted in the XML output by the trivial change below:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Person {
    <span class="hilite">@Encrypted</span> {
        string name;
        string lastName;
        string address;
    }
}

<span class="d_comment">// ...
</span>
    printAsXML(Person(<span class="d_string">"Cindy"</span>, <span class="d_string">"de Cannes"</span>, <span class="d_string">"Cannes"</span>));
</pre>

<p>The output:
</p>

<pre class="shell">&lt;Person&gt;
  &lt;name color="black"&gt;Djoez&lt;/name&gt;              <span class="shell_note">← encrypted</span>
  &lt;lastName color="black"&gt;ef!Dbooft&lt;/lastName&gt;  <span class="shell_note">← encrypted</span>
  &lt;address color="black"&gt;Dbooft&lt;/address&gt;       <span class="shell_note">← encrypted</span>
&lt;/Person&gt;
</pre>

<p>Further, <code class="d_inline">printAsXML()</code> and the attributes that it considers can be used with other types as well:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Data {
    <span class="hilite">@Colored(Color.blue)</span> string message;
}

<span class="d_comment">// ...
</span>
    printAsXML(Data(<span class="d_string">"hello world"</span>));
</pre>

<p>The output:
</p>

<pre class="shell">&lt;Data&gt;
  &lt;message color="blue"&gt;hello world&lt;/message&gt;    <span class="shell_note">← blue</span>
&lt;/Data&gt;
</pre>

<h5 class="subsection">Summary</h5>

<ul>
<li>User defined attributes can be assigned to any declaration.</li>

<li>User defined attributes can be type names as well as values.</li>

<li>User defined attributes can be accessed at compile time by <code class="d_inline">hasUDA</code> and <code class="d_inline">__traits(getAttributes)</code> to alter the way the program is compiled.</li>

</ul>

macros:
        TITLE=User Defined Attributes (UDA)

        DESCRIPTION=Assigning user defined attributes to declarations, determining the attributes at compile time, and compiling the code according to those attributes.

        KEYWORDS=d programming language tutorial book user defined attributes UDA

        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Sun Jun  2 09:00:31 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

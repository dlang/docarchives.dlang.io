
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Templates - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Templates' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='../bugstats.html'>Issues</a></li>
    <li><a href='../contributing.html'>Contributing</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BTemplates%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/templates.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Templates</h1>
        
        



<p>Templates are the feature that allows describing the code as a pattern, for the compiler to generate program code automatically. Parts of the source code may be left to the compiler to be filled in until that part is actually used in the program.
</p>

<p>Templates are very useful especially in libraries because they enable writing generic algorithms and data structures, instead of tying them to specific types.
</p>

<p>Compared to the template supports in other languages, D's templates are very powerful and extensive. I will not get into all of the details of templates in this chapter. I will cover only function, struct, and class templates and only <i>type</i> template parameters. We will see more about templates in <a href="templates_more.html">the More Templates chapter</a>. For a complete reference on D templates, see <a href="https://github.com/PhilippeSigaud/D-templates-tutorial">Philippe Sigaud's <i>D Templates: A Tutorial</i></a>.
</p>

<p>To see the benefits of templates let's start with a function that prints values in parentheses:
</p>

<pre class="d_code"><span class="d_keyword">void</span> printInParens(<span class="d_keyword">int</span> value) {
    writefln(<span class="d_string">"(%s)"</span>, value);
}
</pre>

<p>Because the parameter is specified as <code class="d_inline">int</code>, that function can only be used with values of type <code class="d_inline">int</code>, or values that can automatically be converted to <code class="d_inline">int</code>. For example, the compiler would not allow calling it with a floating point type.
</p>

<p>Let's assume that the requirements of a program changes and that other types need to be printed in parentheses as well. One of the solutions for this would be to take advantage of function overloading and provide overloads of the function for all of the types that the function is used with:
</p>

<pre class="d_code"><span class="d_comment">// The function that already exists
</span><span class="d_keyword">void</span> printInParens(<span class="d_keyword">int</span> value) {
    writefln(<span class="d_string">"(%s)"</span>, value);
}

<span class="d_comment">// Overloading the function for 'double'
</span><span class="d_keyword">void</span> printInParens(<span class="hilite"><span class="d_keyword">double</span></span> value) {
    writefln(<span class="d_string">"(%s)"</span>, value);
}
</pre>

<p>This solution does not scale well because this time the function cannot be used with e.g. <code class="d_inline">real</code> or any user-defined type. Although it is possible to overload the function for other types, the cost of doing this may be prohibitive.
</p>

<p>An important observation here is that regardless of the type of the parameter, the contents of the overloads would all be <i>generically</i> the same: a single <code class="d_inline">writefln()</code> expression.
</p>

<p>Such genericity is common in algorithms and data structures. For example, the binary search algorithm is independent of the type of the elements: It is about the specific steps and operations of the search. Similarly, the linked list data structure is independent of the type of the elements: Linked list is merely about <i>how</i> the elements are stored in the container, regardless of their type.
</p>

<p>Templates are useful in such situations: Once a piece of code is described as a template, the compiler generates overloads of the same code automatically according to the actual uses of that code in the program.
</p>

<p>As I have mentioned above, in this chapter I will cover only function, struct, and class templates, and <i>type</i> template parameters.
</p>

<h5 class="subsection"><a id="ix_Templates.function template" content="function template"></a> Function templates</h5>

<p><a id="ix_Templates.parameter, template" content="parameter, template"></a> Defining a function as a template is leaving one or more of the types that it uses as unspecified, to be deduced later by the compiler.
</p>

<p>The types that are being left unspecified are defined within the template parameter list, which comes between the name of the function and the function parameter list. For that reason, function templates have two parameter lists: the template parameter list and the function parameter list:
</p>

<pre class="d_code"><span class="d_keyword">void</span> printInParens<span class="hilite">(T)</span>(T value) {
    writefln(<span class="d_string">"(%s)"</span>, value);
}
</pre>

<p>The <code class="d_inline">T</code> within the template parameter list above means that <code class="d_inline">T</code> can be any type. Although <code class="d_inline">T</code> is an arbitrary name, it is an acronym for "type" and is very common in templates.
</p>

<p>Since <code class="d_inline">T</code> represents any type, the templated definition of <code class="d_inline">printInParens()</code> above is sufficient to use it with almost every type, including the user-defined ones:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> printInParens(T)(T value) {
    writefln(<span class="d_string">"(%s)"</span>, value);
}

<span class="d_keyword">void</span> main() {
    printInParens(42);           <span class="d_comment">// with int
</span>    printInParens(1.2);          <span class="d_comment">// with double
</span>
    <span class="d_keyword">auto</span> myValue = MyStruct();
    printInParens(myValue);      <span class="d_comment">// with MyStruct
</span>}

<span class="d_keyword">struct</span> MyStruct {
    string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> <span class="d_string">"hello"</span>;
    }
}
</pre>

<p>The compiler considers all of the uses of <code class="d_inline">printInParens()</code> in the program and generates code to support all those uses. The program is then compiled as if the function has been overloaded explicitly for <code class="d_inline">int</code>, <code class="d_inline">double</code>, and <code class="d_inline">MyStruct</code>:
</p>

<pre class="mono">/* Note: These functions are not part of the source
 *       code. They are the equivalents of the functions that
 *       the compiler would automatically generate. */

void printInParens(<span class="hilite">int</span> value) {
    writefln("(%s)", value);
}

void printInParens(<span class="hilite">double</span> value) {
    writefln("(%s)", value);
}

void printInParens(<span class="hilite">MyStruct</span> value) {
    writefln("(%s)", value);
}
</pre>

<p>The output of the program is produced by those different <i>instantiations</i> of the function template:
</p>

<pre class="shell">(42)
(1.2)
(hello)
</pre>

<p>Each template parameter can determine more than one function parameter. For example, both the two function parameters and the return type of the following function template are determined by its single template parameter:
</p>

<pre class="d_code"><span class="d_comment">/* Returns a copy of 'slice' except the elements that are
 * equal to 'value'. */</span>
<span class="hilite">T</span>[] removed(T)(<span class="d_keyword">const</span>(<span class="hilite">T</span>)[] slice, <span class="hilite">T</span> value) {
    T[] result;

    <span class="d_keyword">foreach</span> (element; slice) {
        <span class="d_keyword">if</span> (element != value) {
            result ~= element;
        }
    }

    <span class="d_keyword">return</span> result;
}
</pre>

<h5 class="subsection">More than one template parameter</h5>

<p>Let's change the function template to take the parentheses characters as well:
</p>

<pre class="d_code"><span class="d_keyword">void</span> printInParens(T)(T value, <span class="d_keyword">char</span> opening, <span class="d_keyword">char</span> closing) {
    writeln(opening, value, closing);
}
</pre>

<p>Now we can call the same function with different sets of parentheses:
</p>

<pre class="d_code">    printInParens(42, '&lt;', '&gt;');
</pre>

<p>Although being able to specify the parentheses makes the function more usable, specifying the type of the parentheses as <code class="d_inline">char</code> makes it less flexible because it is not possible to call the function with characters of type <code class="d_inline">wchar</code> or <code class="d_inline">dchar</code>:
</p>

<pre class="d_code">    printInParens(42, '→', '←');      <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<pre class="shell">Error: template deneme.printInParens(T) cannot deduce
template function from argument types !()(int,<span class="hilite">wchar</span>,<span class="hilite">wchar</span>)
</pre>

<p>One solution would be to specify the type of the parentheses as <code class="d_inline">dchar</code> but this would still be insufficient as this time the function could not be called e.g. with <code class="d_inline">string</code> or user-defined types.
</p>

<p><a id="ix_Templates., (comma), template parameter list" content=", (comma), template parameter list"></a> Another solution is to leave the type of the parentheses to the compiler as well. Defining an additional template parameter instead of the specific <code class="d_inline">char</code> is sufficient:
</p>

<pre class="d_code"><span class="d_keyword">void</span> printInParens(T<span class="hilite">, ParensType</span>)(T value,
                                  <span class="hilite">ParensType</span> opening,
                                  <span class="hilite">ParensType</span> closing) {
    writeln(opening, value, closing);
}
</pre>

<p>The meaning of the new template parameter is similar to <code class="d_inline">T</code>'s: <code class="d_inline">ParensType</code> can be any type.
</p>

<p>It is now possible to use many different types of parentheses. The following are with <code class="d_inline">wchar</code> and <code class="d_inline">string</code>:
</p>

<pre class="d_code">    printInParens(42, '→', '←');
    printInParens(1.2, <span class="d_string">"-="</span>, <span class="d_string">"=-"</span>);
</pre>

<pre class="shell">→42←
-=1.2=-
</pre>

<p>The flexibility of <code class="d_inline">printInParens()</code> has been increased, as it now works correctly for any combination of <code class="d_inline">T</code> and <code class="d_inline">ParensType</code> as long as those types are printable with <code class="d_inline">writeln()</code>.
</p>

<h5 class="subsection"><a id="ix_Templates.type deduction" content="type deduction"></a> <a id="ix_Templates.deduction, type" content="deduction, type"></a> Type deduction</h5>

<p>The compiler's deciding on what type to use for a template parameter is called <i>type deduction</i>.
</p>

<p>Continuing from the last example above, the compiler decides on the following types according to the two uses of the function template:
</p>

<ul><li><code class="d_inline">int</code> and <code class="d_inline">wchar</code> when 42 is printed</li>
<li><code class="d_inline">double</code> and <code class="d_inline">string</code> when 1.2 is printed</li>
</ul>

<p>The compiler can deduce types only from the types of the parameter values that are passed to function templates. Although the compiler can usually deduce the types without any ambiguity, there are times when the types must be specified explicitly by the programmer.
</p>

<h5 class="subsection">Explicit type specification</h5>

<p>Sometimes it is not possible for the compiler to deduce the template parameters. A situation that this can happen is when the types do not appear in the function parameter list. When template parameters are not related to function parameters, the compiler cannot deduce the template parameter types.
</p>

<p>To see an example of this, let's design a function that asks a question to the user, reads a value as a response, and returns that value. Additionally, let's make this a function template so that it can be used to read any type of response:
</p>

<pre class="d_code"><span class="hilite">T</span> getResponse<span class="hilite">(T)</span>(string question) {
    writef(<span class="d_string">"%s (%s): "</span>, question, T.stringof);

    <span class="hilite">T</span> response;
    readf(<span class="d_string">" %s"</span>, &amp;response);

    <span class="d_keyword">return</span> response;
}
</pre>

<p>That function template would be very useful in programs to read different types of values from the input. For example, to read some user information, we can imagine calling it as in the following line:
</p>

<pre class="d_code">    getResponse(<span class="d_string">"What is your age?"</span>);
</pre>

<p>Unfortunately, that call does not give the compiler any clue as to what the template parameter <code class="d_inline">T</code> should be. What is known is that the question is passed to the function as a <code class="d_inline">string</code>, but the type of the return value cannot be deduced:
</p>

<pre class="shell">Error: template deneme.getResponse(T) <span class="hilite">cannot deduce</span> template
function from argument types !()(string)
</pre>

<p><a id="ix_Templates.!, template instance" content="!, template instance"></a> In such cases, the template parameters must be specified explicitly by the programmer. Template parameters are specified in parentheses after an exclamation mark:
</p>

<pre class="d_code">    getResponse<span class="hilite">!(<span class="d_keyword">int</span>)</span>(<span class="d_string">"What is your age?"</span>);
</pre>

<p>The code above can now be accepted by the compiler and the function template is compiled as <code class="d_inline">T</code> being an alias of <code class="d_inline">int</code> within the definition of the template.
</p>

<p>When there is only one template parameter specified, the parentheses around it are optional:
</p>

<pre class="d_code">    getResponse<span class="hilite">!<span class="d_keyword">int</span></span>(<span class="d_string">"What is your age?"</span>);    <span class="d_comment">// same as above
</span></pre>

<p>You may recognize that syntax from <code class="d_inline">to!string</code>, which we have been using in earlier programs. <code class="d_inline">to()</code> is a function template, which takes the target type of the conversion as a template parameter. Since it has only one template parameter that needs to be specified, it is commonly written as <code class="d_inline">to!string</code> instead of <code class="d_inline">to!(string)</code>.
</p>

<h5 class="subsection"><a id="ix_Templates.instantiation, template" content="instantiation, template"></a> Template instantiation</h5>

<p>Automatic generation of code for a specific set of template parameter values is called an <i>instantiation</i> of that template for that specific set of parameter values. For example, <code class="d_inline">to!string</code> and <code class="d_inline">to!int</code> are two different instantiations of the <code class="d_inline">to</code> function template.
</p>

<p>As I will mention again in a separate section below, distinct instantiations of templates produce distinct and incompatible types.
</p>

<h5 class="subsection"><a id="ix_Templates.specialization, template" content="specialization, template"></a> Template specializations</h5>

<p>Although the <code class="d_inline">getResponse()</code> function template can in theory be used for any template type, the code that the compiler generates may not be suitable for every type. Let's assume that we have the following type that represents points on a two dimensional space:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point {
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">int</span> y;
}
</pre>

<p>Although the instantiation of <code class="d_inline">getResponse()</code> for the <code class="d_inline">Point</code> type itself would be fine, the generated <code class="d_inline">readf()</code> call for <code class="d_inline">Point</code> cannot be compiled. This is because the standard library function <code class="d_inline">readf()</code> does not know how to read a <code class="d_inline">Point</code> object. The two lines that actually read the response would look like the following in the <code class="d_inline">Point</code> instantiation of the <code class="d_inline">getResponse()</code> function template:
</p>

<pre class="d_code">    Point response;
    readf(<span class="d_string">" %s"</span>, &amp;response);    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>One way of reading a <code class="d_inline">Point</code> object would be to read the values of the <code class="d_inline">x</code> and <code class="d_inline">y</code> members separately and then to <i>construct</i> a <code class="d_inline">Point</code> object from those values.
</p>

<p>Providing a special definition of a template for a specific template parameter value is called a <i>template specialization</i>. The specialization is defined by the type name after a <code class="d_inline">:</code> character in the template parameter list. A <code class="d_inline">Point</code> specialization of the <code class="d_inline">getResponse()</code> function template can be defined as in the following code:
</p>

<pre class="d_code"><span class="d_comment">// The general definition of the function template (same as before)
</span>T getResponse(T)(string question) {
    writef(<span class="d_string">"%s (%s): "</span>, question, T.stringof);

    T response;
    readf(<span class="d_string">" %s"</span>, &amp;response);

    <span class="d_keyword">return</span> response;
}

<span class="d_comment">// The specialization of the function template for Point
</span>T getResponse(T <span class="hilite">: Point</span>)(string question) {
    writefln(<span class="d_string">"%s (Point)"</span>, question);

    <span class="d_keyword">auto</span> x = getResponse!<span class="d_keyword">int</span>(<span class="d_string">"  x"</span>);
    <span class="d_keyword">auto</span> y = getResponse!<span class="d_keyword">int</span>(<span class="d_string">"  y"</span>);

    <span class="d_keyword">return</span> Point(x, y);
}
</pre>

<p>Note that the specialization takes advantage of the general definition of <code class="d_inline">getResponse()</code> to read two <code class="d_inline">int</code> values to be used as the values of the <code class="d_inline">x</code> and <code class="d_inline">y</code> members.
</p>

<p>Instead of instantiating the template itself, now the compiler uses the specialization above whenever <code class="d_inline">getResponse()</code> is called for the <code class="d_inline">Point</code> type:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> center = getResponse!Point(<span class="d_string">"Where is the center?"</span>);
</pre>

<p>Assuming that the user enters 11 and 22:
</p>

<pre class="shell">Where is the center? (Point)
  x (int): 11
  y (int): 22
</pre>

<p>The <code class="d_inline">getResponse!int()</code> calls are directed to the general definition of the template and the <code class="d_inline">getResponse!Point()</code> calls are directed to the <code class="d_inline">Point</code> specialization of it.
</p>

<p>As another example, let's consider using the same template with <code class="d_inline">string</code>. As you would remember from the <a href="strings.html">Strings chapter</a>, <code class="d_inline">readf()</code> would read all of the characters from the input as part of a single <code class="d_inline">string</code> until the end of the input. For that reason, the default definition of <code class="d_inline">getResponse()</code> would not be useful when reading <code class="d_inline">string</code> responses:
</p>

<pre class="d_code">    <span class="d_comment">// Reads the entire input, not only the name!
</span>    <span class="d_keyword">auto</span> name = getResponse!string(<span class="d_string">"What is your name?"</span>);
</pre>

<p>We can provide a template specialization for <code class="d_inline">string</code> as well. The following specialization reads just the <i>line</i> instead:
</p>

<pre class="d_code">T getResponse(T <span class="hilite">: string</span>)(string question) {
    writef(<span class="d_string">"%s (string): "</span>, question);

    <span class="d_comment">// Read and ignore whitespace characters which have
</span>    <span class="d_comment">// presumably been left over from the previous user input
</span>    string response;
    <span class="d_keyword">do</span> {
        response = strip(readln());
    } <span class="d_keyword">while</span> (response.length == 0);

    <span class="d_keyword">return</span> response;
}
</pre>

<h5 class="subsection"><a id="ix_Templates.struct template" content="struct template"></a> <a id="ix_Templates.class template" content="class template"></a> Struct and class templates</h5>

<p>The <code class="d_inline">Point</code> struct may be seen as having a limitation: Because its two members are defined specifically as <code class="d_inline">int</code>, it cannot represent fractional coordinate values. This limitation can be removed if the <code class="d_inline">Point</code> struct is defined as a template.
</p>

<p>Let's first add a member function that returns the distance to another <code class="d_inline">Point</code> object:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.math;

<span class="d_comment">// ...
</span>
<span class="d_keyword">struct</span> Point {
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">int</span> y;

    <span class="d_keyword">int</span> distanceTo(Point that) <span class="d_keyword">const</span> {
        <span class="d_keyword">immutable</span> <span class="d_keyword">real</span> xDistance = x - that.x;
        <span class="d_keyword">immutable</span> <span class="d_keyword">real</span> yDistance = y - that.y;

        <span class="d_keyword">immutable</span> distance = sqrt((xDistance * xDistance) +
                                  (yDistance * yDistance));

        <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>)distance;
    }
}
</pre>

<p>That definition of <code class="d_inline">Point</code> is suitable when the required precision is relatively low: It can calculate the distance between two points at kilometer precision, e.g. between the center and branch offices of an organization:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> center = getResponse!Point(<span class="d_string">"Where is the center?"</span>);
    <span class="d_keyword">auto</span> branch = getResponse!Point(<span class="d_string">"Where is the branch?"</span>);

    writeln(<span class="d_string">"Distance: "</span>, center.distanceTo(branch));
</pre>

<p>Unfortunately, <code class="d_inline">Point</code> is inadequate at higher precisions than <code class="d_inline">int</code> can provide.
</p>

<p>Structs and classes can be defined as templates as well, by specifying a template parameter list after their names. For example, <code class="d_inline">Point</code> can be defined as a struct template by providing a template parameter and replacing the <code class="d_inline">int</code>s by that parameter:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point<span class="hilite">(T)</span> {
    <span class="hilite">T</span> x;
    <span class="hilite">T</span> y;

    <span class="hilite">T</span> distanceTo(Point that) <span class="d_keyword">const</span> {
        <span class="d_keyword">immutable</span> <span class="d_keyword">real</span> xDistance = x - that.x;
        <span class="d_keyword">immutable</span> <span class="d_keyword">real</span> yDistance = y - that.y;

        <span class="d_keyword">immutable</span> distance = sqrt((xDistance * xDistance) +
                                  (yDistance * yDistance));

        <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(<span class="hilite">T</span>)distance;
    }
}
</pre>

<p>Since structs and classes are not functions, they cannot be called with parameters. This makes it impossible for the compiler to deduce their template parameters. The template parameter list must always be specified for struct and class templates:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> center = Point<span class="hilite">!<span class="d_keyword">int</span></span>(0, 0);
    <span class="d_keyword">auto</span> branch = Point<span class="hilite">!<span class="d_keyword">int</span></span>(100, 100);

    writeln(<span class="d_string">"Distance: "</span>, center.distanceTo(branch));
</pre>

<p>The definitions above make the compiler generate code for the <code class="d_inline">int</code> instantiation of the <code class="d_inline">Point</code> template, which is the equivalent of its earlier non-template definition. However, now it can be used with any type. For example, when more precision is needed, with <code class="d_inline">double</code>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> point1 = Point<span class="hilite">!<span class="d_keyword">double</span></span>(1.2, 3.4);
    <span class="d_keyword">auto</span> point2 = Point<span class="hilite">!<span class="d_keyword">double</span></span>(5.6, 7.8);

    writeln(point1.distanceTo(point2));
</pre>

<p>Although the template itself has been defined independently of any specific type, its single definition makes it possible to represent points of various precisions.
</p>

<p>Simply converting <code class="d_inline">Point</code> to a template would cause compilation errors in code that has already been written according to its non-template definition. For example, now the <code class="d_inline">Point</code> specialization of <code class="d_inline">getResponse()</code> cannot be compiled:
</p>

<pre class="d_code">T getResponse(T : Point)(string question) {  <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    writefln(<span class="d_string">"%s (Point)"</span>, question);

    <span class="d_keyword">auto</span> x = getResponse!<span class="d_keyword">int</span>(<span class="d_string">"  x"</span>);
    <span class="d_keyword">auto</span> y = getResponse!<span class="d_keyword">int</span>(<span class="d_string">"  y"</span>);

    <span class="d_keyword">return</span> Point(x, y);
}
</pre>

<p>The reason for the compilation error is that <code class="d_inline">Point</code> itself is not a type anymore: <code class="d_inline">Point</code> is now a <i>struct template</i>. Only instantiations of that template would be considered as types. The following changes are required to correctly specialize <code class="d_inline">getResponse()</code> for any instantiation of <code class="d_inline">Point</code>:
</p>

<pre class="d_code">Point!T getResponse(T : Point!T)(string question) {  <span class="d_comment">// 2, 1
</span>    writefln(<span class="d_string">"%s (Point!%s)"</span>, question, T.stringof); <span class="d_comment">// 5
</span>
    <span class="d_keyword">auto</span> x = getResponse!T(<span class="d_string">"  x"</span>);                   <span class="d_comment">// 3a
</span>    <span class="d_keyword">auto</span> y = getResponse!T(<span class="d_string">"  y"</span>);                   <span class="d_comment">// 3b
</span>
    <span class="d_keyword">return</span> Point!T(x, y);                            <span class="d_comment">// 4
</span>}
</pre>

<ol>
<li>In order for this template specialization to support all instantiations of <code class="d_inline">Point</code>, the template parameter list must mention <code class="d_inline">Point!T</code>. This simply means that the <code class="d_inline">getResponse()</code> specialization is for <code class="d_inline">Point!T</code>, regardless of <code class="d_inline">T</code>. This specialization would match <code class="d_inline">Point!int</code>, <code class="d_inline">Point!double</code>, etc.
</li>

<li>Similarly, to return the correct type as the response, the return type must be specified as <code class="d_inline">Point!T</code> as well.
</li>

<li>Since the types of <code class="d_inline">x</code> and <code class="d_inline">y</code> members of <code class="d_inline">Point!T</code> are now <code class="d_inline">T</code>, as opposed to <code class="d_inline">int</code>, the members must be read by calling <code class="d_inline">getResponse!T()</code>, not <code class="d_inline">getResponse!int()</code>, as the latter would be correct only for <code class="d_inline">Point!int</code>.
</li>

<li>Similar to items 1 and 2, the type of the return value is <code class="d_inline">Point!T</code>.
</li>

<li>To print the name of the type accurately for every type, as in <code class="d_inline">Point!int</code>, <code class="d_inline">Point!double</code>, etc., <code class="d_inline">T.stringof</code> is used.
</li>

</ol>

<h5 class="subsection"><a id="ix_Templates.default template parameter" content="default template parameter"></a> Default template parameters</h5>

<p>Sometimes it is cumbersome to provide template parameter types every time a template is used, especially when that type is almost always a particular type. For example, <code class="d_inline">getResponse()</code> may almost always be called for the <code class="d_inline">int</code> type in the program, and only in a few places for the <code class="d_inline">double</code> type.
</p>

<p>It is possible to specify default types for template parameters, which are assumed when the types are not explicitly provided. Default parameter types are specified after the <code class="d_inline">=</code> character:
</p>

<pre class="d_code">T getResponse(T <span class="hilite">= <span class="d_keyword">int</span></span>)(string question) {
    <span class="d_comment">// ...
</span>}

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> age = getResponse(<span class="d_string">"What is your age?"</span>);
</pre>

<p>As no type has been specified when calling <code class="d_inline">getResponse()</code> above, <code class="d_inline">T</code> becomes the default type <code class="d_inline">int</code> and the call ends up being the equivalent of <code class="d_inline">getResponse!int()</code>.
</p>

<p>Default template parameters can be specified for struct and class templates as well, but in their case the template parameter list must always be written even when empty:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point(T = <span class="d_keyword">int</span>) {
    <span class="d_comment">// ...
</span>}

<span class="d_comment">// ...
</span>
    Point!<span class="hilite">()</span> center;
</pre>


<p>Similar to default function parameter values as we have seen in the <a href="parameter_flexibility.html">Variable Number of Parameters chapter</a>, default template parameters can be specified for all of the template parameters or for the <i>last</i> ones:
</p>

<pre class="d_code"><span class="d_keyword">void</span> myTemplate(T0, T1 <span class="hilite">= <span class="d_keyword">int</span></span>, T2 <span class="hilite">= <span class="d_keyword">char</span></span>)() {
    <span class="d_comment">// ...
</span>}
</pre>

<p>The last two template parameters of that function may be left unspecified but the first one is required:
</p>

<pre class="d_code">    myTemplate!string();
</pre>

<p>In that usage, the second and third parameters are <code class="d_inline">int</code> and <code class="d_inline">char</code>, respectively.
</p>

<h5 class="subsection">Every template instantiation yields a distinct type</h5>

<p>Every instantiation of a template for a given set of types is considered to be a distinct type. For example, <code class="d_inline">Point!int</code> and <code class="d_inline">Point!double</code> are separate types:
</p>

<pre class="d_code">Point!<span class="d_keyword">int</span> point3 = Point!<span class="d_keyword">double</span>(0.25, 0.75); <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>Those different types cannot be used in the assignment operation above:
</p>

<pre class="shell">Error: cannot implicitly convert expression (Point(0.25,0.75))
of type <span class="hilite">Point!(double)</span> to <span class="hilite">Point!(int)</span>
</pre>

<h5 class="subsection">A compile-time feature</h5>

<p>Templates are entirely a compile-time feature. The instances of templates are generated by the compiler at compile time.
</p>

<h5 class="subsection">Class template example: stack data structure</h5>

<p>Struct and class templates are commonly used in the implementations of data structures. Let's design a stack container that will be able to contain any type.
</p>

<p>Stack is one of the simplest data structures. It represents a container where elements are placed conceptually on top of each other as would be in a stack of papers. New elements go on top, and only the topmost element is accessed. When an element is removed, it is always the topmost one.
</p>

<p>If we also define a property that returns the total number of elements in the stack, all of the operations of this data structure would be the following:
</p>

<ul><li>Add element (<code class="d_inline">push()</code>)</li>
<li>Remove element (<code class="d_inline">pop()</code>)</li>
<li>Access the topmost element (<code class="d_inline">.top</code>)</li>
<li>Report the number of elements (<code class="d_inline">.length</code>)</li>
</ul>

<p>An array can be used to store the elements such that the last element of the array would be representing the topmost element of the stack. Finally, it can be defined as a class template to be able to contain elements of any type:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Stack<span class="hilite">(T)</span> {
<span class="d_keyword">private</span>:

    <span class="hilite">T</span>[] elements;

<span class="d_keyword">public</span>:

    <span class="d_keyword">void</span> push(<span class="hilite">T</span> element) {
        elements ~= element;
    }

    <span class="d_keyword">void</span> pop() {
        --elements.length;
    }

    <span class="hilite">T</span> top() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> elements[$ - 1];
    }

    size_t length() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> elements.length;
    }
}
</pre>

<p>Here is a <code class="d_inline">unittest</code> block for this class that uses its <code class="d_inline">int</code> instantiation:
</p>

<pre class="d_code"><span class="d_keyword">unittest</span> {
    <span class="d_keyword">auto</span> stack = <span class="d_keyword">new</span> Stack<span class="hilite">!<span class="d_keyword">int</span></span>;

    <span class="d_comment">// The newly added element must appear on top
</span>    stack.push(42);
    <span class="d_keyword">assert</span>(stack.top == 42);
    <span class="d_keyword">assert</span>(stack.length == 1);

    <span class="d_comment">// .top and .length should not affect the elements
</span>    <span class="d_keyword">assert</span>(stack.top == 42);
    <span class="d_keyword">assert</span>(stack.length == 1);

    <span class="d_comment">// The newly added element must appear on top
</span>    stack.push(100);
    <span class="d_keyword">assert</span>(stack.top == 100);
    <span class="d_keyword">assert</span>(stack.length == 2);

    <span class="d_comment">// Removing the last element must expose the previous one
</span>    stack.pop();
    <span class="d_keyword">assert</span>(stack.top == 42);
    <span class="d_keyword">assert</span>(stack.length == 1);

    <span class="d_comment">// The stack must become empty when the last element is
</span>    <span class="d_comment">// removed
</span>    stack.pop();
    <span class="d_keyword">assert</span>(stack.length == 0);
}
</pre>

<p>To take advantage of this class template, let's try using it this time with a user-defined type. As an example, here is a modified version of <code class="d_inline">Point</code>:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point(T) {
    T x;
    T y;

    string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"(%s,%s)"</span>, x, y);
    }
}
</pre>

<p>A <code class="d_inline">Stack</code> that contains elements of type <code class="d_inline">Point!double</code> can be defined as follows:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> points = <span class="d_keyword">new</span> Stack!(Point!<span class="d_keyword">double</span>);
</pre>

<p>Here is a test program that first adds ten elements to this stack and then removes them one by one:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.random;

<span class="d_keyword">struct</span> Point(T) {
    T x;
    T y;

    string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"(%s,%s)"</span>, x, y);
    }
}

<span class="d_comment">// Returns a random value between -0.50 and 0.50.
</span><span class="d_keyword">double</span> random_double()
<span class="d_keyword">out</span> (result) {
    <span class="d_keyword">assert</span>((result &gt;= -0.50) &amp;&amp; (result &lt; 0.50));

} <span class="d_keyword">do</span> {
    <span class="d_keyword">return</span> (<span class="d_keyword">double</span>(uniform(0, 100)) - 50) / 100;
}

<span class="d_comment">// Returns a Stack that contains 'count' number of random
</span><span class="d_comment">// Point!double elements.
</span>Stack!(Point!<span class="d_keyword">double</span>) randomPoints(size_t count)
<span class="d_keyword">out</span> (result) {
    <span class="d_keyword">assert</span>(result.length == count);

} <span class="d_keyword">do</span> {
    <span class="d_keyword">auto</span> points = <span class="d_keyword">new</span> Stack!(Point!<span class="d_keyword">double</span>);

    <span class="d_keyword">foreach</span> (i; 0 .. count) {
        <span class="d_keyword">immutable</span> point = Point!<span class="d_keyword">double</span>(random_double(),
                                       random_double());
        writeln(<span class="d_string">"adding  : "</span>, point);
        points.push(point);
    }

    <span class="d_keyword">return</span> points;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> stackedPoints = randomPoints(10);

    <span class="d_keyword">while</span> (stackedPoints.length) {
        writeln(<span class="d_string">"removing: "</span>, stackedPoints.top);
        stackedPoints.pop();
    }
}
</pre>

<p>As the output of the program shows, the elements are removed in the reverse order as they have been added:
</p>

<pre class="shell">adding  : (-0.02,-0.01)
adding  : (0.17,-0.5)
adding  : (0.12,0.23)
adding  : (-0.05,-0.47)
adding  : (-0.19,-0.11)
adding  : (0.42,-0.32)
adding  : (0.48,-0.49)
adding  : (0.35,0.38)
adding  : (-0.2,-0.32)
adding  : (0.34,0.27)
removing: (0.34,0.27)
removing: (-0.2,-0.32)
removing: (0.35,0.38)
removing: (0.48,-0.49)
removing: (0.42,-0.32)
removing: (-0.19,-0.11)
removing: (-0.05,-0.47)
removing: (0.12,0.23)
removing: (0.17,-0.5)
removing: (-0.02,-0.01)
</pre>

<h5 class="subsection">Function template example: binary search algorithm</h5>

<p>Binary search is the fastest algorithm to search for an element among the elements of an already sorted array. It is a very simple algorithm: The element in the middle is considered; if that element is the one that has been sought, then the search is over. If not, then the algorithm is repeated on the elements that are either on the left-hand side or on the right-hand side of the middle element, depending on whether the sought element is greater or less than the middle element.
</p>

<p>Algorithms that repeat themselves on a smaller range of the initial elements are recursive. Let's write the binary search algorithm recursively by calling itself.
</p>

<p>Before converting it to a template, let's first write this function to support only arrays of <code class="d_inline">int</code>. We can easily convert it to a template later, by adding a template parameter list and replacing appropriate <code class="d_inline">int</code>s in its definition by <code class="d_inline">T</code>s. Here is a binary search algorithm that works on arrays of <code class="d_inline">int</code>:
</p>

<pre class="d_code"><span class="d_comment">/* This function returns the index of the value if it exists
 * in the array, size_t.max otherwise. */</span>
size_t binarySearch(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[] values, <span class="d_keyword">int</span> value) {
    <span class="d_comment">// The value is not in the array if the array is empty.
</span>    <span class="d_keyword">if</span> (values.length == 0) {
        <span class="d_keyword">return</span> size_t.max;
    }

    <span class="d_keyword">immutable</span> midPoint = values.length / 2;

    <span class="d_keyword">if</span> (value == values[midPoint]) {
        <span class="d_comment">// Found.
</span>        <span class="d_keyword">return</span> midPoint;

    } <span class="d_keyword">else</span> <span class="d_keyword">if</span> (value &lt; values[midPoint]) {
        <span class="d_comment">// The value can only be in the left-hand side; let's
</span>        <span class="d_comment">// search in a slice that represents that half.
</span>        <span class="d_keyword">return</span> binarySearch(values[0 .. midPoint], value);

    } <span class="d_keyword">else</span> {
        <span class="d_comment">// The value can only be in the right-hand side; let's
</span>        <span class="d_comment">// search in the right-hand side.
</span>        <span class="d_keyword">auto</span> index =
            binarySearch(values[midPoint + 1 .. $], value);

        <span class="d_keyword">if</span> (index != size_t.max) {
            <span class="d_comment">// Adjust the index; it is 0-based in the
</span>            <span class="d_comment">// right-hand side slice.
</span>            index += midPoint + 1;
        }

        <span class="d_keyword">return</span> index;
    }

    <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>, <span class="d_string">"We should have never gotten to this line"</span>);
}
</pre>

<p>The function above implements this simple algorithm in four steps:
</p>

<ul><li>If the array is empty, return <code class="d_inline">size_t.max</code> to indicate that the value has not been found.</li>
<li>If the element at the mid-point is equal to the sought value, then return the index of that element.</li>
<li>If the value is less than the element at the mid-point, then repeat the same algorithm on the left-hand side.</li>
<li>Else, repeat the same algorithm on the right-hand side.</li>
</ul>

<p>Here is a unittest block that tests the function:
</p>

<pre class="d_code"><span class="d_keyword">unittest</span> {
    <span class="d_keyword">auto</span> array = [ 1, 2, 3, 5 ];
    <span class="d_keyword">assert</span>(binarySearch(array, 0) == size_t.max);
    <span class="d_keyword">assert</span>(binarySearch(array, 1) == 0);
    <span class="d_keyword">assert</span>(binarySearch(array, 4) == size_t.max);
    <span class="d_keyword">assert</span>(binarySearch(array, 5) == 3);
    <span class="d_keyword">assert</span>(binarySearch(array, 6) == size_t.max);
}
</pre>

<p>Now that the function has been implemented and tested for <code class="d_inline">int</code>, we can convert it to a template. <code class="d_inline">int</code> appears only in two places in the definition of the template:
</p>

<pre class="d_code">size_t binarySearch(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[] values, <span class="d_keyword">int</span> value) {
    <span class="d_comment">// ... int does not appear here ...
</span>}
</pre>

<p>The <code class="d_inline">int</code>s that appear in the parameter list are the types of the elements and the value. Specifying those as template parameters is sufficient to make this algorithm a template and to be usable with other types as well:
</p>

<pre class="d_code">size_t binarySearch<span class="hilite">(T)</span>(<span class="d_keyword">const</span> <span class="hilite">T</span>[] values, <span class="hilite">T</span> value) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>That function template can be used with any type that matches the operations that are applied to that type in the template. In <code class="d_inline">binarySearch()</code>, the elements are used only with comparison operators <code class="d_inline">==</code> and <code class="d_inline">&lt;</code>:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (value <span class="hilite">==</span> values[midPoint]) {
        <span class="d_comment">// ...
</span>
    } <span class="d_keyword">else</span> <span class="d_keyword">if</span> (value <span class="hilite">&lt;</span> values[midPoint]) {

        <span class="d_comment">// ...
</span></pre>

<p>For that reason, <code class="d_inline">Point</code> is not ready to be used with <code class="d_inline">binarySearch()</code> yet:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.string;

<span class="d_keyword">struct</span> Point(T) {
    T x;
    T y;

    string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"(%s,%s)"</span>, x, y);
    }
}

<span class="d_keyword">void</span> main() {
    Point!<span class="d_keyword">int</span>[] points;

    <span class="d_keyword">foreach</span> (i; 0 .. 15) {
        points ~= Point!<span class="d_keyword">int</span>(i, i);
    }

    <span class="d_keyword">assert</span>(binarySearch(points, Point!<span class="d_keyword">int</span>(10, 10)) == 10);
}
</pre>

<p>The program above would cause a compilation error:
</p>

<pre class="shell">Error: need member function <span class="hilite">opCmp()</span> for struct
const(Point!(int)) to compare
</pre>

<p>According to the error message, <code class="d_inline">opCmp()</code> needs to be defined for <code class="d_inline">Point</code>. <code class="d_inline">opCmp()</code> has been covered in <a href="operator_overloading.html">the Operator Overloading chapter</a>:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point(T) {
<span class="d_comment">// ...
</span>
    <span class="d_keyword">int</span> opCmp(<span class="d_keyword">const</span> <span class="d_keyword">ref</span> Point that) <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> (x == that.x
                ? y - that.y
                : x - that.x);
    }
}
</pre>

<h5 class="subsection">Summary</h5>

<p>We will see other features of templates in <a href="templates_more.html">a later chapter</a>. The following are what we have covered in this chapter:
</p>

<ul>
<li>Templates define the code as a pattern, for the compiler to generate instances of it according to the actual uses in the program.</li>

<li>Templates are a compile-time feature.</li>

<li>Specifying template parameter lists is sufficient to make function, struct, and class definitions templates.

<pre class="d_code"><span class="d_keyword">void</span> functionTemplate<span class="hilite">(T)</span>(T functionParameter) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> ClassTemplate<span class="hilite">(T)</span> {
    <span class="d_comment">// ...
</span>}
</pre>

</li>

<li>Template arguments can be specified explicitly after an exclamation mark. The parentheses are not necessary when there is only one token inside the parentheses.

<pre class="d_code">    <span class="d_keyword">auto</span> object1 = <span class="d_keyword">new</span> ClassTemplate!(<span class="d_keyword">double</span>);
    <span class="d_keyword">auto</span> object2 = <span class="d_keyword">new</span> ClassTemplate!<span class="d_keyword">double</span>;    <span class="d_comment">// same thing
</span></pre>

</li>

<li>Every template instantiation yields a distinct type.

<pre class="d_code">    <span class="d_keyword">assert</span>(<span class="d_keyword">typeid</span>(ClassTemplate!<span class="hilite"><span class="d_keyword">int</span></span>) !=
           <span class="d_keyword">typeid</span>(ClassTemplate!<span class="hilite"><span class="d_keyword">uint</span></span>));
</pre>

</li>

<li>Template arguments can only be deduced for function templates.

<pre class="d_code">    functionTemplate(42);  <span class="d_comment">// functionTemplate!int is deduced
</span></pre>

</li>

<li>Templates can be specialized for the type that is after the <code class="d_inline">:</code> character.

<pre class="d_code"><span class="d_keyword">class</span> ClassTemplate(T <span class="hilite">: <span class="d_keyword">dchar</span></span>) {
    <span class="d_comment">// ...
</span>}
</pre>

</li>

<li>Default template arguments are specified after the <code class="d_inline">=</code> character.

<pre class="d_code"><span class="d_keyword">void</span> functionTemplate(T <span class="hilite">= <span class="d_keyword">long</span></span>)(T functionParameter) {
    <span class="d_comment">// ...
</span>}
</pre>

</li>

</ul>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Sun Jun  2 09:00:32 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

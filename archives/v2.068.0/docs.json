[
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/object.d",
		"name": "object",
		"members": [
			{
				"name": "Object",
				"line": 55,
				"comment": " All D class objects inherit from Object.\n",
				"members": [
					{
						"endchar": 5,
						"name": "toString",
						"line": 60,
						"comment": " Convert Object to a human readable string.\n",
						"deco": "FZAya",
						"endline": 63,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 68,
						"comment": " Compute hash function for Object.\n",
						"deco": "FNbNeZm",
						"endline": 72,
						"originalType": "nothrow @trusted size_t()",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 83,
						"comment": " Compare with another Object obj.\n Returns:\n  $(TABLE\n  $(TR $(TD this &lt; obj) $(TD &lt; 0))\n  $(TR $(TD this == obj) $(TD 0))\n  $(TR $(TD this &gt; obj) $(TD &gt; 0))\n  )\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 90,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 95,
						"comment": " Returns !=0 if this object does have the same contents as obj.\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 98,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "factory",
						"line": 130,
						"comment": " Create instance of class specified by the fully qualified name\n classname.\n The class must either have no constructors or have\n a default constructor.\n Returns:\n   null if failed\n Example:\n ---\n module foo.bar;\n\n class C\n {\n     this() { x = 10; }\n     int x;\n }\n\n void main()\n {\n     auto c = cast(C)Object.factory(\"foo.bar.C\");\n     assert(c !is null && c.x == 10);\n }\n ---\n",
						"deco": "FAyaZC6Object",
						"parameters": [
							{
								"name": "classname",
								"deco": "Aya"
							}
						],
						"endline": 138,
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "opEquals",
				"line": 166,
				"comment": " Returns true if lhs and rhs are equal.\n",
				"deco": "FxC6ObjectxC6ObjectZb",
				"parameters": [
					{
						"name": "lhs",
						"deco": "xC6Object"
					},
					{
						"name": "rhs",
						"deco": "xC6Object"
					}
				],
				"endline": 170,
				"originalType": "(const Object lhs, const Object rhs)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"name": "Interface",
				"line": 184,
				"comment": " Information about an interface.\n When an object is accessed via an interface, an Interface* appears as the\n first entry in its vtbl.\n",
				"members": [
					{
						"offset": 0,
						"name": "classinfo",
						"line": 186,
						"comment": ".classinfo for this interface (not for containing class)\n",
						"deco": "C14TypeInfo_Class",
						"originalType": "TypeInfo_Class",
						"char": 22,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "offset",
						"line": 188,
						"comment": "offset to Interface 'this' from Object 'this'\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 17,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "OffsetTypeInfo",
				"line": 195,
				"comment": " Array of pairs giving the offset and type information for each\n member in an aggregate.\n",
				"members": [
					{
						"offset": 0,
						"name": "offset",
						"line": 197,
						"comment": "Offset of member from start of object\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 14,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "ti",
						"line": 198,
						"comment": "TypeInfo for this member\n",
						"deco": "C8TypeInfo",
						"originalType": "TypeInfo",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "TypeInfo",
				"line": 206,
				"comment": " Runtime type information about a type.\n Can be retrieved for any type using a\n <a href=\"../expression.html#typeidexpression\">TypeidExpression</a>.\n",
				"members": [
					{
						"endchar": 79,
						"name": "getHash",
						"line": 259,
						"comment": "Returns a hash of the instance of a type.\n",
						"deco": "xFNbNexPvZm",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 259,
						"originalType": "const nothrow @trusted size_t(in void* p)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 68,
						"name": "equals",
						"line": 262,
						"comment": "Compares two instances for equality.\n",
						"deco": "xFxPvxPvZb",
						"parameters": [
							{
								"name": "p1",
								"deco": "xPv"
							},
							{
								"name": "p2",
								"deco": "xPv"
							}
						],
						"endline": 262,
						"originalType": "const bool(in void* p1, in void* p2)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 75,
						"name": "compare",
						"line": 265,
						"comment": "Compares two instances for &lt;, ==, or &gt;.\n",
						"deco": "xFxPvxPvZi",
						"parameters": [
							{
								"name": "p1",
								"deco": "xPv"
							},
							{
								"name": "p2",
								"deco": "xPv"
							}
						],
						"endline": 265,
						"originalType": "const int(in void* p1, in void* p2)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 73,
						"name": "tsize",
						"line": 268,
						"comment": "Returns size of the type.\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 268,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "swap",
						"line": 271,
						"comment": "Swaps two instances of the type.\n",
						"deco": "xFPvPvZv",
						"parameters": [
							{
								"name": "p1",
								"deco": "Pv"
							},
							{
								"name": "p2",
								"deco": "Pv"
							}
						],
						"endline": 280,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 78,
						"name": "next",
						"line": 284,
						"comment": "Get TypeInfo for 'next' type, as defined by what kind of type this is,\n\nnull if none.\n",
						"deco": "NgFNaNbNdNiZNgC8TypeInfo",
						"endline": 284,
						"char": 31,
						"kind": "function"
					},
					{
						"endchar": 72,
						"name": "init",
						"line": 289,
						"comment": "Return default initializer.  If the type should be initialized to all zeros,\n\nan array with a null ptr and a length equal to the type size will be returned.\n",
						"deco": "xFNaNbNiNfZAxv",
						"endline": 289,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 71,
						"name": "flags",
						"line": 293,
						"comment": "Get flags for type: 1 means GC should scan for pointers,\n\n2 means arg of this type is passed in XMM register\n",
						"deco": "xFNaNbNdNiNfZk",
						"endline": 293,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 58,
						"name": "offTi",
						"line": 296,
						"comment": "Get type information on the contents of the type; null if not available\n",
						"deco": "xFZAxS6object14OffsetTypeInfo",
						"endline": 296,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 34,
						"name": "destroy",
						"line": 298,
						"comment": "Run the destructor on the object and all its sub-objects\n",
						"deco": "xFPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 298,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 35,
						"name": "postblit",
						"line": 300,
						"comment": "Run the postblit on the object and all its sub-objects\n",
						"deco": "xFPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 300,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 78,
						"name": "talign",
						"line": 304,
						"comment": "Return alignment of type\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 304,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "argTypes",
						"line": 309,
						"comment": " Return internal info on arguments fitting into 8byte.\n See X86-64 ABI 3.2.3\n",
						"deco": "FNbNfJC8TypeInfoJC8TypeInfoZi",
						"parameters": [
							{
								"name": "arg1",
								"storageClass": [
									"out"
								],
								"deco": "C8TypeInfo"
							},
							{
								"name": "arg2",
								"storageClass": [
									"out"
								],
								"deco": "C8TypeInfo"
							}
						],
						"endline": 313,
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 87,
						"name": "rtInfo",
						"line": 317,
						"comment": " Return info used by the garbage collector to do precise collection.\n",
						"deco": "xFNaNbNdNiNfZPyv",
						"endline": 317,
						"char": 32,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 16,
						"name": "m_init",
						"line": 841,
						"comment": " class static initializer\n (init.length gives size in bytes of class)\n",
						"deco": "Ag",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "name",
						"line": 844,
						"comment": "class name\n",
						"deco": "Aya",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "vtbl",
						"line": 845,
						"comment": "virtual function pointer table\n",
						"deco": "APv",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "interfaces",
						"line": 846,
						"comment": "interfaces this class implements\n",
						"deco": "AS6object9Interface",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "base",
						"line": 847,
						"comment": "base class\n",
						"deco": "C14TypeInfo_Class",
						"originalType": "TypeInfo_Class",
						"char": 22,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "find",
						"line": 874,
						"comment": " Search all modules for TypeInfo_Class corresponding to classname.\n Returns: null if not found\n",
						"deco": "FxAaZxC14TypeInfo_Class",
						"parameters": [
							{
								"name": "classname",
								"deco": "xAa"
							}
						],
						"endline": 889,
						"originalType": "const(TypeInfo_Class)(in char[] classname)",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "create",
						"line": 894,
						"comment": " Create instance of Object represented by 'this'.\n",
						"deco": "xFZC6Object",
						"endline": 906,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "TypeInfo_Class",
				"line": 776,
				"comment": " Runtime type information about a class.\n Can be retrieved from an object instance by using the\n $(LINK2 ../property.html#classinfo, .classinfo) property.\n",
				"base": "object.TypeInfo",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Throwable",
				"line": 1496,
				"comment": "\n\n\n\n The base class of all thrown objects.\n\n All thrown objects must inherit from Throwable. Class $(D Exception), which\n derives from this class, represents the category of thrown objects that are\n safe to catch and handle. In principle, one should not catch Throwable\n objects that are not derived from $(D Exception), as they represent\n unrecoverable runtime errors. Certain runtime guarantees may fail to hold\n when these errors are thrown, making it unsafe to continue execution after\n catching them.\n",
				"members": [
					{
						"offset": 16,
						"name": "msg",
						"line": 1505,
						"comment": "A message describing the error.\n",
						"deco": "Aya",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "file",
						"line": 1511,
						"comment": " The _file name and line number of the D source code corresponding with\n where the error was thrown from.\n",
						"deco": "Aya",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "line",
						"line": 1512,
						"comment": "ditto\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "info",
						"line": 1519,
						"comment": " The stack trace of where the error happened. This is an opaque object\n that can either be converted to $(D string), or iterated over with $(D\n foreach) to extract the items in the stack trace (as strings).\n",
						"deco": "C6object9Throwable9TraceInfo",
						"originalType": "TraceInfo",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "next",
						"line": 1527,
						"comment": " A reference to the _next error in the list. This is used when a new\n $(D Throwable) is thrown from inside a $(D catch) block. The originally\n caught $(D Exception) will be chained to the new $(D Throwable) via this\n field.\n",
						"deco": "C6object9Throwable",
						"originalType": "Throwable",
						"char": 17,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1549,
						"comment": " Overrides $(D Object.toString) and returns the error message.\n Internally this forwards to the $(D toString) overload that\n takes a $(PARAM sink) delegate.\n",
						"deco": "FZAya",
						"endline": 1554,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1562,
						"comment": " The Throwable hierarchy uses a toString overload that takes a\n $(PARAM sink) delegate to avoid GC allocations, which cannot be\n performed in certain error situations.  Override this $(D\n toString) method to customize the error message.\n",
						"deco": "xFMDFxAaZvZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFxAaZv"
							}
						],
						"endline": 1593,
						"originalType": "const void(scope void delegate(in char[]) sink)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1614,
						"comment": " Creates a new instance of Exception. The next parameter is used\n internally and should always be $(D null) when passed by user code.\n This constructor does not automatically throw the newly-created\n Exception; the $(D throw) statement should be used for that purpose.\n",
						"deco": "FNaNbNiNfAyaAyamC6object9ThrowableZC9Exception",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 1617,
						"originalType": "pure nothrow @nogc @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 30,
						"kind": "constructor"
					}
				],
				"name": "Exception",
				"line": 1605,
				"comment": " The base class of all errors that are safe to catch and handle.\n\n In principle, only thrown objects derived from this class are safe to catch\n inside a $(D catch) block. Thrown objects not derived from Exception\n represent runtime errors that should not be caught, as certain runtime\n guarantees may not hold, making it unsafe to continue program execution.\n",
				"base": "object.Throwable",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1670,
						"comment": " Creates a new instance of Error. The next parameter is used\n internally and should always be $(D null) when passed by user code.\n This constructor does not automatically throw the newly-created\n Error; the $(D throw) statement should be used for that purpose.\n",
						"deco": "FNaNbNiNfAyaC6object9ThrowableZC6object5Error",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 1674,
						"originalType": "pure nothrow @nogc @safe (string msg, Throwable next = null)",
						"char": 30,
						"kind": "constructor"
					},
					{
						"offset": 72,
						"name": "bypassedException",
						"line": 1684,
						"comment": "The first $(D Exception) which was bypassed when this Error was thrown,\n\nor $(D null) if no $(D Exception)s were pending.\n",
						"deco": "C6object9Throwable",
						"originalType": "Throwable",
						"char": 17,
						"kind": "variable"
					}
				],
				"name": "Error",
				"line": 1662,
				"comment": " The base class of all unrecoverable runtime errors.\n\n This represents the category of $(D Throwable) objects that are $(B not)\n safe to catch and handle. In principle, one should not catch Error\n objects, as they represent unrecoverable runtime errors.\n Certain runtime guarantees may fail to hold when these errors are\n thrown, making it unsafe to continue execution after catching them.\n",
				"base": "object.Throwable",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "destroy",
						"line": 2575,
						"type": "void(T obj)",
						"parameters": [
							{
								"name": "obj",
								"type": "T"
							}
						],
						"endline": 2578,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "destroy",
				"line": 2575,
				"comment": "    Destroys the given object and puts it in an invalid state. It's used to\n    destroy an object so that any cleanup which its destructor or finalizer\n    does is done and so that it no longer references any other objects. It does\n    $(I not) initiate a GC cycle or free any GC memory.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "capacity",
						"line": 2773,
						"type": "pure nothrow @property size_t(T[] arr)",
						"parameters": [
							{
								"name": "arr",
								"type": "T[]"
							}
						],
						"endline": 2776,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "capacity",
				"line": 2773,
				"comment": " (Property) Get the current capacity of a slice. The capacity is the size\n that the slice can grow to before the underlying array must be\n reallocated or extended.\n\n If an append must reallocate a slice with no possibility of extension, then\n 0 is returned. This happens when the slice references a static array, or\n if another slice references elements past the end of the current slice.\n\n Note: The capacity of a slice may be impacted by operations on other slices.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2778_207)\n---\n//Static array slice: no capacity\nint[4] sarray = [1, 2, 3, 4];\nint[]  slice  = sarray[];\nassert(sarray.capacity == 0);\n//Appending to slice will reallocate to a new array\nslice ~= 5;\nassert(slice.capacity >= 5);\n\n//Dynamic array slices\nint[] a = [1, 2, 3, 4];\nint[] b = a[1 .. $];\nint[] c = a[1 .. $ - 1];\ndebug(SENTINEL) {} else // non-zero capacity very much depends on the array and GC implementation\n{\n    assert(a.capacity != 0);\n    assert(a.capacity == b.capacity + 1); //both a and b share the same tail\n}\nassert(c.capacity == 0);              //an append to c must relocate c.\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2778_207)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reserve",
						"line": 2808,
						"type": "pure nothrow @trusted size_t(ref T[] arr, size_t newcapacity)",
						"parameters": [
							{
								"name": "arr",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "newcapacity",
								"type": "size_t"
							}
						],
						"endline": 2811,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "reserve",
				"line": 2808,
				"comment": " Reserves capacity for a slice. The capacity is the size\n that the slice can grow to before the underlying array must be\n reallocated or extended.\n\n The return value is the new capacity of the array (which may be larger than\n the requested capacity).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2813_208)\n---\n//Static array slice: no capacity. Reserve relocates.\nint[4] sarray = [1, 2, 3, 4];\nint[]  slice  = sarray[];\nauto u = slice.reserve(8);\nassert(u >= 8);\nassert(sarray.ptr !is slice.ptr);\nassert(slice.capacity == u);\n\n//Dynamic array slices\nint[] a = [1, 2, 3, 4];\na.reserve(8); //prepare a for appending 4 more items\nauto p = a.ptr;\nu = a.capacity;\na ~= [5, 6, 7, 8];\nassert(p == a.ptr);      //a should not have been reallocated\nassert(u == a.capacity); //a should not have been extended\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2813_208)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeSafeAppend",
						"line": 2855,
						"type": "nothrow ref inout(T[])(auto ref inout(T[]) arr)",
						"parameters": [
							{
								"name": "arr",
								"type": "inout(T[])",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 2859,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assumeSafeAppend",
				"line": 2855,
				"comment": " Assume that it is safe to append to this array. Appends made to this array\n after calling this function may append in place, even if the array was a\n slice of a larger array to begin with.\n\n Use this only when it is certain there are no elements in use beyond the\n array in the memory block.  If there are, those elements will be\n overwritten by appending to this array.\n\n Calling this function, and then using references to data located after the\n given array results in undefined behavior.\n\n Returns:\n   The input is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2861_210)\n---\nint[] a = [1, 2, 3, 4];\n\n// Without assumeSafeAppend. Appending relocates.\nint[] b = a [0 .. 3];\nb ~= 5;\nassert(a.ptr != b.ptr);\n\ndebug(SENTINEL) {} else\n{\n    // With assumeSafeAppend. Appending overwrites.\n    int[] c = a [0 .. 3];\n    c.assumeSafeAppend() ~= 5;\n    assert(a.ptr == c.ptr);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2861_210)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "_ArrayEq",
						"line": 2962,
						"type": "bool(T1[] a1, T2[] a2)",
						"parameters": [
							{
								"name": "a1",
								"type": "T1[]"
							},
							{
								"name": "a2",
								"type": "T2[]"
							}
						],
						"endline": 2972,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "_ArrayEq",
				"line": 2962,
				"comment": " Helper function used to see if two containers of different\n types have the same contents in the same sequence.\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "hashOf",
						"line": 2996,
						"type": "size_t(auto ref T arg, size_t seed = 0)",
						"parameters": [
							{
								"name": "arg",
								"type": "T",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "seed",
								"type": "size_t",
								"default": "0"
							}
						],
						"endline": 3000,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "hashOf",
				"line": 2996,
				"comment": "Calculates the hash value of $(D arg) with $(D seed) initial value.\nResult may be non-equals with $(D typeid(T).getHash(&arg))\nThe $(D seed) value may be used for hash chaining:\n----\nstruct Test\n{\n    int a;\n    string b;\n    MyObject c;\n\n    size_t toHash() const @safe pure nothrow\n    {\n        size_t hash = a.hashOf();\n        hash = b.hashOf(hash);\n        size_t h1 = c.myMegaHash();\n        hash = h1.hashOf(hash); //Mix two hash values\n        return hash;\n    }\n}\n----\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RTInfo",
						"line": 3021,
						"init": "null",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "RTInfo",
				"line": 3019,
				"comment": " Create RTInfo for type T\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dup",
						"line": 3122,
						"type": "@property (T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 3134,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "dup",
				"line": 3122,
				"comment": "Provide the .dup array property.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!is(const(T) : T)",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dup",
						"line": 3138,
						"type": "@property T[](const(T)[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "const(T)[]"
							}
						],
						"endline": 3146,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "dup",
				"line": 3138,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(const(T) : T)",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dup",
						"line": 3149,
						"type": "@property @trusted T[](const(T)[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "const(T)[]"
							}
						],
						"endline": 3153,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "dup",
				"line": 3149,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"deco": "v",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "idup",
						"line": 3156,
						"type": "@property immutable(T)[](T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 3166,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "idup",
				"line": 3156,
				"comment": "Provide the .idup array property.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 26,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "idup",
						"line": 3169,
						"type": "@property immutable(T)[](const(T)[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "const(T)[]"
							}
						],
						"endline": 3172,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "idup",
				"line": 3169,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"deco": "v",
						"kind": "type"
					}
				],
				"char": 26,
				"kind": "template"
			}
		],
		"comment": " Forms the symbols available to all D programs. Includes Object, which is\n the root of the class object hierarchy.  This module is implicitly\n imported.\n Macros:\n      WIKI = Object\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Walter Bright, Sean Kelly\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/atomic.d",
		"name": "core.atomic",
		"members": [
			{
				"members": [
					{
						"endchar": 5,
						"name": "atomicOp",
						"line": 74,
						"type": "pure nothrow @nogc HeadUnshared!T(ref shared T val, V1 mod)",
						"parameters": [
							{
								"name": "val",
								"type": "T",
								"storageClass": [
									"shared",
									"ref"
								]
							},
							{
								"name": "mod",
								"type": "V1"
							}
						],
						"endline": 78,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "atomicOp",
				"line": 74,
				"comment": " Performs the binary operation 'op' on val using 'mod' as the modifier.\n\n Params:\n  val = The target variable.\n  mod = The modifier to apply.\n\n Returns:\n  The result of the operation.\n",
				"parameters": [
					{
						"name": "op",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					}
				],
				"constraint": "__traits(compiles, mixin(\"*cast(T*)&val\" ~ op ~ \"mod\"))",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "cas",
						"line": 94,
						"type": "pure nothrow @nogc bool(shared(T)* here, const V1 ifThis, V2 writeThis)",
						"parameters": [
							{
								"name": "here",
								"type": "shared(T)*"
							},
							{
								"name": "ifThis",
								"type": "V1",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "writeThis",
								"type": "V2"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "cas",
				"line": 94,
				"comment": " Stores 'writeThis' to the memory referenced by 'here' if the value\n referenced by 'here' is equal to 'ifThis'.  This operation is both\n lock-free and atomic.\n\n Params:\n  here      = The address of the destination variable.\n  writeThis = The value to store.\n  ifThis    = The comparison value.\n\n Returns:\n  true if the store occurred, false if not.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					},
					{
						"name": "V2",
						"kind": "type"
					}
				],
				"constraint": "!is(T == class) && !is(T U : U*) && __traits(compiles, ()\n{\n*here = writeThis;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "cas",
						"line": 98,
						"type": "pure nothrow @nogc bool(shared(T)* here, const shared(V1) ifThis, shared(V2) writeThis)",
						"parameters": [
							{
								"name": "here",
								"type": "shared(T)*"
							},
							{
								"name": "ifThis",
								"type": "shared(V1)",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "writeThis",
								"type": "shared(V2)"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "cas",
				"line": 98,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					},
					{
						"name": "V2",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) && __traits(compiles, ()\n{\n*here = writeThis;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "cas",
						"line": 102,
						"type": "pure nothrow @nogc bool(shared(T)* here, const shared(V1)* ifThis, shared(V2)* writeThis)",
						"parameters": [
							{
								"name": "here",
								"type": "shared(T)*"
							},
							{
								"name": "ifThis",
								"type": "shared(V1)*",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "writeThis",
								"type": "shared(V2)*"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "cas",
				"line": 102,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					},
					{
						"name": "V2",
						"kind": "type"
					}
				],
				"constraint": "is(T U : U*) && __traits(compiles, ()\n{\n*here = writeThis;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "atomicLoad",
						"line": 116,
						"type": "pure nothrow @nogc HeadUnshared!T(ref const shared T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T",
								"storageClass": [
									"const",
									"shared",
									"ref"
								]
							}
						],
						"endline": 119,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "atomicLoad",
				"line": 116,
				"comment": " Loads 'val' from memory and returns it.  The memory barrier specified\n by 'ms' is applied to the operation, which is fully sequenced by\n default.\n\n Params:\n  val = The target variable.\n\n Returns:\n  The value of 'val'.\n",
				"parameters": [
					{
						"name": "ms",
						"defaultValue": "MemoryOrder.seq",
						"deco": "E4core6atomic11MemoryOrder",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "atomicStore",
						"line": 130,
						"type": "pure nothrow @nogc void(ref shared T val, V1 newval)",
						"parameters": [
							{
								"name": "val",
								"type": "T",
								"storageClass": [
									"shared",
									"ref"
								]
							},
							{
								"name": "newval",
								"type": "V1"
							}
						],
						"endline": 134,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "atomicStore",
				"line": 130,
				"comment": " Writes 'newval' into 'val'.  The memory barrier specified by 'ms' is\n applied to the operation, which is fully sequenced by default.\n\n Params:\n  val    = The target variable.\n  newval = The value to store.\n",
				"parameters": [
					{
						"name": "ms",
						"defaultValue": "MemoryOrder.seq",
						"deco": "E4core6atomic11MemoryOrder",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "V1",
						"kind": "type"
					}
				],
				"constraint": "__traits(compiles, ()\n{\nval = newval;\n}\n)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "raw",
						"line": 142,
						"value": "0",
						"comment": "Not sequenced.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "acq",
						"line": 143,
						"value": "1",
						"comment": "Hoist-load + hoist-store barrier.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "rel",
						"line": 144,
						"value": "2",
						"comment": "Sink-load + sink-store barrier.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "seq",
						"line": 145,
						"value": "3",
						"comment": "Fully sequenced (acquire + release).\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "MemoryOrder",
				"line": 140,
				"comment": " Specifies the memory ordering semantics of an atomic operation.\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "atomicFence",
				"line": 156,
				"comment": " Inserts a full load/store memory fence (on platforms that need it). This ensures\n that all loads and stores before a call to this function are executed before any\n loads and stores after the call.\n",
				"deco": "FNbNiZv",
				"char": 10,
				"kind": "function"
			}
		],
		"comment": " The atomic module provides basic support for lock-free\n concurrent programming.\n\n Copyright: Copyright Sean Kelly 2005 - 2010.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly, Alex RÃ¸nne Petersen\n Source:    $(DRUNTIMESRC core/_atomic.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/math.d",
		"name": "core.math",
		"members": [
			{
				"name": "cos",
				"line": 43,
				"comment": " Returns cosine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cos(x)) $(TH invalid?))\n      $(TR $(TD $(NAN))            $(TD $(NAN)) $(TD yes)     )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN)) $(TD yes)     )\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "sin",
				"line": 58,
				"comment": " Returns sine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)               $(TH sin(x))      $(TH invalid?))\n      $(TR $(TD $(NAN))          $(TD $(NAN))      $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))    $(TD $(NAN))      $(TD yes))\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rndtol",
				"line": 66,
				"comment": " Returns x rounded to a long value using the current rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "FNaNbNiNfeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rndtonl",
				"line": 75,
				"comment": " Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "UNieZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 90,
				"comment": " Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"char": 11,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 91,
				"comment": "ditto\n\n Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 92,
				"comment": "ditto\n\n Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "ldexp",
				"line": 100,
				"comment": " Compute n * 2$(SUPERSCRIPT exp)\n References: frexp\n",
				"deco": "FNaNbNiNfeiZe",
				"parameters": [
					{
						"name": "n",
						"deco": "e"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "fabs",
				"line": 127,
				"comment": " Returns |x|\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH fabs(x)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rint",
				"line": 137,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n If the return value is not equal to x, the FE_INEXACT\n exception is raised.\n $(B nearbyint) performs\n the same operation, but does not set the FE_INEXACT exception.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "yl2x",
				"line": 144,
				"comment": " Building block functions, they\n translate to a single x87 instruction.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			}
		],
		"comment": " Builtin mathematical intrinsics\n\n Source: $(DRUNTIMESRC core/_math.d)\n Macros:\n      TABLE_SV = <table border=1 cellpadding=4 cellspacing=0>\n              <caption>Special Values</caption>\n              $0</table>\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      POWER = $1<sup>$2</sup>\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      LT = &lt;\n      GT = &gt;\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Don Clugston\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/simd.d",
		"name": "core.simd",
		"members": [
			{
				"members": [
					{
						"name": "Vector",
						"line": 36,
						"type": "__vector(T)",
						"char": 23,
						"kind": "alias"
					}
				],
				"name": "Vector",
				"line": 31,
				"comment": " Create a vector type.\n\n Parameters:\n      T = one of double[2], float[4], void[16], byte[16], ubyte[16],\n      short[8], ushort[8], int[4], uint[4], long[2], ulong[2].\n      For 256 bit vectors,\n      one of double[4], float[8], void[32], byte[32], ubyte[32],\n      short[16], ushort[16], int[8], uint[8], long[4], ulong[4]\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "void16",
				"line": 41,
				"comment": "\n",
				"deco": "NhG16v",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "double2",
				"line": 42,
				"comment": "\n",
				"deco": "NhG2d",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "float4",
				"line": 43,
				"comment": "\n",
				"deco": "NhG4f",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "byte16",
				"line": 44,
				"comment": "\n",
				"deco": "NhG16g",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "ubyte16",
				"line": 45,
				"comment": "\n",
				"deco": "NhG16h",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "short8",
				"line": 46,
				"comment": "\n",
				"deco": "NhG8s",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "ushort8",
				"line": 47,
				"comment": "\n",
				"deco": "NhG8t",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "int4",
				"line": 48,
				"comment": "\n",
				"deco": "NhG4i",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "uint4",
				"line": 49,
				"comment": "\n",
				"deco": "NhG4k",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "long2",
				"line": 50,
				"comment": "\n",
				"deco": "NhG2l",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "ulong2",
				"line": 51,
				"comment": "\n",
				"deco": "NhG2m",
				"char": 62,
				"kind": "alias"
			},
			{
				"name": "void32",
				"line": 53,
				"comment": "\n",
				"deco": "NhG32v",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "double4",
				"line": 54,
				"comment": "\n",
				"deco": "NhG4d",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "float8",
				"line": 55,
				"comment": "\n",
				"deco": "NhG8f",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "byte32",
				"line": 56,
				"comment": "\n",
				"deco": "NhG32g",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "ubyte32",
				"line": 57,
				"comment": "\n",
				"deco": "NhG32h",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "short16",
				"line": 58,
				"comment": "\n",
				"deco": "NhG16s",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "ushort16",
				"line": 59,
				"comment": "\n",
				"deco": "NhG16t",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "int8",
				"line": 60,
				"comment": "\n",
				"deco": "NhG8i",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "uint8",
				"line": 61,
				"comment": "\n",
				"deco": "NhG8k",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "long4",
				"line": 62,
				"comment": "\n",
				"deco": "NhG4l",
				"char": 63,
				"kind": "alias"
			},
			{
				"name": "ulong4",
				"line": 63,
				"comment": "\n",
				"deco": "NhG4m",
				"char": 63,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "XMM",
				"line": 73,
				"comment": " XMM opcodes that conform to the following:\n\n  opcode xmm1,xmm2/mem\n\n and do not have side effects (i.e. do not write to memory).\n",
				"baseDeco": "i",
				"char": 3,
				"kind": "enum"
			}
		],
		"comment": " Builtin SIMD intrinsics\n\n Source: $(DRUNTIMESRC core/_simd.d)\n\n Copyright: Copyright Digital Mars 2012.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/thread.d",
		"name": "core.thread",
		"members": [
			{
				"name": "getpid",
				"line": 55,
				"comment": " Returns the process ID of the calling process, which is guaranteed to be\n unique on the system. This call is always successful.\n\n Example:\n ---\n writefln(\"Current process id: %s\", getpid());\n ---\n",
				"char": 40,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "ThreadException",
				"line": 71,
				"comment": "\n\n\n\n Base class for thread exceptions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "ThreadError",
				"line": 88,
				"comment": " Base class for thread errors to be used for function inside GC when allocations are unavailable.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Thread",
				"line": 489,
				"comment": "\n\n\n\n This class encapsulates all threading functionality for the D\n programming language.  As thread manipulation is a required facility\n for garbage collection, all user threads should derive from this\n class, and instances of this class should never be explicitly deleted.\n A new thread may be created using either derivation or composition, as\n in the following example.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1796_248)\n---\nclass DerivedThread : Thread\n{\n    this()\n    {\n        super(&run);\n    }\n\nprivate:\n    void run()\n    {\n        // Derived thread running.\n    }\n}\n\nvoid threadFunc()\n{\n    // Composed thread running.\n}\n\n// create and start instances of each type\nauto derived = new DerivedThread().start();\nauto composed = new Thread(&threadFunc).start();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1796_248)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 507,
						"comment": "\n\n\n\n Initializes a thread object which is associated with a static\n D function.\n\n Params:\n  fn = The thread function.\n  sz = The stack size for this thread.\n\n In:\n  fn must not be null.\n",
						"deco": "FPFZvmZC4core6thread6Thread",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 518,
						"originalType": "(void function() fn, size_t sz = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 532,
						"comment": " Initializes a thread object which is associated with a dynamic\n D function.\n\n Params:\n  dg = The thread function.\n  sz = The stack size for this thread.\n\n In:\n  dg must not be null.\n",
						"deco": "FDFZvmZC4core6thread6Thread",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 543,
						"originalType": "(void delegate() dg, size_t sz = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 549,
						"comment": " Cleans up any remaining resources used by this object.\n",
						"deco": "FZv",
						"endline": 573,
						"char": 5,
						"kind": "destructor"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 593,
							"deco": "FNbZv",
							"endline": 593,
							"char": 5,
							"kind": "function"
						},
						"name": "start",
						"line": 591,
						"comment": "\n\n\n\n Starts the thread and invokes the function or delegate passed upon\n construction.\n\n In:\n  This routine may only be called once per thread instance.\n\n Throws:\n  ThreadException if the thread fails to start.\n",
						"deco": "FNbZC4core6thread6Thread",
						"endline": 697,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "join",
						"line": 715,
						"comment": " Waits for this thread to complete.  If the thread terminated as the\n result of an unhandled exception, this exception will be rethrown.\n\n Params:\n  rethrow = Rethrow any unhandled exception which may have caused this\n            thread to terminate.\n\n Throws:\n  ThreadException if the operation fails.\n  Any exception not handled by the joined thread.\n\n Returns:\n  Any exception not handled by this thread if rethrow = false, null\n  otherwise.\n",
						"deco": "FbZC6object9Throwable",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "b",
								"default": "true"
							}
						],
						"endline": 745,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "name",
						"line": 759,
						"comment": "\n\n\n\n Gets the user-readable label for this thread.\n\n Returns:\n  The name of this thread.\n",
						"deco": "FNdZAya",
						"endline": 765,
						"char": 28,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "name",
						"line": 774,
						"comment": " Sets the user-readable label for this thread.\n\n Params:\n  val = The new name of this thread.\n",
						"deco": "FNdAyaZv",
						"parameters": [
							{
								"name": "val",
								"deco": "Aya"
							}
						],
						"endline": 780,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 793,
						"comment": " Gets the daemon status for this thread.  While the runtime will wait for\n all normal threads to complete before tearing down the process, daemon\n threads are effectively ignored and thus will not prevent the process\n from terminating.  In effect, daemon threads will be terminated\n automatically by the OS when the process exits.\n\n Returns:\n  true if this is a daemon thread.\n",
						"deco": "FNdZb",
						"endline": 799,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 812,
						"comment": " Sets the daemon status for this thread.  While the runtime will wait for\n all normal threads to complete before tearing down the process, daemon\n threads are effectively ignored and thus will not prevent the process\n from terminating.  In effect, daemon threads will be terminated\n automatically by the OS when the process exits.\n\n Params:\n  val = The new daemon status for this thread.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "val",
								"deco": "b"
							}
						],
						"endline": 818,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "isRunning",
						"line": 827,
						"comment": " Tests whether this thread is running.\n\n Returns:\n  true if the thread is running, false if not.\n",
						"deco": "FNbNdZb",
						"endline": 844,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"name": "PRIORITY_MIN",
						"line": 858,
						"comment": "\n\n\n\n The minimum scheduling priority that may be set for a thread.  On\n systems where multiple scheduling policies are defined, this value\n represents the minimum valid priority for the scheduling policy of\n the process.\n",
						"deco": "xi",
						"originalType": "int",
						"char": 25,
						"kind": "variable",
						"storageClass": [
							"const",
							"__gshared"
						]
					},
					{
						"name": "PRIORITY_MAX",
						"line": 867,
						"comment": " The maximum scheduling priority that may be set for a thread.  On\n systems where multiple scheduling policies are defined, this value\n represents the maximum valid priority for the scheduling policy of\n the process.\n",
						"deco": "xi",
						"originalType": "int",
						"char": 25,
						"kind": "variable",
						"storageClass": [
							"const",
							"__gshared"
						]
					},
					{
						"name": "PRIORITY_DEFAULT",
						"line": 876,
						"comment": " The default scheduling priority that is set for a thread.  On\n systems where multiple scheduling policies are defined, this value\n represents the default priority for the scheduling policy of\n the process.\n",
						"deco": "xi",
						"originalType": "int",
						"char": 25,
						"kind": "variable",
						"storageClass": [
							"const",
							"__gshared"
						]
					},
					{
						"endchar": 5,
						"name": "priority",
						"line": 888,
						"comment": " Gets the scheduling priority for the associated thread.\n\n Note: Getting the priority of a thread that already terminated\n might return the default priority.\n\n Returns:\n  The scheduling priority of this thread.\n",
						"deco": "FNdZi",
						"endline": 907,
						"char": 25,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 921,
							"deco": "FZv",
							"endline": 921,
							"char": 5,
							"kind": "function"
						},
						"name": "priority",
						"line": 919,
						"comment": " Sets the scheduling priority for the associated thread.\n\n Note: Setting the priority of a thread that already terminated\n might have no effect.\n\n Params:\n  val = The new scheduling priority of this thread.\n",
						"deco": "FNdiZv",
						"parameters": [
							{
								"name": "val",
								"deco": "i"
							}
						],
						"endline": 991,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "sleep",
						"line": 1044,
						"comment": "\n\n\n\n Suspends the calling thread for at least the supplied period.  This may\n result in multiple OS calls if period is greater than the maximum sleep\n duration supported by the operating system.\n\n Params:\n  val = The minimum duration the calling thread should be suspended.\n\n In:\n  period must be non-negative.\n\n Example:\n ------------------------------------------------------------------------\n\n Thread.sleep( dur!(\"msecs\")( 50 ) );  // sleep for 50 milliseconds\n Thread.sleep( dur!(\"seconds\")( 5 ) ); // sleep for 5 seconds\n\n ------------------------------------------------------------------------\n",
						"deco": "FNbS4core4time8DurationZv",
						"parameters": [
							{
								"name": "val",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 1091,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 1097,
						"comment": " Forces a context switch to occur away from the calling thread.\n",
						"deco": "FNbZv",
						"endline": 1103,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getThis",
						"line": 1118,
						"comment": "\n\n\n\n Provides a reference to the calling thread.\n\n Returns:\n  The thread object representing the calling thread.  The result of\n  deleting this object is undefined.  If the current thread is not\n  attached to the runtime, a null reference is returned.\n",
						"deco": "FNbZC4core6thread6Thread",
						"endline": 1136,
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getAll",
						"line": 1147,
						"comment": " Provides a list of all threads currently being tracked by the system.\n\n Returns:\n  An array containing references to all threads currently being\n  tracked by the system.  The result of deleting any contained\n  objects is undefined.\n",
						"deco": "FZAC4core6thread6Thread",
						"endline": 1160,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 1173,
						"comment": " Operates on all threads currently being tracked by the system.  The\n result of deleting any Thread object is undefined.\n\n Params:\n  dg = The supplied code as a delegate.\n\n Returns:\n  Zero if all elemented are visited, nonzero if not.\n",
						"deco": "FMDFKC4core6thread6ThreadZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFKC4core6thread6ThreadZi"
							}
						],
						"endline": 1187,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 5,
				"name": "thread_setGCSignals",
				"line": 1866,
				"comment": " Instruct the thread module, when initialized, to use a different set of\n signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads.\n This function should be called at most once, prior to thread_init().\n This function is Posix-only.\n\n\n\n\n",
				"deco": "UiiZv",
				"parameters": [
					{
						"name": "suspendSignalNo",
						"deco": "i"
					},
					{
						"name": "resumeSignalNo",
						"deco": "i"
					}
				],
				"endline": 1868,
				"char": 21,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_init",
				"line": 1903,
				"comment": " Initializes the thread module.  This function must be called by the\n garbage collector on startup and before any other thread routines\n are called.\n",
				"deco": "UZv",
				"endline": 1973,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_term",
				"line": 1980,
				"comment": " Terminates the thread module. No other thread routine may be called\n afterwards.\n",
				"deco": "UZv",
				"endline": 1991,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_isMainThread",
				"line": 1997,
				"comment": "\n",
				"deco": "UZb",
				"endline": 2000,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_attachThis",
				"line": 2013,
				"comment": " Registers the calling thread for use with the D Runtime.  If this routine\n is called for a thread which is already registered, no action is performed.\n\n NOTE: This routine does not run thread-local static constructors when called.\n       If full functionality as a D thread is desired, the following function\n       must be called after thread_attachThis:\n\n       extern (C) void rt_moduleTlsCtor();\n",
				"deco": "UZC4core6thread6Thread",
				"endline": 2054,
				"char": 19,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_detachThis",
				"line": 2130,
				"comment": " Deregisters the calling thread from use with the runtime.  If this routine\n is called for a thread which is not registered, the result is undefined.\n\n NOTE: This routine does not run thread-local static destructors when called.\n       If full functionality as a D thread is desired, the following function\n       must be called after thread_detachThis, particularly if the thread is\n       being detached at some indeterminate time before program termination:\n\n       $(D extern(C) void rt_moduleTlsDtor();)\n",
				"deco": "UNbZv",
				"endline": 2134,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_detachByAddr",
				"line": 2148,
				"comment": " Deregisters the given thread from use with the runtime.  If this routine\n is called for a thread which is not registered, the result is undefined.\n\n NOTE: This routine does not run thread-local static destructors when called.\n       If full functionality as a D thread is desired, the following function\n       must be called by the detached thread, particularly if the thread is\n       being detached at some indeterminate time before program termination:\n\n       $(D extern(C) void rt_moduleTlsDtor();)\n",
				"deco": "UmZv",
				"parameters": [
					{
						"name": "addr",
						"deco": "m"
					}
				],
				"endline": 2152,
				"originalType": "extern (C) void(Thread.ThreadAddr addr)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_detachInstance",
				"line": 2156,
				"comment": "ditto\n",
				"deco": "UC4core6thread6ThreadZv",
				"parameters": [
					{
						"name": "t",
						"deco": "C4core6thread6Thread"
					}
				],
				"endline": 2159,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_findByAddr",
				"line": 2189,
				"comment": " Search the list of all threads for a thread with the given thread identifier.\n\n Params:\n  addr = The thread identifier to search for.\n Returns:\n  The thread object associated with the thread identifier, null if not found.\n",
				"deco": "FmZC4core6thread6Thread",
				"parameters": [
					{
						"name": "addr",
						"deco": "m"
					}
				],
				"endline": 2201,
				"originalType": "Thread(Thread.ThreadAddr addr)",
				"char": 15,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"endchar": 1,
				"name": "thread_setThis",
				"line": 2214,
				"comment": " Sets the current thread to a specific reference. Only to be used\n when dealing with externally-created threads (in e.g. C code).\n The primary use of this function is when Thread.getThis() must\n return a sensible value in, for example, TLS destructors. In\n other words, don't touch this unless you know what you're doing.\n\n Params:\n  t = A reference to the current thread. May be null.\n",
				"deco": "UC4core6thread6ThreadZv",
				"parameters": [
					{
						"name": "t",
						"deco": "C4core6thread6Thread"
					}
				],
				"endline": 2217,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_joinAll",
				"line": 2225,
				"comment": " Joins all non-daemon threads that are currently running.  This is done by\n performing successive scans through the thread list until a scan consists\n of only daemon threads.\n",
				"deco": "UZv",
				"endline": 2249,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_suspendAll",
				"line": 2545,
				"comment": " Suspend all threads but the calling thread for \"stop the world\" garbage\n collection runs.  This function may be called multiple times, and must\n be followed by a matching number of calls to thread_resumeAll before\n processing is resumed.\n\n Throws:\n  ThreadError if the suspend operation fails for a running thread.\n",
				"deco": "UNbZv",
				"endline": 2605,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_resumeAll",
				"line": 2687,
				"comment": " Resume all threads but the calling thread for \"stop the world\" garbage\n collection runs.  This function must be called once for each preceding\n call to thread_suspendAll before the threads are actually resumed.\n\n In:\n  This routine must be preceded by a call to thread_suspendAll.\n\n Throws:\n  ThreadError if the resume operation fails for a running thread.\n",
				"deco": "UNbZv",
				"endline": 2714,
				"char": 17,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "stack",
						"line": 2721,
						"value": "0",
						"comment": "The stack and/or registers are being scanned.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tls",
						"line": 2722,
						"value": "1",
						"comment": "TLS data is being scanned.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ScanType",
				"line": 2719,
				"comment": " Indicates the kind of scan being performed by $(D thread_scanAllType).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "ScanAllThreadsFn",
				"line": 2725,
				"comment": "The scanning function.\n",
				"deco": "DFNbPvPvZv",
				"char": 43,
				"kind": "alias"
			},
			{
				"name": "ScanAllThreadsTypeFn",
				"line": 2726,
				"comment": "ditto\n",
				"deco": "DFNbE4core6thread8ScanTypePvPvZv",
				"char": 53,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "thread_scanAllType",
				"line": 2738,
				"comment": " The main entry point for garbage collection.  The supplied delegate\n will be passed ranges representing both stack and register values.\n\n Params:\n  scan        = The scanner function.  It should scan from p1 through p2 - 1.\n\n In:\n  This routine must be preceded by a call to thread_suspendAll.\n",
				"deco": "UNbMDFNbE4core6thread8ScanTypePvPvZvZv",
				"parameters": [
					{
						"name": "scan",
						"storageClass": [
							"scope"
						],
						"deco": "DFNbE4core6thread8ScanTypePvPvZv"
					}
				],
				"endline": 2746,
				"originalType": "nothrow extern (C) void(scope ScanAllThreadsTypeFn scan)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_scanAll",
				"line": 2818,
				"comment": " The main entry point for garbage collection.  The supplied delegate\n will be passed ranges representing both stack and register values.\n\n Params:\n  scan        = The scanner function.  It should scan from p1 through p2 - 1.\n\n In:\n  This routine must be preceded by a call to thread_suspendAll.\n",
				"deco": "UNbMDFNbPvPvZvZv",
				"parameters": [
					{
						"name": "scan",
						"storageClass": [
							"scope"
						],
						"deco": "DFNbPvPvZv"
					}
				],
				"endline": 2821,
				"originalType": "nothrow extern (C) void(scope ScanAllThreadsFn scan)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_enterCriticalRegion",
				"line": 2845,
				"comment": " Signals that the code following this call is a critical region. Any code in\n this region must finish running before the calling thread can be suspended\n by a call to thread_suspendAll.\n\n This function is, in particular, meant to help maintain garbage collector\n invariants when a lock is not used.\n\n A critical region is exited with thread_exitCriticalRegion.\n\n $(RED Warning):\n Using critical regions is extremely error-prone. For instance, using locks\n inside a critical region can easily result in a deadlock when another thread\n holding the lock already got suspended.\n\n The term and concept of a 'critical region' comes from\n $(LINK2 https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925 Mono's SGen garbage collector).\n\n In:\n  The calling thread must be attached to the runtime.\n",
				"deco": "UZv",
				"endline": 2854,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_exitCriticalRegion",
				"line": 2864,
				"comment": " Signals that the calling thread is no longer in a critical region. Following\n a call to this function, the thread can once again be suspended.\n\n In:\n  The calling thread must be attached to the runtime.\n",
				"deco": "UZv",
				"endline": 2873,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_inCriticalRegion",
				"line": 2882,
				"comment": " Returns true if the current thread is in a critical region; otherwise, false.\n\n In:\n  The calling thread must be attached to the runtime.\n",
				"deco": "UZb",
				"endline": 2891,
				"char": 17,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 3007,
						"value": "0",
						"comment": "Address is not marked.\n",
						"char": 10,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 3008,
						"value": "1",
						"comment": "Address is marked.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "unknown",
						"line": 3009,
						"value": "2",
						"comment": "Address is not managed by the GC.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "IsMarked",
				"line": 3005,
				"comment": " Indicates whether an address has been marked by the GC.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "IsMarkedDg",
				"line": 3012,
				"comment": "The isMarked callback function.\n",
				"deco": "DFNbPvZi",
				"char": 42,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "thread_processGCMarks",
				"line": 3026,
				"comment": " This routine allows the runtime to process any special per-thread handling\n for the GC.  This is needed for taking into account any memory that is\n referenced by non-scanned pointers but is about to be freed.  That currently\n means the array append cache.\n\n Params:\n  isMarked = The function used to check if $(D addr) is marked.\n\n In:\n  This routine must be called just prior to resuming all threads.\n",
				"deco": "UNbMDFNbPvZiZv",
				"parameters": [
					{
						"name": "isMarked",
						"storageClass": [
							"scope"
						],
						"deco": "DFNbPvZi"
					}
				],
				"endline": 3036,
				"originalType": "nothrow extern (C) void(scope IsMarkedDg isMarked)",
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_stackTop",
				"line": 3136,
				"comment": " Returns the stack top of the currently active stack within the calling\n thread.\n\n In:\n  The calling thread must be attached to the runtime.\n\n Returns:\n  The address of the stack top.\n",
				"deco": "UNbZPv",
				"endline": 3145,
				"char": 18,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thread_stackBottom",
				"line": 3158,
				"comment": " Returns the stack bottom of the currently active stack within the calling\n thread.\n\n In:\n  The calling thread must be attached to the runtime.\n\n Returns:\n  The address of the stack bottom.\n",
				"deco": "UNbZPv",
				"endline": 3166,
				"char": 18,
				"kind": "function"
			},
			{
				"name": "ThreadGroup",
				"line": 3177,
				"comment": "\n\n\n\n This class is intended to simplify certain common programming techniques.\n",
				"members": [
					{
						"endchar": 5,
						"name": "create",
						"line": 3189,
						"comment": " Creates and starts a new Thread object that executes fn and adds it to\n the list of tracked threads.\n\n Params:\n  fn = The thread function.\n\n Returns:\n  A reference to the newly created thread.\n",
						"deco": "FPFZvZC4core6thread6Thread",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							}
						],
						"endline": 3198,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "create",
						"line": 3211,
						"comment": " Creates and starts a new Thread object that executes dg and adds it to\n the list of tracked threads.\n\n Params:\n  dg = The thread function.\n\n Returns:\n  A reference to the newly created thread.\n",
						"deco": "FDFZvZC4core6thread6Thread",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							}
						],
						"endline": 3220,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 3234,
							"deco": "FZv",
							"endline": 3234,
							"char": 5,
							"kind": "function"
						},
						"name": "add",
						"line": 3232,
						"comment": " Add t to the list of tracked threads if it is not already being tracked.\n\n Params:\n  t = The thread to add.\n\n In:\n  t must not be null.\n",
						"deco": "FC4core6thread6ThreadZv",
						"parameters": [
							{
								"name": "t",
								"deco": "C4core6thread6Thread"
							}
						],
						"endline": 3243,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 3258,
							"deco": "FZv",
							"endline": 3258,
							"char": 5,
							"kind": "function"
						},
						"name": "remove",
						"line": 3256,
						"comment": " Removes t from the list of tracked threads.  No operation will be\n performed if t is not currently being tracked by this object.\n\n Params:\n  t = The thread to remove.\n\n In:\n  t must not be null.\n",
						"deco": "FC4core6thread6ThreadZv",
						"parameters": [
							{
								"name": "t",
								"deco": "C4core6thread6Thread"
							}
						],
						"endline": 3267,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 3273,
						"comment": " Operates on all threads currently tracked by this object.\n",
						"deco": "FMDFKC4core6thread6ThreadZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFKC4core6thread6ThreadZi"
							}
						],
						"endline": 3289,
						"char": 15,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "joinAll",
						"line": 3303,
						"comment": " Iteratively joins all tracked threads.  This function will block add,\n remove, and opApply until it completes.\n\n Params:\n  rethrow = Rethrow any unhandled exception which may have caused the\n            current thread to terminate.\n\n Throws:\n  Any exception not handled by the joined threads.\n",
						"deco": "FbZv",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "b",
								"default": "true"
							}
						],
						"endline": 3314,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Fiber",
				"line": 3853,
				"comment": "\n\n\n\n This class provides a cooperative concurrency mechanism integrated with the\n threading and garbage collection functionality.  Calling a fiber may be\n considered a blocking operation that returns when the fiber yields (via\n Fiber.yield()).  Execution occurs within the context of the calling thread\n so synchronization is not necessary to guarantee memory visibility so long\n as the same thread calls the fiber each time.  Please note that there is no\n requirement that a fiber be bound to one specific thread.  Rather, fibers\n may be freely passed between threads so long as they are not currently\n executing.  Like threads, a new fiber thread may be created using either\n derivation or composition, as in the following example.\n\n Warning:\n Status registers are not saved by the current implementations. This means\n floating point exception status bits (overflow, divide by 0), rounding mode\n and similar stuff is set per-thread, not per Fiber!\n\n Warning:\n On ARM FPU registers are not saved if druntime was compiled as ARM_SoftFloat.\n If such a build is used on a ARM_SoftFP system which actually has got a FPU\n and other libraries are using the FPU registers (other code is compiled\n as ARM_SoftFP) this can cause problems. Druntime must be compiled as\n ARM_SoftFP in this case.\n\n Example:\n ----------------------------------------------------------------------\n\n class DerivedFiber : Fiber\n {\n     this()\n     {\n         super( &run );\n     }\n\n private :\n     void run()\n     {\n         printf( \"Derived fiber running.\\n\" );\n     }\n }\n\n void fiberFunc()\n {\n     printf( \"Composed fiber running.\\n\" );\n     Fiber.yield();\n     printf( \"Composed fiber running.\\n\" );\n }\n\n // create instances of each type\n Fiber derived = new DerivedFiber();\n Fiber composed = new Fiber( &fiberFunc );\n\n // call both fibers once\n derived.call();\n composed.call();\n printf( \"Execution returned to calling context.\\n\" );\n composed.call();\n\n // since each fiber has run to completion, each should have state TERM\n assert( derived.state == Fiber.State.TERM );\n assert( composed.state == Fiber.State.TERM );\n\n ----------------------------------------------------------------------\n\n Authors: Based on a design by Mikola Lysenko.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3871,
						"comment": "\n\n\n\n Initializes a fiber object which is associated with a static\n D function.\n\n Params:\n  fn = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  fn must not be null.\n",
						"deco": "FNbPFZvmZC4core6thread5Fiber",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "PAGESIZE * 4LU"
							}
						],
						"endline": 3880,
						"originalType": "nothrow (void function() fn, size_t sz = PAGESIZE * 4)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3894,
						"comment": " Initializes a fiber object which is associated with a dynamic\n D function.\n\n Params:\n  dg = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  dg must not be null.\n",
						"deco": "FNbDFZvmZC4core6thread5Fiber",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							},
							{
								"name": "sz",
								"deco": "m",
								"default": "PAGESIZE * 4LU"
							}
						],
						"endline": 3903,
						"originalType": "nothrow (void delegate() dg, size_t sz = PAGESIZE * 4)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 3909,
						"comment": " Cleans up any remaining resources used by this object.\n",
						"deco": "FNbZv",
						"endline": 3924,
						"char": 5,
						"kind": "destructor"
					},
					{
						"endchar": 5,
						"name": "call",
						"line": 3951,
						"comment": "\n\n\n\n Transfers execution to this fiber object.  The calling context will be\n suspended until the fiber calls Fiber.yield() or until it terminates\n via an unhandled exception.\n\n Params:\n  rethrow = Rethrow any unhandled exception which may have caused this\n            fiber to terminate.\n\n In:\n  This fiber must be in state HOLD.\n\n Throws:\n  Any exception not handled by the joined thread.\n\n Returns:\n  Any exception not handled by this fiber if rethrow = false, null\n  otherwise.\n",
						"deco": "FE4core6thread5Fiber7RethrowZC6object9Throwable",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "E4core6thread5Fiber7Rethrow",
								"default": "cast(Rethrow)true"
							}
						],
						"endline": 3954,
						"originalType": "Throwable(Rethrow rethrow = Rethrow.yes)",
						"char": 21,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "call",
								"line": 3957,
								"type": "Throwable()",
								"endline": 3970,
								"char": 21,
								"kind": "function",
								"storageClass": [
									"final"
								]
							}
						],
						"name": "call",
						"line": 3957,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "E4core6thread5Fiber7Rethrow",
								"kind": "value"
							}
						],
						"char": 21,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "call",
						"line": 3974,
						"comment": "ditto\n",
						"deco": "FbZC6object9Throwable",
						"parameters": [
							{
								"name": "rethrow",
								"deco": "b"
							}
						],
						"endline": 3977,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"final",
							"deprecated"
						]
					},
					{
						"members": [],
						"name": "Rethrow",
						"line": 4012,
						"comment": "Flag to control rethrow behavior of $(D $(LREF call))\n",
						"baseDeco": "b",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 4027,
							"deco": "FNbZv",
							"endline": 4027,
							"char": 5,
							"kind": "function"
						},
						"name": "reset",
						"line": 4025,
						"comment": " Resets this fiber so that it may be re-used, optionally with a\n new function/delegate.  This routine should only be called for\n fibers that have terminated, as doing otherwise could result in\n scope-dependent functionality that is not executed.\n Stack-based classes, for example, may not be cleaned up\n properly if a fiber is reset before it has terminated.\n\n In:\n  This fiber must be in state TERM or HOLD.\n",
						"deco": "FNbZv",
						"endline": 4036,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 4039,
						"comment": "ditto\n",
						"deco": "FNbPFZvZv",
						"parameters": [
							{
								"name": "fn",
								"deco": "PFZv"
							}
						],
						"endline": 4044,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 4047,
						"comment": "ditto\n",
						"deco": "FNbDFZvZv",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFZv"
							}
						],
						"endline": 4052,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"members": [
							{
								"name": "HOLD",
								"line": 4068,
								"value": "0",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "EXEC",
								"line": 4069,
								"value": "1",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "TERM",
								"line": 4070,
								"value": "2",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "State",
						"line": 4066,
						"comment": "\n\n\n\n A fiber may occupy one of three states: HOLD, EXEC, and TERM.  The HOLD\n state applies to any fiber that is suspended and ready to be called.\n The EXEC state will be set for any fiber that is currently executing.\n And the TERM state is set when a fiber terminates.  Once a fiber\n terminates, it must be reset before it may be called again.\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"name": "state",
						"line": 4080,
						"comment": " Gets the current state of this fiber.\n\n Returns:\n  The state of this fiber as an enumerated value.\n",
						"deco": "xFNbNdZE4core6thread5Fiber5State",
						"endline": 4083,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 4094,
						"comment": "\n\n\n\n Forces a context switch to occur away from the calling fiber.\n",
						"deco": "FNbZv",
						"endline": 4106,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "yieldAndThrow",
						"line": 4119,
						"comment": " Forces a context switch to occur away from the calling fiber and then\n throws obj in the calling fiber.\n\n Params:\n  t = The object to throw.\n\n In:\n  t must not be null.\n",
						"deco": "FNbC6object9ThrowableZv",
						"parameters": [
							{
								"name": "t",
								"deco": "C6object9Throwable"
							}
						],
						"endline": 4137,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getThis",
						"line": 4153,
						"comment": "\n\n\n\n Provides a reference to the calling fiber or null if no fiber is\n currently active.\n\n Returns:\n  The fiber object representing the calling fiber or null if no fiber\n  is currently active within this thread. The result of deleting this object is undefined.\n",
						"deco": "FNbZC4core6thread5Fiber",
						"endline": 4156,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The thread module provides support for thread creation and management.\n\n Copyright: Copyright Sean Kelly 2005 - 2012.\n License: Distributed under the\n      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n    (See accompanying file LICENSE)\n Authors:   Sean Kelly, Walter Bright, Alex RÃ¸nne Petersen, Martin Nowak\n Source:    $(DRUNTIMESRC core/_thread.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/demangle.d",
		"name": "core.demangle",
		"members": [
			{
				"endchar": 1,
				"name": "demangle",
				"line": 1686,
				"comment": " Demangles D mangled names.  If it is not a D mangled name, it returns its\n argument name.\n\n Params:\n  buf = The string to demangle.\n  dst = An optional destination buffer.\n\n Returns:\n  The demangled name or the original string if the name is not a mangled D\n  name.\n",
				"deco": "FAxaAaZAa",
				"parameters": [
					{
						"name": "buf",
						"deco": "Axa"
					},
					{
						"name": "dst",
						"deco": "Aa",
						"default": "null"
					}
				],
				"endline": 1691,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "demangleType",
				"line": 1705,
				"comment": " Demangles a D mangled type.\n\n Params:\n  buf = The string to demangle.\n  dst = An optional destination buffer.\n\n Returns:\n  The demangled type name or the original string if the name is not a\n  mangled D type.\n",
				"deco": "FAxaAaZAa",
				"parameters": [
					{
						"name": "buf",
						"deco": "Axa"
					},
					{
						"name": "dst",
						"deco": "Aa",
						"default": "null"
					}
				],
				"endline": 1709,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mangle",
						"line": 1724,
						"type": "pure nothrow @safe char[](const(char)[] fqn, char[] dst = null)",
						"parameters": [
							{
								"name": "fqn",
								"type": "const(char)[]"
							},
							{
								"name": "dst",
								"type": "char[]",
								"default": "null"
							}
						],
						"endline": 1783,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "mangle",
				"line": 1724,
				"comment": " Mangles a D symbol.\n\n Params:\n  T = The type of the symbol.\n  fqn = The fully qualified name of the symbol.\n  dst = An optional destination buffer.\n\n Returns:\n  The mangled name for a symbols of type T and the given fully\n  qualified name.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1787_280)\n---\nassert(mangle!int(\"a.b\") == \"_D1a1bi\");\nassert(mangle!(char[])(\"test.foo\") == \"_D4test3fooAa\");\nassert(mangle!(int function(int))(\"a.b\") == \"_D1a1bPFiZi\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1787_280)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mangleFunc",
						"line": 1820,
						"type": "pure nothrow @safe char[](const(char)[] fqn, char[] dst = null)",
						"parameters": [
							{
								"name": "fqn",
								"type": "const(char)[]"
							},
							{
								"name": "dst",
								"type": "char[]",
								"default": "null"
							}
						],
						"endline": 1840,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "mangleFunc",
				"line": 1820,
				"comment": " Mangles a D function.\n\n Params:\n  T = function pointer type.\n  fqn = The fully qualified name of the symbol.\n  dst = An optional destination buffer.\n\n Returns:\n  The mangled name for a function with function pointer type T and\n  the given fully qualified name.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1844_282)\n---\nassert(mangleFunc!(int function(int))(\"a.b\") == \"_D1a1bFiZi\");\nassert(mangleFunc!(int function(Object))(\"object.Object.opEquals\") == \"_D6object6Object8opEqualsFC6ObjectZi\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1844_282)\n",
				"parameters": [
					{
						"name": "T",
						"type": "FT*",
						"kind": "type"
					},
					{
						"name": "FT",
						"kind": "type"
					}
				],
				"constraint": "is(FT == function)",
				"char": 8,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "mangleC",
				"line": 1912,
				"comment": " Mangles a C function or variable.\n\n Params:\n  sym = The C symbol to mangle.\n  dst = An optional destination buffer.\n\n Returns:\n  The mangled name for a C function or variable, i.e.\n  an underscore is prepended or not, depending on the\n  compiler/linker tool chain\n",
				"deco": "FAxaAaZAa",
				"parameters": [
					{
						"name": "sym",
						"deco": "Axa"
					},
					{
						"name": "dst",
						"deco": "Aa",
						"default": "null"
					}
				],
				"endline": 1928,
				"char": 8,
				"kind": "function"
			}
		],
		"comment": " The demangle module converts mangled D symbols to a representation similar\n to what would have existed in code.\n\n Copyright: Copyright Sean Kelly 2010 - 2014.\n License: Distributed under the\n      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n    (See accompanying file LICENSE)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/_demangle.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/runtime.d",
		"name": "core.runtime",
		"members": [
			{
				"name": "rt_loadLibrary",
				"line": 21,
				"comment": "C interface for Runtime.loadLibrary\n",
				"deco": "UxPaZPv",
				"parameters": [
					{
						"name": "name",
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) void*(const char* name)",
				"char": 18,
				"kind": "function"
			},
			{
				"name": "rt_unloadLibrary",
				"line": 25,
				"comment": "C interface for Runtime.unloadLibrary, returns 1/0 instead of bool\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pv"
					}
				],
				"char": 16,
				"kind": "function"
			},
			{
				"name": "rt_init",
				"line": 28,
				"comment": "C interface for Runtime.initialize, returns 1/0 instead of bool\n",
				"deco": "UZi",
				"char": 15,
				"kind": "function"
			},
			{
				"name": "rt_term",
				"line": 30,
				"comment": "C interface for Runtime.terminate, returns 1/0 instead of bool\n",
				"deco": "UZi",
				"char": 15,
				"kind": "function"
			},
			{
				"name": "CArgs",
				"line": 72,
				"comment": "\n\n\n\n Stores the unprocessed arguments supplied when the\n process was started.\n",
				"members": [
					{
						"offset": 0,
						"name": "argc",
						"line": 74,
						"comment": "The argument count.\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "argv",
						"line": 75,
						"comment": "The arguments as a C array of strings.\n",
						"deco": "PPa",
						"char": 12,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Runtime",
				"line": 82,
				"comment": " This struct encapsulates all functionality related to the underlying runtime\n module for the calling context.\n",
				"members": [
					{
						"endchar": 5,
						"name": "initialize",
						"line": 94,
						"comment": " Initializes the runtime.  This call is to be used in instances where the\n standard program initialization process is not executed.  This is most\n often in shared libraries or in libraries linked to a C program.\n If the runtime was already successfully initialized this returns true.\n Each call to initialize must be paired by a call to $(LREF terminate).\n\n Returns:\n  true if initialization succeeded or false if initialization failed.\n",
						"deco": "FZb",
						"endline": 97,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "terminate",
						"line": 115,
						"comment": " Terminates the runtime.  This call is to be used in instances where the\n standard program termination process will not be not executed.  This is\n most often in shared libraries or in libraries linked to a C program.\n If the runtime was not successfully initialized the function returns false.\n\n Returns:\n  true if termination succeeded or false if termination failed.\n",
						"deco": "FZb",
						"endline": 118,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "args",
						"line": 133,
						"comment": " Returns the arguments supplied when the process was started.\n\n Returns:\n  The arguments supplied when this process was started.\n",
						"deco": "FNdZAAya",
						"endline": 136,
						"char": 31,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "cArgs",
						"line": 159,
						"comment": " Returns the unprocessed C arguments supplied when the process was started.\n Use this when you need to supply argc and argv to C libraries.\n\n Returns:\n  A $(LREF CArgs) struct with the arguments supplied when this process was started.\n\n Example:\n ---\n import core.runtime;\n\n // A C library function requiring char** arguments\n extern(C) void initLibFoo(int argc, char** argv);\n\n void main()\n {\n     auto args = Runtime.cArgs;\n     initLibFoo(args.argc, args.argv);\n }\n ---\n",
						"deco": "FNdZS4core7runtime5CArgs",
						"endline": 162,
						"char": 28,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "loadLibrary",
								"line": 175,
								"type": "void*(in char[] name)",
								"parameters": [
									{
										"name": "name",
										"type": "char[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 216,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "loadLibrary",
						"line": 175,
						"comment": " Locates a dynamic library with the supplied library name and dynamically\n loads it into the caller's address space.  If the library contains a D\n runtime it will be integrated with the current runtime.\n\n Params:\n  name = The name of the dynamic library to load.\n\n Returns:\n  A reference to the library or null on error.\n",
						"parameters": [],
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "unloadLibrary",
								"line": 227,
								"type": "bool(void* p)",
								"parameters": [
									{
										"name": "p",
										"type": "void*"
									}
								],
								"endline": 230,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "unloadLibrary",
						"line": 227,
						"comment": " Unloads the dynamic library referenced by p.  If this library contains a\n D runtime then any necessary finalization or cleanup of that runtime\n will be performed.\n\n Params:\n  p = A reference to the library to unload.\n",
						"parameters": [],
						"char": 17,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "traceHandler",
						"line": 244,
						"comment": " Overrides the default trace mechanism with a user-supplied version.  A\n trace represents the context from which an exception was thrown, and the\n trace handler will be called when this occurs.  The pointer supplied to\n this routine indicates the base address from which tracing should occur.\n If the supplied pointer is null then the trace routine should determine\n an appropriate calling context from which to begin the trace.\n\n Params:\n  h = The new trace handler.  Set to null to use the default handler.\n",
						"deco": "FNdPFPvZC6object9Throwable9TraceInfoZv",
						"parameters": [
							{
								"name": "h",
								"deco": "PFPvZC6object9Throwable9TraceInfo"
							}
						],
						"endline": 247,
						"originalType": "@property void(TraceHandler h)",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "traceHandler",
						"line": 255,
						"comment": " Gets the current trace handler.\n\n Returns:\n  The current trace handler or null if none has been set.\n",
						"deco": "FNdZPFPvZC6object9Throwable9TraceInfo",
						"endline": 258,
						"originalType": "@property TraceHandler()",
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "collectHandler",
						"line": 271,
						"comment": " Overrides the default collect hander with a user-supplied version.  This\n routine will be called for each resource object that is finalized in a\n non-deterministic manner--typically during a garbage collection cycle.\n If the supplied routine returns true then the object's dtor will called\n as normal, but if the routine returns false than the dtor will not be\n called.  The default behavior is for all object dtors to be called.\n\n Params:\n  h = The new collect handler.  Set to null to use the default handler.\n",
						"deco": "FNdPFC6ObjectZbZv",
						"parameters": [
							{
								"name": "h",
								"deco": "PFC6ObjectZb"
							}
						],
						"endline": 274,
						"originalType": "@property void(CollectHandler h)",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "collectHandler",
						"line": 283,
						"comment": " Gets the current collect handler.\n\n Returns:\n  The current collect handler or null if none has been set.\n",
						"deco": "FNdZPFC6ObjectZb",
						"endline": 286,
						"originalType": "@property CollectHandler()",
						"char": 37,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "moduleUnitTester",
						"line": 298,
						"comment": " Overrides the default module unit tester with a user-supplied version.\n This routine will be called once on program initialization.  The return\n value of this routine indicates to the runtime whether the tests ran\n without error.\n\n Params:\n  h = The new unit tester.  Set to null to use the default unit tester.\n",
						"deco": "FNdPFZbZv",
						"parameters": [
							{
								"name": "h",
								"deco": "PFZb"
							}
						],
						"endline": 301,
						"originalType": "@property void(ModuleUnitTester h)",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "moduleUnitTester",
						"line": 310,
						"comment": " Gets the current module unit tester.\n\n Returns:\n  The current module unit tester handler or null if none has been set.\n",
						"deco": "FNdZPFZb",
						"endline": 313,
						"originalType": "@property ModuleUnitTester()",
						"char": 39,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "dmd_coverSourcePath",
				"line": 330,
				"comment": " Set source file path for coverage reports.\n\n Params:\n  path = The new path name.\n",
				"deco": "UAyaZv",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "dmd_coverDestPath",
				"line": 338,
				"comment": " Set output path for coverage reports.\n\n Params:\n  path = The new path name.\n",
				"deco": "UAyaZv",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "dmd_coverSetMerge",
				"line": 346,
				"comment": " Enable merging of coverage reports with existing data.\n\n Params:\n  flag = enable/disable coverage merge mode\n",
				"deco": "UbZv",
				"parameters": [
					{
						"name": "flag",
						"deco": "b"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "runModuleUnitTests",
				"line": 362,
				"comment": "\n\n\n\n This routine is called by the runtime to run module unit tests on startup.\n The user-supplied unit tester will be called if one has been supplied,\n otherwise all unit tests will be run in sequence.\n\n Returns:\n  true if execution should continue after testing is complete and false if\n  not.  Default behavior is to return true.\n",
				"deco": "UZb",
				"endline": 433,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "defaultTraceHandler",
				"line": 444,
				"comment": "\n\n\n\n\n",
				"deco": "FPvZC6object9Throwable9TraceInfo",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pv",
						"default": "null"
					}
				],
				"endline": 686,
				"originalType": "Throwable.TraceInfo(void* ptr = null)",
				"char": 21,
				"kind": "function"
			}
		],
		"comment": " The runtime module exposes information specific to the D runtime code.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/_runtime.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/checkedint.d",
		"name": "core.checkedint",
		"members": [
			{
				"endchar": 1,
				"name": "adds",
				"line": 49,
				"comment": " Add two signed integers, checking for overflow.\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfiiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "y",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 55,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "adds",
				"line": 76,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfllKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "y",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 83,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "addu",
				"line": 117,
				"comment": " Add two unsigned integers, checking for overflow (aka carry).\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfkkKbZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					},
					{
						"name": "y",
						"deco": "k"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 123,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "addu",
				"line": 144,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmmKbZm",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					},
					{
						"name": "y",
						"deco": "m"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 150,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subs",
				"line": 184,
				"comment": " Subtract two signed integers, checking for overflow.\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfiiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "y",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 190,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subs",
				"line": 211,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfllKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "y",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 219,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subu",
				"line": 252,
				"comment": " Subtract two unsigned integers, checking for overflow (aka borrow).\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfkkKbZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					},
					{
						"name": "y",
						"deco": "k"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 257,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "subu",
				"line": 279,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmmKbZm",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					},
					{
						"name": "y",
						"deco": "m"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 284,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "negs",
				"line": 315,
				"comment": " Negate an integer.\n\n Params:\n      x = operand\n      overflow = set if x cannot be negated, is not affected otherwise\n Returns:\n      the negation of x\n",
				"deco": "FNaNbNiNfiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 320,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "negs",
				"line": 338,
				"comment": "ditto\n",
				"deco": "FNaNbNiNflKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 343,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "muls",
				"line": 374,
				"comment": " Multiply two signed integers, checking for overflow.\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfiiKbZi",
				"parameters": [
					{
						"name": "x",
						"deco": "i"
					},
					{
						"name": "y",
						"deco": "i"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 380,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "muls",
				"line": 403,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfllKbZl",
				"parameters": [
					{
						"name": "x",
						"deco": "l"
					},
					{
						"name": "y",
						"deco": "l"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 409,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "mulu",
				"line": 445,
				"comment": " Multiply two unsigned integers, checking for overflow (aka carry).\n\n The overflow is sticky, meaning a sequence of operations can\n be done and overflow need only be checked at the end.\n Params:\n      x = left operand\n      y = right operand\n      overflow = set if an overflow occurs, is not affected otherwise\n Returns:\n      the sum\n",
				"deco": "FNaNbNiNfkkKbZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					},
					{
						"name": "y",
						"deco": "k"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 451,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "mulu",
				"line": 474,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmmKbZm",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					},
					{
						"name": "y",
						"deco": "m"
					},
					{
						"name": "overflow",
						"storageClass": [
							"ref"
						],
						"deco": "b"
					}
				],
				"endline": 480,
				"char": 7,
				"kind": "function"
			}
		],
		"comment": " This module implements integral arithmetic primitives that check\n for out-of-range results.\n\n Integral arithmetic operators operate on fixed width types.\n Results that are not representable in those fixed widths are silently\n truncated to fit.\n This module offers integral arithmetic primitives that produce the\n same results, but set an 'overflow' flag when such truncation occurs.\n The setting is sticky, meaning that numerous operations can be cascaded\n and then the flag need only be checked at the end.\n Whether the operation is signed or unsigned is indicated by an 's' or 'u'\n suffix, respectively. While this could be achieved without such suffixes by\n using overloading on the signedness of the types, the suffix makes it clear\n which is happening without needing to examine the types.\n\n While the generic versions of these functions are computationally expensive\n relative to the cost of the operation itself, compiler implementations are free\n to recognize them and generate equivalent and faster code.\n\n References: $(LINK2 http://blog.regehr.org/archives/1139, Fast Integer Overflow Checks)\n Copyright: Copyright (c) Walter Bright 2014.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Walter Bright\n Source:    $(DRUNTIMESRC core/_checkedint.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/bitop.d",
		"name": "core.bitop",
		"members": [
			{
				"name": "bsf",
				"line": 33,
				"comment": " Scans the bits in v starting with bit 0, looking\n for the first set bit.\n Returns:\n      The bit number of the first bit set.\n      The return value is undefined if v is zero.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL36_302)\n---\nassert(bsf(0x21) == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL36_302)\n",
				"deco": "FNaNbNiNfmZi",
				"parameters": [
					{
						"name": "v",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @safe int(size_t v)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "bsr",
				"line": 49,
				"comment": " Scans the bits in v from the most significant bit\n to the least significant bit, looking\n for the first set bit.\n Returns:\n      The bit number of the first bit set.\n      The return value is undefined if v is zero.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL52_303)\n---\nassert(bsr(0x21) == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL52_303)\n",
				"deco": "FNaNbNiNfmZi",
				"parameters": [
					{
						"name": "v",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @safe int(size_t v)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "bt",
				"line": 62,
				"comment": " Tests the bit.\n (No longer an intrisic - the compiler recognizes the patterns\n in the body.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL72_304)\n---\nsize_t[2] array;\n\narray[0] = 2;\narray[1] = 0x100;\n\nassert(bt(array.ptr, 1));\nassert(array[0] == 2);\nassert(array[1] == 0x100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL72_304)\n",
				"deco": "FNaNbNixPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "xPm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"endline": 70,
				"originalType": "pure nothrow @nogc @system int(in size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "btc",
				"line": 87,
				"comment": " Tests and complements the bit.\n",
				"deco": "FNaNbNiPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "Pm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @system int(size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "btr",
				"line": 93,
				"comment": " Tests and resets (sets to 0) the bit.\n",
				"deco": "FNaNbNiPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "Pm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @system int(size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "bts",
				"line": 109,
				"comment": " Tests and sets the bit.\n Params:\n p = a non-NULL pointer to an array of size_ts.\n bitnum = a bit number, starting with bit 0 of p[0],\n and progressing. It addresses bits like the expression:\n---\np[index / (size_t.sizeof*8)] & (1 << (index & ((size_t.sizeof*8) - 1)))\n---\n Returns:\n      A non-zero value if the bit was set, and a zero\n      if it was clear.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL112_305)\n---\nsize_t[2] array;\n\narray[0] = 2;\narray[1] = 0x100;\n\nassert(btc(array.ptr, 35) == 0);\nif (size_t.sizeof == 8)\n{\n    assert(array[0] == 0x8_0000_0002);\n    assert(array[1] == 0x100);\n}\nelse\n{\n    assert(array[0] == 2);\n    assert(array[1] == 0x108);\n}\n\nassert(btc(array.ptr, 35));\nassert(array[0] == 2);\nassert(array[1] == 0x100);\n\nassert(bts(array.ptr, 35) == 0);\nif (size_t.sizeof == 8)\n{\n    assert(array[0] == 0x8_0000_0002);\n    assert(array[1] == 0x100);\n}\nelse\n{\n    assert(array[0] == 2);\n    assert(array[1] == 0x108);\n}\n\nassert(btr(array.ptr, 35));\nassert(array[0] == 2);\nassert(array[1] == 0x100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL112_305)\n",
				"deco": "FNaNbNiPmmZi",
				"parameters": [
					{
						"name": "p",
						"deco": "Pm"
					},
					{
						"name": "bitnum",
						"deco": "m"
					}
				],
				"originalType": "pure nothrow @nogc @system int(size_t* p, size_t bitnum)",
				"char": 5,
				"kind": "function"
			},
			{
				"name": "bswap",
				"line": 157,
				"comment": " Swaps bytes in a 4 byte uint end-to-end, i.e. byte 0 becomes\n byte 3, byte 1 becomes byte 2, byte 2 becomes byte 1, byte 3\n becomes byte 0.\n",
				"deco": "FNaNbNiNfkZk",
				"parameters": [
					{
						"name": "v",
						"deco": "k"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "inp",
				"line": 164,
				"comment": " Reads I/O port at port_address.\n",
				"deco": "FNbNikZh",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					}
				],
				"char": 11,
				"kind": "function"
			},
			{
				"name": "inpw",
				"line": 170,
				"comment": " ditto\n",
				"deco": "FNbNikZt",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "inpl",
				"line": 176,
				"comment": " ditto\n",
				"deco": "FNbNikZk",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "outp",
				"line": 182,
				"comment": " Writes and returns value to I/O port at port_address.\n",
				"deco": "FNbNikhZh",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					},
					{
						"name": "value",
						"deco": "h"
					}
				],
				"char": 11,
				"kind": "function"
			},
			{
				"name": "outpw",
				"line": 188,
				"comment": " ditto\n",
				"deco": "FNbNiktZt",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					},
					{
						"name": "value",
						"deco": "t"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "outpl",
				"line": 194,
				"comment": " ditto\n",
				"deco": "FNbNikkZk",
				"parameters": [
					{
						"name": "port_address",
						"deco": "k"
					},
					{
						"name": "value",
						"deco": "k"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "_popcnt",
				"line": 204,
				"comment": " Calculates the number of set bits in a 32-bit integer\n using the X86 SSE4 POPCNT instruction.\n POPCNT is not available on all X86 CPUs.\n",
				"deco": "FNaNbNiNftZt",
				"parameters": [
					{
						"name": "x",
						"deco": "t"
					}
				],
				"char": 12,
				"kind": "function"
			},
			{
				"name": "_popcnt",
				"line": 206,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfkZi",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					}
				],
				"char": 9,
				"kind": "function"
			},
			{
				"name": "_popcnt",
				"line": 210,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfmZi",
				"parameters": [
					{
						"name": "x",
						"deco": "m"
					}
				],
				"char": 13,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 279,
				"comment": " Read/write value from/to the memory location indicated by ptr.\n\n These functions are recognized by the compiler, and calls to them are guaranteed\n to not be removed (as dead assignment elimination or presumed to have no effect)\n or reordered in the same thread.\n\n These reordering guarantees are only made with regards to other\n operations done through these functions; the compiler is free to reorder regular\n loads/stores with regards to loads/stores done through these functions.\n\n This is useful when dealing with memory-mapped I/O (MMIO) where a store can\n have an effect other than just writing a value, or where sequential loads\n with no intervening stores can retrieve\n different values from the same location due to external stores to the location.\n\n These functions will, when possible, do the load/store as a single operation. In\n general, this is possible when the size of the operation is less than or equal to\n $(D (void*).sizeof), although some targets may support larger operations. If the\n load/store cannot be done as a single operation, multiple smaller operations will be used.\n\n These are not to be conflated with atomic operations. They do not guarantee any\n atomicity. This may be provided by coincidence as a result of the instructions\n used on the target, but this should not be relied on for portable programs.\n Further, no memory fences are implied by these functions.\n They should not be used for communication between threads.\n They may be used to guarantee a write or read cycle occurs at a specified address.\n",
				"deco": "FNbNiNfPhZh",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Ph"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 280,
				"comment": "ditto\n",
				"deco": "FNbNiNfPtZt",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pt"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 281,
				"comment": "ditto\n",
				"deco": "FNbNiNfPkZk",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pk"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileLoad",
				"line": 282,
				"comment": "ditto\n",
				"deco": "FNbNiNfPmZm",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pm"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 284,
				"comment": "ditto\n",
				"deco": "FNbNiNfPhhZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Ph"
					},
					{
						"name": "value",
						"deco": "h"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 285,
				"comment": "ditto\n",
				"deco": "FNbNiNfPttZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pt"
					},
					{
						"name": "value",
						"deco": "t"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 286,
				"comment": "ditto\n",
				"deco": "FNbNiNfPkkZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pk"
					},
					{
						"name": "value",
						"deco": "k"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"name": "volatileStore",
				"line": 287,
				"comment": "ditto\n",
				"deco": "FNbNiNfPmmZv",
				"parameters": [
					{
						"name": "ptr",
						"deco": "Pm"
					},
					{
						"name": "value",
						"deco": "m"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "popcnt",
				"line": 307,
				"comment": "  Calculates the number of set bits in a 32-bit integer.\n",
				"deco": "FNaNbNiNfkZi",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					}
				],
				"endline": 336,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "bitswap",
				"line": 354,
				"comment": " Reverses the order of bits in a 32-bit integer.\n",
				"deco": "FNaNbNiNekZk",
				"parameters": [
					{
						"name": "x",
						"deco": "k"
					}
				],
				"endline": 408,
				"char": 15,
				"kind": "function"
			}
		],
		"comment": " This module contains a collection of bit-level operations.\n\n Copyright: Copyright Don Clugston 2005 - 2013.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Don Clugston, Sean Kelly, Walter Bright, Alex RÃ¸nne Petersen\n Source:    $(DRUNTIMESRC core/_bitop.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/time.d",
		"name": "core.time",
		"members": [
			{
				"members": [
					{
						"name": "normal",
						"line": 155,
						"value": "0",
						"comment": "        Use the normal clock.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bootTime",
						"line": 162,
						"value": "1",
						"comment": "        $(BLUE Linux-Only)\n\n        Uses $(D CLOCK_MONOTONIC_BOOTTIME).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "coarse",
						"line": 192,
						"value": "2",
						"comment": "        Use the coarse clock, not the normal one (e.g. on Linux, that would be\n        $(D CLOCK_REALTIME_COARSE) instead of $(D CLOCK_REALTIME) for\n        $(D clock_gettime) if a function is using the realtime clock). It's\n        generally faster to get the time with the coarse clock than the normal\n        clock, but it's less precise (e.g. 1 msec instead of 1 usec or 1 nsec).\n        Howeover, it $(I is) guaranteed to still have sub-second precision\n        (just not as high as with $(D ClockType.normal)).\n\n        On systems which do not support a coarser clock,\n        $(D MonoTimeImpl!(ClockType.coarse)) will internally use the same clock\n        as $(D Monotime) does, and $(D Clock.currTime!(ClockType.coarse)) will\n        use the same clock as $(D Clock.currTime). This is because the coarse\n        clock is doing the same thing as the normal clock (just at lower\n        precision), whereas some of the other clock types\n        (e.g. $(D ClockType.processCPUTime)) mean something fundamentally\n        different. So, treating those as $(D ClockType.normal) on systems where\n        they weren't natively supported would give misleading results.\n\n        Most programs should not use the coarse clock, exactly because it's\n        less precise, and most programs don't need to get the time often\n        enough to care, but for those rare programs that need to get the time\n        extremely frequently (e.g. hundreds of thousands of times a second) but\n        don't care about high precision, the coarse clock might be appropriate.\n\n        Currently, only Linux and FreeBSD support a coarser clock, and on other\n        platforms, it's treated as $(D ClockType.normal).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "precise",
						"line": 205,
						"value": "3",
						"comment": "        Uses a more precise clock than the normal one (which is already very\n        precise), but it takes longer to get the time. Similarly to\n        $(D ClockType.coarse), if it's used on a system that does not support a\n        more precise clock than the normal one, it's treated as equivalent to\n        $(D ClockType.normal).\n\n        Currently, only FreeBSD supports a more precise clock, where it uses\n        $(D CLOCK_MONOTONIC_PRECISE) for the monotonic time and\n        $(D CLOCK_REALTIME_PRECISE) for the wall clock time.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "processCPUTime",
						"line": 212,
						"value": "4",
						"comment": "        $(BLUE Linux-Only)\n\n        Uses $(D CLOCK_PROCESS_CPUTIME_ID).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "raw",
						"line": 219,
						"value": "5",
						"comment": "        $(BLUE Linux-Only)\n\n        Uses $(D CLOCK_MONOTONIC_RAW).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "second",
						"line": 242,
						"value": "6",
						"comment": "        Uses a clock that has a precision of one second (contrast to the coarse\n        clock, which has sub-second precision like the normal clock does).\n\n        FreeBSD is the only system which specifically has a clock set up for\n        this (it has $(D CLOCK_SECOND) to use with $(D clock_gettime) which\n        takes advantage of an in-kernel cached value), but on other systems, the\n        fastest function available will be used, and the resulting $(D SysTime)\n        will be rounded down to the second if the clock that was used gave the\n        time at a more precise resolution. So, it's guaranteed that the time\n        will be given at a precision of one second and it's likely the case that\n        will be faster than $(D ClockType.normal), since there tend to be\n        several options on a system to get the time at low resolutions, and they\n        tend to be faster than getting the time at high resolutions.\n\n        So, the primary difference between $(D ClockType.coarse) and\n        $(D ClockType.second) is that $(D ClockType.coarse) sacrifices some\n        precision in order to get speed but is still fairly precise, whereas\n        $(D ClockType.second) tries to be as fast as possible at the expense of\n        all sub-second precision.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "threadCPUTime",
						"line": 249,
						"value": "7",
						"comment": "        $(BLUE Linux-Only)\n\n        Uses $(D CLOCK_THREAD_CPUTIME_ID).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "uptime",
						"line": 256,
						"value": "8",
						"comment": "        $(BLUE FreeBSD-Only)\n\n        Uses $(D CLOCK_UPTIME).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "uptimeCoarse",
						"line": 263,
						"value": "9",
						"comment": "        $(BLUE FreeBSD-Only)\n\n        Uses $(D CLOCK_UPTIME_FAST).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "uptimePrecise",
						"line": 270,
						"value": "10",
						"comment": "        $(BLUE FreeBSD-Only)\n\n        Uses $(D CLOCK_UPTIME_PRECISE).\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ClockType",
				"line": 150,
				"comment": "    What type of clock to use with $(LREF MonoTime) / $(LREF MonoTimeImpl) or\n    $(D std.datetime.Clock.currTime). They default to $(D ClockType.normal),\n    and most programs do not need to ever deal with the others.\n\n    The other $(D ClockType)s are provided so that other clocks provided by the\n    underlying C, system calls can be used with $(LREF MonoTimeImpl) or\n    $(D std.datetime.Clock.currTime) without having to use the C API directly.\n\n    In the case of the monotonic time, $(LREF MonoTimeImpl) is templatized on\n    $(D ClockType), whereas with $(D std.datetime.Clock.currTime), its a runtime\n    argument, since in the case of the monotonic time, the type of the clock\n    affects the resolution of a $(LREF MonoTimeImpl) object, whereas with\n    $(XREF datetime, SysTime), its resolution is always hecto-nanoseconds\n    regardless of the source of the time.\n\n    $(D ClockType.normal), $(D ClockType.coarse), and $(D ClockType.precise)\n    work with both $(D Clock.currTime) and $(LREF MonoTimeImpl).\n    $(D ClockType.second) only works with $(D Clock.currTime). The others only\n    work with $(LREF MonoTimeImpl).\n",
				"baseDeco": "i",
				"char": 19,
				"kind": "enum"
			},
			{
				"name": "Duration",
				"line": 416,
				"comment": "    Represents a duration of time of weeks or less (kept internally as hnsecs).\n    (e.g. 22 days or 700 seconds).\n\n    It is used when representing a duration of time - such as how long to\n    sleep with $(CXREF thread, Thread.sleep).\n\n    In std.datetime, it is also used as the result of various arithmetic\n    operations on time points.\n\n    Use the $(LREF dur) function or one of its non-generic aliases to create\n    $(D Duration)s.\n\n    It's not possible to create a Duration of months or years, because the\n    variable number of days in a month or year makes it impossible to convert\n    between months or years and smaller units without a specific date. So,\n    nothing uses $(D Duration)s when dealing with months or years. Rather,\n    functions specific to months and years are defined. For instance,\n    $(XREF datetime, Date) has $(D add!\"years\") and $(D add!\"months\") for adding\n    years and months rather than creating a Duration of years or months and\n    adding that to a $(XREF datetime, Date). But Duration is used when dealing\n    with weeks or smaller.\n\n    Examples:\n--------------------\nassert(dur!\"days\"(12) == dur!\"hnsecs\"(10_368_000_000_000L));\nassert(dur!\"hnsecs\"(27) == dur!\"hnsecs\"(27));\nassert(std.datetime.Date(2010, 9, 7) + dur!\"days\"(5) ==\n       std.datetime.Date(2010, 9, 12));\n\nassert(days(-12) == dur!\"hnsecs\"(-10_368_000_000_000L));\nassert(hnsecs(-27) == dur!\"hnsecs\"(-27));\nassert(std.datetime.Date(2010, 9, 7) - std.datetime.Date(2010, 10, 3) ==\n       days(-26));\n--------------------\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1905_344)\n---\nimport core.time;\n\n// using the dur template\nauto numDays = dur!\"days\"(12);\n\n// using the days function\nnumDays = days(12);\n\n// alternatively using UFCS syntax\nnumDays = 12.days;\n\nauto myTime = 100.msecs + 20_000.usecs + 30_000.hnsecs;\nassert(myTime == 123.msecs);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1905_344)\n",
				"members": [
					{
						"endchar": 74,
						"name": "zero",
						"line": 426,
						"comment": "        A $(D Duration) of $(D 0). It's shorter than doing something like\n        $(D dur!\"seconds\"(0)) and more explicit than $(D Duration.init).\n",
						"deco": "FNaNbNdNiNfZS4core4time8Duration",
						"endline": 426,
						"char": 45,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 80,
						"name": "max",
						"line": 431,
						"comment": "        Largest $(D Duration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time8Duration",
						"endline": 431,
						"char": 45,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 80,
						"name": "min",
						"line": 436,
						"comment": "        Most negative $(D Duration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time8Duration",
						"endline": 436,
						"char": 45,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 461,
						"comment": "        Compares this $(D Duration) with the given $(D Duration).\n\n        Returns:\n            $(TABLE\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNiNfS4core4time8DurationZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 469,
						"char": 9,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 535,
								"type": "const nothrow @nogc Duration(D rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "D"
									}
								],
								"endline": 544,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 535,
						"comment": "        Adds or subtracts two durations.\n\n        The legal types of arithmetic for $(D Duration) using this operator are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD +) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD +) $(TD TickDuration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD TickDuration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            rhs = The duration to add to or subtract from this $(D Duration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(_Unqual!D == Duration) || is(_Unqual!D == TickDuration))",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 613,
								"type": "const nothrow @nogc Duration(D lhs)",
								"parameters": [
									{
										"name": "lhs",
										"type": "D"
									}
								],
								"endline": 618,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 613,
						"comment": "        Adds or subtracts two durations.\n\n        The legal types of arithmetic for $(D Duration) using this operator are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD +) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD TickDuration) $(TD -) $(TD Duration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            lhs = The $(D TickDuration) to add to this $(D Duration) or to\n                  subtract this $(D Duration) from.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && is(_Unqual!D == TickDuration)",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 666,
								"type": "nothrow @nogc ref Duration(in D rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 677,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 666,
						"comment": "        Adds or subtracts two durations as well as assigning the result to this\n        $(D Duration).\n\n        The legal types of arithmetic for $(D Duration) using this operator are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD +) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD Duration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD +) $(TD TickDuration) $(TD -->) $(TD Duration))\n        $(TR $(TD Duration) $(TD -) $(TD TickDuration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            rhs = The duration to add to or subtract from this $(D Duration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(_Unqual!D == Duration) || is(_Unqual!D == TickDuration))",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 767,
								"type": "const nothrow @nogc Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 771,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 767,
						"comment": "        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD *) $(TD long) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The value to multiply this $(D Duration) by.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"*\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 806,
								"type": "nothrow @nogc ref Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 812,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 806,
						"comment": "        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD *) $(TD long) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The value to multiply this $(D Duration) by.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"*\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 861,
								"type": "const Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 868,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 861,
						"comment": "        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD /) $(TD long) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The value to divide from this duration.\n\n        Throws:\n            $(D TimeException) if an attempt to divide by $(D 0) is made.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"/\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 912,
								"type": "ref Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 921,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 912,
						"comment": "        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD Duration) $(TD /) $(TD long) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The value to divide from this $(D Duration).\n\n        Throws:\n            $(D TimeException) if an attempt to divide by $(D 0) is made.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"/\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 969,
								"type": "const nothrow @nogc Duration(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 973,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 969,
						"comment": "        Multiplies an integral value and a $(D Duration).\n\n        The legal types of arithmetic for $(D Duration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD long) $(TD *) $(TD Duration) $(TD -->) $(TD Duration))\n        )\n\n        Params:\n            value = The number of units to multiply this $(D Duration) by.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"*\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 1000,
								"type": "const nothrow @nogc Duration()",
								"endline": 1004,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 1000,
						"comment": "        Returns the negation of this $(D Duration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 1026,
								"type": "const nothrow @nogc TickDuration()",
								"endline": 1030,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 1026,
						"comment": "        Returns a $(LREF TickDuration) with the same number of hnsecs as this\n        $(D Duration).\n        Note that the conventional way to convert between $(D Duration) and\n        $(D TickDuration) is using $(XREF conv, to), e.g.:\n        $(D duration.to!TickDuration())\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(_Unqual!T == TickDuration)",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "split",
										"line": 1109,
										"type": "const nothrow @nogc void(out Args args)",
										"parameters": [
											{
												"name": "args",
												"type": "Args",
												"storageClass": [
													"out"
												]
											}
										],
										"endline": 1120,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "split",
								"line": 1109,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "Args",
										"kind": "tuple"
									}
								],
								"constraint": "units.length != 0 && args.length == units.length && allAreMutableIntegralTypes!Args",
								"char": 14,
								"kind": "template"
							},
							{
								"endchar": 9,
								"name": "split",
								"line": 1123,
								"comment": " Ditto\n",
								"type": "const nothrow @nogc ()",
								"endline": 1165,
								"char": 14,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "split",
						"line": 1103,
						"comment": "        Splits out the Duration into the given units.\n\n        split takes the list of time units to split out as template arguments.\n        The time unit strings must be given in decreasing order. How it returns\n        the values for those units depends on the overload used.\n\n        The overload which accepts function arguments takes integral types in\n        the order that the time unit strings were given, and those integers are\n        passed by $(D ref). split assigns the values for the units to each\n        corresponding integer. Any integral type may be used, but no attempt is\n        made to prevent integer overflow, so don't use small integral types in\n        circumstances where the values for those units aren't likely to fit in\n        an integral type that small.\n\n        The overload with no arguments returns the values for the units in a\n        struct with members whose names are the same as the given time unit\n        strings. The members are all $(D long)s. This overload will also work\n        with no time strings being given, in which case $(I all) of the time\n        units from weeks through hnsecs will be provided (but no nsecs, since it\n        would always be $(D 0)).\n\n        For both overloads, the entire value of the Duration is split among the\n        units (rather than splitting the Duration across all units and then only\n        providing the values for the requested units), so if only one unit is\n        given, the result is equivalent to $(LREF total).\n\n        $(D \"nsecs\") is accepted by split, but $(D \"years\") and $(D \"months\")\n        are not.\n\n        For negative durations, all of the split values will be negative.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1204_324)\n---\n{\n    auto d = dur!\"days\"(12) + dur!\"minutes\"(7) + dur!\"usecs\"(501223);\n    long days;\n    int seconds;\n    short msecs;\n    d.split!(\"days\", \"seconds\", \"msecs\")(days, seconds, msecs);\n    assert(days == 12);\n    assert(seconds == 7 * 60);\n    assert(msecs == 501);\n\n    auto splitStruct = d.split!(\"days\", \"seconds\", \"msecs\")();\n    assert(splitStruct.days == 12);\n    assert(splitStruct.seconds == 7 * 60);\n    assert(splitStruct.msecs == 501);\n\n    auto fullSplitStruct = d.split();\n    assert(fullSplitStruct.weeks == 1);\n    assert(fullSplitStruct.days == 5);\n    assert(fullSplitStruct.hours == 0);\n    assert(fullSplitStruct.minutes == 7);\n    assert(fullSplitStruct.seconds == 0);\n    assert(fullSplitStruct.msecs == 501);\n    assert(fullSplitStruct.usecs == 223);\n    assert(fullSplitStruct.hnsecs == 0);\n\n    assert(d.split!\"minutes\"().minutes == d.total!\"minutes\");\n}\n\n{\n    auto d = dur!\"days\"(12);\n    assert(d.split!\"weeks\"().weeks == 1);\n    assert(d.split!\"days\"().days == 12);\n\n    assert(d.split().weeks == 1);\n    assert(d.split().days == 5);\n}\n\n{\n    auto d = dur!\"days\"(7) + dur!\"hnsecs\"(42);\n    assert(d.split!(\"seconds\", \"nsecs\")().nsecs == 4200);\n}\n\n{\n    auto d = dur!\"days\"(-7) + dur!\"hours\"(-9);\n    auto result = d.split!(\"days\", \"hours\")();\n    assert(result.days == -7);\n    assert(result.hours == -9);\n}\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1204_324)\n",
						"parameters": [
							{
								"name": "units",
								"kind": "tuple"
							}
						],
						"constraint": "allAreAcceptedUnits!(\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"msecs\", \"usecs\", \"hnsecs\", \"nsecs\")(units) && unitsAreInDescendingOrder(units)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "get",
								"line": 1409,
								"type": "const nothrow @nogc long()",
								"endline": 1423,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "get",
						"line": 1409,
						"comment": "        $(RED Deprecated. Please use $(LREF split) instead. Too frequently,\n              get or one of the individual unit getters is used when the\n              function that gave the desired behavior was $(LREF total). This\n              should make it more explicit and help prevent bugs. This function\n              will be removed in June 2015.)\n\n        Returns the number of the given units in this $(D Duration)\n        (minus the larger units).\n\n        $(D d.get!\"minutes\"()) is equivalent to $(D d.split().minutes).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1426_326)\n---\nassert(dur!\"weeks\"(12).get!\"weeks\" == 12);\nassert(dur!\"weeks\"(12).get!\"days\" == 0);\n\nassert(dur!\"days\"(13).get!\"weeks\" == 1);\nassert(dur!\"days\"(13).get!\"days\" == 6);\n\nassert(dur!\"hours\"(49).get!\"days\" == 2);\nassert(dur!\"hours\"(49).get!\"hours\" == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1426_326)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"weeks\" || units == \"days\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\"",
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "weeks",
						"line": 1465,
						"comment": "        $(RED Deprecated. Please use $(LREF split) instead. Too frequently,\n              $(LREF get) or one of the individual unit getters is used when the\n              function that gave the desired behavior was $(LREF total). This\n              should make it more explicit and help prevent bugs. This function\n              will be removed in June 2015.)\n\n        Returns the number of weeks in this $(D Duration)\n        (minus the larger units).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1471_328)\n---\nassert(dur!\"weeks\"(12).weeks == 12);\nassert(dur!\"days\"(13).weeks == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1471_328)\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 1468,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "days",
						"line": 1498,
						"comment": "        $(RED Deprecated. Please use $(LREF split) instead. Too frequently,\n              $(LREF get) or one of the individual unit getters is used when the\n              function that gave the desired behavior was $(LREF total). This\n              should make it more explicit and help prevent bugs. This function\n              will be removed in June 2015.)\n\n        Returns the number of days in this $(D Duration)\n        (minus the larger units).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1504_330)\n---\nassert(dur!\"weeks\"(12).days == 0);\nassert(dur!\"days\"(13).days == 6);\nassert(dur!\"hours\"(49).days == 2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1504_330)\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 1501,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "hours",
						"line": 1533,
						"comment": "        $(RED Deprecated. Please use $(LREF split) instead. Too frequently,\n              $(LREF get) or one of the individual unit getters is used when the\n              function that gave the desired behavior was $(LREF total). This\n              should make it more explicit and help prevent bugs. This function\n              will be removed in June 2015.)\n\n        Returns the number of hours in this $(D Duration)\n        (minus the larger units).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1539_332)\n---\nassert(dur!\"days\"(8).hours == 0);\nassert(dur!\"hours\"(49).hours == 1);\nassert(dur!\"minutes\"(121).hours == 2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1539_332)\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 1536,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "minutes",
						"line": 1568,
						"comment": "        $(RED Deprecated. Please use $(LREF split) instead. Too frequently,\n              $(LREF get) or one of the individual unit getters is used when the\n              function that gave the desired behavior was $(LREF total). This\n              should make it more explicit and help prevent bugs. This function\n              will be removed in June 2015.)\n\n        Returns the number of minutes in this $(D Duration)\n        (minus the larger units).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1574_334)\n---\nassert(dur!\"hours\"(47).minutes == 0);\nassert(dur!\"minutes\"(127).minutes == 7);\nassert(dur!\"seconds\"(121).minutes == 2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1574_334)\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 1571,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "seconds",
						"line": 1603,
						"comment": "        $(RED Deprecated. Please use $(LREF split) instead. Too frequently,\n              $(LREF get) or one of the individual unit getters is used when the\n              function that gave the desired behavior was $(LREF total). This\n              should make it more explicit and help prevent bugs. This function\n              will be removed in June 2015.)\n\n        Returns the number of seconds in this $(D Duration)\n        (minus the larger units).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1609_336)\n---\nassert(dur!\"minutes\"(47).seconds == 0);\nassert(dur!\"seconds\"(127).seconds == 7);\nassert(dur!\"msecs\"(1217).seconds == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1609_336)\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 1606,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "fracSec",
						"line": 1637,
						"comment": "        $(RED Deprecated. Please use $(LREF split) instead. Too frequently,\n              $(LREF get) or one of the individual unit getters is used when the\n              function that gave the desired behavior was $(LREF total). This\n              should make it more explicit and help prevent bugs. This function\n              will be removed in June 2015.)\n\n        Returns the fractional seconds past the second in this $(D Duration).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1650_338)\n---\nassert(dur!\"msecs\"(1000).fracSec == FracSec.from!\"msecs\"(0));\nassert(dur!\"msecs\"(1217).fracSec == FracSec.from!\"msecs\"(217));\nassert(dur!\"usecs\"(43).fracSec == FracSec.from!\"usecs\"(43));\nassert(dur!\"hnsecs\"(50_007).fracSec == FracSec.from!\"hnsecs\"(50_007));\nassert(dur!\"nsecs\"(62_127).fracSec == FracSec.from!\"nsecs\"(62_100));\n\nassert(dur!\"msecs\"(-1000).fracSec == FracSec.from!\"msecs\"(-0));\nassert(dur!\"msecs\"(-1217).fracSec == FracSec.from!\"msecs\"(-217));\nassert(dur!\"usecs\"(-43).fracSec == FracSec.from!\"usecs\"(-43));\nassert(dur!\"hnsecs\"(-50_007).fracSec == FracSec.from!\"hnsecs\"(-50_007));\nassert(dur!\"nsecs\"(-62_127).fracSec == FracSec.from!\"nsecs\"(-62_100));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1650_338)\n",
						"deco": "xFNaNbNdNfZS4core4time7FracSec",
						"endline": 1647,
						"char": 23,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "total",
								"line": 1688,
								"type": "const nothrow @nogc @property long()",
								"endline": 1703,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "total",
						"line": 1688,
						"comment": "        Returns the total number of the given units in this $(D Duration).\n        So, unlike $(D split), it does not strip out the larger units.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1706_340)\n---\nassert(dur!\"weeks\"(12).total!\"weeks\" == 12);\nassert(dur!\"weeks\"(12).total!\"days\" == 84);\n\nassert(dur!\"days\"(13).total!\"weeks\" == 1);\nassert(dur!\"days\"(13).total!\"days\" == 13);\n\nassert(dur!\"hours\"(49).total!\"days\" == 2);\nassert(dur!\"hours\"(49).total!\"hours\" == 49);\n\nassert(dur!\"nsecs\"(2007).total!\"hnsecs\" == 20);\nassert(dur!\"nsecs\"(2007).total!\"nsecs\" == 2000);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1706_340)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"weeks\" || units == \"days\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
						"char": 20,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1758,
						"comment": "        Converts this $(D Duration) to a $(D string).\n",
						"deco": "xFNaNbNfZAya",
						"endline": 1761,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isNegative",
						"line": 1816,
						"comment": "        Returns whether this $(D Duration) is negative.\n",
						"deco": "xFNaNbNdNiNfZb",
						"endline": 1819,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "to",
						"line": 1934,
						"type": "pure nothrow @nogc @safe T(D td)",
						"parameters": [
							{
								"name": "td",
								"type": "D"
							}
						],
						"endline": 1962,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "to",
				"line": 1934,
				"comment": "    Converts a $(D TickDuration) to the given units as either an integral\n    value or a floating point value.\n\n    Params:\n        units = The units to convert to. Accepts $(D \"seconds\") and smaller\n                only.\n        T     = The type to convert to (either an integral type or a\n                floating point type).\n\n        td    = The TickDuration to convert\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1965_345)\n---\nauto t = TickDuration.from!\"seconds\"(1000);\n\nlong tl = to!(\"seconds\",long)(t);\nassert(tl == 1000);\n\ndouble td = to!(\"seconds\",double)(t);\nassert(_abs(td - 1000) < 0.001);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1965_345)\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "D",
						"kind": "type"
					}
				],
				"constraint": "is(_Unqual!D == TickDuration) && (units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\")",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dur",
						"line": 2058,
						"type": "pure nothrow @nogc @safe Duration(long length)",
						"parameters": [
							{
								"name": "length",
								"deco": "l"
							}
						],
						"endline": 2070,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "dur",
				"line": 2058,
				"comment": "    These allow you to construct a $(D Duration) from the given time units\n    with the given length.\n\n    You can either use the generic function $(D dur) and give it the units as\n    a $(D string) or use the named aliases.\n\n    The possible values for units are $(D \"weeks\"), $(D \"days\"), $(D \"hours\"),\n    $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\") (milliseconds), $(D \"usecs\"),\n    (microseconds), $(D \"hnsecs\") (hecto-nanoseconds, i.e. 100 ns), and\n    $(D \"nsecs\").\n\n    Params:\n        units  = The time units of the $(D Duration) (e.g. $(D \"days\")).\n        length = The number of units in the $(D Duration).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2083_347)\n---\n// Generic\nassert(dur!\"weeks\"(142).total!\"weeks\" == 142);\nassert(dur!\"days\"(142).total!\"days\" == 142);\nassert(dur!\"hours\"(142).total!\"hours\" == 142);\nassert(dur!\"minutes\"(142).total!\"minutes\" == 142);\nassert(dur!\"seconds\"(142).total!\"seconds\" == 142);\nassert(dur!\"msecs\"(142).total!\"msecs\" == 142);\nassert(dur!\"usecs\"(142).total!\"usecs\" == 142);\nassert(dur!\"hnsecs\"(142).total!\"hnsecs\" == 142);\nassert(dur!\"nsecs\"(142).total!\"nsecs\" == 100);\n\n// Non-generic\nassert(weeks(142).total!\"weeks\" == 142);\nassert(days(142).total!\"days\" == 142);\nassert(hours(142).total!\"hours\" == 142);\nassert(minutes(142).total!\"minutes\" == 142);\nassert(seconds(142).total!\"seconds\" == 142);\nassert(msecs(142).total!\"msecs\" == 142);\nassert(usecs(142).total!\"usecs\" == 142);\nassert(hnsecs(142).total!\"hnsecs\" == 142);\nassert(nsecs(142).total!\"nsecs\" == 100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2083_347)\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"weeks\" || units == \"days\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
				"char": 10,
				"kind": "template"
			},
			{
				"name": "weeks",
				"line": 2072,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "days",
				"line": 2073,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "hours",
				"line": 2074,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "minutes",
				"line": 2075,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "seconds",
				"line": 2076,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "msecs",
				"line": 2077,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "usecs",
				"line": 2078,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "hnsecs",
				"line": 2079,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "nsecs",
				"line": 2080,
				"comment": "Ditto\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "MonoTime",
				"line": 2169,
				"comment": "    alias for $(D MonoTimeImpl) instantiated with $(D ClockType.normal). This is\n    what most programs should use. It's also what much of $(D MonoTimeImpl) uses\n    in its documentation (particularly in the examples), because that's what's\n    going to be used in most code.\n",
				"deco": "S4core4time42__T12MonoTimeImplVE4core4time9ClockTypei0Z12MonoTimeImpl",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "MonoTimeImpl",
						"line": 2218,
						"members": [
							{
								"endchar": 5,
								"name": "currTime",
								"line": 2269,
								"comment": "        The current time of the system's monotonic clock. This has no relation\n        to the wall clock time, as the wall clock time can be adjusted (e.g.\n        by NTP), whereas the monotonic clock always moves forward. The source\n        of the monotonic time is system-specific.\n\n        On Windows, $(D QueryPerformanceCounter) is used. On Mac OS X,\n        $(D mach_absolute_time) is used, while on other POSIX systems,\n        $(D clock_gettime) is used.\n\n        $(RED Warning): On some systems, the monotonic clock may stop counting\n                        when the computer goes to sleep or hibernates. So, the\n                        monotonic clock may indicate less time than has actually\n                        passed if that occurs. This is known to happen on\n                        Mac OS X. It has not been tested whether it occurs on\n                        either Windows or Linux.\n",
								"type": "nothrow @nogc @property @trusted MonoTimeImpl()",
								"endline": 2299,
								"char": 35,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 51,
								"name": "zero",
								"line": 2308,
								"comment": "        A $(D MonoTime) of $(D 0) ticks. It's provided to be consistent with\n        $(D Duration.zero), and it's more explicit than $(D MonoTime.init).\n",
								"type": "MonoTimeImpl()",
								"endline": 2308,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 57,
								"name": "max",
								"line": 2313,
								"comment": "        Largest $(D MonoTime) possible.\n",
								"type": "MonoTimeImpl()",
								"endline": 2313,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 57,
								"name": "min",
								"line": 2318,
								"comment": "        Most negative $(D MonoTime) possible.\n",
								"type": "MonoTimeImpl()",
								"endline": 2318,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opCmp",
								"line": 2342,
								"comment": "        Compares this MonoTime with the given MonoTime.\n\n        Returns:\n            $(BOOKTABLE,\n                $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n                $(TR $(TD this == rhs) $(TD 0))\n                $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
								"type": "const pure nothrow @nogc int(MonoTimeImpl rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "MonoTimeImpl"
									}
								],
								"endline": 2347,
								"char": 9,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 2431,
										"type": "const pure nothrow @nogc Duration(MonoTimeImpl rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "MonoTimeImpl"
											}
										],
										"endline": 2436,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 2431,
								"comment": "        Subtracting two MonoTimes results in a $(LREF Duration) representing\n        the amount of time which elapsed between them.\n\n        The primary way that programs should time how long something takes is to\n        do\n--------------------\nMonoTime before = MonoTime.currTime;\n// do stuff\nMonoTime after = MonoTime.currTime;\n\n// How long it took.\nDuration timeElapsed = after - before;\n--------------------\n        or to use a wrapper (such as a stop watch type) which does that.\n\n        $(RED Warning):\n            Because $(LREF Duration) is in hnsecs, whereas MonoTime is in system\n            ticks, it's usually the case that this assertion will fail\n--------------------\nauto before = MonoTime.currTime;\n// do stuff\nauto after = MonoTime.currTime;\nauto timeElapsed = after - before;\nassert(before + timeElapsed == after).\n--------------------\n\n            This is generally fine, and by its very nature, converting from\n            system ticks to any type of seconds (hnsecs, nsecs, etc.) will\n            introduce rounding errors, but if code needs to avoid any of the\n            small rounding errors introduced by conversion, then it needs to use\n            MonoTime's $(D ticks) property and keep all calculations in ticks\n            rather than using $(LREF Duration).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"-\"",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 2487,
										"type": "const pure nothrow @nogc MonoTimeImpl(Duration rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Duration"
											}
										],
										"endline": 2492,
										"char": 18,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 2487,
								"comment": "        Adding or subtracting a $(LREF Duration) to/from a MonoTime results in\n        a MonoTime which is adjusted by that amount.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"+\" || op == \"-\"",
								"char": 18,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2533,
										"type": "pure nothrow @nogc ref MonoTimeImpl(Duration rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Duration"
											}
										],
										"endline": 2539,
										"char": 22,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2533,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"+\" || op == \"-\"",
								"char": 22,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "ticks",
								"line": 2587,
								"comment": "        The number of ticks in the monotonic time.\n\n        Most programs should not use this directly, but it's exposed for those\n        few programs that need it.\n\n        The main reasons that a program might need to use ticks directly is if\n        the system clock has higher precision than hnsecs, and the program needs\n        that higher precision, or if the program needs to avoid the rounding\n        errors caused by converting to hnsecs.\n",
								"type": "const pure nothrow @nogc @property long()",
								"endline": 2590,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "ticksPerSecond",
								"line": 2606,
								"comment": "        The number of ticks that MonoTime has per second - i.e. the resolution\n        or frequency of the system's monotonic clock.\n\n        e.g. if the system clock had a resolution of microseconds, then\n        ticksPerSecond would be $(D 1_000_000).\n",
								"type": "pure nothrow @nogc @property long()",
								"endline": 2609,
								"char": 27,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 2618,
								"comment": "\n",
								"type": "const pure nothrow string()",
								"endline": 2625,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "MonoTimeImpl",
				"line": 2218,
				"comment": "    Represents a timestamp of the system's monotonic clock.\n\n    A monotonic clock is one which always goes forward and never moves\n    backwards, unlike the system's wall clock time (as represented by\n    $(XREF datetime, SysTime)). The system's wall clock time can be adjusted\n    by the user or by the system itself via services such as NTP, so it is\n    unreliable to use the wall clock time for timing. Timers which use the wall\n    clock time could easily end up never going off due to changes made to the\n    wall clock time or otherwise waiting for a different period of time than\n    that specified by the programmer. However, because the monotonic clock\n    always increases at a fixed rate and is not affected by adjustments to the\n    wall clock time, it is ideal for use with timers or anything which requires\n    high precision timing.\n\n    So, MonoTime should be used for anything involving timers and timing,\n    whereas $(XREF datetime, SysTime) should be used when the wall clock time\n    is required.\n\n    The monotonic clock has no relation to wall clock time. Rather, it holds\n    its time as the number of ticks of the clock which have occurred since the\n    clock started (typically when the system booted up). So, to determine how\n    much time has passed between two points in time, one monotonic time is\n    subtracted from the other to determine the number of ticks which occurred\n    between the two points of time, and those ticks are divided by the number of\n    ticks that occur every second (as represented by MonoTime.ticksPerSecond)\n    to get a meaningful duration of time. Normally, MonoTime does these\n    calculations for the programmer, but the $(D ticks) and $(D ticksPerSecond)\n    properties are provided for those who require direct access to the system\n    ticks. The normal way that MonoTime would be used is\n\n--------------------\n    MonoTime before = MonoTime.currTime;\n    // do stuff...\n    MonoTime after = MonoTime.currTime;\n    Duration timeElapsed = after - before;\n--------------------\n\n    $(LREF MonoTime) is an alias to $(D MonoTimeImpl!(ClockType.normal)) and is\n    what most programs should use for the monotonic clock, so that's what is\n    used in most of $(D MonoTimeImpl)'s documentation. But $(D MonoTimeImpl)\n    can be instantiated with other clock types for those rare programs that need\n    it.\n\n    See_Also:\n        $(LREF ClockType)\n",
				"parameters": [
					{
						"name": "clockType",
						"deco": "E4core4time9ClockType",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "convClockFreq",
				"line": 2827,
				"comment": "    Converts the given time from one clock frequency/resolution to another.\n\n    See_Also:\n        $(LREF ticksToNSecs)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2839_359)\n---\n// one tick is one second -> one tick is a hecto-nanosecond\nassert(convClockFreq(45, 1, 10_000_000) == 450_000_000);\n\n// one tick is one microsecond -> one tick is a millisecond\nassert(convClockFreq(9029, 1_000_000, 1_000) == 9);\n\n// one tick is 1/3_515_654 of a second -> 1/1_001_010 of a second\nassert(convClockFreq(912_319, 3_515_654, 1_001_010) == 259_764);\n\n// one tick is 1/MonoTime.ticksPerSecond -> one tick is a nanosecond\n// Equivalent to ticksToNSecs\nauto nsecs = convClockFreq(1982, MonoTime.ticksPerSecond, 1_000_000_000);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2839_359)\n",
				"deco": "FNaNbNiNflllZl",
				"parameters": [
					{
						"name": "ticks",
						"deco": "l"
					},
					{
						"name": "srcTicksPerSecond",
						"deco": "l"
					},
					{
						"name": "dstTicksPerSecond",
						"deco": "l"
					}
				],
				"endline": 2836,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ticksToNSecs",
				"line": 2925,
				"comment": "    Convenience wrapper around $(LREF convClockFreq) which converts ticks at\n    a clock frequency of $(D MonoTime.ticksPerSecond) to nanoseconds.\n\n    It's primarily of use when $(D MonoTime.ticksPerSecond) is greater than\n    hecto-nanosecond resolution, and an application needs a higher precision\n    than hecto-nanoceconds.\n\n    See_Also:\n        $(LREF convClockFreq)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2931_361)\n---\nauto before = MonoTime.currTime;\n// do stuff\nauto after = MonoTime.currTime;\nauto diffInTicks = after.ticks - before.ticks;\nauto diffInNSecs = ticksToNSecs(diffInTicks);\nassert(diffInNSecs == convClockFreq(diffInTicks, MonoTime.ticksPerSecond, 1_000_000_000));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2931_361)\n",
				"deco": "FNaNbNiNflZl",
				"parameters": [
					{
						"name": "ticks",
						"deco": "l"
					}
				],
				"endline": 2928,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nsecsToTicks",
				"line": 2945,
				"comment": "    The reverse of $(LREF ticksToNSecs).\n",
				"deco": "FNaNbNiNflZl",
				"parameters": [
					{
						"name": "ticks",
						"deco": "l"
					}
				],
				"endline": 2948,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "TickDuration",
				"line": 2975,
				"comment": "    $(RED Warning: TickDuration will be deprecated in the near future (once all\n          uses of it in Phobos have been deprecated). Please use\n          $(LREF MonoTime) for the cases where a monotonic timestamp is needed\n          and $(LREF Duration) when a duration is needed, rather than using\n          TickDuration. It has been decided that TickDuration is too confusing\n          (e.g. it conflates a monotonic timestamp and a duration in monotonic\n           clock ticks) and that having multiple duration types is too awkward\n          and confusing.)\n\n   Represents a duration of time in system clock ticks.\n\n   The system clock ticks are the ticks of the system clock at the highest\n   precision that the system provides.\n",
				"members": [
					{
						"name": "ticksPerSec",
						"line": 2985,
						"comment": "       The number of ticks that the system clock has in one second.\n\n       If $(D ticksPerSec) is $(D 0), then then $(D TickDuration) failed to\n       get the value of $(D ticksPerSec) on the current system, and\n       $(D TickDuration) is not going to work. That would be highly abnormal\n       though.\n",
						"deco": "yl",
						"originalType": "long",
						"char": 27,
						"kind": "variable",
						"storageClass": [
							"static",
							"immutable"
						]
					},
					{
						"name": "appOrigin",
						"line": 2992,
						"comment": "        The tick of the system clock (as a $(D TickDuration)) when the\n        application started.\n",
						"deco": "yS4core4time12TickDuration",
						"originalType": "TickDuration",
						"char": 35,
						"kind": "variable",
						"storageClass": [
							"static",
							"immutable"
						]
					},
					{
						"endchar": 51,
						"name": "zero",
						"line": 3002,
						"comment": "        It's the same as $(D TickDuration(0)), but it's provided to be\n        consistent with $(D Duration) and $(D FracSec), which provide $(D zero)\n        properties.\n",
						"deco": "FNaNbNdNiNfZS4core4time12TickDuration",
						"endline": 3002,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 57,
						"name": "max",
						"line": 3007,
						"comment": "        Largest $(D TickDuration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time12TickDuration",
						"endline": 3007,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 57,
						"name": "min",
						"line": 3012,
						"comment": "        Most negative $(D TickDuration) possible.\n",
						"deco": "FNaNbNdNiNfZS4core4time12TickDuration",
						"endline": 3012,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"offset": 0,
						"name": "length",
						"line": 3089,
						"comment": "       The number of system ticks in this $(D TickDuration).\n\n       You can convert this $(D length) into the number of seconds by dividing\n       it by $(D ticksPerSec) (or using one the appropriate property function\n       to do it).\n",
						"deco": "l",
						"char": 10,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "seconds",
						"line": 3094,
						"comment": "        Returns the total number of seconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3097,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "msecs",
						"line": 3117,
						"comment": "        Returns the total number of milliseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3120,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "usecs",
						"line": 3126,
						"comment": "        Returns the total number of microseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3129,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hnsecs",
						"line": 3135,
						"comment": "        Returns the total number of hecto-nanoseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3138,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "nsecs",
						"line": 3144,
						"comment": "        Returns the total number of nanoseconds in this $(D TickDuration).\n",
						"deco": "xFNaNbNdNiNfZl",
						"endline": 3147,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "from",
								"line": 3158,
								"type": "pure nothrow @nogc @safe TickDuration(long length)",
								"parameters": [
									{
										"name": "length",
										"deco": "l"
									}
								],
								"endline": 3168,
								"char": 25,
								"kind": "function"
							}
						],
						"name": "from",
						"line": 3158,
						"comment": "        This allows you to construct a $(D TickDuration) from the given time\n        units with the given length.\n\n        Params:\n            units  = The time units of the $(D TickDuration) (e.g. $(D \"msecs\")).\n            length = The number of units in the $(D TickDuration).\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"seconds\" || units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
						"char": 25,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 3194,
								"type": "const pure nothrow @nogc @safe Duration()",
								"endline": 3198,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 3194,
						"comment": "        Returns a $(LREF Duration) with the same number of hnsecs as this\n        $(D TickDuration).\n        Note that the conventional way to convert between $(D TickDuration)\n        and $(D Duration) is using $(XREF conv, to), e.g.:\n        $(D tickDuration.to!Duration())\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(_Unqual!T == Duration)",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 3243,
								"type": "pure nothrow @nogc ref @safe TickDuration(TickDuration rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "TickDuration"
									}
								],
								"endline": 3248,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 3243,
						"comment": "        Adds or subtracts two $(D TickDuration)s as well as assigning the result\n        to this $(D TickDuration).\n\n        The legal types of arithmetic for $(D TickDuration) using this operator\n        are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD +=) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD -=) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            rhs = The $(D TickDuration) to add to or subtract from this\n                  $(D $(D TickDuration)).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 22,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 3289,
								"type": "const pure nothrow @nogc @safe TickDuration(TickDuration rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "TickDuration"
									}
								],
								"endline": 3293,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 3289,
						"comment": "        Adds or subtracts two $(D TickDuration)s.\n\n        The legal types of arithmetic for $(D TickDuration) using this operator\n        are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD +) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD -) $(TD TickDuration) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            rhs = The $(D TickDuration) to add to or subtract from this\n                  $(D TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 3310,
								"type": "const pure nothrow @nogc @safe TickDuration()",
								"endline": 3314,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 3310,
						"comment": "        Returns the negation of this $(D TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 18,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 3332,
						"comment": "       operator overloading \"<, >, <=, >=\"\n",
						"deco": "xFNaNbNiNfS4core4time12TickDurationZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S4core4time12TickDuration"
							}
						],
						"endline": 3335,
						"char": 9,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 3388,
								"type": "pure nothrow @nogc @safe void(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3393,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 3388,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD *) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD *) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this duration.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"*\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 3436,
								"type": "pure @safe void(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3444,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 3436,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD /) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD /) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this $(D TickDuration).\n\n        Throws:\n            $(D TimeException) if an attempt to divide by $(D 0) is made.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"/\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 3486,
								"type": "const pure nothrow @nogc @safe TickDuration(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3491,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 3486,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD *) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD *) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this $(D TickDuration).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"*\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 3522,
								"type": "const pure @safe TickDuration(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 3530,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 3522,
						"comment": "        The legal types of arithmetic for $(D TickDuration) using this operator\n        overload are\n\n        $(TABLE\n        $(TR $(TD TickDuration) $(TD /) $(TD long) $(TD -->) $(TD TickDuration))\n        $(TR $(TD TickDuration) $(TD /) $(TD floating point) $(TD -->) $(TD TickDuration))\n        )\n\n        Params:\n            value = The value to divide from this $(D TickDuration).\n\n        Throws:\n            $(D TimeException) if an attempt to divide by $(D 0) is made.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"/\" && (__traits(isIntegral, T) || __traits(isFloating, T))",
						"char": 18,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3552,
						"comment": "        Params:\n            ticks = The number of ticks in the TickDuration.\n",
						"deco": "FNaNbNcNiNflZS4core4time12TickDuration",
						"parameters": [
							{
								"name": "ticks",
								"deco": "l"
							}
						],
						"endline": 3555,
						"originalType": "pure nothrow @nogc ref @safe (long ticks)",
						"char": 30,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "currSystemTick",
						"line": 3589,
						"comment": "        The current system tick. The number of ticks per second varies from\n        system to system. $(D currSystemTick) uses a monotonic clock, so it's\n        intended for precision timing by comparing relative time values, not for\n        getting the current system time.\n\n        On Windows, $(D QueryPerformanceCounter) is used. On Mac OS X,\n        $(D mach_absolute_time) is used, while on other Posix systems,\n        $(D clock_gettime) is used. If $(D mach_absolute_time) or\n        $(D clock_gettime) is unavailable, then Posix systems use\n        $(D gettimeofday) (the decision is made when $(D TickDuration) is\n        compiled), which unfortunately, is not monotonic, but if\n        $(D mach_absolute_time) and $(D clock_gettime) aren't available, then\n        $(D gettimeofday) is the the best that there is.\n\n        $(RED Warning):\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or on Linux.\n\n        Throws:\n            $(D TimeException) if it fails to get the time.\n",
						"deco": "FNbNdNiNeZS4core4time12TickDuration",
						"endline": 3634,
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "convert",
						"line": 3655,
						"type": "pure nothrow @nogc @safe long(long value)",
						"parameters": [
							{
								"name": "value",
								"deco": "l"
							}
						],
						"endline": 3702,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "convert",
				"line": 3655,
				"comment": "    Generic way of converting between two time units. Conversions to smaller\n    units use truncating division. Years and months can be converted to each\n    other, small units can be converted to each other, but years and months\n    cannot be converted to or from smaller units (due to the varying number\n    of days in a month or year).\n\n    Params:\n        from  = The units of time to convert from.\n        to    = The units of time to convert to.\n        value = The value to convert.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3705_379)\n---\nassert(convert!(\"years\", \"months\")(1) == 12);\nassert(convert!(\"months\", \"years\")(12) == 1);\n\nassert(convert!(\"weeks\", \"days\")(1) == 7);\nassert(convert!(\"hours\", \"seconds\")(1) == 3600);\nassert(convert!(\"seconds\", \"days\")(1) == 0);\nassert(convert!(\"seconds\", \"days\")(86_400) == 1);\n\nassert(convert!(\"nsecs\", \"nsecs\")(1) == 1);\nassert(convert!(\"nsecs\", \"hnsecs\")(1) == 0);\nassert(convert!(\"hnsecs\", \"nsecs\")(1) == 100);\nassert(convert!(\"nsecs\", \"seconds\")(1) == 0);\nassert(convert!(\"seconds\", \"nsecs\")(1) == 1_000_000_000);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3705_379)\n",
				"parameters": [
					{
						"name": "from",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "to",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "(from == \"weeks\" || from == \"days\" || from == \"hours\" || from == \"minutes\" || from == \"seconds\" || from == \"msecs\" || from == \"usecs\" || from == \"hnsecs\" || from == \"nsecs\") && (to == \"weeks\" || to == \"days\" || to == \"hours\" || to == \"minutes\" || to == \"seconds\" || to == \"msecs\" || to == \"usecs\" || to == \"hnsecs\" || to == \"nsecs\") || (from == \"years\" || from == \"months\") && (to == \"years\" || to == \"months\")",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "FracSec",
				"line": 3813,
				"comment": "    Represents fractional seconds.\n\n    This is the portion of the time which is smaller than a second and it cannot\n    hold values which would be greater than or equal to a second (or less than\n    or equal to a negative second).\n\n    It holds hnsecs internally, but you can create it using either milliseconds,\n    microseconds, or hnsecs. What it does is allow for a simple way to set or\n    adjust the fractional seconds portion of a $(D Duration) or a\n    $(XREF datetime, SysTime) without having to worry about whether you're\n    dealing with milliseconds, microseconds, or hnsecs.\n\n    $(D FracSec)'s functions which take time unit strings do accept\n    $(D \"nsecs\"), but because the resolution of $(D Duration) and\n    $(XREF datetime, SysTime) is hnsecs, you don't actually get precision higher\n    than hnsecs. $(D \"nsecs\") is accepted merely for convenience. Any values\n    given as nsecs will be converted to hnsecs using $(D convert) (which uses\n    truncating division when converting to smaller units).\n",
				"members": [
					{
						"endchar": 72,
						"name": "zero",
						"line": 3823,
						"comment": "        A $(D FracSec) of $(D 0). It's shorter than doing something like\n        $(D FracSec.from!\"msecs\"(0)) and more explicit than $(D FracSec.init).\n",
						"deco": "FNaNbNdNiNfZS4core4time7FracSec",
						"endline": 3823,
						"char": 44,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "from",
								"line": 3844,
								"type": "FracSec(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 3853,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "from",
						"line": 3844,
						"comment": "        Create a $(D FracSec) from the given units ($(D \"msecs\"), $(D \"usecs\"),\n        or $(D \"hnsecs\")).\n\n        Params:\n            units = The units to create a FracSec from.\n            value = The number of the given units passed the second.\n\n        Throws:\n            $(D TimeException) if the given value would result in a $(D FracSec)\n            greater than or equal to $(D 1) second or less than or equal to\n            $(D -1) seconds.\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\" || units == \"nsecs\"",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 3895,
								"type": "const nothrow @nogc FracSec()",
								"endline": 3899,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 3895,
						"comment": "        Returns the negation of this $(D FracSec).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 13,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "msecs",
						"line": 3917,
						"comment": "        The value of this $(D FracSec) as milliseconds.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 3920,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "msecs",
						"line": 3949,
						"comment": "        The value of this $(D FracSec) as milliseconds.\n\n        Params:\n            milliseconds = The number of milliseconds passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "milliseconds",
								"deco": "i"
							}
						],
						"endline": 3954,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "usecs",
						"line": 3989,
						"comment": "        The value of this $(D FracSec) as microseconds.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 3992,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "usecs",
						"line": 4021,
						"comment": "        The value of this $(D FracSec) as microseconds.\n\n        Params:\n            microseconds = The number of microseconds passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "microseconds",
								"deco": "i"
							}
						],
						"endline": 4026,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hnsecs",
						"line": 4062,
						"comment": "        The value of this $(D FracSec) as hnsecs.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 4065,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hnsecs",
						"line": 4094,
						"comment": "        The value of this $(D FracSec) as hnsecs.\n\n        Params:\n            hnsecs = The number of hnsecs passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "hnsecs",
								"deco": "i"
							}
						],
						"endline": 4098,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "nsecs",
						"line": 4138,
						"comment": "        The value of this $(D FracSec) as nsecs.\n\n        Note that this does not give you any greater precision\n        than getting the value of this $(D FracSec) as hnsecs.\n",
						"deco": "xFNaNbNdNiNfZi",
						"endline": 4141,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "nsecs",
						"line": 4173,
						"comment": "        The value of this $(D FracSec) as nsecs.\n\n        Note that this does not give you any greater precision\n        than setting the value of this $(D FracSec) as hnsecs.\n\n        Params:\n            nsecs = The number of nsecs passed the second.\n\n        Throws:\n            $(D TimeException) if the given value is not less than $(D 1) second\n            and greater than a $(D -1) seconds.\n",
						"deco": "FNaNdNflZv",
						"parameters": [
							{
								"name": "nsecs",
								"deco": "l"
							}
						],
						"endline": 4178,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 4232,
						"comment": "        Converts this $(D TickDuration) to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 4235,
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 4403,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC4core4time13TimeException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 4406,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 4415,
						"comment": "        Params:\n            msg  = The message for the exception.\n            next = The previous exception in the chain of exceptions.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC4core4time13TimeException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 4418,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "TimeException",
				"line": 4394,
				"comment": "    Exception type used by core.time.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "abs",
				"line": 4446,
				"comment": "    Returns the absolute value of a duration.\n",
				"deco": "FNaNbNiNfS4core4time8DurationZS4core4time8Duration",
				"parameters": [
					{
						"name": "duration",
						"deco": "S4core4time8Duration"
					}
				],
				"endline": 4449,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "abs",
				"line": 4452,
				"comment": " Ditto\n",
				"deco": "FNaNbNiNfS4core4time12TickDurationZS4core4time12TickDuration",
				"parameters": [
					{
						"name": "duration",
						"deco": "S4core4time12TickDuration"
					}
				],
				"endline": 4455,
				"char": 14,
				"kind": "function"
			}
		],
		"comment": "    Module containing core time functionality, such as $(LREF Duration) (which\n    represents a duration of time) or $(LREF MonoTime) (which represents a\n    timestamp of the system's monotonic clock).\n\n    Various functions take a string (or strings) to represent a unit of time\n    (e.g. $(D convert!(\"days\", \"hours\")(numDays))). The valid strings to use\n    with such functions are \"years\", \"months\", \"weeks\", \"days\", \"hours\",\n    \"minutes\", \"seconds\", \"msecs\" (milliseconds), \"usecs\" (microseconds),\n    \"hnsecs\" (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There\n    are a few functions that also allow \"nsecs\", but very little actually\n    has precision greater than hnsecs.\n\n    $(BOOKTABLE Cheat Sheet,\n    $(TR $(TH Symbol) $(TH Description))\n    $(LEADINGROW Types)\n    $(TR $(TDNW $(LREF Duration)) $(TD Represents a duration of time of weeks\n    or less (kept internally as hnsecs). (e.g. 22 days or 700 seconds).))\n    $(TR $(TDNW $(LREF TickDuration)) $(TD Represents a duration of time in\n    system clock ticks, using the highest precision that the system provides.))\n    $(TR $(TDNW $(LREF MonoTime)) $(TD Represents a monotonic timestamp in\n    system clock ticks, using the highest precision that the system provides.))\n    $(TR $(TDNW $(LREF FracSec)) $(TD Represents fractional seconds\n    (portions of time smaller than a second).))\n    $(LEADINGROW Functions)\n    $(TR $(TDNW $(LREF convert)) $(TD Generic way of converting between two time\n    units.))\n    $(TR $(TDNW $(LREF dur)) $(TD Allows constructing a $(LREF Duration) from\n    the given time units with the given length.))\n    $(TR $(TDNW $(LREF weeks)$(NBSP)$(LREF days)$(NBSP)$(LREF hours)$(BR)\n    $(LREF minutes)$(NBSP)$(LREF seconds)$(NBSP)$(LREF msecs)$(BR)\n    $(LREF usecs)$(NBSP)$(LREF hnsecs)$(NBSP)$(LREF nsecs))\n    $(TD Convenience aliases for $(LREF dur).))\n    $(TR $(TDNW $(LREF abs)) $(TD Returns the absolute value of a duration.))\n    )\n\n    $(BOOKTABLE Conversions,\n    $(TR $(TH )\n     $(TH From $(LREF Duration))\n     $(TH From $(LREF TickDuration))\n     $(TH From $(LREF FracSec))\n     $(TH From units)\n    )\n    $(TR $(TD $(B To $(LREF Duration)))\n     $(TD -)\n     $(TD $(D tickDuration.)$(SXREF conv, to)$(D !Duration()))\n     $(TD -)\n     $(TD $(D dur!\"msecs\"(5)) or $(D 5.msecs()))\n    )\n    $(TR $(TD $(B To $(LREF TickDuration)))\n     $(TD $(D duration.)$(SXREF conv, to)$(D !TickDuration()))\n     $(TD -)\n     $(TD -)\n     $(TD $(D TickDuration.from!\"msecs\"(msecs)))\n    )\n    $(TR $(TD $(B To $(LREF FracSec)))\n     $(TD $(D duration.fracSec))\n     $(TD -)\n     $(TD -)\n     $(TD $(D FracSec.from!\"msecs\"(msecs)))\n    )\n    $(TR $(TD $(B To units))\n     $(TD $(D duration.total!\"days\"))\n     $(TD $(D tickDuration.msecs))\n     $(TD $(D fracSec.msecs))\n     $(TD $(D convert!(\"days\", \"msecs\")(msecs)))\n    ))\n\n    Copyright: Copyright 2010 - 2012\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Jonathan M Davis and Kato Shoichi\n    Source:    $(DRUNTIMESRC core/_time.d)\n    Macros:\n    NBSP=&nbsp;\n    SXREF=<a href=\"std_$1.html#$2\">$(D $2)</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/exception.d",
		"name": "core.exception",
		"members": [
			{
				"members": [],
				"name": "RangeError",
				"line": 17,
				"comment": " Thrown on a range error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "AssertError",
				"line": 48,
				"comment": " Thrown on an assert error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "FinalizeError",
				"line": 121,
				"comment": " Thrown on finalize error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "HiddenFuncError",
				"line": 189,
				"comment": " Thrown on hidden function error.\n $(RED Deprecated.\n   This feature is not longer part of the language.)\n",
				"base": "object.Error",
				"char": 12,
				"kind": "class"
			},
			{
				"members": [],
				"name": "OutOfMemoryError",
				"line": 213,
				"comment": " Thrown on an out of memory error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "InvalidMemoryOperationError",
				"line": 254,
				"comment": " Thrown on an invalid memory operation.\n\n An invalid memory operation error occurs in circumstances when the garbage\n collector has detected an operation it cannot reliably handle. The default\n D GC is not re-entrant, so this can happen due to allocations done from\n within finalizers called during a garbage collection cycle.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "SwitchError",
				"line": 290,
				"comment": " Thrown on a switch error.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "UnicodeException",
				"line": 321,
				"comment": " Thrown on a unicode conversion error.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "AssertHandler",
				"line": 369,
				"comment": "Gets/sets assert hander. null means the default handler is used.\n",
				"deco": "PFNbAyamAyaZv",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "assertHandler",
				"line": 372,
				"comment": "ditto\n",
				"deco": "FNbNdNiNeZPFNbAyamAyaZv",
				"endline": 375,
				"originalType": "nothrow @nogc @property @trusted AssertHandler()",
				"char": 25,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "assertHandler",
				"line": 378,
				"comment": "ditto\n",
				"deco": "FNbNdNiNePFNbAyamAyaZvZv",
				"parameters": [
					{
						"name": "handler",
						"deco": "PFNbAyamAyaZv"
					}
				],
				"endline": 381,
				"originalType": "nothrow @nogc @property @trusted void(AssertHandler handler)",
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "setAssertHandler",
				"line": 391,
				"comment": " Overrides the default assert hander with a user-supplied version.\n $(RED Deprecated.\n   Please use $(LREF assertHandler) instead.)\n\n Params:\n  h = The new assert handler.  Set to null to use the default handler.\n",
				"deco": "FNbNiNePFNbAyamAyaZvZv",
				"parameters": [
					{
						"name": "h",
						"deco": "PFNbAyamAyaZv"
					}
				],
				"endline": 394,
				"originalType": "nothrow @nogc @trusted void(AssertHandler h)",
				"char": 17,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"endchar": 1,
				"name": "onAssertError",
				"line": 411,
				"comment": "\n\n\n\n A callback for assert errors in D.  The user-supplied assert handler will\n be called if one has been supplied, otherwise an $(LREF AssertError) will be\n thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n",
				"deco": "UNbAyamZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 416,
				"originalType": "nothrow extern (C) void(string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onAssertErrorMsg",
				"line": 429,
				"comment": " A callback for assert errors in D.  The user-supplied assert handler will\n be called if one has been supplied, otherwise an $(LREF AssertError) will be\n thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n  msg  = An error message supplied by the user.\n",
				"deco": "UNbAyamAyaZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "m"
					},
					{
						"name": "msg",
						"deco": "Aya"
					}
				],
				"endline": 434,
				"originalType": "nothrow extern (C) void(string file, size_t line, string msg)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onUnittestErrorMsg",
				"line": 447,
				"comment": " A callback for unittest errors in D.  The user-supplied unittest handler\n will be called if one has been supplied, otherwise the error will be\n written to stderr.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n  msg  = An error message supplied by the user.\n",
				"deco": "UNbAyamAyaZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "m"
					},
					{
						"name": "msg",
						"deco": "Aya"
					}
				],
				"endline": 450,
				"originalType": "nothrow extern (C) void(string file, size_t line, string msg)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onRangeError",
				"line": 467,
				"comment": "\n\n\n\n A callback for array bounds errors in D.  A $(LREF RangeError) will be thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF RangeError).\n",
				"deco": "UNaNbNfAyamZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 470,
				"originalType": "pure nothrow @safe extern (C) void(string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onFinalizeError",
				"line": 485,
				"comment": " A callback for finalize errors in D.  A $(LREF FinalizeError) will be thrown.\n\n Params:\n  info = The TypeInfo instance for the object that failed finalization.\n  e = The exception thrown during finalization.\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF FinalizeError).\n",
				"deco": "UNbNeC8TypeInfoC6object9ThrowableAyamZv",
				"parameters": [
					{
						"name": "info",
						"deco": "C8TypeInfo"
					},
					{
						"name": "e",
						"deco": "C6object9Throwable"
					},
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 495,
				"originalType": "nothrow @trusted extern (C) void(TypeInfo info, Throwable e, string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onHiddenFuncError",
				"line": 507,
				"comment": " A callback for hidden function errors in D.  A $(LREF HiddenFuncError) will be\n thrown.\n $(RED Deprecated.\n   This feature is not longer part of the language.)\n\n Throws:\n  $(LREF HiddenFuncError).\n",
				"deco": "UNaNbNfC6ObjectZv",
				"parameters": [
					{
						"name": "o",
						"deco": "C6Object"
					}
				],
				"endline": 510,
				"char": 28,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"endchar": 1,
				"name": "onOutOfMemoryError",
				"line": 520,
				"comment": " A callback for out of memory errors in D.  An $(LREF OutOfMemoryError) will be\n thrown.\n\n Throws:\n  $(LREF OutOfMemoryError).\n",
				"deco": "UNaNbNiNePvZv",
				"parameters": [
					{
						"name": "pretend_sideffect",
						"deco": "Pv",
						"default": "null"
					}
				],
				"endline": 525,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onInvalidMemoryOperationError",
				"line": 535,
				"comment": " A callback for invalid memory operations in D.  An\n $(LREF InvalidMemoryOperationError) will be thrown.\n\n Throws:\n  $(LREF InvalidMemoryOperationError).\n",
				"deco": "UNaNbNiNePvZv",
				"parameters": [
					{
						"name": "pretend_sideffect",
						"deco": "Pv",
						"default": "null"
					}
				],
				"endline": 541,
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onSwitchError",
				"line": 554,
				"comment": " A callback for switch errors in D.  A $(LREF SwitchError) will be thrown.\n\n Params:\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF SwitchError).\n",
				"deco": "UNaNbNfAyamZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 557,
				"originalType": "pure nothrow @safe extern (C) void(string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "onUnicodeError",
				"line": 572,
				"comment": " A callback for unicode errors in D.  A $(LREF UnicodeException) will be thrown.\n\n Params:\n  msg = Information about the error.\n  idx = String index where this error was detected.\n  file = The name of the file that signaled this error.\n  line = The line number on which this error occurred.\n\n Throws:\n  $(LREF UnicodeException).\n",
				"deco": "UNaNfAyamAyamZv",
				"parameters": [
					{
						"name": "msg",
						"deco": "Aya"
					},
					{
						"name": "idx",
						"deco": "m"
					},
					{
						"name": "file",
						"deco": "Aya",
						"default": "__FILE__"
					},
					{
						"name": "line",
						"deco": "m",
						"default": "cast(ulong)__LINE__"
					}
				],
				"endline": 575,
				"originalType": "pure @safe extern (C) void(string msg, size_t idx, string file = __FILE__, size_t line = __LINE__)",
				"char": 17,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_assertm",
				"line": 601,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 604,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_assert_msg",
				"line": 606,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyaAyakZv",
				"parameters": [
					{
						"name": "msg",
						"deco": "Aya"
					},
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 609,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_assert",
				"line": 611,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyakZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 614,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_unittestm",
				"line": 618,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 621,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_unittest_msg",
				"line": 623,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyaAyakZv",
				"parameters": [
					{
						"name": "msg",
						"deco": "Aya"
					},
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 626,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_unittest",
				"line": 628,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyakZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 631,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_array_bounds",
				"line": 635,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 638,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_arraybounds",
				"line": 640,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UAyakZv",
				"parameters": [
					{
						"name": "file",
						"deco": "Aya"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 643,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "_d_switch_error",
				"line": 647,
				"comment": " These functions must be defined for any D program linked\n against this library.\n\n Function calls to these are generated by the compiler and inserted into\n the object code.\n",
				"deco": "UPyS6object10ModuleInfokZv",
				"parameters": [
					{
						"name": "m",
						"deco": "PyS6object10ModuleInfo"
					},
					{
						"name": "line",
						"deco": "k"
					}
				],
				"endline": 650,
				"char": 10,
				"kind": "function"
			}
		],
		"comment": " The exception module defines all system-level exceptions and provides a\n mechanism to alter system-level error handling.\n\n Copyright: Copyright Sean Kelly 2005 - 2013.\n License: Distributed under the\n      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n    (See accompanying file LICENSE)\n Authors:   Sean Kelly and Jonathan M Davis\n Source:    $(DRUNTIMESRC core/_exception.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/vararg.d",
		"name": "core.vararg",
		"members": [],
		"comment": " The vararg module is intended to facilitate vararg manipulation in D.\n It should be interface compatible with the C module \"stdarg,\" and the\n two modules may share a common implementation if possible (as is done\n here).\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Walter Bright, Hauke Duden\n Source:    $(DRUNTIMESRC core/_vararg.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/condition.d",
		"name": "core.sync.condition",
		"members": [
			{
				"name": "Condition",
				"line": 56,
				"comment": "\n\n\n\n This class represents a condition variable as conceived by C.A.R. Hoare.  As\n per Mesa type monitors however, \"signal\" has been replaced with \"notify\" to\n indicate that control is not transferred to the waiter when a notification\n is sent.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 72,
						"comment": "\n\n\n\n Initializes a condition object which is associated with the supplied\n mutex object.\n\n Params:\n  m = The mutex with which this condition will be associated.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNbNfC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"endline": 96,
						"originalType": "nothrow @safe (Mutex m)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "mutex",
						"line": 128,
						"comment": "\n\n\n\n Gets the mutex associated with this condition.\n\n Returns:\n  The mutex associated with this condition.\n",
						"deco": "FNdZC4core4sync5mutex5Mutex",
						"endline": 131,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "wait",
						"line": 151,
						"comment": "\n\n\n\n Wait until notified.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 163,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 184,
							"deco": "FZv",
							"endline": 184,
							"char": 5,
							"kind": "function"
						},
						"name": "wait",
						"line": 182,
						"comment": " Suspends the calling thread until a notification occurs or until the\n supplied time period has elapsed.\n\n Params:\n  val = The time to wait.\n\n In:\n  val must be non-negative.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if notified before the timeout and false if not.\n",
						"deco": "FS4core4time8DurationZb",
						"parameters": [
							{
								"name": "val",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 216,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "notify",
						"line": 225,
						"comment": " Notifies one waiter.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 237,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "notifyAll",
						"line": 246,
						"comment": " Notifies all waiters.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 258,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The condition module provides a primitive for synchronized condition\n checking.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_condition.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/barrier.d",
		"name": "core.sync.barrier",
		"members": [
			{
				"name": "Barrier",
				"line": 41,
				"comment": "\n\n\n\n This class represents a barrier across which threads may only travel in\n groups of a specific size.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 58,
						"comment": "\n\n\n\n Initializes a barrier object which releases threads in groups of limit\n in size.\n\n Params:\n  limit = The number of waiting threads to release in unison.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FkZC4core4sync7barrier7Barrier",
						"parameters": [
							{
								"name": "limit",
								"deco": "k"
							}
						],
						"endline": 70,
						"originalType": "(uint limit)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "wait",
						"line": 84,
						"comment": "\n\n\n\n Wait for the pre-determined number of threads and then proceed.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 99,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The barrier module provides a primitive for synchronizing the progress of\n a group of threads.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_barrier.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/semaphore.d",
		"name": "core.sync.semaphore",
		"members": [
			{
				"name": "Semaphore",
				"line": 60,
				"comment": "\n\n\n\n This class represents a general counting semaphore as concieved by Edsger\n Dijkstra.  As per Mesa type monitors however, \"signal\" has been replaced\n with \"notify\" to indicate that control is not transferred to the waiter when\n a notification is sent.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 76,
						"comment": "\n\n\n\n Initializes a semaphore object with the specified initial count.\n\n Params:\n  count = The initial count for the semaphore.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FkZC4core4sync9semaphore9Semaphore",
						"parameters": [
							{
								"name": "count",
								"deco": "k",
								"default": "0u"
							}
						],
						"endline": 96,
						"originalType": "(uint count = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "wait",
						"line": 131,
						"comment": "\n\n\n\n Wait until the current count is above zero, then atomically decrement\n the count by one and return.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 161,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 184,
							"deco": "FZv",
							"endline": 184,
							"char": 5,
							"kind": "function"
						},
						"name": "wait",
						"line": 182,
						"comment": " Suspends the calling thread until the current count moves above zero or\n until the supplied time period has elapsed.  If the count moves above\n zero in this interval, then atomically decrement the count by one and\n return true.  Otherwise, return false.\n\n Params:\n  period = The time to wait.\n\n In:\n  period must be non-negative.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if notified before the timeout and false if not.\n",
						"deco": "FS4core4time8DurationZb",
						"parameters": [
							{
								"name": "period",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 256,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "notify",
						"line": 266,
						"comment": " Atomically increment the current count by one.  This will notify one\n waiter, if there are any in the queue.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FZv",
						"endline": 285,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "tryWait",
						"line": 298,
						"comment": " If the current count is equal to zero, return.  Otherwise, atomically\n decrement the count by one and return true.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if the count was above zero and false if not.\n",
						"deco": "FZb",
						"endline": 328,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The semaphore module provides a general use semaphore for synchronization.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_semaphore.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/rwmutex.d",
		"name": "core.sync.rwmutex",
		"members": [
			{
				"name": "ReadWriteMutex",
				"line": 51,
				"comment": "\n\n\n\n This class represents a mutex that allows any number of readers to enter,\n but when a writer enters, all other readers and writers are blocked.\n\n Please note that this mutex is not recursive and is intended to guard access\n to data only.  Also, no deadlock checking is in place because doing so would\n require dynamic memory allocation, which would reduce performance by an\n unacceptable amount.  As a result, any attempt to recursively acquire this\n mutex may well deadlock the caller, particularly if a write lock is acquired\n while holding a read lock, or vice-versa.  In practice, this should not be\n an issue however, because it is uncommon to call deeply into unknown code\n while holding a lock that simply protects data.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL394_421)\n---\nimport core.atomic, core.thread, core.sync.semaphore;\n\nstatic void runTest(ReadWriteMutex.Policy policy)\n{\n    scope mutex = new ReadWriteMutex(policy);\n    scope rdSemA = new Semaphore, rdSemB = new Semaphore,\n          wrSemA = new Semaphore, wrSemB = new Semaphore;\n    shared size_t numReaders, numWriters;\n\n    void readerFn()\n    {\n        synchronized (mutex.reader)\n        {\n            atomicOp!\"+=\"(numReaders, 1);\n            rdSemA.notify();\n            rdSemB.wait();\n            atomicOp!\"-=\"(numReaders, 1);\n        }\n    }\n\n    void writerFn()\n    {\n        synchronized (mutex.writer)\n        {\n            atomicOp!\"+=\"(numWriters, 1);\n            wrSemA.notify();\n            wrSemB.wait();\n            atomicOp!\"-=\"(numWriters, 1);\n        }\n    }\n\n    void waitQueued(size_t queuedReaders, size_t queuedWriters)\n    {\n        for (;;)\n        {\n            synchronized (mutex.m_commonMutex)\n            {\n                if (mutex.m_numQueuedReaders == queuedReaders &&\n                    mutex.m_numQueuedWriters == queuedWriters)\n                    break;\n            }\n            Thread.yield();\n        }\n    }\n\n    scope group = new ThreadGroup;\n\n    // 2 simultaneous readers\n    group.create(&readerFn); group.create(&readerFn);\n    rdSemA.wait(); rdSemA.wait();\n    assert(numReaders == 2);\n    rdSemB.notify(); rdSemB.notify();\n    group.joinAll();\n    assert(numReaders == 0);\n    foreach (t; group) group.remove(t);\n\n    // 1 writer at a time\n    group.create(&writerFn); group.create(&writerFn);\n    wrSemA.wait();\n    assert(!wrSemA.tryWait());\n    assert(numWriters == 1);\n    wrSemB.notify();\n    wrSemA.wait();\n    assert(numWriters == 1);\n    wrSemB.notify();\n    group.joinAll();\n    assert(numWriters == 0);\n    foreach (t; group) group.remove(t);\n\n    // reader and writer are mutually exclusive\n    group.create(&readerFn);\n    rdSemA.wait();\n    group.create(&writerFn);\n    waitQueued(0, 1);\n    assert(!wrSemA.tryWait());\n    assert(numReaders == 1 && numWriters == 0);\n    rdSemB.notify();\n    wrSemA.wait();\n    assert(numReaders == 0 && numWriters == 1);\n    wrSemB.notify();\n    group.joinAll();\n    assert(numReaders == 0 && numWriters == 0);\n    foreach (t; group) group.remove(t);\n\n    // writer and reader are mutually exclusive\n    group.create(&writerFn);\n    wrSemA.wait();\n    group.create(&readerFn);\n    waitQueued(1, 0);\n    assert(!rdSemA.tryWait());\n    assert(numReaders == 0 && numWriters == 1);\n    wrSemB.notify();\n    rdSemA.wait();\n    assert(numReaders == 1 && numWriters == 0);\n    rdSemB.notify();\n    group.joinAll();\n    assert(numReaders == 0 && numWriters == 0);\n    foreach (t; group) group.remove(t);\n\n    // policy determines whether queued reader or writers progress first\n    group.create(&writerFn);\n    wrSemA.wait();\n    group.create(&readerFn);\n    group.create(&writerFn);\n    waitQueued(1, 1);\n    assert(numReaders == 0 && numWriters == 1);\n    wrSemB.notify();\n\n    if (policy == ReadWriteMutex.Policy.PREFER_READERS)\n    {\n        rdSemA.wait();\n        assert(numReaders == 1 && numWriters == 0);\n        rdSemB.notify();\n        wrSemA.wait();\n        assert(numReaders == 0 && numWriters == 1);\n        wrSemB.notify();\n    }\n    else if (policy == ReadWriteMutex.Policy.PREFER_WRITERS)\n    {\n        wrSemA.wait();\n        assert(numReaders == 0 && numWriters == 1);\n        wrSemB.notify();\n        rdSemA.wait();\n        assert(numReaders == 1 && numWriters == 0);\n        rdSemB.notify();\n    }\n    group.joinAll();\n    assert(numReaders == 0 && numWriters == 0);\n    foreach (t; group) group.remove(t);\n}\nrunTest(ReadWriteMutex.Policy.PREFER_READERS);\nrunTest(ReadWriteMutex.Policy.PREFER_WRITERS);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL394_421)\n",
				"members": [
					{
						"members": [
							{
								"name": "PREFER_READERS",
								"line": 70,
								"value": "0",
								"comment": "Readers get preference.  This may starve writers.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "PREFER_WRITERS",
								"line": 71,
								"value": "1",
								"comment": "Writers get preference.  This may starve readers.\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Policy",
						"line": 68,
						"comment": " Defines the policy used by this mutex.  Currently, two policies are\n defined.\n\n The first will queue writers until no readers hold the mutex, then\n pass the writers through one at a time.  If a reader acquires the mutex\n while there are still writers queued, the reader will take precedence.\n\n The second will queue readers if there are any writers queued.  Writers\n are passed through one at a time, and once there are no writers present,\n all queued readers will be alerted.\n\n Future policies may offer a more even balance between reader and writer\n precedence.\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 89,
						"comment": "\n\n\n\n Initializes a read/write mutex object with the supplied policy.\n\n Params:\n  policy = The policy to use.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FE4core4sync7rwmutex14ReadWriteMutex6PolicyZC4core4sync7rwmutex14ReadWriteMutex",
						"parameters": [
							{
								"name": "policy",
								"deco": "E4core4sync7rwmutex14ReadWriteMutex6Policy",
								"default": "cast(Policy)1"
							}
						],
						"endline": 106,
						"originalType": "(Policy policy = Policy.PREFER_WRITERS)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "policy",
						"line": 119,
						"comment": "\n\n\n\n Gets the policy used by this mutex.\n\n Returns:\n  The policy used by this mutex.\n",
						"deco": "FNdZE4core4sync7rwmutex14ReadWriteMutex6Policy",
						"endline": 122,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "reader",
						"line": 136,
						"comment": "\n\n\n\n Gets an object representing the reader lock for the associated mutex.\n\n Returns:\n  A reader sub-mutex.\n",
						"deco": "FNdZC4core4sync7rwmutex14ReadWriteMutex6Reader",
						"endline": 139,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "writer",
						"line": 148,
						"comment": " Gets an object representing the writer lock for the associated mutex.\n\n Returns:\n  A writer sub-mutex.\n",
						"deco": "FNdZC4core4sync7rwmutex14ReadWriteMutex6Writer",
						"endline": 151,
						"char": 22,
						"kind": "function"
					},
					{
						"interfaces": [
							"object.Object.Monitor"
						],
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 169,
								"comment": " Initializes a read/write mutex reader proxy object.\n",
								"deco": "FZC4core4sync7rwmutex14ReadWriteMutex6Reader",
								"endline": 173,
								"originalType": "()",
								"char": 9,
								"kind": "constructor"
							},
							{
								"endchar": 9,
								"name": "lock",
								"line": 179,
								"comment": " Acquires a read lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 190,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.lock"
								]
							},
							{
								"endchar": 9,
								"name": "unlock",
								"line": 196,
								"comment": " Releases a read lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 206,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.unlock"
								]
							},
							{
								"endchar": 9,
								"name": "tryLock",
								"line": 217,
								"comment": " Attempts to acquire a read lock on the enclosing mutex.  If one can\n be obtained without blocking, the lock is acquired and true is\n returned.  If not, the lock is not acquired and false is returned.\n\n Returns:\n  true if the lock was acquired and false if not.\n",
								"deco": "FZb",
								"endline": 226,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "Reader",
						"line": 163,
						"comment": "\n\n\n\n This class can be considered a mutex in its own right, and is used to\n negotiate a read lock for the enclosing mutex.\n",
						"char": 5,
						"kind": "class"
					},
					{
						"interfaces": [
							"object.Object.Monitor"
						],
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 272,
								"comment": " Initializes a read/write mutex writer proxy object.\n",
								"deco": "FZC4core4sync7rwmutex14ReadWriteMutex6Writer",
								"endline": 276,
								"originalType": "()",
								"char": 9,
								"kind": "constructor"
							},
							{
								"endchar": 9,
								"name": "lock",
								"line": 282,
								"comment": " Acquires a write lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 293,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.lock"
								]
							},
							{
								"endchar": 9,
								"name": "unlock",
								"line": 299,
								"comment": " Releases a write lock on the enclosing mutex.\n",
								"deco": "FNeZv",
								"endline": 322,
								"char": 23,
								"kind": "function",
								"overrides": [
									"object.Object.Monitor.unlock"
								]
							},
							{
								"endchar": 9,
								"name": "tryLock",
								"line": 333,
								"comment": " Attempts to acquire a write lock on the enclosing mutex.  If one can\n be obtained without blocking, the lock is acquired and true is\n returned.  If not, the lock is not acquired and false is returned.\n\n Returns:\n  true if the lock was acquired and false if not.\n",
								"deco": "FZb",
								"endline": 342,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "Writer",
						"line": 266,
						"comment": "\n\n\n\n This class can be considered a mutex in its own right, and is used to\n negotiate a write lock for the enclosing mutex.\n",
						"char": 5,
						"kind": "class"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The read/write mutex module provides a primitive for maintaining shared read\n access and mutually exclusive write access.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_rwmutex.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/config.d",
		"name": "core.sync.config",
		"members": [],
		"comment": " The config module contains utility routines and configuration information\n specific to this package.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_config.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/mutex.d",
		"name": "core.sync.mutex",
		"members": [
			{
				"interfaces": [
					"object.Object.Monitor"
				],
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 61,
						"comment": "\n\n\n\n Initializes a mutex object.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNbNeZC4core4sync5mutex5Mutex",
						"endline": 83,
						"originalType": "nothrow @trusted ()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 92,
						"comment": " Initializes a mutex object and sets it as the monitor for o.\n\n In:\n  o must not already have a monitor.\n",
						"deco": "FNbNeC6ObjectZC4core4sync5mutex5Mutex",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 101,
						"originalType": "nothrow @trusted (Object o)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "lock",
						"line": 131,
						"comment": "\n\n\n\n If this lock is not already held by the caller, the lock is acquired,\n then the internal counter is incremented by one.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNeZv",
						"endline": 134,
						"char": 19,
						"kind": "function",
						"overrides": [
							"object.Object.Monitor.lock"
						]
					},
					{
						"endchar": 5,
						"name": "unlock",
						"line": 162,
						"comment": " Decrements the internal lock count by one.  If this brings the count to\n zero, the lock is released.\n\n Throws:\n  SyncError on error.\n",
						"deco": "FNeZv",
						"endline": 165,
						"char": 19,
						"kind": "function",
						"overrides": [
							"object.Object.Monitor.unlock"
						]
					},
					{
						"endchar": 5,
						"name": "tryLock",
						"line": 197,
						"comment": " If the lock is held by another caller, the method returns.  Otherwise,\n the lock is acquired if it is not already held, and then the internal\n counter is incremented by one.\n\n Throws:\n  SyncError on error.\n\n Returns:\n  true if the lock was acquired and false if not.\n",
						"deco": "FZb",
						"endline": 207,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "Mutex",
				"line": 47,
				"comment": "\n\n\n\n This class represents a general purpose, recursive mutex.\n",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " The mutex module provides a primitive for maintaining mutually exclusive\n access.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_mutex.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/sync/exception.d",
		"name": "core.sync.exception",
		"members": [
			{
				"members": [],
				"name": "SyncError",
				"line": 21,
				"comment": " Base class for synchronization errors.\n",
				"base": "object.Error",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Define base class for synchronization exceptions.\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly\n Source:    $(DRUNTIMESRC core/sync/_exception.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/cpuid.d",
		"name": "core.cpuid",
		"members": [
			{
				"name": "CacheInfo",
				"line": 101,
				"comment": "Cache size and behaviour\n",
				"members": [
					{
						"offset": 0,
						"name": "size",
						"line": 107,
						"comment": "Size of the cache, in kilobytes, per CPU.\n\nFor L1 unified (data + code) caches, this size is half the physical size.\n\n(we don't halve it for larger sizes, since normally\n\ndata size is much greater than code size for critical loops).\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@trusted"
						]
					},
					{
						"offset": 8,
						"name": "associativity",
						"line": 113,
						"comment": "Number of ways of associativity, eg:\n\n1 = direct mapped\n\n2 = 2-way set associative\n\n3 = 3-way set associative\n\nubyte.max = fully associative\n",
						"deco": "h",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"@trusted"
						]
					},
					{
						"offset": 12,
						"name": "lineSize",
						"line": 115,
						"comment": "Number of bytes read into the cache when a cache miss occurs.\n",
						"deco": "k",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"@trusted"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "datacache",
				"line": 121,
				"comment": "$(RED Scheduled for deprecation. Please use $(D dataCaches) instead.)\n",
				"deco": "G5S4core5cpuid9CacheInfo",
				"char": 28,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"endchar": 58,
				"name": "dataCaches",
				"line": 126,
				"comment": "The data caches. If there are fewer than 5 physical caches levels,\n\nthe remaining levels are set to size_t.max (== entire memory space)\n",
				"deco": "FNbNdNiNeZxG5S4core5cpuid9CacheInfo",
				"endline": 126,
				"originalType": "nothrow @nogc @property @trusted const(CacheInfo)[5]()",
				"char": 25,
				"kind": "function"
			},
			{
				"endchar": 54,
				"name": "vendor",
				"line": 131,
				"comment": "Returns vendor string, for display purposes only.\n\nDo NOT use this to determine features!\n\nNote that some CPUs have programmable vendorIDs.\n",
				"deco": "FNbNdNiNeZAya",
				"endline": 131,
				"char": 12,
				"kind": "function"
			},
			{
				"endchar": 47,
				"name": "processor",
				"line": 133,
				"comment": "Returns processor string, for display purposes only\n",
				"deco": "FNbNdNiNeZAya",
				"endline": 133,
				"char": 12,
				"kind": "function"
			},
			{
				"endchar": 55,
				"name": "x87onChip",
				"line": 136,
				"comment": "Does it have an x87 FPU on-chip?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 136,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 55,
				"name": "mmx",
				"line": 138,
				"comment": "Is MMX supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 138,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 55,
				"name": "sse",
				"line": 140,
				"comment": "Is SSE supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 140,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 56,
				"name": "sse2",
				"line": 142,
				"comment": "Is SSE2 supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 142,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 60,
				"name": "sse3",
				"line": 144,
				"comment": "Is SSE3 supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 144,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 61,
				"name": "ssse3",
				"line": 146,
				"comment": "Is SSSE3 supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 146,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 61,
				"name": "sse41",
				"line": 148,
				"comment": "Is SSE4.1 supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 148,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 61,
				"name": "sse42",
				"line": 150,
				"comment": "Is SSE4.2 supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 150,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 64,
				"name": "sse4a",
				"line": 152,
				"comment": "Is SSE4a supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 152,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 59,
				"name": "aes",
				"line": 154,
				"comment": "Is AES supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 154,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 65,
				"name": "hasPclmulqdq",
				"line": 156,
				"comment": "Is pclmulqdq supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 156,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 62,
				"name": "hasRdrand",
				"line": 158,
				"comment": "Is rdrand supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 158,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "avx",
				"line": 160,
				"comment": "Is AVX supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 164,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 44,
				"name": "vaes",
				"line": 166,
				"comment": "Is VEX-Encoded AES supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 166,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 54,
				"name": "hasVpclmulqdq",
				"line": 168,
				"comment": "Is vpclmulqdq supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 168,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 66,
				"name": "fma",
				"line": 170,
				"comment": "Is FMA supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 170,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 68,
				"name": "fp16c",
				"line": 172,
				"comment": "Is FP16C supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 172,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 70,
				"name": "avx2",
				"line": 174,
				"comment": "Is AVX2 supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 174,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 62,
				"name": "hle",
				"line": 176,
				"comment": "Is HLE (hardware lock elision) supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 176,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 62,
				"name": "rtm",
				"line": 178,
				"comment": "Is RTM (restricted transactional memory) supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 178,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 61,
				"name": "hasRdseed",
				"line": 180,
				"comment": "Is rdseed supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 180,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 58,
				"name": "hasSha",
				"line": 182,
				"comment": "Is SHA supported\n",
				"deco": "FNbNdNiNeZb",
				"endline": 182,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 64,
				"name": "amd3dnow",
				"line": 184,
				"comment": "Is AMD 3DNOW supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 184,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 68,
				"name": "amd3dnowExt",
				"line": 186,
				"comment": "Is AMD 3DNOW Ext supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 186,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 62,
				"name": "amdMmx",
				"line": 188,
				"comment": "Are AMD extensions to MMX supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 188,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 60,
				"name": "hasFxsr",
				"line": 190,
				"comment": "Is fxsave/fxrstor supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 190,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 60,
				"name": "hasCmov",
				"line": 192,
				"comment": "Is cmov supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 192,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 65,
				"name": "hasRdtsc",
				"line": 194,
				"comment": "Is rdtsc supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 194,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 65,
				"name": "hasCmpxchg8b",
				"line": 196,
				"comment": "Is cmpxchg8b supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 196,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 70,
				"name": "hasCmpxchg16b",
				"line": 198,
				"comment": "Is cmpxchg8b supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 198,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 5,
				"name": "hasSysEnterSysExit",
				"line": 200,
				"comment": "Is SYSENTER/SYSEXIT supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 206,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 61,
				"name": "has3dnowPrefetch",
				"line": 210,
				"comment": "Is 3DNow prefetch supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 211,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "hasLahfSahf",
				"line": 213,
				"comment": "Are LAHF and SAHF supported in 64-bit mode?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 213,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 66,
				"name": "hasPopcnt",
				"line": 215,
				"comment": "Is POPCNT supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 215,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 68,
				"name": "hasLzcnt",
				"line": 217,
				"comment": "Is LZCNT supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 217,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 64,
				"name": "isX86_64",
				"line": 219,
				"comment": "Is this an Intel64 or AMD 64?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 219,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 62,
				"name": "isItanium",
				"line": 222,
				"comment": "Is this an IA64 (Itanium) processor?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 222,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 59,
				"name": "hyperThreading",
				"line": 225,
				"comment": "Is hyperthreading supported?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 225,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 48,
				"name": "threadsPerCPU",
				"line": 227,
				"comment": "Returns number of threads per CPU\n",
				"deco": "FNbNdNiNeZk",
				"endline": 227,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 46,
				"name": "coresPerCPU",
				"line": 229,
				"comment": "Returns number of cores in CPU\n",
				"deco": "FNbNdNiNeZk",
				"endline": 229,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 61,
				"name": "preferAthlon",
				"line": 257,
				"comment": "Optimisation hints for assembly code.\n\n\n\nFor forward compatibility, the CPU is compared against different\n\nmicroarchitectures. For 32-bit x86, comparisons are made against\n\nthe Intel PPro/PII/PIII/PM family.\n\n\n\nThe major 32-bit x86 microarchitecture 'dynasties' have been:\n\n\n\n* Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).\n\n* AMD Athlon (K7, K8, K10).\n\n* Intel NetBurst (Pentium 4, Pentium D).\n\n* In-order Pentium (Pentium1, PMMX, Atom)\n\n\n\nOther early CPUs (Nx586, AMD K5, K6, Centaur C3, Transmeta,\n\nCyrix, Rise) were mostly in-order.\n\n\n\nSome new processors do not fit into the existing categories:\n\n\n\n* Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.\n\n* Centaur Isiah = VIA Nano (family 6, model F) is an out-of-order core.\n\n\n\nWithin each dynasty, the optimisation techniques are largely\n\nidentical (eg, use instruction pairing for group 4). Major\n\ninstruction set improvements occur within each dynasty.\n\nDoes this CPU perform better on AMD K7 code than PentiumPro..Core2 code?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 257,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 68,
				"name": "preferPentium4",
				"line": 259,
				"comment": "Does this CPU perform better on Pentium4 code than PentiumPro..Core2 code?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 259,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 96,
				"name": "preferPentium1",
				"line": 261,
				"comment": "Does this CPU perform better on Pentium I code than Pentium Pro code?\n",
				"deco": "FNbNdNiNeZb",
				"endline": 261,
				"char": 10,
				"kind": "function"
			},
			{
				"name": "stepping",
				"line": 271,
				"comment": "$(RED Warning: This field will be turned into a property in a future release.)\n\n\n\nProcessor type (vendor-dependent).\n\nThis should be visible ONLY for display purposes.\n",
				"deco": "k",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"name": "model",
				"line": 271,
				"comment": "$(RED Warning: This field will be turned into a property in a future release.)\n\n\n\nProcessor type (vendor-dependent).\n\nThis should be visible ONLY for display purposes.\n",
				"deco": "k",
				"char": 20,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"name": "family",
				"line": 271,
				"comment": "$(RED Warning: This field will be turned into a property in a future release.)\n\n\n\nProcessor type (vendor-dependent).\n\nThis should be visible ONLY for display purposes.\n",
				"deco": "k",
				"char": 27,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"name": "numCacheLevels",
				"line": 273,
				"comment": "$(RED This field has been deprecated. Please use $(D cacheLevels) instead.)\n",
				"deco": "k",
				"init": "1u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"nothrow",
					"__gshared",
					"@nogc",
					"@trusted"
				]
			},
			{
				"endchar": 59,
				"name": "cacheLevels",
				"line": 275,
				"comment": "The number of cache levels in the CPU.\n",
				"deco": "FNbNdNiNeZk",
				"endline": 275,
				"char": 20,
				"kind": "function",
				"storageClass": [
					"__gshared"
				]
			}
		],
		"comment": " Identify the characteristics of the host CPU, providing information\n about cache sizes and assembly optimisation hints. This module is\n provided primarily for assembly language programmers.\n\n References:\n Some of this information was extremely difficult to track down. Some of the\n documents below were found only in cached versions stored by search engines!\n This code relies on information found in:\n\n $(UL\n $(LI \"Intel(R) 64 and IA-32 Architectures Software Developers Manual,\n    Volume 2A: Instruction Set Reference, A-M\" (2007).\n )\n $(LI \"AMD CPUID Specification\", Advanced Micro Devices, Rev 2.28 (2008).\n )\n $(LI \"AMD Processor Recognition Application Note For Processors Prior to AMD\n    Family 0Fh Processors\", Advanced Micro Devices, Rev 3.13 (2005).\n )\n $(LI \"AMD Geode(TM) GX Processors Data Book\",\n    Advanced Micro Devices, Publication ID 31505E, (2005).\n )\n $(LI \"AMD K6 Processor Code Optimisation\", Advanced Micro Devices, Rev D (2000).\n )\n $(LI \"Application note 106: Software Customization for the 6x86 Family\",\n    Cyrix Corporation, Rev 1.5 (1998)\n )\n $(LI $(LINK http://www.datasheetcatalog.org/datasheet/nationalsemiconductor/GX1.pdf))\n $(LI \"Geode(TM) GX1 Processor Series Low Power Integrated X86 Solution\",\n   National Semiconductor, (2002)\n )\n $(LI \"The VIA Isaiah Architecture\", G. Glenn Henry, Centaur Technology, Inc (2008).\n )\n $(LI $(LINK http://www.sandpile.org/ia32/cpuid.htm))\n $(LI $(LINK http://www.akkadia.org/drepper/cpumemory.pdf))\n $(LI \"What every programmer should know about memory\",\n    Ulrich Depper, Red Hat, Inc., (2007).\n )\n $(LI \"CPU Identification by the Windows Kernel\", G. Chappell (2009).\n   $(LINK http://www.geoffchappell.com/viewer.htm?doc=studies/windows/km/cpu/cx8.htm)\n )\n $(LI \"Intel(R) Processor Identification and the CPUID Instruction, Application\n    Note 485\" (2009).\n )\n )\n\n Bugs: Currently only works on x86 and Itanium CPUs.\n      Many processors have bugs in their microcode for the CPUID instruction,\n      so sometimes the cache information may be incorrect.\n\n Copyright: Copyright Don Clugston 2007 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Don Clugston, Tomas Lindquist Olsen &lt;tomas@famolsen.dk&gt;\n Source:    $(DRUNTIMESRC core/_cpuid.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/druntime/src/core/memory.d",
		"name": "core.memory",
		"members": [
			{
				"name": "GC",
				"line": 131,
				"comment": " This struct encapsulates all garbage collection functionality for the D\n programming language.\n",
				"members": [
					{
						"endchar": 5,
						"name": "enable",
						"line": 141,
						"comment": " Enables automatic garbage collection behavior if collections have\n previously been suspended by a call to disable.  This function is\n reentrant, and must be called once for every call to disable before\n automatic collections are enabled.\n",
						"deco": "FNbZv",
						"endline": 144,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "disable",
						"line": 154,
						"comment": " Disables automatic garbage collections performed to minimize the\n process footprint.  Collections may continue to occur in instances\n where the implementation deems necessary for correct program behavior,\n such as during an out of memory condition.  This function is reentrant,\n but enable must be called once for each call to disable.\n",
						"deco": "FNbZv",
						"endline": 157,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "collect",
						"line": 167,
						"comment": " Begins a full collection.  While the meaning of this may change based\n on the garbage collector implementation, typical behavior is to scan\n all stack segments for roots, mark accessible memory blocks as alive,\n and then to reclaim free space.  This action may need to suspend all\n running threads for at least part of the collection process.\n",
						"deco": "FNbZv",
						"endline": 170,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "minimize",
						"line": 177,
						"comment": " Indicates that the managed memory space be minimized by returning free\n physical memory to the operating system.  The amount of free memory\n returned depends on the allocator design and on program behavior.\n",
						"deco": "FNbZv",
						"endline": 180,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"members": [
							{
								"name": "NONE",
								"line": 189,
								"value": "0u",
								"comment": "No attributes set.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "FINALIZE",
								"line": 190,
								"value": "1u",
								"comment": "Finalize the data in this block on collect.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "NO_SCAN",
								"line": 191,
								"value": "2u",
								"comment": "Do not scan through this block on collect.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "NO_MOVE",
								"line": 192,
								"value": "4u",
								"comment": "Do not move this memory block on collect.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "APPENDABLE",
								"line": 214,
								"value": "8u",
								"comment": "        This block contains the info to allow appending.\n\n        This can be used to manually allocate arrays. Initial slice size is 0.\n\n        Note: The slice's useable size will not match the block size. Use\n        $(LREF capacity) to retrieve actual useable capacity.\n\n        Example:\n        ----\n        // Allocate the underlying array.\n        int*  pToArray = cast(int*)GC.malloc(10 * int.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.APPENDABLE);\n        // Bind a slice. Check the slice has capacity information.\n        int[] slice = pToArray[0 .. 0];\n        assert(capacity(slice) > 0);\n        // Appending to the slice will not relocate it.\n        slice.length = 5;\n        slice ~= 1;\n        assert(slice.ptr == p);\n        ----\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "NO_INTERIOR",
								"line": 222,
								"value": "16u",
								"comment": "        This block is guaranteed to have a pointer to its base while it is\n        alive.  Interior pointers can be safely ignored.  This attribute is\n        useful for eliminating false pointers in very large data structures\n        and is only implemented for data structures at least a page in size.\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "BlkAttr",
						"line": 187,
						"comment": " Elements for a bit field representing memory block attributes.  These\n are manipulated via the getAttr, setAttr, clrAttr functions.\n",
						"baseDeco": "k",
						"char": 5,
						"kind": "enum"
					},
					{
						"name": "BlkInfo",
						"line": 237,
						"comment": " Contains aggregate information about a block of managed memory.  The\n purpose of this struct is to support a more efficient query style in\n instances where detailed information is needed.\n\n base = A pointer to the base of the block in question.\n size = The size of the block, calculated from base.\n attr = Attribute bits set on the memory block.\n",
						"deco": "S4core6memory8BlkInfo_",
						"char": 20,
						"kind": "alias"
					},
					{
						"endchar": 5,
						"name": "getAttr",
						"line": 253,
						"comment": " Returns a bit field representing all block attributes set for the memory\n referenced by p.  If p references memory not originally allocated by\n this garbage collector, points to the interior of a memory block, or if\n p is null, zero will be returned.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n\n Returns:\n  A bit field containing any bits set for the memory block referenced by\n  p or zero on error.\n",
						"deco": "FNbxPvZk",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 256,
						"originalType": "nothrow uint(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getAttr",
						"line": 260,
						"comment": "ditto\n",
						"deco": "FNaNbPvZk",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 263,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "setAttr",
						"line": 280,
						"comment": " Sets the specified bits for the memory references by p.  If p references\n memory not originally allocated by this garbage collector, points to the\n interior of a memory block, or if p is null, no action will be\n performed.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n  a = A bit field containing any bits to set for this memory block.\n\n Returns:\n  The result of a call to getAttr after the specified bits have been\n  set.\n",
						"deco": "FNbxPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 283,
						"originalType": "nothrow uint(in void* p, uint a)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "setAttr",
						"line": 287,
						"comment": "ditto\n",
						"deco": "FNaNbPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 290,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "clrAttr",
						"line": 307,
						"comment": " Clears the specified bits for the memory references by p.  If p\n references memory not originally allocated by this garbage collector,\n points to the interior of a memory block, or if p is null, no action\n will be performed.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n  a = A bit field containing any bits to clear for this memory block.\n\n Returns:\n  The result of a call to getAttr after the specified bits have been\n  cleared.\n",
						"deco": "FNbxPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 310,
						"originalType": "nothrow uint(in void* p, uint a)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "clrAttr",
						"line": 314,
						"comment": "ditto\n",
						"deco": "FNaNbPvkZk",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "a",
								"deco": "k"
							}
						],
						"endline": 317,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "malloc",
						"line": 340,
						"comment": " Requests an aligned block of managed memory from the garbage collector.\n This memory may be deleted at will with a call to free, or it may be\n discarded and cleaned up automatically during a collection run.  If\n allocation fails, this function will call onOutOfMemory which is\n expected to throw an OutOfMemoryError.\n\n Params:\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  A reference to the allocated memory or null if insufficient memory\n  is available.\n\n Throws:\n  OutOfMemoryError on allocation failure.\n",
						"deco": "FNaNbmkxC8TypeInfoZPv",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 343,
						"originalType": "pure nothrow void*(size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "qalloc",
						"line": 366,
						"comment": " Requests an aligned block of managed memory from the garbage collector.\n This memory may be deleted at will with a call to free, or it may be\n discarded and cleaned up automatically during a collection run.  If\n allocation fails, this function will call onOutOfMemory which is\n expected to throw an OutOfMemoryError.\n\n Params:\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  Information regarding the allocated memory block or BlkInfo.init on\n  error.\n\n Throws:\n  OutOfMemoryError on allocation failure.\n",
						"deco": "FNaNbmkxC8TypeInfoZS4core6memory8BlkInfo_",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 369,
						"originalType": "pure nothrow BlkInfo(size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "calloc",
						"line": 393,
						"comment": " Requests an aligned block of managed memory from the garbage collector,\n which is initialized with all bits set to zero.  This memory may be\n deleted at will with a call to free, or it may be discarded and cleaned\n up automatically during a collection run.  If allocation fails, this\n function will call onOutOfMemory which is expected to throw an\n OutOfMemoryError.\n\n Params:\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  A reference to the allocated memory or null if insufficient memory\n  is available.\n\n Throws:\n  OutOfMemoryError on allocation failure.\n",
						"deco": "FNaNbmkxC8TypeInfoZPv",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 396,
						"originalType": "pure nothrow void*(size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "realloc",
						"line": 433,
						"comment": " If sz is zero, the memory referenced by p will be deallocated as if\n by a call to free.  A new memory block of size sz will then be\n allocated as if by a call to malloc, or the implementation may instead\n resize the memory block in place.  The contents of the new memory block\n will be the same as the contents of the old memory block, up to the\n lesser of the new and old sizes.  Note that existing memory will only\n be freed by realloc if sz is equal to zero.  The garbage collector is\n otherwise expected to later reclaim the memory block if it is unused.\n If allocation fails, this function will call onOutOfMemory which is\n expected to throw an OutOfMemoryError.  If p references memory not\n originally allocated by this garbage collector, or if it points to the\n interior of a memory block, no action will be taken.  If ba is zero\n (the default) and p references the head of a valid, known memory block\n then any bits set on the current block will be set on the new block if a\n reallocation is required.  If ba is not zero and p references the head\n of a valid, known memory block then the bits in ba will replace those on\n the current memory block and will also be set on the new block if a\n reallocation is required.\n\n Params:\n  p  = A pointer to the root of a valid memory block or to null.\n  sz = The desired allocation size in bytes.\n  ba = A bitmask of the attributes to set on this block.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers.\n\n Returns:\n  A reference to the allocated memory on success or null if sz is\n  zero.  On failure, the original value of p is returned.\n\n Throws:\n  OutOfMemoryError on allocation failure.\nExample:\nIssue 13111$(DDOX_UNITTEST_HEADER __unittestL439_424)\n---\nenum size1 = 1 << 11 + 1; // page in large object pool\nenum size2 = 1 << 22 + 1; // larger than large object pool size\n\nauto data1 = cast(ubyte*)GC.calloc(size1);\nauto data2 = cast(ubyte*)GC.realloc(data1, size2);\n\nBlkInfo info = query(data2);\nassert(info.size >= size2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL439_424)\n",
						"deco": "FNaNbPvmkxC8TypeInfoZPv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ba",
								"deco": "k",
								"default": "0u"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 436,
						"originalType": "pure nothrow void*(void* p, size_t sz, uint ba = 0, const TypeInfo ti = null)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "extend",
						"line": 477,
						"comment": " Requests that the managed memory block referenced by p be extended in\n place by at least mx bytes, with a desired extension of sz bytes.  If an\n extension of the required size is not possible or if p references memory\n not originally allocated by this garbage collector, no action will be\n taken.\n\n Params:\n  p  = A pointer to the root of a valid memory block or to null.\n  mx = The minimum extension size in bytes.\n  sz = The desired extension size in bytes.\n  ti = TypeInfo to describe the full memory block. The GC might use\n       this information to improve scanning for pointers or to\n       call finalizers.\n\n Returns:\n  The size in bytes of the extended memory block referenced by p or zero\n  if no extension occurred.\n\n Note:\n  Extend may also be used to extend slices (or memory blocks with\n  $(LREF APPENDABLE) info). However, use the return value only\n  as an indicator of success. $(LREF capacity) should be used to\n  retrieve actual useable slice capacity.\nExample:\nStandard extending$(DDOX_UNITTEST_HEADER __unittestL482_425)\n---\nsize_t size = 1000;\nint* p = cast(int*)GC.malloc(size * int.sizeof, GC.BlkAttr.NO_SCAN);\n\n//Try to extend the allocated data by 1000 elements, preferred 2000.\nsize_t u = GC.extend(p, 1000 * int.sizeof, 2000 * int.sizeof);\nif (u != 0)\n    size = u / int.sizeof;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL482_425)\nExample:\nslice extending$(DDOX_UNITTEST_HEADER __unittestL493_426)\n---\nint[] slice = new int[](1000);\nint*  p     = slice.ptr;\n\n//Check we have access to capacity before attempting the extend\nif (slice.capacity)\n{\n    //Try to extend slice by 1000 elements, preferred 2000.\n    size_t u = GC.extend(p, 1000 * int.sizeof, 2000 * int.sizeof);\n    if (u != 0)\n    {\n        slice.length = slice.capacity;\n        assert(slice.length >= 2000);\n    }\n}\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL493_426)\n",
						"deco": "FNaNbPvmmxC8TypeInfoZm",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							},
							{
								"name": "mx",
								"deco": "m"
							},
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 480,
						"originalType": "pure nothrow size_t(void* p, size_t mx, size_t sz, const TypeInfo ti = null)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "reserve",
						"line": 522,
						"comment": " Requests that at least sz bytes of memory be obtained from the operating\n system and marked as free.\n\n Params:\n  sz = The desired size in bytes.\n\n Returns:\n  The actual number of bytes reserved or zero on error.\n",
						"deco": "FNbmZm",
						"parameters": [
							{
								"name": "sz",
								"deco": "m"
							}
						],
						"endline": 525,
						"originalType": "nothrow size_t(size_t sz)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "free",
						"line": 539,
						"comment": " Deallocates the memory referenced by p.  If p is null, no action\n occurs.  If p references memory not originally allocated by this\n garbage collector, or if it points to the interior of a memory block,\n no action will be taken.  The block will not be finalized regardless\n of whether the FINALIZE attribute is set.  If finalization is desired,\n use delete instead.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n",
						"deco": "FNaNbPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 542,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addrOf",
						"line": 560,
						"comment": " Returns the base address of the memory block containing p.  This value\n is useful to determine whether p is an interior pointer, and the result\n may be passed to routines such as sizeOf which may otherwise fail.  If p\n references memory not originally allocated by this garbage collector, if\n p is null, or if the garbage collector does not support this operation,\n null will be returned.\n\n Params:\n  p = A pointer to the root or the interior of a valid memory block or to\n      null.\n\n Returns:\n  The base address of the memory block referenced by p or null on error.\n",
						"deco": "FNbPNgvZPNgv",
						"parameters": [
							{
								"name": "p",
								"deco": "PNgv"
							}
						],
						"endline": 563,
						"char": 25,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addrOf",
						"line": 567,
						"comment": "ditto\n",
						"deco": "FNaNbPvZPv",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 570,
						"char": 18,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "sizeOf",
						"line": 586,
						"comment": " Returns the true size of the memory block referenced by p.  This value\n represents the maximum number of bytes for which a call to realloc may\n resize the existing block in place.  If p references memory not\n originally allocated by this garbage collector, points to the interior\n of a memory block, or if p is null, zero will be returned.\n\n Params:\n  p = A pointer to the root of a valid memory block or to null.\n\n Returns:\n  The size in bytes of the memory block referenced by p or zero on error.\n",
						"deco": "FNbxPvZm",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 589,
						"originalType": "nothrow size_t(in void* p)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "sizeOf",
						"line": 593,
						"comment": "ditto\n",
						"deco": "FNaNbPvZm",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 596,
						"originalType": "pure nothrow size_t(void* p)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "query",
						"line": 624,
						"comment": " Returns aggregate information about the memory block containing p.  If p\n references memory not originally allocated by this garbage collector, if\n p is null, or if the garbage collector does not support this operation,\n BlkInfo.init will be returned.  Typically, support for this operation\n is dependent on support for addrOf.\n\n Params:\n  p = A pointer to the root or the interior of a valid memory block or to\n      null.\n\n Returns:\n  Information regarding the memory block referenced by p or BlkInfo.init\n  on error.\n",
						"deco": "FNbxPvZS4core6memory8BlkInfo_",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 627,
						"originalType": "nothrow BlkInfo(in void* p)",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "query",
						"line": 631,
						"comment": "ditto\n",
						"deco": "FNaNbPvZS4core6memory8BlkInfo_",
						"parameters": [
							{
								"name": "p",
								"deco": "Pv"
							}
						],
						"endline": 634,
						"originalType": "pure nothrow BlkInfo(void* p)",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addRoot",
						"line": 682,
						"comment": " Adds an internal root pointing to the GC memory block referenced by p.\n As a result, the block referenced by p itself and any blocks accessible\n via it will be considered live until the root is removed again.\n\n If p is null, no operation is performed.\n\n Params:\n  p = A pointer into a GC-managed memory block or null.\n\n Example:\n ---\n // Typical C-style callback mechanism; the passed function\n // is invoked with the user-supplied context pointer at a\n // later point.\n extern(C) void addCallback(void function(void*), void*);\n\n // Allocate an object on the GC heap (this would usually be\n // some application-specific context data).\n auto context = new Object;\n\n // Make sure that it is not collected even if it is no\n // longer referenced from D code (stack, GC heap, â¦).\n GC.addRoot(cast(void*)context);\n\n // Also ensure that a moving collector does not relocate\n // the object.\n GC.setAttr(cast(void*)context, GC.BlkAttr.NO_MOVE);\n\n // Now context can be safely passed to the C library.\n addCallback(&myHandler, cast(void*)context);\n\n extern(C) void myHandler(void* ctx)\n {\n     // Assuming that the callback is invoked only once, the\n     // added root can be removed again now to allow the GC\n     // to collect it later.\n     GC.removeRoot(ctx);\n     GC.clrAttr(ctx, GC.BlkAttr.NO_MOVE);\n\n     auto context = cast(Object)ctx;\n     // Use context hereâ¦\n }\n ---\n",
						"deco": "FNbxPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 685,
						"originalType": "nothrow void(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "removeRoot",
						"line": 696,
						"comment": " Removes the memory block referenced by p from an internal list of roots\n to be scanned during a collection.  If p is null or is not a value\n previously passed to addRoot() then no operation is performed.\n\n Params:\n  p = A pointer into a GC-managed memory block or null.\n",
						"deco": "FNbxPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 699,
						"originalType": "nothrow void(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addRange",
						"line": 730,
						"comment": " Adds $(D p[0 .. sz]) to the list of memory ranges to be scanned for\n pointers during a collection. If p is null, no operation is performed.\n\n Note that $(D p[0 .. sz]) is treated as an opaque range of memory assumed\n to be suitably managed by the caller. In particular, if p points into a\n GC-managed memory block, addRange does $(I not) mark this block as live.\n\n Params:\n  p  = A pointer to a valid memory address or to null.\n  sz = The size in bytes of the block to add. If sz is zero then the\n       no operation will occur. If p is null then sz must be zero.\n  ti = TypeInfo to describe the memory. The GC might use this information\n       to improve scanning for pointers or to call finalizers\n\n Example:\n ---\n // Allocate a piece of memory on the C heap.\n enum size = 1_000;\n auto rawMemory = core.stdc.stdlib.malloc(size);\n\n // Add it as a GC range.\n GC.addRange(rawMemory, size);\n\n // Now, pointers to GC-managed memory stored in\n // rawMemory will be recognized on collection.\n ---\n",
						"deco": "FNbNixPvmxC8TypeInfoZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							},
							{
								"name": "sz",
								"deco": "m"
							},
							{
								"name": "ti",
								"deco": "xC8TypeInfo",
								"default": "null"
							}
						],
						"endline": 733,
						"originalType": "nothrow @nogc void(in void* p, size_t sz, const TypeInfo ti = null)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "removeRange",
						"line": 745,
						"comment": " Removes the memory range starting at p from an internal list of ranges\n to be scanned during a collection. If p is null or does not represent\n a value previously passed to addRange() then no operation is\n performed.\n\n Params:\n  p  = A pointer to a valid memory address or to null.\n",
						"deco": "FNbNixPvZv",
						"parameters": [
							{
								"name": "p",
								"deco": "xPv"
							}
						],
						"endline": 748,
						"originalType": "nothrow @nogc void(in void* p)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "runFinalizers",
						"line": 761,
						"comment": " Runs any finalizer that is located in address range of the\n given code segment.  This is used before unloading shared\n libraries.  All matching objects which have a finalizer in this\n code segment are assumed to be dead, using them while or after\n calling this method has undefined behavior.\n\n Params:\n  segment = address range of a code segment.\n",
						"deco": "FxAvZv",
						"parameters": [
							{
								"name": "segment",
								"deco": "xAv"
							}
						],
						"endline": 764,
						"originalType": "void(in void[] segment)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			}
		],
		"comment": " This module provides an interface to the garbage collector used by\n applications written in the D programming language. It allows the\n garbage collector in the runtime to be swapped without affecting\n binary compatibility of applications.\n\n Using this module is not necessary in typical D code. It is mostly\n useful when doing low-level _memory management.\n\n Notes_to_implementors:\n $(UL\n $(LI On POSIX systems, the signals SIGUSR1 and SIGUSR2 are reserved\n   by this module for use in the garbage collector implementation.\n   Typically, they will be used to stop and resume other threads\n   when performing a collection, but an implementation may choose\n   not to use this mechanism (or not stop the world at all, in the\n   case of concurrent garbage collectors).)\n\n $(LI Registers, the stack, and any other _memory locations added through\n   the $(D GC.$(LREF addRange)) function are always scanned conservatively.\n   This means that even if a variable is e.g. of type $(D float),\n   it will still be scanned for possible GC pointers. And, if the\n   word-interpreted representation of the variable matches a GC-managed\n   _memory block's address, that _memory block is considered live.)\n\n $(LI Implementations are free to scan the non-root heap in a precise\n   manner, so that fields of types like $(D float) will not be considered\n   relevant when scanning the heap. Thus, casting a GC pointer to an\n   integral type (e.g. $(D size_t)) and storing it in a field of that\n   type inside the GC heap may mean that it will not be recognized\n   if the _memory block was allocated with precise type info or with\n   the $(D GC.BlkAttr.$(LREF NO_SCAN)) attribute.)\n\n $(LI Destructors will always be executed while other threads are\n   active; that is, an implementation that stops the world must not\n   execute destructors until the world has been resumed.)\n\n $(LI A destructor of an object must not access object references\n   within the object. This means that an implementation is free to\n   optimize based on this rule.)\n\n $(LI An implementation is free to perform heap compaction and copying\n   so long as no valid GC pointers are invalidated in the process.\n   However, _memory allocated with $(D GC.BlkAttr.$(LREF NO_MOVE)) must\n   not be moved/copied.)\n\n $(LI Implementations must support interior pointers. That is, if the\n   only reference to a GC-managed _memory block points into the\n   middle of the block rather than the beginning (for example), the\n   GC must consider the _memory block live. The exception to this\n   rule is when a _memory block is allocated with the\n   $(D GC.BlkAttr.$(LREF NO_INTERIOR)) attribute; it is the user's\n   responsibility to make sure such _memory blocks have a proper pointer\n   to them when they should be considered live.)\n\n $(LI It is acceptable for an implementation to store bit flags into\n   pointer values and GC-managed _memory blocks, so long as such a\n   trick is not visible to the application. In practice, this means\n   that only a stop-the-world collector can do this.)\n\n $(LI Implementations are free to assume that GC pointers are only\n   stored on word boundaries. Unaligned pointers may be ignored\n   entirely.)\n\n $(LI Implementations are free to run collections at any point. It is,\n   however, recommendable to only do so when an allocation attempt\n   happens and there is insufficient _memory available.)\n )\n\n Copyright: Copyright Sean Kelly 2005 - 2009.\n License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n Authors:   Sean Kelly, Alex RÃ¸nne Petersen\n Source:    $(DRUNTIMESRC core/_memory.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/functional.d",
		"name": "std.functional",
		"members": [
			{
				"members": [],
				"name": "unaryFun",
				"line": 107,
				"comment": "Transforms a string representing an expression into a unary\nfunction. The string must either use symbol name $(D a) as\nthe parameter or provide the symbol via the $(D parmName) argument.\nIf $(D fun) is not a string, $(D unaryFun) aliases itself away to $(D fun).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL134_428)\n---\n// Strings are compiled into functions:\nalias isEven = unaryFun!(\"(a & 1) == 0\");\nassert(isEven(2) && !isEven(1));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL134_428)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "parmName",
						"defaultValue": "\"a\"",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "binaryFun",
				"line": 198,
				"comment": "Transforms a string representing an expression into a binary function. The\nstring must either use symbol names $(D a) and $(D b) as the parameters or\nprovide the symbols via the $(D parm1Name) and $(D parm2Name) arguments.\nIf $(D fun) is not a string, $(D binaryFun) aliases itself away to\n$(D fun).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL228_430)\n---\nalias less = binaryFun!(\"a < b\");\nassert(less(1, 2) && !less(2, 1));\nalias greater = binaryFun!(\"a > b\");\nassert(!greater(\"1\", \"2\") && greater(\"2\", \"1\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL228_430)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "parm1Name",
						"defaultValue": "\"a\"",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "parm2Name",
						"defaultValue": "\"b\"",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "lessThan",
				"line": 491,
				"comment": "   Predicate that returns $(D_PARAM a < b).\n   Correctly compares signed and unsigned integers, ie. -1 < 2U.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "greaterThan",
				"line": 511,
				"comment": "   Predicate that returns $(D_PARAM a > b).\n   Correctly compares signed and unsigned integers, ie. 2U > -1.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "equalTo",
				"line": 531,
				"comment": "   Predicate that returns $(D_PARAM a == b).\n   Correctly compares signed and unsigned integers, ie. !(-1 == ~0U).\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "reverseArgs",
								"line": 545,
								"type": "(auto ref Args args)",
								"parameters": [
									{
										"name": "args",
										"type": "Args",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 549,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "reverseArgs",
						"line": 545,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "is(typeof(pred(Reverse!args)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "reverseArgs",
				"line": 543,
				"comment": "   N-ary predicate that reverses the order of arguments, e.g., given\n   $(D pred(a, b, c)), returns $(D pred(c, b, a)).\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "binaryReverseArgs",
								"line": 582,
								"type": "(auto ref ElementType1 a, auto ref ElementType2 b)",
								"parameters": [
									{
										"name": "a",
										"type": "ElementType1",
										"storageClass": [
											"auto",
											"ref"
										]
									},
									{
										"name": "b",
										"type": "ElementType2",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 586,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "binaryReverseArgs",
						"line": 582,
						"parameters": [
							{
								"name": "ElementType1",
								"kind": "type"
							},
							{
								"name": "ElementType2",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "binaryReverseArgs",
				"line": 580,
				"comment": "   Binary predicate that reverses the order of arguments, e.g., given\n   $(D pred(a, b)), returns $(D pred(b, a)).\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "not",
								"line": 606,
								"type": "(auto ref T args)",
								"parameters": [
									{
										"name": "args",
										"type": "T",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 616,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "not",
						"line": 606,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "not",
				"line": 604,
				"comment": "Negates predicate $(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL620_440)\n---\nimport std.functional;\nimport std.algorithm : find;\nimport std.uni : isWhite;\nstring a = \"   Hello, world!\";\nassert(find!(not!isWhite)(a) == \"Hello, world!\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL620_440)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "partial",
				"line": 656,
				"comment": "$(LINK2 http://en.wikipedia.org/wiki/Partial_application, Partially\napplies) $(D_PARAM fun) by tying its first argument to $(D_PARAM arg).\n\nExample:\n\n----\nint fun(int a, int b) { return a + b; }\nalias partial!(fun, 5) fun5;\nassert(fun5(6) == 11);\n----\n\nNote that in most cases you'd use an alias instead of a value\nassignment. Using an alias allows you to partially evaluate template\nfunctions without committing to a particular type of the function.\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "arg",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "curry",
				"line": 695,
				"comment": "Deprecated alias for $(D partial), kept for backwards compatibility\n",
				"storageClass": [
					"deprecated"
				],
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "adjoin",
						"line": 801,
						"type": "F[0]",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "adjoin",
				"line": 799,
				"comment": "Takes multiple functions and adjoins them together. The result is a\n$(XREF typecons, Tuple) with one element per passed-in function. Upon\ninvocation, the returned tuple is the adjoined results of all\nfunctions.\n\nNote: In the special case where only a single function is provided\n($(D F.length == 1)), adjoin simply aliases to the single passed function\n($(D F[0])).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL827_450)\n---\nimport std.functional, std.typecons;\nstatic bool f1(int a) { return a != 0; }\nstatic int f2(int a) { return a / 2; }\nauto x = adjoin!(f1, f2)(5);\nassert(is(typeof(x) == Tuple!(bool, int)));\nassert(x[0] == true && x[1] == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL827_450)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "tuple"
					}
				],
				"constraint": "F.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "adjoin",
								"line": 806,
								"type": "(auto ref V a)",
								"parameters": [
									{
										"name": "a",
										"type": "V",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 823,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "adjoin",
						"line": 806,
						"parameters": [
							{
								"name": "V",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "adjoin",
				"line": 804,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "F",
						"kind": "tuple"
					}
				],
				"constraint": "F.length > 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "compose",
				"line": 936,
				"comment": "   Composes passed-in functions $(D fun[0], fun[1], ...) returning a\n   function $(D f(x)) that in turn returns $(D\n   fun[0](fun[1](...(x)))...). Each function can be a regular\n   functions, a delegate, or a string.\n\n   Example:\n\n----\n// First split a string in whitespace-separated tokens and then\n// convert each token into an integer\nassert(compose!(map!(to!(int)), split)(\"1 2 3\") == [1, 2, 3]);\n----\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "pipe",
						"line": 976,
						"type": "compose!(Reverse!fun)",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "pipe",
				"line": 976,
				"comment": "   Pipes functions in sequence. Offers the same functionality as $(D\n   compose), but with functions specified in reverse order. This may\n   lead to more readable code in some situation because the order of\n   execution is the same as lexical order.\n\n   Example:\n\n----\n// Read an entire text file, split the resulting string in\n// whitespace-separated tokens, and then convert each token into an\n// integer\nint[] a = pipe!(readText, split, map!(to!(int)))(\"file.txt\");\n----\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "memoize",
						"line": 1027,
						"type": "ReturnType!fun(ParameterTypeTuple!fun args)",
						"parameters": [
							{
								"name": "args",
								"type": "ParameterTypeTuple!fun"
							}
						],
						"endline": 1037,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "memoize",
				"line": 1023,
				"comment": " $(LUCKY Memoizes) a function so as to avoid repeated\n computation. The memoization structure is a hash table keyed by a\n tuple of the function's arguments. There is a speed gain if the\n function is repeatedly called with the same arguments and is more\n expensive than a hash table lookup. For more information on memoization, refer to $(WEB docs.google.com/viewer?url=http%3A%2F%2Fhop.perl.plover.com%2Fbook%2Fpdf%2F03CachingAndMemoization.pdf, this book chapter).\n\nExample:\n----\ndouble transmogrify(int a, string b)\n{\n   ... expensive computation ...\n}\nalias fastTransmogrify = memoize!transmogrify;\nunittest\n{\n    auto slow = transmogrify(2, \"hello\");\n    auto fast = fastTransmogrify(2, \"hello\");\n    assert(slow == fast);\n}\n----\n\nTechnically the memoized function should be pure because $(D memoize) assumes it will\nalways return the same result for a given tuple of arguments. However, $(D memoize) does not\nenforce that because sometimes it\nis useful to memoize an impure function, too.\nExample:\nTo _memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call.\n For example, to transform the exponential-time Fibonacci implementation into a linear-time computation:$(DDOX_UNITTEST_HEADER __unittestL1098_454)\n---\nulong fib(ulong n)\n{\n    return n < 2 ? 1 : memoize!fib(n - 2) + memoize!fib(n - 1);\n}\nassert(fib(10) == 89);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1098_454)\nExample:\nTo improve the speed of the factorial function,$(DDOX_UNITTEST_HEADER __unittestL1110_455)\n---\nulong fact(ulong n)\n{\n    return n < 2 ? 1 : n * memoize!fact(n - 1);\n}\nassert(fact(10) == 3628800);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1110_455)\nExample:\nThis memoizes all values of $(D fact) up to the largest argument. To only cache the final\n result, move $(D memoize) outside the function as shown below.$(DDOX_UNITTEST_HEADER __unittestL1123_456)\n---\nulong factImpl(ulong n)\n{\n    return n < 2 ? 1 : n * factImpl(n - 1);\n}\nalias fact = memoize!factImpl;\nassert(fact(10) == 3628800);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1123_456)\nExample:\nWhen the $(D maxSize) parameter is specified, memoize will used\n a fixed size hash table to limit the number of cached entries.$(DDOX_UNITTEST_HEADER __unittestL1137_457)\n---\nulong fact(ulong n)\n{\n    // Memoize no more than 8 values\n    return n < 2 ? 1 : n * memoize!(fact, 8)(n - 1);\n}\nassert(fact(8) == 40320);\n// using more entries than maxSize will overwrite existing entries\nassert(fact(10) == 3628800);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1137_457)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "memoize",
						"line": 1044,
						"type": "ReturnType!fun(ParameterTypeTuple!fun args)",
						"parameters": [
							{
								"name": "args",
								"type": "ParameterTypeTuple!fun"
							}
						],
						"endline": 1091,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "memoize",
				"line": 1041,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "maxSize",
						"deco": "k",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toDelegate",
						"line": 1274,
						"type": "(auto ref F fp)",
						"parameters": [
							{
								"name": "fp",
								"type": "F",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 1314,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toDelegate",
				"line": 1274,
				"comment": " Convert a callable to a delegate with the same parameter list and\n return type, avoiding heap allocations and use of auxiliary storage.\n\n Examples:\n ----\n void doStuff() {\n     writeln(\"Hello, world.\");\n }\n\n void runDelegate(void delegate() myDelegate) {\n     myDelegate();\n }\n\n auto delegateToPass = toDelegate(&doStuff);\n runDelegate(delegateToPass);  // Calls doStuff, prints \"Hello, world.\"\n ----\n\n BUGS:\n $(UL\n   $(LI Does not work with $(D @safe) functions.)\n   $(LI Ignores C-style / D-style variadic arguments.)\n )\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isCallable!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "forward",
				"line": 1411,
				"comment": "Forwards function arguments with saving ref-ness.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1431_460)\n---\nclass C\n{\n    static int foo(int n) { return 1; }\n    static int foo(ref int n) { return 2; }\n}\nint bar()(auto ref int x) { return C.foo(forward!x); }\n\nassert(bar(1) == 1);\nint i;\nassert(bar(i) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1431_460)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1446_461)\n---\nvoid foo(int n, ref string s) { s = null; foreach (i; 0..n) s ~= \"Hello\"; }\n\n// forwards all arguments which are bound to parameter tuple\nvoid bar(Args...)(auto ref Args args) { return foo(forward!args); }\n\n// forwards all arguments with swapping order\nvoid baz(Args...)(auto ref Args args) { return foo(forward!args[$/2..$], forward!args[0..$/2]); }\n\nstring s;\nbar(1, s);\nassert(s == \"Hello\");\nbaz(s, 2);\nassert(s == \"HelloHello\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1446_461)\n",
				"parameters": [
					{
						"name": "args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "Functions that manipulate other functions.\n\nThis module provides functions for compile time function composition. These\nfunctions are helpful when constructing predicates for the algorithms in\n$(LINK2 std_algorithm.html, std.algorithm) or $(LINK2 std_range.html,\nstd.range).\n\n$(BOOKTABLE ,\n$(TR $(TH Function Name) $(TH Description)\n)\n    $(TR $(TD $(D $(LREF adjoin)))\n        $(TD Joins a couple of functions into one that executes the original\n        functions independently and returns a tuple with all the results.\n    ))\n    $(TR $(TD $(D $(LREF compose)), $(D $(LREF pipe)))\n        $(TD Join a couple of functions into one that executes the original\n        functions one after the other, using one function's result for the next\n        function's argument.\n    ))\n    $(TR $(TD $(D $(LREF forward)))\n        $(TD Forwards function arguments while saving ref-ness.\n    ))\n    $(TR $(TD $(D $(LREF lessThan)), $(D $(LREF greaterThan)), $(D $(LREF equalTo)))\n        $(TD Ready-made predicate functions to compare two values.\n    ))\n    $(TR $(TD $(D $(LREF memoize)))\n        $(TD Creates a function that caches its result for fast re-evalation.\n    ))\n    $(TR $(TD $(D $(LREF not)))\n        $(TD Creates a function that negates another.\n    ))\n    $(TR $(TD $(D $(LREF partial)))\n        $(TD Creates a function that binds the first argument of a given function\n        to a given value.\n    ))\n    $(TR $(TD $(D $(LREF reverseArgs)), $(D $(LREF binaryReverseArgs)))\n        $(TD Predicate that reverses the order of its arguments.\n    ))\n    $(TR $(TD $(D $(LREF toDelegate)))\n        $(TD Converts a callable to a delegate.\n    ))\n    $(TR $(TD $(D $(LREF unaryFun)), $(D $(LREF binaryFun)))\n        $(TD Create a unary or binary function from a string. Most often\n        used when defining algorithms on ranges.\n    ))\n)\n\nMacros:\n\nWIKI = Phobos/StdFunctional\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nSource:    $(PHOBOSSRC std/_functional.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/math.d",
		"name": "std.math",
		"members": [
			{
				"name": "E",
				"line": 472,
				"comment": " e = 2.718281...\n",
				"deco": "e",
				"init": "2.71828L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG2T",
				"line": 473,
				"comment": " $(SUB log, 2)10 = 3.321928...\n",
				"deco": "e",
				"init": "3.32193L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG2E",
				"line": 474,
				"comment": " $(SUB log, 2)e = 1.442695...\n",
				"deco": "e",
				"init": "1.4427L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG2",
				"line": 475,
				"comment": " $(SUB log, 10)2 = 0.301029...\n",
				"deco": "e",
				"init": "0.30103L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LOG10E",
				"line": 476,
				"comment": " $(SUB log, 10)e = 0.434294...\n",
				"deco": "e",
				"init": "0.434294L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LN2",
				"line": 477,
				"comment": " ln 2  = 0.693147...\n",
				"deco": "e",
				"init": "0.693147L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LN10",
				"line": 478,
				"comment": " ln 10 = 2.302585...\n",
				"deco": "e",
				"init": "2.30259L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "PI",
				"line": 479,
				"comment": " $(_PI) = 3.141592...\n",
				"deco": "e",
				"init": "3.14159L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "PI_2",
				"line": 480,
				"comment": " $(PI) / 2 = 1.570796...\n",
				"deco": "e",
				"init": "1.5708L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "PI_4",
				"line": 481,
				"comment": " $(PI) / 4 = 0.785398...\n",
				"deco": "e",
				"init": "0.785398L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "M_1_PI",
				"line": 482,
				"comment": " 1 / $(PI) = 0.318309...\n",
				"deco": "e",
				"init": "0.31831L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "M_2_PI",
				"line": 483,
				"comment": " 2 / $(PI) = 0.636619...\n",
				"deco": "e",
				"init": "0.63662L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "M_2_SQRTPI",
				"line": 484,
				"comment": " 2 / $(SQRT)$(PI) = 1.128379...\n",
				"deco": "e",
				"init": "1.12838L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "SQRT2",
				"line": 485,
				"comment": " $(SQRT)2 = 1.414213...\n",
				"deco": "e",
				"init": "1.41421L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "SQRT1_2",
				"line": 486,
				"comment": " $(SQRT)$(HALF) = 0.707106...\n",
				"deco": "e",
				"init": "0.707107L",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 508,
						"type": "pure nothrow @safe Num(Num x)",
						"parameters": [
							{
								"name": "x",
								"type": "Num"
							}
						],
						"endline": 517,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "abs",
				"line": 508,
				"comment": " Calculates the absolute value of a number\n\n Params:\n     Num = (template parameter) type of number\n       x = real number value\n       z = complex number value\n       y = imaginary number value\n\n Returns:\n     The absolute value of the number.  If floating-point or integral,\n     the return type will be the same as the input; if complex or\n     imaginary, the returned value will be the corresponding floating\n     point type.\n\n For complex numbers, abs(z) = sqrt( $(POWER z.re, 2) + $(POWER z.im, 2) )\n = hypot(z.re, z.im).\nExample:\nditto$(DDOX_UNITTEST_HEADER __unittestL536_464)\n---\nassert(isIdentical(abs(-0.0L), 0.0L));\nassert(isNaN(abs(real.nan)));\nassert(abs(-real.infinity) == real.infinity);\nassert(abs(-3.2Li) == 3.2L);\nassert(abs(71.6Li) == 71.6L);\nassert(abs(-56) == 56);\nassert(abs(2321312L)  == 2321312L);\nassert(abs(-1L+1i) == sqrt(2.0L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL536_464)\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(Num.init >= 0)) && is(typeof(-Num.init)) && !(is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*)))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 520,
						"type": "pure nothrow @nogc @safe (Num z)",
						"parameters": [
							{
								"name": "z",
								"type": "Num"
							}
						],
						"endline": 525,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "abs",
				"line": 520,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(cfloat*)) || is(Num* : const(cdouble*)) || is(Num* : const(creal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 528,
						"type": "pure nothrow @nogc @safe (Num y)",
						"parameters": [
							{
								"name": "y",
								"type": "Num"
							}
						],
						"endline": 533,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "abs",
				"line": 528,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "conj",
						"line": 573,
						"type": "pure nothrow @nogc @safe (Num z)",
						"parameters": [
							{
								"name": "z",
								"type": "Num"
							}
						],
						"endline": 583,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "conj",
				"line": 573,
				"comment": " Complex conjugate\n\n  conj(x + iy) = x - iy\n\n Note that z * conj(z) = $(POWER z.re, 2) - $(POWER z.im, 2)\n is always a real number\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL594_466)\n---\ncreal c = 7 + 3Li;\nassert(conj(c) == 7-3Li);\nireal z = -3.2Li;\nassert(conj(z) == -z);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL594_466)\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(cfloat*)) || is(Num* : const(cdouble*)) || is(Num* : const(creal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "conj",
						"line": 586,
						"type": "pure nothrow @nogc @safe (Num y)",
						"parameters": [
							{
								"name": "y",
								"type": "Num"
							}
						],
						"endline": 591,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "conj",
				"line": 586,
				"comment": " ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*))",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "cos",
				"line": 630,
				"comment": " Returns cosine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cos(x)) $(TH invalid?))\n      $(TR $(TD $(NAN))            $(TD $(NAN)) $(TD yes)     )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN)) $(TD yes)     )\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "cos",
				"line": 633,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 633,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 72,
				"name": "cos",
				"line": 636,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 636,
				"char": 7,
				"kind": "function"
			},
			{
				"name": "sin",
				"line": 658,
				"comment": " Returns $(WEB en.wikipedia.org/wiki/Sine, sine) of x. x is in $(WEB en.wikipedia.org/wiki/Radian, radians).\n\n      $(TABLE_SV\n      $(TH3 x           ,  sin(x)      ,  invalid?)\n      $(TD3 $(NAN)      ,  $(NAN)      ,  yes     )\n      $(TD3 $(PLUSMN)0.0,  $(PLUSMN)0.0,  no      )\n      $(TD3 $(PLUSMNINF),  $(NAN)      ,  yes     )\n      )\n\n Params:\n      x = angle in radians (not degrees)\n Returns:\n      sine of x\n See_Also:\n      $(MYREF cos), $(MYREF tan), $(MYREF asin)\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL667_469)\n---\nimport std.math : sin, PI;\nimport std.stdio : writefln;\n\nvoid someFunc()\n{\n  real x = 30.0;\n  auto result = sin(x * (PI / 180)); // convert degrees to radians\n  writefln(\"The sine of %s degrees is %s\", x, result);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL667_469)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "sin",
				"line": 661,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 661,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 72,
				"name": "sin",
				"line": 664,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 664,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sin",
				"line": 688,
				"comment": "  Returns sine for complex and imaginary arguments.\n\n  sin(z) = sin(z.re)*cosh(z.im) + cos(z.re)*sinh(z.im)i\n\n If both sin($(THETA)) and cos($(THETA)) are required,\n it is most efficient to use expi($(THETA)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL702_470)\n---\nassert(sin(0.0+0.0i) == 0.0);\nassert(sin(2.0+0.0i) == sin(2.0L) );\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL702_470)\n",
				"deco": "FNaNbNiNfcZc",
				"parameters": [
					{
						"name": "z",
						"deco": "c"
					}
				],
				"endline": 693,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sin",
				"line": 696,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfjZj",
				"parameters": [
					{
						"name": "y",
						"deco": "j"
					}
				],
				"endline": 699,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cos",
				"line": 713,
				"comment": "  cosine, complex and imaginary\n\n  cos(z) = cos(z.re)*cosh(z.im) - sin(z.re)*sinh(z.im)i\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL727_471)\n---\nassert(cos(0.0+0.0i)==1.0);\nassert(cos(1.3L+0.0i)==cos(1.3L));\nassert(cos(5.2Li)== cosh(5.2L));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL727_471)\n",
				"deco": "FNaNbNiNfcZc",
				"parameters": [
					{
						"name": "z",
						"deco": "c"
					}
				],
				"endline": 718,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cos",
				"line": 721,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfjZe",
				"parameters": [
					{
						"name": "y",
						"deco": "j"
					}
				],
				"endline": 724,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tan",
				"line": 745,
				"comment": " Returns tangent of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)             $(TH tan(x))       $(TH invalid?))\n      $(TR $(TD $(NAN))        $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))  $(TD $(NAN))       $(TD yes))\n      )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 894,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "acos",
				"line": 966,
				"comment": " Calculates the arc cosine of x,\n returning a value ranging from 0 to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH acos(x)) $(TH invalid?))\n      $(TR $(TD $(GT)1.0)  $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(LT)-1.0) $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(NAN))    $(TD $(NAN))  $(TD yes))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 969,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "acos",
				"line": 972,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 972,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "acos",
				"line": 975,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 975,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "asin",
				"line": 993,
				"comment": " Calculates the arc sine of x,\n returning a value ranging from -$(PI)/2 to $(PI)/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH asin(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(GT)1.0)     $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD yes))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 996,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "asin",
				"line": 999,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 999,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "asin",
				"line": 1002,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1002,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan",
				"line": 1019,
				"comment": " Calculates the arc tangent of x,\n returning a value ranging from -$(PI)/2 to $(PI)/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH atan(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN))       $(TD yes))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1084,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "atan",
				"line": 1087,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1087,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "atan",
				"line": 1090,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1090,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan2",
				"line": 1118,
				"comment": " Calculates the arc tangent of y / x,\n returning a value ranging from -$(PI) to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH y)                 $(TH x)            $(TH atan(y, x)))\n      $(TR $(TD $(NAN))            $(TD anything)     $(TD $(NAN)) )\n      $(TR $(TD anything)          $(TD $(NAN))       $(TD $(NAN)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(GT)0.0)     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0)         $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(LT)0.0)     $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -0.0)         $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(GT)0.0)          $(TD $(PLUSMN)0.0) $(TD $(PI)/2) )\n      $(TR $(TD $(LT)0.0)          $(TD $(PLUSMN)0.0) $(TD -$(PI)/2) )\n      $(TR $(TD $(GT)0.0)          $(TD $(INFIN))     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD anything)     $(TD $(PLUSMN)$(PI)/2))\n      $(TR $(TD $(GT)0.0)          $(TD -$(INFIN))    $(TD $(PLUSMN)$(PI)) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(INFIN))     $(TD $(PLUSMN)$(PI)/4))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD -$(INFIN))    $(TD $(PLUSMN)3$(PI)/4))\n      )\n",
				"deco": "FNaNbNiNeeeZe",
				"parameters": [
					{
						"name": "y",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1191,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan2",
				"line": 1194,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfddZd",
				"parameters": [
					{
						"name": "y",
						"deco": "d"
					},
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1197,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atan2",
				"line": 1200,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfffZf",
				"parameters": [
					{
						"name": "y",
						"deco": "f"
					},
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1203,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cosh",
				"line": 1218,
				"comment": " Calculates the hyperbolic cosine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cosh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)0.0) $(TD no) )\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1224,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "cosh",
				"line": 1227,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1227,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "cosh",
				"line": 1230,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1230,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sinh",
				"line": 1246,
				"comment": " Calculates the hyperbolic sine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH sinh(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1259,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "sinh",
				"line": 1262,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1262,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "sinh",
				"line": 1265,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1265,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tanh",
				"line": 1281,
				"comment": " Calculates the hyperbolic tangent of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH tanh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)1.0) $(TD no))\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1291,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "tanh",
				"line": 1294,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1294,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "tanh",
				"line": 1297,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1297,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "acosh",
				"line": 1349,
				"comment": " Calculates the inverse hyperbolic cosine of x.\n\n  Mathematically, acosh(x) = log(x + sqrt( x*x - 1))\n\n $(TABLE_DOMRG\n  $(DOMAIN 1..$(INFIN))\n  $(RANGE  1..log(real.max), $(INFIN)) )\n      $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(LT)1,     $(NAN) )\n    $(SV  1,      0       )\n    $(SV  +$(INFIN),+$(INFIN))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1355,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "acosh",
				"line": 1358,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1358,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 77,
				"name": "acosh",
				"line": 1361,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1361,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "asinh",
				"line": 1390,
				"comment": " Calculates the inverse hyperbolic sine of x.\n\n  Mathematically,\n  ---------------\n  asinh(x) =  log( x + sqrt( x*x + 1 )) // if x >= +0\n  asinh(x) = -log(-x + sqrt( x*x + 1 )) // if x <= -0\n  -------------\n\n    $(TABLE_SV\n    $(SVH x,                asinh(x)       )\n    $(SV  $(NAN),           $(NAN)         )\n    $(SV  $(PLUSMN)0,       $(PLUSMN)0      )\n    $(SV  $(PLUSMN)$(INFIN),$(PLUSMN)$(INFIN))\n    )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1397,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "asinh",
				"line": 1400,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1400,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "asinh",
				"line": 1403,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1403,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "atanh",
				"line": 1432,
				"comment": " Calculates the inverse hyperbolic tangent of x,\n returning a value from ranging from -1 to 1.\n\n Mathematically, atanh(x) = log( (1+x)/(1-x) ) / 2\n\n\n $(TABLE_DOMRG\n  $(DOMAIN -$(INFIN)..$(INFIN))\n  $(RANGE  -1..1) )\n $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(PLUSMN)0, $(PLUSMN)0)\n    $(SV  -$(INFIN), -0)\n )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1436,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "atanh",
				"line": 1439,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1439,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "atanh",
				"line": 1442,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1442,
				"char": 7,
				"kind": "function"
			},
			{
				"name": "rndtol",
				"line": 1461,
				"comment": " Returns x rounded to a long value using the current rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "FNaNbNiNfeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 78,
				"name": "rndtol",
				"line": 1464,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZl",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1464,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 77,
				"name": "rndtol",
				"line": 1467,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZl",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1467,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rndtonl",
				"line": 1476,
				"comment": " Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n",
				"deco": "UeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 17,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 1488,
				"comment": " Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"char": 7,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 1491,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"char": 8,
				"kind": "function"
			},
			{
				"name": "sqrt",
				"line": 1494,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "exp",
				"line": 1559,
				"comment": " Calculates e$(SUPERSCRIPT x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUPERSCRIPT x)) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1655,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "exp",
				"line": 1658,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 1658,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 75,
				"name": "exp",
				"line": 1661,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 1661,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "expm1",
				"line": 1683,
				"comment": " Calculates the value of the natural logarithm base (e)\n raised to the power of x, minus 1.\n\n For very small x, expm1(x) is more accurate\n than exp(x)-1.\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUPERSCRIPT x)-1)  )\n    $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN))    )\n    $(TR $(TD -$(INFIN))     $(TD -1.0)         )\n    $(TR $(TD $(NAN))        $(TD $(NAN))       )\n  )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 1900,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "exp2",
				"line": 1914,
				"comment": " Calculates 2$(SUPERSCRIPT x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH exp2(x))   )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2149_487)\n---\nassert(feqrel(exp2(0.5L), SQRT2) >= real.mant_dig -1);\nassert(exp2(8.0L) == 256.0);\nassert(exp2(-9.0L)== 1.0L/512.0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2149_487)\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 2146,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "expi",
				"line": 2274,
				"comment": " Calculate cos(y) + i sin(y).\n\n On many CPUs (such as x86), this is a very efficient operation;\n almost twice as fast as calculating sin(y) and cos(y) separately,\n and is the preferred method when both are required.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2306_490)\n---\nassert(expi(1.3e5L) == cos(1.3e5L) + sin(1.3e5L) * 1i);\nassert(expi(0.0L) == 1L + 0.0Li);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2306_490)\n",
				"deco": "FNaNbNiNeeZc",
				"parameters": [
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 2303,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "frexp",
						"line": 2330,
						"type": "pure nothrow @nogc @trusted T(const T value, out int exp)",
						"parameters": [
							{
								"name": "value",
								"type": "T",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "exp",
								"storageClass": [
									"out"
								],
								"deco": "i"
							}
						],
						"endline": 2509,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "frexp",
				"line": 2330,
				"comment": " Separate floating point value into significand and exponent.\n\n Returns:\n      Calculate and return $(I x) and $(I exp) such that\n      value =$(I x)*2$(SUPERSCRIPT exp) and\n      .5 $(LT)= |$(I x)| $(LT) 1.0\n\n      $(I x) has same sign as value.\n\n      $(TABLE_SV\n      $(TR $(TH value)           $(TH returns)         $(TH exp))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0)    $(TD 0))\n      $(TR $(TD +$(INFIN))       $(TD +$(INFIN))       $(TD int.max))\n      $(TR $(TD -$(INFIN))       $(TD -$(INFIN))       $(TD int.min))\n      $(TR $(TD $(PLUSMN)$(NAN)) $(TD $(PLUSMN)$(NAN)) $(TD int.min))\n      )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2512_491)\n---\nint exp;\nreal mantissa = frexp(123.456L, exp);\n\n// check if values are equal to 19 decimal digits of precision\nassert(equalsDigit(mantissa * pow(2.0L, cast(real)exp), 123.456L, 19));\n\nassert(frexp(-real.nan, exp) && exp == int.min);\nassert(frexp(real.nan, exp) && exp == int.min);\nassert(frexp(-real.infinity, exp) == -real.infinity && exp == int.min);\nassert(frexp(real.infinity, exp) == real.infinity && exp == int.max);\nassert(frexp(-0.0, exp) == -0.0 && exp == 0);\nassert(frexp(0.0, exp) == 0.0 && exp == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2512_491)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "ilogb",
				"line": 2611,
				"comment": " Extracts the exponent of x as a signed integral value.\n\n If x is not a special value, the result is the same as\n $(D cast(int)logb(x)).\n\n      $(TABLE_SV\n      $(TR $(TH x)                $(TH ilogb(x))     $(TH Range error?))\n      $(TR $(TD 0)                 $(TD FP_ILOGB0)   $(TD yes))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD int.max)     $(TD no))\n      $(TR $(TD $(NAN))            $(TD FP_ILOGBNAN) $(TD no))\n      )\n",
				"deco": "FNbNiNeeZi",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 2679,
				"char": 5,
				"kind": "function"
			},
			{
				"name": "ldexp",
				"line": 2722,
				"comment": " Compute n * 2$(SUPERSCRIPT exp)\n References: frexp\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2731_495)\n---\nimport std.typetuple;\nforeach(T; TypeTuple!(float, double, real))\n{\n    T r;\n\n    r = ldexp(3.0L, 3);\n    assert(r == 24);\n\n    r = ldexp(cast(T)3.0, cast(int) 3);\n    assert(r == 24);\n\n    T n = 3.0;\n    int exp = 3;\n    r = ldexp(n, exp);\n    assert(r == 24);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2731_495)\n",
				"deco": "FNaNbNiNfeiZe",
				"parameters": [
					{
						"name": "n",
						"deco": "e"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 92,
				"name": "ldexp",
				"line": 2725,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdiZd",
				"parameters": [
					{
						"name": "n",
						"deco": "d"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"endline": 2725,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 90,
				"name": "ldexp",
				"line": 2728,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffiZf",
				"parameters": [
					{
						"name": "n",
						"deco": "f"
					},
					{
						"name": "exp",
						"deco": "i"
					}
				],
				"endline": 2728,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log",
				"line": 2836,
				"comment": " Calculate the natural logarithm of x.\n\n    $(TABLE_SV\n    $(TR $(TH x)            $(TH log(x))    $(TH divide by 0?) $(TH invalid?))\n    $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n    $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n    $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n    )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2948_498)\n---\nassert(log(E) == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2948_498)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 2945,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log10",
				"line": 2963,
				"comment": " Calculate the base-10 logarithm of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH log10(x))  $(TH divide by 0?) $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n      $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n      $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n      )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3079_499)\n---\nassert(fabs(log10(1000) - 3) < .000001);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3079_499)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3076,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log1p",
				"line": 3098,
				"comment": "      Calculates the natural logarithm of 1 + x.\n\n      For very small x, log1p(x) will be more accurate than\n      log(1 + x).\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log1p(x))     $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no)           $(TD no))\n  $(TR $(TD -1.0)         $(TD -$(INFIN))    $(TD yes)          $(TD no))\n  $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD no)           $(TD yes))\n  $(TR $(TD +$(INFIN))    $(TD -$(INFIN))    $(TD no)           $(TD no))\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3120,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "log2",
				"line": 3133,
				"comment": " Calculates the base-2 logarithm of x:\n $(SUB log, 2)x\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log2(x))   $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no) )\n  $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes) )\n  $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no) )\n  )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3240_500)\n---\n// check if values are equal to 19 decimal digits of precision\nassert(equalsDigit(log2(1024.0L), 10, 19));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3240_500)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3237,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logb",
				"line": 3260,
				"comment": " Extracts the exponent of x as a signed integral value.\n\n If x is subnormal, it is treated as if it were normalized.\n For a positive, finite x:\n\n 1 $(LT)= $(I x) * FLT_RADIX$(SUPERSCRIPT -logb(x)) $(LT) FLT_RADIX\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH logb(x))   $(TH divide by 0?) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -$(INFIN)) $(TD yes) )\n      )\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3284,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "fmod",
				"line": 3300,
				"comment": " Calculates the remainder from the calculation x/y.\n Returns:\n The value of x - i * y, where i is the number of times that y can\n be completely subtracted from x. The result has the same sign as x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH y)             $(TH fmod(x, y))   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)   $(TD not 0.0)       $(TD $(PLUSMN)0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(NAN))       $(TD yes))\n  $(TR $(TD anything)       $(TD $(PLUSMN)0.0)  $(TD $(NAN))       $(TD yes))\n  $(TR $(TD !=$(PLUSMNINF)) $(TD $(PLUSMNINF))  $(TD x)            $(TD no))\n )\n",
				"deco": "FNbNiNeeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 3308,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "modf",
				"line": 3321,
				"comment": " Breaks x into an integral part and a fractional part, each of which has\n the same sign as x. The integral part is stored in i.\n Returns:\n The fractional part of x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH i (on input))  $(TH modf(x, i))   $(TH i (on return)))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(PLUSMN)0.0) $(TD $(PLUSMNINF)))\n )\n",
				"deco": "FNbNiNeeKeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "i",
						"storageClass": [
							"ref"
						],
						"deco": "e"
					}
				],
				"endline": 3330,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "scalbn",
				"line": 3344,
				"comment": " Efficiently calculates x * 2$(SUPERSCRIPT n).\n\n scalbn handles underflow and overflow in\n the same fashion as the basic arithmetic operators.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH scalb(x)))\n      $(TR $(TD $(PLUSMNINF))      $(TD $(PLUSMNINF)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) )\n      )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3377_501)\n---\nassert(scalbn(-real.infinity, 5) == -real.infinity);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3377_501)\n",
				"deco": "FNbNiNeeiZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "n",
						"deco": "i"
					}
				],
				"endline": 3374,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cbrt",
				"line": 3392,
				"comment": " Calculates the cube root of x.\n\n      $(TABLE_SV\n      $(TR $(TH $(I x))            $(TH cbrt(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no) )\n      $(TR $(TD $(NAN))            $(TD $(NAN))            $(TD yes) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no) )\n      )\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3403,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "fabs",
				"line": 3415,
				"comment": " Returns |x|\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH fabs(x)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )\n      )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "fabs",
				"line": 3418,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 3418,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "fabs",
				"line": 3421,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 3421,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "hypot",
				"line": 3443,
				"comment": " Calculates the length of the\n hypotenuse of a right-angled triangle with sides of length x and y.\n The hypotenuse is the value of the square root of\n the sums of the squares of x and y:\n\n      sqrt($(POWER x, 2) + $(POWER y, 2))\n\n Note that hypot(x, y), hypot(y, x) and\n hypot(x, -y) are equivalent.\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH y)            $(TH hypot(x, y)) $(TH invalid?))\n  $(TR $(TD x)            $(TD $(PLUSMN)0.0) $(TD |x|)         $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD y)            $(TD +$(INFIN))   $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD $(NAN))       $(TD +$(INFIN))   $(TD no))\n  )\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 3495,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ceil",
				"line": 3533,
				"comment": " Returns the value of x rounded upward to the next integer\n (toward positive infinity).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3587_503)\n---\nassert(ceil(+123.456L) == +124);\nassert(ceil(-123.456L) == -123);\nassert(ceil(-1.234L) == -1);\nassert(ceil(-0.123L) == 0);\nassert(ceil(0.0L) == 0);\nassert(ceil(+0.123L) == 1);\nassert(ceil(+1.234L) == 2);\nassert(ceil(real.infinity) == real.infinity);\nassert(isNaN(ceil(real.nan)));\nassert(isNaN(ceil(real.init)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3587_503)\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3584,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "floor",
				"line": 3661,
				"comment": " Returns the value of x rounded downward to the next integer\n (toward negative infinity).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3711_506)\n---\nassert(floor(+123.456L) == +123);\nassert(floor(-123.456L) == -124);\nassert(floor(-1.234L) == -2);\nassert(floor(-0.123L) == -1);\nassert(floor(0.0L) == 0);\nassert(floor(+0.123L) == 0);\nassert(floor(+1.234L) == 1);\nassert(floor(real.infinity) == real.infinity);\nassert(isNaN(floor(real.nan)));\nassert(isNaN(floor(real.init)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3711_506)\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3708,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nearbyint",
				"line": 3780,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n\n Unlike the rint functions, nearbyint does not raise the\n FE_INEXACT exception.\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3788,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "rint",
				"line": 3798,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n If the return value is not equal to x, the FE_INEXACT\n exception is raised.\n $(B nearbyint) performs\n the same operation, but does not set the FE_INEXACT exception.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "rint",
				"line": 3801,
				"comment": "ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 3801,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 74,
				"name": "rint",
				"line": 3804,
				"comment": "ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 3804,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "lrint",
				"line": 3816,
				"comment": " Rounds x to the nearest integer value, using the current rounding\n mode.\n\n This is generally the fastest method to convert a floating-point number\n to an integer. Note that the results from this function\n depend on the rounding mode, if the fractional part of x is exactly 0.5.\n If using the default rounding mode (ties round to even integers)\n lrint(4.5) == 4, lrint(5.5)==6.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3952_509)\n---\nassert(lrint(4.5) == 4);\nassert(lrint(5.5) == 6);\nassert(lrint(-4.5) == -4);\nassert(lrint(-5.5) == -6);\n\nassert(lrint(int.max - 0.5) == 2147483646L);\nassert(lrint(int.max + 0.5) == 2147483648L);\nassert(lrint(int.min - 0.5) == -2147483648L);\nassert(lrint(int.min + 0.5) == -2147483648L);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3952_509)\n",
				"deco": "FNaNbNiNeeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3949,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "round",
				"line": 3970,
				"comment": " Return the value of x rounded to the nearest integer.\n If the fractional part of x is exactly 0.5, the return value is rounded to\n the even integer.\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3982,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "lround",
				"line": 3990,
				"comment": " Return the value of x rounded to the nearest integer.\n\n If the fractional part of x is exactly 0.5, the return value is rounded\n away from zero.\n",
				"deco": "FNbNiNeeZl",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 3996,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "trunc",
				"line": 4013,
				"comment": " Returns the integer portion of x, dropping the fractional portion.\n\n This is also known as \"chop\" rounding.\n",
				"deco": "FNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 4054,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "remainder",
				"line": 4078,
				"comment": " Calculate the remainder x REM y, following IEC 60559.\n\n REM is the value of x - y * n, where n is the integer nearest the exact\n value of x / y.\n If |n - x / y| == 0.5, n is even.\n If the result is zero, it has the same sign as x.\n Otherwise, the sign of the result is the sign of x / y.\n Precision mode has no effect on the remainder functions.\n\n remquo returns n in the parameter n.\n\n $(TABLE_SV\n  $(TR $(TH x)               $(TH y)            $(TH remainder(x, y)) $(TH n)   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)    $(TD not 0.0)      $(TD $(PLUSMN)0.0)    $(TD 0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))    $(TD anything)     $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD anything)        $(TD $(PLUSMN)0.0) $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD != $(PLUSMNINF)) $(TD $(PLUSMNINF)) $(TD x)               $(TD ?)   $(TD no))\n )\n\n Note: remquo not supported on windows\n",
				"deco": "FNbNiNeeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 4087,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "IeeeFlags",
				"line": 4105,
				"comment": " IEEE exception status flags ('sticky bits')\n\n These flags indicate that an exceptional floating-point condition has occurred.\n They indicate that a NaN or an infinity has been generated, that a result\n is inexact, or that a signalling NaN has been encountered. If floating-point\n exceptions are enabled (unmasked), a hardware exception will be generated\n instead of setting these flags.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4248_511)\n---\nstatic void func() {\n    int a = 10 * 10;\n}\n\nreal a=3.5;\n// Set all the flags to zero\nresetIeeeFlags();\nassert(!ieeeFlags.divByZero);\n// Perform a division by zero.\na/=0.0L;\nassert(a==real.infinity);\nassert(ieeeFlags.divByZero);\n// Create a NaN\na*=0.0L;\nassert(ieeeFlags.invalid);\nassert(isNaN(a));\n\n// Check that calling func() has no effect on the\n// status flags.\nIeeeFlags f = ieeeFlags;\nfunc();\nassert(ieeeFlags == f);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4248_511)\n",
				"members": [
					{
						"endchar": 69,
						"name": "inexact",
						"line": 4230,
						"comment": "The result cannot be represented exactly, so rounding occurred.\n\n(example: x = sin(0.1); )\n",
						"deco": "FNdZb",
						"endline": 4230,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 73,
						"name": "underflow",
						"line": 4233,
						"comment": "A zero was generated by underflow (example: x = real.min*real.epsilon/2;)\n",
						"deco": "FNdZb",
						"endline": 4233,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 71,
						"name": "overflow",
						"line": 4236,
						"comment": "An infinity was generated by overflow (example: x = real.max*2;)\n",
						"deco": "FNdZb",
						"endline": 4236,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 73,
						"name": "divByZero",
						"line": 4239,
						"comment": "An infinity was generated by division by zero (example: x = 3/0.0; )\n",
						"deco": "FNdZb",
						"endline": 4239,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 69,
						"name": "invalid",
						"line": 4242,
						"comment": "A machine NaN was generated. (example: x = real.infinity * 0.0; )\n",
						"deco": "FNdZb",
						"endline": 4242,
						"char": 21,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 53,
				"name": "resetIeeeFlags",
				"line": 4284,
				"comment": "Set all of the floating-point status flags to false.\n",
				"deco": "FZv",
				"endline": 4284,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ieeeFlags",
				"line": 4287,
				"comment": "Return a snapshot of the current state of the floating-point status flags.\n",
				"deco": "FNdZS3std4math9IeeeFlags",
				"endline": 4290,
				"char": 21,
				"kind": "function"
			},
			{
				"name": "FloatingPointControl",
				"line": 4341,
				"comment": " Control the Floating point hardware\n\n  Change the IEEE754 floating-point rounding mode and the floating-point\n  hardware exceptions.\n\n  By default, the rounding mode is roundToNearest and all hardware exceptions\n  are disabled. For most applications, debugging is easier if the $(I division\n  by zero), $(I overflow), and $(I invalid operation) exceptions are enabled.\n  These three are combined into a $(I severeExceptions) value for convenience.\n  Note in particular that if $(I invalidException) is enabled, a hardware trap\n  will be generated whenever an uninitialized floating-point variable is used.\n\n  All changes are temporary. The previous state is restored at the\n  end of the scope.\n\n\nExample:\n----\n{\n    FloatingPointControl fpctrl;\n\n    // Enable hardware exceptions for division by zero, overflow to infinity,\n    // invalid operations, and uninitialized floating-point variables.\n    fpctrl.enableExceptions(FloatingPointControl.severeExceptions);\n\n    // This will generate a hardware exception, if x is a\n    // default-initialized floating point variable:\n    real x; // Add `= 0` or even `= real.nan` to not throw the exception.\n    real y = x * 3.0;\n\n    // The exception is only thrown for default-uninitialized NaN-s.\n    // NaN-s with other payload are valid:\n    real z = y * real.nan; // ok\n\n    // Changing the rounding mode:\n    fpctrl.rounding = FloatingPointControl.roundUp;\n    assert(rint(1.1) == 2);\n\n    // The set hardware exceptions will be disabled when leaving this scope.\n    // The original rounding mode will also be restored.\n}\n\n// Ensure previous values are returned:\nassert(!FloatingPointControl.enabledExceptions);\nassert(FloatingPointControl.rounding == FloatingPointControl.roundToNearest);\nassert(rint(1.1) == 1);\n----\n\n",
				"members": [
					{
						"name": "severeExceptions",
						"line": 4426,
						"value": "13u",
						"comment": "Severe = The overflow, division by zero, and invalid exceptions.\n",
						"char": 13,
						"kind": "enum member"
					},
					{
						"endchar": 5,
						"name": "hasExceptionTraps",
						"line": 4459,
						"comment": "Returns true if the current FPU supports exception trapping\n",
						"deco": "FNbNdNiNfZb",
						"endline": 4477,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "enableExceptions",
						"line": 4480,
						"comment": "Enable (unmask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
						"deco": "FNikZv",
						"parameters": [
							{
								"name": "exceptions",
								"deco": "k"
							}
						],
						"endline": 4488,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "disableExceptions",
						"line": 4491,
						"comment": "Disable (mask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
						"deco": "FNikZv",
						"parameters": [
							{
								"name": "exceptions",
								"deco": "k"
							}
						],
						"endline": 4499,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "rounding",
						"line": 4502,
						"comment": "Change the floating-point hardware rounding mode\n",
						"deco": "FNdNikZv",
						"parameters": [
							{
								"name": "newMode",
								"deco": "k"
							}
						],
						"endline": 4506,
						"originalType": "@nogc @property void(RoundingMode newMode)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "enabledExceptions",
						"line": 4509,
						"comment": "Return the exceptions which are currently enabled (unmasked)\n",
						"deco": "FNdNiZk",
						"endline": 4516,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "rounding",
						"line": 4519,
						"comment": "Return the currently active rounding mode\n",
						"deco": "FNdNiZk",
						"endline": 4522,
						"originalType": "@nogc @property RoundingMode()",
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 4525,
						"comment": "Clear all pending exceptions, then restore the original exception state and rounding mode.\n",
						"deco": "FNiZv",
						"endline": 4530,
						"char": 5,
						"kind": "destructor"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isNaN",
						"line": 4676,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 4711,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isNaN",
				"line": 4676,
				"comment": " Determines if $(D_PARAM x) is NaN.\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is Nan.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4714_513)\n---\nassert( isNaN(float.init));\nassert( isNaN(-double.init));\nassert( isNaN(real.nan));\nassert( isNaN(-real.nan));\nassert(!isNaN(cast(float)53.6));\nassert(!isNaN(cast(real)-53.6));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4714_513)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!X",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isFinite",
						"line": 4771,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 4776,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isFinite",
				"line": 4771,
				"comment": " Determines if $(D_PARAM x) is finite.\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is finite.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4779_515)\n---\nassert( isFinite(1.23f));\nassert( isFinite(float.max));\nassert( isFinite(float.min_normal));\nassert(!isFinite(float.nan));\nassert(!isFinite(float.infinity));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4779_515)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isNormal",
						"line": 4825,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 4838,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isNormal",
				"line": 4825,
				"comment": " Determines if $(D_PARAM x) is normalized.\n\n A normalized number must not be zero, subnormal, infinite nor $(NAN).\n\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is normalized.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4841_517)\n---\nfloat f = 3;\ndouble d = 500;\nreal e = 10e+48;\n\nassert(isNormal(f));\nassert(isNormal(d));\nassert(isNormal(e));\nf = d = e = 0;\nassert(!isNormal(f));\nassert(!isNormal(d));\nassert(!isNormal(e));\nassert(!isNormal(real.infinity));\nassert(isNormal(-real.max));\nassert(!isNormal(real.min_normal/4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4841_517)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isSubnormal",
						"line": 4871,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 4911,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isSubnormal",
				"line": 4871,
				"comment": " Determines if $(D_PARAM x) is subnormal.\n\n Subnormals (also known as \"denormal number\"), have a 0 exponent\n and a 0 most significant mantissa bit.\n\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is a denormal number.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4914_518)\n---\nimport std.typetuple;\n\nforeach (T; TypeTuple!(float, double, real))\n{\n    T f;\n    for (f = 1.0; !isSubnormal(f); f /= 2)\n        assert(f != 0);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4914_518)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isInfinity",
						"line": 4940,
						"type": "pure nothrow @nogc @trusted bool(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 4977,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isInfinity",
				"line": 4940,
				"comment": " Determines if $(D_PARAM x) is $(PLUSMN)$(INFIN).\n params:\n  x = a floating point number.\n returns:\n  $(D true) if $(D_PARAM x) is $(PLUSMN)$(INFIN).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4980_519)\n---\nassert(!isInfinity(float.init));\nassert(!isInfinity(-float.init));\nassert(!isInfinity(float.nan));\nassert(!isInfinity(-float.nan));\nassert(isInfinity(float.infinity));\nassert(isInfinity(-float.infinity));\nassert(isInfinity(-1.0f / 0.0f));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4980_519)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!X",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isIdentical",
				"line": 5057,
				"comment": " Is the binary representation of x identical to y?\n\n Same as ==, except that positive and negative zero are not identical,\n and two $(NAN)s are identical if they have the same 'payload'.\n",
				"deco": "FNaNbNiNeeeZb",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5078,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "signbit",
						"line": 5083,
						"type": "pure nothrow @nogc @trusted int(X x)",
						"parameters": [
							{
								"name": "x",
								"type": "X"
							}
						],
						"endline": 5087,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "signbit",
				"line": 5083,
				"comment": " Return 1 if sign bit of e is set, 0 if not.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5090_521)\n---\ndebug (math) printf(\"math.signbit.unittest\\n\");\nassert(!signbit(float.nan));\nassert(signbit(-float.nan));\nassert(!signbit(168.1234f));\nassert(signbit(-168.1234f));\nassert(!signbit(0.0f));\nassert(signbit(-0.0f));\nassert(signbit(-float.max));\nassert(!signbit(float.max));\n\nassert(!signbit(double.nan));\nassert(signbit(-double.nan));\nassert(!signbit(168.1234));\nassert(signbit(-168.1234));\nassert(!signbit(0.0));\nassert(signbit(-0.0));\nassert(signbit(-double.max));\nassert(!signbit(double.max));\n\nassert(!signbit(real.nan));\nassert(signbit(-real.nan));\nassert(!signbit(168.1234L));\nassert(signbit(-168.1234L));\nassert(!signbit(0.0L));\nassert(signbit(-0.0L));\nassert(signbit(-real.max));\nassert(!signbit(real.max));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5090_521)\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "copysign",
						"line": 5132,
						"type": "pure nothrow @nogc @trusted R(R to, X from)",
						"parameters": [
							{
								"name": "to",
								"type": "R"
							},
							{
								"name": "from",
								"type": "X"
							}
						],
						"endline": 5143,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "copysign",
				"line": 5132,
				"comment": " Return a value composed of to with from's sign bit.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!R && isFloatingPoint!X",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sgn",
						"line": 5199,
						"type": "pure nothrow @nogc @safe F(F x)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							}
						],
						"endline": 5203,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "sgn",
				"line": 5199,
				"comment": "Returns $(D -1) if $(D x < 0), $(D x) if $(D x == 0), $(D 1) if\n$(D x > 0), and $(NAN) if x==$(NAN).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5206_523)\n---\nassert(sgn(168.1234) == 1);\nassert(sgn(-168.1234) == -1);\nassert(sgn(0.0) == 0);\nassert(sgn(-0.0) == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5206_523)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "NaN",
				"line": 5228,
				"comment": " Create a quiet $(NAN), storing an integer inside the payload.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n",
				"deco": "FNaNbNiNemZe",
				"parameters": [
					{
						"name": "payload",
						"deco": "m"
					}
				],
				"endline": 5293,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getNaNPayload",
				"line": 5316,
				"comment": " Extract an integral payload from a $(NAN).\n\n Returns:\n the integer payload as a ulong.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n",
				"deco": "FNaNbNiNeeZm",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 5354,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextUp",
				"line": 5398,
				"comment": " Calculate the next largest floating point value after x.\n\n Return the least number greater than x that is representable as a real;\n thus, it gives the next point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextUp(x)   )\n    $(SV  -$(INFIN),    -real.max   )\n    $(SV  $(PLUSMN)0.0, real.min_normal*real.epsilon )\n    $(SV  real.max,     $(INFIN) )\n    $(SV  $(INFIN),     $(INFIN) )\n    $(SV  $(NAN),       $(NAN)   )\n )\n",
				"deco": "FNaNbNiNeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 5495,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextUp",
				"line": 5498,
				"comment": " ditto\n",
				"deco": "FNaNbNiNedZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 5522,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextUp",
				"line": 5525,
				"comment": " ditto\n",
				"deco": "FNaNbNiNefZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 5552,
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextDown",
				"line": 5569,
				"comment": " Calculate the next smallest floating point value before x.\n\n Return the greatest number less than x that is representable as a real;\n thus, it gives the previous point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextDown(x)   )\n    $(SV  $(INFIN),     real.max  )\n    $(SV  $(PLUSMN)0.0, -real.min_normal*real.epsilon )\n    $(SV  -real.max,    -$(INFIN) )\n    $(SV  -$(INFIN),    -$(INFIN) )\n    $(SV  $(NAN),       $(NAN)    )\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5587_526)\n---\nassert( nextDown(1.0 + real.epsilon) == 1.0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5587_526)\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 5572,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextDown",
				"line": 5575,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfdZd",
				"parameters": [
					{
						"name": "x",
						"deco": "d"
					}
				],
				"endline": 5578,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "nextDown",
				"line": 5581,
				"comment": " ditto\n",
				"deco": "FNaNbNiNffZf",
				"parameters": [
					{
						"name": "x",
						"deco": "f"
					}
				],
				"endline": 5584,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nextafter",
						"line": 5675,
						"type": "pure nothrow @nogc @safe T(const T x, const T y)",
						"parameters": [
							{
								"name": "x",
								"type": "T",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "y",
								"type": "T",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 5679,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "nextafter",
				"line": 5675,
				"comment": " Calculates the next representable value after x in the direction of y.\n\n If y > x, the result will be the next largest floating-point value;\n if y < x, the result will be the next smallest value.\n If x == y, the result is y.\n\n Remarks:\n This function is not generally very useful; it's almost always better to use\n the faster functions nextUp() or nextDown() instead.\n\n The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and\n the function result is infinite. The FE_INEXACT and FE_UNDERFLOW\n exceptions will be raised if the function value is subnormal, and x is\n not equal to y.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5682_528)\n---\nfloat a = 1;\nassert(is(typeof(nextafter(a, a)) == float));\nassert(nextafter(a, a.infinity) > a);\n\ndouble b = 2;\nassert(is(typeof(nextafter(b, b)) == double));\nassert(nextafter(b, b.infinity) > b);\n\nreal c = 3;\nassert(is(typeof(nextafter(c, c)) == real));\nassert(nextafter(c, c.infinity) > c);\n}\n\n//real nexttoward(real x, real y) { return core.stdc.math.nexttowardl(x, y); }\n\n/*******************************************\n* Returns the positive difference between x and y.\n* Returns:\n*      $(TABLE_SV\n*      $(TR $(TH x, y)       $(TH fdim(x, y)))\n*      $(TR $(TD x $(GT) y)  $(TD x - y))\n*      $(TR $(TD x $(LT)= y) $(TD +0.0))\n*      )\n*/\nreal fdim(real x, real y) @safe pure nothrow @nogc { return (x > y) ? x - y : +0.0; \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5682_528)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 85,
				"name": "fdim",
				"line": 5708,
				"comment": " Returns the positive difference between x and y.\n Returns:\n      $(TABLE_SV\n      $(TR $(TH x, y)       $(TH fdim(x, y)))\n      $(TR $(TD x $(GT) y)  $(TD x - y))\n      $(TR $(TD x $(LT)= y) $(TD +0.0))\n      )\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5708,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "fmax",
				"line": 5713,
				"comment": " Returns the larger of x and y.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5713,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 76,
				"name": "fmin",
				"line": 5718,
				"comment": " Returns the smaller of x and y.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 5718,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 81,
				"name": "fma",
				"line": 5726,
				"comment": " Returns (x * y) + z, rounding only once according to the\n current rounding mode.\n\n BUGS: Not currently implemented - rounds twice.\n",
				"deco": "FNaNbNiNfeeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					},
					{
						"name": "z",
						"deco": "e"
					}
				],
				"endline": 5726,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 5731,
						"type": "pure nothrow @nogc @trusted Unqual!F(F x, G n)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							},
							{
								"name": "n",
								"type": "G"
							}
						],
						"endline": 5776,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 5731,
				"comment": " Compute the value of x $(SUPERSCRIPT n), where n is an integer\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F && isIntegral!G",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 5833,
						"type": "pure nothrow @nogc @trusted typeof(Unqual!F.init * Unqual!G.init)(F x, G n)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							},
							{
								"name": "n",
								"type": "G"
							}
						],
						"endline": 5868,
						"char": 43,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 5833,
				"comment": " Compute the value of an integer x, raised to the power of a positive\n integer n.\n\n  If both x and n are 0, the result is 1.\n  If n is negative, an integer divide error will occur at runtime,\n regardless of the value of x.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5871_531)\n---\nimmutable int one = 1;\nimmutable byte two = 2;\nimmutable ubyte three = 3;\nimmutable short four = 4;\nimmutable long ten = 10;\n\nassert(pow(two, three) == 8);\nassert(pow(two, ten) == 1024);\nassert(pow(one, ten) == 1);\nassert(pow(ten, four) == 10_000);\nassert(pow(four, 10) == 1_048_576);\nassert(pow(three, four) == 81);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5871_531)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!F && isIntegral!G",
				"char": 43,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 5889,
						"type": "pure nothrow @nogc @trusted real(I x, F y)",
						"parameters": [
							{
								"name": "x",
								"type": "I"
							},
							{
								"name": "y",
								"type": "F"
							}
						],
						"endline": 5893,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 5889,
				"comment": "Computes integer to floating point powers.\n",
				"parameters": [
					{
						"name": "I",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!I && isFloatingPoint!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pow",
						"line": 5937,
						"type": "pure nothrow @nogc @trusted Unqual!(Largest!(F, G))(F x, G y)",
						"parameters": [
							{
								"name": "x",
								"type": "F"
							},
							{
								"name": "y",
								"type": "G"
							}
						],
						"endline": 6118,
						"char": 25,
						"kind": "function"
					}
				],
				"name": "pow",
				"line": 5937,
				"comment": " Calculates x$(SUPERSCRIPT y).\n\n $(TABLE_SV\n $(TR $(TH x) $(TH y) $(TH pow(x, y))\n      $(TH div 0) $(TH invalid?))\n $(TR $(TD anything)      $(TD $(PLUSMN)0.0)                $(TD 1.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD +$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD +$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD -$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD -$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(GT) 0.0)                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(LT) 0.0)                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD odd integer $(GT) 0.0)      $(TD -$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(GT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD no)        $(TD no))\n $(TR $(TD -$(INFIN))      $(TD odd integer $(LT) 0.0)      $(TD -0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(LT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)1.0)   $(TD $(PLUSMN)$(INFIN))          $(TD $(NAN))\n      $(TD no)        $(TD yes) )\n $(TR $(TD $(LT) 0.0)      $(TD finite, nonintegral)        $(TD $(NAN))\n      $(TD no)        $(TD yes))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(LT) 0.0)      $(TD $(PLUSMNINF))\n      $(TD yes)       $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(LT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD yes)       $(TD no))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(GT) 0.0)      $(TD $(PLUSMN)0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(GT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n )\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F && isFloatingPoint!G",
				"char": 25,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "feqrel",
						"line": 6193,
						"type": "pure nothrow @nogc @trusted int(const X x, const X y)",
						"parameters": [
							{
								"name": "x",
								"type": "X",
								"storageClass": [
									"const"
								]
							},
							{
								"name": "y",
								"type": "X",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 6263,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "feqrel",
				"line": 6193,
				"comment": " To what precision is x equal to y?\n\n Returns: the number of mantissa bits which are equal in x and y.\n eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.\n\n      $(TABLE_SV\n      $(TR $(TH x)      $(TH y)          $(TH feqrel(x, y)))\n      $(TR $(TD x)      $(TD x)          $(TD real.mant_dig))\n      $(TR $(TD x)      $(TD $(GT)= 2*x) $(TD 0))\n      $(TR $(TD x)      $(TD $(LT)= x/2) $(TD 0))\n      $(TR $(TD $(NAN)) $(TD any)        $(TD 0))\n      $(TR $(TD any)    $(TD $(NAN))     $(TD 0))\n      )\n",
				"parameters": [
					{
						"name": "X",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!X",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "poly",
						"line": 6480,
						"type": "pure nothrow @nogc @trusted Unqual!(CommonType!(T1, T2))(T1 x, in T2[] A)",
						"parameters": [
							{
								"name": "x",
								"type": "T1"
							},
							{
								"name": "A",
								"type": "T2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 6496,
						"char": 30,
						"kind": "function"
					}
				],
				"name": "poly",
				"line": 6480,
				"comment": " Evaluate polynomial A(x) = $(SUB a, 0) + $(SUB a, 1)x + $(SUB a, 2)$(POWER x,2)\n                          + $(SUB a,3)$(POWER x,3); ...\n\n Uses Horner's rule A(x) = $(SUB a, 0) + x($(SUB a, 1) + x($(SUB a, 2)\n                         + x($(SUB a, 3) + ...)))\n Params:\n      x =     the value to evaluate.\n      A =     array of coefficients $(SUB a, 0), $(SUB a, 1), etc.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6499_535)\n---\ndouble x = 3.1;\nstatic real[] pp = [56.1, 32.7, 6];\n\nassert(poly(x, pp) == (56.1L + (32.7L + 6.0L * x) * x));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6499_535)\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T1 && isFloatingPoint!T2",
				"char": 30,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "approxEqual",
						"line": 6678,
						"type": "bool(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 1e-05)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T"
							},
							{
								"name": "rhs",
								"type": "U"
							},
							{
								"name": "maxRelDiff",
								"type": "V"
							},
							{
								"name": "maxAbsDiff",
								"type": "V",
								"default": "1e-05"
							}
						],
						"endline": 6739,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "approxEqual",
				"line": 6678,
				"comment": "   Computes whether $(D lhs) is approximately equal to $(D rhs)\n   admitting a maximum relative difference $(D maxRelDiff) and a\n   maximum absolute difference $(D maxAbsDiff).\n\n   If the two inputs are ranges, $(D approxEqual) returns true if and\n   only if the ranges have the same number of elements and if $(D\n   approxEqual) evaluates to $(D true) for each pair of elements.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "V",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "approxEqual",
						"line": 6744,
						"type": "bool(T lhs, U rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T"
							},
							{
								"name": "rhs",
								"type": "U"
							}
						],
						"endline": 6747,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "approxEqual",
				"line": 6744,
				"comment": "   Returns $(D approxEqual(lhs, rhs, 1e-2, 1e-5)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6750_538)\n---\nassert(approxEqual(1.0, 1.0099));\nassert(!approxEqual(1.0, 1.011));\nfloat[] arr1 = [ 1.0, 2.0, 3.0 ];\ndouble[] arr2 = [ 1.001, 1.999, 3 ];\nassert(approxEqual(arr1, arr2));\n\nreal num = real.infinity;\nassert(num == real.infinity);  // Passes.\nassert(approxEqual(num, real.infinity));  // Fails.\nnum = -real.infinity;\nassert(num == -real.infinity);  // Passes.\nassert(approxEqual(num, -real.infinity));  // Fails.\n\nassert(!approxEqual(3, 0));\nassert(approxEqual(3, 3));\nassert(approxEqual(3.0, 3));\nassert(approxEqual([3, 3, 3], 3.0));\nassert(approxEqual([3.0, 3.0, 3.0], 3));\nint a = 10;\nassert(approxEqual(10, a));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6750_538)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " Contains the elementary mathematical functions (powers, roots,\n and trigonometric functions), and low-level floating-point operations.\n Mathematical special functions are available in $(D std.mathspecial).\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Members) )\n$(TR $(TDNW Constants) $(TD\n    $(MYREF E) $(MYREF PI) $(MYREF PI_2) $(MYREF PI_4) $(MYREF M_1_PI)\n    $(MYREF M_2_PI) $(MYREF M_2_SQRTPI) $(MYREF LN10) $(MYREF LN2)\n    $(MYREF LOG2) $(MYREF LOG2E) $(MYREF LOG2T) $(MYREF LOG10E)\n    $(MYREF SQRT2) $(MYREF SQRT1_2)\n))\n$(TR $(TDNW Classics) $(TD\n $(MYREF abs) $(MYREF fabs) $(MYREF sqrt) $(MYREF cbrt) $(MYREF hypot) $(MYREF poly)\n))\n$(TR $(TDNW Trigonometry) $(TD\n    $(MYREF sin) $(MYREF cos) $(MYREF tan) $(MYREF asin) $(MYREF acos)\n    $(MYREF atan) $(MYREF atan2) $(MYREF sinh) $(MYREF cosh) $(MYREF tanh)\n    $(MYREF asinh) $(MYREF acosh) $(MYREF atanh) $(MYREF expi)\n))\n$(TR $(TDNW Rounding) $(TD\n    $(MYREF ceil) $(MYREF floor) $(MYREF round) $(MYREF lround)\n    $(MYREF trunc) $(MYREF rint) $(MYREF lrint) $(MYREF nearbyint)\n    $(MYREF rndtol)\n))\n$(TR $(TDNW Exponentiation & Logarithms) $(TD\n    $(MYREF pow) $(MYREF exp) $(MYREF exp2) $(MYREF expm1) $(MYREF ldexp)\n    $(MYREF frexp) $(MYREF log) $(MYREF log2) $(MYREF log10) $(MYREF logb)\n    $(MYREF ilogb) $(MYREF log1p) $(MYREF scalbn)\n))\n$(TR $(TDNW Modulus) $(TD\n    $(MYREF fmod) $(MYREF modf) $(MYREF remainder)\n))\n$(TR $(TDNW Floating-point operations) $(TD\n    $(MYREF approxEqual) $(MYREF feqrel) $(MYREF fdim) $(MYREF fmax)\n    $(MYREF fmin) $(MYREF fma) $(MYREF nextDown) $(MYREF nextUp)\n    $(MYREF nextafter) $(MYREF NaN) $(MYREF getNaNPayload)\n))\n$(TR $(TDNW Introspection) $(TD\n    $(MYREF isFinite) $(MYREF isIdentical) $(MYREF isInfinity) $(MYREF isNaN)\n    $(MYREF isNormal) $(MYREF isSubnormal) $(MYREF signbit) $(MYREF sgn)\n    $(MYREF copysign)\n))\n$(TR $(TDNW Complex Numbers) $(TD\n  $(MYREF abs) $(MYREF conj) $(MYREF sin) $(MYREF cos) $(MYREF expi)\n))\n$(TR $(TDNW Hardware Control) $(TD\n    $(MYREF IeeeFlags) $(MYREF FloatingPointControl)\n))\n)\n)\n\n The functionality closely follows the IEEE754-2008 standard for\n floating-point arithmetic, including the use of camelCase names rather\n than C99-style lower case names. All of these functions behave correctly\n when presented with an infinity or NaN.\n\n The following IEEE 'real' formats are currently supported:\n $(UL\n $(LI 64 bit Big-endian  'double' (eg PowerPC))\n $(LI 128 bit Big-endian 'quadruple' (eg SPARC))\n $(LI 64 bit Little-endian 'double' (eg x86-SSE2))\n $(LI 80 bit Little-endian, with implied bit 'real80' (eg x87, Itanium))\n $(LI 128 bit Little-endian 'quadruple' (not implemented on any known processor!))\n $(LI Non-IEEE 128 bit Big-endian 'doubledouble' (eg PowerPC) has partial support)\n )\n Unlike C, there is no global 'errno' variable. Consequently, almost all of\n these functions are pure nothrow.\n\n Status:\n The semantics and names of feqrel and approxEqual will be revised.\n\n Macros:\n      WIKI = Phobos/StdMath\n\n      TABLE_SV = <table border=1 cellpadding=4 cellspacing=0>\n              <caption>Special Values</caption>\n              $0</table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n      TH3 = $(TR $(TH $1) $(TH $2) $(TH $3))\n      TD3 = $(TR $(TD $1) $(TD $2) $(TD $3))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)\n      POWER = $1<sup>$2</sup>\n      SUB = $1<sub>$2</sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2</sup><sub>$(SMALL $1)</sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)</sup><sub>$(SMALL $2)</sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n            D implementations of tan, atan, atan2, exp, expm1, exp2, log, log10, log1p,\n            log2, floor, ceil and lrint functions are based on the CEPHES math library,\n            which is Copyright (C) 2001 Stephen L. Moshier <steve@moshier.net>\n            and are incorporated herein by permission of the author.  The author\n            reserves the right to distribute this material elsewhere under different\n            copying permissions.  These modifications are distributed here under\n            the following terms:\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright), Don Clugston,\n            Conversion of CEPHES math library to D by Iain Buclaw\n Source: $(PHOBOSSRC std/_math.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/mathspecial.d",
		"name": "std.mathspecial",
		"members": [
			{
				"endchar": 1,
				"name": "gamma",
				"line": 90,
				"comment": " The Gamma function, $(GAMMA)(x)\n\n  $(GAMMA)(x) is a generalisation of the factorial function\n  to real and complex numbers.\n  Like x!, $(GAMMA)(x+1) = x * $(GAMMA)(x).\n\n  Mathematically, if z.re > 0 then\n   $(GAMMA)(z) = $(INTEGRATE 0, $(INFIN)) $(POWER t, z-1)$(POWER e, -t) dt\n\n  $(TABLE_SV\n    $(SVH  x,           $(GAMMA)(x) )\n    $(SV  $(NAN),       $(NAN)      )\n    $(SV  $(PLUSMN)0.0, $(PLUSMNINF))\n    $(SV integer > 0,   (x-1)!      )\n    $(SV integer < 0,   $(NAN)      )\n    $(SV +$(INFIN),      +$(INFIN)   )\n    $(SV -$(INFIN),      $(NAN)      )\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 93,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logGamma",
				"line": 109,
				"comment": " Natural logarithm of the gamma function, $(GAMMA)(x)\n\n Returns the base e (2.718...) logarithm of the absolute\n value of the gamma function of the argument.\n\n For reals, logGamma is equivalent to log(fabs(gamma(x))).\n\n  $(TABLE_SV\n    $(SVH  x,             logGamma(x)   )\n    $(SV  $(NAN),         $(NAN)      )\n    $(SV integer <= 0,    +$(INFIN)    )\n    $(SV $(PLUSMNINF),    +$(INFIN)    )\n  )\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 112,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sgnGamma",
				"line": 122,
				"comment": " The sign of $(GAMMA)(x).\n\n Returns -1 if $(GAMMA)(x) < 0,  +1 if $(GAMMA)(x) > 0,\n $(NAN) if sign is indeterminate.\n\n Note that this function can be used in conjunction with logGamma(x) to\n evaluate gamma for very large values of x.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 137,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "beta",
				"line": 154,
				"comment": " Beta function\n\n The beta function is defined as\n\n beta(x, y) = ($(GAMMA)(x) * $(GAMMA)(y)) / $(GAMMA)(x + y)\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 159,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "digamma",
				"line": 174,
				"comment": " Digamma function\n\n  The digamma function is the logarithmic derivative of the gamma function.\n\n  digamma(x) = d/dx logGamma(x)\n\n  See_Also: $(LREF logmdigamma), $(LREF logmdigammaInverse).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 177,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logmdigamma",
				"line": 185,
				"comment": " Log Minus Digamma function\n\n  logmdigamma(x) = log(x) - digamma(x)\n\n  See_Also: $(LREF digamma), $(LREF logmdigammaInverse).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 188,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "logmdigammaInverse",
				"line": 196,
				"comment": " Inverse of the Log Minus Digamma function\n\n  Given y, the function finds x such log(x) - digamma(x) = y.\n\n  See_Also: $(LREF logmdigamma), $(LREF digamma).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 199,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "betaIncomplete",
				"line": 221,
				"comment": " Incomplete beta integral\n\n Returns incomplete beta integral of the arguments, evaluated\n from zero to x. The regularized incomplete beta function is defined as\n\n betaIncomplete(a, b, x) = $(GAMMA)(a + b) / ( $(GAMMA)(a) $(GAMMA)(b) ) *\n $(INTEGRATE 0, x) $(POWER t, a-1)$(POWER (1-t), b-1) dt\n\n and is the same as the the cumulative distribution function.\n\n The domain of definition is 0 <= x <= 1.  In this\n implementation a and b are restricted to positive values.\n The integral from x to 1 may be obtained by the symmetry\n relation\n\n    betaIncompleteCompl(a, b, x )  =  betaIncomplete( b, a, 1-x )\n\n The integral is evaluated by a continued fraction expansion\n or, when b * x is small, by a power series.\n",
				"deco": "FNaNbNiNfeeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "b",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 224,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "betaIncompleteInverse",
				"line": 234,
				"comment": " Inverse of incomplete beta integral\n\n Given y, the function finds x such that\n\n  betaIncomplete(a, b, x) == y\n\n  Newton iterations or interval halving is used.\n",
				"deco": "FNaNbNiNfeeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "b",
						"deco": "e"
					},
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 237,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "gammaIncomplete",
				"line": 253,
				"comment": " Incomplete gamma integral and its complement\n\n These functions are defined by\n\n   gammaIncomplete = ( $(INTEGRATE 0, x) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)\n\n  gammaIncompleteCompl(a,x)   =   1 - gammaIncomplete(a,x)\n = ($(INTEGRATE x, $(INFIN)) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)\n\n In this implementation both arguments must be positive.\n The integral is evaluated by either a power series or\n continued fraction expansion, depending on the relative\n values of a and x.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 260,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "gammaIncompleteCompl",
				"line": 263,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 270,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "gammaIncompleteComplInverse",
				"line": 278,
				"comment": " Inverse of complemented incomplete gamma integral\n\n Given a and p, the function finds x such that\n\n  gammaIncompleteCompl( a, x ) = p.\n",
				"deco": "FNaNbNiNfeeZe",
				"parameters": [
					{
						"name": "a",
						"deco": "e"
					},
					{
						"name": "p",
						"deco": "e"
					}
				],
				"endline": 285,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "erf",
				"line": 302,
				"comment": " Error function\n\n The integral is\n\n  erf(x) =  2/ $(SQRT)($(PI))\n     $(INTEGRATE 0, x) exp( - $(POWER t, 2)) dt\n\n The magnitude of x is limited to about 106.56 for IEEE 80-bit\n arithmetic; 1 or -1 is returned outside this range.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 305,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "erfc",
				"line": 316,
				"comment": " Complementary error function\n\n erfc(x) = 1 - erf(x)\n         = 2/ $(SQRT)($(PI))\n     $(INTEGRATE x, $(INFIN)) exp( - $(POWER t, 2)) dt\n\n This function has high relative accuracy for\n values of x far from zero. (For values near zero, use erf(x)).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 319,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "normalDistribution",
				"line": 339,
				"comment": " Normal distribution function.\n\n The normal (or Gaussian, or bell-shaped) distribution is\n defined as:\n\n normalDist(x) = 1/$(SQRT)(2$(PI)) $(INTEGRATE -$(INFIN), x) exp( - $(POWER t, 2)/2) dt\n   = 0.5 + 0.5 * erf(x/sqrt(2))\n   = 0.5 * erfc(- x/sqrt(2))\n\n To maintain accuracy at values of x near 1.0, use\n      normalDistribution(x) = 1.0 - normalDistribution(-x).\n\n References:\n $(LINK http://www.netlib.org/cephes/ldoubdoc.html),\n G. Marsaglia, \"Evaluating the Normal Distribution\",\n Journal of Statistical Software <b>11</b>, (July 2004).\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "x",
						"deco": "e"
					}
				],
				"endline": 342,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "normalDistributionInverse",
				"line": 350,
				"comment": " Inverse of Normal distribution function\n\n Returns the argument, x, for which the area under the\n Normal probability density function (integrated from\n minus infinity to x) is equal to p.\n",
				"deco": "FNaNbNiNfeZe",
				"parameters": [
					{
						"name": "p",
						"deco": "e"
					}
				],
				"endline": 357,
				"char": 6,
				"kind": "function"
			}
		],
		"comment": " Mathematical Special Functions\n\n The technical term 'Special Functions' includes several families of\n transcendental functions, which have important applications in particular\n branches of mathematics and physics.\n\n The gamma and related functions, and the error function are crucial for\n mathematical statistics.\n The Bessel and related functions arise in problems involving wave propagation\n (especially in optics).\n Other major categories of special functions include the elliptic integrals\n (related to the arc length of an ellipse), and the hypergeometric functions.\n\n Status:\n  Many more functions will be added to this module.\n  The naming convention for the distribution functions (gammaIncomplete, etc)\n  is not yet finalized and will probably change.\n\n Macros:\n      WIKI = Phobos/StdMathSpecial\n\n      TABLE_SV = <table border=1 cellpadding=4 cellspacing=0>\n              <caption>Special Values</caption>\n              $0</table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)\n      POWER = $1<sup>$2</sup>\n      SUB = $1<sub>$2</sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2</sup><sub>$(SMALL $1)</sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)</sup><sub>$(SMALL $2)</sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n\n Copyright: Based on the CEPHES math library, which is\n            Copyright (C) 1994 Stephen L. Moshier (moshier@world.std.com).\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Stephen L. Moshier (original C code). Conversion to D by Don Clugston\n Source:    $(PHOBOSSRC std/_mathspecial.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/process.d",
		"name": "std.process",
		"members": [
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 289,
				"comment": "Spawns a new _process, optionally assigning it an arbitrary set of standard\ninput, output, and error streams.\n\nThe function returns immediately, leaving the child _process to execute\nin parallel with its parent.  It is recommended to always call $(LREF wait)\non the returned $(LREF Pid), as detailed in the documentation for $(D wait).\n\nCommand_line:\nThere are four overloads of this function.  The first two take an array\nof strings, $(D args), which should contain the program name as the\nzeroth element and any command-line arguments in subsequent elements.\nThe third and fourth versions are included for convenience, and may be\nused when there are no command-line arguments.  They take a single string,\n$(D program), which specifies the program name.\n\nUnless a directory is specified in $(D args[0]) or $(D program),\n$(D spawnProcess) will search for the program in a platform-dependent\nmanner.  On POSIX systems, it will look for the executable in the\ndirectories listed in the PATH environment variable, in the order\nthey are listed.  On Windows, it will search for the executable in\nthe following sequence:\n$(OL\n    $(LI The directory from which the application loaded.)\n    $(LI The current directory for the parent process.)\n    $(LI The 32-bit Windows system directory.)\n    $(LI The 16-bit Windows system directory.)\n    $(LI The Windows directory.)\n    $(LI The directories listed in the PATH environment variable.)\n)\n---\n// Run an executable called \"prog\" located in the current working\n// directory:\nauto pid = spawnProcess(\"./prog\");\nscope(exit) wait(pid);\n// We can do something else while the program runs.  The scope guard\n// ensures that the process is waited for at the end of the scope.\n...\n\n// Run DMD on the file \"myprog.d\", specifying a few compiler switches:\nauto dmdPid = spawnProcess([\"dmd\", \"-O\", \"-release\", \"-inline\", \"myprog.d\" ]);\nif (wait(dmdPid) != 0)\n    writeln(\"Compilation failed!\");\n---\n\nEnvironment_variables:\nBy default, the child process inherits the environment of the parent\nprocess, along with any additional variables specified in the $(D env)\nparameter.  If the same variable exists in both the parent's environment\nand in $(D env), the latter takes precedence.\n\nIf the $(LREF Config.newEnv) flag is set in $(D config), the child\nprocess will $(I not) inherit the parent's environment.  Its entire\nenvironment will then be determined by $(D env).\n---\nwait(spawnProcess(\"myapp\", [\"foo\" : \"bar\"], Config.newEnv));\n---\n\nStandard_streams:\nThe optional arguments $(D stdin), $(D stdout) and $(D stderr) may\nbe used to assign arbitrary $(XREF stdio,File) objects as the standard\ninput, output and error streams, respectively, of the child process.  The\nformer must be opened for reading, while the latter two must be opened for\nwriting.  The default is for the child process to inherit the standard\nstreams of its parent.\n---\n// Run DMD on the file myprog.d, logging any error messages to a\n// file named errors.log.\nauto logFile = File(\"errors.log\", \"w\");\nauto pid = spawnProcess([\"dmd\", \"myprog.d\"],\n                        std.stdio.stdin,\n                        std.stdio.stdout,\n                        logFile);\nif (wait(pid) != 0)\n    writeln(\"Compilation failed. See errors.log for details.\");\n---\n\nNote that if you pass a $(D File) object that is $(I not)\none of the standard input/output/error streams of the parent process,\nthat stream will by default be $(I closed) in the parent process when\nthis function returns.  See the $(LREF Config) documentation below for\ninformation about how to disable this behaviour.\n\nBeware of buffering issues when passing $(D File) objects to\n$(D spawnProcess).  The child process will inherit the low-level raw\nread/write offset associated with the underlying file descriptor, but\nit will not be aware of any buffered data.  In cases where this matters\n(e.g. when a file should be aligned before being passed on to the\nchild process), it may be a good idea to use unbuffered streams, or at\nleast ensure all relevant buffers are flushed.\n\nParams:\nargs    = An array which contains the program name as the zeroth element\n          and any command-line arguments in the following elements.\nstdin   = The standard input stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for reading.\n          By default the child process inherits the parent's input\n          stream.\nstdout  = The standard output stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for writing.\n          By default the child process inherits the parent's output stream.\nstderr  = The standard error stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for writing.\n          By default the child process inherits the parent's error stream.\nenv     = Additional environment variables for the child process.\nconfig  = Flags that control process creation. See $(LREF Config)\n          for an overview of available flags.\nworkDir = The working directory for the new process.\n          By default the child process inherits the parent's working\n          directory.\n\nReturns:\nA $(LREF Pid) object that corresponds to the spawned process.\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to pass one of the streams\n    to the child process (Windows only).$(BR)\n$(CXREF exception,RangeError) if $(D args) is empty.\n",
				"deco": "FNexAAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "stdin",
						"deco": "S3std5stdio4File",
						"default": "stdin"
					},
					{
						"name": "stdout",
						"deco": "S3std5stdio4File",
						"default": "stdout"
					},
					{
						"name": "stderr",
						"deco": "S3std5stdio4File",
						"default": "stderr"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 301,
				"originalType": "@trusted Pid(in char[][] args, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 304,
				"comment": "ditto\n",
				"deco": "FNexAAaxHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 317,
				"originalType": "@trusted Pid(in char[][] args, const string[string] env, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 320,
				"comment": "ditto\n",
				"deco": "FNexAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "stdin",
						"deco": "S3std5stdio4File",
						"default": "stdin"
					},
					{
						"name": "stdout",
						"deco": "S3std5stdio4File",
						"default": "stdout"
					},
					{
						"name": "stderr",
						"deco": "S3std5stdio4File",
						"default": "stderr"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 331,
				"originalType": "@trusted Pid(in char[] program, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnProcess",
				"line": 334,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 341,
				"originalType": "@trusted Pid(in char[] program, const string[string] env, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnShell",
				"line": 957,
				"comment": "A variation on $(LREF spawnProcess) that runs the given _command through\nthe current user's preferred _command interpreter (aka. shell).\n\nThe string $(D command) is passed verbatim to the shell, and is therefore\nsubject to its rules about _command structure, argument/filename quoting\nand escaping of special characters.\nThe path to the shell executable is determined by the $(LREF userShell)\nfunction.\n\nIn all other respects this function works just like $(D spawnProcess).\nPlease refer to the $(LREF spawnProcess) documentation for descriptions\nof the other function parameters, the return value and any exceptions\nthat may be thrown.\n---\n// Run the command/program \"foo\" on the file named \"my file.txt\", and\n// redirect its output into foo.log.\nauto pid = spawnShell(`foo \"my file.txt\" > foo.log`);\nwait(pid);\n---\n\nSee_also:\n$(LREF escapeShellCommand), which may be helpful in constructing a\nproperly quoted and escaped shell _command line for the current platform.\n",
				"deco": "FNexAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "stdin",
						"deco": "S3std5stdio4File",
						"default": "stdin"
					},
					{
						"name": "stdout",
						"deco": "S3std5stdio4File",
						"default": "stdout"
					},
					{
						"name": "stderr",
						"deco": "S3std5stdio4File",
						"default": "stderr"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 983,
				"originalType": "@trusted Pid(in char[] command, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "spawnShell",
				"line": 986,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigxAaZC3std7process3Pid",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 999,
				"originalType": "@trusted Pid(in char[] command, const string[string] env, Config config = Config.none, in char[] workDir = null)",
				"char": 5,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "newEnv",
						"line": 1072,
						"value": "1",
						"comment": "    By default, the child process inherits the parent's environment,\n    and any environment variables passed to $(LREF spawnProcess) will\n    be added to it.  If this flag is set, the only variables in the\n    child process' environment will be those given to spawnProcess.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "retainStdin",
						"line": 1081,
						"value": "2",
						"comment": "    Unless the child process inherits the standard input/output/error\n    streams of its parent, one almost always wants the streams closed\n    in the parent when $(LREF spawnProcess) returns.  Therefore, by\n    default, this is done.  If this is not desirable, pass any of these\n    options to spawnProcess.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "retainStdout",
						"line": 1082,
						"value": "4",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "retainStderr",
						"line": 1083,
						"value": "8",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "suppressConsole",
						"line": 1090,
						"value": "16",
						"comment": "    On Windows, if the child process is a console application, this\n    flag will prevent the creation of a console window.  Otherwise,\n    it will be ignored. On POSIX, $(D suppressConsole) has no effect.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "inheritFDs",
						"line": 1105,
						"value": "32",
						"comment": "    On POSIX, open $(LINK2 http://en.wikipedia.org/wiki/File_descriptor,file descriptors)\n    are by default inherited by the child process.  As this may lead\n    to subtle bugs when pipes or multiple threads are involved,\n    $(LREF spawnProcess) ensures that all file descriptors except the\n    ones that correspond to standard input/output/error are closed\n    in the child process when it starts.  Use $(D inheritFDs) to prevent\n    this.\n\n    On Windows, this option has no effect, and any handles which have been\n    explicitly marked as inheritable will always be inherited by the child\n    process.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Config",
				"line": 1062,
				"comment": "Flags that control the behaviour of $(LREF spawnProcess) and\n$(LREF spawnShell).\n\nUse bitwise OR to combine flags.\n\nExample:\n---\nauto logFile = File(\"myapp_error.log\", \"w\");\n\n// Start program, suppressing the console window (Windows only),\n// redirect its error stream to logFile, and leave logFile open\n// in the parent process as well.\nauto pid = spawnProcess(\"myapp\", stdin, stdout, logFile,\n                        Config.retainStderr | Config.suppressConsole);\nscope(exit)\n{\n    auto exitCode = wait(pid);\n    logFile.writeln(\"myapp exited with code \", exitCode);\n    logFile.close();\n}\n---\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Pid",
				"line": 1110,
				"comment": "A handle that corresponds to a spawned process.\n",
				"members": [
					{
						"endchar": 5,
						"name": "processID",
						"line": 1120,
						"comment": "    The process ID number.\n\n    This is a number that uniquely identifies the process on the operating\n    system, for at least as long as the process is running.  Once $(LREF wait)\n    has been called on the $(LREF Pid), this method will return an\n    invalid (negative) process ID.\n",
						"deco": "xFNaNbNdNfZi",
						"endline": 1123,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "osHandle",
						"line": 1143,
						"comment": "    An operating system handle to the process.\n\n    This handle is used to specify the process in OS-specific APIs.\n    On POSIX, this function returns a $(D core.sys.posix.sys.types.pid_t)\n    with the same value as $(LREF Pid.processID), while on Windows it returns\n    a $(D core.sys.windows.windows.HANDLE).\n\n    Once $(LREF wait) has been called on the $(LREF Pid), this method\n    will return an invalid handle.\n",
						"deco": "FNaNbNdNfZi",
						"endline": 1146,
						"originalType": "pure nothrow @property @safe pid_t()",
						"char": 21,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "wait",
				"line": 1301,
				"comment": "Waits for the process associated with $(D pid) to terminate, and returns\nits exit status.\n\nIn general one should always _wait for child processes to terminate\nbefore exiting the parent process.  Otherwise, they may become\n\"$(WEB en.wikipedia.org/wiki/Zombie_process,zombies)\" â processes\nthat are defunct, yet still occupy a slot in the OS process table.\n\nIf the process has already terminated, this function returns directly.\nThe exit code is cached, so that if wait() is called multiple times on\nthe same $(LREF Pid) it will always return the same value.\n\nPOSIX_specific:\nIf the process is terminated by a signal, this function returns a\nnegative number whose absolute value is the signal number.\nSince POSIX restricts normal exit codes to the range 0-255, a\nnegative return value will always indicate termination by signal.\nSignal codes are defined in the $(D core.sys.posix.signal) module\n(which corresponds to the $(D signal.h) POSIX header).\n\nThrows:\n$(LREF ProcessException) on failure.\n\nExamples:\nSee the $(LREF spawnProcess) documentation.\n\nSee_also:\n$(LREF tryWait), for a non-blocking function.\n",
				"deco": "FNfC3std7process3PidZi",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					}
				],
				"endline": 1305,
				"char": 5,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tryWait",
				"line": 1370,
				"comment": "A non-blocking version of $(LREF wait).\n\nIf the process associated with $(D pid) has already terminated,\n$(D tryWait) has the exact same effect as $(D wait).\nIn this case, it returns a tuple where the $(D terminated) field\nis set to $(D true) and the $(D status) field has the same\ninterpretation as the return value of $(D wait).\n\nIf the process has $(I not) yet terminated, this function differs\nfrom $(D wait) in that does not wait for this to happen, but instead\nreturns immediately.  The $(D terminated) field of the returned\ntuple will then be set to $(D false), while the $(D status) field\nwill always be 0 (zero).  $(D wait) or $(D tryWait) should then be\ncalled again on the same $(D Pid) at some later time; not only to\nget the exit code, but also to avoid the process becoming a \"zombie\"\nwhen it finally terminates.  (See $(LREF wait) for details).\n\nReturns:\nAn $(D std.typecons.Tuple!(bool, \"terminated\", int, \"status\")).\n\nThrows:\n$(LREF ProcessException) on failure.\n\nExample:\n---\nauto pid = spawnProcess(\"dmd myapp.d\");\nscope(exit) wait(pid);\n...\nauto dmd = tryWait(pid);\nif (dmd.terminated)\n{\n    if (dmd.status == 0) writeln(\"Compilation succeeded!\");\n    else writeln(\"Compilation failed\");\n}\nelse writeln(\"Still compiling...\");\n...\n---\nNote that in this example, the first $(D wait) call will have no\neffect if the process has already terminated by the time $(D tryWait)\nis called.  In the opposite case, however, the $(D scope) statement\nensures that we always wait for the process if it hasn't terminated\nby the time we reach the end of the scope.\n",
				"deco": "FNfC3std7process3PidZS3std8typecons61__T5TupleTbVAyaa10_7465726d696e61746564TiVAyaa6_737461747573Z5Tuple",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					}
				],
				"endline": 1376,
				"originalType": "@safe (Pid pid)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "kill",
				"line": 1429,
				"comment": "Attempts to terminate the process associated with $(D pid).\n\nThe effect of this function, as well as the meaning of $(D codeOrSignal),\nis highly platform dependent.  Details are given below.  Common to all\nplatforms is that this function only $(I initiates) termination of the process,\nand returns immediately.  It does not wait for the process to end,\nnor does it guarantee that the process does in fact get terminated.\n\nAlways call $(LREF wait) to wait for a process to complete, even if $(D kill)\nhas been called on it.\n\nWindows_specific:\nThe process will be\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx,\nforcefully and abruptly terminated).  If $(D codeOrSignal) is specified, it\nmust be a nonnegative number which will be used as the exit code of the process.\nIf not, the process wil exit with code 1.  Do not use $(D codeOrSignal = 259),\nas this is a special value (aka. $(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx,STILL_ACTIVE))\nused by Windows to signal that a process has in fact $(I not) terminated yet.\n---\nauto pid = spawnProcess(\"some_app\");\nkill(pid, 10);\nassert (wait(pid) == 10);\n---\n\nPOSIX_specific:\nA $(LINK2 http://en.wikipedia.org/wiki/Unix_signal,signal) will be sent to\nthe process, whose value is given by $(D codeOrSignal).  Depending on the\nsignal sent, this may or may not terminate the process.  Symbolic constants\nfor various $(LINK2 http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals,\nPOSIX signals) are defined in $(D core.sys.posix.signal), which corresponds to the\n$(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html,\n$(D signal.h) POSIX header).  If $(D codeOrSignal) is omitted, the\n$(D SIGTERM) signal will be sent.  (This matches the behaviour of the\n$(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/kill.html,\n$(D _kill)) shell command.)\n---\nimport core.sys.posix.signal: SIGKILL;\nauto pid = spawnProcess(\"some_app\");\nkill(pid, SIGKILL);\nassert (wait(pid) == -SIGKILL); // Negative return value on POSIX!\n---\n\nThrows:\n$(LREF ProcessException) on error (e.g. if codeOrSignal is invalid).\n    Note that failure to terminate the process is considered a \"normal\"\n    outcome, not an error.$(BR)\n",
				"deco": "FC3std7process3PidZv",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					}
				],
				"endline": 1437,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "kill",
				"line": 1440,
				"comment": "ditto\n",
				"deco": "FC3std7process3PidiZv",
				"parameters": [
					{
						"name": "pid",
						"deco": "C3std7process3Pid"
					},
					{
						"name": "codeOrSignal",
						"deco": "i"
					}
				],
				"endline": 1458,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "pipe",
				"line": 1529,
				"comment": "Creates a unidirectional _pipe.\n\nData is written to one end of the _pipe and read from the other.\n---\nauto p = pipe();\np.writeEnd.writeln(\"Hello World\");\nassert (p.readEnd.readln().chomp() == \"Hello World\");\n---\nPipes can, for example, be used for interprocess communication\nby spawning a new process and passing one end of the _pipe to\nthe child, while the parent uses the other end.\n(See also $(LREF pipeProcess) and $(LREF pipeShell) for an easier\nway of doing this.)\n---\n// Use cURL to download the dlang.org front page, pipe its\n// output to grep to extract a list of links to ZIP files,\n// and write the list to the file \"D downloads.txt\":\nauto p = pipe();\nauto outFile = File(\"D downloads.txt\", \"w\");\nauto cpid = spawnProcess([\"curl\", \"http://dlang.org/download.html\"],\n                         std.stdio.stdin, p.writeEnd);\nscope(exit) wait(cpid);\nauto gpid = spawnProcess([\"grep\", \"-o\", `http://\\S*\\.zip`],\n                         p.readEnd, outFile);\nscope(exit) wait(gpid);\n---\n\nReturns:\nA $(LREF Pipe) object that corresponds to the created _pipe.\n\nThrows:\n$(XREF stdio,StdioException) on failure.\n",
				"deco": "FNeZS3std7process4Pipe",
				"endline": 1544,
				"char": 6,
				"kind": "function"
			},
			{
				"name": "Pipe",
				"line": 1580,
				"comment": "An interface to a pipe created by the $(LREF pipe) function.\n",
				"members": [
					{
						"endchar": 60,
						"name": "readEnd",
						"line": 1583,
						"comment": "The read end of the pipe.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1583,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 62,
						"name": "writeEnd",
						"line": 1587,
						"comment": "The write end of the pipe.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1587,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "close",
						"line": 1604,
						"comment": "    Closes both ends of the pipe.\n\n    Normally it is not necessary to do this manually, as $(XREF stdio,File)\n    objects are automatically closed when there are no more references\n    to them.\n\n    Note that if either end of the pipe has been passed to a child process,\n    it will only be closed in the parent process.  (What happens in the\n    child process is platform dependent.)\n\n    Throws:\n    $(XREF exception,ErrnoException) if an error occurs.\n",
						"deco": "FNfZv",
						"endline": 1608,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "pipeProcess",
				"line": 1711,
				"comment": "Starts a new process, creating pipes to redirect its standard\ninput, output and/or error streams.\n\n$(D pipeProcess) and $(D pipeShell) are convenient wrappers around\n$(LREF spawnProcess) and $(LREF spawnShell), respectively, and\nautomate the task of redirecting one or more of the child process'\nstandard streams through pipes.  Like the functions they wrap,\nthese functions return immediately, leaving the child process to\nexecute in parallel with the invoking process.  It is recommended\nto always call $(LREF wait) on the returned $(LREF ProcessPipes.pid),\nas detailed in the documentation for $(D wait).\n\nThe $(D args)/$(D program)/$(D command), $(D env) and $(D config)\nparameters are forwarded straight to the underlying spawn functions,\nand we refer to their documentation for details.\n\nParams:\nargs     = An array which contains the program name as the zeroth element\n           and any command-line arguments in the following elements.\n           (See $(LREF spawnProcess) for details.)\nprogram  = The program name, $(I without) command-line arguments.\n           (See $(LREF spawnProcess) for details.)\ncommand  = A shell command which is passed verbatim to the command\n           interpreter.  (See $(LREF spawnShell) for details.)\nredirect = Flags that determine which streams are redirected, and\n           how.  See $(LREF Redirect) for an overview of available\n           flags.\nenv      = Additional environment variables for the child process.\n           (See $(LREF spawnProcess) for details.)\nconfig   = Flags that control process creation. See $(LREF Config)\n           for an overview of available flags, and note that the\n           $(D retainStd...) flags have no effect in this function.\nworkDir  = The working directory for the new process.\n           By default the child process inherits the parent's working\n           directory.\n\nReturns:\nA $(LREF ProcessPipes) object which contains $(XREF stdio,File)\nhandles that communicate with the redirected streams of the child\nprocess, along with a $(LREF Pid) object that corresponds to the\nspawned process.\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to redirect any of the streams.$(BR)\n\nExample:\n---\n// my_application writes to stdout and might write to stderr\nauto pipes = pipeProcess(\"my_application\", Redirect.stdout | Redirect.stderr);\nscope(exit) wait(pipes.pid);\n\n// Store lines of output.\nstring[] output;\nforeach (line; pipes.stdout.byLine) output ~= line.idup;\n\n// Store lines of errors.\nstring[] errors;\nforeach (line; pipes.stderr.byLine) errors ~= line.idup;\n\n\n// sendmail expects to read from stdin\npipes = pipeProcess([\"/usr/bin/sendmail\", \"-t\"], Redirect.stdin);\npipes.stdin.writeln(\"To: you\");\npipes.stdin.writeln(\"From: me\");\npipes.stdin.writeln(\"Subject: dlang\");\npipes.stdin.writeln(\"\");\npipes.stdin.writeln(message);\n\n// a single period tells sendmail we are finished\npipes.stdin.writeln(\".\");\n\n// but at this point sendmail might not see it, we need to flush\npipes.stdin.flush();\n\n// sendmail happens to exit on \".\", but some you have to close the file:\npipes.stdin.close();\n\n// otherwise this wait will wait forever\nwait(pipes.pid);\n\n---\n",
				"deco": "FNfxAAaE3std7process8RedirectxHAyaAyaE3std7process6ConfigxAaZS3std7process12ProcessPipes",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "redirect",
						"deco": "E3std7process8Redirect",
						"default": "cast(Redirect)7"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1719,
				"originalType": "@safe ProcessPipes(in char[][] args, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 14,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "pipeProcess",
				"line": 1722,
				"comment": "ditto\n",
				"deco": "FNfxAaE3std7process8RedirectxHAyaAyaE3std7process6ConfigxAaZS3std7process12ProcessPipes",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "redirect",
						"deco": "E3std7process8Redirect",
						"default": "cast(Redirect)7"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1730,
				"originalType": "@safe ProcessPipes(in char[] program, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 14,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "pipeShell",
				"line": 1733,
				"comment": "ditto\n",
				"deco": "FNfxAaE3std7process8RedirectxHAyaAyaE3std7process6ConfigxAaZS3std7process12ProcessPipes",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "redirect",
						"deco": "E3std7process8Redirect",
						"default": "cast(Redirect)7"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1741,
				"originalType": "@safe ProcessPipes(in char[] command, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, in char[] workDir = null)",
				"char": 14,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "stdin",
						"line": 1829,
						"value": "1",
						"comment": "Redirect the standard input, output or error streams, respectively.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stdout",
						"line": 1830,
						"value": "2",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stderr",
						"line": 1831,
						"value": "4",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 1837,
						"value": "7",
						"comment": "    Redirect _all three streams.  This is equivalent to\n    $(D Redirect.stdin | Redirect.stdout | Redirect.stderr).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stderrToStdout",
						"line": 1843,
						"value": "8",
						"comment": "    Redirect the standard error stream into the standard output stream.\n    This can not be combined with $(D Redirect.stderr).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stdoutToStderr",
						"line": 1849,
						"value": "16",
						"comment": "    Redirect the standard output stream into the standard error stream.\n    This can not be combined with $(D Redirect.stdout).\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Redirect",
				"line": 1826,
				"comment": "Flags that can be passed to $(LREF pipeProcess) and $(LREF pipeShell)\nto specify which of the child process' standard streams are redirected.\nUse bitwise OR to combine flags.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "ProcessPipes",
				"line": 1932,
				"comment": "Object which contains $(XREF stdio,File) handles that allow communication\nwith a child process through its standard streams.\n",
				"members": [
					{
						"endchar": 5,
						"name": "pid",
						"line": 1935,
						"comment": "The $(LREF Pid) of the child process.\n",
						"deco": "FNbNdNfZC3std7process3Pid",
						"endline": 1939,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdin",
						"line": 1949,
						"comment": "    An $(XREF stdio,File) that allows writing to the child process'\n    standard input stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard input stream hasn't\n    been redirected.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1955,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdout",
						"line": 1965,
						"comment": "    An $(XREF stdio,File) that allows reading from the child process'\n    standard output stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard output stream hasn't\n    been redirected.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1971,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stderr",
						"line": 1981,
						"comment": "    An $(XREF stdio,File) that allows reading from the child process'\n    standard error stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard error stream hasn't\n    been redirected.\n",
						"deco": "FNbNdNfZS3std5stdio4File",
						"endline": 1987,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "execute",
				"line": 2050,
				"comment": "Executes the given program or shell command and returns its exit\ncode and output.\n\n$(D execute) and $(D executeShell) start a new process using\n$(LREF spawnProcess) and $(LREF spawnShell), respectively, and wait\nfor the process to complete before returning.  The functions capture\nwhat the child process prints to both its standard output and\nstandard error streams, and return this together with its exit code.\n---\nauto dmd = execute([\"dmd\", \"myapp.d\"]);\nif (dmd.status != 0) writeln(\"Compilation failed:\\n\", dmd.output);\n\nauto ls = executeShell(\"ls -l\");\nif (ls.status != 0) writeln(\"Failed to retrieve file listing\");\nelse writeln(ls.output);\n---\n\nThe $(D args)/$(D program)/$(D command), $(D env) and $(D config)\nparameters are forwarded straight to the underlying spawn functions,\nand we refer to their documentation for details.\n\nParams:\nargs      = An array which contains the program name as the zeroth element\n            and any command-line arguments in the following elements.\n            (See $(LREF spawnProcess) for details.)\nprogram   = The program name, $(I without) command-line arguments.\n            (See $(LREF spawnProcess) for details.)\ncommand   = A shell command which is passed verbatim to the command\n            interpreter.  (See $(LREF spawnShell) for details.)\nenv       = Additional environment variables for the child process.\n            (See $(LREF spawnProcess) for details.)\nconfig    = Flags that control process creation. See $(LREF Config)\n            for an overview of available flags, and note that the\n            $(D retainStd...) flags have no effect in this function.\nmaxOutput = The maximum number of bytes of output that should be\n            captured.\nworkDir   = The working directory for the new process.\n            By default the child process inherits the parent's working\n            directory.\n\nReturns:\nAn $(D std.typecons.Tuple!(int, \"status\", string, \"output\")).\n\nPOSIX_specific:\nIf the process is terminated by a signal, the $(D status) field of\nthe return value will contain a negative number whose absolute\nvalue is the signal number.  (See $(LREF wait) for details.)\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to capture output.\n",
				"deco": "FNexAAaxHAyaAyaE3std7process6ConfigmxAaZS3std8typecons54__T5TupleTiVAyaa6_737461747573TAyaVAyaa6_6f7574707574Z5Tuple",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "maxOutput",
						"deco": "m",
						"default": "18446744073709551615LU"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 2058,
				"originalType": "@trusted (in char[][] args, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, in char[] workDir = null)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "execute",
				"line": 2061,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigmxAaZS3std8typecons54__T5TupleTiVAyaa6_737461747573TAyaVAyaa6_6f7574707574Z5Tuple",
				"parameters": [
					{
						"name": "program",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "maxOutput",
						"deco": "m",
						"default": "18446744073709551615LU"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 2069,
				"originalType": "@trusted (in char[] program, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, in char[] workDir = null)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "executeShell",
				"line": 2072,
				"comment": "ditto\n",
				"deco": "FNexAaxHAyaAyaE3std7process6ConfigmxAaZS3std8typecons54__T5TupleTiVAyaa6_737461747573TAyaVAyaa6_6f7574707574Z5Tuple",
				"parameters": [
					{
						"name": "command",
						"deco": "xAa"
					},
					{
						"name": "env",
						"deco": "xHAyaAya",
						"default": "cast(const(string[string]))null"
					},
					{
						"name": "config",
						"deco": "E3std7process6Config",
						"default": "cast(Config)0"
					},
					{
						"name": "maxOutput",
						"deco": "m",
						"default": "18446744073709551615LU"
					},
					{
						"name": "workDir",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 2080,
				"originalType": "@trusted (in char[] command, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, in char[] workDir = null)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"members": [],
				"name": "ProcessException",
				"line": 2170,
				"comment": "An exception that signals a problem with starting or waiting for a process.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "userShell",
				"line": 2224,
				"comment": "Determines the path to the current user's default command interpreter.\n\nOn Windows, this function returns the contents of the COMSPEC environment\nvariable, if it exists.  Otherwise, it returns the string $(D \"cmd.exe\").\n\nOn POSIX, $(D userShell) returns the contents of the SHELL environment\nvariable, if it exists and is non-empty.  Otherwise, it returns\n$(D \"/bin/sh\").\n",
				"deco": "FNdNfZAya",
				"endline": 2229,
				"char": 18,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thisProcessID",
				"line": 2239,
				"comment": "Returns the process ID number of the current process.\n",
				"deco": "FNbNdNeZi",
				"endline": 2243,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "escapeShellCommand",
				"line": 2350,
				"comment": "Escapes an argv-style argument array to be used with $(LREF spawnShell),\n$(LREF pipeShell) or $(LREF executeShell).\n---\nstring url = \"http://dlang.org/\";\nexecuteShell(escapeShellCommand(\"wget\", url, \"-O\", \"dlang-index.html\"));\n---\n\nConcatenate multiple $(D escapeShellCommand) and\n$(LREF escapeShellFileName) results to use shell redirection or\npiping operators.\n---\nexecuteShell(\n    escapeShellCommand(\"curl\", \"http://dlang.org/download.html\") ~\n    \"|\" ~\n    escapeShellCommand(\"grep\", \"-o\", `http://\\S*\\.zip`) ~\n    \">\" ~\n    escapeShellFileName(\"D download links.txt\"));\n---\n\nThrows:\n$(OBJECTREF Exception) if any part of the command line contains unescapable\ncharacters (NUL on all platforms, as well as CR and LF on Windows).\n",
				"deco": "FNaNfxAAaXAya",
				"parameters": [
					{
						"name": "args",
						"deco": "xAAa"
					}
				],
				"endline": 2371,
				"originalType": "pure @safe string(in char[][] args...)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "escapeWindowsArgument",
				"line": 2495,
				"comment": "Quotes a command-line argument in a manner conforming to the behavior of\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/bb776391(v=vs.85).aspx,\nCommandLineToArgvW).\n",
				"deco": "FNaNbNexAaZAya",
				"parameters": [
					{
						"name": "arg",
						"deco": "xAa"
					}
				],
				"endline": 2503,
				"originalType": "pure nothrow @trusted string(in char[] arg)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "escapeShellFileName",
				"line": 2680,
				"comment": "Escapes a filename to be used for shell redirection with $(LREF spawnShell),\n$(LREF pipeShell) or $(LREF executeShell).\n",
				"deco": "FNaNbNexAaZAya",
				"parameters": [
					{
						"name": "fileName",
						"deco": "xAa"
					}
				],
				"endline": 2701,
				"originalType": "pure nothrow @trusted string(in char[] fileName)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "environment",
				"line": 2825,
				"comment": "Manipulates _environment variables using an associative-array-like\ninterface.\n\nThis class contains only static methods, and cannot be instantiated.\nSee below for examples of use.\n",
				"members": [
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 2842,
						"comment": "    Retrieves the value of the environment variable with the given $(D name).\n    ---\n    auto path = environment[\"PATH\"];\n    ---\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variable does not exist,\n    or $(XREF utf,UTFException) if the variable contains invalid UTF-16\n    characters (Windows only).\n\n    See_also:\n    $(LREF environment.get), which doesn't throw on failure.\n",
						"deco": "FNfxAaZAya",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 2847,
						"originalType": "@safe string(in char[] name)",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "get",
						"line": 2874,
						"comment": "    Retrieves the value of the environment variable with the given $(D name),\n    or a default value if the variable doesn't exist.\n\n    Unlike $(LREF environment.opIndex), this function never throws.\n    ---\n    auto sh = environment.get(\"SHELL\", \"/bin/sh\");\n    ---\n    This function is also useful in checking for the existence of an\n    environment variable.\n    ---\n    auto myVar = environment.get(\"MYVAR\");\n    if (myVar is null)\n    {\n        // Environment variable doesn't exist.\n        // Note that we have to use 'is' for the comparison, since\n        // myVar == null is also true if the variable exists but is\n        // empty.\n    }\n    ---\n\n    Throws:\n    $(XREF utf,UTFException) if the variable contains invalid UTF-16\n    characters (Windows only).\n",
						"deco": "FNfxAaAyaZAya",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "defaultValue",
								"deco": "Aya",
								"default": "null"
							}
						],
						"endline": 2879,
						"originalType": "@safe string(in char[] name, string defaultValue = null)",
						"char": 12,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 2895,
						"comment": "    Assigns the given $(D value) to the environment variable with the given\n    $(D name).\n\n    If the variable does not exist, it will be created. If it already exists,\n    it will be overwritten.\n    ---\n    environment[\"foo\"] = \"bar\";\n    ---\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variable could not be added\n        (e.g. if the name is invalid).\n",
						"deco": "FNeNgAaxAaZANga",
						"parameters": [
							{
								"name": "value",
								"deco": "NgAa"
							},
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 2920,
						"originalType": "@trusted inout(char)[](inout char[] value, in char[] name)",
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "remove",
						"line": 2928,
						"comment": "    Removes the environment variable with the given $(D name).\n\n    If the variable isn't in the environment, this function returns\n    successfully without doing anything.\n",
						"deco": "FNbNiNexAaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 2933,
						"originalType": "nothrow @nogc @trusted void(in char[] name)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "toAA",
						"line": 2947,
						"comment": "    Copies all environment variables into an associative array.\n\n    Windows_specific:\n    While Windows environment variable names are case insensitive, D's\n    built-in associative arrays are not.  This function will store all\n    variable names in uppercase (e.g. $(D PATH)).\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variables could not\n        be retrieved (Windows only).\n",
						"deco": "FNeZHAyaAya",
						"endline": 3001,
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 16,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "system",
				"line": 3167,
				"comment": "   Execute $(D command) in a _command shell.\n\n   $(RED Deprecated. Please use $(LREF spawnShell) or $(LREF executeShell)\n         instead. This function will be removed in August 2015.)\n\n   Returns: If $(D command) is null, returns nonzero if the _command\n   interpreter is found, and zero otherwise. If $(D command) is not\n   null, returns -1 on error, or the exit status of command (which may\n   in turn signal an error in command's execution).\n\n   Note: On Unix systems, the homonym C function (which is accessible\n   to D programs as $(LINK2 core_stdc_stdlib.html, core.stdc.stdlib._system))\n   returns a code in the same format as $(LUCKY waitpid, waitpid),\n   meaning that C programs must use the $(D WEXITSTATUS) macro to\n   extract the actual exit code from the $(D system) call. D's $(D\n   system) automatically extracts the exit status.\n\n",
				"deco": "FAyaZi",
				"parameters": [
					{
						"name": "command",
						"deco": "Aya"
					}
				],
				"endline": 3184,
				"char": 5,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"name": "execv",
				"line": 3372,
				"comment": "    Replaces the current process by executing a command, $(D pathname), with\n    the arguments in $(D argv).\n\n    $(RED Deprecated on Windows.  From August 2015, these functions will\n    only be available on POSIX platforms. The reason is that they never\n    did what the documentation claimed they did, nor is it technically\n    possible to implement such behaviour on Windows. See below for more\n    information.)\n\n    Typically, the first element of $(D argv) is\n    the command being executed, i.e. $(D argv[0] == pathname). The 'p'\n    versions of $(D exec) search the PATH environment variable for $(D\n    pathname). The 'e' versions additionally take the new process'\n    environment variables as an array of strings of the form key=value.\n\n    Does not return on success (the current process will have been\n    replaced). Returns -1 on failure with no indication of the\n    underlying error.\n\n    Windows_specific:\n    These functions are only supported on POSIX platforms, as the Windows\n    operating systems do not provide the ability to overwrite the current\n    process image with another. In single-threaded programs it is possible\n    to approximate the effect of $(D execv*) by using $(LREF spawnProcess)\n    and terminating the current process once the child process has returned.\n    For example:\n    ---\n    auto commandLine = [ \"program\", \"arg1\", \"arg2\" ];\n    version (Posix)\n    {\n        execv(commandLine[0], commandLine);\n        throw new Exception(\"Failed to execute program\");\n    }\n    else version (Windows)\n    {\n        import core.stdc.stdlib: _exit;\n        _exit(wait(spawnProcess(commandLine)));\n    }\n    ---\n    This is, however, NOT equivalent to POSIX' $(D execv*).  For one thing, the\n    executed program is started as a separate process, with all this entails.\n    Secondly, in a multithreaded program, other threads will continue to do\n    work while the current thread is waiting for the child process to complete.\n\n    A better option may sometimes be to terminate the current program immediately\n    after spawning the child process.  This is the behaviour exhibited by the\n    $(LINK2 http://msdn.microsoft.com/en-us/library/431x4c1w.aspx,$(D __exec))\n    functions in Microsoft's C runtime library, and it is how D's now-deprecated\n    Windows $(D execv*) functions work. Example:\n    ---\n    auto commandLine = [ \"program\", \"arg1\", \"arg2\" ];\n    version (Posix)\n    {\n        execv(commandLine[0], commandLine);\n        throw new Exception(\"Failed to execute program\");\n    }\n    else version (Windows)\n    {\n        spawnProcess(commandLine);\n        import core.stdc.stdlib: _exit;\n        _exit(0);\n    }\n    ---\n",
				"deco": "FxAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "execve",
				"line": 3374,
				"comment": "ditto\n",
				"deco": "FxAyaxAAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					},
					{
						"name": "envp",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv, in string[] envp)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "execvp",
				"line": 3376,
				"comment": "ditto\n",
				"deco": "FxAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "execvpe",
				"line": 3378,
				"comment": "ditto\n",
				"deco": "FxAyaxAAyaxAAyaZi",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAya"
					},
					{
						"name": "argv",
						"deco": "xAAya"
					},
					{
						"name": "envp",
						"deco": "xAAya"
					}
				],
				"originalType": "int(in string pathname, in string[] argv, in string[] envp)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "getpid",
				"line": 3517,
				"comment": " Returns the process ID of the calling process, which is guaranteed to be\n unique on the system. This call is always successful.\n\n $(RED Deprecated.  Please use $(LREF thisProcessID) instead.\n       This function will be removed in August 2015.)\n\n Example:\n ---\n writefln(\"Current process id: %s\", getpid());\n ---\n",
				"storageClass": [
					"deprecated"
				],
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "shell",
				"line": 3541,
				"comment": "   Runs $(D_PARAM cmd) in a shell and returns its standard output. If\n   the process could not be started or exits with an error code,\n   throws ErrnoException.\n\n   $(RED Deprecated.  Please use $(LREF executeShell) instead.\n         This function will be removed in August 2015.)\n\n   Example:\n\n   ----\n   auto tempFilename = chomp(shell(\"mcookie\"));\n   auto f = enforce(fopen(tempFilename), \"w\");\n   scope(exit)\n   {\n       fclose(f) == 0 || assert(false);\n       system(escapeShellCommand(\"rm\", tempFilename));\n   }\n   ... use f ...\n   ----\n",
				"deco": "FAyaZAya",
				"parameters": [
					{
						"name": "cmd",
						"deco": "Aya"
					}
				],
				"endline": 3577,
				"char": 8,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"endchar": 1,
				"name": "getenv",
				"line": 3604,
				"comment": "Gets the value of environment variable $(D name) as a string. Calls\n$(LINK2 core_stdc_stdlib.html#_getenv, core.stdc.stdlib._getenv)\ninternally.\n\n$(RED Deprecated. Please use $(LREF environment.opIndex) or\n      $(LREF environment.get) instead.  This function will be\n      removed in August 2015.)\n",
				"deco": "FNbxAaZAya",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 3613,
				"originalType": "nothrow string(in char[] name)",
				"char": 8,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"name": "setenv",
				"line": 3625,
				"comment": "Sets the value of environment variable $(D name) to $(D value). If the\nvalue was written, or the variable was already present and $(D\noverwrite) is false, returns normally. Otherwise, it throws an\nexception. Calls $(LINK2 core_sys_posix_stdlib.html#_setenv,\ncore.sys.posix.stdlib._setenv) internally.\n\n$(RED Deprecated. Please use $(LREF environment.opIndexAssign) instead.\n      This function will be removed in August 2015.)\n",
				"deco": "FxAaxAabZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "value",
						"deco": "xAa"
					},
					{
						"name": "overwrite",
						"deco": "b"
					}
				],
				"originalType": "void(in char[] name, in char[] value, bool overwrite)",
				"char": 34,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"name": "unsetenv",
				"line": 3641,
				"comment": "Removes variable $(D name) from the environment. Calls $(LINK2\ncore_sys_posix_stdlib.html#_unsetenv, core.sys.posix.stdlib._unsetenv) internally.\n\n$(RED Deprecated. Please use $(LREF environment.remove) instead.\n      This function will be removed in August 2015.)\n",
				"deco": "FxAaZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"originalType": "void(in char[] name)",
				"char": 34,
				"kind": "function",
				"storageClass": [
					"deprecated"
				]
			},
			{
				"name": "browse",
				"line": 3665,
				"comment": " Start up the browser and set it to viewing the page at url.\n",
				"deco": "FAyaZv",
				"parameters": [
					{
						"name": "url",
						"deco": "Aya"
					}
				],
				"char": 10,
				"kind": "function"
			}
		],
		"comment": "Functions for starting and interacting with other processes, and for\nworking with the current _process' execution environment.\n\nProcess_handling:\n$(UL $(LI\n    $(LREF spawnProcess) spawns a new _process, optionally assigning it an\n    arbitrary set of standard input, output, and error streams.\n    The function returns immediately, leaving the child _process to execute\n    in parallel with its parent.  All other functions in this module that\n    spawn processes are built around $(D spawnProcess).)\n$(LI\n    $(LREF wait) makes the parent _process wait for a child _process to\n    terminate.  In general one should always do this, to avoid\n    child processes becoming \"zombies\" when the parent _process exits.\n    Scope guards are perfect for this â see the $(LREF spawnProcess)\n    documentation for examples.  $(LREF tryWait) is similar to $(D wait),\n    but does not block if the _process has not yet terminated.)\n$(LI\n    $(LREF pipeProcess) also spawns a child _process which runs\n    in parallel with its parent.  However, instead of taking\n    arbitrary streams, it automatically creates a set of\n    pipes that allow the parent to communicate with the child\n    through the child's standard input, output, and/or error streams.\n    This function corresponds roughly to C's $(D popen) function.)\n$(LI\n    $(LREF execute) starts a new _process and waits for it\n    to complete before returning.  Additionally, it captures\n    the _process' standard output and error streams and returns\n    the output of these as a string.)\n$(LI\n    $(LREF spawnShell), $(LREF pipeShell) and $(LREF executeShell) work like\n    $(D spawnProcess), $(D pipeProcess) and $(D execute), respectively,\n    except that they take a single command string and run it through\n    the current user's default command interpreter.\n    $(D executeShell) corresponds roughly to C's $(D system) function.)\n$(LI\n    $(LREF kill) attempts to terminate a running _process.)\n)\n\nThe following table compactly summarises the different _process creation\nfunctions and how they relate to each other:\n$(BOOKTABLE,\n    $(TR $(TH )\n         $(TH Runs program directly)\n         $(TH Runs shell command))\n    $(TR $(TD Low-level _process creation)\n         $(TD $(LREF spawnProcess))\n         $(TD $(LREF spawnShell)))\n    $(TR $(TD Automatic input/output redirection using pipes)\n         $(TD $(LREF pipeProcess))\n         $(TD $(LREF pipeShell)))\n    $(TR $(TD Execute and wait for completion, collect output)\n         $(TD $(LREF execute))\n         $(TD $(LREF executeShell)))\n)\n\nOther_functionality:\n$(UL\n$(LI\n    $(LREF pipe) is used to create unidirectional pipes.)\n$(LI\n    $(LREF environment) is an interface through which the current _process'\n    environment variables can be read and manipulated.)\n$(LI\n    $(LREF escapeShellCommand) and $(LREF escapeShellFileName) are useful\n    for constructing shell command lines in a portable way.)\n)\n\nAuthors:\n    $(LINK2 https://github.com/kyllingstad, Lars Tandle Kyllingstad),\n    $(LINK2 https://github.com/schveiguy, Steven Schveighoffer),\n    $(WEB thecybershadow.net, Vladimir Panteleev)\nCopyright:\n    Copyright (c) 2013, the authors. All rights reserved.\nLicense:\n   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nSource:\n    $(PHOBOSSRC std/_process.d)\nMacros:\n    WIKI=Phobos/StdProcess\n    OBJECTREF=$(D $(LINK2 object.html#$0,$0))\n    LREF=$(D $(LINK2 #.$0,$0))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/zlib.d",
		"name": "std.zlib",
		"members": [
			{
				"members": [],
				"name": "ZlibException",
				"line": 42,
				"comment": " Errors throw a ZlibException.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "adler32",
				"line": 79,
				"comment": " $(P Compute the Adler-32 checksum of a buffer's worth of data.)\n\n Params:\n     adler = the starting checksum for the computation. Use 0\n             for a new checksum. Use the output of this function\n             for a cumulative checksum.\n     buf = buffer containing input data\n\n Returns:\n     A $(D uint) checksum for the provided input data and starting checksum\n\n See_Also:\n     $(LINK http://en.wikipedia.org/wiki/Adler-32)\n",
				"deco": "FkAxvZk",
				"parameters": [
					{
						"name": "adler",
						"deco": "k"
					},
					{
						"name": "buf",
						"deco": "Axv"
					}
				],
				"endline": 87,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "crc32",
				"line": 117,
				"comment": " $(P Compute the CRC32 checksum of a buffer's worth of data.)\n\n Params:\n     crc = the starting checksum for the computation. Use 0\n             for a new checksum. Use the output of this function\n             for a cumulative checksum.\n     buf = buffer containing input data\n\n Returns:\n     A $(D uint) checksum for the provided input data and starting checksum\n\n See_Also:\n     $(LINK http://en.wikipedia.org/wiki/Cyclic_redundancy_check)\n",
				"deco": "FkAxvZk",
				"parameters": [
					{
						"name": "crc",
						"deco": "k"
					},
					{
						"name": "buf",
						"deco": "Axv"
					}
				],
				"endline": 125,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "compress",
				"line": 152,
				"comment": " $(P Compress data)\n\n Params:\n     srcbuf = buffer containing the data to compress\n     level = compression level. Legal values are 1..9, with 1 being the\n             least compression and 9 being the most. The default value\n             is 6.\n\n Returns:\n     the compressed data\n",
				"deco": "FAxviZAxv",
				"parameters": [
					{
						"name": "srcbuf",
						"deco": "Axv"
					},
					{
						"name": "level",
						"deco": "i"
					}
				],
				"endline": 169,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "compress",
				"line": 175,
				"comment": " ditto\n",
				"deco": "FAxvZAxv",
				"parameters": [
					{
						"name": "srcbuf",
						"deco": "Axv"
					}
				],
				"endline": 178,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "uncompress",
				"line": 191,
				"comment": " Decompresses the data in srcbuf[].\n Params:\n  srcbuf  = buffer containing the compressed data.\n  destlen = size of the uncompressed data.\n            It need not be accurate, but the decompression will be faster\n            if the exact size is supplied.\n  winbits = the base two logarithm of the maximum window size.\n Returns: the decompressed data.\n",
				"deco": "FAvmiZAv",
				"parameters": [
					{
						"name": "srcbuf",
						"deco": "Av"
					},
					{
						"name": "destlen",
						"deco": "m",
						"default": "0LU"
					},
					{
						"name": "winbits",
						"deco": "i",
						"default": "15"
					}
				],
				"endline": 239,
				"originalType": "void[](void[] srcbuf, size_t destlen = 0u, int winbits = 15)",
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "deflate",
						"line": 287,
						"value": "0",
						"comment": "a standard zlib header\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "gzip",
						"line": 288,
						"value": "1",
						"comment": "a gzip file format header\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "determineFromData",
						"line": 289,
						"value": "2",
						"comment": "used when decompressing. Try to automatically detect the stream format by looking at the data\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "HeaderFormat",
				"line": 286,
				"comment": "the header format the compressed stream is wrapped in\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Compress",
				"line": 296,
				"comment": " Used when the data to be compressed is not all in one buffer.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 329,
						"comment": " Constructor.\n\n Params:\n    level = compression level. Legal values are 1..9, with 1 being the least\n            compression and 9 being the most. The default value is 6.\n    header = sets the compression type to one of the options available\n             in $(LREF HeaderFormat). Defaults to HeaderFormat.deflate.\n\n See_Also:\n    $(LREF compress), $(LREF HeaderFormat)\n",
						"deco": "FiE3std4zlib12HeaderFormatZC3std4zlib8Compress",
						"parameters": [
							{
								"name": "level",
								"deco": "i"
							},
							{
								"name": "header",
								"deco": "E3std4zlib12HeaderFormat",
								"default": "cast(HeaderFormat)0"
							}
						],
						"endline": 338,
						"originalType": "(int level, HeaderFormat header = HeaderFormat.deflate)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 341,
						"comment": "ditto\n",
						"deco": "FE3std4zlib12HeaderFormatZC3std4zlib8Compress",
						"parameters": [
							{
								"name": "header",
								"deco": "E3std4zlib12HeaderFormat",
								"default": "cast(HeaderFormat)0"
							}
						],
						"endline": 344,
						"originalType": "(HeaderFormat header = HeaderFormat.deflate)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "compress",
						"line": 365,
						"comment": " Compress the data in buf and return the compressed data.\n Params:\n    buf = data to compress\n\n Returns:\n    the compressed data. The buffers returned from successive calls to this should be concatenated together.\n\n",
						"deco": "FAxvZAxv",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 397,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 419,
							"deco": "FZv",
							"endline": 419,
							"char": 5,
							"kind": "function"
						},
						"name": "flush",
						"line": 417,
						"comment": " Compress and return any remaining data.\n The returned data should be appended to that returned by compress().\n Params:\n  mode = one of the following:\n          $(DL\n                    $(DT Z_SYNC_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on.)\n                    $(DT Z_FULL_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on,\n                        and the decompressor needs to be restartable at this\n                        point.)\n                    $(DT Z_FINISH)\n                    $(DD (default) Used when finished compressing the data. )\n                )\n",
						"deco": "FiZAv",
						"parameters": [
							{
								"name": "mode",
								"deco": "i",
								"default": "4"
							}
						],
						"endline": 466,
						"originalType": "void[](int mode = Z_FINISH)",
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "UnCompress",
				"line": 473,
				"comment": " Used when the data to be decompressed is not all in one buffer.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 499,
						"comment": " Construct. destbufsize is the same as for D.zlib.uncompress().\n",
						"deco": "FkZC3std4zlib10UnCompress",
						"parameters": [
							{
								"name": "destbufsize",
								"deco": "k"
							}
						],
						"endline": 502,
						"originalType": "(uint destbufsize)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 505,
						"comment": " ditto\n",
						"deco": "FE3std4zlib12HeaderFormatZC3std4zlib10UnCompress",
						"parameters": [
							{
								"name": "format",
								"deco": "E3std4zlib12HeaderFormat",
								"default": "cast(HeaderFormat)2"
							}
						],
						"endline": 508,
						"originalType": "(HeaderFormat format = HeaderFormat.determineFromData)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 528,
							"deco": "FZv",
							"endline": 528,
							"char": 5,
							"kind": "function"
						},
						"name": "uncompress",
						"line": 526,
						"comment": " Decompress the data in buf and return the decompressed data.\n The buffers returned from successive calls to this should be concatenated\n together.\n",
						"deco": "FAxvZAxv",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 571,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 580,
							"deco": "FZv",
							"endline": 580,
							"char": 5,
							"kind": "function"
						},
						"name": "flush",
						"line": 578,
						"comment": " Decompress and return any remaining data.\n The returned data should be appended to that returned by uncompress().\n The UnCompress object cannot be used further.\n",
						"deco": "FZAv",
						"endline": 623,
						"out": {
							"endchar": 5,
							"name": "__ensure",
							"line": 584,
							"deco": "FKxAvZv",
							"parameters": [
								{
									"name": "__result",
									"storageClass": [
										"ref"
									],
									"deco": "xAv"
								}
							],
							"endline": 584,
							"originalType": "void(ref const void[] __result)",
							"char": 5,
							"kind": "function"
						},
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Compress/decompress data using the $(WEB www.zlib.net, zlib library).\n\n References:\n  $(WEB en.wikipedia.org/wiki/Zlib, Wikipedia)\n\n Macros:\n  WIKI = Phobos/StdZlib\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_zlib.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/ascii.d",
		"name": "std.ascii",
		"members": [
			{
				"name": "fullHexDigits",
				"line": 37,
				"comment": "0..9A..Fa..f\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789ABCDEFabcdef\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "hexDigits",
				"line": 38,
				"comment": "0..9A..F\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789ABCDEF\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "lowerHexDigits",
				"line": 39,
				"comment": "0..9a..f\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789abcdef\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "digits",
				"line": 40,
				"comment": "0..9\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"0123456789\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "octalDigits",
				"line": 41,
				"comment": "0..7\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"01234567\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "letters",
				"line": 42,
				"comment": "A..Za..z\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "uppercase",
				"line": 43,
				"comment": "A..Z\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "lowercase",
				"line": 44,
				"comment": "a..z\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"abcdefghijklmnopqrstuvwxyz\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "whitespace",
				"line": 45,
				"comment": "ASCII _whitespace\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\" \\x09\\x0b\\x0d\\x0a\\x0c\"",
				"char": 11,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"members": [
					{
						"name": "upper",
						"line": 52,
						"value": "false",
						"comment": "Upper case letters\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lower",
						"line": 53,
						"value": "1",
						"comment": "Lower case letters\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "LetterCase",
				"line": 50,
				"comment": "    Letter case specifier.\n",
				"baseDeco": "b",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "newline",
				"line": 60,
				"comment": "Newline sequence for this system.\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"\\x0a\"",
				"char": 15,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"endchar": 1,
				"name": "isAlphaNum",
				"line": 69,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a letter or a number (0..9, a..z, A..Z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL75_600)\n---\nassert( isAlphaNum('A'));\nassert( isAlphaNum('1'));\nassert(!isAlphaNum('#'));\n\n// N.B.: does not return true for non-ASCII Unicode alphanumerics:\nassert(!isAlphaNum('Ã¡'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL75_600)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 72,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isAlpha",
				"line": 99,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is an ASCII letter (A..Z, a..z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL106_602)\n---\nassert( isAlpha('A'));\nassert(!isAlpha('1'));\nassert(!isAlpha('#'));\n\n// N.B.: does not return true for non-ASCII Unicode alphabetic characters:\nassert(!isAlpha('Ã¡'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL106_602)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 103,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isLower",
				"line": 130,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a lowercase ASCII letter (a..z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL136_604)\n---\nassert( isLower('a'));\nassert(!isLower('A'));\nassert(!isLower('#'));\n\n// N.B.: does not return true for non-ASCII Unicode lowercase letters\nassert(!isLower('Ã¡'));\nassert(!isLower('Ã'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL136_604)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 133,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isUpper",
				"line": 161,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is an uppercase ASCII letter (A..Z).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL167_606)\n---\nassert( isUpper('A'));\nassert(!isUpper('a'));\nassert(!isUpper('#'));\n\n// N.B.: does not return true for non-ASCII Unicode uppercase letters\nassert(!isUpper('Ã¡'));\nassert(!isUpper('Ã'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL167_606)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 164,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isDigit",
				"line": 192,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a digit (0..9).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL198_608)\n---\nassert( isDigit('3'));\nassert( isDigit('8'));\nassert(!isDigit('B'));\nassert(!isDigit('#'));\n\n// N.B.: does not return true for non-ASCII Unicode numbers\nassert(!isDigit('ï¼')); // full-width digit zero (U+FF10)\nassert(!isDigit('ï¼')); // full-width digit four (U+FF14)\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL198_608)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 195,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isOctalDigit",
				"line": 224,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a digit in base 8 (0..7).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL230_610)\n---\nassert( isOctalDigit('0'));\nassert( isOctalDigit('7'));\nassert(!isOctalDigit('8'));\nassert(!isOctalDigit('A'));\nassert(!isOctalDigit('#'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL230_610)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 227,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isHexDigit",
				"line": 253,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a digit in base 16 (0..9, A..F, a..f).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL259_612)\n---\nassert( isHexDigit('0'));\nassert( isHexDigit('A'));\nassert( isHexDigit('f')); // lowercase hex digits are accepted\nassert(!isHexDigit('g'));\nassert(!isHexDigit('G'));\nassert(!isHexDigit('#'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL259_612)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 256,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isWhite",
				"line": 285,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a whitespace character. That includes the\n    space, tab, vertical tab, form feed, carriage return, and linefeed\n    characters.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL291_614)\n---\nassert( isWhite(' '));\nassert( isWhite('\\t'));\nassert( isWhite('\\n'));\nassert(!isWhite('1'));\nassert(!isWhite('a'));\nassert(!isWhite('#'));\n\n// N.B.: Does not return true for non-ASCII Unicode whitespace characters.\nstatic import std.uni;\nassert(std.uni.isWhite('\\u00A0'));\nassert(!isWhite('\\u00A0')); // std.ascii.isWhite\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL291_614)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 288,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isControl",
				"line": 320,
				"comment": "    Params: c = The character to test.\n    Returns: Whether $(D c) is a control character.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL326_616)\n---\nassert( isControl('\\0'));\nassert( isControl('\\022'));\nassert( isControl('\\n')); // newline is both whitespace and control\nassert(!isControl(' '));\nassert(!isControl('1'));\nassert(!isControl('a'));\nassert(!isControl('#'));\n\n// N.B.: non-ASCII Unicode control characters are not recognized:\nassert(!isControl('\\u0080'));\nassert(!isControl('\\u2028'));\nassert(!isControl('\\u2029'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL326_616)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 323,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPunctuation",
				"line": 359,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a punctuation character. That includes\n    all ASCII characters which are not control characters, letters, digits, or\n    whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL365_618)\n---\nassert( isPunctuation('.'));\nassert( isPunctuation(','));\nassert( isPunctuation(':'));\nassert( isPunctuation('!'));\nassert( isPunctuation('#'));\nassert( isPunctuation('~'));\nassert( isPunctuation('+'));\nassert( isPunctuation('_'));\n\nassert(!isPunctuation('1'));\nassert(!isPunctuation('a'));\nassert(!isPunctuation(' '));\nassert(!isPunctuation('\\n'));\nassert(!isPunctuation('\\0'));\n\n// N.B.: Non-ASCII Unicode punctuation characters are not recognized.\nassert(!isPunctuation('\\u2012')); // (U+2012 = en-dash)\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL365_618)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 362,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isGraphical",
				"line": 403,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a printable character other than the\n    space character.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL409_620)\n---\nassert( isGraphical('1'));\nassert( isGraphical('a'));\nassert( isGraphical('#'));\nassert(!isGraphical(' ')); // whitespace is not graphical\nassert(!isGraphical('\\n'));\nassert(!isGraphical('\\0'));\n\n// N.B.: Unicode graphical characters are not regarded as such.\nassert(!isGraphical('Ã¡'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL409_620)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 406,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPrintable",
				"line": 439,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is a printable character - including the\n    space character.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL445_622)\n---\nassert( isPrintable(' '));  // whitespace is printable\nassert( isPrintable('1'));\nassert( isPrintable('a'));\nassert( isPrintable('#'));\nassert(!isPrintable('\\0')); // control characters are not printable\n\n// N.B.: Printable non-ASCII Unicode characters are not recognized.\nassert(!isPrintable('Ã¡'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL445_622)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 442,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isASCII",
				"line": 474,
				"comment": "    Params: c = The character to test.\n    Returns: Whether or not $(D c) is in the ASCII character set - i.e. in the\n    range 0..0x7F.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL480_624)\n---\nassert( isASCII('a'));\nassert(!isASCII('Ã¡'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL480_624)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 477,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toLower",
						"line": 506,
						"type": "(C c)",
						"parameters": [
							{
								"name": "c",
								"type": "C"
							}
						],
						"endline": 518,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toLower",
				"line": 506,
				"comment": "    Converts an ASCII letter to lowercase.\n\n    Params: c = A character of any type that implicitly converts to $(D dchar).\n    In the case where it's a built-in type, or an enum of a built-in type,\n    $(D Unqual!(OriginalType!C)) is returned, whereas if it's a user-defined\n    type, $(D dchar) is returned.\n\n    Returns: The corresponding lowercase letter, if $(D c) is an uppercase\n    ASCII character, otherwise $(D c) itself.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL521_626)\n---\nassert(toLower('a') == 'a');\nassert(toLower('A') == 'a');\nassert(toLower('#') == '#');\n\n// N.B.: Non-ASCII Unicode uppercase letters are not converted.\nassert(toLower('Ã') == 'Ã');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL521_626)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C : dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUpper",
						"line": 568,
						"type": "(C c)",
						"parameters": [
							{
								"name": "c",
								"type": "C"
							}
						],
						"endline": 580,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toUpper",
				"line": 568,
				"comment": "    Converts an ASCII letter to uppercase.\n\n    Params: c = Any type which implicitly converts to $(D dchar). In the case\n    where it's a built-in type, or an enum of a built-in type,\n    $(D Unqual!(OriginalType!C)) is returned, whereas if it's a user-defined\n    type, $(D dchar) is returned.\n\n    Returns: The corresponding uppercase letter, if $(D c) is a lowercase ASCII\n    character, otherwise $(D c) itself.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL583_628)\n---\nassert(toUpper('a') == 'A');\nassert(toUpper('A') == 'A');\nassert(toUpper('#') == '#');\n\n// N.B.: Non-ASCII Unicode lowercase letters are not converted.\nassert(toUpper('Ã¡') == 'Ã¡');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL583_628)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C : dchar)",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "    Functions which operate on ASCII characters.\n\n    All of the functions in std._ascii accept Unicode characters but\n    effectively ignore them if they're not ASCII. All $(D isX) functions return\n    $(D false) for non-ASCII characters, and all $(D toX) functions do nothing\n    to non-ASCII characters.\n\n    For functions which operate on Unicode characters, see\n    $(LINK2 std_uni.html, std.uni).\n\n    References:\n        $(LINK2 http://www.digitalmars.com/d/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org/wiki/Ascii, Wikipedia)\n\n    Macros:\n        WIKI=Phobos/StdASCII\n\n    Copyright: Copyright 2000 - 2013\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_ascii.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/getopt.d",
		"name": "std.getopt",
		"members": [
			{
				"members": [],
				"name": "GetOptException",
				"line": 46,
				"comment": "Thrown on one of the following conditions:\n$(UL\n  $(LI An unrecognized command-line argument is passed, and\n       $(D std.getopt.config.passThrough) was not present.)\n  $(LI A command-line option was not found, and\n       $(D std.getopt.config.required) was present.)\n)\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getopt",
						"line": 427,
						"type": "GetoptResult(ref string[] args, T opts)",
						"parameters": [
							{
								"name": "args",
								"type": "string[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "opts",
								"type": "T"
							}
						],
						"endline": 438,
						"char": 14,
						"kind": "function"
					}
				],
				"name": "getopt",
				"line": 427,
				"comment": "   Parse and remove command line options from an string array.\n\n   Synopsis:\n\n---------\nimport std.getopt;\n\nstring data = \"file.dat\";\nint length = 24;\nbool verbose;\nenum Color { no, yes };\nColor color;\n\nvoid main(string[] args)\n{\n  auto helpInformation = getopt(\n    args,\n    \"length\",  &length,    // numeric\n    \"file\",    &data,      // string\n    \"verbose\", &verbose,   // flag\n    \"color\", \"Information about this color\", &color);    // enum\n  ...\n\n  if (helpInformation.helpWanted)\n  {\n    defaultGetoptPrinter(\"Some information about the program.\",\n      helpInformation.options);\n  }\n}\n---------\n\n The $(D getopt) function takes a reference to the command line\n (as received by $(D main)) as its first argument, and an\n unbounded number of pairs of strings and pointers. Each string is an\n option meant to \"fill\" the value pointed-to by the pointer to its\n right (the \"bound\" pointer). The option string in the call to\n $(D getopt) should not start with a dash.\n\n In all cases, the command-line options that were parsed and used by\n $(D getopt) are removed from $(D args). Whatever in the\n arguments did not look like an option is left in $(D args) for\n further processing by the program. Values that were unaffected by the\n options are not touched, so a common idiom is to initialize options\n to their defaults and then invoke $(D getopt). If a\n command-line argument is recognized as an option with a parameter and\n the parameter cannot be parsed properly (e.g. a number is expected\n but not present), a $(D ConvException) exception is thrown.\n If $(D std.getopt.config.passThrough) was not passed to getopt\n and an unrecognized command-line argument is found, a $(D GetOptException)\n is thrown.\n\n Depending on the type of the pointer being bound, $(D getopt)\n recognizes the following kinds of options:\n\n $(OL\n    $(LI $(I Boolean options). A lone argument sets the option to $(D true).\n    Additionally $(B true) or $(B false) can be set within the option separated\n    with an \"=\" sign:\n\n---------\n  bool verbose = false, debugging = true;\n  getopt(args, \"verbose\", &verbose, \"debug\", &debugging);\n---------\n\n    To set $(D verbose) to $(D true), invoke the program with either\n    $(D --verbose) or $(D --verbose=true).\n\n    To set $(D debugging) to $(D false), invoke the program with\n    $(D --debugging=false).\n    )\n\n    $(LI $(I Numeric options.) If an option is bound to a numeric type, a\n    number is expected as the next option, or right within the option separated\n    with an \"=\" sign:\n\n---------\n  uint timeout;\n  getopt(args, \"timeout\", &timeout);\n---------\n\n    To set $(D timeout) to $(D 5), invoke the program with either\n    $(D --timeout=5) or $(D --timeout 5).\n    )\n\n    $(LI $(I Incremental options.) If an option name has a \"+\" suffix and is\n    bound to a numeric type, then the option's value tracks the number of times\n    the option occurred on the command line:\n\n---------\n  uint paranoid;\n  getopt(args, \"paranoid+\", &paranoid);\n---------\n\n    Invoking the program with \"--paranoid --paranoid --paranoid\" will set $(D\n    paranoid) to 3. Note that an incremental option never expects a parameter,\n    e.g. in the command line \"--paranoid 42 --paranoid\", the \"42\" does not set\n    $(D paranoid) to 42; instead, $(D paranoid) is set to 2 and \"42\" is not\n    considered as part of the normal program arguments.\n    )\n\n    $(LI $(I Enum options.) If an option is bound to an enum, an enum symbol as\n    a string is expected as the next option, or right within the option\n    separated with an \"=\" sign:\n\n---------\n  enum Color { no, yes };\n  Color color; // default initialized to Color.no\n  getopt(args, \"color\", &color);\n---------\n\n    To set $(D color) to $(D Color.yes), invoke the program with either\n    $(D --color=yes) or $(D --color yes).\n    )\n\n    $(LI $(I String options.) If an option is bound to a string, a string is\n    expected as the next option, or right within the option separated with an\n    \"=\" sign:\n\n---------\nstring outputFile;\ngetopt(args, \"output\", &outputFile);\n---------\n\n    Invoking the program with \"--output=myfile.txt\" or \"--output myfile.txt\"\n    will set $(D outputFile) to \"myfile.txt\". If you want to pass a string\n    containing spaces, you need to use the quoting that is appropriate to your\n    shell, e.g. --output='my file.txt'.\n    )\n\n    $(LI $(I Array options.) If an option is bound to an array, a new element\n    is appended to the array each time the option occurs:\n\n---------\nstring[] outputFiles;\ngetopt(args, \"output\", &outputFiles);\n---------\n\n    Invoking the program with \"--output=myfile.txt --output=yourfile.txt\" or\n    \"--output myfile.txt --output yourfile.txt\" will set $(D outputFiles) to\n    $(D [ \"myfile.txt\", \"yourfile.txt\" ]).\n\n    Alternatively you can set $(LREF arraySep) as the element separator:\n\n---------\nstring[] outputFiles;\narraySep = \",\";  // defaults to \"\", separation by whitespace\ngetopt(args, \"output\", &outputFiles);\n---------\n\n    With the above code you can invoke the program with\n    \"--output=myfile.txt,yourfile.txt\", or \"--output myfile.txt,yourfile.txt\".)\n\n    $(LI $(I Hash options.) If an option is bound to an associative array, a\n    string of the form \"name=value\" is expected as the next option, or right\n    within the option separated with an \"=\" sign:\n\n---------\ndouble[string] tuningParms;\ngetopt(args, \"tune\", &tuningParms);\n---------\n\n    Invoking the program with e.g. \"--tune=alpha=0.5 --tune beta=0.6\" will set\n    $(D tuningParms) to [ \"alpha\" : 0.5, \"beta\" : 0.6 ].\n\n    Alternatively you can set $(LREF arraySep) as the element separator:\n\n---------\ndouble[string] tuningParms;\narraySep = \",\";  // defaults to \"\", separation by whitespace\ngetopt(args, \"tune\", &tuningParms);\n---------\n\n    With the above code you can invoke the program with\n    \"--tune=alpha=0.5,beta=0.6\", or \"--tune alpha=0.5,beta=0.6\".\n\n    In general, the keys and values can be of any parsable types.\n    )\n\n    $(LI $(I Callback options.) An option can be bound to a function or\n    delegate with the signature $(D void function()), $(D void function(string\n    option)), $(D void function(string option, string value)), or their\n    delegate equivalents.\n\n    $(UL\n        $(LI If the callback doesn't take any arguments, the callback is\n        invoked whenever the option is seen.\n        )\n\n        $(LI If the callback takes one string argument, the option string\n        (without the leading dash(es)) is passed to the callback.  After that,\n        the option string is considered handled and removed from the options\n        array.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option)\n  {\n    if (option == \"quiet\")\n    {\n      verbosityLevel = 0;\n    }\n    else\n    {\n      assert(option == \"verbose\");\n      verbosityLevel = 2;\n    }\n  }\n  getopt(args, \"verbose\", &myHandler, \"quiet\", &myHandler);\n}\n---------\n\n        )\n\n        $(LI If the callback takes two string arguments, the option string is\n        handled as an option with one argument, and parsed accordingly. The\n        option and its value are passed to the callback. After that, whatever\n        was passed to the callback is considered handled and removed from the\n        list.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option, string value)\n  {\n    switch (value)\n    {\n      case \"quiet\": verbosityLevel = 0; break;\n      case \"verbose\": verbosityLevel = 2; break;\n      case \"shouting\": verbosityLevel = verbosityLevel.max; break;\n      default :\n        stderr.writeln(\"Dunno how verbose you want me to be by saying \",\n          value);\n        exit(1);\n    }\n  }\n  getopt(args, \"verbosity\", &myHandler);\n}\n---------\n        )\n    ))\n)\n\nOptions_with_multiple_names:\nSometimes option synonyms are desirable, e.g. \"--verbose\",\n\"--loquacious\", and \"--garrulous\" should have the same effect. Such\nalternate option names can be included in the option specification,\nusing \"|\" as a separator:\n\n---------\nbool verbose;\ngetopt(args, \"verbose|loquacious|garrulous\", &verbose);\n---------\n\nCase:\nBy default options are case-insensitive. You can change that behavior\nby passing $(D getopt) the $(D caseSensitive) directive like this:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nIn the example above, \"--foo\", \"--bar\", \"--FOo\", \"--bAr\" etc. are recognized.\nThe directive is active til the end of $(D getopt), or until the\nconverse directive $(D caseInsensitive) is encountered:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    std.getopt.config.caseInsensitive,\n    \"bar\", &bar);\n---------\n\nThe option \"--Foo\" is rejected due to $(D\nstd.getopt.config.caseSensitive), but not \"--Bar\", \"--bAr\"\netc. because the directive $(D\nstd.getopt.config.caseInsensitive) turned sensitivity off before\noption \"bar\" was parsed.\n\nShort_versus_long_options:\nTraditionally, programs accepted single-letter options preceded by\nonly one dash (e.g. $(D -t)). $(D getopt) accepts such parameters\nseamlessly. When used with a double-dash (e.g. $(D --t)), a\nsingle-letter option behaves the same as a multi-letter option. When\nused with a single dash, a single-letter option is accepted. If the\noption has a parameter, that must be \"stuck\" to the option without\nany intervening space or \"=\":\n\n---------\nuint timeout;\ngetopt(args, \"timeout|t\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), use either of the following: $(D --timeout=5),\n$(D --timeout 5), $(D --t=5), $(D --t 5), or $(D -t5). Forms such as $(D -t 5)\nand $(D -timeout=5) will be not accepted.\n\nFor more details about short options, refer also to the next section.\n\nBundling:\nSingle-letter options can be bundled together, i.e. \"-abc\" is the same as\n$(D \"-a -b -c\"). By default, this option is turned off. You can turn it on\nwith the $(D std.getopt.config.bundling) directive:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.bundling,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nIn case you want to only enable bundling for some of the parameters,\nbundling can be turned off with $(D std.getopt.config.noBundling).\n\nRequired:\nAn option can be marked as required. If that option is not present in the\narguments an exceptin will be thrown.\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.required,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nOnly the option direclty following $(D std.getopt.config.required) is\nrequired.\n\nPassing_unrecognized_options_through:\nIf an application needs to do its own processing of whichever arguments\n$(D getopt) did not understand, it can pass the\n$(D std.getopt.config.passThrough) directive to $(D getopt):\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.passThrough,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nAn unrecognized option such as \"--baz\" will be found untouched in\n$(D args) after $(D getopt) returns.\n\nHelp_Information_Generation:\nIf an option string is followed by another string, this string serves as an\ndescription for this option. The function $(D getopt) returns a struct of type\n$(D GetoptResult). This return value contains information about all passed options\nas well a bool indicating if information about these options where required by\nthe passed arguments.\n\nThe function also always adds an option for `--help|-h` to set the flag\n$(D GetoptResult.helpWanted) if seen on the command line.\n\nOptions_Terminator:\nA lonesome double-dash terminates $(D getopt) gathering. It is used to\nseparate program options from other parameters (e.g. options to be passed\nto another program). Invoking the example above with $(D \"--foo -- --bar\")\nparses foo but leaves \"--bar\" in $(D args). The double-dash itself is\nremoved from the argument array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL441_631)\n---\nauto args = [\"prog\", \"--foo\", \"-b\"];\n\nbool foo;\nbool bar;\nauto rslt = getopt(args, \"foo|f\", \"Some information about foo.\", &foo, \"bar|b\",\n    \"Some help message about bar.\", &bar);\n\nif (rslt.helpWanted)\n{\n    defaultGetoptPrinter(\"Some information about the program.\",\n        rslt.options);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL441_631)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 14,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "caseSensitive",
						"line": 465,
						"value": "0",
						"comment": "Turns case sensitivity on\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "caseInsensitive",
						"line": 467,
						"value": "1",
						"comment": "Turns case sensitivity off\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bundling",
						"line": 469,
						"value": "2",
						"comment": "Turns bundling on\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "noBundling",
						"line": 471,
						"value": "3",
						"comment": "Turns bundling off\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "passThrough",
						"line": 473,
						"value": "4",
						"comment": "Pass unrecognized arguments through\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "noPassThrough",
						"line": 475,
						"value": "5",
						"comment": "Signal unrecognized arguments as errors\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stopOnFirstNonOption",
						"line": 477,
						"value": "6",
						"comment": "Stop at first argument that does not look like an option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "keepEndOfOptions",
						"line": 479,
						"value": "7",
						"comment": "Do not erase the endOfOptions separator from args\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "required",
						"line": 481,
						"value": "8",
						"comment": "Makes the next option a required option\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "config",
				"line": 463,
				"comment": "   Configuration options for $(D getopt).\n\n   You can pass them to $(D getopt) in any position, except in between an option\n   string and its bound pointer.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "GetoptResult",
				"line": 488,
				"comment": " The result of the $(D getopt) function.\n\n$(D helpWanted) is set if the option `--help` or `-h` was passed to the option parser.\n",
				"members": [
					{
						"offset": 0,
						"name": "helpWanted",
						"line": 489,
						"comment": "Flag indicating if help was requested\n",
						"deco": "b",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "options",
						"line": 490,
						"comment": "All possible options\n",
						"deco": "AS3std6getopt6Option",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Option",
				"line": 495,
				"comment": " The result of the $(D getoptHelp) function.\n",
				"members": [
					{
						"offset": 0,
						"name": "optShort",
						"line": 496,
						"comment": "The short symbol for this option\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "optLong",
						"line": 497,
						"comment": "The long symbol for this option\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "help",
						"line": 498,
						"comment": "The description of this option\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "required",
						"line": 499,
						"comment": "If a option is required, not passing it will result in an error\n",
						"deco": "b",
						"char": 10,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "optionChar",
				"line": 854,
				"comment": "   The option character (default '-').\n\n   Defaults to '-' but it can be assigned to prior to calling $(D getopt).\n",
				"deco": "w",
				"init": "'-'",
				"char": 7,
				"kind": "variable"
			},
			{
				"name": "endOfOptions",
				"line": 862,
				"comment": "   The string that conventionally marks the end of all options (default '--').\n\n   Defaults to \"--\" but can be assigned to prior to calling $(D getopt). Assigning an\n   empty string to $(D endOfOptions) effectively disables it.\n",
				"deco": "Aya",
				"init": "\"--\"",
				"char": 8,
				"kind": "variable"
			},
			{
				"name": "assignChar",
				"line": 869,
				"comment": "   The assignment character used in options with parameters (default '=').\n\n   Defaults to '=' but can be assigned to prior to calling $(D getopt).\n",
				"deco": "w",
				"init": "'='",
				"char": 7,
				"kind": "variable"
			},
			{
				"name": "arraySep",
				"line": 877,
				"comment": "   The string used to separate the elements of an array or associative array\n   (default is \"\" which means the elements are separated by whitespace).\n\n   Defaults to \"\" but can be assigned to prior to calling $(D getopt).\n",
				"deco": "Aya",
				"init": "\"\"",
				"char": 8,
				"kind": "variable"
			},
			{
				"endchar": 1,
				"name": "defaultGetoptPrinter",
				"line": 1384,
				"comment": " This function prints the passed $(D Option) and text in an aligned manner.\n\nThe passed text will be printed first, followed by a newline. Than the short\nand long version of every option will be printed. The short and long version\nwill be aligned to the longest option of every $(D Option) passed. If a help\nmessage is present it will be printed after the long version of the\n$(D Option).\n\n------------\nforeach(it; opt)\n{\n    writefln(\"%*s %*s %s\", lengthOfLongestShortOption, it.optShort,\n        lengthOfLongestLongOption, it.optLong, it.help);\n}\n------------\n\nParams:\n    text = The text to printed at the beginning of the help output.\n    opt = The $(D Option) extracted from the $(D getopt) parameter.\n",
				"deco": "FAyaAS3std6getopt6OptionZv",
				"parameters": [
					{
						"name": "text",
						"deco": "Aya"
					},
					{
						"name": "opt",
						"deco": "AS3std6getopt6Option"
					}
				],
				"endline": 1389,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "defaultGetoptFormatter",
						"line": 1400,
						"type": "void(Output output, string text, Option[] opt)",
						"parameters": [
							{
								"name": "output",
								"type": "Output"
							},
							{
								"name": "text",
								"type": "string"
							},
							{
								"name": "opt",
								"type": "Option[]"
							}
						],
						"endline": 1426,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "defaultGetoptFormatter",
				"line": 1400,
				"comment": " This function writes the passed text and $(D Option) into an output range\nin the manner, described in the documentation of function\n$(D defaultGetoptPrinter).\n\nParams:\n    output = The output range used to write the help information.\n    text = The text to printed at the beginning of the help output.\n    opt = The $(D Option) extracted from the $(D getopt) parameter.\n",
				"parameters": [
					{
						"name": "Output",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "Processing of command line options.\n\nThe getopt module implements a $(D getopt) function, which adheres to\nthe POSIX syntax for command line options. GNU extensions are\nsupported in the form of long options introduced by a double dash\n(\"--\"). Support for bundling of command line options, as was the case\nwith the more traditional single-letter approach, is provided but not\nenabled by default.\n\nMacros:\n\nWIKI = Phobos/StdGetopt\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nCredits:   This module and its documentation are inspired by Perl's $(WEB\n           perldoc.perl.org/Getopt/Long.html, Getopt::Long) module. The syntax of\n           D's $(D getopt) is simpler than its Perl counterpart because $(D\n           getopt) infers the expected parameter types from the static types of\n           the passed-in pointers.\nSource:    $(PHOBOSSRC std/_getopt.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/compiler.d",
		"name": "std.compiler",
		"members": [
			{
				"name": "name",
				"line": 24,
				"comment": "Vendor specific string naming the compiler, for example: \"Digital Mars D\".\n",
				"deco": "yAa",
				"originalType": "string",
				"init": "\"Digital Mars D\"",
				"char": 12,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"members": [
					{
						"name": "unknown",
						"line": 29,
						"value": "0",
						"comment": "Compiler vendor could not be detected\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "digitalMars",
						"line": 30,
						"value": "1",
						"comment": "Digital Mars D (DMD)\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "gnu",
						"line": 31,
						"value": "2",
						"comment": "GNU D Compiler (GDC)\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "llvm",
						"line": 32,
						"value": "3",
						"comment": "LLVM D Compiler (LDC)\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "dotNET",
						"line": 33,
						"value": "4",
						"comment": "D.NET\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "sdc",
						"line": 34,
						"value": "5",
						"comment": "Stupid D Compiler (SDC)\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "Vendor",
				"line": 27,
				"comment": "Master list of D compiler vendors.\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "vendor",
				"line": 38,
				"comment": "Which vendor produced this compiler.\n",
				"deco": "yE3std8compiler6Vendor",
				"originalType": "Vendor",
				"char": 38,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "version_major",
				"line": 51,
				"comment": " The vendor specific version number, as in\n version_major.version_minor\n",
				"deco": "yk",
				"originalType": "uint",
				"init": "2u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "version_minor",
				"line": 52,
				"comment": "ditto\n",
				"deco": "yk",
				"originalType": "uint",
				"init": "68u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "D_major",
				"line": 59,
				"comment": " The version of the D Programming Language Specification\n supported by the compiler.\n",
				"deco": "yk",
				"originalType": "uint",
				"init": "2u",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			}
		],
		"comment": " Identify the compiler used and its various features.\n\n Macros:\n      WIKI = Phobos/StdCompiler\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright), Alex RÃ¸nne Petersen\n Source:    $(PHOBOSSRC std/_compiler.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/datetime.d",
		"name": "std.datetime",
		"members": [
			{
				"members": [
					{
						"name": "jan",
						"line": 167,
						"value": "cast(ubyte)1u",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "feb",
						"line": 168,
						"value": "2",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "mar",
						"line": 169,
						"value": "3",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "apr",
						"line": 170,
						"value": "4",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "may",
						"line": 171,
						"value": "5",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "jun",
						"line": 172,
						"value": "6",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "jul",
						"line": 173,
						"value": "7",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "aug",
						"line": 174,
						"value": "8",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "sep",
						"line": 175,
						"value": "9",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "oct",
						"line": 176,
						"value": "10",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "nov",
						"line": 177,
						"value": "11",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					},
					{
						"name": "dec",
						"line": 178,
						"value": "12",
						"comment": "\n",
						"char": 22,
						"kind": "enum member"
					}
				],
				"name": "Month",
				"line": 167,
				"comment": "    Represents the 12 months of the Gregorian year (January is 1).\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "sun",
						"line": 184,
						"value": "cast(ubyte)0u",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "mon",
						"line": 185,
						"value": "1",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "tue",
						"line": 186,
						"value": "2",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "wed",
						"line": 187,
						"value": "3",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "thu",
						"line": 188,
						"value": "4",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "fri",
						"line": 189,
						"value": "5",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					},
					{
						"name": "sat",
						"line": 190,
						"value": "6",
						"comment": "\n",
						"char": 26,
						"kind": "enum member"
					}
				],
				"name": "DayOfWeek",
				"line": 184,
				"comment": "    Represents the 7 days of the Gregorian week (Sunday is 0).\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 208,
						"value": "0",
						"comment": "No, don't allow day overflow.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 211,
						"value": "1",
						"comment": "Yes, allow day overflow.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AllowDayOverflow",
				"line": 205,
				"comment": "    In some date calculations, adding months or years can cause the date to fall\n    on a day of the month which is not valid (e.g. February 29th 2001 or\n    June 31st 2000). If overflow is allowed (as is the default), then the month\n    will be incremented accordingly (so, February 29th 2001 would become\n    March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow\n    is not allowed, then the day will be adjusted to the last valid day in that\n    month (so, February 29th 2001 would become February 28th 2001 and\n    June 31st 2000 would become June 30th 2000).\n\n    AllowDayOverflow only applies to calculations involving months or years.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "bwd",
						"line": 222,
						"value": "0",
						"comment": "Backward.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "fwd",
						"line": 225,
						"value": "1",
						"comment": "Forward.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "both",
						"line": 228,
						"value": "2",
						"comment": "Both backward and forward.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Direction",
				"line": 219,
				"comment": "    Indicates a direction in time. One example of its use is $(LREF2 .Interval, Interval)'s\n    $(LREF expand, expand) function which uses it to indicate whether the interval should\n    be expanded backwards (into the past), forwards (into the future), or both.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 259,
						"value": "0",
						"comment": "No, don't call popFront() before returning the range.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 262,
						"value": "1",
						"comment": "Yes, call popFront() before returning the range.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "PopFirst",
				"line": 256,
				"comment": "    Used to indicate whether $(D popFront) should be called immediately upon\n    creating a range. The idea is that for some functions used to generate a\n    range for an interval, $(D front) is not necessarily a time point which\n    would ever be generated by the range. To get the first time point\n    in the range to match what the function generates, then use\n    $(D PopFirst.yes) to indicate that the range should have $(D popFront)\n    called on it before the range is returned so that $(D front) is a time point\n    which the function would generate.\n\n    For instance, if the function used to generate a range of time points\n    generated successive Easters (i.e. you're iterating over all of the Easters\n    within the interval), the initial date probably isn't an Easter. Using\n    $(D PopFirst.yes) would tell the function which returned the\n    range that $(D popFront) was to be called so that front would then be\n    an Easter - the next one generated by the function (which when\n    iterating forward would be the Easter following the original $(D front),\n    while when iterating backward, it would be the Easter prior to the\n    original $(D front)). If $(D PopFirst.no) were used, then $(D front) would\n    remain the original time point and it would not necessarily be a time point\n    which would be generated by the range-generating function (which in many\n    cases is exactly what is desired -\n    e.g. if iterating over every day starting at the beginning\n    of the interval).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 272,
						"value": "0",
						"comment": "No, don't start the StopWatch when it is constructed.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 275,
						"value": "1",
						"comment": "Yes, do start the StopWatch when it is constructed.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AutoStart",
				"line": 269,
				"comment": "   Used by StopWatch to indicate whether it should start immediately upon\n   construction.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "timeStrings",
				"line": 287,
				"comment": "    Array of the strings representing time units, starting with the smallest\n    unit and going to the largest. It does not include $(D \"nsecs\").\n\n   Includes $(D \"hnsecs\") (hecto-nanoseconds (100 ns)),\n   $(D \"usecs\") (microseconds), $(D \"msecs\") (milliseconds), $(D \"seconds\"),\n   $(D \"minutes\"), $(D \"hours\"), $(D \"days\"), $(D \"weeks\"), $(D \"months\"), and\n   $(D \"years\")\n",
				"deco": "yAAa",
				"originalType": "string[]",
				"init": "[\"hnsecs\", \"usecs\", \"msecs\", \"seconds\", \"minutes\", \"hours\", \"days\", \"weeks\", \"months\", \"years\"]",
				"char": 20,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "DateTimeException",
				"line": 300,
				"comment": "    Exception type used by std.datetime. It's an alias to $(CXREF time, TimeException).\n    Either can be caught without concern about which\n    module it came from.\n",
				"deco": "C4core4time13TimeException",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Clock",
				"line": 306,
				"comment": "    Effectively a namespace to make it clear that the methods it contains are\n    getting the time from the system clock. It cannot be instantiated.\n",
				"members": [
					{
						"endchar": 5,
						"name": "currTime",
						"line": 317,
						"comment": "        Returns the current time in the given time zone.\n\n        Throws:\n            $(XREF exception, ErrnoException) (on Posix) or $(XREF exception, Exception) (on Windows)\n            if it fails to get the time of day.\n",
						"deco": "FNfyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "opCall()"
							}
						],
						"endline": 320,
						"originalType": "@safe SysTime(immutable TimeZone tz = LocalTime())",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "currStdTime",
						"line": 353,
						"comment": "        Returns the number of hnsecs since midnight, January 1st, 1 A.D. for the\n        current time.\n\n        Throws:\n            $(LREF DateTimeException) if it fails to get the time.\n",
						"deco": "FNdNeZl",
						"endline": 389,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "currSystemTick",
						"line": 407,
						"comment": "        The current system tick. The number of ticks per second varies from\n        system to system. currSystemTick uses a monotonic clock, so it's\n        intended for precision timing by comparing relative time values, not\n        for getting the current system time.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or Linux.\n\n        Throws:\n            $(LREF DateTimeException) if it fails to get the time.\n",
						"deco": "FNbNdNfZS4core4time12TickDuration",
						"endline": 410,
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "currAppTick",
						"line": 432,
						"comment": "        The current number of system ticks since the application started.\n        The number of ticks per second varies from system to system.\n        This uses a monotonic clock.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or on Linux.\n\n        Throws:\n            $(LREF DateTimeException) if it fails to get the time.\n",
						"deco": "FNdNfZS4core4time12TickDuration",
						"endline": 435,
						"char": 35,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"name": "SysTime",
				"line": 497,
				"comment": "    $(D SysTime) is the type used to get the current time from the\n    system or doing anything that involves time zones. Unlike\n    $(LREF DateTime), the time zone is an integral part of $(D SysTime) (though for\n    local time applications, time zones can be ignored and\n    it will work, since it defaults to using the local time zone). It holds its\n    internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC),\n    so it interfaces well with the system time. However, that means that, unlike\n    $(LREF DateTime), it is not optimized for calendar-based operations, and\n    getting individual units from it such as years or days is going to involve\n    conversions and be less efficient.\n\n    For calendar-based operations that don't\n    care about time zones, then $(LREF DateTime) would be the type to\n    use. For system time, use $(D SysTime).\n\n    $(LREF2 .Clock.currTime, Clock.currTime) will return the current time as a $(D SysTime).\n    To convert a $(D SysTime) to a $(LREF Date) or $(LREF DateTime), simply cast\n    it. To convert a $(LREF Date) or $(LREF DateTime) to a\n    $(D SysTime), use $(D SysTime)'s constructor, and pass in the\n    intended time zone with it (or don't pass in a $(LREF2 .TimeZone, TimeZone), and the local\n    time zone will be used). Be aware, however, that converting from a\n    $(LREF DateTime) to a $(D SysTime) will not necessarily be 100% accurate due to\n    DST (one hour of the year doesn't exist and another occurs twice).\n    To not risk any conversion errors, keep times as\n    $(D SysTime)s. Aside from DST though, there shouldn't be any conversion\n    problems.\n\n    For using time zones other than local time or UTC, use\n    $(LREF PosixTimeZone) on Posix systems (or on Windows, if providing the TZ\n    Database files), and use $(LREF WindowsTimeZone) on Windows systems.\n    The time in $(D SysTime) is kept internally in hnsecs from midnight,\n    January 1st, 1 A.D. UTC. Conversion error cannot happen when changing\n    the time zone of a $(D SysTime). $(LREF LocalTime) is the $(LREF2 .TimeZone, TimeZone) class\n    which represents the local time, and $(D UTC) is the $(LREF2 .TimeZone, TimeZone) class\n    which represents UTC. $(D SysTime) uses $(LREF LocalTime) if no $(LREF2 .TimeZone, TimeZone)\n    is provided. For more details on time zones, see the documentation for\n    $(LREF2 .TimeZone, TimeZone), $(LREF PosixTimeZone), and $(LREF WindowsTimeZone).\n\n    $(D SysTime)'s range is from approximately 29,000 B.C. to approximately\n    29,000 A.D.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 512,
						"comment": "        Params:\n            dateTime = The $(LREF DateTime) to use to set this $(LREF SysTime)'s\n                       internal std time. As $(LREF DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            tz       = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                       $(LREF LocalTime) will be used. The given $(LREF DateTime) is\n                       assumed to be in the given time zone.\n",
						"deco": "FNbNcNfxS3std8datetime8DateTimeyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "dateTime",
								"deco": "xS3std8datetime8DateTime"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 518,
						"originalType": "nothrow ref @safe (in DateTime dateTime, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 557,
						"comment": "        Params:\n            dateTime = The $(LREF DateTime) to use to set this $(LREF SysTime)'s\n                       internal std time. As $(LREF DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            fracSecs = The fractional seconds portion of the time.\n            tz       = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                       $(LREF LocalTime) will be used. The given $(LREF DateTime) is\n                       assumed to be in the given time zone.\n\n        Throws:\n            $(LREF DateTimeException) if $(D fracSecs) is negative or if it's\n            greater than or equal to one second.\n",
						"deco": "FNcNfxS3std8datetime8DateTimexS4core4time8DurationyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "dateTime",
								"deco": "xS3std8datetime8DateTime"
							},
							{
								"name": "fracSecs",
								"deco": "xS4core4time8Duration"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 570,
						"originalType": "ref @safe (in DateTime dateTime, in Duration fracSecs, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 615,
						"comment": "        $(RED Scheduled for deprecation. Please use the overload which takes a\n              $(CXREF time, Duration) for the fractional seconds. This overload\n              will be deprecated in 2.068).\n\n        Params:\n            dateTime = The $(LREF DateTime) to use to set this $(LREF SysTime)'s\n                       internal std time. As $(LREF DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            fracSec  = The fractional seconds portion of the time.\n            tz       = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                       $(LREF LocalTime) will be used. The given $(LREF DateTime) is\n                       assumed to be in the given time zone.\n\n        Throws:\n            $(LREF DateTimeException) if $(D fracSec) is negative.\n",
						"deco": "FNcNfxS3std8datetime8DateTimexS4core4time7FracSecyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "dateTime",
								"deco": "xS3std8datetime8DateTime"
							},
							{
								"name": "fracSec",
								"deco": "xS4core4time7FracSec"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 633,
						"originalType": "ref @safe (in DateTime dateTime, in FracSec fracSec, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 672,
						"comment": "        Params:\n            date = The $(LREF Date) to use to set this $(LREF SysTime)'s internal std\n                   time. As $(LREF Date) has no concept of time zone, tz is used as\n                   its time zone.\n            tz   = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                   $(LREF LocalTime) will be used. The given $(LREF Date) is assumed\n                   to be in the given time zone.\n",
						"deco": "FNbNcNfxS3std8datetime4DateyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "date",
								"deco": "xS3std8datetime4Date"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 685,
						"originalType": "nothrow ref @safe (in Date date, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 720,
						"comment": "        Note:\n            Whereas the other constructors take in the given date/time, assume\n            that it's in the given time zone, and convert it to hnsecs in UTC\n            since midnight, January 1st, 1 A.D. UTC - i.e. std time - this\n            constructor takes a std time, which is specifically already in UTC,\n            so no conversion takes place. Of course, the various getter\n            properties and functions will use the given time zone's conversion\n            function to convert the results to that time zone, but no conversion\n            of the arguments to this constructor takes place.\n\n        Params:\n            stdTime = The number of hnsecs since midnight, January 1st, 1 A.D. UTC.\n            tz      = The $(LREF2 .TimeZone, TimeZone) to use for this $(LREF SysTime). If null,\n                      $(LREF LocalTime) will be used.\n",
						"deco": "FNaNbNcNflyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							},
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone",
								"default": "null"
							}
						],
						"endline": 724,
						"originalType": "pure nothrow ref @safe (long stdTime, immutable TimeZone tz = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opAssign",
						"line": 748,
						"comment": "        Params:\n            rhs = The $(LREF SysTime) to assign to this one.\n",
						"deco": "FNaNbNcNjNfKxS3std8datetime7SysTimeZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 754,
						"originalType": "pure nothrow ref @safe SysTime(ref const SysTime rhs)return ",
						"char": 17,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opAssign",
						"line": 760,
						"comment": "        Params:\n            rhs = The $(LREF SysTime) to assign to this one.\n",
						"deco": "FNaNbNcNjNfS3std8datetime7SysTimeZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S3std8datetime7SysTime"
							}
						],
						"endline": 766,
						"char": 17,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 775,
						"comment": "        Checks for equality between this $(LREF SysTime) and the given\n        $(LREF SysTime).\n\n        Note that the time zone is ignored. Only the internal\n        std times (which are in UTC) are compared.\n",
						"deco": "xFNaNbNfxS3std8datetime7SysTimeZb",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 778,
						"originalType": "const pure nothrow @safe bool(const SysTime rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 781,
						"comment": "ditto\n",
						"deco": "xFNaNbNfKxS3std8datetime7SysTimeZb",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 784,
						"originalType": "const pure nothrow @safe bool(ref const SysTime rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 842,
						"comment": "        Compares this $(LREF SysTime) with the given $(LREF SysTime).\n\n        Time zone is irrelevant when comparing $(LREF SysTime)s.\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime7SysTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 850,
						"originalType": "const pure nothrow @safe int(in SysTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 915,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n",
						"deco": "xFNbNdNfZs",
						"endline": 918,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 968,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(LREF SysTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL987_669)\n---\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).year == 1999);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).year == 2010);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL987_669)\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 984,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 1048,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(LREF DateTimeException) if $(D isAD) is true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1054_671)\n---\nassert(SysTime(DateTime(0, 1, 1, 12, 30, 33)).yearBC == 1);\nassert(SysTime(DateTime(-1, 1, 1, 10, 7, 2)).yearBC == 2);\nassert(SysTime(DateTime(-100, 1, 1, 4, 59, 0)).yearBC == 101);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1054_671)\n",
						"deco": "xFNdNfZt",
						"endline": 1051,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 1092,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(LREF SysTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if a non-positive value is given.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 1108,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 1181,
						"comment": "        Month of a Gregorian Year.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1187_675)\n---\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).month == 7);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).month == 10);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).month == 4);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1187_675)\n",
						"deco": "xFNbNdNfZE3std8datetime5Month",
						"endline": 1184,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 1241,
						"comment": "        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(LREF SysTime)'s month to.\n\n        Throws:\n            $(LREF DateTimeException) if the given month is not a valid month.\n",
						"deco": "FNdNfE3std8datetime5MonthZv",
						"parameters": [
							{
								"name": "month",
								"deco": "E3std8datetime5Month"
							}
						],
						"endline": 1257,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 1341,
						"comment": "        Day of a Gregorian Month.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1347_679)\n---\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).day == 6);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).day == 4);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).day == 5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1347_679)\n",
						"deco": "xFNbNdNfZh",
						"endline": 1344,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 1403,
						"comment": "        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(LREF SysTime)'s day to.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is not a valid day of the\n            current month.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 1419,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 1496,
						"comment": "        Hours past midnight.\n",
						"deco": "xFNbNdNfZh",
						"endline": 1508,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 1566,
						"comment": "        Hours past midnight.\n\n        Params:\n            hour = The hours to set this $(LREF SysTime)'s hour to.\n\n        Throws:\n            $(LREF DateTimeException) if the given hour are not a valid hour of\n            the day.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							}
						],
						"endline": 1585,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 1619,
						"comment": "        Minutes past the current hour.\n",
						"deco": "xFNbNdNfZh",
						"endline": 1633,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 1691,
						"comment": "        Minutes past the current hour.\n\n        Params:\n            minute = The minute to set this $(LREF SysTime)'s minute to.\n\n        Throws:\n            $(LREF DateTimeException) if the given minute are not a valid minute\n            of an hour.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "minute",
								"deco": "i"
							}
						],
						"endline": 1713,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 1747,
						"comment": "        Seconds past the current minute.\n",
						"deco": "xFNbNdNfZh",
						"endline": 1762,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 1820,
						"comment": "        Seconds past the current minute.\n\n        Params:\n            second = The second to set this $(LREF SysTime)'s second to.\n\n        Throws:\n            $(LREF DateTimeException) if the given second are not a valid second\n            of a minute.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "second",
								"deco": "i"
							}
						],
						"endline": 1844,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fracSecs",
						"line": 1879,
						"comment": "        Fractional seconds past the second (i.e. the portion of a\n        $(LREF SysTime) which is less than a second).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1890_688)\n---\nauto dt = DateTime(1982, 4, 1, 20, 59, 22);\nassert(SysTime(dt, msecs(213)).fracSecs == msecs(213));\nassert(SysTime(dt, usecs(5202)).fracSecs == usecs(5202));\nassert(SysTime(dt, hnsecs(1234567)).fracSecs == hnsecs(1234567));\n\n// SysTime and Duration both have a precision of hnsecs (100 ns),\n// so nsecs are going to be truncated.\nassert(SysTime(dt, nsecs(123456789)).fracSecs == nsecs(123456700));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1890_688)\n",
						"deco": "xFNbNdNfZS4core4time8Duration",
						"endline": 1887,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fracSecs",
						"line": 1951,
						"comment": "        Fractional seconds past the second (i.e. the portion of a\n        $(LREF SysTime) which is less than a second).\n\n        Params:\n            fracSecs = The duration to set this $(LREF SysTime)'s fractional\n                       seconds to.\n\n        Throws:\n            $(LREF DateTimeException) if the given duration is negative or if\n            it's greater than or equal to one second.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1975_690)\n---\nauto st = SysTime(DateTime(1982, 4, 1, 20, 59, 22));\nassert(st.fracSecs == Duration.zero);\n\nst.fracSecs = msecs(213);\nassert(st.fracSecs == msecs(213));\n\nst.fracSecs = hnsecs(1234567);\nassert(st.fracSecs == hnsecs(1234567));\n\n// SysTime has a precision of hnsecs (100 ns), so nsecs are\n// going to be truncated.\nst.fracSecs = nsecs(123456789);\nassert(st.fracSecs == hnsecs(1234567));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1975_690)\n",
						"deco": "FNdNfS4core4time8DurationZv",
						"parameters": [
							{
								"name": "fracSecs",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 1972,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fracSec",
						"line": 2028,
						"comment": "        $(RED Scheduled for deprecation. Please use $(LREF fracSecs) instead of\n              fracSec. It uses a $(CXREF time, Duration) to represent the\n              fractional seconds instead of a $(CXREF time, FracSec). This\n              overload will be deprecated in 2.068).\n\n        Fractional seconds past the second.\n",
						"deco": "xFNbNdNfZS4core4time7FracSec",
						"endline": 2043,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fracSec",
						"line": 2107,
						"comment": "        $(RED Scheduled for deprecation. Please use $(LREF fracSecs) instead of\n              fracSec. It uses a $(CXREF time, Duration) to represent the\n              fractional seconds instead of a $(CXREF time, FracSec). This\n              overload will be deprecated in 2.068).\n\n        Fractional seconds past the second.\n\n        Params:\n            fracSec = The fractional seconds to set this $(LREF SysTime)'s\n                      fractional seconds to.\n\n        Throws:\n            $(LREF DateTimeException) if $(D fracSec) is negative.\n",
						"deco": "FNdNfS4core4time7FracSecZv",
						"parameters": [
							{
								"name": "fracSec",
								"deco": "S4core4time7FracSec"
							}
						],
						"endline": 2133,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdTime",
						"line": 2165,
						"comment": "        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(LREF SysTime).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 2168,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdTime",
						"line": 2192,
						"comment": "        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(LREF SysTime).\n\n        Params:\n            stdTime = The number of hnsecs since January 1st, 1 A.D. UTC.\n",
						"deco": "FNaNbNdNflZv",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 2195,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timezone",
						"line": 2225,
						"comment": "        The current time zone of this $(LREF SysTime). Its internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(LREF SysTime)'s time zone before returning.\n",
						"deco": "xFNaNbNdNfZyC3std8datetime8TimeZone",
						"endline": 2228,
						"char": 35,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timezone",
						"line": 2240,
						"comment": "        The current time zone of this $(LREF SysTime). It's internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(LREF SysTime)'s time zone before returning.\n\n        Params:\n            timezone = The $(LREF2 .TimeZone, TimeZone) to set this $(LREF SysTime)'s time zone to.\n",
						"deco": "FNaNbNdNfyC3std8datetime8TimeZoneZv",
						"parameters": [
							{
								"name": "timezone",
								"deco": "yC3std8datetime8TimeZone"
							}
						],
						"endline": 2246,
						"originalType": "pure nothrow @property @safe void(immutable TimeZone timezone)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 2252,
						"comment": "        Returns whether DST is in effect for this $(LREF SysTime).\n",
						"deco": "xFNbNdNfZb",
						"endline": 2256,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "utcOffset",
						"line": 2263,
						"comment": "        Returns what the offset from UTC is for this $(LREF SysTime).\n        It includes the DST offset in effect at that time (if any).\n",
						"deco": "xFNbNdNfZS4core4time8Duration",
						"endline": 2266,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toLocalTime",
						"line": 2273,
						"comment": "        Returns a $(LREF SysTime) with the same std time as this one, but with\n        $(LREF LocalTime) as its time zone.\n",
						"deco": "xFNaNbNfZS3std8datetime7SysTime",
						"endline": 2276,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toUTC",
						"line": 2305,
						"comment": "        Returns a $(LREF SysTime) with the same std time as this one, but with\n        $(D UTC) as its time zone.\n",
						"deco": "xFNaNbNfZS3std8datetime7SysTime",
						"endline": 2308,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toOtherTZ",
						"line": 2325,
						"comment": "        Returns a $(LREF SysTime) with the same std time as this one, but with\n        given time zone as its time zone.\n",
						"deco": "xFNaNbNfyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
						"parameters": [
							{
								"name": "tz",
								"deco": "yC3std8datetime8TimeZone"
							}
						],
						"endline": 2331,
						"originalType": "const pure nothrow @safe SysTime(immutable TimeZone tz)",
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toUnixTime",
						"line": 2357,
						"comment": "        Returns a $(D time_t) which represents the same time as this\n        $(LREF SysTime).\n\n        Note that like all conversions in std.datetime, this is a truncating\n        conversion.\n\n        If $(D time_t) is 32 bits, rather than 64, and the result can't fit in a\n        32-bit value, then the closest value that can be held in 32 bits will be\n        used (so $(D time_t.max) if it goes over and $(D time_t.min) if it goes\n        under).\n",
						"deco": "xFNaNbNfZl",
						"endline": 2360,
						"originalType": "const pure nothrow @safe time_t()",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toTimeVal",
						"line": 2387,
						"comment": "        Returns a $(D timeval) which represents this $(LREF SysTime).\n\n        Note that like all conversions in std.datetime, this is a truncating\n        conversion.\n\n        If $(D time_t) is 32 bits, rather than 64, and the result can't fit in a\n        32-bit value, then the closest value that can be held in 32 bits will be\n        used for $(D tv_sec). (so $(D time_t.max) if it goes over and\n        $(D time_t.min) if it goes under).\n",
						"deco": "xFNaNbNfZS4core3sys5posix3sys4time7timeval",
						"endline": 2395,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toTM",
						"line": 2423,
						"comment": "        Returns a $(D tm) which represents this $(LREF SysTime).\n",
						"deco": "xFNbNfZS4core4stdc4time2tm",
						"endline": 2447,
						"char": 8,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "add",
								"line": 2527,
								"type": "nothrow ref @safe SysTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 2555,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "add",
						"line": 2527,
						"comment": "        Adds the given number of years or months to this $(LREF SysTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\" || units == \"months\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 3690,
								"type": "nothrow ref @safe SysTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 3694,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 3690,
						"comment": "        Adds the given number of years or months to this $(LREF SysTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(LREF SysTime) 12 months\n        gets the exact same $(LREF SysTime). However, the days can still be affected\n        due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3697_707)\n---\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst1.roll!\"months\"(1);\nassert(st1 == SysTime(DateTime(2010, 2, 1, 12, 33, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst2.roll!\"months\"(-1);\nassert(st2 == SysTime(DateTime(2010, 12, 1, 12, 33, 33)));\n\nauto st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst3.roll!\"months\"(1);\nassert(st3 == SysTime(DateTime(1999, 3, 1, 12, 33, 33)));\n\nauto st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(1999, 2, 28, 12, 33, 33)));\n\nauto st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst5.roll!\"years\"(1);\nassert(st5 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(st6 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3697_707)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 4535,
								"type": "nothrow ref @safe SysTime(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 4560,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 4535,
						"comment": "        Adds the given number of units to this $(LREF SysTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF SysTime) one\n        year's worth of days gets the exact same $(LREF SysTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\"), $(D \"usecs\"), and\n        $(D \"hnsecs\").\n\n        Note that when rolling msecs, usecs or hnsecs, they all add up to a\n        second. So, for example, rolling 1000 msecs is exactly the same as\n        rolling 100,000 usecs.\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(LREF SysTime).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4563_711)\n---\nauto st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));\nst1.roll!\"days\"(1);\nassert(st1 == SysTime(DateTime(2010, 1, 2, 11, 23, 12)));\nst1.roll!\"days\"(365);\nassert(st1 == SysTime(DateTime(2010, 1, 26, 11, 23, 12)));\nst1.roll!\"days\"(-32);\nassert(st1 == SysTime(DateTime(2010, 1, 25, 11, 23, 12)));\n\nauto st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));\nst2.roll!\"hours\"(1);\nassert(st2 == SysTime(DateTime(2010, 7, 4, 13, 0, 0)));\n\nauto st3 = SysTime(DateTime(2010, 2, 12, 12, 0, 0));\nst3.roll!\"hours\"(-1);\nassert(st3 == SysTime(DateTime(2010, 2, 12, 11, 0, 0)));\n\nauto st4 = SysTime(DateTime(2009, 12, 31, 0, 0, 0));\nst4.roll!\"minutes\"(1);\nassert(st4 == SysTime(DateTime(2009, 12, 31, 0, 1, 0)));\n\nauto st5 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst5.roll!\"minutes\"(-1);\nassert(st5 == SysTime(DateTime(2010, 1, 1, 0, 59, 0)));\n\nauto st6 = SysTime(DateTime(2009, 12, 31, 0, 0, 0));\nst6.roll!\"seconds\"(1);\nassert(st6 == SysTime(DateTime(2009, 12, 31, 0, 0, 1)));\n\nauto st7 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst7.roll!\"seconds\"(-1);\nassert(st7 == SysTime(DateTime(2010, 1, 1, 0, 0, 59)));\n\nauto dt = DateTime(2010, 1, 1, 0, 0, 0);\nauto st8 = SysTime(dt);\nst8.roll!\"msecs\"(1);\nassert(st8 == SysTime(dt, msecs(1)));\n\nauto st9 = SysTime(dt);\nst9.roll!\"msecs\"(-1);\nassert(st9 == SysTime(dt, msecs(999)));\n\nauto st10 = SysTime(dt);\nst10.roll!\"hnsecs\"(1);\nassert(st10 == SysTime(dt, hnsecs(1)));\n\nauto st11 = SysTime(dt);\nst11.roll!\"hnsecs\"(-1);\nassert(st11 == SysTime(dt, hnsecs(9_999_999)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4563_711)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"days\"",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 5976,
								"type": "const pure nothrow @safe SysTime(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 5992,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 5976,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF SysTime).\n\n        The legal types of arithmetic for $(LREF SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 6196,
								"type": "pure nothrow ref @safe SysTime(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 6210,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 6196,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF SysTime), as well as assigning the result to this $(LREF SysTime).\n\n        The legal types of arithmetic for $(LREF SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 6402,
								"type": "const pure nothrow @safe Duration(in SysTime rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "SysTime",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 6406,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 6402,
						"comment": "        Gives the difference between two $(LREF SysTime)s.\n\n        The legal types of arithmetic for $(LREF SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD -) $(TD SysTime) $(TD -->) $(TD duration))\n        )\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "diffMonths",
						"line": 6510,
						"comment": "        Returns the difference between the two $(LREF SysTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(LREF SysTime)s. To get the difference in days or weeks,\n        subtract the $(LREF SysTime)s themselves and use the $(CXREF time, Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(CXREF time, Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(LREF SysTime) to subtract from this one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6516_722)\n---\nassert(SysTime(Date(1999, 2, 1)).diffMonths(\n            SysTime(Date(1999, 1, 31))) == 1);\n\nassert(SysTime(Date(1999, 1, 31)).diffMonths(\n            SysTime(Date(1999, 2, 1))) == -1);\n\nassert(SysTime(Date(1999, 3, 1)).diffMonths(\n            SysTime(Date(1999, 1, 1))) == 2);\n\nassert(SysTime(Date(1999, 1, 1)).diffMonths(\n            SysTime(Date(1999, 3, 31))) == -2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6516_722)\n",
						"deco": "xFNbNfxS3std8datetime7SysTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime7SysTime"
							}
						],
						"endline": 6513,
						"originalType": "const nothrow @safe int(in SysTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isLeapYear",
						"line": 6553,
						"comment": "        Whether this $(LREF SysTime) is in a leap year.\n",
						"deco": "xFNbNdNfZb",
						"endline": 6556,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfWeek",
						"line": 6572,
						"comment": "        Day of the week this $(LREF SysTime) is on.\n",
						"deco": "xFNbNdNfZE3std8datetime9DayOfWeek",
						"endline": 6575,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 6591,
						"comment": "        Day of the year this $(LREF SysTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6597_726)\n---\nassert(SysTime(DateTime(1999, 1, 1, 12, 22, 7)).dayOfYear == 1);\nassert(SysTime(DateTime(1999, 12, 31, 7, 2, 59)).dayOfYear == 365);\nassert(SysTime(DateTime(2000, 12, 31, 21, 20, 0)).dayOfYear == 366);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6597_726)\n",
						"deco": "xFNbNdNfZt",
						"endline": 6594,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 6622,
						"comment": "        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(LREF SysTime) is on.\n",
						"deco": "FNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 6634,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 6650,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF SysTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6667_729)\n---\nassert(SysTime(DateTime(1, 1, 1, 0, 0, 0)).dayOfGregorianCal == 1);\nassert(SysTime(DateTime(1, 12, 31, 23, 59, 59)).dayOfGregorianCal == 365);\nassert(SysTime(DateTime(2, 1, 1, 2, 2, 2)).dayOfGregorianCal == 366);\n\nassert(SysTime(DateTime(0, 12, 31, 7, 7, 7)).dayOfGregorianCal == 0);\nassert(SysTime(DateTime(0, 1, 1, 19, 30, 0)).dayOfGregorianCal == -365);\nassert(SysTime(DateTime(-1, 12, 31, 4, 7, 0)).dayOfGregorianCal == -366);\n\nassert(SysTime(DateTime(2000, 1, 1, 9, 30, 20)).dayOfGregorianCal == 730_120);\nassert(SysTime(DateTime(2010, 12, 31, 15, 45, 50)).dayOfGregorianCal == 734_137);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6667_729)\n",
						"deco": "xFNbNdNfZi",
						"endline": 6664,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 7021,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF SysTime) is on.\n        Setting this property does not affect the time portion of $(LREF SysTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(LREF SysTime)\n                   to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7041_732)\n---\nauto st = SysTime(DateTime(0, 1, 1, 12, 0, 0));\nst.dayOfGregorianCal = 1;\nassert(st == SysTime(DateTime(1, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 365;\nassert(st == SysTime(DateTime(1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 366;\nassert(st == SysTime(DateTime(2, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 0;\nassert(st == SysTime(DateTime(0, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = -365;\nassert(st == SysTime(DateTime(-0, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = -366;\nassert(st == SysTime(DateTime(-1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 730_120;\nassert(st == SysTime(DateTime(2000, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 734_137;\nassert(st == SysTime(DateTime(2010, 12, 31, 12, 0, 0)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7041_732)\n",
						"deco": "FNbNdNfiZv",
						"parameters": [
							{
								"name": "days",
								"deco": "i"
							}
						],
						"endline": 7038,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isoWeek",
						"line": 7279,
						"comment": "        The ISO 8601 week of the year that this $(LREF SysTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date).\n",
						"deco": "xFNbNdNfZh",
						"endline": 7282,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "endOfMonth",
						"line": 7299,
						"comment": "        $(LREF SysTime) for the last day in the month that this Date is in.\n        The time portion of endOfMonth is always 23:59:59.9999999.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7325_735)\n---\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).endOfMonth ==\n       SysTime(DateTime(1999, 1, 31, 23, 59, 59),\n               hnsecs(9_999_999)));\n\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0),\n               msecs(24)).endOfMonth ==\n       SysTime(DateTime(1999, 2, 28, 23, 59, 59),\n               hnsecs(9_999_999)));\n\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27),\n               usecs(5203)).endOfMonth ==\n       SysTime(DateTime(2000, 2, 29, 23, 59, 59),\n               hnsecs(9_999_999)));\n\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9),\n               hnsecs(12345)).endOfMonth ==\n       SysTime(DateTime(2000, 6, 30, 23, 59, 59),\n               hnsecs(9_999_999)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7325_735)\n",
						"deco": "xFNbNdNfZS3std8datetime7SysTime",
						"endline": 7322,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "daysInMonth",
						"line": 7392,
						"comment": "        The last day in the month that this $(LREF SysTime) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7398_737)\n---\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).daysInMonth == 31);\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0)).daysInMonth == 28);\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27)).daysInMonth == 29);\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9)).daysInMonth == 30);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7398_737)\n",
						"deco": "xFNbNdNfZh",
						"endline": 7395,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAD",
						"line": 7448,
						"comment": "        Whether the current year is a date in A.D.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7454_739)\n---\nassert(SysTime(DateTime(1, 1, 1, 12, 7, 0)).isAD);\nassert(SysTime(DateTime(2010, 12, 31, 0, 0, 0)).isAD);\nassert(!SysTime(DateTime(0, 12, 31, 23, 59, 59)).isAD);\nassert(!SysTime(DateTime(-2010, 1, 1, 2, 2, 2)).isAD);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7454_739)\n",
						"deco": "xFNbNdNfZb",
						"endline": 7451,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "julianDay",
						"line": 7485,
						"comment": "        The $(WEB en.wikipedia.org/wiki/Julian_day, Julian day)\n        for this $(LREF SysTime) at the given time. For example,\n        prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so\n        this function returns 2_450_173, while from noon onward, the Julian\n        day number would be 2_450_174, so this function returns 2_450_174.\n",
						"deco": "xFNbNdNfZl",
						"endline": 7490,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "modJulianDay",
						"line": 7529,
						"comment": "        The modified $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for any time on this date (since, the modified\n        Julian day changes at midnight).\n",
						"deco": "xFNbNdNfZl",
						"endline": 7532,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 7552,
								"type": "const nothrow @safe Date()",
								"endline": 7556,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 7552,
						"comment": "        Returns a $(LREF Date) equivalent to this $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == Date)",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 7586,
								"type": "const nothrow @safe DateTime()",
								"endline": 7608,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 7586,
						"comment": "        Returns a $(LREF DateTime) equivalent to this $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == DateTime)",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 7645,
								"type": "const nothrow @safe TimeOfDay()",
								"endline": 7664,
								"char": 15,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 7645,
						"comment": "        Returns a $(LREF TimeOfDay) equivalent to this $(LREF SysTime).\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == TimeOfDay)",
						"char": 15,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 7721,
						"comment": "        Converts this $(LREF SysTime) to a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time\n        zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(LREF SysTime)'s time zone is $(LREF LocalTime), then TZ is empty.\n        If its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the\n        offset from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC\n        is $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7762_746)\n---\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               msecs(24)).toISOString() ==\n       \"19981225T021500.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               hnsecs(520_920)).toISOString() ==\n       \"-00040105T000002.052092\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7762_746)\n",
						"deco": "xFNbNfZAya",
						"endline": 7759,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 7851,
						"comment": "        Converts this $(LREF SysTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(LREF SysTime)'s time zone is $(LREF LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7892_748)\n---\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               msecs(24)).toISOExtString() ==\n       \"1998-12-25T02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               hnsecs(520_920)).toISOExtString() ==\n       \"-0004-01-05T00:00:02.052092\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7892_748)\n",
						"deco": "xFNbNfZAya",
						"endline": 7889,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toSimpleString",
						"line": 7985,
						"comment": "        Converts this $(LREF SysTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(LREF SysTime)'s time zone is $(LREF LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8026_750)\n---\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               msecs(24)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               hnsecs(520_920)).toSimpleString() ==\n        \"-0004-Jan-05 00:00:02.052092\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8026_750)\n",
						"deco": "xFNbNfZAya",
						"endline": 8023,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 8106,
						"comment": "        Converts this $(LREF SysTime) to a string.\n",
						"deco": "xFNbNfZAya",
						"endline": 8109,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 8152,
								"type": "@safe SysTime(in S isoString, immutable TimeZone tz = null)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "tz",
										"type": "TimeZone",
										"storageClass": [
											"immutable"
										],
										"default": "null"
									}
								],
								"endline": 8209,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 8152,
						"comment": "        Creates a $(LREF SysTime) from a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time\n        zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOString) except that\n        trailing zeroes are permitted - including having fractional seconds with\n        all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(LREF LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(LREF SysTime) to be a particular time\n        zone, pass in that time zone and the $(LREF SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n            tz        = The time zone to convert the given time to (no\n                        conversion occurs if null).\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF SysTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8212_753)\n---\nassert(SysTime.fromISOString(\"20100704T070612\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOString(\"19981225T021500.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(7)));\nassert(SysTime.fromISOString(\"00000105T230959.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), usecs(20)));\nassert(SysTime.fromISOString(\"-00040105T000002\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOString(\" 20100704T070612 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOString(\"20100704T070612Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOString(\"20100704T070612-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromISOString(\"20100704T070612+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(8))));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8212_753)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 8373,
								"type": "@safe SysTime(in S isoExtString, immutable TimeZone tz = null)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "tz",
										"type": "TimeZone",
										"storageClass": [
											"immutable"
										],
										"default": "null"
									}
								],
								"endline": 8432,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 8373,
						"comment": "        Creates a $(LREF SysTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOExtString)\n        except that trailing zeroes are permitted - including having fractional\n        seconds with all zeroes. However, a decimal point with nothing following\n        it is invalid.\n\n        If there is no time zone in the string, then $(LREF LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(LREF SysTime) to be a particular time\n        zone, pass in that time zone and the $(LREF SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for dates\n                           and times.\n            tz           = The time zone to convert the given time to (no\n                           conversion occurs if null).\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF SysTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8435_755)\n---\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOExtString(\"1998-12-25T02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(7)));\nassert(SysTime.fromISOExtString(\"0000-01-05T23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), usecs(20)));\nassert(SysTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(8))));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8435_755)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromSimpleString",
								"line": 8599,
								"type": "@safe SysTime(in S simpleString, immutable TimeZone tz = null)",
								"parameters": [
									{
										"name": "simpleString",
										"type": "S",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "tz",
										"type": "TimeZone",
										"storageClass": [
											"immutable"
										],
										"default": "null"
									}
								],
								"endline": 8658,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "fromSimpleString",
						"line": 8599,
						"comment": "        Creates a $(LREF SysTime) from a string with the format\n        YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toSimpleString) except\n        that trailing zeroes are permitted - including having fractional seconds\n        with all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(LREF LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(LREF SysTime) to be a particular time\n        zone, pass in that time zone and the $(LREF SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n\n        Params:\n            simpleString = A string formatted in the way that\n                           $(D toSimpleString) formats dates and times.\n            tz           = The time zone to convert the given time to (no\n                           conversion occurs if null).\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF SysTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8661_757)\n---\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromSimpleString(\"1998-Dec-25 02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), msecs(7)));\nassert(SysTime.fromSimpleString(\"0000-Jan-05 23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), usecs(20)));\nassert(SysTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new immutable SimpleTimeZone(dur!\"hours\"(8))));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8661_757)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 20,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 8799,
						"comment": "        Returns the $(LREF SysTime) farthest in the past which is representable\n        by $(LREF SysTime).\n\n        The $(LREF SysTime) which is returned is in UTC.\n",
						"deco": "FNaNbNdNfZS3std8datetime7SysTime",
						"endline": 8802,
						"char": 30,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 8817,
						"comment": "        Returns the $(LREF SysTime) farthest in the future which is representable\n        by $(LREF SysTime).\n\n        The $(LREF SysTime) which is returned is in UTC.\n",
						"deco": "FNaNbNdNfZS3std8datetime7SysTime",
						"endline": 8820,
						"char": 30,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Date",
				"line": 8881,
				"comment": "    Represents a date in the\n    $(WEB en.wikipedia.org/wiki/Proleptic_Gregorian_calendar, Proleptic Gregorian Calendar)\n    ranging from\n    32,768 B.C. to 32,767 A.D. Positive years are A.D. Non-positive years are\n    B.C.\n\n    Year, month, and day are kept separately internally so that $(D Date) is\n    optimized for calendar-based operations.\n\n    $(D Date) uses the Proleptic Gregorian Calendar, so it assumes the Gregorian\n    leap year calculations for its entire length. As per\n    $(WEB en.wikipedia.org/wiki/ISO_8601, ISO 8601), it treats 1 B.C. as\n    year 0, i.e. 1 B.C. is 0, 2 B.C. is -1, etc. Use $(LREF yearBC) to use B.C. as\n    a positive integer with 1 B.C. being the year prior to 1 A.D.\n\n    Year 0 is a leap year.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 8896,
						"comment": "        Throws:\n            $(LREF DateTimeException) if the resulting $(LREF Date) would not be valid.\n\n        Params:\n            year  = Year of the Gregorian Calendar. Positive values are A.D.\n                    Non-positive values are B.C. with year 0 being the year\n                    prior to 1 A.D.\n            month = Month of the year.\n            day   = Day of the month.\n",
						"deco": "FNaNcNfiiiZS3std8datetime4Date",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"deco": "i"
							},
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 8904,
						"originalType": "pure ref @safe (int year, int month, int day)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 8971,
						"comment": "        Params:\n            day = The Xth day of the Gregorian Calendar that the constructed\n                  $(LREF Date) will be for.\n",
						"deco": "FNaNbNcNfiZS3std8datetime4Date",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 9092,
						"originalType": "pure nothrow ref @safe (int day)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 9114,
						"comment": "        Compares this $(LREF Date) with the given $(LREF Date).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime4DateZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime4Date"
							}
						],
						"endline": 9132,
						"originalType": "const pure nothrow @safe int(in Date rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 9222,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9228_764)\n---\nassert(Date(1999, 7, 6).year == 1999);\nassert(Date(2010, 10, 4).year == 2010);\nassert(Date(-7, 4, 5).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9228_764)\n",
						"deco": "xFNaNbNdNfZs",
						"endline": 9225,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 9258,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this Date's year to.\n\n        Throws:\n            $(LREF DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9265_766)\n---\nassert(Date(1999, 7, 6).year == 1999);\nassert(Date(2010, 10, 4).year == 2010);\nassert(Date(-7, 4, 5).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9265_766)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 9262,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 9304,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(LREF DateTimeException) if $(D isAD) is true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9314_768)\n---\nassert(Date(0, 1, 1).yearBC == 1);\nassert(Date(-1, 1, 1).yearBC == 2);\nassert(Date(-100, 1, 1).yearBC == 101);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9314_768)\n",
						"deco": "xFNaNdNfZt",
						"endline": 9311,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 9343,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(LREF Date)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if a non-positive value is given.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9352_770)\n---\nauto date = Date(2010, 1, 1);\ndate.yearBC = 1;\nassert(date == Date(0, 1, 1));\n\ndate.yearBC = 10;\nassert(date == Date(-9, 1, 1));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9352_770)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 9349,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 9378,
						"comment": "        Month of a Gregorian Year.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9384_772)\n---\nassert(Date(1999, 7, 6).month == 7);\nassert(Date(2010, 10, 4).month == 10);\nassert(Date(-7, 4, 5).month == 4);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9384_772)\n",
						"deco": "xFNaNbNdNfZE3std8datetime5Month",
						"endline": 9381,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 9413,
						"comment": "        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(LREF Date)'s month to.\n\n        Throws:\n            $(LREF DateTimeException) if the given month is not a valid month or if\n            the current day would not be valid in the given month.\n",
						"deco": "FNaNdNfE3std8datetime5MonthZv",
						"parameters": [
							{
								"name": "month",
								"deco": "E3std8datetime5Month"
							}
						],
						"endline": 9418,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 9447,
						"comment": "        Day of a Gregorian Month.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9453_775)\n---\nassert(Date(1999, 7, 6).day == 6);\nassert(Date(2010, 10, 4).day == 4);\nassert(Date(-7, 4, 5).day == 5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9453_775)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 9450,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 9493,
						"comment": "        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(LREF Date)'s day to.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is not a valid day of the\n            current month.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 9497,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "add",
								"line": 9604,
								"type": "pure nothrow ref @safe Date(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 9623,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "add",
						"line": 9604,
						"comment": "        Adds the given number of years or months to this $(LREF Date). A negative\n        number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9626_778)\n---\nauto d1 = Date(2010, 1, 1);\nd1.add!\"months\"(11);\nassert(d1 == Date(2010, 12, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.add!\"months\"(-11);\nassert(d2 == Date(2009, 2, 1));\n\nauto d3 = Date(2000, 2, 29);\nd3.add!\"years\"(1);\nassert(d3 == Date(2001, 3, 1));\n\nauto d4 = Date(2000, 2, 29);\nd4.add!\"years\"(1, AllowDayOverflow.no);\nassert(d4 == Date(2001, 2, 28));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9626_778)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 10386,
								"type": "pure nothrow ref @safe Date(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 10390,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 10386,
						"comment": "        Adds the given number of years or months to this $(LREF Date). A negative\n        number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(LREF Date) 12 months gets\n        the exact same $(LREF Date). However, the days can still be affected due to\n        the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL10393_783)\n---\nauto d1 = Date(2010, 1, 1);\nd1.roll!\"months\"(1);\nassert(d1 == Date(2010, 2, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.roll!\"months\"(-1);\nassert(d2 == Date(2010, 12, 1));\n\nauto d3 = Date(1999, 1, 29);\nd3.roll!\"months\"(1);\nassert(d3 == Date(1999, 3, 1));\n\nauto d4 = Date(1999, 1, 29);\nd4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(d4 == Date(1999, 2, 28));\n\nauto d5 = Date(2000, 2, 29);\nd5.roll!\"years\"(1);\nassert(d5 == Date(2001, 3, 1));\n\nauto d6 = Date(2000, 2, 29);\nd6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(d6 == Date(2001, 2, 28));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL10393_783)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 11024,
								"type": "pure nothrow ref @safe Date(long days)",
								"parameters": [
									{
										"name": "days",
										"deco": "l"
									}
								],
								"endline": 11041,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 11024,
						"comment": "        Adds the given number of units to this $(LREF Date). A negative number will\n        subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF Date) one\n        year's worth of days gets the exact same $(LREF Date).\n\n        The only accepted units are $(D \"days\").\n\n        Params:\n            units = The units to add. Must be $(D \"days\").\n            days  = The number of days to add to this $(LREF Date).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11044_787)\n---\nauto d = Date(2010, 1, 1);\nd.roll!\"days\"(1);\nassert(d == Date(2010, 1, 2));\nd.roll!\"days\"(365);\nassert(d == Date(2010, 1, 26));\nd.roll!\"days\"(-32);\nassert(d == Date(2010, 1, 25));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11044_787)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"days\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 11261,
								"type": "const pure nothrow @safe Date(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 11276,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 11261,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF Date).\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(LREF Date).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 11361,
								"type": "pure nothrow ref @safe Date(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 11374,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 11361,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF Date), as well as assigning the result to this $(LREF Date).\n\n        The legal types of arithmetic for $(LREF Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(LREF Date).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 11443,
								"type": "const pure nothrow @safe Duration(in Date rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Date",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 11447,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 11443,
						"comment": "        Gives the difference between two $(LREF Date)s.\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD -) $(TD Date) $(TD -->) $(TD duration))\n        )\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "diffMonths",
						"line": 11497,
						"comment": "        Returns the difference between the two $(LREF Date)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(LREF SysTime)s. To get the difference in days or weeks,\n        subtract the $(LREF SysTime)s themselves and use the $(CXREF time, Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(CXREF time, Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either $(LREF Date) is is irrelevant. It is the difference in the month\n        property combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(LREF Date) to subtract from this one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11506_792)\n---\nassert(Date(1999, 2, 1).diffMonths(Date(1999, 1, 31)) == 1);\nassert(Date(1999, 1, 31).diffMonths(Date(1999, 2, 1)) == -1);\nassert(Date(1999, 3, 1).diffMonths(Date(1999, 1, 1)) == 2);\nassert(Date(1999, 1, 1).diffMonths(Date(1999, 3, 31)) == -2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11506_792)\n",
						"deco": "xFNaNbNfxS3std8datetime4DateZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime4Date"
							}
						],
						"endline": 11503,
						"originalType": "const pure nothrow @safe int(in Date rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isLeapYear",
						"line": 11735,
						"comment": "        Whether this $(LREF Date) is in a leap year.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 11738,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfWeek",
						"line": 11754,
						"comment": "        Day of the week this $(LREF Date) is on.\n",
						"deco": "xFNaNbNdNfZE3std8datetime9DayOfWeek",
						"endline": 11757,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 11773,
						"comment": "        Day of the year this $(LREF Date) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11786_796)\n---\nassert(Date(1999, 1, 1).dayOfYear == 1);\nassert(Date(1999, 12, 31).dayOfYear == 365);\nassert(Date(2000, 12, 31).dayOfYear == 366);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11786_796)\n",
						"deco": "xFNaNbNdNfZt",
						"endline": 11783,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 11834,
						"comment": "        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(LREF Date) is on.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is an invalid day of the\n            year.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 11851,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 11884,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF Date) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11938_801)\n---\nassert(Date(1, 1, 1).dayOfGregorianCal == 1);\nassert(Date(1, 12, 31).dayOfGregorianCal == 365);\nassert(Date(2, 1, 1).dayOfGregorianCal == 366);\n\nassert(Date(0, 12, 31).dayOfGregorianCal == 0);\nassert(Date(0, 1, 1).dayOfGregorianCal == -365);\nassert(Date(-1, 12, 31).dayOfGregorianCal == -366);\n\nassert(Date(2000, 1, 1).dayOfGregorianCal == 730_120);\nassert(Date(2010, 12, 31).dayOfGregorianCal == 734_137);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11938_801)\n",
						"deco": "xFNaNbNdNfZi",
						"endline": 11935,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 11973,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF Date) is on.\n\n        Params:\n            day = The day of the Gregorian Calendar to set this $(LREF Date) to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL11979_803)\n---\nauto date = Date.init;\ndate.dayOfGregorianCal = 1;\nassert(date == Date(1, 1, 1));\n\ndate.dayOfGregorianCal = 365;\nassert(date == Date(1, 12, 31));\n\ndate.dayOfGregorianCal = 366;\nassert(date == Date(2, 1, 1));\n\ndate.dayOfGregorianCal = 0;\nassert(date == Date(0, 12, 31));\n\ndate.dayOfGregorianCal = -365;\nassert(date == Date(-0, 1, 1));\n\ndate.dayOfGregorianCal = -366;\nassert(date == Date(-1, 12, 31));\n\ndate.dayOfGregorianCal = 730_120;\nassert(date == Date(2000, 1, 1));\n\ndate.dayOfGregorianCal = 734_137;\nassert(date == Date(2010, 12, 31));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL11979_803)\n",
						"deco": "FNaNbNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 11976,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isoWeek",
						"line": 12024,
						"comment": "        The ISO 8601 week of the year that this $(LREF Date) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 12056,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "endOfMonth",
						"line": 12123,
						"comment": "        $(LREF Date) for the last day in the month that this $(LREF Date) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12132_806)\n---\nassert(Date(1999, 1, 6).endOfMonth == Date(1999, 1, 31));\nassert(Date(1999, 2, 7).endOfMonth == Date(1999, 2, 28));\nassert(Date(2000, 2, 7).endOfMonth == Date(2000, 2, 29));\nassert(Date(2000, 6, 4).endOfMonth == Date(2000, 6, 30));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12132_806)\n",
						"deco": "xFNaNbNdNfZS3std8datetime4Date",
						"endline": 12129,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "daysInMonth",
						"line": 12182,
						"comment": "        The last day in the month that this $(LREF Date) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12188_808)\n---\nassert(Date(1999, 1, 6).daysInMonth == 31);\nassert(Date(1999, 2, 7).daysInMonth == 28);\nassert(Date(2000, 2, 7).daysInMonth == 29);\nassert(Date(2000, 6, 4).daysInMonth == 30);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12188_808)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 12185,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAD",
						"line": 12238,
						"comment": "        Whether the current year is a date in A.D.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12244_810)\n---\nassert(Date(1, 1, 1).isAD);\nassert(Date(2010, 12, 31).isAD);\nassert(!Date(0, 12, 31).isAD);\nassert(!Date(-2010, 1, 1).isAD);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12244_810)\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 12241,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "julianDay",
						"line": 12271,
						"comment": "        The $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for this $(LREF Date) at noon (since the Julian day changes\n        at noon).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 12274,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "modJulianDay",
						"line": 12298,
						"comment": "        The modified $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for any time on this date (since, the modified\n        Julian day changes at midnight).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 12301,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 12318,
						"comment": "        Converts this $(LREF Date) to a string with the format YYYYMMDD.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12340_814)\n---\nassert(Date(2010, 7, 4).toISOString() == \"20100704\");\nassert(Date(1998, 12, 25).toISOString() == \"19981225\");\nassert(Date(0, 1, 5).toISOString() == \"00000105\");\nassert(Date(-4, 1, 5).toISOString() == \"-00040105\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12340_814)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12337,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 12374,
						"comment": "        Converts this $(LREF Date) to a string with the format YYYY-MM-DD.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12396_816)\n---\nassert(Date(2010, 7, 4).toISOExtString() == \"2010-07-04\");\nassert(Date(1998, 12, 25).toISOExtString() == \"1998-12-25\");\nassert(Date(0, 1, 5).toISOExtString() == \"0000-01-05\");\nassert(Date(-4, 1, 5).toISOExtString() == \"-0004-01-05\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12396_816)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12393,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toSimpleString",
						"line": 12430,
						"comment": "        Converts this $(LREF Date) to a string with the format YYYY-Mon-DD.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12452_818)\n---\nassert(Date(2010, 7, 4).toSimpleString() == \"2010-Jul-04\");\nassert(Date(1998, 12, 25).toSimpleString() == \"1998-Dec-25\");\nassert(Date(0, 1, 5).toSimpleString() == \"0000-Jan-05\");\nassert(Date(-4, 1, 5).toSimpleString() == \"-0004-Jan-05\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12452_818)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12449,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 12487,
						"comment": "        Converts this $(LREF Date) to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 12490,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 12514,
								"type": "pure @safe Date(in S isoString)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 12545,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 12514,
						"comment": "        Creates a $(LREF Date) from a string with the format YYYYMMDD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF Date) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12548_821)\n---\nassert(Date.fromISOString(\"20100704\") == Date(2010, 7, 4));\nassert(Date.fromISOString(\"19981225\") == Date(1998, 12, 25));\nassert(Date.fromISOString(\"00000105\") == Date(0, 1, 5));\nassert(Date.fromISOString(\"-00040105\") == Date(-4, 1, 5));\nassert(Date.fromISOString(\" 20100704 \") == Date(2010, 7, 4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12548_821)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 12636,
								"type": "pure @safe Date(in S isoExtString)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 12672,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 12636,
						"comment": "        Creates a $(LREF Date) from a string with the format YYYY-MM-DD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for\n                           dates.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(LREF Date) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12675_823)\n---\nassert(Date.fromISOExtString(\"2010-07-04\") == Date(2010, 7, 4));\nassert(Date.fromISOExtString(\"1998-12-25\") == Date(1998, 12, 25));\nassert(Date.fromISOExtString(\"0000-01-05\") == Date(0, 1, 5));\nassert(Date.fromISOExtString(\"-0004-01-05\") == Date(-4, 1, 5));\nassert(Date.fromISOExtString(\" 2010-07-04 \") == Date(2010, 7, 4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12675_823)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromSimpleString",
								"line": 12763,
								"type": "pure @safe Date(in S simpleString)",
								"parameters": [
									{
										"name": "simpleString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 12796,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fromSimpleString",
						"line": 12763,
						"comment": "        Creates a $(LREF Date) from a string with the format YYYY-Mon-DD.\n        Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the correct\n            format or if the resulting $(LREF Date) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL12799_825)\n---\nassert(Date.fromSimpleString(\"2010-Jul-04\") == Date(2010, 7, 4));\nassert(Date.fromSimpleString(\"1998-Dec-25\") == Date(1998, 12, 25));\nassert(Date.fromSimpleString(\"0000-Jan-05\") == Date(0, 1, 5));\nassert(Date.fromSimpleString(\"-0004-Jan-05\") == Date(-4, 1, 5));\nassert(Date.fromSimpleString(\" 2010-Jul-04 \") == Date(2010, 7, 4));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL12799_825)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 17,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 12879,
						"comment": "        Returns the $(LREF Date) farthest in the past which is representable by\n        $(LREF Date).\n",
						"deco": "FNaNbNdNfZS3std8datetime4Date",
						"endline": 12887,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 12900,
						"comment": "        Returns the $(LREF Date) farthest in the future which is representable by\n        $(LREF Date).\n",
						"deco": "FNaNbNdNfZS3std8datetime4Date",
						"endline": 12908,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "TimeOfDay",
				"line": 13137,
				"comment": "    Represents a time of day with hours, minutes, and seconds. It uses 24 hour\n    time.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 13151,
						"comment": "        Params:\n            hour   = Hour of the day [0 - 24$(RPAREN).\n            minute = Minute of the hour [0 - 60$(RPAREN).\n            second = Second of the minute [0 - 60$(RPAREN).\n\n        Throws:\n            $(LREF DateTimeException) if the resulting $(LREF TimeOfDay) would be not\n            be valid.\n",
						"deco": "FNaNcNfiiiZS3std8datetime9TimeOfDay",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							},
							{
								"name": "minute",
								"deco": "i"
							},
							{
								"name": "second",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 13160,
						"originalType": "pure ref @safe (int hour, int minute, int second = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 13203,
						"comment": "        Compares this $(LREF TimeOfDay) with the given $(LREF TimeOfDay).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime9TimeOfDayZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime9TimeOfDay"
							}
						],
						"endline": 13221,
						"originalType": "const pure nothrow @safe int(in TimeOfDay rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 13263,
						"comment": "        Hours past midnight.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 13266,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 13290,
						"comment": "        Hours past midnight.\n\n        Params:\n            hour = The hour of the day to set this $(LREF TimeOfDay)'s hour to.\n\n        Throws:\n            $(LREF DateTimeException) if the given hour would result in an invalid\n            $(LREF TimeOfDay).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							}
						],
						"endline": 13294,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 13314,
						"comment": "        Minutes past the hour.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 13317,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 13341,
						"comment": "        Minutes past the hour.\n\n        Params:\n            minute = The minute to set this $(LREF TimeOfDay)'s minute to.\n\n        Throws:\n            $(LREF DateTimeException) if the given minute would result in an\n            invalid $(LREF TimeOfDay).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "minute",
								"deco": "i"
							}
						],
						"endline": 13345,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 13365,
						"comment": "        Seconds past the minute.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 13368,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 13392,
						"comment": "        Seconds past the minute.\n\n        Params:\n            second = The second to set this $(LREF TimeOfDay)'s second to.\n\n        Throws:\n            $(LREF DateTimeException) if the given second would result in an\n            invalid $(LREF TimeOfDay).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "second",
								"deco": "i"
							}
						],
						"endline": 13396,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 13429,
								"type": "pure nothrow ref @safe TimeOfDay(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 13433,
								"char": 19,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 13429,
						"comment": "        Adds the given number of units to this $(LREF TimeOfDay). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF TimeOfDay)\n        one hours's worth of minutes gets the exact same\n        $(LREF TimeOfDay).\n\n        Accepted units are $(D \"hours\"), $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this\n                    $(LREF TimeOfDay).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL13436_839)\n---\nauto tod1 = TimeOfDay(7, 12, 0);\ntod1.roll!\"hours\"(1);\nassert(tod1 == TimeOfDay(8, 12, 0));\n\nauto tod2 = TimeOfDay(7, 12, 0);\ntod2.roll!\"hours\"(-1);\nassert(tod2 == TimeOfDay(6, 12, 0));\n\nauto tod3 = TimeOfDay(23, 59, 0);\ntod3.roll!\"minutes\"(1);\nassert(tod3 == TimeOfDay(23, 0, 0));\n\nauto tod4 = TimeOfDay(0, 0, 0);\ntod4.roll!\"minutes\"(-1);\nassert(tod4 == TimeOfDay(0, 59, 0));\n\nauto tod5 = TimeOfDay(23, 59, 59);\ntod5.roll!\"seconds\"(1);\nassert(tod5 == TimeOfDay(23, 59, 0));\n\nauto tod6 = TimeOfDay(0, 0, 0);\ntod6.roll!\"seconds\"(-1);\nassert(tod6 == TimeOfDay(0, 0, 59));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL13436_839)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"hours\"",
						"char": 19,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 13672,
								"type": "const pure nothrow @safe TimeOfDay(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 13687,
								"char": 15,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 13672,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF TimeOfDay).\n\n        The legal types of arithmetic for $(LREF TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(LREF TimeOfDay).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 15,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 13766,
								"type": "pure nothrow ref @safe TimeOfDay(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 13778,
								"char": 19,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 13766,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF TimeOfDay), as well as assigning the result to this\n        $(LREF TimeOfDay).\n\n        The legal types of arithmetic for $(LREF TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(LREF TimeOfDay).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 19,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 13837,
								"type": "const pure nothrow @safe Duration(in TimeOfDay rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "TimeOfDay",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 13844,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 13837,
						"comment": "        Gives the difference between two $(LREF TimeOfDay)s.\n\n        The legal types of arithmetic for $(LREF TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD -) $(TD TimeOfDay) $(TD -->) $(TD duration))\n        )\n\n        Params:\n            rhs = The $(LREF TimeOfDay) to subtract from this one.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 13878,
						"comment": "        Converts this $(LREF TimeOfDay) to a string with the format HHMMSS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL13888_846)\n---\nassert(TimeOfDay(0, 0, 0).toISOString() == \"000000\");\nassert(TimeOfDay(12, 30, 33).toISOString() == \"123033\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL13888_846)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 13885,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 13908,
						"comment": "        Converts this $(LREF TimeOfDay) to a string with the format HH:MM:SS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL13918_848)\n---\nassert(TimeOfDay(0, 0, 0).toISOExtString() == \"00:00:00\");\nassert(TimeOfDay(12, 30, 33).toISOExtString() == \"12:30:33\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL13918_848)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 13915,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 13938,
						"comment": "        Converts this TimeOfDay to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 13941,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 13965,
								"type": "pure @safe TimeOfDay(in S isoString)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 13987,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 13965,
						"comment": "        Creates a $(LREF TimeOfDay) from a string with the format HHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF TimeOfDay) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL13990_851)\n---\nassert(TimeOfDay.fromISOString(\"000000\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOString(\"123033\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOString(\" 123033 \") == TimeOfDay(12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL13990_851)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 22,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 14073,
								"type": "pure @safe TimeOfDay(in S isoExtString)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 14100,
								"char": 22,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 14073,
						"comment": "        Creates a $(LREF TimeOfDay) from a string with the format HH:MM:SS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(LREF TimeOfDay) would not be\n            valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14103_853)\n---\nassert(TimeOfDay.fromISOExtString(\"00:00:00\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOExtString(\"12:30:33\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOExtString(\" 12:30:33 \") == TimeOfDay(12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14103_853)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 22,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 14177,
						"comment": "        Returns midnight.\n",
						"deco": "FNaNbNdNfZS3std8datetime9TimeOfDay",
						"endline": 14180,
						"char": 32,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 14194,
						"comment": "        Returns one second short of midnight.\n",
						"deco": "FNaNbNdNfZS3std8datetime9TimeOfDay",
						"endline": 14202,
						"char": 32,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "DateTime",
				"line": 14360,
				"comment": "   Combines the $(LREF Date) and $(LREF TimeOfDay) structs to give an object\n   which holds both the date and the time. It is optimized for calendar-based\n   operations and has no concept of time zone. For an object which is\n   optimized for time operations based on the system time, use\n   $(LREF SysTime). $(LREF SysTime) has a concept of time zone and has much higher\n   precision (hnsecs). $(D DateTime) is intended primarily for calendar-based\n   uses rather than precise time operations.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 14369,
						"comment": "        Params:\n            date = The date portion of $(LREF DateTime).\n            tod  = The time portion of $(LREF DateTime).\n",
						"deco": "FNaNbNcNfxS3std8datetime4DatexS3std8datetime9TimeOfDayZS3std8datetime8DateTime",
						"parameters": [
							{
								"name": "date",
								"deco": "xS3std8datetime4Date"
							},
							{
								"name": "tod",
								"deco": "xS3std8datetime9TimeOfDay",
								"default": "TimeOfDay(cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u)"
							}
						],
						"endline": 14373,
						"originalType": "pure nothrow ref @safe (in Date date, in TimeOfDay tod = TimeOfDay.init)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 14406,
						"comment": "        Params:\n            year   = The year portion of the date.\n            month  = The month portion of the date.\n            day    = The day portion of the date.\n            hour   = The hour portion of the time;\n            minute = The minute portion of the time;\n            second = The second portion of the time;\n",
						"deco": "FNaNcNfiiiiiiZS3std8datetime8DateTime",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"deco": "i"
							},
							{
								"name": "day",
								"deco": "i"
							},
							{
								"name": "hour",
								"deco": "i",
								"default": "0"
							},
							{
								"name": "minute",
								"deco": "i",
								"default": "0"
							},
							{
								"name": "second",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 14410,
						"originalType": "pure ref @safe (int year, int month, int day, int hour = 0, int minute = 0, int second = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 14438,
						"comment": "        Compares this $(LREF DateTime) with the given $(D DateTime.).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n",
						"deco": "xFNaNbNfxS3std8datetime8DateTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime8DateTime"
							}
						],
						"endline": 14446,
						"originalType": "const pure nothrow @safe int(in DateTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "date",
						"line": 14648,
						"comment": "        The date portion of $(LREF DateTime).\n",
						"deco": "xFNaNbNdNfZS3std8datetime4Date",
						"endline": 14651,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "date",
						"line": 14678,
						"comment": "        The date portion of $(LREF DateTime).\n\n        Params:\n            date = The Date to set this $(LREF DateTime)'s date portion to.\n",
						"deco": "FNaNbNdNfxS3std8datetime4DateZv",
						"parameters": [
							{
								"name": "date",
								"deco": "xS3std8datetime4Date"
							}
						],
						"endline": 14681,
						"originalType": "pure nothrow @property @safe void(in Date date)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timeOfDay",
						"line": 14700,
						"comment": "        The time portion of $(LREF DateTime).\n",
						"deco": "xFNaNbNdNfZS3std8datetime9TimeOfDay",
						"endline": 14703,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "timeOfDay",
						"line": 14731,
						"comment": "        The time portion of $(LREF DateTime).\n\n        Params:\n            tod = The $(LREF TimeOfDay) to set this $(LREF DateTime)'s time portion\n                  to.\n",
						"deco": "FNaNbNdNfxS3std8datetime9TimeOfDayZv",
						"parameters": [
							{
								"name": "tod",
								"deco": "xS3std8datetime9TimeOfDay"
							}
						],
						"endline": 14734,
						"originalType": "pure nothrow @property @safe void(in TimeOfDay tod)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 14754,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n",
						"deco": "xFNaNbNdNfZs",
						"endline": 14757,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "year",
						"line": 14783,
						"comment": "        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(LREF DateTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if the new year is not a leap year and if the\n            resulting date would be on February 29th.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14789_867)\n---\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).year == 1999);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).year == 2010);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).year == -7);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14789_867)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 14786,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 14821,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(LREF DateTimeException) if $(D isAD) is true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14827_869)\n---\nassert(DateTime(Date(0, 1, 1), TimeOfDay(12, 30, 33)).yearBC == 1);\nassert(DateTime(Date(-1, 1, 1), TimeOfDay(10, 7, 2)).yearBC == 2);\nassert(DateTime(Date(-100, 1, 1), TimeOfDay(4, 59, 0)).yearBC == 101);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14827_869)\n",
						"deco": "xFNaNdNfZs",
						"endline": 14824,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "yearBC",
						"line": 14856,
						"comment": "        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(LREF DateTime)'s year to.\n\n        Throws:\n            $(LREF DateTimeException) if a non-positive value is given.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14862_871)\n---\nauto dt = DateTime(Date(2010, 1, 1), TimeOfDay(7, 30, 0));\ndt.yearBC = 1;\nassert(dt == DateTime(Date(0, 1, 1), TimeOfDay(7, 30, 0)));\n\ndt.yearBC = 10;\nassert(dt == DateTime(Date(-9, 1, 1), TimeOfDay(7, 30, 0)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14862_871)\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							}
						],
						"endline": 14859,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 14888,
						"comment": "        Month of a Gregorian Year.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14894_873)\n---\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).month == 7);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).month == 10);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).month == 4);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14894_873)\n",
						"deco": "xFNaNbNdNfZE3std8datetime5Month",
						"endline": 14891,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "month",
						"line": 14923,
						"comment": "        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(LREF DateTime)'s month to.\n\n        Throws:\n            $(LREF DateTimeException) if the given month is not a valid month.\n",
						"deco": "FNaNdNfE3std8datetime5MonthZv",
						"parameters": [
							{
								"name": "month",
								"deco": "E3std8datetime5Month"
							}
						],
						"endline": 14926,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 14953,
						"comment": "        Day of a Gregorian Month.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL14959_876)\n---\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).day == 6);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).day == 4);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).day == 5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL14959_876)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 14956,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "day",
						"line": 15002,
						"comment": "        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(LREF DateTime)'s day to.\n\n        Throws:\n            $(LREF DateTimeException) if the given day is not a valid day of the\n            current month.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 15005,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 15094,
						"comment": "        Hours past midnight.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 15097,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hour",
						"line": 15121,
						"comment": "        Hours past midnight.\n\n        Params:\n            hour = The hour of the day to set this $(LREF DateTime)'s hour to.\n\n        Throws:\n            $(LREF DateTimeException) if the given hour would result in an invalid\n            $(LREF DateTime).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "hour",
								"deco": "i"
							}
						],
						"endline": 15124,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 15144,
						"comment": "        Minutes past the hour.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 15147,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "minute",
						"line": 15171,
						"comment": "        Minutes past the hour.\n\n        Params:\n            minute = The minute to set this $(LREF DateTime)'s minute to.\n\n        Throws:\n            $(LREF DateTimeException) if the given minute would result in an\n            invalid $(LREF DateTime).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "minute",
								"deco": "i"
							}
						],
						"endline": 15174,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 15194,
						"comment": "        Seconds past the minute.\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 15197,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "second",
						"line": 15221,
						"comment": "        Seconds past the minute.\n\n        Params:\n            second = The second to set this $(LREF DateTime)'s second to.\n\n        Throws:\n            $(LREF DateTimeException) if the given seconds would result in an\n            invalid $(LREF DateTime).\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "second",
								"deco": "i"
							}
						],
						"endline": 15224,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "add",
								"line": 15260,
								"type": "pure nothrow ref @safe DateTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 15267,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "add",
						"line": 15260,
						"comment": "        Adds the given number of years or months to this $(LREF DateTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15270_885)\n---\nauto dt1 = DateTime(2010, 1, 1, 12, 30, 33);\ndt1.add!\"months\"(11);\nassert(dt1 == DateTime(2010, 12, 1, 12, 30, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 30, 33);\ndt2.add!\"months\"(-11);\nassert(dt2 == DateTime(2009, 2, 1, 12, 30, 33));\n\nauto dt3 = DateTime(2000, 2, 29, 12, 30, 33);\ndt3.add!\"years\"(1);\nassert(dt3 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt4 = DateTime(2000, 2, 29, 12, 30, 33);\ndt4.add!\"years\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(2001, 2, 28, 12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15270_885)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\" || units == \"months\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 15323,
								"type": "pure nothrow ref @safe DateTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									},
									{
										"name": "allowOverflow",
										"type": "AllowDayOverflow",
										"default": "AllowDayOverflow.yes"
									}
								],
								"endline": 15330,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 15323,
						"comment": "        Adds the given number of years or months to this $(LREF DateTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(LREF DateTime) 12 months\n        gets the exact same $(LREF DateTime). However, the days can still be\n        affected due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(LREF DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15333_887)\n---\nauto dt1 = DateTime(2010, 1, 1, 12, 33, 33);\ndt1.roll!\"months\"(1);\nassert(dt1 == DateTime(2010, 2, 1, 12, 33, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 33, 33);\ndt2.roll!\"months\"(-1);\nassert(dt2 == DateTime(2010, 12, 1, 12, 33, 33));\n\nauto dt3 = DateTime(1999, 1, 29, 12, 33, 33);\ndt3.roll!\"months\"(1);\nassert(dt3 == DateTime(1999, 3, 1, 12, 33, 33));\n\nauto dt4 = DateTime(1999, 1, 29, 12, 33, 33);\ndt4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(1999, 2, 28, 12, 33, 33));\n\nauto dt5 = DateTime(2000, 2, 29, 12, 30, 33);\ndt5.roll!\"years\"(1);\nassert(dt5 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt6 = DateTime(2000, 2, 29, 12, 30, 33);\ndt6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(dt6 == DateTime(2001, 2, 28, 12, 30, 33));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15333_887)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"years\" || units == \"months\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "roll",
								"line": 15390,
								"type": "pure nothrow ref @safe DateTime(long value)",
								"parameters": [
									{
										"name": "value",
										"deco": "l"
									}
								],
								"endline": 15395,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "roll",
						"line": 15390,
						"comment": "        Adds the given number of units to this $(LREF DateTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(LREF DateTime) one\n        year's worth of days gets the exact same $(LREF DateTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(LREF DateTime).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL15398_889)\n---\nauto dt1 = DateTime(2010, 1, 1, 11, 23, 12);\ndt1.roll!\"days\"(1);\nassert(dt1 == DateTime(2010, 1, 2, 11, 23, 12));\ndt1.roll!\"days\"(365);\nassert(dt1 == DateTime(2010, 1, 26, 11, 23, 12));\ndt1.roll!\"days\"(-32);\nassert(dt1 == DateTime(2010, 1, 25, 11, 23, 12));\n\nauto dt2 = DateTime(2010, 7, 4, 12, 0, 0);\ndt2.roll!\"hours\"(1);\nassert(dt2 == DateTime(2010, 7, 4, 13, 0, 0));\n\nauto dt3 = DateTime(2010, 1, 1, 0, 0, 0);\ndt3.roll!\"seconds\"(-1);\nassert(dt3 == DateTime(2010, 1, 1, 0, 0, 59));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL15398_889)\n",
						"parameters": [
							{
								"name": "units",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "units == \"days\"",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 15949,
								"type": "const pure nothrow @safe DateTime(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 15964,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 15949,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF DateTime).\n\n        The legal types of arithmetic for $(LREF DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(LREF DateTime).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 16047,
								"type": "pure nothrow ref @safe DateTime(in D duration)",
								"parameters": [
									{
										"name": "duration",
										"type": "D",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 16062,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 16047,
						"comment": "        Gives the result of adding or subtracting a duration from this\n        $(LREF DateTime), as well as assigning the result to this $(LREF DateTime).\n\n        The legal types of arithmetic for $(LREF DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(LREF DateTime).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "D",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\") && (is(Unqual!D == Duration) || is(Unqual!D == TickDuration))",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 16125,
								"type": "const pure nothrow @safe Duration(in DateTime rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "DateTime",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 16132,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 16125,
						"comment": "        Gives the difference between two $(LREF DateTime)s.\n\n        The legal types of arithmetic for $(LREF DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD -) $(TD DateTime) $(TD -->) $(TD duration))\n        )\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "diffMonths",
						"line": 16222,
						"comment": "        Returns the difference between the two $(LREF DateTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(LREF SysTime)s. To get the difference in days or weeks,\n        subtract the $(LREF SysTime)s themselves and use the $(CXREF time, Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(CXREF time, Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(LREF DateTime) to subtract from this one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16228_897)\n---\nassert(DateTime(1999, 2, 1, 12, 2, 3).diffMonths(\n            DateTime(1999, 1, 31, 23, 59, 59)) == 1);\n\nassert(DateTime(1999, 1, 31, 0, 0, 0).diffMonths(\n            DateTime(1999, 2, 1, 12, 3, 42)) == -1);\n\nassert(DateTime(1999, 3, 1, 5, 30, 0).diffMonths(\n            DateTime(1999, 1, 1, 2, 4, 7)) == 2);\n\nassert(DateTime(1999, 1, 1, 7, 2, 4).diffMonths(\n            DateTime(1999, 3, 31, 0, 30, 58)) == -2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16228_897)\n",
						"deco": "xFNaNbNfxS3std8datetime8DateTimeZi",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime8DateTime"
							}
						],
						"endline": 16225,
						"originalType": "const pure nothrow @safe int(in DateTime rhs)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isLeapYear",
						"line": 16265,
						"comment": "        Whether this $(LREF DateTime) is in a leap year.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 16268,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfWeek",
						"line": 16284,
						"comment": "        Day of the week this $(LREF DateTime) is on.\n",
						"deco": "xFNaNbNdNfZE3std8datetime9DayOfWeek",
						"endline": 16287,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 16303,
						"comment": "        Day of the year this $(LREF DateTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16309_901)\n---\nassert(DateTime(Date(1999, 1, 1), TimeOfDay(12, 22, 7)).dayOfYear == 1);\nassert(DateTime(Date(1999, 12, 31), TimeOfDay(7, 2, 59)).dayOfYear == 365);\nassert(DateTime(Date(2000, 12, 31), TimeOfDay(21, 20, 0)).dayOfYear == 366);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16309_901)\n",
						"deco": "xFNaNbNdNfZt",
						"endline": 16306,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfYear",
						"line": 16334,
						"comment": "        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(LREF DateTime) is on.\n",
						"deco": "FNaNdNfiZv",
						"parameters": [
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 16337,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 16353,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF DateTime) is on.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16359_904)\n---\nassert(DateTime(Date(1, 1, 1), TimeOfDay(0, 0, 0)).dayOfGregorianCal == 1);\nassert(DateTime(Date(1, 12, 31), TimeOfDay(23, 59, 59)).dayOfGregorianCal == 365);\nassert(DateTime(Date(2, 1, 1), TimeOfDay(2, 2, 2)).dayOfGregorianCal == 366);\n\nassert(DateTime(Date(0, 12, 31), TimeOfDay(7, 7, 7)).dayOfGregorianCal == 0);\nassert(DateTime(Date(0, 1, 1), TimeOfDay(19, 30, 0)).dayOfGregorianCal == -365);\nassert(DateTime(Date(-1, 12, 31), TimeOfDay(4, 7, 0)).dayOfGregorianCal == -366);\n\nassert(DateTime(Date(2000, 1, 1), TimeOfDay(9, 30, 20)).dayOfGregorianCal == 730_120);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(15, 45, 50)).dayOfGregorianCal == 734_137);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16359_904)\n",
						"deco": "xFNaNbNdNfZi",
						"endline": 16356,
						"char": 19,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dayOfGregorianCal",
						"line": 16391,
						"comment": "        The Xth day of the Gregorian Calendar that this $(LREF DateTime) is on.\n        Setting this property does not affect the time portion of\n        $(LREF DateTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(LREF DateTime)\n                   to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16397_906)\n---\nauto dt = DateTime(Date.init, TimeOfDay(12, 0, 0));\ndt.dayOfGregorianCal = 1;\nassert(dt == DateTime(Date(1, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 365;\nassert(dt == DateTime(Date(1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 366;\nassert(dt == DateTime(Date(2, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 0;\nassert(dt == DateTime(Date(0, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -365;\nassert(dt == DateTime(Date(-0, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -366;\nassert(dt == DateTime(Date(-1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 730_120;\nassert(dt == DateTime(Date(2000, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 734_137;\nassert(dt == DateTime(Date(2010, 12, 31), TimeOfDay(12, 0, 0)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16397_906)\n",
						"deco": "FNaNbNdNfiZv",
						"parameters": [
							{
								"name": "days",
								"deco": "i"
							}
						],
						"endline": 16394,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isoWeek",
						"line": 16440,
						"comment": "        The ISO 8601 week of the year that this $(LREF DateTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 16443,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "endOfMonth",
						"line": 16460,
						"comment": "        $(LREF DateTime) for the last day in the month that this $(LREF DateTime) is\n        in. The time portion of endOfMonth is always 23:59:59.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16469_909)\n---\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).endOfMonth ==\n       DateTime(Date(1999, 1, 31), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).endOfMonth ==\n       DateTime(Date(1999, 2, 28), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).endOfMonth ==\n       DateTime(Date(2000, 2, 29), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).endOfMonth ==\n       DateTime(Date(2000, 6, 30), TimeOfDay(23, 59, 59)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16469_909)\n",
						"deco": "xFNaNbNdNfZS3std8datetime8DateTime",
						"endline": 16466,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "daysInMonth",
						"line": 16526,
						"comment": "        The last day in the month that this $(LREF DateTime) is in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16532_911)\n---\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).daysInMonth == 31);\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).daysInMonth == 28);\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).daysInMonth == 29);\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).daysInMonth == 30);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16532_911)\n",
						"deco": "xFNaNbNdNfZh",
						"endline": 16529,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAD",
						"line": 16552,
						"comment": "        Whether the current year is a date in A.D.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16558_913)\n---\nassert(DateTime(Date(1, 1, 1), TimeOfDay(12, 7, 0)).isAD);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(0, 0, 0)).isAD);\nassert(!DateTime(Date(0, 12, 31), TimeOfDay(23, 59, 59)).isAD);\nassert(!DateTime(Date(-2010, 1, 1), TimeOfDay(2, 2, 2)).isAD);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16558_913)\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 16555,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "julianDay",
						"line": 16582,
						"comment": "        The $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for this\n        $(LREF DateTime) at the given time. For example, prior to noon,\n        1996-03-31 would be the Julian day number 2_450_173, so this function\n        returns 2_450_173, while from noon onward, the julian day number would\n        be 2_450_174, so this function returns 2_450_174.\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 16588,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "modJulianDay",
						"line": 16627,
						"comment": "        The modified $(WEB en.wikipedia.org/wiki/Julian_day, Julian day) for any\n        time on this date (since, the modified Julian day changes at midnight).\n",
						"deco": "xFNaNbNdNfZl",
						"endline": 16630,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOString",
						"line": 16650,
						"comment": "        Converts this $(LREF DateTime) to a string with the format YYYYMMDDTHHMMSS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16660_917)\n---\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOString() ==\n       \"19981225T021500\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOString() ==\n       \"-00040105T000002\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16660_917)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 16657,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toISOExtString",
						"line": 16703,
						"comment": "        Converts this $(LREF DateTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16713_919)\n---\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOExtString() ==\n       \"1998-12-25T02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOExtString() ==\n       \"-0004-01-05T00:00:02\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16713_919)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 16710,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toSimpleString",
						"line": 16755,
						"comment": "        Converts this $(LREF DateTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16765_921)\n---\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toSimpleString() ==\n       \"-0004-Jan-05 00:00:02\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16765_921)\n",
						"deco": "xFNaNbNfZAya",
						"endline": 16762,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 16807,
						"comment": "        Converts this $(LREF DateTime) to a string.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 16810,
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOString",
								"line": 16835,
								"type": "pure @safe DateTime(in S isoString)",
								"parameters": [
									{
										"name": "isoString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 16854,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "fromISOString",
						"line": 16835,
						"comment": "        Creates a $(LREF DateTime) from a string with the format YYYYMMDDTHHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(LREF DateTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16857_924)\n---\nassert(DateTime.fromISOString(\"20100704T070612\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOString(\"19981225T021500\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOString(\"00000105T230959\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOString(\"-00040105T000002\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOString(\" 20100704T070612 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16857_924)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 21,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromISOExtString",
								"line": 16923,
								"type": "pure @safe DateTime(in S isoExtString)",
								"parameters": [
									{
										"name": "isoExtString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 16942,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "fromISOExtString",
						"line": 16923,
						"comment": "        Creates a $(LREF DateTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for dates\n                           and times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(LREF DateTime) would not be\n            valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL16945_926)\n---\nassert(DateTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOExtString(\"1998-12-25T02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOExtString(\"0000-01-05T23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL16945_926)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 21,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fromSimpleString",
								"line": 17009,
								"type": "pure @safe DateTime(in S simpleString)",
								"parameters": [
									{
										"name": "simpleString",
										"type": "S",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17028,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "fromSimpleString",
						"line": 17009,
						"comment": "        Creates a $(LREF DateTime) from a string with the format\n        YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates and times.\n\n        Throws:\n            $(LREF DateTimeException) if the given string is not in the correct\n            format or if the resulting $(LREF DateTime) would not be valid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL17031_928)\n---\nassert(DateTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\nassert(DateTime.fromSimpleString(\"1998-Dec-25 02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\nassert(DateTime.fromSimpleString(\"0000-Jan-05 23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\nassert(DateTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\nassert(DateTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL17031_928)\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 21,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "min",
						"line": 17084,
						"comment": "        Returns the $(LREF DateTime) farthest in the past which is representable by\n        $(LREF DateTime).\n",
						"deco": "FNaNbNdNfZS3std8datetime8DateTime",
						"endline": 17098,
						"char": 31,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 17111,
						"comment": "        Returns the $(LREF DateTime) farthest in the future which is representable\n        by $(LREF DateTime).\n",
						"deco": "FNaNbNdNfZS3std8datetime8DateTime",
						"endline": 17128,
						"char": 31,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "Interval",
						"line": 17373,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 17391,
										"type": "pure (in TP begin, in U end)",
										"parameters": [
											{
												"name": "begin",
												"type": "TP",
												"storageClass": [
													"in"
												]
											},
											{
												"name": "end",
												"type": "U",
												"storageClass": [
													"in"
												]
											}
										],
										"endline": 17399,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 17391,
								"comment": "        Params:\n            begin = The time point which begins the interval.\n            end   = The time point which ends (but is not included in) the\n                    interval.\n\n        Throws:\n            $(LREF DateTimeException) if $(D_PARAM end) is before $(D_PARAM begin).\n\n        Examples:\n--------------------\nInterval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n--------------------\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(Unqual!TP == Unqual!U)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 17417,
										"type": "pure (in TP begin, in D duration)",
										"parameters": [
											{
												"name": "begin",
												"type": "TP",
												"storageClass": [
													"in"
												]
											},
											{
												"name": "duration",
												"type": "D",
												"storageClass": [
													"in"
												]
											}
										],
										"endline": 17425,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 17417,
								"comment": "        Params:\n            begin    = The time point which begins the interval.\n            duration = The duration from the starting point to the end point.\n\n        Throws:\n            $(LREF DateTimeException) if the resulting $(D end) is before\n            $(D begin).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), dur!\"years\"(3)) ==\n       Interval!Date(Date(1996, 1, 2), Date(1999, 1, 2)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 17432,
								"comment": "        Params:\n            rhs = The $(LREF2 .Interval, Interval) to assign to this one.\n",
								"type": "pure nothrow ref Interval(ref const Interval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Interval",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 17437,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 17444,
								"comment": "        Params:\n            rhs = The $(LREF2 .Interval, Interval) to assign to this one.\n",
								"type": "pure nothrow ref Interval(Interval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Interval"
									}
								],
								"endline": 17449,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 17461,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).begin ==\n       Date(1996, 1, 2));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 17464,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 17476,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n\n        Throws:\n            $(LREF DateTimeException) if the resulting interval would be invalid.\n",
								"type": "pure @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 17482,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 17494,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).end ==\n       Date(2012, 3, 1));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 17497,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 17509,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n\n        Throws:\n            $(LREF DateTimeException) if the resulting interval would be invalid.\n",
								"type": "pure @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 17515,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 17527,
								"comment": "        Returns the duration between $(D begin) and $(D end).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).length ==\n       dur!\"days\"(5903));\n--------------------\n",
								"type": "const pure nothrow @property ()",
								"endline": 17530,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 17542,
								"comment": "        Whether the interval's length is 0, that is, whether $(D begin == end).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(1996, 1, 2)).empty);\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).empty);\n--------------------\n",
								"type": "const pure nothrow @property bool()",
								"endline": 17545,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 17568,
								"comment": "        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(1994, 12, 24)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2000, 1, 5)));\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17573,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 17597,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17605,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 17627,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval going to positive infinity can never be contained in a finite\n        interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17632,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 17654,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval beginning at negative infinity can never be contained in a\n        finite interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17659,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 17684,
								"comment": "        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2000, 1, 5)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17689,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 17714,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17720,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 17742,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17747,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 17769,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be before an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17774,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 17799,
								"comment": "        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2000, 1, 5)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17804,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 17829,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17835,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 17857,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be after an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17862,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 17881,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17886,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 17910,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17916,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 17937,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17942,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 17963,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 17968,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 17992,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n",
								"type": "const Interval(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18002,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 18026,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18033,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 18057,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18064,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 18089,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18095,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 18117,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18122,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 18144,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18149,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 18173,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n",
								"type": "const Interval(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18184,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 18208,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(2012, 3, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const PosInfInterval!TP(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18216,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 18240,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are not\n            adjacent or if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1996, 1, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const NegInfInterval!TP(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18248,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 18273,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(1991, 1, 8))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n",
								"type": "const pure Interval(in Interval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18282,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 18307,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(2050, 1, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure PosInfInterval!TP(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18312,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 18337,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1602, 5, 21))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const pure NegInfInterval!TP(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 18342,
								"char": 23,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "shift",
										"line": 18370,
										"type": "pure void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 18383,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "shift",
								"line": 18370,
								"comment": "        Shifts the interval forward or backwards in time by the given duration\n        (a positive duration shifts the interval forward; a negative duration\n        shifts it backward). Effectively, it does $(D begin += duration) and\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Throws:\n            $(LREF DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expand",
										"line": 18467,
										"type": "pure void(D duration, Direction dir = Direction.both)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											},
											{
												"name": "dir",
												"type": "Direction",
												"default": "Direction.both"
											}
										],
										"endline": 18510,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expand",
								"line": 18467,
								"comment": "        Expands the interval forwards and/or backwards in time. Effectively,\n        it does $(D begin -= duration) and/or $(D end += duration). Whether\n        it expands forwards and/or backwards in time is determined by\n        $(D_PARAM dir).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Throws:\n            $(LREF DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n\ninterval1.expand(2);\nassert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));\n\ninterval2.expand(-2);\nassert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "fwdRange",
								"line": 18679,
								"comment": "        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(LREF DateTimeException) will be\n        thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or beyond the $(D end)\n        of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant if when creating a custom delegate.\n\n        Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n",
								"type": "const IntervalRange!(TP, Direction.fwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 18689,
								"char": 39,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "bwdRange",
								"line": 18772,
								"comment": "        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(LREF DateTimeException) will\n        be thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or less than the\n        $(D begin) of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\n//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\nassert(range.front == Date(2010, 9, 9));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n",
								"type": "const IntervalRange!(TP, Direction.bwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 18782,
								"char": 39,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 18803,
								"comment": "        Converts this interval to a string.\n",
								"type": "const nothrow string()",
								"endline": 18806,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Interval",
				"line": 17373,
				"comment": "    Represents an interval of time.\n\n    An $(D Interval) has a starting point and an end point. The interval of time\n    is therefore the time starting at the starting point up to, but not\n    including, the end point. e.g.\n\n    $(BOOKTABLE,\n    $(TR $(TD [January 5th, 2010 - March 10th, 2010$(RPAREN)))\n    $(TR $(TD [05:00:30 - 12:00:00$(RPAREN)))\n    $(TR $(TD [1982-01-04T08:59:00 - 2010-07-04T12:00:00$(RPAREN)))\n    )\n\n    A range can be obtained from an $(D Interval), allowing iteration over\n    that interval, with the exact time points which are iterated over depending\n    on the function which generates the range.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "PosInfInterval",
						"line": 20284,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 20297,
								"comment": "        Params:\n            begin = The time point which begins the interval.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n",
								"type": "pure nothrow (in TP begin)",
								"parameters": [
									{
										"name": "begin",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20300,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 20307,
								"comment": "        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref PosInfInterval(ref const PosInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfInterval",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 20311,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 20318,
								"comment": "        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref PosInfInterval(PosInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfInterval"
									}
								],
								"endline": 20322,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 20333,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).begin == Date(1996, 1, 2));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 20336,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "begin",
								"line": 20345,
								"comment": "        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n",
								"type": "pure nothrow @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 20348,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 20359,
								"comment": "        Whether the interval's length is 0. Always returns false.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n",
								"type": "const pure nothrow @property bool()",
								"endline": 20362,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20377,
								"comment": "        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(1994, 12, 24)));\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(2000, 1, 5)));\n--------------------\n",
								"type": "const pure nothrow bool(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 20380,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20404,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20409,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20427,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1995, 7, 2))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20430,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 20448,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval going to positive infinity\n        can never contain an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20451,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 20470,
								"comment": "        Whether this interval is before the given time point.\n\n        Always returns false because an interval going to positive infinity\n        can never be before any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(2000, 1, 5)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20473,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 20499,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval going to positive infinity can never be before any other\n        interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20504,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 20526,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(1992, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20529,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 20548,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20551,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 20567,
								"comment": "        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(2000, 1, 5)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20570,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 20595,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20600,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 20622,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval going to positive infinity can\n        never be after another interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20625,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 20644,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20647,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 20671,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20676,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 20698,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals going to positive infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20701,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 20720,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20723,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 20747,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n",
								"type": "const Interval!TP(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20756,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 20776,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1999, 1 , 12)));\n--------------------\n",
								"type": "const pure nothrow PosInfInterval(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20779,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 20802,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 1, 12)));\n--------------------\n",
								"type": "const Interval!TP(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20809,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 20831,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1999, 1, 12)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20836,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 20858,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals going to positive infinity\n        can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20861,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 20880,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20883,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 20913,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const PosInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20921,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 20947,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure nothrow PosInfInterval(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20950,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 20986,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(500, 8, 9), Date(1602, 1, 31))) ==\n       PosInfInterval!Date(Date(500, 8, 9)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure PosInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 20991,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 21020,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n",
								"type": "const pure nothrow PosInfInterval(in PosInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 21023,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "shift",
										"line": 21047,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 21051,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "shift",
								"line": 21047,
								"comment": "        Shifts the $(D begin) of this interval forward or backwards in time by\n        the given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D begin += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expand",
										"line": 21120,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 21124,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expand",
								"line": 21120,
								"comment": "        Expands the interval backwards in time. Effectively, it does\n        $(D begin -= duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, begin + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "fwdRange",
								"line": 21249,
								"comment": "        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(LREF DateTimeException) will be\n        thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(2010, 9, 1));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n",
								"type": "const PosInfIntervalRange!TP(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 21257,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 21278,
								"comment": "        Converts this interval to a string.\n",
								"type": "const nothrow string()",
								"endline": 21281,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "PosInfInterval",
				"line": 20284,
				"comment": "    Represents an interval of time which has positive infinity as its end point.\n\n    Any ranges which iterate over a $(D PosInfInterval) are infinite. So, the\n    main purpose of using $(D PosInfInterval) is to create an infinite range\n    which starts at a fixed point in time and goes to positive infinity.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NegInfInterval",
						"line": 22476,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 22489,
								"comment": "        Params:\n            end = The time point which ends the interval.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n",
								"type": "pure nothrow (in TP end)",
								"parameters": [
									{
										"name": "end",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22492,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 22499,
								"comment": "        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref NegInfInterval(ref const NegInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfInterval",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 22503,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 22510,
								"comment": "        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n",
								"type": "pure nothrow ref NegInfInterval(NegInfInterval rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfInterval"
									}
								],
								"endline": 22514,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 22525,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).end == Date(2012, 3, 1));\n--------------------\n",
								"type": "const pure nothrow @property TP()",
								"endline": 22528,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "end",
								"line": 22537,
								"comment": "        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n",
								"type": "pure nothrow @property void(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 22540,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 22551,
								"comment": "        Whether the interval's length is 0. Always returns false.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n",
								"type": "const pure nothrow @property bool()",
								"endline": 22554,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 22570,
								"comment": "        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(1994, 12, 24)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure nothrow bool(TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP"
									}
								],
								"endline": 22573,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 22597,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22602,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 22620,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval beginning at negative\n        infinity can never contain an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22623,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "contains",
								"line": 22641,
								"comment": "        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22644,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 22661,
								"comment": "        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is\n                        before it.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2000, 1, 5)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22664,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 22689,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22694,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 22713,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22716,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isBefore",
								"line": 22739,
								"comment": "        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval beginning at negative\n        infinity can never be before another interval beginning at negative\n        infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22742,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 22762,
								"comment": "        Whether this interval is after the given time point.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2012, 3, 1)));\n--------------------\n",
								"type": "const pure nothrow bool(in TP timePoint)",
								"parameters": [
									{
										"name": "timePoint",
										"type": "TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22765,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 22794,
								"comment": "        Whether this interval is after the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval beginning at negative infinity can never be after any other\n        interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22799,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 22821,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22824,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAfter",
								"line": 22846,
								"comment": "        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22849,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 22873,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22878,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 22897,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22900,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersects",
								"line": 22921,
								"comment": "        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals beginning at negative infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22924,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 22948,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2000, 8, 2)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval!TP(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22957,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 22980,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n",
								"type": "const Interval!TP(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 22987,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "intersection",
								"line": 23007,
								"comment": "        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(1999, 7 , 6)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n--------------------\n",
								"type": "const nothrow NegInfInterval(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23010,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 23038,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2012, 3, 1))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2019, 2, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n",
								"type": "const pure bool(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23043,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 23062,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in PosInfInterval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "PosInfInterval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23065,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isAdjacent",
								"line": 23087,
								"comment": "        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals beginning at negative\n        infinity can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n",
								"type": "const pure nothrow bool(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23090,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 23120,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(LREF DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n--------------------\n",
								"type": "const NegInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23128,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "merge",
								"line": 23154,
								"comment": "        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const pure nothrow NegInfInterval(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23157,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 23193,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(LREF DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n\nassert(NegInfInterval!Date(Date(1600, 1, 7)).span(\n            Interval!Date(Date(2012, 3, 11), Date(2017, 7, 1))) ==\n       NegInfInterval!Date(Date(2017, 7 , 1)));\n--------------------\n",
								"type": "const pure NegInfInterval(in Interval!TP interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "Interval!TP",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23198,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "span",
								"line": 23227,
								"comment": "        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n",
								"type": "const pure nothrow NegInfInterval(in NegInfInterval interval)",
								"parameters": [
									{
										"name": "interval",
										"type": "NegInfInterval",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 23230,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "shift",
										"line": 23254,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 23258,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "shift",
								"line": 23254,
								"comment": "        Shifts the $(D end) of this interval forward or backwards in time by the\n        given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 4, 5));\nauto interval2 = NegInfInterval!Date(Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, end + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "expand",
										"line": 23326,
										"type": "pure nothrow void(D duration)",
										"parameters": [
											{
												"name": "duration",
												"type": "D"
											}
										],
										"endline": 23330,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "expand",
								"line": 23326,
								"comment": "        Expands the interval forwards in time. Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 3, 1));\nauto interval2 = NegInfInterval!Date(Date(2012, 3, 1));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));\n--------------------\n",
								"parameters": [
									{
										"name": "D",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, end + duration)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "bwdRange",
								"line": 23454,
								"comment": "        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(LREF DateTimeException) will\n        be thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(LREF DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = NegInfInterval!Date(Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\nassert(range.front == Date(2010, 9, 9)); //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n",
								"type": "const NegInfIntervalRange!TP(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
								"parameters": [
									{
										"name": "func",
										"type": "TP delegate(in TP)"
									},
									{
										"name": "popFirst",
										"type": "PopFirst",
										"default": "PopFirst.no"
									}
								],
								"endline": 23462,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 23483,
								"comment": "        Converts this interval to a string.\n",
								"type": "const nothrow string()",
								"endline": 23486,
								"char": 12,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NegInfInterval",
				"line": 22476,
				"comment": "    Represents an interval of time which has negative infinity as its starting\n    point.\n\n    Any ranges which iterate over a $(D NegInfInterval) are infinite. So, the\n    main purpose of using $(D NegInfInterval) is to create an infinite range\n    which starts at negative infinity and goes to a fixed end point.\n    Iterate over it in reverse.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyDayOfWeek",
						"line": 24698,
						"type": "nothrow TP delegate(in TP)(DayOfWeek dayOfWeek)",
						"parameters": [
							{
								"name": "dayOfWeek",
								"type": "DayOfWeek"
							}
						],
						"endline": 24719,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyDayOfWeek",
				"line": 24698,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given\n    $(D DayOfWeek) in a range.\n\n    Using this delegate allows iteration over successive time points which\n    are all the same day of the week. e.g. passing $(D DayOfWeek.mon) to\n    $(D everyDayOfWeek) would result in a delegate which could be used to\n    iterate over all of the Mondays in a range.\n\n    Params:\n        dir       = The direction to iterate in. If passing the return value to\n                    $(D fwdRange), use $(D Direction.fwd). If passing it to\n                    $(D bwdRange), use $(D Direction.bwd).\n        dayOfWeek = The week that each time point in the range will be.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL24722_997)\n---\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDayOfWeek!Date(DayOfWeek.mon);\nauto range = interval.fwdRange(func);\n\n//A Thursday. Using PopFirst.yes would have made this Date(2010, 9, 6).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 13));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 20));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL24722_997)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					}
				],
				"constraint": "isTimePoint!TP && (dir == Direction.fwd || dir == Direction.bwd) && __traits(hasMember, TP, \"dayOfWeek\") && !__traits(isStaticFunction, TP.dayOfWeek) && is(typeof(TP.dayOfWeek) == DayOfWeek)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyMonth",
						"line": 24802,
						"type": "TP delegate(in TP)(int month)",
						"parameters": [
							{
								"name": "month",
								"deco": "i"
							}
						],
						"endline": 24833,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyMonth",
				"line": 24802,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given month\n    which would be reached by adding months to the given time point.\n\n    So, using this delegate allows iteration over successive time points\n    which are in the same month but different years. For example,\n    iterate over each successive December 25th in an interval by starting with a\n    date which had the 25th as its day and passed $(D Month.dec) to\n    $(D everyMonth) to create the delegate.\n\n    Since it wouldn't really make sense to be iterating over a specific month\n    and end up with some of the time points in the succeeding month or two years\n    after the previous time point, $(D AllowDayOverflow.no) is always used when\n    calculating the next time point.\n\n    Params:\n        dir   = The direction to iterate in. If passing the return value to\n                $(D fwdRange), use $(D Direction.fwd). If passing it to\n                $(D bwdRange), use $(D Direction.bwd).\n        month = The month that each time point in the range will be in.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL24836_999)\n---\nauto interval = Interval!Date(Date(2000, 1, 30), Date(2004, 8, 5));\nauto func = everyMonth!(Date)(Month.feb);\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2010, 2, 29).\nassert(range.front == Date(2000, 1, 30));\n\nrange.popFront();\nassert(range.front == Date(2000, 2, 29));\n\nrange.popFront();\nassert(range.front == Date(2001, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2002, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2003, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2004, 2, 28));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL24836_999)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					}
				],
				"constraint": "isTimePoint!TP && (dir == Direction.fwd || dir == Direction.bwd) && __traits(hasMember, TP, \"month\") && !__traits(isStaticFunction, TP.month) && is(typeof(TP.month) == Month)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyDuration",
						"line": 24925,
						"type": "nothrow TP delegate(in TP)(D duration)",
						"parameters": [
							{
								"name": "duration",
								"type": "D"
							}
						],
						"endline": 24940,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyDuration",
				"line": 24925,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    duration later.\n\n    Using this delegate allows iteration over successive time points which\n    are apart by the given duration e.g. passing $(D dur!\"days\"(3)) to\n    $(D everyDuration) would result in a delegate which could be used to iterate\n    over a range of days which are each 3 days apart.\n\n    Params:\n        dir      = The direction to iterate in. If passing the return value to\n                   $(D fwdRange), use $(D Direction.fwd). If passing it to\n                   $(D bwdRange), use $(D Direction.bwd).\n        duration = The duration which separates each successive time point in\n                   the range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL24943_1001)\n---\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDuration!Date(dur!\"days\"(8));\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2010, 9, 10).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 10));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 18));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 26));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL24943_1001)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					},
					{
						"name": "D",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP && __traits(compiles, TP.init + duration) && (dir == Direction.fwd || dir == Direction.bwd)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "everyDuration",
						"line": 25025,
						"type": "nothrow TP delegate(in TP)(int years, int months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, D duration = dur!\"days\"(0))",
						"parameters": [
							{
								"name": "years",
								"deco": "i"
							},
							{
								"name": "months",
								"deco": "i",
								"default": "0"
							},
							{
								"name": "allowOverflow",
								"type": "AllowDayOverflow",
								"default": "AllowDayOverflow.yes"
							},
							{
								"name": "duration",
								"type": "D",
								"default": "dur!\"days\"(0)"
							}
						],
						"endline": 25059,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "everyDuration",
				"line": 25025,
				"comment": "    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    number of years, month, and duration later.\n\n    The difference between this version of $(D everyDuration) and the version\n    which just takes a $(CXREF time, Duration) is that this one also takes the number of\n    years and months (along with an $(D AllowDayOverflow) to indicate whether\n    adding years and months should allow the days to overflow).\n\n    Note that if iterating forward, $(D add!\"years\"()) is called on the given\n    time point, then $(D add!\"months\"()), and finally the duration is added\n    to it. However, if iterating backwards, the duration is added first, then\n    $(D add!\"months\"()) is called, and finally $(D add!\"years\"()) is called.\n    That way, going backwards generates close to the same time points that\n    iterating forward does, but since adding years and months is not entirely\n    reversible (due to possible day overflow, regardless of whether\n    $(D AllowDayOverflow.yes) or $(D AllowDayOverflow.no) is used), it can't be\n    guaranteed that iterating backwards will give the same time points as\n    iterating forward would have (even assuming that the end of the range is a\n    time point which would be returned by the delegate when iterating forward\n    from $(D begin)).\n\n    Params:\n        dir           = The direction to iterate in. If passing the return\n                        value to $(D fwdRange), use $(D Direction.fwd). If\n                        passing it to $(D bwdRange), use $(D Direction.bwd).\n        years         = The number of years to add to the time point passed to\n                        the delegate.\n        months        = The number of months to add to the time point passed to\n                        the delegate.\n        allowOverflow = Whether the days should be allowed to overflow on\n                        $(D begin) and $(D end), causing their month to\n                        increment.\n        duration      = The duration to add to the time point passed to the\n                        delegate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL25062_1003)\n---\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2025, 9, 27));\nauto func = everyDuration!Date(4, 1, AllowDayOverflow.yes, dur!\"days\"(2));\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2014, 10, 12).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2014, 10, 4));\n\nrange.popFront();\nassert(range.front == Date(2018, 11, 6));\n\nrange.popFront();\nassert(range.front == Date(2022, 12, 8));\n\nrange.popFront();\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL25062_1003)\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"defaultValue": "Direction.fwd",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					},
					{
						"name": "D",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP && __traits(compiles, TP.init + duration) && __traits(compiles, TP.init.add!\"years\"(years)) && __traits(compiles, TP.init.add!\"months\"(months)) && (dir == Direction.fwd || dir == Direction.bwd)",
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "IntervalRange",
						"line": 25182,
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25191,
								"comment": "        Params:\n            rhs = The $(D IntervalRange) to assign to this one.\n",
								"type": "pure nothrow ref IntervalRange(ref IntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "IntervalRange",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 25196,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25200,
								"comment": " Ditto\n",
								"type": "pure nothrow ref IntervalRange(IntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "IntervalRange"
									}
								],
								"endline": 25203,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 25209,
								"comment": "        Whether this $(D IntervalRange) is empty.\n",
								"type": "const pure nothrow @property bool()",
								"endline": 25212,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 25221,
								"comment": "        The first time point in the range.\n\n        Throws:\n            $(LREF DateTimeException) if the range is empty.\n",
								"type": "const pure @property TP()",
								"endline": 25229,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 25248,
								"comment": "        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range. If the generated time point is beyond the edge\n        of the range, then $(D front) is set to that edge, and the range is then\n        empty. So, if iterating forwards, and the generated time point is\n        greater than the interval's $(D end), then $(D front) is set to\n        $(D end). If iterating backwards, and the generated time point is less\n        than the interval's $(D begin), then $(D front) is set to $(D begin).\n\n        Throws:\n            $(LREF DateTimeException) if the range is empty or if the generated\n            time point is in the wrong direction (i.e. if iterating\n            forward and the generated time point is before $(D front), or if\n            iterating backwards and the generated time point is after\n            $(D front)).\n",
								"type": "void()",
								"endline": 25274,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 25280,
								"comment": "        Returns a copy of $(D this).\n",
								"type": "pure nothrow @property IntervalRange()",
								"endline": 25283,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "interval",
								"line": 25289,
								"comment": "        The interval that this $(D IntervalRange) currently covers.\n",
								"type": "const pure nothrow @property Interval!TP()",
								"endline": 25292,
								"char": 27,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "func",
								"line": 25298,
								"comment": "        The function used to generate the next time point in the range.\n",
								"type": "pure nothrow @property TP delegate(in TP)()",
								"endline": 25301,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "direction",
								"line": 25307,
								"comment": "        The $(D Direction) that this range iterates in.\n",
								"type": "const pure nothrow @property Direction()",
								"endline": 25310,
								"char": 25,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "IntervalRange",
				"line": 25182,
				"comment": "    A range over an $(LREF2 .Interval, Interval).\n\n    $(D IntervalRange) is only ever constructed by $(LREF2 .Interval, Interval). However, when\n    it is constructed, it is given a function, $(D func), which is used to\n    generate the time points which are iterated over. $(D func) takes a time\n    point and returns a time point of the same type. For instance,\n    to iterate over all of the days in\n    the interval $(D Interval!Date), pass a function to $(LREF2 .Interval, Interval)'s $(D fwdRange)\n    where that function took a $(LREF Date) and returned a $(LREF Date) which was one\n    day later. That function would then be used by $(D IntervalRange)'s\n    $(D popFront) to iterate over the $(LREF Date)s in the interval.\n\n    If $(D dir == Direction.fwd), then a range iterates forward in time, whereas\n    if $(D dir == Direction.bwd), then it iterates backwards in time. So, if\n    $(D dir == Direction.fwd) then $(D front == interval.begin), whereas if\n    $(D dir == Direction.bwd) then $(D front == interval.end). $(D func) must\n    generate a time point going in the proper direction of iteration, or a\n    $(LREF DateTimeException) will be thrown. So, to iterate forward in\n    time, the time point that $(D func) generates must be later in time than the\n    one passed to it. If it's either identical or earlier in time, then a\n    $(LREF DateTimeException) will be thrown. To iterate backwards, then\n    the generated time point must be before the time point which was passed in.\n\n    If the generated time point is ever passed the edge of the range in the\n    proper direction, then the edge of that range will be used instead. So, if\n    iterating forward, and the generated time point is past the interval's\n    $(D end), then $(D front) becomes $(D end). If iterating backwards, and the\n    generated time point is before $(D begin), then $(D front) becomes\n    $(D begin). In either case, the range would then be empty.\n\n    Also note that while normally the $(D begin) of an interval is included in\n    it and its $(D end) is excluded from it, if $(D dir == Direction.bwd), then\n    $(D begin) is treated as excluded and $(D end) is treated as included. This\n    allows for the same behavior in both directions. This works because none of\n    $(LREF2 .Interval, Interval)'s functions which care about whether $(D begin) or $(D end) is\n    included or excluded are ever called by $(D IntervalRange). $(D interval)\n    returns a normal interval, regardless of whether $(D dir == Direction.fwd)\n    or if $(D dir == Direction.bwd), so any $(LREF2 .Interval, Interval) functions which are\n    called on it which care about whether $(D begin) or $(D end) are included or\n    excluded will treat $(D begin) as included and $(D end) as excluded.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					},
					{
						"name": "dir",
						"deco": "E3std8datetime9Direction",
						"kind": "value"
					}
				],
				"constraint": "isTimePoint!TP && dir != Direction.both",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "PosInfIntervalRange",
						"line": 25680,
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25689,
								"comment": "        Params:\n            rhs = The $(D PosInfIntervalRange) to assign to this one.\n",
								"type": "pure nothrow ref PosInfIntervalRange(ref PosInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfIntervalRange",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 25695,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25699,
								"comment": " Ditto\n",
								"type": "pure nothrow ref PosInfIntervalRange(PosInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "PosInfIntervalRange"
									}
								],
								"endline": 25702,
								"char": 29,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 25708,
								"comment": "        This is an infinite range, so it is never empty.\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 25714,
								"comment": "        The first time point in the range.\n",
								"type": "const pure nothrow @property TP()",
								"endline": 25717,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 25728,
								"comment": "        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(LREF DateTimeException) if the generated time point is less than\n            $(D front).\n",
								"type": "void()",
								"endline": 25735,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 25741,
								"comment": "        Returns a copy of $(D this).\n",
								"type": "pure nothrow @property PosInfIntervalRange()",
								"endline": 25744,
								"char": 35,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "interval",
								"line": 25750,
								"comment": "        The interval that this range currently covers.\n",
								"type": "const pure nothrow @property PosInfInterval!TP()",
								"endline": 25753,
								"char": 33,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "func",
								"line": 25759,
								"comment": "        The function used to generate the next time point in the range.\n",
								"type": "pure nothrow @property TP delegate(in TP)()",
								"endline": 25762,
								"char": 24,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "PosInfIntervalRange",
				"line": 25680,
				"comment": "    A range over a $(D PosInfInterval). It is an infinite range.\n\n    $(D PosInfIntervalRange) is only ever constructed by $(D PosInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D PosInfInterval!Date), pass a function to\n    $(D PosInfInterval)'s $(D fwdRange) where that function took a $(LREF Date) and\n    returned a $(LREF Date) which was one day later. That function would then be\n    used by $(D PosInfIntervalRange)'s $(D popFront) to iterate over the\n    $(LREF Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to positive infinity, the range is always iterated over\n    forwards, never backwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(LREF DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be later in time\n    than the one passed to it. If it's either identical or earlier in time, then\n    a $(LREF DateTimeException) will be thrown.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NegInfIntervalRange",
						"line": 25968,
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25977,
								"comment": "        Params:\n            rhs = The $(D NegInfIntervalRange) to assign to this one.\n",
								"type": "pure nothrow ref NegInfIntervalRange(ref NegInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfIntervalRange",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 25983,
								"char": 29,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 25987,
								"comment": " Ditto\n",
								"type": "pure nothrow ref NegInfIntervalRange(NegInfIntervalRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "NegInfIntervalRange"
									}
								],
								"endline": 25990,
								"char": 29,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 25996,
								"comment": "        This is an infinite range, so it is never empty.\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 26002,
								"comment": "        The first time point in the range.\n",
								"type": "const pure nothrow @property TP()",
								"endline": 26005,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 26016,
								"comment": "        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(LREF DateTimeException) if the generated time point is greater than\n            $(D front).\n",
								"type": "void()",
								"endline": 26023,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 26029,
								"comment": "        Returns a copy of $(D this).\n",
								"type": "pure nothrow @property NegInfIntervalRange()",
								"endline": 26032,
								"char": 35,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "interval",
								"line": 26038,
								"comment": "        The interval that this range currently covers.\n",
								"type": "const pure nothrow @property NegInfInterval!TP()",
								"endline": 26041,
								"char": 33,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "func",
								"line": 26047,
								"comment": "        The function used to generate the next time point in the range.\n",
								"type": "pure nothrow @property TP delegate(in TP)()",
								"endline": 26050,
								"char": 24,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NegInfIntervalRange",
				"line": 25968,
				"comment": "    A range over a $(D NegInfInterval). It is an infinite range.\n\n    $(D NegInfIntervalRange) is only ever constructed by $(D NegInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D NegInfInterval!Date), pass a function to\n    $(D NegInfInterval)'s $(D bwdRange) where that function took a $(LREF Date) and\n    returned a $(LREF Date) which was one day earlier. That function would then be\n    used by $(D NegInfIntervalRange)'s $(D popFront) to iterate over the\n    $(LREF Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to negative infinity, the range is always iterated over\n    backwards, never forwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(LREF DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be earlier in time\n    than the one passed to it. If it's either identical or later in time, then a\n    $(LREF DateTimeException) will be thrown.\n\n    Also note that while normally the $(D end) of an interval is excluded from\n    it, $(D NegInfIntervalRange) treats it as if it were included. This allows\n    for the same behavior as with $(D PosInfIntervalRange). This works\n    because none of $(D NegInfInterval)'s functions which care about whether\n    $(D end) is included or excluded are ever called by\n    $(D NegInfIntervalRange). $(D interval) returns a normal interval, so any\n    $(D NegInfInterval) functions which are called on it which care about\n    whether $(D end) is included or excluded will treat $(D end) as excluded.\n",
				"parameters": [
					{
						"name": "TP",
						"kind": "type"
					}
				],
				"constraint": "isTimePoint!TP",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "TimeZone",
				"line": 26232,
				"comment": "    Represents a time zone. It is used with $(LREF SysTime) to indicate the time\n    zone of a $(LREF SysTime).\n",
				"members": [
					{
						"endchar": 5,
						"name": "name",
						"line": 26246,
						"comment": "        The name of the time zone per the TZ Database. This is the name used to\n        get a $(LREF2 .TimeZone, TimeZone) by name with $(D TimeZone.getTimeZone).\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)\n",
						"deco": "xFNbNdNfZAya",
						"endline": 26249,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stdName",
						"line": 26259,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n",
						"deco": "xFNbNdNfZAya",
						"endline": 26262,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dstName",
						"line": 26272,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n",
						"deco": "xFNbNdNfZAya",
						"endline": 26275,
						"char": 22,
						"kind": "function"
					},
					{
						"name": "hasDST",
						"line": 26284,
						"comment": "        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current dates\n        but will still return true for $(D hasDST) because the time zone did at\n        some point have DST.\n",
						"deco": "xFNbNdNfZb",
						"char": 29,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "dstInEffect",
						"line": 26296,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 19,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "utcToTZ",
						"line": 26307,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 19,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "tzToUTC",
						"line": 26318,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"char": 19,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 5,
						"name": "utcOffsetAt",
						"line": 26329,
						"comment": "        Returns what the offset from UTC is at the given std time.\n        It includes the DST offset in effect at that time (if any).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n",
						"deco": "xFNbNflZS4core4time8Duration",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 26332,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getTimeZone",
						"line": 26368,
						"comment": "        Returns a $(LREF2 .TimeZone, TimeZone) with the give name per the TZ Database.\n\n        This returns a $(LREF PosixTimeZone) on Posix systems and a\n        $(LREF WindowsTimeZone) on Windows systems. For\n        $(LREF PosixTimeZone) on Windows, call $(D PosixTimeZone.getTimeZone)\n        directly and give it the location of the TZ Database time zone files on\n        disk.\n\n        On Windows, the given TZ Database name is converted to the corresponding\n        time zone name on Windows prior to calling\n        $(D WindowsTimeZone.getTimeZone). This function allows for\n        the same time zone names on both Windows and Posix systems.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)<br>\n            $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n                  Windows <-> TZ Database Name Conversion Table)\n\n        Params:\n            name = The TZ Database name of the desired time zone\n\n        Throws:\n            $(LREF DateTimeException) if the given time zone could not be found.\n\n        Examples:\n--------------------\nauto tz = TimeZone.getTimeZone(\"America/Los_Angeles\");\n--------------------\n",
						"deco": "FNfAyaZyC3std8datetime8TimeZone",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							}
						],
						"endline": 26391,
						"char": 32,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getInstalledTZNames",
						"line": 26716,
						"comment": "        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        On Windows, this function will convert the Windows time zone names to\n        the corresponding TZ Database names with\n        $(D windowsTZNameToTZDatabaseName). To get the actual Windows time\n        zone names, use $(D WindowsTimeZone.getInstalledTZNames) directly.\n\n        Params:\n            subName = The first part of the time zones desired.\n\n        Throws:\n            $(D FileException) on Posix systems if it fails to read from disk.\n            $(LREF DateTimeException) on Windows systems if it fails to read the\n            registry.\n",
						"deco": "FNfAyaZAAya",
						"parameters": [
							{
								"name": "subName",
								"deco": "Aya",
								"default": "\"\""
							}
						],
						"endline": 26746,
						"char": 21,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 26806,
						"comment": "        $(LREF LocalTime) is a singleton class. $(LREF LocalTime) returns its only\n        instance.\n",
						"deco": "FNaNbNeZyC3std8datetime9LocalTime",
						"endline": 26810,
						"char": 33,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "name",
						"line": 26831,
						"comment": "            The name of the time zone per the TZ Database. This is the name used to\n            get a $(LREF2 .TimeZone, TimeZone) by name with $(D TimeZone.getTimeZone).\n\n            Note that this always returns the empty string. This is because time\n            zones cannot be uniquely identified by the attributes given by the\n            OS (such as the $(D stdName) and $(D dstName)), and neither Posix\n            systems nor Windows systems provide an easy way to get the TZ\n            Database name of the local time zone.\n\n            See_Also:\n                $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n                  Database)<br>\n                $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List\n                  of Time Zones)\n",
						"deco": "xFNbNdNfZAya",
						"char": 35,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.name"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "stdName",
						"line": 26847,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n",
						"deco": "xFNbNdNeZAya",
						"endline": 26887,
						"char": 31,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.stdName"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstName",
						"line": 26918,
						"comment": "        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n",
						"deco": "xFNbNdNeZAya",
						"endline": 26958,
						"char": 31,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstName"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 26991,
						"comment": "        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n",
						"deco": "xFNbNdNeZb",
						"endline": 27025,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 27056,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n",
						"deco": "xFNbNelZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27086,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 27107,
						"comment": "        Returns hnsecs in the local time zone using the standard C function\n        calls on Posix systems and the standard Windows system calls on Windows\n        systems to adjust the time to the appropriate time zone from std time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n",
						"deco": "xFNbNelZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27127,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 27147,
						"comment": "        Returns std time using the standard C function calls on Posix systems\n        and the standard Windows system calls on Windows systems to adjust the\n        time to UTC from the appropriate time zone.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNelZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 27183,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "LocalTime",
				"line": 26798,
				"comment": "    A TimeZone which represents the current local time zone on\n    the system running your program.\n\n    This uses the underlying C calls to adjust the time rather than using\n    specific D code based off of system settings to calculate the time such as\n    $(LREF PosixTimeZone) and $(LREF WindowsTimeZone) do. That also means that it will\n    use whatever the current time zone is on the system, even if the system's\n    time zone changes while the program is running.\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 27375,
						"comment": "        $(D UTC) is a singleton class. $(D UTC) returns its only instance.\n",
						"deco": "FNaNbNfZyC3std8datetime3UTC",
						"endline": 27378,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 27384,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNdNfZb",
						"endline": 27387,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 27393,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27396,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 27409,
						"comment": "        Returns the given hnsecs without changing them at all.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27412,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 27441,
						"comment": "        Returns the given hnsecs without changing them at all.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 27444,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcOffsetAt",
						"line": 27470,
						"comment": "        Returns a $(CXREF time, Duration) of 0.\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n",
						"deco": "xFNbNflZS4core4time8Duration",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27473,
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcOffsetAt"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "UTC",
				"line": 27368,
				"comment": "    A $(LREF2 .TimeZone, TimeZone) which represents UTC.\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 27507,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNdNfZb",
						"endline": 27510,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 27516,
						"comment": "        Always returns false.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27519,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 27530,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27533,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 27558,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 27561,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcOffsetAt",
						"line": 27585,
						"comment": "        Returns utcOffset as a $(CXREF time, Duration).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n",
						"deco": "xFNbNflZS4core4time8Duration",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27588,
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcOffsetAt"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 27597,
						"comment": "        Params:\n            utcOffset = This time zone's offset from UTC with west of UTC being\n                        negative (it is added to UTC to get the adjusted time).\n            stdName   = The $(D stdName) for this time zone.\n",
						"deco": "yFNaNfS4core4time8DurationAyaZyC3std8datetime14SimpleTimeZone",
						"parameters": [
							{
								"name": "utcOffset",
								"deco": "S4core4time8Duration"
							},
							{
								"name": "stdName",
								"deco": "Aya",
								"default": "\"\""
							}
						],
						"endline": 27605,
						"originalType": "immutable pure @safe (Duration utcOffset, string stdName = \"\")",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 27617,
						"comment": "        $(RED Deprecated. Please use the overload which takes a Duration. This\n              overload will be removed in December 2014).\n\n        Params:\n            utcOffset = This time zone's offset from UTC in minutes with west of\n                        negative (it is added to UTC to get the adjusted time).\n            stdName   = The $(D stdName) for this time zone.\n",
						"deco": "yFNaNfiAyaZyC3std8datetime14SimpleTimeZone",
						"parameters": [
							{
								"name": "utcOffset",
								"deco": "i"
							},
							{
								"name": "stdName",
								"deco": "Aya",
								"default": "\"\""
							}
						],
						"endline": 27620,
						"originalType": "immutable pure @safe (int utcOffset, string stdName = \"\")",
						"char": 5,
						"kind": "constructor",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "utcOffset",
						"line": 27636,
						"comment": "        The amount of time the offset from UTC is (negative is west of UTC,\n        positive is east).\n",
						"deco": "xFNaNbNdNfZS4core4time8Duration",
						"endline": 27639,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "SimpleTimeZone",
				"line": 27500,
				"comment": "    Represents a time zone with an offset (in minutes, west is negative) from\n    UTC but no DST.\n\n    It's primarily used as the time zone in the result of $(LREF SysTime)'s\n    $(D fromISOString), $(D fromISOExtString), and $(D fromSimpleString).\n\n    $(D name) and $(D dstName) are always the empty string since this time zone\n    has no DST, and while it may be meant to represent a time zone which is in\n    the TZ Database, obviously it's not likely to be following the exact rules\n    of any of the time zones in the TZ Database, so it makes no sense to set it.\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "hasDST",
						"line": 27920,
						"comment": "        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n",
						"deco": "xFNbNdNfZb",
						"endline": 27923,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "dstInEffect",
						"line": 27935,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27948,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "utcToTZ",
						"line": 27959,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"endline": 27973,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "tzToUTC",
						"line": 27984,
						"comment": "        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"endline": 28019,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "defaultTZDatabaseDir",
						"line": 28028,
						"comment": "            The default directory where the TZ Database files are. It's empty\n            for Windows, since Windows doesn't have them.\n",
						"deco": "Aya",
						"init": "\"/usr/share/zoneinfo/\"",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					},
					{
						"endchar": 5,
						"name": "getTimeZone",
						"line": 28073,
						"comment": "        Returns a $(LREF2 .TimeZone, TimeZone) with the give name per the TZ Database. The time\n        zone information is fetched from the TZ Database time zone files in the\n        given directory.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)\n\n        Params:\n            name          = The TZ Database name of the desired time zone\n            tzDatabaseDir = The directory where the TZ Database files are\n                            located. Because these files are not located on\n                            Windows systems, provide them\n                            and give their location here to\n                            use $(LREF PosixTimeZone)s.\n\n        Throws:\n            $(LREF DateTimeException) if the given time zone could not be found or\n            $(D FileException) if the TZ Database file could not be opened.\n\n        Examples:\n--------------------\nauto tz = PosixTimeZone.getTimeZone(\"America/Los_Angeles\");\n\nassert(tz.name == \"America/Los_Angeles\");\nassert(tz.stdName == \"PST\");\nassert(tz.dstName == \"PDT\");\n--------------------\n",
						"deco": "FNeAyaAyaZyC3std8datetime13PosixTimeZone",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "tzDatabaseDir",
								"deco": "Aya",
								"default": "\"/usr/share/zoneinfo/\""
							}
						],
						"endline": 28373,
						"originalType": "@trusted immutable(PosixTimeZone)(string name, string tzDatabaseDir = defaultTZDatabaseDir)",
						"char": 37,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getInstalledTZNames",
						"line": 28391,
						"comment": "        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        Params:\n            subName       = The first part of the desired time zones.\n            tzDatabaseDir = The directory where the TZ Database files are\n                            located.\n\n        Throws:\n            $(D FileException) if it fails to read from disk.\n",
						"deco": "FNeAyaAyaZAAya",
						"parameters": [
							{
								"name": "subName",
								"deco": "Aya",
								"default": "\"\""
							},
							{
								"name": "tzDatabaseDir",
								"deco": "Aya",
								"default": "\"/usr/share/zoneinfo/\""
							}
						],
						"endline": 28431,
						"originalType": "@trusted string[](string subName = \"\", string tzDatabaseDir = defaultTZDatabaseDir)",
						"char": 21,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "PosixTimeZone",
				"line": 27905,
				"comment": "    Represents a time zone from a TZ Database time zone file. Files from the TZ\n    Database are how Posix systems hold their time zone information.\n    Unfortunately, Windows does not use the TZ Database. To use the TZ Database,\n    use $(D PosixTimeZone) (which reads its information from the TZ Database\n    files on disk) on Windows by providing the TZ Database files and telling\n    $(D PosixTimeZone.getTimeZone) where the directory holding them is.\n\n    To get a $(D PosixTimeZone), either call $(D PosixTimeZone.getTimeZone)\n    (which allows specifying the location the time zone files) or call\n    $(D TimeZone.getTimeZone) (which will give a $(D PosixTimeZone) on Posix\n    systems and a $(LREF WindowsTimeZone) on Windows systems).\n\n    Note:\n        Unless your system's local time zone deals with leap seconds (which is\n        highly unlikely), then the only way to get a time zone which\n        takes leap seconds into account is to use $(LREF PosixTimeZone) with a\n        time zone whose name starts with \"right/\". Those time zone files do\n        include leap seconds, and $(LREF PosixTimeZone) will take them into account\n        (though posix systems which use a \"right/\" time zone as their local time\n        zone will $(I not) take leap seconds into account even though they're\n        in the file).\n\n    See_Also:\n        $(WEB www.iana.org/time-zones, Home of the TZ Database files)<br>\n        $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of Time\n          Zones)\n",
				"base": "std.datetime.TimeZone",
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "hasDST",
						"line": 28736,
						"comment": "            Whether this time zone has Daylight Savings Time at any point in\n            time. Note that for some time zone types it may not have DST for\n            current dates but will still return true for $(D hasDST) because the\n            time zone did at some point have DST.\n",
						"deco": "xFNbNdNfZb",
						"char": 33,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.hasDST"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "dstInEffect",
						"line": 28748,
						"comment": "            Takes the number of hnsecs (100 ns) since midnight, January 1st,\n            1 A.D. in UTC time (i.e. std time) and returns whether DST is in\n            effect in this time zone at the given point in time.\n\n            Params:\n                stdTime = The UTC time that needs to be checked for DST in this\n                          time zone.\n",
						"deco": "xFNbNflZb",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.dstInEffect"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "utcToTZ",
						"line": 28760,
						"comment": "            Takes the number of hnsecs (100 ns) since midnight, January 1st,\n            1 A.D. in UTC time (i.e. std time) and converts it to this time\n                zone's time.\n\n            Params:\n                stdTime = The UTC time that needs to be adjusted to this time\n                          zone's time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "stdTime",
								"deco": "l"
							}
						],
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.utcToTZ"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "tzToUTC",
						"line": 28772,
						"comment": "            Takes the number of hnsecs (100 ns) since midnight, January 1st,\n            1 A.D. in this time zone's time and converts it to UTC (i.e. std\n            time).\n\n            Params:\n                adjTime = The time in this time zone that needs to be adjusted\n                          to UTC time.\n",
						"deco": "xFNbNflZl",
						"parameters": [
							{
								"name": "adjTime",
								"deco": "l"
							}
						],
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.datetime.TimeZone.tzToUTC"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"name": "getTimeZone",
						"line": 28798,
						"comment": "            Returns a $(LREF2 .TimeZone, TimeZone) with the given name per the Windows time\n            zone names. The time zone information is fetched from the Windows\n            registry.\n\n            See_Also:\n                $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n                  Database)<br>\n                $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List\n                  of Time Zones)\n\n            Params:\n                name = The TZ Database name of the desired time zone.\n\n            Throws:\n                $(LREF DateTimeException) if the given time zone could not be\n                found.\n\n            Examples:\n    --------------------\n    auto tz = TimeZone.getTimeZone(\"America/Los_Angeles\");\n    --------------------\n",
						"deco": "FNfAyaZyC3std8datetime15WindowsTimeZone",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							}
						],
						"char": 43,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "getInstalledTZNames",
						"line": 28808,
						"comment": "            Returns a list of the names of the time zones installed on the\n            system. The list returned by WindowsTimeZone contains the Windows\n            TZ names, not the TZ Database names. However,\n            $(D TimeZone.getinstalledTZNames) will return the TZ Database names\n            which are equivalent to the Windows TZ names.\n",
						"deco": "FNfZAAya",
						"char": 25,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "WindowsTimeZone",
				"line": 28726,
				"comment": "        $(BLUE This class is Windows-Only.)\n\n        Represents a time zone from the Windows registry. Unfortunately, Windows\n        does not use the TZ Database. To use the TZ Database, use\n        $(LREF PosixTimeZone) (which reads its information from the TZ Database\n        files on disk) on Windows by providing the TZ Database files and telling\n        $(D PosixTimeZone.getTimeZone) where the directory holding them is.\n\n        The TZ Database files and Windows' time zone information frequently\n        do not match. Windows has many errors with regards to when DST switches\n        occur (especially for historical dates). Also, the TZ Database files\n        include far more time zones than Windows does. So, for accurate\n        time zone information, use the TZ Database files with\n        $(LREF PosixTimeZone) rather than $(LREF WindowsTimeZone). However, because\n        $(LREF WindowsTimeZone) uses Windows system calls to deal with the time,\n        it's far more likely to match the behavior of other Windows programs.\n        Be aware of the differences when selecting a method.\n\n        $(LREF WindowsTimeZone) does not exist on Posix systems.\n\n        To get a $(LREF WindowsTimeZone), either call\n        $(D WindowsTimeZone.getTimeZone) or call $(D TimeZone.getTimeZone)\n        (which will give a $(LREF PosixTimeZone) on Posix systems and a\n         $(LREF WindowsTimeZone) on Windows systems).\n\n        See_Also:\n            $(WEB www.iana.org/time-zones, Home of the TZ Database files)\n",
				"base": "std.datetime.TimeZone",
				"char": 11,
				"kind": "class"
			},
			{
				"name": "setTZEnvVar",
				"line": 29158,
				"comment": "        $(BLUE This function is Posix-Only.)\n\n        Sets the local time zone on Posix systems with the TZ\n        Database name by setting the TZ environment variable.\n\n        Unfortunately, there is no way to do it on Windows using the TZ\n        Database name, so this function only exists on Posix systems.\n",
				"deco": "FNbNfAyaZv",
				"parameters": [
					{
						"name": "tzDatabaseName",
						"deco": "Aya"
					}
				],
				"char": 10,
				"kind": "function"
			},
			{
				"name": "clearTZEnvVar",
				"line": 29166,
				"comment": "        $(BLUE This function is Posix-Only.)\n\n        Clears the TZ environment variable.\n",
				"deco": "FNbNfZv",
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "tzDatabaseNameToWindowsTZName",
				"line": 29221,
				"comment": "    Converts the given TZ Database name to the corresponding Windows time zone\n    name.\n\n    Note that in a few cases, a TZ Dabatase name corresponds to two different\n    Windows time zone names. So, while in most cases converting from one to the\n    other and back again will result in the same time zone name started\n    with, in a few case, it'll get a different name.\n\n    Also, there are far more TZ Database names than Windows time zones, so some\n    of the more exotic TZ Database names don't have corresponding Windows time\n    zone names.\n\n    Returns null if the given time zone name cannot be converted.\n\n    See_Also:\n        $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n",
				"deco": "FNaNbNiNfAyaZAya",
				"parameters": [
					{
						"name": "tzName",
						"deco": "Aya"
					}
				],
				"endline": 29658,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "windowsTZNameToTZDatabaseName",
				"line": 29681,
				"comment": "    Converts the given Windows time zone name to a corresponding TZ Database\n    name.\n\n    Returns null if the given time zone name cannot be converted.\n\n    See_Also:\n        $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n",
				"deco": "FNaNbNiNfAyaZAya",
				"parameters": [
					{
						"name": "tzName",
						"deco": "Aya"
					}
				],
				"endline": 29803,
				"char": 8,
				"kind": "function"
			},
			{
				"name": "StopWatch",
				"line": 29860,
				"comment": "   $(D StopWatch) measures time as precisely as possible.\n\n   This class uses a high-performance counter. On Windows systems, it uses\n   $(D QueryPerformanceCounter), and on Posix systems, it uses\n   $(D clock_gettime) if available, and $(D gettimeofday) otherwise.\n\n   But the precision of $(D StopWatch) differs from system to system. It is\n   impossible to for it to be the same from system to system since the precision\n   of the system clock varies from system to system, and other system-dependent\n   and situation-dependent stuff (such as the overhead of a context switch\n   between threads) can also affect $(D StopWatch)'s accuracy.\n\n   Examples:\n--------------------\nvoid foo()\n{\n    StopWatch sw;\n    enum n = 100;\n    TickDuration[n] times;\n    TickDuration last = TickDuration.from!\"seconds\"(0);\n    foreach(i; 0..n)\n    {\n       sw.start(); //start/resume mesuring.\n       foreach(unused; 0..1_000_000)\n           bar();\n       sw.stop();  //stop/pause measuring.\n       //Return value of peek() after having stopped are the always same.\n       writeln((i + 1) * 1_000_000, \" times done, lap time: \",\n               sw.peek().msecs, \"[ms]\");\n       times[i] = sw.peek() - last;\n       last = sw.peek();\n    }\n    real sum = 0;\n    // To know the number of seconds,\n    // use properties of TickDuration.\n    // (seconds, msecs, usecs, hnsecs)\n    foreach(t; times)\n       sum += t.hnsecs;\n    writeln(\"Average time: \", sum/n, \" hnsecs\");\n}\n--------------------\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 29897,
						"comment": "       Auto start with constructor.\n",
						"deco": "FNcNfE3std8datetime9AutoStartZS3std8datetime9StopWatch",
						"parameters": [
							{
								"name": "autostart",
								"deco": "E3std8datetime9AutoStart"
							}
						],
						"endline": 29901,
						"originalType": "ref @safe (AutoStart autostart)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 29911,
						"comment": "\n",
						"deco": "xFNaNbNfxS3std8datetime9StopWatchZb",
						"parameters": [
							{
								"name": "rhs",
								"deco": "xS3std8datetime9StopWatch"
							}
						],
						"endline": 29914,
						"originalType": "const pure nothrow @safe bool(const StopWatch rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 29917,
						"comment": "ditto\n",
						"deco": "xFNaNbNfKxS3std8datetime9StopWatchZb",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8datetime9StopWatch"
							}
						],
						"endline": 29921,
						"originalType": "const pure nothrow @safe bool(ref const StopWatch rhs)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 29927,
						"comment": "       Resets the stop watch.\n",
						"deco": "FNfZv",
						"endline": 29941,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "start",
						"line": 29956,
						"comment": "       Starts the stop watch.\n",
						"deco": "FNfZv",
						"endline": 29961,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "stop",
						"line": 29982,
						"comment": "       Stops the stop watch.\n",
						"deco": "FNfZv",
						"endline": 29987,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "peek",
						"line": 30009,
						"comment": "       Peek at the amount of time which has passed since the stop watch was\n       started.\n",
						"deco": "xFNfZS4core4time12TickDuration",
						"endline": 30015,
						"char": 18,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setMeasured",
						"line": 30034,
						"comment": "       Set the amount of time which has been measured since the stop watch was\n       started.\n",
						"deco": "FNfS4core4time12TickDurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time12TickDuration"
							}
						],
						"endline": 30038,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "running",
						"line": 30054,
						"comment": "       Confirm whether this stopwatch is measuring time.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 30057,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "benchmark",
						"line": 30112,
						"type": "TickDuration[fun.length](uint n)",
						"parameters": [
							{
								"name": "n",
								"deco": "k"
							}
						],
						"endline": 30127,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "benchmark",
				"line": 30112,
				"comment": "    Benchmarks code for speed assessment and comparison.\n\n    Params:\n        fun = aliases of callable objects (e.g. function names). Each should\n              take no arguments.\n        n   = The number of times each function is to be executed.\n\n    Returns:\n        The amount of time (as a $(CXREF time, TickDuration)) that it took to\n        call each function $(D n) times. The first value is the length of time\n        that it took to call $(D fun[0]) $(D n) times. The second value is the\n        length of time it took to call $(D fun[1]) $(D n) times. Etc.\n\n    Note that casting the TickDurations to $(CXREF time, Duration)s will make\n    the results easier to deal with (and it may change in the future that\n    benchmark will return an array of Durations rather than TickDurations).\n\n    See_Also:\n        $(LREF measureTime)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL30130_1057)\n---\nimport std.conv : to;\nint a;\nvoid f0() {}\nvoid f1() {auto b = a;}\nvoid f2() {auto b = to!string(a);}\nauto r = benchmark!(f0, f1, f2)(10_000);\nauto f0Result = to!Duration(r[0]); // time f0 took to run 10,000 times\nauto f1Result = to!Duration(r[1]); // time f1 took to run 10,000 times\nauto f2Result = to!Duration(r[2]); // time f2 took to run 10,000 times\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL30130_1057)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"char": 26,
				"kind": "template"
			},
			{
				"name": "ComparingBenchmarkResult",
				"line": 30156,
				"comment": "   Return value of benchmark with two functions comparing.\n",
				"members": [
					{
						"endchar": 5,
						"name": "point",
						"line": 30165,
						"comment": "       Evaluation value\n\n       This returns the evaluation value of performance as the ratio of\n       baseFunc's time over targetFunc's time. If performance is high, this\n       returns a high value.\n",
						"deco": "xFNaNbNdNfZe",
						"endline": 30168,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "baseTime",
						"line": 30174,
						"comment": "       The time required of the base function\n",
						"deco": "xFNaNbNdNfZS4core4time12TickDuration",
						"endline": 30177,
						"char": 35,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "targetTime",
						"line": 30183,
						"comment": "       The time required of the target function\n",
						"deco": "xFNaNbNdNfZS4core4time12TickDuration",
						"endline": 30186,
						"char": 35,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "comparingBenchmark",
						"line": 30224,
						"type": "ComparingBenchmarkResult()",
						"endline": 30230,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "comparingBenchmark",
				"line": 30224,
				"comment": "   Benchmark with two functions comparing.\n\n   Params:\n       baseFunc   = The function to become the base of the speed.\n       targetFunc = The function that wants to measure speed.\n       times      = The number of times each function is to be executed.\n\n   Examples:\n--------------------\nvoid f1() {\n   // ...\n}\nvoid f2() {\n   // ...\n}\n\nvoid main() {\n   auto b = comparingBenchmark!(f1, f2, 0x80);\n   writeln(b.point);\n}\n--------------------\n",
				"parameters": [
					{
						"name": "baseFunc",
						"kind": "alias"
					},
					{
						"name": "targetFunc",
						"kind": "alias"
					},
					{
						"name": "times",
						"defaultValue": "4095",
						"deco": "i",
						"kind": "value"
					}
				],
				"char": 26,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isTimePoint",
						"line": 30278,
						"init": "hasMin!T && hasMax!T && hasOverloadedOpBinaryWithDuration!T && hasOverloadedOpAssignWithDuration!T && hasOverloadedOpBinaryWithSelf!T",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isTimePoint",
				"line": 30276,
				"comment": "    Whether the given type defines all of the necessary functions for it to\n    function as a time point.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "yearIsLeapYear",
				"line": 30307,
				"comment": "    Whether the given Gregorian Year is a leap year.\n\n    Params:\n        year = The year to to be tested.\n",
				"deco": "FNaNbNfiZb",
				"parameters": [
					{
						"name": "year",
						"deco": "i"
					}
				],
				"endline": 30316,
				"char": 13,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"endchar": 1,
				"name": "unixTimeToStdTime",
				"line": 30343,
				"comment": "    Converts a $(D time_t) (which uses midnight, January 1st, 1970 UTC as its\n    epoch and seconds as its units) to std time (which uses midnight,\n    January 1st, 1 A.D. UTC and hnsecs as its units).\n\n    Params:\n        unixTime = The $(D time_t) to convert.\n",
				"deco": "FNaNbNflZl",
				"parameters": [
					{
						"name": "unixTime",
						"deco": "l"
					}
				],
				"endline": 30347,
				"originalType": "pure nothrow @safe long(time_t unixTime)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "stdTimeToUnixTime",
				"line": 30380,
				"comment": "    Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch\n    and hnsecs as its units) to $(D time_t) (which uses midnight, January 1st,\n    1970 UTC as its epoch and seconds as its units). If $(D time_t) is 32 bits,\n    rather than 64, and the result can't fit in a 32-bit value, then the closest\n    value that can be held in 32 bits will be used (so $(D time_t.max) if it\n    goes over and $(D time_t.min) if it goes under).\n\n    Note:\n        While Windows systems require that $(D time_t) be non-negative (in spite\n        of $(D time_t) being signed), this function still returns negative\n        numbers on Windows, since it's more flexible to allow negative time_t\n        for those who need it. If on Windows and using the\n        standard C functions or Win32 API functions which take a $(D time_t),\n        check whether the return value of\n        $(D stdTimeToUnixTime) is non-negative.\n\n    Params:\n        stdTime = The std time to convert.\n",
				"deco": "FNaNbNflZl",
				"parameters": [
					{
						"name": "stdTime",
						"deco": "l"
					}
				],
				"endline": 30400,
				"originalType": "pure nothrow @safe time_t(long stdTime)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "SYSTEMTIMEToSysTime",
				"line": 30440,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(D SYSTEMTIME) struct to a $(LREF SysTime).\n\n        Params:\n            st = The $(D SYSTEMTIME) struct to convert.\n            tz = The time zone that the time in the $(D SYSTEMTIME) struct is\n                 assumed to be (if the $(D SYSTEMTIME) was supplied by a Windows\n                 system call, the $(D SYSTEMTIME) will either be in local time\n                 or UTC, depending on the call).\n\n        Throws:\n            $(LREF DateTimeException) if the given $(D SYSTEMTIME) will not fit in\n            a $(LREF SysTime), which is highly unlikely to happen given that\n            $(D SysTime.max) is in 29,228 A.D. and the maximum $(D SYSTEMTIME)\n            is in 30,827 A.D.\n",
				"deco": "FNfxPPvyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "st",
						"deco": "xPPv"
					},
					{
						"name": "tz",
						"deco": "yC3std8datetime8TimeZone",
						"default": "opCall()"
					}
				],
				"originalType": "@safe SysTime(const SYSTEMTIME* st, immutable TimeZone tz = LocalTime())",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "SysTimeToSYSTEMTIME",
				"line": 30460,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(LREF SysTime) to a $(D SYSTEMTIME) struct.\n\n        The $(D SYSTEMTIME) which is returned will be set using the given\n        $(LREF SysTime)'s time zone, so to get the $(D SYSTEMTIME) in\n        UTC, set the $(LREF SysTime)'s time zone to UTC.\n\n        Params:\n            sysTime = The $(LREF SysTime) to convert.\n\n        Throws:\n            $(LREF DateTimeException) if the given $(LREF SysTime) will not fit in a\n            $(D SYSTEMTIME). This will only happen if the $(LREF SysTime)'s date is\n            prior to 1601 A.D.\n",
				"deco": "FNfxS3std8datetime7SysTimeZPv",
				"parameters": [
					{
						"name": "sysTime",
						"deco": "xS3std8datetime7SysTime"
					}
				],
				"originalType": "@safe SYSTEMTIME(in SysTime sysTime)",
				"char": 16,
				"kind": "function"
			},
			{
				"name": "FILETIMEToStdTime",
				"line": 30476,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(D FILETIME) struct to the number of hnsecs since midnight,\n        January 1st, 1 A.D.\n\n        Params:\n            ft = The $(D FILETIME) struct to convert.\n\n        Throws:\n            $(LREF DateTimeException) if the given $(D FILETIME) cannot be\n            represented as the return value.\n",
				"deco": "FNfxPPvZl",
				"parameters": [
					{
						"name": "ft",
						"deco": "xPPv"
					}
				],
				"originalType": "@safe long(const FILETIME* ft)",
				"char": 10,
				"kind": "function"
			},
			{
				"name": "FILETIMEToSysTime",
				"line": 30493,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(D FILETIME) struct to a $(LREF SysTime).\n\n        Params:\n            ft = The $(D FILETIME) struct to convert.\n            tz = The time zone that the $(LREF SysTime) will be in ($(D FILETIME)s\n                 are in UTC).\n\n        Throws:\n            $(LREF DateTimeException) if the given $(D FILETIME) will not fit in a\n            $(LREF SysTime).\n",
				"deco": "FNfxPPvyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "ft",
						"deco": "xPPv"
					},
					{
						"name": "tz",
						"deco": "yC3std8datetime8TimeZone",
						"default": "opCall()"
					}
				],
				"originalType": "@safe SysTime(const FILETIME* ft, immutable TimeZone tz = LocalTime())",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "stdTimeToFILETIME",
				"line": 30509,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a number of hnsecs since midnight, January 1st, 1 A.D. to a\n        $(D FILETIME) struct.\n\n        Params:\n            stdTime = The number of hnsecs since midnight, January 1st, 1 A.D. UTC.\n\n        Throws:\n            $(LREF DateTimeException) if the given value will not fit in a\n            $(D FILETIME).\n",
				"deco": "FNflZPv",
				"parameters": [
					{
						"name": "stdTime",
						"deco": "l"
					}
				],
				"originalType": "@safe FILETIME(long stdTime)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "SysTimeToFILETIME",
				"line": 30526,
				"comment": "        $(BLUE This function is Windows-Only.)\n\n        Converts a $(LREF SysTime) to a $(D FILETIME) struct.\n\n        $(D FILETIME)s are always in UTC.\n\n        Params:\n            sysTime = The $(LREF SysTime) to convert.\n\n        Throws:\n            $(LREF DateTimeException) if the given $(LREF SysTime) will not fit in a\n            $(D FILETIME).\n",
				"deco": "FNfS3std8datetime7SysTimeZPv",
				"parameters": [
					{
						"name": "sysTime",
						"deco": "S3std8datetime7SysTime"
					}
				],
				"originalType": "@safe FILETIME(SysTime sysTime)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "DosFileTime",
				"line": 30706,
				"comment": "    Type representing the DOS file date/time format.\n",
				"deco": "k",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "DosFileTimeToSysTime",
				"line": 30718,
				"comment": "    Converts from DOS file date/time to $(LREF SysTime).\n\n    Params:\n        dft = The DOS file time to convert.\n        tz  = The time zone which the DOS file time is assumed to be in.\n\n    Throws:\n        $(LREF DateTimeException) if the $(D DosFileTime) is invalid.\n",
				"deco": "FNfkyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "dft",
						"deco": "k"
					},
					{
						"name": "tz",
						"deco": "yC3std8datetime8TimeZone",
						"default": "opCall()"
					}
				],
				"endline": 30736,
				"originalType": "@safe SysTime(DosFileTime dft, immutable TimeZone tz = LocalTime())",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "SysTimeToDosFileTime",
				"line": 30761,
				"comment": "    Converts from $(LREF SysTime) to DOS file date/time.\n\n    Params:\n        sysTime = The $(LREF SysTime) to convert.\n\n    Throws:\n        $(LREF DateTimeException) if the given $(LREF SysTime) cannot be converted to\n        a $(D DosFileTime).\n",
				"deco": "FNfS3std8datetime7SysTimeZk",
				"parameters": [
					{
						"name": "sysTime",
						"deco": "S3std8datetime7SysTime"
					}
				],
				"endline": 30780,
				"originalType": "@safe DosFileTime(SysTime sysTime)",
				"char": 13,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseRFC822DateTime",
						"line": 30829,
						"type": "@safe SysTime(in char[] value)",
						"parameters": [
							{
								"name": "value",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 30833,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "parseRFC822DateTime",
				"line": 30829,
				"comment": "    The given array of $(D char) or random-access range of $(D char) or\n    $(D ubyte) is expected to be in the format specified in\n    $(WEB tools.ietf.org/html/rfc5322, RFC 5322) section 3.3 with the\n    grammar rule $(I date-time). It is the date-time format commonly used in\n    internet messages such as e-mail and HTTP. The corresponding\n    $(LREF SysTime) will be returned.\n\n    RFC 822 was the original spec (hence the function's name), whereas RFC 5322\n    is the current spec.\n\n    The day of the week is ignored beyond verifying that it's a valid day of the\n    week, as the day of the week can be inferred from the date. It is not\n    checked whether the given day of the week matches the actual day of the week\n    of the given date (though it is technically invalid per the spec if the\n    day of the week doesn't match the actual day of the week of the given date).\n\n    If the time zone is $(D \"-0000\") (or considered to be equivalent to\n    $(D \"-0000\") by section 4.3 of the spec), a $(LREF SimpleTimeZone) with a\n    utc offset of $(D 0) is used rather than $(LREF UTC), whereas $(D \"+0000\")\n    uses $(LREF UTC).\n\n    Note that because $(LREF SysTime) does not currently support having a second\n    value of 60 (as is sometimes done for leap seconds), if the date-time value\n    does have a value of 60 for the seconds, it is treated as 59.\n\n    The one area in which this function violates RFC 5322 is that it accepts\n    $(D \"\\n\") in folding whitespace in the place of $(D \"\\r\\n\"), because the\n    HTTP spec requires it.\n\n    Throws:\n        $(LREF DateTimeException) if the given string doesn't follow the grammar\n        for a date-time field or if the resulting $(LREF SysTime) is invalid.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL31039_1072)\n---\nauto tz = new immutable SimpleTimeZone(hours(-8));\nassert(parseRFC822DateTime(\"Sat, 6 Jan 1990 12:14:19 -0800\") ==\n       SysTime(DateTime(1990, 1, 6, 12, 14, 19), tz));\n\nassert(parseRFC822DateTime(\"9 Jul 2002 13:11 +0000\") ==\n       SysTime(DateTime(2002, 7, 9, 13, 11, 0), UTC()));\n\nauto badStr = \"29 Feb 2001 12:17:16 +0200\";\nassertThrown!DateTimeException(parseRFC822DateTime(badStr));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL31039_1072)\n",
				"parameters": [],
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseRFC822DateTime",
						"line": 30836,
						"type": "@safe SysTime(R value)",
						"parameters": [
							{
								"name": "value",
								"type": "R"
							}
						],
						"endline": 31036,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "parseRFC822DateTime",
				"line": 30836,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && hasLength!R && (is(Unqual!(ElementType!R) == char) || is(Unqual!(ElementType!R) == ubyte))",
				"char": 9,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "validTimeUnits",
				"line": 31561,
				"comment": "    Whether all of the given strings are valid units of time.\n\n    $(D \"nsecs\") is not considered a valid unit of time. Nothing in std.datetime\n    can handle precision greater than hnsecs, and the few functions in core.time\n    which deal with \"nsecs\" deal with it explicitly.\n",
				"deco": "FNaNbNfAAyaXb",
				"parameters": [
					{
						"name": "units",
						"deco": "AAya"
					}
				],
				"endline": 31571,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "cmpTimeUnits",
				"line": 31589,
				"comment": "    Compares two time unit strings. $(D \"years\") are the largest units and\n    $(D \"hnsecs\") are the smallest.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n\n    Throws:\n        $(LREF DateTimeException) if either of the given strings is not a valid\n        time unit string.\n",
				"deco": "FNaNfAyaAyaZi",
				"parameters": [
					{
						"name": "lhs",
						"deco": "Aya"
					},
					{
						"name": "rhs",
						"deco": "Aya"
					}
				],
				"endline": 31607,
				"char": 5,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "CmpTimeUnits",
						"line": 31647,
						"init": "cmpTimeUnitsCTFE(lhs, rhs)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "CmpTimeUnits",
				"line": 31644,
				"comment": "    Compares two time unit strings at compile time. $(D \"years\") are the largest\n    units and $(D \"hnsecs\") are the smallest.\n\n    This template is used instead of $(D cmpTimeUnits) because exceptions\n    can't be thrown at compile time and $(D cmpTimeUnits) must enforce that\n    the strings it's given are valid time unit strings. This template uses a\n    template constraint instead.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n",
				"parameters": [
					{
						"name": "lhs",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "rhs",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "validTimeUnits(lhs, rhs)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "valid",
						"line": 31706,
						"type": "pure nothrow @safe bool(int value)",
						"parameters": [
							{
								"name": "value",
								"deco": "i"
							}
						],
						"endline": 31720,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "valid",
				"line": 31706,
				"comment": "    Returns whether the given value is valid for the given unit type when in a\n    time point. Naturally, a duration is not held to a particular range, but\n    the values in a time point are (e.g. a month must be in the range of\n    1 - 12 inclusive).\n\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL31723_1085)\n---\nassert(valid!\"hours\"(12));\nassert(!valid!\"hours\"(32));\nassert(valid!\"months\"(12));\nassert(!valid!\"months\"(13));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL31723_1085)\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"months\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\"",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "valid",
						"line": 31741,
						"type": "pure nothrow @safe bool(int year, int month, int day)",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"deco": "i"
							},
							{
								"name": "day",
								"deco": "i"
							}
						],
						"endline": 31745,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "valid",
				"line": 31741,
				"comment": "    Returns whether the given day is valid for the given year and month.\n\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"days\"",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforceValid",
						"line": 31759,
						"type": "pure @safe void(int value, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "value",
								"deco": "i"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 31787,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "enforceValid",
				"line": 31759,
				"comment": "    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n        file  = The file that the $(LREF DateTimeException) will list if thrown.\n        line  = The line number that the $(LREF DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(LREF DateTimeException) if $(D valid!units(value)) is false.\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"months\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\"",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforceValid",
						"line": 31803,
						"type": "pure @safe void(int year, Month month, int day, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "year",
								"deco": "i"
							},
							{
								"name": "month",
								"type": "Month"
							},
							{
								"name": "day",
								"deco": "i"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 31810,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "enforceValid",
				"line": 31803,
				"comment": "    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n        file  = The file that the $(LREF DateTimeException) will list if thrown.\n        line  = The line number that the $(LREF DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(LREF DateTimeException) if $(D valid!\"days\"(year, month, day)) is false.\n",
				"parameters": [
					{
						"name": "units",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "units == \"days\"",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "monthsToMonth",
				"line": 31821,
				"comment": "    Returns the number of months from the current months of the year to the\n    given month of the year. If they are the same, then the result is 0.\n\n    Params:\n        currMonth = The current month of the year.\n        month     = The month of the year to get the number of months to.\n",
				"deco": "FNaNfiiZi",
				"parameters": [
					{
						"name": "currMonth",
						"deco": "i"
					},
					{
						"name": "month",
						"deco": "i"
					}
				],
				"endline": 31833,
				"char": 12,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"endchar": 1,
				"name": "daysToDayOfWeek",
				"line": 31899,
				"comment": "    Returns the number of days from the current day of the week to the given\n    day of the week. If they are the same, then the result is 0.\n\n    Params:\n        currDoW = The current day of the week.\n        dow     = The day of the week to get the number of days to.\n",
				"deco": "FNaNbNfE3std8datetime9DayOfWeekE3std8datetime9DayOfWeekZi",
				"parameters": [
					{
						"name": "currDoW",
						"deco": "E3std8datetime9DayOfWeek"
					},
					{
						"name": "dow",
						"deco": "E3std8datetime9DayOfWeek"
					}
				],
				"endline": 31908,
				"char": 12,
				"kind": "function",
				"storageClass": [
					"static"
				]
			},
			{
				"members": [
					{
						"name": "measureTime",
						"line": 32006,
						"type": "()",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "measureTime",
				"line": 32006,
				"comment": "        Function for starting to a stop watch time when the function is called\n        and stopping it when its return value goes out of scope and is destroyed.\n\n        When the value that is returned by this function is destroyed,\n        $(D func) will run. $(D func) is a unary function that takes a\n        $(CXREF time, TickDuration).\n\n        Examples:\n--------------------\n{\n    auto mt = measureTime!((TickDuration a)\n        { /+ do something when the scope is exited +/ });\n    // do something that needs to be timed\n}\n--------------------\n\n        which is functionally equivalent to\n\n--------------------\n{\n    auto sw = StopWatch(AutoStart.yes);\n    scope(exit)\n    {\n        TickDuration a = sw.peek();\n        /+ do something when the scope is exited +/\n    }\n    // do something that needs to be timed\n}\n--------------------\n\n        See_Also:\n            $(LREF benchmark)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"char": 10,
				"kind": "template"
			}
		],
		"comment": "    Module containing Date/Time functionality.\n\n    This module provides:\n    $(UL\n        $(LI Types to represent points in time: $(LREF SysTime), $(LREF Date),\n             $(LREF TimeOfDay), and $(LREF2 .DateTime, DateTime).)\n        $(LI Types to represent intervals of time.)\n        $(LI Types to represent ranges over intervals of time.)\n        $(LI Types to represent time zones (used by $(LREF SysTime)).)\n        $(LI A platform-independent, high precision stopwatch type:\n             $(LREF StopWatch))\n        $(LI Benchmarking functions.)\n        $(LI Various helper functions.)\n    )\n\n    Closely related to std.datetime is <a href=\"core_time.html\">$(D core.time)</a>,\n    and some of the time types used in std.datetime come from there - such as\n    $(CXREF time, Duration), $(CXREF time, TickDuration), and\n    $(CXREF time, FracSec).\n    core.time is publically imported into std.datetime, it isn't necessary\n    to import it separately.\n\n    Three of the main concepts used in this module are time points, time\n    durations, and time intervals.\n\n    A time point is a specific point in time. e.g. January 5th, 2010\n    or 5:00.\n\n    A time duration is a length of time with units. e.g. 5 days or 231 seconds.\n\n    A time interval indicates a period of time associated with a fixed point in\n    time. It is either two time points associated with each other,\n    indicating the time starting at the first point up to, but not including,\n    the second point - e.g. [January 5th, 2010 - March 10th, 2010$(RPAREN) - or\n    it is a time point and a time duration associated with one another. e.g.\n    January 5th, 2010 and 5 days, indicating [January 5th, 2010 -\n    January 10th, 2010$(RPAREN).\n\n    Various arithmetic operations are supported between time points and\n    durations (e.g. the difference between two time points is a time duration),\n    and ranges can be gotten from time intervals, so range-based operations may\n    be done on a series of time points.\n\n    The types that the typical user is most likely to be interested in are\n    $(LREF Date) (if they want dates but don't care about time), $(LREF DateTime)\n    (if they want dates and times but don't care about time zones), $(LREF SysTime)\n    (if they want the date and time from the OS and/or do care about time\n    zones), and StopWatch (a platform-independent, high precision stop watch).\n    $(LREF Date) and $(LREF DateTime) are optimized for calendar-based operations,\n    while $(LREF SysTime) is designed for dealing with time from the OS. Check out\n    their specific documentation for more details.\n\n    To get the current time, use $(LREF2 .Clock.currTime, Clock.currTime).\n    It will return the current\n    time as a $(LREF SysTime). To print it, $(D toString) is\n    sufficient, but if using $(D toISOString), $(D toISOExtString), or\n    $(D toSimpleString), use the corresponding $(D fromISOString),\n    $(D fromISOExtString), or $(D fromSimpleString) to create a\n    $(LREF SysTime) from the string.\n\n--------------------\nauto currentTime = Clock.currTime();\nauto timeString = currentTime.toISOExtString();\nauto restoredTime = SysTime.fromISOExtString(timeString);\n--------------------\n\n    Various functions take a string (or strings) to represent a unit of time\n    (e.g. $(D convert!(\"days\", \"hours\")(numDays))). The valid strings to use\n    with such functions are $(D \"years\"), $(D \"months\"), $(D \"weeks\"),\n    $(D \"days\"), $(D \"hours\"), $(D \"minutes\"), $(D \"seconds\"),\n    $(D \"msecs\") (milliseconds), $(D \"usecs\") (microseconds),\n    $(D \"hnsecs\") (hecto-nanoseconds - i.e. 100 ns), or some subset thereof.\n    There are a few functions in core.time which take $(D \"nsecs\"), but because\n    nothing in std.datetime has precision greater than hnsecs, and very little\n    in core.time does, no functions in std.datetime accept $(D \"nsecs\").\n    To remember which units are abbreviated and which aren't,\n    all units seconds and greater use their full names, and all\n    sub-second units are abbreviated (since they'd be rather long if they\n    weren't).\n\n    Note:\n        $(LREF DateTimeException) is an alias for $(CXREF time, TimeException),\n        so you don't need to worry about core.time functions and std.datetime\n        functions throwing different exception types (except in the rare case\n        that they throw something other than $(CXREF time, TimeException) or\n        $(LREF DateTimeException)).\n\n    See_Also:\n        <a href=\"../intro-to-datetime.html\">Introduction to std&#46;_datetime </a><br>\n        $(WEB en.wikipedia.org/wiki/ISO_8601, ISO 8601)<br>\n        $(WEB en.wikipedia.org/wiki/Tz_database,\n              Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones,\n              List of Time Zones)<br>\n\n    Copyright: Copyright 2010 - 2011\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Jonathan M Davis and Kato Shoichi\n    Source:    $(PHOBOSSRC std/_datetime.d)\n    Macros:\n        LREF2=<a href=\"#$1\">$(D $2)</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/socket.d",
		"name": "std.socket",
		"members": [
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 149,
						"comment": "\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6socket15SocketException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 152,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 155,
						"comment": "\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC3std6socket15SocketException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 158,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketException",
				"line": 146,
				"comment": "Base exception thrown by $(D std.socket).\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "lastSocketError",
				"line": 229,
				"comment": "Retrieve the error message for the most recently encountered network error.\n",
				"deco": "FNdNfZAya",
				"endline": 232,
				"char": 18,
				"kind": "function"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "errorCode",
						"line": 238,
						"comment": "Platform-specific error code.\n",
						"deco": "i",
						"char": 9,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 241,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiPFNeiZAyaZC3std6socket17SocketOSException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							},
							{
								"name": "errorFormatter",
								"deco": "PFNeiZAya",
								"default": "& formatSocketError"
							}
						],
						"endline": 254,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr(), string function(int) @trusted errorFormatter = &formatSocketError)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 257,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiPFNeiZAyaZC3std6socket17SocketOSException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							},
							{
								"name": "errorFormatter",
								"deco": "PFNeiZAya",
								"default": "& formatSocketError"
							}
						],
						"endline": 265,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr(), string function(int) @trusted errorFormatter = &formatSocketError)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 268,
						"comment": "\n",
						"deco": "FNfAyaiPFNeiZAyaAyamC6object9ThrowableZC3std6socket17SocketOSException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "errorFormatter",
								"deco": "PFNeiZAya",
								"default": "& formatSocketError"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 276,
						"originalType": "@safe (string msg, int err, string function(int) @trusted errorFormatter = &formatSocketError, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketOSException",
				"line": 236,
				"comment": "Socket exceptions representing network errors reported by the operating\n\nsystem.\n",
				"base": "std.socket.SocketException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 283,
						"comment": "\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6socket24SocketParameterException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 286,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 289,
						"comment": "\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC3std6socket24SocketParameterException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 292,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketParameterException",
				"line": 280,
				"comment": "Socket exceptions representing invalid parameters specified by user code.\n",
				"base": "std.socket.SocketException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 300,
						"comment": "\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6socket22SocketFeatureException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 303,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 306,
						"comment": "\n",
						"deco": "FNaNbNfAyaC6object9ThrowableAyamZC3std6socket22SocketFeatureException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 309,
						"originalType": "pure nothrow @safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketFeatureException",
				"line": 297,
				"comment": "Socket exceptions representing attempts to use network capabilities not\n\navailable on the current system.\n",
				"base": "std.socket.SocketException",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "wouldHaveBlocked",
				"line": 315,
				"comment": "Return $(D true) if the last socket operation failed because the socket\n\nwas in non-blocking mode and the operation would have blocked.\n",
				"deco": "FNbNiNfZb",
				"endline": 323,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "UNSPEC",
						"line": 381,
						"value": "0",
						"comment": "Unspecified address family\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UNIX",
						"line": 382,
						"value": "1",
						"comment": "Local communication\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "INET",
						"line": 383,
						"value": "2",
						"comment": "Internet Protocol version 4\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPX",
						"line": 384,
						"value": "4",
						"comment": "Novell IPX\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "APPLETALK",
						"line": 385,
						"value": "5",
						"comment": "AppleTalk\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "INET6",
						"line": 386,
						"value": "10",
						"comment": "Internet Protocol version 6\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AddressFamily",
				"line": 379,
				"comment": " The communication domain used to resolve an address.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "STREAM",
						"line": 395,
						"value": "1",
						"comment": "Sequenced, reliable, two-way communication-based byte streams\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "DGRAM",
						"line": 396,
						"value": "2",
						"comment": "Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RAW",
						"line": 397,
						"value": "3",
						"comment": "Raw protocol access\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RDM",
						"line": 398,
						"value": "4",
						"comment": "Reliably-delivered message datagrams\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SEQPACKET",
						"line": 399,
						"value": "5",
						"comment": "Sequenced, reliable, two-way connection-based datagrams with a fixed maximum length\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketType",
				"line": 393,
				"comment": " Communication semantics\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "IP",
						"line": 408,
						"value": "0",
						"comment": "Internet Protocol version 4\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ICMP",
						"line": 409,
						"value": "1",
						"comment": "Internet Control Message Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IGMP",
						"line": 410,
						"value": "2",
						"comment": "Internet Group Management Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "GGP",
						"line": 411,
						"value": "3",
						"comment": "Gateway to Gateway Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TCP",
						"line": 412,
						"value": "6",
						"comment": "Transmission Control Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "PUP",
						"line": 413,
						"value": "12",
						"comment": "PARC Universal Packet Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UDP",
						"line": 414,
						"value": "17",
						"comment": "User Datagram Protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IDP",
						"line": 415,
						"value": "22",
						"comment": "Xerox NS protocol\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RAW",
						"line": 416,
						"value": "255",
						"comment": "Raw IP packets\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6",
						"line": 417,
						"value": "41",
						"comment": "Internet Protocol version 6\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ProtocolType",
				"line": 406,
				"comment": " Protocol\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Protocol",
				"line": 438,
				"comment": " $(D Protocol) is a class for retrieving protocol information.\n\n Example:\n ---\n auto proto = new Protocol;\n writeln(\"About protocol TCP:\");\n if (proto.getProtocolByType(ProtocolType.TCP))\n {\n     writefln(\"  Name: %s\", proto.name);\n     foreach(string s; proto.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writeln(\"  No information found\");\n ---\n",
				"members": [
					{
						"offset": 16,
						"name": "type",
						"line": 441,
						"comment": "These members are populated when one of the following functions are called successfully:\n",
						"deco": "E3std6socket12ProtocolType",
						"char": 18,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 24,
						"name": "name",
						"line": 442,
						"comment": "ditto\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 40,
						"name": "aliases",
						"line": 443,
						"comment": "ditto\n",
						"deco": "AAya",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "getProtocolByName",
						"line": 474,
						"comment": " Returns: false on failure\n",
						"deco": "FNbNexAaZb",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 482,
						"originalType": "nothrow @trusted bool(in char[] name)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getProtocolByType",
						"line": 487,
						"comment": " Returns: false on failure\n",
						"deco": "FNbNeE3std6socket12ProtocolTypeZb",
						"parameters": [
							{
								"name": "type",
								"deco": "E3std6socket12ProtocolType"
							}
						],
						"endline": 495,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Service",
				"line": 536,
				"comment": " $(D Service) is a class for retrieving service information.\n\n Example:\n ---\n auto serv = new Service;\n writeln(\"About service epmap:\");\n if (serv.getServiceByName(\"epmap\", \"tcp\"))\n {\n     writefln(\"  Service: %s\", serv.name);\n     writefln(\"  Port: %d\", serv.port);\n     writefln(\"  Protocol: %s\", serv.protocolName);\n     foreach (string s; serv.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writefln(\"  No service for epmap.\");\n ---\n",
				"members": [
					{
						"offset": 16,
						"name": "name",
						"line": 539,
						"comment": "These members are populated when one of the following functions are called successfully:\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 32,
						"name": "aliases",
						"line": 540,
						"comment": "ditto\n",
						"deco": "AAya",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 48,
						"name": "port",
						"line": 541,
						"comment": "ditto\n",
						"deco": "t",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 56,
						"name": "protocolName",
						"line": 542,
						"comment": "ditto\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "getServiceByName",
						"line": 577,
						"comment": " If a protocol name is omitted, any protocol will be matched.\n Returns: false on failure.\n",
						"deco": "FNbNexAaxAaZb",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "protocolName",
								"deco": "xAa",
								"default": "null"
							}
						],
						"endline": 585,
						"originalType": "nothrow @trusted bool(in char[] name, in char[] protocolName = null)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getServiceByPort",
						"line": 589,
						"comment": "ditto\n",
						"deco": "FNbNetxAaZb",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							},
							{
								"name": "protocolName",
								"deco": "xAa",
								"default": "null"
							}
						],
						"endline": 597,
						"originalType": "nothrow @trusted bool(ushort port, in char[] protocolName = null)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 634,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiZC3std6socket13HostException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 637,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 640,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiZC3std6socket13HostException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 643,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 646,
						"comment": "\n",
						"deco": "FNfAyaiAyamC6object9ThrowableZC3std6socket13HostException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 649,
						"originalType": "@safe (string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "HostException",
				"line": 631,
				"comment": " Class for exceptions thrown from an $(D InternetHost).\n",
				"base": "std.socket.SocketOSException",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "InternetHost",
				"line": 688,
				"comment": " $(D InternetHost) is a class for resolving IPv4 addresses.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n\n Example:\n ---\n auto ih = new InternetHost;\n\n // Forward lookup\n writeln(\"About www.digitalmars.com:\");\n if (ih.getHostByName(\"www.digitalmars.com\"))\n {\n     writefln(\"  Name: %s\", ih.name);\n     auto ip = InternetAddress.addrToString(ih.addrList[0]);\n     writefln(\"  IP address: %s\", ip);\n     foreach (string s; ih.aliases)\n          writefln(\"  Alias: %s\", s);\n     writeln(\"---\");\n\n     // Reverse lookup\n     writefln(\"About IP %s:\", ip);\n     if (ih.getHostByAddr(ih.addrList[0]))\n     {\n         writefln(\"  Name: %s\", ih.name);\n         foreach (string s; ih.aliases)\n              writefln(\"  Alias: %s\", s);\n     }\n     else\n         writeln(\"  Reverse lookup failed\");\n }\n else\n     writeln(\"  Can't resolve www.digitalmars.com\");\n ---\n",
				"members": [
					{
						"offset": 16,
						"name": "name",
						"line": 691,
						"comment": "These members are populated when one of the following functions are called successfully:\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 32,
						"name": "aliases",
						"line": 692,
						"comment": "ditto\n",
						"deco": "AAya",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 48,
						"name": "addrList",
						"line": 693,
						"comment": "ditto\n",
						"deco": "Ak",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "getHostByName",
						"line": 779,
						"comment": " Resolve host name.\n Returns: false if unable to resolve.\n",
						"deco": "FNexAaZb",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							}
						],
						"endline": 806,
						"originalType": "@trusted bool(in char[] name)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getHostByAddr",
						"line": 816,
						"comment": " Resolve IPv4 address number.\n\n Params:\n   addr = The IPv4 address to resolve, in host byte order.\n Returns:\n   false if unable to resolve.\n",
						"deco": "FNekZb",
						"parameters": [
							{
								"name": "addr",
								"deco": "k"
							}
						],
						"endline": 822,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getHostByAddr",
						"line": 829,
						"comment": " Same as previous, but addr is an IPv4 address string in the\n dotted-decimal form $(I a.b.c.d).\n Returns: false if unable to resolve.\n",
						"deco": "FNexAaZb",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							}
						],
						"endline": 837,
						"originalType": "@trusted bool(in char[] addr)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"name": "AddressInfo",
				"line": 877,
				"comment": "Holds information about a socket _address retrieved by $(D getAddressInfo).\n",
				"members": [
					{
						"offset": 0,
						"name": "family",
						"line": 879,
						"comment": "Address _family\n",
						"deco": "E3std6socket13AddressFamily",
						"char": 19,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 4,
						"name": "type",
						"line": 880,
						"comment": "Socket _type\n",
						"deco": "E3std6socket10SocketType",
						"char": 16,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 8,
						"name": "protocol",
						"line": 881,
						"comment": "Protocol\n",
						"deco": "E3std6socket12ProtocolType",
						"char": 18,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 16,
						"name": "address",
						"line": 882,
						"comment": "Socket _address\n",
						"deco": "C3std6socket7Address",
						"originalType": "Address",
						"char": 13,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 24,
						"name": "canonicalName",
						"line": 883,
						"comment": "Canonical name, when $(D AddressInfoFlags.CANONNAME) is used.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "PASSIVE",
						"line": 891,
						"value": "1",
						"comment": "The resulting addresses will be used in a call to $(D Socket.bind).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "CANONNAME",
						"line": 894,
						"value": "2",
						"comment": "The canonical name is returned in $(D canonicalName) member in the first $(D AddressInfo).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "NUMERICHOST",
						"line": 898,
						"value": "4",
						"comment": "The $(D node) parameter passed to $(D getAddressInfo) must be a numeric string.\n\nThis will suppress any potentially lengthy network host address lookups.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "AddressInfoFlags",
				"line": 888,
				"comment": "Specifies option flags for $(D getAddressInfo).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "getAddressInfo",
						"line": 969,
						"type": "@trusted AddressInfo[](in char[] node, T options)",
						"parameters": [
							{
								"name": "node",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "options",
								"type": "T"
							}
						],
						"endline": 996,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "getAddressInfo",
				"line": 969,
				"comment": " Provides _protocol-independent translation from host names to socket\n addresses. If advanced functionality is not required, consider using\n $(D getAddress) for compatibility with older systems.\n\n Returns: Array with one $(D AddressInfo) per socket address.\n\n Throws: $(D SocketOSException) on failure, or $(D SocketFeatureException)\n if this functionality is not available on the current system.\n\n Params:\n  node     = string containing host name or numeric address\n  options  = optional additional parameters, identified by type:\n             $(UL $(LI $(D string) - service name or port number)\n                  $(LI $(D AddressInfoFlags) - option flags)\n                  $(LI $(D AddressFamily) - address family to filter by)\n                  $(LI $(D SocketType) - socket type to filter by)\n                  $(LI $(D ProtocolType) - protocol to filter by))\n\n Example:\n ---\n // Roundtrip DNS resolution\n auto results = getAddressInfo(\"www.digitalmars.com\");\n assert(results[0].address.toHostNameString() ==\n     \"digitalmars.com\");\n\n // Canonical name\n results = getAddressInfo(\"www.digitalmars.com\",\n     AddressInfoFlags.CANONNAME);\n assert(results[0].canonicalName == \"digitalmars.com\");\n\n // IPv6 resolution\n results = getAddressInfo(\"ipv6.google.com\");\n assert(results[0].family == AddressFamily.INET6);\n\n // Multihomed resolution\n results = getAddressInfo(\"google.com\");\n assert(results.length > 1);\n\n // Parsing IPv4\n results = getAddressInfo(\"127.0.0.1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET);\n\n // Parsing IPv6\n results = getAddressInfo(\"::1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET6);\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "getAddress",
				"line": 1104,
				"comment": " Provides _protocol-independent translation from host names to socket\n addresses. Uses $(D getAddressInfo) if the current system supports it,\n and $(D InternetHost) otherwise.\n\n Returns: Array with one $(D Address) instance per socket address.\n\n Throws: $(D SocketOSException) on failure.\n\n Example:\n ---\n writeln(\"Resolving www.digitalmars.com:\");\n try\n {\n     auto addresses = getAddress(\"www.digitalmars.com\");\n     foreach (address; addresses)\n         writefln(\"  IP: %s\", address.toAddrString());\n }\n catch (SocketException e)\n     writefln(\"  Lookup failed: %s\", e.msg);\n ---\n",
				"deco": "FNfxAaxAaZAC3std6socket7Address",
				"parameters": [
					{
						"name": "hostname",
						"deco": "xAa"
					},
					{
						"name": "service",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1118,
				"originalType": "@safe Address[](in char[] hostname, in char[] service = null)",
				"char": 11,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getAddress",
				"line": 1121,
				"comment": "ditto\n",
				"deco": "FNfxAatZAC3std6socket7Address",
				"parameters": [
					{
						"name": "hostname",
						"deco": "xAa"
					},
					{
						"name": "port",
						"deco": "t"
					}
				],
				"endline": 1138,
				"originalType": "@safe Address[](in char[] hostname, ushort port)",
				"char": 11,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "parseAddress",
				"line": 1198,
				"comment": " Provides _protocol-independent parsing of network addresses. Does not\n attempt name resolution. Uses $(D getAddressInfo) with\n $(D AddressInfoFlags.NUMERICHOST) if the current system supports it, and\n $(D InternetAddress) otherwise.\n\n Returns: An $(D Address) instance representing specified address.\n\n Throws: $(D SocketException) on failure.\n\n Example:\n ---\n writeln(\"Enter IP address:\");\n string ip = readln().chomp();\n try\n {\n     Address address = parseAddress(ip);\n     writefln(\"Looking up reverse of %s:\",\n         address.toAddrString());\n     try\n     {\n         string reverse = address.toHostNameString();\n         if (reverse)\n             writefln(\"  Reverse name: %s\", reverse);\n         else\n             writeln(\"  Reverse hostname not found.\");\n     }\n     catch (SocketException e)\n         writefln(\"  Lookup error: %s\", e.msg);\n }\n catch (SocketException e)\n {\n     writefln(\"  %s is not a valid IP address: %s\",\n         ip, e.msg);\n }\n ---\n",
				"deco": "FNfxAaxAaZC3std6socket7Address",
				"parameters": [
					{
						"name": "hostaddr",
						"deco": "xAa"
					},
					{
						"name": "service",
						"deco": "xAa",
						"default": "null"
					}
				],
				"endline": 1204,
				"originalType": "@safe Address(in char[] hostaddr, in char[] service = null)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "parseAddress",
				"line": 1207,
				"comment": "ditto\n",
				"deco": "FNfxAatZC3std6socket7Address",
				"parameters": [
					{
						"name": "hostaddr",
						"deco": "xAa"
					},
					{
						"name": "port",
						"deco": "t"
					}
				],
				"endline": 1218,
				"originalType": "@safe Address(in char[] hostaddr, ushort port)",
				"char": 9,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1249,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiZC3std6socket16AddressException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 1252,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1255,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiZC3std6socket16AddressException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 1258,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1261,
						"comment": "\n",
						"deco": "FNfAyaiAyamC6object9ThrowableZC3std6socket16AddressException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 1264,
						"originalType": "@safe (string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "AddressException",
				"line": 1246,
				"comment": " Class for exceptions thrown from an $(D Address).\n",
				"base": "std.socket.SocketOSException",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Address",
				"line": 1292,
				"comment": " $(D Address) is an abstract class for representing a socket addresses.\n\n Example:\n ---\n writeln(\"About www.google.com port 80:\");\n try\n {\n     Address[] addresses = getAddress(\"www.google.com\", 80);\n     writefln(\"  %d addresses found.\", addresses.length);\n     foreach (int i, Address a; addresses)\n     {\n         writefln(\"  Address %d:\", i+1);\n         writefln(\"    IP address: %s\", a.toAddrString());\n         writefln(\"    Hostname: %s\", a.toHostNameString());\n         writefln(\"    Port: %s\", a.toPortString());\n         writefln(\"    Service name: %s\",\n             a.toServiceNameString());\n     }\n }\n catch (SocketException e)\n     writefln(\"  Lookup error: %s\", e.msg);\n ---\n",
				"members": [
					{
						"name": "name",
						"line": 1295,
						"comment": "Returns pointer to underlying $(D sockaddr) structure.\n",
						"deco": "FNaNbNdNiNfZPS4core3sys5posix3sys6socket8sockaddr",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "name",
						"line": 1296,
						"comment": "ditto\n",
						"deco": "xFNaNbNdNiNfZPxS4core3sys5posix3sys6socket8sockaddr",
						"char": 41,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "nameLen",
						"line": 1299,
						"comment": "Returns actual size of underlying $(D sockaddr) structure.\n",
						"deco": "xFNaNbNdNiNfZk",
						"originalType": "const pure nothrow @nogc @property @safe socklen_t()",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 5,
						"name": "addressFamily",
						"line": 1302,
						"comment": "Family of this address.\n",
						"deco": "xFNaNbNdNiNfZE3std6socket13AddressFamily",
						"endline": 1305,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toAddrString",
						"line": 1375,
						"comment": " Attempts to retrieve the host address as a human-readable string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if address retrieval for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1378,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHostNameString",
						"line": 1390,
						"comment": " Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D Address), or $(D null) if\n the host name did not resolve.\n\n Throws: $(D AddressException) on error, or $(D SocketFeatureException)\n if host name lookup for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1393,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toPortString",
						"line": 1402,
						"comment": " Attempts to retrieve the numeric port number as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if port number retrieval for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1405,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toServiceNameString",
						"line": 1414,
						"comment": " Attempts to retrieve the service name as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if service name lookup for this address family is not available on the\n current system.\n",
						"deco": "xFNfZAya",
						"endline": 1417,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1420,
						"comment": "Human readable string representing this address.\n",
						"deco": "xFNfZAya",
						"endline": 1433,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [],
				"name": "UnknownAddress",
				"line": 1439,
				"comment": " $(D UnknownAddress) encapsulates an unknown socket address.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1477,
						"comment": "Constructs an $(D Address) with a reference to the specified $(D sockaddr).\n",
						"deco": "FNaNbNiNfPS4core3sys5posix3sys6socket8sockaddrkZC3std6socket23UnknownAddressReference",
						"parameters": [
							{
								"name": "sa",
								"deco": "PS4core3sys5posix3sys6socket8sockaddr"
							},
							{
								"name": "len",
								"deco": "k"
							}
						],
						"endline": 1481,
						"originalType": "pure nothrow @nogc @safe (sockaddr* sa, socklen_t len)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1484,
						"comment": "Constructs an $(D Address) with a copy of the specified $(D sockaddr).\n",
						"deco": "FNaNbPxS4core3sys5posix3sys6socket8sockaddrkZC3std6socket23UnknownAddressReference",
						"parameters": [
							{
								"name": "sa",
								"deco": "PxS4core3sys5posix3sys6socket8sockaddr"
							},
							{
								"name": "len",
								"deco": "k"
							}
						],
						"endline": 1488,
						"originalType": "pure nothrow @system (const(sockaddr)* sa, socklen_t len)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "UnknownAddressReference",
				"line": 1469,
				"comment": " $(D UnknownAddressReference) encapsulates a reference to an arbitrary\n socket address.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "ADDR_ANY",
						"line": 1544,
						"comment": "Any IPv4 host address.\n",
						"deco": "k",
						"init": "0u",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"name": "ADDR_NONE",
						"line": 1545,
						"comment": "An invalid IPv4 host address.\n",
						"deco": "k",
						"init": "4294967295u",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"name": "PORT_ANY",
						"line": 1546,
						"comment": "Any IPv4 port number.\n",
						"deco": "t",
						"init": "cast(ushort)0u",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "port",
						"line": 1549,
						"comment": "Returns the IPv4 _port number (in host byte order).\n",
						"deco": "xFNaNbNdNiNfZt",
						"endline": 1552,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addr",
						"line": 1555,
						"comment": "Returns the IPv4 address number (in host byte order).\n",
						"deco": "xFNaNbNdNiNfZk",
						"endline": 1558,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1568,
						"comment": " Construct a new $(D InternetAddress).\n Params:\n   addr = an IPv4 address string in the dotted-decimal form a.b.c.d,\n          or a host name which will be resolved using an $(D InternetHost)\n          object.\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNfxAatZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1583,
						"originalType": "@safe (in char[] addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1591,
						"comment": " Construct a new $(D InternetAddress).\n Params:\n   addr = (optional) an IPv4 address in host byte order, may be $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNaNbNiNfktZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "k"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1596,
						"originalType": "pure nothrow @nogc @safe (uint addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1599,
						"comment": "ditto\n",
						"deco": "FNaNbNiNftZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1604,
						"originalType": "pure nothrow @nogc @safe (ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1611,
						"comment": " Construct a new $(D InternetAddress).\n Params:\n   addr = A sockaddr_in as obtained from lower-level API calls such as getifaddrs.\n",
						"deco": "FNaNbNiNfS4core3sys5posix7netinet3in_11sockaddr_inZC3std6socket15InternetAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "S4core3sys5posix7netinet3in_11sockaddr_in"
							}
						],
						"endline": 1615,
						"originalType": "pure nothrow @nogc @safe (sockaddr_in addr)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "toAddrString",
						"line": 1618,
						"comment": "Human readable string representing the IPv4 address in dotted-decimal form.\n",
						"deco": "xFNeZAya",
						"endline": 1621,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toAddrString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toPortString",
						"line": 1624,
						"comment": "Human readable string representing the IPv4 port.\n",
						"deco": "xFNfZAya",
						"endline": 1627,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toPortString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toHostNameString",
						"line": 1637,
						"comment": " Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D InternetAddress), or\n $(D null) if the host name did not resolve.\n\n Throws: $(D AddressException) on error.\n",
						"deco": "xFNfZAya",
						"endline": 1656,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toHostNameString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1668,
						"comment": " Compares with another InternetAddress of same type for equality\n Returns: true if the InternetAddresses share the same address and\n port number.\n Examples:\n --------------\n InternetAddress addr1,addr2;\n if (addr1 == addr2) { }\n --------------\n",
						"deco": "xFNfC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1673,
						"char": 19,
						"kind": "function",
						"overrides": [
							"object.Object.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "parse",
						"line": 1681,
						"comment": " Parse an IPv4 address string in the dotted-decimal form $(I a.b.c.d)\n and return the number.\n Returns: If the string is not a legitimate IPv4 address,\n $(D ADDR_NONE) is returned.\n",
						"deco": "FNbNexAaZk",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							}
						],
						"endline": 1684,
						"originalType": "nothrow @trusted uint(in char[] addr)",
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "addrToString",
						"line": 1690,
						"comment": " Convert an IPv4 address number in host byte order to a human readable\n string representing the IPv4 address in dotted-decimal form.\n",
						"deco": "FNbNekZAya",
						"parameters": [
							{
								"name": "addr",
								"deco": "k"
							}
						],
						"endline": 1695,
						"char": 19,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "InternetAddress",
				"line": 1515,
				"comment": " $(D InternetAddress) encapsulates an IPv4 (Internet Protocol version 4)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "ADDR_ANY",
						"line": 1794,
						"comment": "Any IPv6 host address.\n",
						"deco": "FNaNbNcNdNiNfZxG16h",
						"endline": 1809,
						"originalType": "pure nothrow @nogc @property ref @safe const(ubyte)[16]()",
						"char": 43,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "PORT_ANY",
						"line": 1812,
						"comment": "Any IPv6 port number.\n",
						"deco": "t",
						"init": "cast(ushort)0u",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "port",
						"line": 1815,
						"comment": "Returns the IPv6 port number.\n",
						"deco": "xFNaNbNdNiNfZt",
						"endline": 1818,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addr",
						"line": 1821,
						"comment": "Returns the IPv6 address.\n",
						"deco": "xFNaNbNdNiNfZG16h",
						"endline": 1824,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1833,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr    = an IPv6 host address string in the form described in RFC 2373,\n             or a host name which will be resolved using $(D getAddressInfo).\n   service = (optional) service name.\n",
						"deco": "FNexAaxAaZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							},
							{
								"name": "service",
								"deco": "xAa",
								"default": "null"
							}
						],
						"endline": 1838,
						"originalType": "@trusted (in char[] addr, in char[] service = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1847,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr = an IPv6 host address string in the form described in RFC 2373,\n          or a host name which will be resolved using $(D getAddressInfo).\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNfxAatZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1853,
						"originalType": "@safe (in char[] addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1862,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr = (optional) an IPv6 host address in host byte order, or\n          $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n",
						"deco": "FNaNbNiNfG16htZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "G16h"
							},
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1867,
						"originalType": "pure nothrow @nogc @safe (ubyte[16] addr, ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1870,
						"comment": "ditto\n",
						"deco": "FNaNbNiNftZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"endline": 1875,
						"originalType": "pure nothrow @nogc @safe (ushort port)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1882,
						"comment": " Construct a new $(D Internet6Address).\n Params:\n   addr = A sockaddr_in6 as obtained from lower-level API calls such as getifaddrs.\n",
						"deco": "FNaNbNiNfS4core3sys5posix7netinet3in_12sockaddr_in6ZC3std6socket16Internet6Address",
						"parameters": [
							{
								"name": "addr",
								"deco": "S4core3sys5posix7netinet3in_12sockaddr_in6"
							}
						],
						"endline": 1886,
						"originalType": "pure nothrow @nogc @safe (sockaddr_in6 addr)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "parse",
						"line": 1893,
						"comment": " Parse an IPv6 host address string as described in RFC 2373, and return the\n address.\n Throws: $(D SocketException) on error.\n",
						"deco": "FNexAaZG16h",
						"parameters": [
							{
								"name": "addr",
								"deco": "xAa"
							}
						],
						"endline": 1902,
						"originalType": "@trusted ubyte[16](in char[] addr)",
						"char": 22,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "Internet6Address",
				"line": 1764,
				"comment": " $(D Internet6Address) encapsulates an IPv6 (Internet Protocol version 6)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n",
				"base": "std.socket.Address",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 32,
						"name": "this",
						"line": 1948,
						"comment": "Construct a new $(D UnixAddress) from the specified path.\n",
						"deco": "FNfxAaZC3std6socket11UnixAddress",
						"parameters": [
							{
								"name": "path",
								"deco": "xAa"
							}
						],
						"endline": 1948,
						"originalType": "@safe (in char[] path)",
						"char": 9,
						"kind": "constructor"
					},
					{
						"endchar": 53,
						"name": "this",
						"line": 1955,
						"comment": " Construct a new $(D UnixAddress).\n Params:\n   addr = A sockaddr_un as obtained from lower-level API calls.\n",
						"deco": "FNaNbNiNfS4core3sys5posix3sys2un11sockaddr_unZC3std6socket11UnixAddress",
						"parameters": [
							{
								"name": "addr",
								"deco": "S4core3sys5posix3sys2un11sockaddr_un"
							}
						],
						"endline": 1955,
						"originalType": "pure nothrow @nogc @safe (sockaddr_un addr)",
						"char": 9,
						"kind": "constructor"
					},
					{
						"endchar": 54,
						"name": "path",
						"line": 1958,
						"comment": "Get the underlying _path.\n",
						"deco": "xFNdNfZAya",
						"endline": 1958,
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 57,
						"name": "toString",
						"line": 1961,
						"comment": "ditto\n",
						"deco": "xFNfZAya",
						"endline": 1961,
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.socket.Address.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "UnixAddress",
				"line": 1943,
				"comment": " $(D UnixAddress) encapsulates an address for a Unix domain socket\n ($(D AF_UNIX)). Available only on supported systems.\n",
				"base": "std.socket.Address",
				"char": 5,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2073,
						"comment": "\n",
						"deco": "FNfAyaAyamC6object9ThrowableiZC3std6socket21SocketAcceptException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 2076,
						"originalType": "@safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2079,
						"comment": "\n",
						"deco": "FNfAyaC6object9ThrowableAyamiZC3std6socket21SocketAcceptException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "err",
								"deco": "i",
								"default": "_lasterr()"
							}
						],
						"endline": 2082,
						"originalType": "@safe (string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2085,
						"comment": "\n",
						"deco": "FNfAyaiAyamC6object9ThrowableZC3std6socket21SocketAcceptException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "err",
								"deco": "i"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 2088,
						"originalType": "@safe (string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "SocketAcceptException",
				"line": 2070,
				"comment": " Class for exceptions thrown by $(D Socket.accept).\n",
				"base": "std.socket.SocketOSException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "RECEIVE",
						"line": 2094,
						"value": "0",
						"comment": "socket receives are disallowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SEND",
						"line": 2095,
						"value": "1",
						"comment": "socket sends are disallowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "BOTH",
						"line": 2096,
						"value": "2",
						"comment": "both RECEIVE and SEND\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketShutdown",
				"line": 2092,
				"comment": "How a socket is shutdown:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "NONE",
						"line": 2103,
						"value": "0",
						"comment": "no flags specified\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "OOB",
						"line": 2105,
						"value": "1",
						"comment": "out-of-band stream data\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "PEEK",
						"line": 2106,
						"value": "2",
						"comment": "peek at incoming data without removing it from the queue, only for receiving\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "DONTROUTE",
						"line": 2107,
						"value": "4",
						"comment": "data should not be subject to routing; this flag may be ignored. Only for sending\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketFlags",
				"line": 2101,
				"comment": "Flags may be OR'ed together:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "TimeVal",
				"line": 2129,
				"comment": "Duration timeout value.\n",
				"members": [
					{
						"offset": 16,
						"name": "seconds",
						"line": 2137,
						"comment": "Number of _seconds.\n",
						"deco": "l",
						"originalType": "tv_sec_t",
						"char": 18,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 24,
						"name": "microseconds",
						"line": 2138,
						"comment": "Number of additional _microseconds.\n",
						"deco": "l",
						"originalType": "tv_usec_t",
						"char": 19,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "SocketSet",
				"line": 2156,
				"comment": " A collection of sockets for use with $(D Socket.select).\n\n $(D SocketSet) wraps the platform $(D fd_set) type. However, unlike\n $(D fd_set), $(D SocketSet) is not statically limited to $(D FD_SETSIZE)\n or any other limit, and grows as needed.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2263,
						"comment": " Create a SocketSet with a specific initial capacity (defaults to\n $(D FD_SETSIZE), the system's default capacity).\n",
						"deco": "FNaNbNfmZC3std6socket9SocketSet",
						"parameters": [
							{
								"name": "size",
								"deco": "m",
								"default": "1024LU"
							}
						],
						"endline": 2267,
						"originalType": "pure nothrow @safe (size_t size = FD_SETSIZE)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "reset",
						"line": 2270,
						"comment": "Reset the $(D SocketSet) so that there are 0 $(D Socket)s in the collection.\n",
						"deco": "FNaNbNiNfZv",
						"endline": 2279,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "add",
						"line": 2313,
						"comment": "Add a $(D Socket) to the collection.\n\nThe socket must not already be in the collection.\n",
						"deco": "FNaNbNfC3std6socket6SocketZv",
						"parameters": [
							{
								"name": "s",
								"deco": "C3std6socket6Socket"
							}
						],
						"endline": 2316,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "remove",
						"line": 2341,
						"comment": "Remove this $(D Socket) from the collection.\n\nDoes nothing if the socket is not in the collection already.\n",
						"deco": "FNaNbNfC3std6socket6SocketZv",
						"parameters": [
							{
								"name": "s",
								"deco": "C3std6socket6Socket"
							}
						],
						"endline": 2344,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isSet",
						"line": 2364,
						"comment": "Return nonzero if this $(D Socket) is in the collection.\n",
						"deco": "xFNaNbNiNfC3std6socket6SocketZi",
						"parameters": [
							{
								"name": "s",
								"deco": "C3std6socket6Socket"
							}
						],
						"endline": 2367,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "max",
						"line": 2375,
						"comment": "Return the current capacity of this $(D SocketSet). The exact\n\nmeaning of the return value varies from platform to platform.\n\nNote that since D 2.065, this value does not indicate a\n\nrestriction, and $(D SocketSet) will grow its capacity as\n\nneeded automatically.\n",
						"deco": "xFNaNbNdNiNfZk",
						"endline": 2378,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "SOCKET",
						"line": 2511,
						"value": "1",
						"comment": "Socket level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IP",
						"line": 2512,
						"value": "0",
						"comment": "Internet Protocol version 4 level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ICMP",
						"line": 2513,
						"value": "1",
						"comment": "Internet Control Message Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IGMP",
						"line": 2514,
						"value": "2",
						"comment": "Internet Group Management Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "GGP",
						"line": 2515,
						"value": "3",
						"comment": "Gateway to Gateway Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TCP",
						"line": 2516,
						"value": "6",
						"comment": "Transmission Control Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "PUP",
						"line": 2517,
						"value": "12",
						"comment": "PARC Universal Packet Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UDP",
						"line": 2518,
						"value": "17",
						"comment": "User Datagram Protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IDP",
						"line": 2519,
						"value": "22",
						"comment": "Xerox NS protocol level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RAW",
						"line": 2520,
						"value": "255",
						"comment": "Raw IP packet level\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6",
						"line": 2521,
						"value": "41",
						"comment": "Internet Protocol version 6 level\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketOptionLevel",
				"line": 2509,
				"comment": "The level at which a socket option is defined:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Linger",
				"line": 2525,
				"comment": "_Linger information for use with SocketOption.LINGER.\n",
				"members": [
					{
						"offset": 8,
						"name": "on",
						"line": 2533,
						"comment": "Nonzero for _on.\n",
						"deco": "i",
						"originalType": "l_onoff_t",
						"char": 20,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					},
					{
						"offset": 12,
						"name": "time",
						"line": 2534,
						"comment": "Linger _time.\n",
						"deco": "i",
						"originalType": "l_linger_t",
						"char": 20,
						"kind": "variable",
						"storageClass": [
							"@safe"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "DEBUG",
						"line": 2547,
						"value": "1",
						"comment": "Record debugging information\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "BROADCAST",
						"line": 2548,
						"value": "6",
						"comment": "Allow transmission of broadcast messages\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "REUSEADDR",
						"line": 2549,
						"value": "2",
						"comment": "Allow local reuse of address\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "LINGER",
						"line": 2550,
						"value": "13",
						"comment": "Linger on close if unsent data is present\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "OOBINLINE",
						"line": 2551,
						"value": "10",
						"comment": "Receive out-of-band data in band\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SNDBUF",
						"line": 2552,
						"value": "7",
						"comment": "Send buffer size\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RCVBUF",
						"line": 2553,
						"value": "8",
						"comment": "Receive buffer size\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "DONTROUTE",
						"line": 2554,
						"value": "5",
						"comment": "Do not route\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SNDTIMEO",
						"line": 2555,
						"value": "21",
						"comment": "Send timeout\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RCVTIMEO",
						"line": 2556,
						"value": "20",
						"comment": "Receive timeout\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ERROR",
						"line": 2557,
						"value": "4",
						"comment": "Retrieve and clear error status\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "KEEPALIVE",
						"line": 2558,
						"value": "9",
						"comment": "Enable keep-alive packets\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ACCEPTCONN",
						"line": 2559,
						"value": "30",
						"comment": "Listen\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "RCVLOWAT",
						"line": 2560,
						"value": "18",
						"comment": "Minimum number of input bytes to process\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "SNDLOWAT",
						"line": 2561,
						"value": "19",
						"comment": "Minimum number of output bytes to process\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TYPE",
						"line": 2562,
						"value": "3",
						"comment": "Socket type\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TCP_NODELAY",
						"line": 2565,
						"value": "1",
						"comment": "Disable the Nagle algorithm for send coalescing\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_UNICAST_HOPS",
						"line": 2568,
						"value": "16",
						"comment": "IP unicast hop limit\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_MULTICAST_IF",
						"line": 2569,
						"value": "17",
						"comment": "IP multicast interface\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_MULTICAST_LOOP",
						"line": 2570,
						"value": "19",
						"comment": "IP multicast loopback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_MULTICAST_HOPS",
						"line": 2571,
						"value": "18",
						"comment": "IP multicast hops\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_JOIN_GROUP",
						"line": 2572,
						"value": "20",
						"comment": "Add an IP group membership\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_LEAVE_GROUP",
						"line": 2573,
						"value": "21",
						"comment": "Drop an IP group membership\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "IPV6_V6ONLY",
						"line": 2574,
						"value": "26",
						"comment": "Treat wildcard bind as AF_INET6-only\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SocketOption",
				"line": 2545,
				"comment": "Specifies a socket option:\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Socket",
				"line": 2582,
				"comment": " $(D Socket) is a class that creates a network communication endpoint using\n the Berkeley sockets interface.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2650,
						"comment": " Create a blocking socket. If a single protocol type exists to support\n this socket type within the address family, the $(D ProtocolType) may be\n omitted.\n",
						"deco": "FNeE3std6socket13AddressFamilyE3std6socket10SocketTypeE3std6socket12ProtocolTypeZC3std6socket6Socket",
						"parameters": [
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							},
							{
								"name": "type",
								"deco": "E3std6socket10SocketType"
							},
							{
								"name": "protocol",
								"deco": "E3std6socket12ProtocolType"
							}
						],
						"endline": 2657,
						"originalType": "@trusted (AddressFamily af, SocketType type, ProtocolType protocol)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2663,
						"comment": "ditto\n",
						"deco": "FNfE3std6socket13AddressFamilyE3std6socket10SocketTypeZC3std6socket6Socket",
						"parameters": [
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							},
							{
								"name": "type",
								"deco": "E3std6socket10SocketType"
							}
						],
						"endline": 2666,
						"originalType": "@safe (AddressFamily af, SocketType type)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2670,
						"comment": "ditto\n",
						"deco": "FNeE3std6socket13AddressFamilyE3std6socket10SocketTypexAaZC3std6socket6Socket",
						"parameters": [
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							},
							{
								"name": "type",
								"deco": "E3std6socket10SocketType"
							},
							{
								"name": "protocolName",
								"deco": "xAa"
							}
						],
						"endline": 2677,
						"originalType": "@trusted (AddressFamily af, SocketType type, in char[] protocolName)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2684,
						"comment": " Create a blocking socket using the parameters from the specified\n $(D AddressInfo) structure.\n",
						"deco": "FNfxS3std6socket11AddressInfoZC3std6socket6Socket",
						"parameters": [
							{
								"name": "info",
								"deco": "xS3std6socket11AddressInfo"
							}
						],
						"endline": 2687,
						"originalType": "@safe (in AddressInfo info)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 2690,
						"comment": "Use an existing socket handle.\n",
						"deco": "FNaNbNiNfE3std6socket8socket_tE3std6socket13AddressFamilyZC3std6socket6Socket",
						"parameters": [
							{
								"name": "sock",
								"deco": "E3std6socket8socket_t"
							},
							{
								"name": "af",
								"deco": "E3std6socket13AddressFamily"
							}
						],
						"endline": 2695,
						"originalType": "pure nothrow @nogc @safe (socket_t sock, AddressFamily af)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "handle",
						"line": 2705,
						"comment": "Get underlying socket handle.\n",
						"deco": "xFNaNbNdNiNfZE3std6socket8socket_t",
						"endline": 2708,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "blocking",
						"line": 2717,
						"comment": " Get/set socket's blocking flag.\n\n When a socket is blocking, calls to receive(), accept(), and send()\n will block and wait for data/action.\n A non-blocking socket will immediately return instead of blocking.\n",
						"deco": "xFNbNdNiNeZb",
						"endline": 2727,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "blocking",
						"line": 2730,
						"comment": "ditto\n",
						"deco": "FNdNebZv",
						"parameters": [
							{
								"name": "byes",
								"deco": "b"
							}
						],
						"endline": 2755,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addressFamily",
						"line": 2759,
						"comment": "Get the socket's address family.\n",
						"deco": "FNdNfZE3std6socket13AddressFamily",
						"endline": 2762,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isAlive",
						"line": 2765,
						"comment": "Property that indicates if this is a valid, alive socket.\n",
						"deco": "xFNdNeZb",
						"endline": 2770,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "bind",
						"line": 2773,
						"comment": "Associate a local address with this socket.\n",
						"deco": "FNeC3std6socket7AddressZv",
						"parameters": [
							{
								"name": "addr",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 2777,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "connect",
						"line": 2784,
						"comment": " Establish a connection. If the socket is blocking, connect waits for\n the connection to be made. If the socket is nonblocking, connect\n returns immediately and the connection attempt is still in progress.\n",
						"deco": "FNeC3std6socket7AddressZv",
						"parameters": [
							{
								"name": "to",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 2810,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "listen",
						"line": 2817,
						"comment": " Listen for an incoming connection. $(D bind) must be called before you\n can $(D listen). The $(D backlog) is a request of how many pending\n incoming connections are queued until $(D accept)ed.\n",
						"deco": "FNeiZv",
						"parameters": [
							{
								"name": "backlog",
								"deco": "i"
							}
						],
						"endline": 2821,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "accepting",
						"line": 2832,
						"protection": "protected",
						"comment": " Called by $(D accept) when a new $(D Socket) must be created for a new\n connection. To use a derived class, override this method and return an\n instance of your class. The returned $(D Socket)'s handle must not be\n set; $(D Socket) has a protected constructor $(D this()) to use in this\n situation.\n",
						"deco": "FNaNbNfZC3std6socket6Socket",
						"endline": 2835,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "accept",
						"line": 2842,
						"comment": " Accept an incoming connection. If the socket is blocking, $(D accept)\n waits for a connection request. Throws $(D SocketAcceptException) if\n unable to _accept. See $(D accepting) for use with derived classes.\n",
						"deco": "FNeZC3std6socket6Socket",
						"endline": 2866,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "shutdown",
						"line": 2869,
						"comment": "Disables sends and/or receives.\n",
						"deco": "FNbNiNeE3std6socket14SocketShutdownZv",
						"parameters": [
							{
								"name": "how",
								"deco": "E3std6socket14SocketShutdown"
							}
						],
						"endline": 2872,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "close",
						"line": 2896,
						"comment": " Immediately drop any connections and release socket resources.\n Calling $(D shutdown) before $(D close) is recommended for\n connection-oriented sockets. The $(D Socket) object is no longer\n usable after $(D close).\n",
						"deco": "FNbNiNeZv",
						"endline": 2900,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "hostName",
						"line": 2905,
						"comment": "Returns the local machine's host name.\n",
						"deco": "FNdNeZAya",
						"endline": 2911,
						"char": 29,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "remoteAddress",
						"line": 2914,
						"comment": "Remote endpoint $(D Address).\n",
						"deco": "FNdNeZC3std6socket7Address",
						"endline": 2924,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "localAddress",
						"line": 2927,
						"comment": "Local endpoint $(D Address).\n",
						"deco": "FNdNeZC3std6socket7Address",
						"endline": 2937,
						"char": 23,
						"kind": "function"
					},
					{
						"name": "ERROR",
						"line": 2944,
						"comment": " Send or receive error code. See $(D wouldHaveBlocked),\n $(D lastSocketError) and $(D Socket.getErrorText) for obtaining more\n information about the error.\n",
						"deco": "i",
						"init": "-1",
						"char": 14,
						"kind": "variable",
						"storageClass": [
							"enum",
							"@safe"
						]
					},
					{
						"endchar": 5,
						"name": "send",
						"line": 2953,
						"comment": " Send data on the connection. If the socket is blocking and there is no\n buffer space left, $(D send) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n",
						"deco": "FNeAxvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 2964,
						"originalType": "@trusted ptrdiff_t(const(void)[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "send",
						"line": 2967,
						"comment": "ditto\n",
						"deco": "FNfAxvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 2970,
						"originalType": "@safe ptrdiff_t(const(void)[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 2979,
						"comment": " Send data to a specific destination Address. If the destination address is\n not specified, a connection must have been made and that address is used.\n If the socket is blocking and there is no buffer space left, $(D sendTo) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n",
						"deco": "FNeAxvE3std6socket11SocketFlagsC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							},
							{
								"name": "to",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 2992,
						"originalType": "@trusted ptrdiff_t(const(void)[] buf, SocketFlags flags, Address to)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 2995,
						"comment": "ditto\n",
						"deco": "FNfAxvC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "to",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 2998,
						"originalType": "@safe ptrdiff_t(const(void)[] buf, Address to)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 3003,
						"comment": "ditto\n",
						"deco": "FNeAxvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 3013,
						"originalType": "@trusted ptrdiff_t(const(void)[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sendTo",
						"line": 3018,
						"comment": "ditto\n",
						"deco": "FNfAxvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Axv"
							}
						],
						"endline": 3021,
						"originalType": "@safe ptrdiff_t(const(void)[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receive",
						"line": 3031,
						"comment": " Receive data on the connection. If the socket is blocking, $(D receive)\n waits until there is data to be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n",
						"deco": "FNeAvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 3043,
						"originalType": "@trusted ptrdiff_t(void[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receive",
						"line": 3046,
						"comment": "ditto\n",
						"deco": "FNfAvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							}
						],
						"endline": 3049,
						"originalType": "@safe ptrdiff_t(void[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3058,
						"comment": " Receive data and get the remote endpoint $(D Address).\n If the socket is blocking, $(D receiveFrom) waits until there is data to\n be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n",
						"deco": "FNeAvE3std6socket11SocketFlagsKC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							},
							{
								"name": "from",
								"storageClass": [
									"ref"
								],
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3077,
						"originalType": "@trusted ptrdiff_t(void[] buf, SocketFlags flags, ref Address from)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3081,
						"comment": "ditto\n",
						"deco": "FNfAvKC3std6socket7AddressZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "from",
								"storageClass": [
									"ref"
								],
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3084,
						"originalType": "@safe ptrdiff_t(void[] buf, ref Address from)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3089,
						"comment": "ditto\n",
						"deco": "FNeAvE3std6socket11SocketFlagsZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "flags",
								"deco": "E3std6socket11SocketFlags"
							}
						],
						"endline": 3103,
						"originalType": "@trusted ptrdiff_t(void[] buf, SocketFlags flags)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "receiveFrom",
						"line": 3108,
						"comment": "ditto\n",
						"deco": "FNfAvZl",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							}
						],
						"endline": 3111,
						"originalType": "@safe ptrdiff_t(void[] buf)",
						"char": 15,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3117,
						"comment": "Get a socket option.\n\nReturns: The number of bytes written to $(D result).\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionAvZi",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"deco": "Av"
							}
						],
						"endline": 3123,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3127,
						"comment": "Common case of getting integer and boolean options.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJiZi",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"storageClass": [
									"out"
								],
								"deco": "i"
							}
						],
						"endline": 3130,
						"originalType": "@trusted int(SocketOptionLevel level, SocketOption option, out int32_t result)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3134,
						"comment": "Get the linger option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJS3std6socket6LingerZi",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"storageClass": [
									"out"
								],
								"deco": "S3std6socket6Linger"
							}
						],
						"endline": 3138,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getOption",
						"line": 3141,
						"comment": "Get a timeout (duration) option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJS4core4time8DurationZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "result",
								"storageClass": [
									"out"
								],
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 3162,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3165,
						"comment": "Set a socket option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionAvZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "Av"
							}
						],
						"endline": 3170,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3174,
						"comment": "Common case for setting integer and boolean options.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptioniZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "i"
							}
						],
						"endline": 3177,
						"originalType": "@trusted void(SocketOptionLevel level, SocketOption option, int32_t value)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3181,
						"comment": "Set the linger option.\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionS3std6socket6LingerZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "S3std6socket6Linger"
							}
						],
						"endline": 3185,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setOption",
						"line": 3228,
						"comment": " Sets a timeout (duration) option, i.e. $(D SocketOption.SNDTIMEO) or\n $(D RCVTIMEO). Zero indicates no timeout.\n\n In a typical application, you might also want to consider using\n a non-blocking socket instead of setting a timeout on a blocking one.\n\n Note: While the receive timeout setting is generally quite accurate\n on *nix systems even for smaller durations, there are two issues to\n be aware of on Windows: First, although undocumented, the effective\n timeout duration seems to be the one set on the socket plus half\n a second. $(D setOption()) tries to compensate for that, but still,\n timeouts under 500ms are not possible on Windows. Second, be aware\n that the actual amount of time spent until a blocking call returns\n randomly varies on the order of 10ms.\n\n Params:\n   level  = The level at which a socket option is defined.\n   option = Either $(D SocketOption.SNDTIMEO) or $(D SocketOption.RCVTIMEO).\n   value  = The timeout duration to set. Must not be negative.\n\n Throws: $(D SocketException) if setting the options fails.\n\n Example:\n ---\n import std.datetime;\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n // Set a receive timeout, and then wait at one end of\n // the socket pair, knowing that no data will arrive.\n pair[0].setOption(SocketOptionLevel.SOCKET,\n     SocketOption.RCVTIMEO, dur!\"seconds\"(1));\n\n auto sw = StopWatch(AutoStart.yes);\n ubyte[1] buffer;\n pair[0].receive(buffer);\n writefln(\"Waited %s ms until the socket timed out.\",\n     sw.peek.msecs);\n ---\n",
						"deco": "FNeE3std6socket17SocketOptionLevelE3std6socket12SocketOptionS4core4time8DurationZv",
						"parameters": [
							{
								"name": "level",
								"deco": "E3std6socket17SocketOptionLevel"
							},
							{
								"name": "option",
								"deco": "E3std6socket12SocketOption"
							},
							{
								"name": "value",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 3250,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "getErrorText",
						"line": 3254,
						"comment": "Get a text description of this socket's error status, and clear the\n\nsocket's error status.\n",
						"deco": "FNfZAya",
						"endline": 3259,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setKeepAlive",
						"line": 3274,
						"comment": " Enables TCP keep-alive with the specified parameters.\n\n Params:\n   time     = Number of seconds with no activity until the first\n              keep-alive packet is sent.\n   interval = Number of seconds between when successive keep-alive\n              packets are sent if no acknowledgement is received.\n\n Throws: $(D SocketOSException) if setting the options fails, or\n $(D SocketFeatureException) if setting keep-alive parameters is\n unsupported on the current platform.\n",
						"deco": "FNeiiZv",
						"parameters": [
							{
								"name": "time",
								"deco": "i"
							},
							{
								"name": "interval",
								"deco": "i"
							}
						],
						"endline": 3299,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "select",
						"line": 3319,
						"comment": " Wait for a socket to change status. A wait timeout of $(Duration) or\n $(D TimeVal), may be specified; if a timeout is not specified or the\n $(D TimeVal) is $(D null), the maximum timeout is used. The $(D TimeVal)\n timeout has an unspecified value when $(D select) returns.\n Returns: The number of sockets with status changes, $(D 0) on timeout,\n or $(D -1) on interruption. If the return value is greater than $(D 0),\n the $(D SocketSets) are updated to only contain the sockets having status\n changes. For a connecting socket, a write status change means the\n connection is established and it's able to send. For a listening socket,\n a read status change means there is an incoming connection request and\n it's able to accept.\n",
						"deco": "FNeC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetS4core4time8DurationZi",
						"parameters": [
							{
								"name": "checkRead",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkWrite",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkError",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "timeout",
								"deco": "S4core4time8Duration"
							}
						],
						"endline": 3326,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "select",
						"line": 3330,
						"comment": "ditto\n",
						"deco": "FNfC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetZi",
						"parameters": [
							{
								"name": "checkRead",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkWrite",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkError",
								"deco": "C3std6socket9SocketSet"
							}
						],
						"endline": 3333,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "select",
						"line": 3336,
						"comment": "Ditto\n",
						"deco": "FNeC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetPS3std6socket7TimeValZi",
						"parameters": [
							{
								"name": "checkRead",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkWrite",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "checkError",
								"deco": "C3std6socket9SocketSet"
							},
							{
								"name": "timeout",
								"deco": "PS3std6socket7TimeVal"
							}
						],
						"endline": 3428,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "createAddress",
						"line": 3443,
						"protection": "protected",
						"comment": "Returns a new Address object for the current address family.\n\nCan be overridden to support other addresses.\n",
						"deco": "FNaNbNfZC3std6socket7Address",
						"endline": 3467,
						"char": 23,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3476,
						"comment": "Constructs a blocking TCP Socket.\n",
						"deco": "FNfE3std6socket13AddressFamilyZC3std6socket9TcpSocket",
						"parameters": [
							{
								"name": "family",
								"deco": "E3std6socket13AddressFamily"
							}
						],
						"endline": 3479,
						"originalType": "@safe (AddressFamily family)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3482,
						"comment": "Constructs a blocking IPv4 TCP Socket.\n",
						"deco": "FNfZC3std6socket9TcpSocket",
						"endline": 3485,
						"originalType": "@safe ()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3490,
						"comment": "Constructs a blocking TCP Socket and connects to an $(D Address).\n",
						"deco": "FNfC3std6socket7AddressZC3std6socket9TcpSocket",
						"parameters": [
							{
								"name": "connectTo",
								"deco": "C3std6socket7Address"
							}
						],
						"endline": 3494,
						"originalType": "@safe (Address connectTo)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "TcpSocket",
				"line": 3473,
				"comment": "$(D TcpSocket) is a shortcut class for a TCP Socket.\n",
				"base": "std.socket.Socket",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3502,
						"comment": "Constructs a blocking UDP Socket.\n",
						"deco": "FNfE3std6socket13AddressFamilyZC3std6socket9UdpSocket",
						"parameters": [
							{
								"name": "family",
								"deco": "E3std6socket13AddressFamily"
							}
						],
						"endline": 3505,
						"originalType": "@safe (AddressFamily family)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3509,
						"comment": "Constructs a blocking IPv4 UDP Socket.\n",
						"deco": "FNfZC3std6socket9UdpSocket",
						"endline": 3512,
						"originalType": "@safe ()",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "UdpSocket",
				"line": 3499,
				"comment": "$(D UdpSocket) is a shortcut class for a UDP Socket.\n",
				"base": "std.socket.Socket",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "socketPair",
				"line": 3535,
				"comment": " Creates a pair of connected sockets.\n\n The two sockets are indistinguishable.\n\n Throws: $(D SocketException) if creation of the sockets fails.\n\n Example:\n ---\n immutable ubyte[] data = [1, 2, 3, 4];\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n pair[0].send(data);\n\n auto buf = new ubyte[data.length];\n pair[1].receive(buf);\n assert(buf == data);\n ---\n",
				"deco": "FNeZG2C3std6socket6Socket",
				"endline": 3573,
				"char": 11,
				"kind": "function"
			}
		],
		"comment": " Socket primitives.\n Example: See $(SAMPLESRC listener.d) and $(SAMPLESRC htmlget.d)\n License: $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors: Christopher E. Miller, $(WEB klickverbot.at, David Nadlinger),\n      $(WEB thecybershadow.net, Vladimir Panteleev)\n Source:  $(PHOBOSSRC std/_socket.d)\n Macros:\n      WIKI=Phobos/StdSocket\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/typecons.d",
		"name": "std.typecons",
		"members": [
			{
				"members": [
					{
						"name": "Unique",
						"line": 59,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 100,
								"comment": "    Constructor that takes an rvalue.\n    It will ensure uniqueness, as long as the rvalue\n    isn't just a view on an lvalue (e.g., a cast).\n    Typical usage:\n    ----\n    Unique!Foo f = new Foo;\n    ----\n",
								"type": "(RefT p)",
								"parameters": [
									{
										"name": "p",
										"type": "RefT"
									}
								],
								"endline": 104,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 110,
								"comment": "    Constructor that takes an lvalue. It nulls its source.\n    The nulling will ensure uniqueness as long as there\n    are no previous aliases to the source.\n",
								"type": "(ref RefT p)",
								"parameters": [
									{
										"name": "p",
										"type": "RefT",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 116,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 130,
										"type": "(Unique!U u)",
										"parameters": [
											{
												"name": "u",
												"type": "Unique!U"
											}
										],
										"endline": 136,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 130,
								"comment": "    Constructor that takes a $(D Unique) of a type that is convertible to our type.\n\n    Typically used to transfer a $(D Unique) rvalue of derived type to\n    a $(D Unique) of base type.\n    Example:\n    ---\n    class C : Object {}\n\n    Unique!C uc = new C;\n    Unique!Object uo = uc.release;\n    ---\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(u.RefT : RefT)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 139,
										"type": "void(Unique!U u)",
										"parameters": [
											{
												"name": "u",
												"type": "Unique!U"
											}
										],
										"endline": 147,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 139,
								"comment": "Transfer ownership from a $(D Unique) of a type that is convertible to our type.\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(u.RefT : RefT)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "isEmpty",
								"line": 156,
								"comment": " Returns whether the resource exists.\n",
								"type": "const @property bool()",
								"endline": 159,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "release",
								"line": 161,
								"comment": " Transfer ownership to a $(D Unique) rvalue. Nullifies the current contents.\n",
								"type": "Unique()",
								"endline": 168,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 31,
								"name": "opDot",
								"line": 170,
								"comment": " Forwards member access to contents.\n",
								"type": "RefT()",
								"endline": 170,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Unique",
				"line": 59,
				"comment": "Encapsulates unique ownership of a resource.  Resource of type $(D T) is\ndeleted at the end of the scope, unless it is transferred.  The\ntransfer can be explicit, by calling $(D release), or implicit, when\nreturning Unique from a function. The resource can be a polymorphic\nclass object, in which case Unique behaves polymorphically too.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL182_1131)\n---\nstatic struct S\n{\n    int i;\n    this(int i){this.i = i;}\n}\nUnique!S produce()\n{\n    // Construct a unique instance of S on the heap\n    Unique!S ut = new S(5);\n    // Implicit transfer of ownership\n    return ut;\n}\n// Borrow a unique resource by ref\nvoid increment(ref Unique!S ur)\n{\n    ur.i++;\n}\nvoid consume(Unique!S u2)\n{\n    assert(u2.i == 6);\n    // Resource automatically deleted here\n}\nUnique!S u1;\nassert(u1.isEmpty);\nu1 = produce();\nincrement(u1);\nassert(u1.i == 6);\n//consume(u1); // Error: u1 is not copyable\n// Transfer ownership of the resource\nconsume(u1.release);\nassert(u1.isEmpty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL182_1131)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Tuple",
						"line": 430,
						"members": [
							{
								"name": "Types",
								"line": 435,
								"comment": " The types of the `Tuple`'s components.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL438_1135)\n---\nalias Fields = Tuple!(int, \"id\", string, float);\nstatic assert(is(Fields.Types == TypeTuple!(int, string, float)));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL438_1135)\n",
								"type": "staticMap!(extractType, fieldSpecs)",
								"char": 9,
								"kind": "alias"
							},
							{
								"name": "fieldNames",
								"line": 447,
								"comment": " The names of the `Tuple`'s components. Unnamed fields have empty names.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL450_1136)\n---\nalias Fields = Tuple!(int, \"id\", string, float);\nstatic assert(Fields.fieldNames == TypeTuple!(\"id\", \"\", \"\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL450_1136)\n",
								"type": "staticMap!(extractName, fieldSpecs)",
								"char": 9,
								"kind": "alias"
							},
							{
								"name": "expand",
								"line": 462,
								"comment": " Use $(D t.expand) for a `Tuple` $(D t) to expand it into its\n components. The result of $(D expand) acts as if the `Tuple`'s components\n were listed as a list of values. (Ordinarily, a $(D Tuple) acts as a\n single value.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL466_1137)\n---\nauto t1 = tuple(1, \" hello \", 2.3);\nassert(t1.toString() == `Tuple!(int, string, double)(1, \" hello \", 2.3)`);\n\nvoid takeSeveralTypes(int n, string s, bool b)\n{\n    assert(n == 4 && s == \"test\" && b == false);\n}\n\nauto t2 = tuple(4, \"test\", false);\n//t.expand acting as a list of values\ntakeSeveralTypes(t2.expand);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL466_1137)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL524_1138)\n---\nalias ISD = Tuple!(int, string, double);\nauto tup = ISD(1, \"test\", 3.2);\nassert(tup.toString() == `Tuple!(int, string, double)(1, \"test\", 3.2)`);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL524_1138)\n",
								"type": "Types",
								"char": 15,
								"kind": "variable"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "this",
										"line": 538,
										"type": "(U[n] values)",
										"parameters": [
											{
												"name": "values",
												"type": "U[n]"
											}
										],
										"endline": 545,
										"char": 9,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 538,
								"comment": " Constructor taking a compatible array.\n\n Params:\n     values = A compatible static array to build the `Tuple` from.\n              Array slices are not supported.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL548_1139)\n---\nint[2] ints;\nTuple!(int, int) t = ints;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL548_1139)\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									},
									{
										"name": "n",
										"type": "size_t",
										"kind": "value"
									}
								],
								"constraint": "n == Types.length && allSatisfy!(isBuildableFrom!U, Types)",
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "this",
										"line": 564,
										"type": "(U another)",
										"parameters": [
											{
												"name": "another",
												"type": "U"
											}
										],
										"endline": 568,
										"char": 9,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 564,
								"comment": " Constructor taking a compatible `Tuple`. Two `Tuple`s are compatible\n $(B iff) they are both of the same length, and, for each type `T` on the\n left-hand side, the corresponding type `U` on the right-hand side can\n implicitly convert to `T`.\n\n Params:\n     another = A compatible `Tuple` to build from. Its type must be\n               compatible with the target `Tuple`'s type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL571_1140)\n---\nalias IntVec = Tuple!(int, int, int);\nalias DubVec = Tuple!(double, double, double);\n\nIntVec iv = tuple(1, 1, 1);\n\n//Ok, int can implicitly convert to double\nDubVec dv = iv;\n//Error: double cannot implicitly convert to int\n//IntVec iv2 = dv;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL571_1140)\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "areBuildCompatibleTuples!(typeof(this), U)",
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opEquals",
										"line": 604,
										"type": "bool(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 608,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 604,
								"comment": " Comparison for equality. Two `Tuple`s are considered equal\n $(B iff) they fulfill the following criteria:\n\n $(UL\n   $(LI Each `Tuple` is the same length.)\n   $(LI For each type `T` on the left-hand side and each type\n        `U` on the right-hand side, values of type `T` can be\n        compared with values of type `U`.)\n   $(LI For each value `v1` on the left-hand side and each value\n        `v2` on the right-hand side, the expression `v1 == v2` is\n        true.))\n\n Params:\n     rhs = The `Tuple` to compare against. It must meeting the criteria\n           for comparison between `Tuple`s.\n\n Returns:\n     true if both `Tuple`s are equal, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL618_1141)\n---\nTuple!(int, string) t1 = tuple(1, \"test\");\nTuple!(double, string) t2 =  tuple(1.0, \"test\");\n//Ok, int can be compared with double and\n//both have a value of 1\nassert(t1 == t2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL618_1141)\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"==\")",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opEquals",
										"line": 611,
										"type": "const bool(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 615,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 611,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"==\")",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opCmp",
										"line": 643,
										"type": "int(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 654,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 643,
								"comment": " Comparison for ordering.\n\n Params:\n     rhs = The `Tuple` to compare against. It must meet the criteria\n           for comparison between `Tuple`s.\n\n Returns:\n For any values `v1` on the right-hand side and `v2` on the\n left-hand side:\n\n $(UL\n   $(LI A negative integer if the expression `v1 < v2` is true.)\n   $(LI A positive integer if the expression `v1 > v2` is true.)\n   $(LI 0 if the expression `v1 == v2` is true.))\nExample:\nThe first `v1` for which `v1 > v2` is true determines\n            the result. This could lead to unexpected behaviour.$(DDOX_UNITTEST_HEADER __unittestL674_1142)\n---\nauto tup1 = tuple(1, 1, 1);\nauto tup2 = tuple(1, 100, 100);\nassert(tup1 < tup2);\n\n//Only the first result matters for comparison\ntup1[0] = 2;\nassert(tup1 > tup2);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL674_1142)\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"<\")",
								"char": 13,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opCmp",
										"line": 657,
										"type": "const int(R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R"
											}
										],
										"endline": 668,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 657,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"<\")",
								"char": 13,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "opAssign",
										"line": 693,
										"type": "void(auto ref R rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "R",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 716,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 693,
								"comment": " Assignment from another `Tuple`.\n\n Params:\n     rhs = The source `Tuple` to assign from. Each element of the\n           source `Tuple` must be implicitly assignable to each\n           respective element of the target `Tuple`.\n",
								"parameters": [
									{
										"name": "R",
										"kind": "type"
									}
								],
								"constraint": "areCompatibleTuples!(typeof(this), R, \"=\")",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "slice",
										"line": 731,
										"type": "@property ref @trusted Tuple!(sliceSpecs!(from, to))()",
										"endline": 735,
										"char": 43,
										"kind": "function"
									}
								],
								"name": "slice",
								"line": 731,
								"comment": " Takes a slice of this `Tuple`.\n\n Params:\n     from = A `size_t` designating the starting position of the slice.\n     to = A `size_t` designating the ending position (exclusive) of the slice.\n\n Returns:\n     A new `Tuple` that is a slice from `[from, to$(RPAREN)` of the original.\n     It has the same types and values as the range `[from, to$(RPAREN)` in\n     the original.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL738_1143)\n---\nTuple!(int, string, float, double) a;\na[1] = \"abc\";\na[2] = 4.5;\nauto s = a.slice!(1, 3);\nstatic assert(is(typeof(s) == Tuple!(string, float)));\nassert(s[0] == \"abc\" && s[1] == 4.5);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL738_1143)\n",
								"parameters": [
									{
										"name": "from",
										"type": "size_t",
										"kind": "value"
									},
									{
										"name": "to",
										"type": "size_t",
										"kind": "value"
									}
								],
								"constraint": "from <= to && to <= Types.length",
								"char": 43,
								"kind": "template"
							},
							{
								"endchar": 9,
								"name": "toHash",
								"line": 754,
								"comment": "            Creates a hash of this `Tuple`.\n\n            Returns:\n                A `size_t` representing the hash of this `Tuple`.\n",
								"type": "const nothrow @trusted size_t()",
								"endline": 760,
								"char": 16,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 9,
										"name": "toString",
										"line": 795,
										"type": "string()",
										"endline": 799,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "toString",
								"line": 795,
								"comment": " Converts to string.\n\n Returns:\n     The string representation of this `Tuple`.\n",
								"parameters": [],
								"char": 16,
								"kind": "template"
							}
						],
						"char": 5,
						"kind": "struct"
					}
				],
				"name": "Tuple",
				"line": 311,
				"comment": "Tuple of values, for example $(D Tuple!(int, string)) is a record that\nstores an $(D int) and a $(D string). $(D Tuple) can be used to bundle\nvalues together, notably when returning multiple values from a\nfunction. If $(D obj) is a `Tuple`, the individual members are\naccessible with the syntax $(D obj[0]) for the first field, $(D obj[1])\nfor the second, and so on.\n\nThe choice of zero-based indexing instead of one-base indexing was\nmotivated by the ability to use value `Tuple`s with various compile-time\nloop constructs (e.g. $(XREF typetuple, TypeTuple) iteration), all of which use\nzero-based indexing.\n\nParams:\n    Specs = A list of types (and optionally, member names) that the `Tuple` contains.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL804_1144)\n---\nTuple!(int, int) point;\n// assign coordinates\npoint[0] = 5;\npoint[1] = 6;\n// read coordinates\nauto x = point[0];\nauto y = point[1];\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL804_1144)\nExample:\n`Tuple` members can be named. It is legal to mix named and unnamed\n    members. The method above is still applicable to all fields.$(DDOX_UNITTEST_HEADER __unittestL819_1145)\n---\nalias Entry = Tuple!(int, \"index\", string, \"value\");\nEntry e;\ne.index = 4;\ne.value = \"Hello\";\nassert(e[1] == \"Hello\");\nassert(e[0] == 4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL819_1145)\nExample:\nA `Tuple` with named fields is a distinct type from a `Tuple` with unnamed\n    fields, i.e. each naming imparts a separate type for the `Tuple`. Two\n    `Tuple`s differing in naming only are still distinct, even though they\n    might have the same structure.$(DDOX_UNITTEST_HEADER __unittestL835_1146)\n---\nTuple!(int, \"x\", int, \"y\") point1;\nTuple!(int, int) point2;\nassert(!is(typeof(point1) == typeof(point2)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL835_1146)\n",
				"parameters": [
					{
						"name": "Specs",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 851,
						"type": "ReverseTupleType!T(T t)",
						"parameters": [
							{
								"name": "t",
								"type": "T"
							}
						],
						"endline": 864,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 851,
				"comment": "    Create a copy of a `Tuple` with its fields in reverse order.\n\n    Params:\n        t = The `Tuple` to copy.\n\n    Returns:\n        A copy of `t` with its fields in reverse order.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL867_1147)\n---\nauto tup = tuple(1, \"2\");\nassert(tup.reverse == tuple(\"2\", 1));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL867_1147)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isTuple!T",
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "tuple",
								"line": 1317,
								"type": "(Args args)",
								"parameters": [
									{
										"name": "args",
										"type": "Args"
									}
								],
								"endline": 1353,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "tuple",
						"line": 1317,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "tuple",
				"line": 1315,
				"comment": "    Constructs a $(D Tuple) object instantiated and initialized according to\n    the given arguments.\n\n    Params:\n        Names = A list of strings naming each successive field of the `Tuple`.\n                Each name matches up with the corresponding field given by `Args`.\n                A name does not have to be provided for every field, but as\n                the names must proceed in order, it is not possible to skip\n                one field and name the next after it.\n\n        args = Values to initialize the `Tuple` with. The `Tuple`'s type will\n               be inferred from the types of the values given.\n\n    Returns:\n        A new `Tuple` with its type inferred from the arguments given.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1357_1159)\n---\nauto value = tuple(5, 6.7, \"hello\");\nassert(value[0] == 5);\nassert(value[1] == 6.7);\nassert(value[2] == \"hello\");\n\n// Field names can be provided.\nauto entry = tuple!(\"index\", \"value\")(4, \"Hello\");\nassert(entry.index == 4);\nassert(entry.value == \"Hello\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1357_1159)\n",
				"parameters": [
					{
						"name": "Names",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isTuple",
				"line": 1379,
				"comment": "    Returns $(D true) if and only if $(D T) is an instance of $(D std.typecons.Tuple).\n\n    Params:\n        T = The type to check.\n\n    Returns:\n        true if `T` is a `Tuple` type, false otherwise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1392_1160)\n---\nstatic assert(isTuple!(Tuple!()));\nstatic assert(isTuple!(Tuple!(int)));\nstatic assert(isTuple!(Tuple!(int, real, string)));\nstatic assert(isTuple!(Tuple!(int, \"x\", real, \"y\")));\nstatic assert(isTuple!(Tuple!(int, Tuple!(real), string)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1392_1160)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Rebindable",
				"line": 1474,
				"comment": "$(D Rebindable!(T)) is a simple, efficient wrapper that behaves just\nlike an object of type $(D T), except that you can reassign it to\nrefer to another object. For completeness, $(D Rebindable!(T)) aliases\nitself away to $(D T) if $(D T) is a non-const object type. However,\n$(D Rebindable!(T)) does not compile if $(D T) is a non-class type.\n\nYou may want to use $(D Rebindable) when you want to have mutable\nstorage referring to $(D const) objects, for example an array of\nreferences that must be sorted in place. $(D Rebindable) does not\nbreak the soundness of D's type system and does not incur any of the\nrisks usually associated with $(D cast).\n\nParams:\n    T = An object, interface, or array slice type.\nExample:\nRegular $(D const) object references cannot be reassigned.$(DDOX_UNITTEST_HEADER __unittestL1498_1162)\n---\nclass Widget { int x; int y() const { return x; } }\nconst a = new Widget;\n// Fine\na.y();\n// error! can't modify const a\n// a.x = 5;\n// error! can't modify const a\n// a = new Widget;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1498_1162)\nExample:\nHowever, $(D Rebindable!(Widget)) does allow reassignment,\n    while otherwise behaving exactly like a $(D const Widget).$(DDOX_UNITTEST_HEADER __unittestL1514_1163)\n---\nclass Widget { int x; int y() const { return x; } }\nauto a = Rebindable!(const Widget)(new Widget);\n// Fine\na.y();\n// error! can't modify const a\n// a.x = 5;\n// Fine\na = new Widget;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1514_1163)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == interface) || isDynamicArray!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rebindable",
						"line": 1537,
						"type": "Rebindable!T(T obj)",
						"parameters": [
							{
								"name": "obj",
								"type": "T"
							}
						],
						"endline": 1543,
						"char": 14,
						"kind": "function"
					}
				],
				"name": "rebindable",
				"line": 1537,
				"comment": "Convenience function for creating a $(D Rebindable) using automatic type\ninference.\n\nParams:\n    obj = A reference to an object or interface, or an array slice\n          to initialize the `Rebindable` with.\n\nReturns:\n    A newly constructed `Rebindable` initialized with the given reference.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == interface) || isDynamicArray!T",
				"char": 14,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rebindable",
						"line": 1556,
						"type": "Rebindable!T(Rebindable!T obj)",
						"parameters": [
							{
								"name": "obj",
								"type": "Rebindable!T"
							}
						],
						"endline": 1559,
						"char": 14,
						"kind": "function"
					}
				],
				"name": "rebindable",
				"line": 1556,
				"comment": "This function simply returns the $(D Rebindable) object passed in.  It's useful\nin generic programming cases when a given object may be either a regular\n$(D class) or a $(D Rebindable).\n\nParams:\n    obj = An instance of Rebindable!T.\n\nReturns:\n    `obj` without any modification.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 14,
				"kind": "template"
			},
			{
				"members": [],
				"name": "UnqualRef",
				"line": 1652,
				"comment": "    Similar to $(D Rebindable!(T)) but strips all qualifiers from the reference as\n    opposed to just constness / immutability. Primary intended use case is with\n    shared (having thread-local reference to shared class data)\n\n    Params:\n        T = A class or interface type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1672_1165)\n---\nclass Data {}\n\nstatic shared(Data) a;\nstatic UnqualRef!(shared Data) b;\n\nimport core.thread;\n\nauto thread = new core.thread.Thread({\n    a = new shared Data();\n    b = new shared Data();\n});\n\nthread.start();\nthread.join();\n\nassert(a !is null);\nassert(b is null);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1672_1165)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == interface)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "alignForSize",
						"line": 1716,
						"type": "string(string[] names...)",
						"parameters": [
							{
								"name": "names",
								"type": "string[]"
							}
						],
						"endline": 1742,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "alignForSize",
				"line": 1716,
				"comment": "  Order the provided members to minimize size while preserving alignment.\n  Alignment is not always optimal for 80-bit reals, nor for structs declared\n  as align(1).\n\n  Params:\n      E = A list of the types to be aligned, representing fields\n          of an aggregate such as a `struct` or `class`.\n\n      names = The names of the fields that are to be aligned.\n\n  Returns:\n      A string to be mixed in to an aggregate, such as a `struct` or `class`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1745_1167)\n---\nstruct Banner {\n    mixin(alignForSize!(byte[6], double)([\"name\", \"height\"]));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1745_1167)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "tuple"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Nullable",
						"line": 1777,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 1788,
								"comment": "Constructor initializing $(D this) with $(D value).\n\nParams:\n    value = The value to initialize this `Nullable` with.\n",
								"type": "inout (inout T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 1792,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "isNull",
								"line": 1817,
								"comment": "Check if `this` is in the null state.\n\nReturns:\n    true $(B iff) `this` is in the null state, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1823_1169)\n---\nNullable!int ni;\nassert(ni.isNull);\n\nni = 0;\nassert(!ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1823_1169)\n",
								"type": "const pure nothrow @property @safe bool()",
								"endline": 1820,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "nullify",
										"line": 1835,
										"type": "void()",
										"endline": 1839,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "nullify",
								"line": 1835,
								"comment": "Forces $(D this) to the null state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1842_1170)\n---\nNullable!int ni = 0;\nassert(!ni.isNull);\n\nni.nullify();\nassert(ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1842_1170)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 1858,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 1862,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 1858,
								"comment": "Assigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null.\n\nParams:\n    value = A value of type `T` to assign to this `Nullable`.\nExample:\nIf this `Nullable` wraps a type that already has a null value\n    (such as a pointer), then assigning the null value to this\n    `Nullable` is no different than assigning any other value of\n    type `T`, and the resulting code will look very strange. It\n    is strongly recommended that this be avoided by instead using\n    the version of `Nullable` that takes an additional `nullValue`\n    template argument.$(DDOX_UNITTEST_HEADER __unittestL1873_1171)\n---\n//Passes\nNullable!(int*) npi;\nassert(npi.isNull);\n\n//Passes?!\nnpi = null;\nassert(!npi.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1873_1171)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "get",
								"line": 1891,
								"comment": "Gets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\n\nReturns:\n    The value held internally by this `Nullable`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1899_1172)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullable!int ni;\n//`get` is implicitly called. Will throw\n//an AssertError in non-release mode\nassertThrown!Throwable(ni == 0);\n\nni = 0;\nassertNotThrown!Throwable(ni == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1899_1172)\n",
								"type": "inout pure nothrow @property ref @safe inout(T)()",
								"endline": 1896,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Nullable",
				"line": 1777,
				"comment": "Defines a value paired with a distinctive \"null\" state that denotes\nthe absence of a value. If default constructed, a $(D\nNullable!T) object starts in the null state. Assigning it renders it\nnon-null. Calling $(D nullify) can nullify it again.\n\nPractically $(D Nullable!T) stores a $(D T) and a $(D bool).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1920_1173)\n---\nstruct CustomerRecord\n{\n    string name;\n    string address;\n    int customerNum;\n}\n\nNullable!CustomerRecord getByName(string name)\n{\n    //A bunch of hairy stuff\n\n    return Nullable!CustomerRecord.init;\n}\n\nauto queryResult = getByName(\"Doe, John\");\nif (!queryResult.isNull)\n{\n    //Process Mr. Doe's customer record\n    auto address = queryResult.address;\n    auto customerNum = queryResult.customerNum;\n\n    //Do some things with this customer's info\n}\nelse\n{\n    //Add the customer to the database\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1920_1173)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Nullable",
						"line": 2236,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2246,
								"comment": "Constructor initializing $(D this) with $(D value).\n\nParams:\n    value = The value to initialize this `Nullable` with.\n",
								"type": "(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 2249,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "isNull",
								"line": 2274,
								"comment": "Check if `this` is in the null state.\n\nReturns:\n    true $(B iff) `this` is in the null state, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2289_1187)\n---\nNullable!(int, -1) ni;\n//Initialized to \"null\" state\nassert(ni.isNull);\n\nni = 0;\nassert(!ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2289_1187)\n",
								"type": "const @property bool()",
								"endline": 2286,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "nullify",
										"line": 2302,
										"type": "void()",
										"endline": 2305,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "nullify",
								"line": 2302,
								"comment": "Forces $(D this) to the null state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2308_1188)\n---\nNullable!(int, -1) ni = 0;\nassert(!ni.isNull);\n\nni = -1;\nassert(ni.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2308_1188)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 2327,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 2330,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 2327,
								"comment": "Assigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null. No null checks are made. Note\nthat the assignment may leave $(D this) in the null state.\n\nParams:\n    value = A value of type `T` to assign to this `Nullable`.\n            If it is `nullvalue`, then the internal state of\n            this `Nullable` will be set to null.\nExample:\nIf this `Nullable` wraps a type that already has a null value\n    (such as a pointer), and that null value is not given for\n    `nullValue`, then assigning the null value to this `Nullable`\n    is no different than assigning any other value of type `T`,\n    and the resulting code will look very strange. It is strongly\n    recommended that this be avoided by using `T`'s \"built in\"\n    null value for `nullValue`.$(DDOX_UNITTEST_HEADER __unittestL2341_1189)\n---\n//Passes\nenum nullVal = cast(int*)0xCAFEBABE;\nNullable!(int*, nullVal) npi;\nassert(npi.isNull);\n\n//Passes?!\nnpi = null;\nassert(!npi.isNull);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2341_1189)\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "get",
								"line": 2360,
								"comment": "Gets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\n\nReturns:\n    The value held internally by this `Nullable`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2370_1190)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullable!(int, -1) ni;\n//`get` is implicitly called. Will throw\n//an error in non-release mode\nassertThrown!Throwable(ni == 0);\n\nni = 0;\nassertNotThrown!Throwable(ni == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2370_1190)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 2367,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Nullable",
				"line": 2236,
				"comment": "Just like $(D Nullable!T), except that the null state is defined as a\nparticular value. For example, $(D Nullable!(uint, uint.max)) is an\n$(D uint) that sets aside the value $(D uint.max) to denote a null\nstate. $(D Nullable!(T, nullValue)) is more storage-efficient than $(D\nNullable!T) because it does not need to store an extra $(D bool).\n\nParams:\n    T = The wrapped type for which Nullable provides a null value.\n\n    nullValue = The null value which denotes the null state of this\n                `Nullable`. Must be of type `T`.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2391_1191)\n---\nNullable!(size_t, size_t.max) indexOf(string[] haystack, string needle)\n{\n    //Find the needle, returning -1 if not found\n\n    return Nullable!(size_t, size_t.max).init;\n}\n\nvoid sendLunchInvite(string name)\n{\n}\n\n//It's safer than C...\nauto coworkers = [\"Jane\", \"Jim\", \"Marry\", \"Fred\"];\nauto pos = indexOf(coworkers, \"Bob\");\nif (!pos.isNull)\n{\n    //Send Bob an invitation to lunch\n    sendLunchInvite(coworkers[pos]);\n}\nelse\n{\n    //Bob not found; report the error\n}\n\n//And there's no overhead\nstatic assert(Nullable!(size_t, size_t.max).sizeof == size_t.sizeof);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2391_1191)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "nullValue",
						"type": "T",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NullableRef",
						"line": 2553,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2563,
								"comment": "Constructor binding $(D this) to $(D value).\n\nParams:\n    value = The value to bind to.\n",
								"type": "pure nothrow @safe (T* value)",
								"parameters": [
									{
										"name": "value",
										"type": "T*"
									}
								],
								"endline": 2566,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "bind",
								"line": 2591,
								"comment": "Binds the internal state to $(D value).\n\nParams:\n    value = A pointer to a value of type `T` to bind this `NullableRef` to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2597_1199)\n---\nNullableRef!int nr = new int(42);\nassert(nr == 42);\n\nint* n = new int(1);\nnr.bind(n);\nassert(nr == 1);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2597_1199)\n",
								"type": "pure nothrow @safe void(T* value)",
								"parameters": [
									{
										"name": "value",
										"type": "T*"
									}
								],
								"endline": 2594,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "isNull",
								"line": 2613,
								"comment": "Returns $(D true) if and only if $(D this) is in the null state.\n\nReturns:\n    true if `this` is in the null state, otherwise false.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2619_1200)\n---\nNullableRef!int nr;\nassert(nr.isNull);\n\nint* n = new int(42);\nnr.bind(n);\nassert(!nr.isNull && nr == 42);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2619_1200)\n",
								"type": "const pure nothrow @property @safe bool()",
								"endline": 2616,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "nullify",
								"line": 2632,
								"comment": "Forces $(D this) to the null state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2638_1201)\n---\nNullableRef!int nr = new int(42);\nassert(!nr.isNull);\n\nnr.nullify();\nassert(nr.isNull);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2638_1201)\n",
								"type": "pure nothrow @safe void()",
								"endline": 2635,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 2656,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 2662,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 2656,
								"comment": "Assigns $(D value) to the internally-held state.\n\nParams:\n    value = A value of type `T` to assign to this `NullableRef`.\n            If the internal state of this `NullableRef` has not\n            been initialized, an error will be thrown in\n            non-release mode.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2665_1202)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullableRef!int nr;\nassert(nr.isNull);\nassertThrown!Throwable(nr = 42);\n\nnr.bind(new int(0));\nassert(!nr.isNull);\nassertNotThrown!Throwable(nr = 42);\nassert(nr == 42);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2665_1202)\n",
								"parameters": [],
								"constraint": "isAssignable!T",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "get",
								"line": 2683,
								"comment": "Gets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2691_1203)\n---\nimport std.exception: assertThrown, assertNotThrown;\n\nNullableRef!int nr;\n//`get` is implicitly called. Will throw\n//an error in non-release mode\nassertThrown!Throwable(nr == 0);\n\nnr.bind(new int(0));\nassertNotThrown!Throwable(nr == 0);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2691_1203)\n",
								"type": "inout pure nothrow @property ref @safe inout(T)()",
								"endline": 2688,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NullableRef",
				"line": 2553,
				"comment": "Just like $(D Nullable!T), except that the object refers to a value\nsitting elsewhere in memory. This makes assignments overwrite the\ninitially assigned value. Internally $(D NullableRef!T) only stores a\npointer to $(D T) (i.e., $(D Nullable!T.sizeof == (T*).sizeof)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BlackHole",
						"line": 2862,
						"type": "AutoImplement!(Base, generateEmptyFunction, isAbstractFunction)",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "BlackHole",
				"line": 2862,
				"comment": "$(D BlackHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions in $(D Base) as do-nothing functions.  Each\nauto-implemented function just returns the default value of the return type\nwithout doing anything.\n\nThe name came from\n$(WEB search.cpan.org/~sburke/Class-_BlackHole-0.04/lib/Class/_BlackHole.pm, Class::_BlackHole)\nPerl module by Sean M. Burke.\n\nParams:\n    Base = A non-final class for `BlackHole` to inherit from.\n\nSee_Also:\n  $(LREF AutoImplement), $(LREF generateEmptyFunction)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2865_1210)\n---\nimport std.math: isNaN;\n\nstatic abstract class C\n{\n    int m_value;\n    this(int v) { m_value = v; }\n    int value() @property { return m_value; }\n\n    abstract real realValue() @property;\n    abstract void doSomething();\n}\n\nauto c = new BlackHole!C(42);\nassert(c.value == 42);\n\n// Returns real.init which is NaN\nassert(c.realValue.isNaN);\n// Abstract functions are implemented as do-nothing\nc.doSomething();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2865_1210)\n",
				"parameters": [
					{
						"name": "Base",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "WhiteHole",
						"line": 2942,
						"type": "AutoImplement!(Base, generateAssertTrap, isAbstractFunction)",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "WhiteHole",
				"line": 2942,
				"comment": "$(D WhiteHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions as functions that always fail. These functions\nsimply throw an $(D Error) and never return. `Whitehole` is useful for\ntrapping the use of class member functions that haven't been implemented.\n\nThe name came from\n$(WEB search.cpan.org/~mschwern/Class-_WhiteHole-0.04/lib/Class/_WhiteHole.pm, Class::_WhiteHole)\nPerl module by Michael G Schwern.\n\nParams:\n    Base = A non-final class for `WhiteHole` to inherit from.\n\nSee_Also:\n  $(LREF AutoImplement), $(LREF generateAssertTrap)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2945_1212)\n---\nimport std.exception: assertThrown;\n\nstatic class C\n{\n    abstract void notYetImplemented();\n}\n\nauto c = new WhiteHole!C;\nassertThrown!NotImplementedError(c.notYetImplemented()); // throws an Error\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2945_1212)\n",
				"parameters": [
					{
						"name": "Base",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "AutoImplement",
						"line": 3082,
						"members": [],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "AutoImplement",
				"line": 3082,
				"comment": "$(D AutoImplement) automatically implements (by default) all abstract member\nfunctions in the class or interface $(D Base) in specified way.\n\nParams:\n  how  = template which specifies _how functions will be implemented/overridden.\n\n         Two arguments are passed to $(D how): the type $(D Base) and an alias\n         to an implemented function.  Then $(D how) must return an implemented\n         function body as a string.\n\n         The generated function body can use these keywords:\n         $(UL\n            $(LI $(D a0), $(D a1), &hellip;: arguments passed to the function;)\n            $(LI $(D args): a tuple of the arguments;)\n            $(LI $(D self): an alias to the function itself;)\n            $(LI $(D parent): an alias to the overridden function (if any).)\n         )\n\n        You may want to use templated property functions (instead of Implicit\n        Template Properties) to generate complex functions:\n--------------------\n// Prints log messages for each call to overridden functions.\nstring generateLogger(C, alias fun)() @property\n{\n    import std.traits;\n    enum qname = C.stringof ~ \".\" ~ __traits(identifier, fun);\n    string stmt;\n\n    stmt ~= q{ struct Importer { import std.stdio; } };\n    stmt ~= `Importer.writeln(\"Log: ` ~ qname ~ `(\", args, \")\");`;\n    static if (!__traits(isAbstractFunction, fun))\n    {\n        static if (is(ReturnType!fun == void))\n            stmt ~= q{ parent(args); };\n        else\n            stmt ~= q{\n                auto r = parent(args);\n                Importer.writeln(\"--> \", r);\n                return r;\n            };\n    }\n    return stmt;\n}\n--------------------\n\n  what = template which determines _what functions should be\n         implemented/overridden.\n\n         An argument is passed to $(D what): an alias to a non-final member\n         function in $(D Base).  Then $(D what) must return a boolean value.\n         Return $(D true) to indicate that the passed function should be\n         implemented/overridden.\n\n--------------------\n// Sees if fun returns something.\nenum bool hasValue(alias fun) = !is(ReturnType!(fun) == void);\n--------------------\n\n\nNote:\n\nGenerated code is inserted in the scope of $(D std.typecons) module.  Thus,\nany useful functions outside $(D std.typecons) cannot be used in the generated\ncode.  To workaround this problem, you may $(D import) necessary things in a\nlocal struct, as done in the $(D generateLogger()) template in the above\nexample.\n\n\nBUGS:\n\n$(UL\n $(LI Variadic arguments to constructors are not forwarded to super.)\n $(LI Deep interface inheritance causes compile error with messages like\n      \"Error: function std.typecons._AutoImplement!(Foo)._AutoImplement.bar\n      does not override any function\".  [$(BUGZILLA 2525), $(BUGZILLA 3525)] )\n $(LI The $(D parent) keyword is actually a delegate to the super class'\n      corresponding member function.  [$(BUGZILLA 2540)] )\n $(LI Using alias template parameter in $(D how) and/or $(D what) may cause\n     strange compile error.  Use template tuple parameter instead to workaround\n     this problem.  [$(BUGZILLA 4217)] )\n)\n",
				"parameters": [
					{
						"name": "Base",
						"kind": "type"
					},
					{
						"name": "how",
						"kind": "alias"
					},
					{
						"name": "what",
						"defaultAlias": "isAbstractFunction",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "generateEmptyFunction",
				"line": 3709,
				"comment": "Predefined how-policies for $(D AutoImplement).  These templates are also used by\n$(D BlackHole) and $(D WhiteHole), respectively.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "generateAssertTrap",
						"line": 3728,
						"type": "string",
						"init": "\"throw new NotImplementedError(\\\"\" ~ C.stringof ~ \".\" ~ __traits(identifier, func) ~ \"\\\");\"",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "generateAssertTrap",
				"line": 3726,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "wrap",
								"line": 3794,
								"type": "pure nothrow @trusted (inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 3799,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "wrap",
						"line": 3794,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "Targets.length == 1 && is(Source : Targets[0])",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 9,
								"name": "wrap",
								"line": 3804,
								"type": "(inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 3813,
								"char": 14,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "wrap",
						"line": 3801,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "!allSatisfy!(Bind!(isImplicitlyConvertible, Source), Targets)",
						"char": 5,
						"kind": "template"
					}
				],
				"name": "wrap",
				"line": 3788,
				"comment": " Supports structural based typesafe conversion.\n\n If $(D Source) has structural conformance with the $(D interface) $(D Targets),\n wrap creates internal wrapper class which inherits $(D Targets) and\n wrap $(D src) object, then return it.\n",
				"parameters": [
					{
						"name": "Targets",
						"kind": "tuple"
					}
				],
				"constraint": "Targets.length >= 1 && allSatisfy!(isMutable, Targets)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "wrap",
						"line": 3966,
						"type": ".wrap!(staticMap!(Unqual, Targets))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "wrap",
				"line": 3961,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Targets",
						"kind": "tuple"
					}
				],
				"constraint": "Targets.length >= 1 && !allSatisfy!(isMutable, Targets)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "unwrap",
								"line": 3982,
								"type": "pure nothrow @trusted (inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 3987,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "unwrap",
						"line": 3982,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "is(Target : Source)",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "unwrap",
								"line": 3989,
								"type": "pure nothrow @trusted (inout Source src)",
								"parameters": [
									{
										"name": "src",
										"type": "Source",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 4007,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "unwrap",
						"line": 3989,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"constraint": "!is(Target : Source)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "unwrap",
				"line": 3978,
				"comment": " Extract object which wrapped by $(D wrap).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4017_1217)\n---\ninterface Quack\n{\n    int quack();\n    @property int height();\n}\ninterface Flyer\n{\n    @property int height();\n}\nclass Duck : Quack\n{\n    int quack() { return 1; }\n    @property int height() { return 10; }\n}\nclass Human\n{\n    int quack() { return 2; }\n    @property int height() { return 20; }\n}\n\nDuck d1 = new Duck();\nHuman h1 = new Human();\n\ninterface Refleshable\n{\n    int reflesh();\n}\n// does not have structural conformance\nstatic assert(!__traits(compiles, d1.wrap!Refleshable));\nstatic assert(!__traits(compiles, h1.wrap!Refleshable));\n\n// strict upcast\nQuack qd = d1.wrap!Quack;\nassert(qd is d1);\nassert(qd.quack() == 1);    // calls Duck.quack\n// strict downcast\nDuck d2 = qd.unwrap!Duck;\nassert(d2 is d1);\n\n// structural upcast\nQuack qh = h1.wrap!Quack;\nassert(qh.quack() == 2);    // calls Human.quack\n// structural downcast\nHuman h2 = qh.unwrap!Human;\nassert(h2 is h1);\n\n// structural upcast (two steps)\nQuack qx = h1.wrap!Quack;   // Human -> Quack\nFlyer fx = qx.wrap!Flyer;   // Quack -> Flyer\nassert(fx.height == 20);    // calls Human.height\n// strucural downcast (two steps)\nQuack qy = fx.unwrap!Quack; // Flyer -> Quack\nHuman hy = qy.unwrap!Human; // Quack -> Human\nassert(hy is h1);\n// strucural downcast (one step)\nHuman hz = fx.unwrap!Human; // Flyer -> Human\nassert(hz is h1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4017_1217)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4078_1218)\n---\ninterface A { int run(); }\ninterface B { int stop(); @property int status(); }\nclass X\n{\n    int run() { return 1; }\n    int stop() { return 2; }\n    @property int status() { return 3; }\n}\n\nauto x = new X();\nauto ab = x.wrap!(A, B);\nA a = ab;\nB b = ab;\nassert(a.run() == 1);\nassert(b.stop() == 2);\nassert(b.status == 3);\nstatic assert(functionAttributes!(typeof(ab).status) & FunctionAttribute.property);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4078_1218)\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					}
				],
				"constraint": "isMutable!Target",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "unwrap",
						"line": 4013,
						"type": ".unwrap!(Unqual!Target)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "unwrap",
				"line": 4010,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					}
				],
				"constraint": "!isMutable!Target",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 4497,
						"value": "0",
						"comment": "Do not auto-initialize the object\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 4499,
						"value": "1",
						"comment": "Auto-initialize the object\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "RefCountedAutoInitialize",
				"line": 4494,
				"comment": "Options regarding auto-initialization of a $(D RefCounted) object (see\nthe definition of $(D RefCounted) below).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "RefCounted",
						"line": 4520,
						"members": [
							{
								"name": "RefCountedStore",
								"line": 4525,
								"comment": "$(D RefCounted) storage implementation.\n",
								"members": [
									{
										"endchar": 9,
										"name": "isInitialized",
										"line": 4599,
										"comment": "           Returns $(D true) if and only if the underlying store has been\n           allocated and initialized.\n",
										"type": "const nothrow @property @safe bool()",
										"endline": 4602,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "refCount",
										"line": 4609,
										"comment": "           Returns underlying reference count if it is allocated and initialized\n           (a positive integer), and $(D 0) otherwise.\n",
										"type": "const nothrow @property @safe size_t()",
										"endline": 4612,
										"char": 16,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "ensureInitialized",
										"line": 4618,
										"comment": "           Makes sure the payload was properly initialized. Such a\n           call is typically inserted before using the payload.\n",
										"type": "void()",
										"endline": 4621,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "refCountedStore",
								"line": 4628,
								"comment": "Returns storage implementation struct.\n",
								"type": "inout nothrow @property ref @safe inout(RefCountedStore)()",
								"endline": 4631,
								"char": 32,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 4638,
										"type": "(auto ref A args)",
										"parameters": [
											{
												"name": "args",
												"type": "A",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 4641,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 4638,
								"comment": "Constructor that initializes the payload.\n\nPostcondition: $(D refCountedStore.isInitialized)\n",
								"parameters": [
									{
										"name": "A",
										"kind": "tuple"
									}
								],
								"constraint": "A.length > 0",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 4644,
								"comment": "Ditto\n",
								"type": "(T val)",
								"parameters": [
									{
										"name": "val",
										"type": "T"
									}
								],
								"endline": 4647,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "~this",
								"line": 4665,
								"comment": "Destructor that tracks the reference count appropriately. If $(D\n!refCountedStore.isInitialized), does nothing. When the reference count goes\ndown to zero, calls $(D destroy) agaist the payload and calls $(D free)\nto deallocate the corresponding resource.\n",
								"endline": 4681,
								"char": 5,
								"kind": "destructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 4686,
								"comment": "Assignment operators\n",
								"type": "void(typeof(this) rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "typeof(this)"
									}
								],
								"endline": 4691,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 4694,
								"comment": "Ditto\n",
								"type": "void(T rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "T"
									}
								],
								"endline": 4707,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "refCountedPayload",
								"line": 4727,
								"comment": "        Returns a reference to the payload. If (autoInit ==\n        RefCountedAutoInitialize.yes), calls $(D\n        refCountedStore.ensureInitialized). Otherwise, just issues $(D\n        assert(refCountedStore.isInitialized)). Used with $(D alias\n        refCountedPayload this;), so callers can just use the $(D RefCounted)\n        object as a $(D T).\n\n        $(BLUE The first overload exists only if $(D autoInit == RefCountedAutoInitialize.yes).)\n        So if $(D autoInit == RefCountedAutoInitialize.no)\n        or called for a constant or immutable object, then\n        $(D refCountedPayload) will also be qualified as safe and nothrow\n        (but will still assert if not initialized).\n",
								"type": "@property ref T()return ",
								"char": 15,
								"kind": "function"
							},
							{
								"name": "refCountedPayload",
								"line": 4731,
								"comment": "ditto\n",
								"type": "inout nothrow @property ref @safe inout(T)()return ",
								"char": 22,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RefCounted",
				"line": 4520,
				"comment": "Defines a reference-counted object containing a $(D T) value as\npayload. $(D RefCounted) keeps track of all references of an object,\nand when the reference count goes down to zero, frees the underlying\nstore. $(D RefCounted) uses $(D malloc) and $(D free) for operation.\n\n$(D RefCounted) is unsafe and should be used with care. No references\nto the payload should be escaped outside the $(D RefCounted) object.\n\nThe $(D autoInit) option makes the object ensure the store is\nautomatically initialized. Leaving $(D autoInit ==\nRefCountedAutoInitialize.yes) (the default option) is convenient but\nhas the cost of a test whenever the payload is accessed. If $(D\nautoInit == RefCountedAutoInitialize.no), user code must call either\n$(D refCountedStore.isInitialized) or $(D refCountedStore.ensureInitialized)\nbefore attempting to access the payload. Not doing so results in null\npointer dereference.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4764_1225)\n---\n// A pair of an $(D int) and a $(D size_t) - the latter being the\n// reference count - will be dynamically allocated\nauto rc1 = RefCounted!int(5);\nassert(rc1 == 5);\n// No more allocation, add just one extra reference count\nauto rc2 = rc1;\n// Reference semantics\nrc2 = 42;\nassert(rc1 == 42);\n// the pair will be freed when rc1 and rc2 go out of scope\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4764_1225)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "autoInit",
						"defaultValue": "RefCountedAutoInitialize.yes",
						"deco": "E3std8typecons24RefCountedAutoInitialize",
						"kind": "value"
					}
				],
				"constraint": "!is(T == class) && !is(T == interface)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "refCounted",
						"line": 4874,
						"type": "RefCounted!(T, RefCountedAutoInitialize.no)(T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 4879,
						"char": 45,
						"kind": "function"
					}
				],
				"name": "refCounted",
				"line": 4874,
				"comment": " Initializes a `RefCounted` with `val`. The template parameter\n `T` of `RefCounted` is inferred from `val`.\n This function can be used to move non-copyable values to the heap.\n It also disables the `autoInit` option of `RefCounted`.\n\n Params:\n   val = The value to be reference counted\n Returns:\n   An initialized $(D RefCounted) containing $(D val).\n See_Also:\n   $(WEB http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared, C++'s make_shared)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4882_1231)\n---\nstatic struct File\n{\n    string name;\n    @disable this(this); // not copyable\n    ~this() { name = null; }\n}\n\nauto file = File(\"name\");\nassert(file.name == \"name\");\n// file cannot be copied and has unique ownership\nstatic assert(!__traits(compiles, {auto file2 = file;}));\n\n// make the file refcounted to share ownership\nimport std.algorithm.mutation : move;\nauto rcFile = refCounted(move(file));\nassert(rcFile.name == \"name\");\nassert(file.name == null);\nauto rcFile2 = rcFile;\nassert(rcFile.refCountedStore.refCount == 2);\n// file gets properly closed when last reference is dropped\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4882_1231)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 45,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Proxy",
				"line": 4921,
				"comment": "    Creates a proxy for the value `a` that will forward all operations\n    while disabling implicit conversions. The aliased item `a` must be\n    an $(B lvalue). This is useful for creating a new type from the\n    \"base\" type (though this is $(B not) a subtype-supertype\n    relationship; the new type is not related to the old type in any way,\n    by design).\n\n    The new type supports all operations that the underlying type does,\n    including all operators such as `+`, `--`, `<`, `[]`, etc.\n\n    Params:\n        a = The value to act as a proxy for all operations. It must\n            be an lvalue.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5124_1232)\n---\nstruct MyInt\n{\n    private int value;\n    mixin Proxy!value;\n\n    this(int n){ value = n; }\n}\n\nMyInt n = 10;\n\n// Enable operations that original type has.\n++n;\nassert(n == 11);\nassert(n * 2 == 22);\n\nvoid func(int n) { }\n\n// Disable implicit conversions to original type.\n//int x = n;\n//func(n);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5124_1232)\nExample:\nThe proxied value must be an $(B lvalue).$(DDOX_UNITTEST_HEADER __unittestL5149_1233)\n---\nstruct NewIntType\n{\n    //Won't work; the literal '1' is\n    //is an rvalue, not an lvalue\n    //mixin Proxy!1;\n\n    //Okay, n is an lvalue\n    int n;\n    mixin Proxy!n;\n\n    this(int n) { this.n = n; }\n}\n\nNewIntType nit = 0;\nnit++;\nassert(nit == 1);\n\n\nstruct NewObjectType\n{\n    Object obj;\n    //Ok, obj is an lvalue\n    mixin Proxy!obj;\n\n    this (Object o) { obj = o; }\n}\n\nNewObjectType not = new Object();\nassert(__traits(compiles, not.toHash()));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5149_1233)\nExample:\nThere is one exception to the fact that the new type is not related to the\n    old type. $(LINK2 http://dlang.org/function.html#pseudo-member, Pseudo-member)\n    functions are usable with the new type; they will be forwarded on to the\n    proxied value.$(DDOX_UNITTEST_HEADER __unittestL5188_1234)\n---\nimport std.math;\n\nfloat f = 1.0;\nassert(!f.isInfinity);\n\nstruct NewFloat\n{\n    float _;\n    mixin Proxy!_;\n\n    this(float f) { _ = f; }\n}\n\nNewFloat nf = 1.0f;\nassert(!nf.isInfinity);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5188_1234)\n",
				"parameters": [
					{
						"name": "a",
						"kind": "alias"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Typedef",
						"line": 5605,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Typedef",
				"line": 5605,
				"comment": "$(B Typedef) allows the creation of a unique type which is\nbased on an existing type. Unlike the $(D alias) feature,\n$(B Typedef) ensures the two types are not considered as equals.\n\nExample:\n----\nalias MyInt = Typedef!int;\nstatic void takeInt(int) { }\nstatic void takeMyInt(MyInt) { }\n\nint i;\ntakeInt(i);    // ok\ntakeMyInt(i);  // fails\n\nMyInt myInt;\ntakeInt(myInt);    // fails\ntakeMyInt(myInt);  // ok\n----\n\nParams:\n\ninit = Optional initial value for the new type. For example:\n\n----\nalias MyInt = Typedef!(int, 10);\nMyInt myInt;\nassert(myInt == 10);  // default-initialized to 10\n----\n\ncookie = Optional, used to create multiple unique types which are\nbased on the same origin type $(D T). For example:\n\n----\nalias TypeInt1 = Typedef!int;\nalias TypeInt2 = Typedef!int;\n\n// The two Typedefs are the same type.\nstatic assert(is(TypeInt1 == TypeInt2));\n\nalias MoneyEuros = Typedef!(float, float.init, \"euros\");\nalias MoneyDollars = Typedef!(float, float.init, \"dollars\");\n\n// The two Typedefs are _not_ the same type.\nstatic assert(!is(MoneyEuros == MoneyDollars));\n----\n\nNote: If a library routine cannot handle the Typedef type,\nyou can use the $(D TypedefType) template to extract the\ntype which the Typedef wraps.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "init",
						"type": "T",
						"defaultValue": "T.init",
						"kind": "value"
					},
					{
						"name": "cookie",
						"defaultValue": "null",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "TypedefType",
				"line": 5638,
				"comment": "Get the underlying type which a $(D Typedef) wraps.\nIf $(D T) is not a $(D Typedef) it will alias itself to $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5647_1242)\n---\nimport std.typecons: Typedef, TypedefType;\nimport std.conv: to;\n\nalias MyInt = Typedef!int;\nstatic assert(is(TypedefType!MyInt == int));\n\n/// Instantiating with a non-Typedef will return that type\nstatic assert(is(TypedefType!int == int));\n\nstring num = \"5\";\n\n// extract the needed type\nMyInt myInt = MyInt( num.to!(TypedefType!MyInt) );\nassert(myInt == 5);\n\n// cast to the underlying type to get the value that's being wrapped\nint x = cast(TypedefType!MyInt)myInt;\n\nalias MyIntInit = Typedef!(int, 42);\nstatic assert(is(TypedefType!MyIntInit == int));\nstatic assert(MyIntInit() == 42);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5647_1242)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "scoped",
								"line": 5881,
								"type": "@system (auto ref Args args)",
								"parameters": [
									{
										"name": "args",
										"type": "Args",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 5891,
								"char": 18,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "scoped",
						"line": 5881,
						"comment": "Returns the scoped object\n",
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"char": 18,
						"kind": "template"
					}
				],
				"name": "scoped",
				"line": 5840,
				"comment": "Allocates a $(D class) object right inside the current scope,\ntherefore avoiding the overhead of $(D new). This facility is unsafe;\nit is the responsibility of the user to not escape a reference to the\nobject outside the scope.\n\nNote: it's illegal to move a class reference even if you are sure there\nare no pointers to it. As such, it is illegal to move a scoped object.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5894_1248)\n---\nclass A\n{\n    int x;\n    this()     {x = 0;}\n    this(int i){x = i;}\n}\n\n// Standard usage\nauto a1 = scoped!A();\nauto a2 = scoped!A(1);\na1.x = 42;\nassert(a1.x == 42);\nassert(a2.x ==  1);\n\n// Restrictions\nstatic assert(!is(typeof({\n    auto e1 = a1; // illegal, scoped objects can't be copied\n    assert([a2][0].x == 42); // ditto\n    alias ScopedObject = typeof(a1);\n    auto e2 = ScopedObject();  //Illegal, must be built via scoped!A\n    auto e3 = ScopedObject(1); //Illegal, must be built via scoped!A\n})));\n\n// Use as member variable\nstruct B\n{\n    typeof(scoped!A()) a; // note the trailing parentheses\n}\n\n// Use with alias\nalias makeScopedA = scoped!A;\nauto a6 = makeScopedA();\nauto a7 = makeScopedA();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5894_1248)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"name": "no",
								"line": 6255,
								"value": "false",
								"comment": "         When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".no) for the negative option. When using a value\n         of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".no) or just $(D false) or $(D 0).\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "yes",
								"line": 6262,
								"value": "true",
								"comment": " When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".yes) for the affirmative option. When using a\n         value of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".yes).\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Flag",
						"line": 6248,
						"comment": "\n",
						"baseDeco": "b",
						"char": 5,
						"kind": "enum"
					}
				],
				"name": "Flag",
				"line": 6246,
				"comment": "Defines a simple, self-documenting yes/no flag. This makes it easy for\nAPIs to define functions accepting flags without resorting to $(D\nbool), which is opaque in calls, and without needing to define an\nenumerated type separately. Using $(D Flag!\"Name\") instead of $(D\nbool) makes the flag's meaning visible in calls. Each yes/no flag has\nits own type, which makes confusions and mix-ups impossible.\n\nExample:\n\nCode calling $(D getLine) (usually far away from its definition) can't be\nunderstood without looking at the documentation, even by users familiar with\nthe API:\n----\nstring getLine(bool keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\nauto line = getLine(false);\n----\n\nAssuming the reverse meaning (i.e. \"ignoreTerminator\") and inserting the wrong\ncode compiles and runs with erroneous results.\n\nAfter replacing the boolean parameter with an instantiation of $(D Flag), code\ncalling $(D getLine) can be easily read and understood even by people not\nfluent with the API:\n\n----\nstring getLine(Flag!\"keepTerminator\" keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\nauto line = getLine(Flag!\"keepTerminator\".yes);\n----\n\nPassing categorical data by means of unstructured $(D bool)\nparameters is classified under \"simple-data coupling\" by Steve\nMcConnell in the $(LUCKY Code Complete) book, along with three other\nkinds of coupling. The author argues citing several studies that\ncoupling has a negative effect on code quality. $(D Flag) offers a\nsimple structuring method for passing yes/no flags to APIs.\n\nAn alias can be used to reduce the verbosity of the flag's type:\n----\nalias KeepTerminator = Flag!\"keepTerminator\";\nstring getline(KeepTerminator keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\n// Code calling getLine can now refer to flag values using the shorter name:\nauto line = getLine(KeepTerminator.yes);\n----\n",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Yes",
				"line": 6271,
				"comment": "Convenience names that allow using e.g. $(D Yes.encryption) instead of\n$(D Flag!\"encryption\".yes) and $(D No.encryption) instead of $(D\nFlag!\"encryption\".no).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6290_1262)\n---\nFlag!\"abc\" flag1;\nassert(flag1 == Flag!\"abc\".no);\nassert(flag1 == No.abc);\nassert(!flag1);\nif (flag1) assert(false);\nflag1 = Yes.abc;\nassert(flag1);\nif (!flag1) assert(false);\nif (flag1) {} else assert(false);\nassert(flag1 == Yes.abc);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6290_1262)\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "No",
				"line": 6281,
				"comment": "Ditto\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [],
				"name": "isBitFlagEnum",
				"line": 6310,
				"comment": "Detect whether an enum is of integral type and has only \"flag\" values\n(i.e. values with a bit count of exactly 1).\nAdditionally, a zero value is allowed for compatibility with enums including\na \"None\" value.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6332_1263)\n---\nenum A\n{\n    None,\n    A = 1<<0,\n    B = 1<<1,\n    C = 1<<2,\n    D = 1<<3,\n}\n\nstatic assert(isBitFlagEnum!A);\n\nenum B\n{\n    A,\n    B,\n    C,\n    D // D == 3\n}\n\nstatic assert(!isBitFlagEnum!B);\n\nenum C: double\n{\n    A = 1<<0,\n    B = 1<<1\n}\n\nstatic assert(!isBitFlagEnum!C);\n}\n\n/**\nA typesafe structure for storing combination of enum values.\n\nThis template defines a simple struct to represent bitwise OR combinations of\nenum values. It can be used if all the enum values are integral constants with\na bit count of at most 1, or if the $(D unsafe) parameter is explicitly set to\nYes.\nThis is much safer than using the enum itself to store\nthe OR combination, which can produce surprising effects like this:\n----\nenum E\n{\nA = 1<<0,\nB = 1<<1\n}\nE e = E.A | E.B;\n// will throw SwitchError\nfinal switch(e)\n{\ncase E.A:\n    return;\ncase E.B:\n    return;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6332_1263)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BitFlags",
						"line": 6390,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "BitFlags",
				"line": 6390,
				"comment": "A typesafe structure for storing combination of enum values.\n\nThis template defines a simple struct to represent bitwise OR combinations of\nenum values. It can be used if all the enum values are integral constants with\na bit count of at most 1, or if the $(D unsafe) parameter is explicitly set to\nYes.\nThis is much safer than using the enum itself to store\nthe OR combination, which can produce surprising effects like this:\n----\nenum E\n{\n    A = 1<<0,\n    B = 1<<1\n}\nE e = E.A | E.B;\n// will throw SwitchError\nfinal switch(e)\n{\n    case E.A:\n        return;\n    case E.B:\n        return;\n}\n----\nExample:\nBitFlags can be manipulated with the usual operators$(DDOX_UNITTEST_HEADER __unittestL6518_1264)\n---\n// You can use such an enum with BitFlags straight away\nenum Enum\n{\n    None,\n    A = 1<<0,\n    B = 1<<1,\n    C = 1<<2\n}\nstatic assert(__traits(compiles, BitFlags!Enum));\n\n// You need to specify the $(D unsafe) parameter for enum with custom values\nenum UnsafeEnum\n{\n    A,\n    B,\n    C,\n    D = B|C\n}\nstatic assert(!__traits(compiles, BitFlags!UnsafeEnum));\nstatic assert(__traits(compiles, BitFlags!(UnsafeEnum, Yes.unsafe)));\n\nimmutable BitFlags!Enum flags_empty;\n// A default constructed BitFlags has no value set\nassert(!(flags_empty & Enum.A) && !(flags_empty & Enum.B) && !(flags_empty & Enum.C));\n\n// Value can be set with the | operator\nimmutable BitFlags!Enum flags_A = flags_empty | Enum.A;\n\n// And tested with the & operator\nassert(flags_A & Enum.A);\n\n// Which commutes\nassert(Enum.A & flags_A);\n\n// BitFlags can be variadically initialized\nimmutable BitFlags!Enum flags_AB = BitFlags!Enum(Enum.A, Enum.B);\nassert((flags_AB & Enum.A) && (flags_AB & Enum.B) && !(flags_AB & Enum.C));\n\n// Use the ~ operator for subtracting flags\nimmutable BitFlags!Enum flags_B = flags_AB & ~BitFlags!Enum(Enum.A);\nassert(!(flags_B & Enum.A) && (flags_B & Enum.B) && !(flags_B & Enum.C));\n\n// You can use the EnumMembers template to set all flags\nimmutable BitFlags!Enum flags_all = EnumMembers!Enum;\n\n// use & between BitFlags for intersection\nimmutable BitFlags!Enum flags_BC = BitFlags!Enum(Enum.B, Enum.C);\nassert (flags_B == (flags_BC & flags_AB));\n\n// All the binary operators work in their assignment version\nBitFlags!Enum temp = flags_empty;\ntemp |= flags_AB;\nassert(temp == (flags_empty | flags_AB));\ntemp = flags_empty;\ntemp |= Enum.B;\nassert(temp == (flags_empty | Enum.B));\ntemp = flags_empty;\ntemp &= flags_AB;\nassert(temp == (flags_empty & flags_AB));\ntemp = flags_empty;\ntemp &= Enum.A;\nassert(temp == (flags_empty & Enum.A));\n\n// BitFlags with no value set evaluate to false\nassert(!flags_empty);\n\n// BitFlags with at least one value set evaluate to true\nassert(flags_A);\n\n// This can be useful to check intersection between BitFlags\nassert(flags_A & flags_AB);\nassert(flags_AB & Enum.A);\n\n// Finally, you can of course get you raw value out of flags\nauto value = cast(int)flags_A;\nassert(value == Enum.A);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6518_1264)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "unsafe",
						"defaultValue": "No.unsafe",
						"deco": "E3std8typecons28__T4FlagVAyaa6_756e73616665Z4Flag",
						"kind": "value"
					}
				],
				"constraint": "unsafe || isBitFlagEnum!E",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ReplaceType",
				"line": 6615,
				"comment": "Replaces all occurrences of `From` into `To`, in one or more types `T`. For\nexample, $(D ReplaceType!(int, uint, Tuple!(int, float)[string])) yields\n$(D Tuple!(uint, float)[string]). The types in which replacement is performed\nmay be arbitrarily complex, including qualifiers, built-in type constructors\n(pointers, arrays, associative arrays, functions, and delegates), and template\ninstantiations; replacement proceeds transitively through the type definition.\nHowever, member types in `struct`s or `class`es are not replaced because there\nare no ways to express the types resulting after replacement.\n\nThis is an advanced type manipulation necessary e.g. for replacing the\nplaceholder type `This` in $(XREF variant, Algebraic).\n\nReturns: `ReplaceType` aliases itself to the type(s) that result after\nreplacement.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6671_1265)\n---\nstatic assert(\n    is(ReplaceType!(int, string, int[]) == string[]) &&\n    is(ReplaceType!(int, string, int[int]) == string[string]) &&\n    is(ReplaceType!(int, string, const(int)[]) == const(string)[]) &&\n    is(ReplaceType!(int, string, Tuple!(int[], float))\n        == Tuple!(string[], float))\n);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6671_1265)\n",
				"parameters": [
					{
						"name": "From",
						"kind": "type"
					},
					{
						"name": "To",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a variety of type constructors, i.e., templates\nthat allow construction of new, useful general-purpose types.\n\nSource:    $(PHOBOSSRC std/_typecons.d)\n\nMacros:\n\nWIKI = Phobos/StdVariant\n\nSynopsis:\n\n----\n// value tuples\nalias Coord = Tuple!(float, \"x\", float, \"y\", float, \"z\");\nCoord c;\nc[1] = 1;       // access by index\nc.z = 1;        // access by given name\nalias DicEntry = Tuple!(string, string); // names can be omitted\n\n// Rebindable references to const and immutable objects\nvoid bar()\n{\n    const w1 = new Widget, w2 = new Widget;\n    w1.foo();\n    // w1 = w2 would not work; can't rebind const object\n    auto r = Rebindable!(const Widget)(w1);\n    // invoke method as if r were a Widget object\n    r.foo();\n    // rebind r to refer to another object\n    r = w2;\n}\n----\n\nCopyright: Copyright the respective authors, 2008-\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n           $(WEB bartoszmilewski.wordpress.com, Bartosz Milewski),\n           Don Clugston,\n           Shin Fujishiro,\n           Kenji Hara\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/conv.d",
		"name": "std.conv",
		"members": [
			{
				"members": [],
				"name": "ConvException",
				"line": 41,
				"comment": " Thrown on conversion errors.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "ConvOverflowException",
				"line": 156,
				"comment": " Thrown on conversion overflow errors.\n",
				"base": "std.conv.ConvException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "to",
								"line": 292,
								"type": "T(A args)",
								"parameters": [
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 296,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "to",
						"line": 292,
						"parameters": [
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"constraint": "!isRawStaticArray!A",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "to",
								"line": 299,
								"type": "T(ref S arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "S",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 303,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "to",
						"line": 299,
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isRawStaticArray!S",
						"char": 7,
						"kind": "template"
					}
				],
				"name": "to",
				"line": 290,
				"comment": "\nThe $(D_PARAM to) family of functions converts a value from type\n$(D_PARAM Source) to type $(D_PARAM Target). The source type is\ndeduced and the target type must be specified, for example the\nexpression $(D_PARAM to!int(42.0)) converts the number 42 from\n$(D_PARAM double) to $(D_PARAM int). The conversion is \"safe\", i.e.,\nit checks for overflow; $(D_PARAM to!int(4.2e10)) would throw the\n$(D_PARAM ConvOverflowException) exception. Overflow checks are only\ninserted when necessary, e.g., $(D_PARAM to!double(42)) does not do\nany checking because any int fits in a double.\n\nConverting a value to its own type (useful mostly for generic code)\nsimply returns its argument.\n\nExample:\n-------------------------\nint a = 42;\nauto b = to!int(a); // b is int with value 42\nauto c = to!double(3.14); // c is double with value 3.14\n-------------------------\n\nConverting among numeric types is a safe way to cast them around.\n\nConversions from floating-point types to integral types allow loss of\nprecision (the fractional part of a floating-point number). The\nconversion is truncating towards zero, the same way a cast would\ntruncate. (To round a floating point value when casting to an\nintegral, use $(D_PARAM roundTo).)\n\nExamples:\n-------------------------\nint a = 420;\nauto b = to!long(a); // same as long b = a;\nauto c = to!byte(a / 10); // fine, c = 42\nauto d = to!byte(a); // throw ConvOverflowException\ndouble e = 4.2e6;\nauto f = to!int(e); // f == 4200000\ne = -3.14;\nauto g = to!uint(e); // fails: floating-to-integral negative overflow\ne = 3.14;\nauto h = to!uint(e); // h = 3\ne = 3.99;\nh = to!uint(a); // h = 3\ne = -3.99;\nf = to!int(a); // f = -3\n-------------------------\n\nConversions from integral types to floating-point types always\nsucceed, but might lose accuracy. The largest integers with a\npredecessor representable in floating-point format are 2^24-1 for\nfloat, 2^53-1 for double, and 2^64-1 for $(D_PARAM real) (when\n$(D_PARAM real) is 80-bit, e.g. on Intel machines).\n\nExample:\n-------------------------\nint a = 16_777_215; // 2^24 - 1, largest proper integer representable as float\nassert(to!int(to!float(a)) == a);\nassert(to!int(to!float(-a)) == -a);\na += 2;\nassert(to!int(to!float(a)) == a); // fails!\n-------------------------\n\nConversions from string to numeric types differ from the C equivalents\n$(D_PARAM atoi()) and $(D_PARAM atol()) by checking for overflow and\nnot allowing whitespace.\n\nFor conversion of strings to signed types, the grammar recognized is:\n<pre>\n$(I Integer): $(I Sign UnsignedInteger)\n$(I UnsignedInteger)\n$(I Sign):\n    $(B +)\n    $(B -)\n</pre>\n\nFor conversion to unsigned types, the grammar recognized is:\n<pre>\n$(I UnsignedInteger):\n    $(I DecimalDigit)\n    $(I DecimalDigit) $(I UnsignedInteger)\n</pre>\n\nConverting an array to another array type works by converting each\nelement in turn. Associative arrays can be converted to associative\narrays as long as keys and values can in turn be converted.\n\nExample:\n-------------------------\nint[] a = [1, 2, 3];\nauto b = to!(float[])(a);\nassert(b == [1.0f, 2, 3]);\nstring str = \"1 2 3 4 5 6\";\nauto numbers = to!(double[])(split(str));\nassert(numbers == [1.0, 2, 3, 4, 5, 6]);\nint[string] c;\nc[\"a\"] = 1;\nc[\"b\"] = 2;\nauto d = to!(double[wstring])(c);\nassert(d[\"a\"w] == 1 && d[\"b\"w] == 2);\n-------------------------\n\nConversions operate transitively, meaning that they work on arrays and\nassociative arrays of any complexity:\n\n-------------------------\nint[string][double[int[]]] a;\n...\nauto b = to!(short[wstring][string[double[]]])(a);\n-------------------------\n\nThis conversion works because $(D_PARAM to!short) applies to an\n$(D_PARAM int), $(D_PARAM to!wstring) applies to a $(D_PARAM\nstring), $(D_PARAM to!string) applies to a $(D_PARAM double), and\n$(D_PARAM to!(double[])) applies to an $(D_PARAM int[]). The\nconversion might throw an exception because $(D_PARAM to!short)\nmight fail the range check.\n\n\n   Entry point that dispatches to the appropriate conversion\n   primitive. Client code normally calls $(D _to!TargetType(value))\n   (and not some variant of $(D toImpl)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 361,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 386,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 361,
				"comment": "If the source type is implicitly convertible to the target type, $(D\nto) simply performs the implicit conversion.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isImplicitlyConvertible!(S, T) && !isEnumStrToStr!(S, T) && !isNullToStr!(S, T)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 491,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 498,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 491,
				"comment": "When source type supports member template function opCast, it is used.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && is(typeof(S.init.opCast!T()) : T) && !isExactSomeString!T && !is(typeof(T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 542,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 547,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 542,
				"comment": "When target type supports 'converting construction', it is used.\n$(UL $(LI If target type is struct, $(D T(value)) is used.)\n     $(LI If target type is class, $(D new T(value)) is used.))\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && is(T == struct) && is(typeof(T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 591,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 596,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 591,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && is(T == class) && is(typeof(new T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 664,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 713,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 664,
				"comment": "Object-to-object conversions by dynamic casting throw exception when the source is\nnon-null and the target is null.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && (is(S == class) || is(S == interface)) && !is(typeof(value.opCast!T()) : T) && (is(T == class) || is(T == interface)) && !is(typeof(new T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 827,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 922,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 827,
				"comment": "Stringize conversion from all types is supported.\n$(UL\n  $(LI String _to string conversion works for any two string types having\n       ($(D char), $(D wchar), $(D dchar)) character widths and any\n       combination of qualifiers (mutable, $(D const), or $(D immutable)).)\n  $(LI Converts array (other than strings) to string.\n       Each element is converted by calling $(D to!T).)\n  $(LI Associative array to string conversion.\n       Each element is printed by calling $(D to!T).)\n  $(LI Object to string conversion calls $(D toString) against the object or\n       returns $(D \"null\") if the object is null.)\n  $(LI Struct to string conversion calls $(D toString) against the struct if\n       it is defined.)\n  $(LI For structs that do not define $(D toString), the conversion to string\n       produces the list of fields.)\n  $(LI Enumerated types are converted to strings as their symbolic names.)\n  $(LI Boolean values are printed as $(D \"true\") or $(D \"false\").)\n  $(LI $(D char), $(D wchar), $(D dchar) to a string type.)\n  $(LI Unsigned or signed integers to strings.\n       $(DL $(DT [special case])\n            $(DD Convert integral value to string in $(D_PARAM radix) radix.\n            radix must be a value from 2 to 36.\n            value is treated as a signed value only if radix is 10.\n            The characters A through Z are used to represent values 10 through 36\n            and their case is determined by the $(D_PARAM letterCase) parameter.)))\n  $(LI All floating point types to all string types.)\n  $(LI Pointer to string conversions prints the pointer as a $(D size_t) value.\n       If pointer is $(D char*), treat it as C-style strings.\n       In that case, this function is $(D @system).))\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!(isImplicitlyConvertible!(S, T) && !isEnumStrToStr!(S, T) && !isNullToStr!(S, T)) && !isInfinite!S && isExactSomeString!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1219,
						"type": "pure @trusted T(S value, uint radix, LetterCase letterCase = LetterCase.upper)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							},
							{
								"name": "radix",
								"deco": "k"
							},
							{
								"name": "letterCase",
								"type": "LetterCase",
								"default": "LetterCase.upper"
							}
						],
						"endline": 1288,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1219,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!S && isExactSomeString!T",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1317,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1346,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1317,
				"comment": "Narrowing numeric-numeric conversions throw when the value does not\nfit in the narrower type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && (isNumeric!S || isSomeChar!S || isBoolean!S) && (isNumeric!T || isSomeChar!T || isBoolean!T) && !is(T == enum)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1410,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1436,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1410,
				"comment": "Array-to-array conversion (except when target is a string type)\nconverts each element in turn by using $(D to).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isImplicitlyConvertible!(S, T) && !isSomeString!S && isDynamicArray!S && !isExactSomeString!T && isArray!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1494,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1513,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1494,
				"comment": "Associative array to associative array conversion converts each key\nand each value in turn.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isAssociativeArray!S && isAssociativeArray!T && !is(T == enum)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1727,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1739,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1727,
				"comment": "String to non-string conversion runs parsing.\n$(UL\n  $(LI When the source is a wide string, it is first converted to a narrow\n       string and then parsed.)\n  $(LI When the source is a narrow string, normal text parsing occurs.))\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!S && isDynamicArray!S && !isExactSomeString!T && is(typeof(parse!T(value)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1742,
						"type": "T(S value, uint radix)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							},
							{
								"name": "radix",
								"deco": "k"
							}
						],
						"endline": 1754,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1742,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!S && isDynamicArray!S && !isExactSomeString!T && is(typeof(parse!T(value, radix)))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toImpl",
						"line": 1783,
						"type": "T(S value)",
						"parameters": [
							{
								"name": "value",
								"type": "S"
							}
						],
						"endline": 1794,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toImpl",
				"line": 1783,
				"comment": "Convert a value that is implicitly convertible to the enum base type\ninto an Enum value. If the value does not match any enum member values\na ConvException is thrown.\nEnums with floating-point or string base types are not supported.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(T == enum) && !is(S == enum) && is(typeof(value == OriginalType!T.init)) && !isFloatingPoint!(OriginalType!T) && !isSomeString!(OriginalType!T)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "roundTo",
								"line": 1818,
								"type": "Target(Source value)",
								"parameters": [
									{
										"name": "value",
										"type": "Source"
									}
								],
								"endline": 1825,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "roundTo",
						"line": 1818,
						"parameters": [
							{
								"name": "Source",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					}
				],
				"name": "roundTo",
				"line": 1816,
				"comment": " Rounded conversion from floating point to integral.\n\nRounded conversions do not work with non-integral target types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1829_1312)\n---\nassert(roundTo!int(3.14) == 3);\nassert(roundTo!int(3.49) == 3);\nassert(roundTo!int(3.5) == 4);\nassert(roundTo!int(3.999) == 4);\nassert(roundTo!int(-3.14) == -3);\nassert(roundTo!int(-3.49) == -3);\nassert(roundTo!int(-3.5) == -4);\nassert(roundTo!int(-3.999) == -4);\nassert(roundTo!(const int)(to!(const double)(-3.999)) == -4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1829_1312)\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 1864,
						"type": "Target(ref Source s)",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1888,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 1864,
				"comment": " The $(D_PARAM parse) family of functions works quite like the\n $(D_PARAM to) family, except that (1) it only works with character ranges\n as input, (2) takes the input by reference and advances it to\n the position following the conversion, and (3) does not throw if it\n could not convert the entire input. It still throws if an overflow\n occurred during conversion or if no character of the input\n was meaningfully converted.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1891_1314)\n---\nimport std.string : munch;\nstring test = \"123 \\t  76.14\";\nauto a = parse!uint(test);\nassert(a == 123);\nassert(test == \" \\t  76.14\"); // parse bumps string\nmunch(test, \" \\t\\n\\r\"); // skip ws\nassert(test == \"76.14\");\nauto b = parse!double(test);\nassert(b == 76.14);\nassert(test == \"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1891_1314)\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Source && isSomeChar!(ElementType!Source) && is(Unqual!Target == bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 2226,
						"type": "Target(ref Source s, uint radix)",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "radix",
								"deco": "k"
							}
						],
						"endline": 2281,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 2226,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!(ElementType!Source) && isIntegral!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3054,
						"type": "Target(ref Source s)",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 3073,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3054,
				"comment": "Parsing one character off a string returns the character and bumps the\nstring up one position.\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && staticIndexOf!(Unqual!Target, dchar, Unqual!(ElementEncodingType!Source)) >= 0",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3199,
						"type": "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "lbracket",
								"deco": "w",
								"default": "'['"
							},
							{
								"name": "rbracket",
								"deco": "w",
								"default": "']'"
							},
							{
								"name": "comma",
								"deco": "w",
								"default": "','"
							}
						],
						"endline": 3226,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3199,
				"comment": " Parses an array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), and element separator (by\n default $(D ',')).\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && isDynamicArray!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3307,
						"type": "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "lbracket",
								"deco": "w",
								"default": "'['"
							},
							{
								"name": "rbracket",
								"deco": "w",
								"default": "']'"
							},
							{
								"name": "comma",
								"deco": "w",
								"default": "','"
							}
						],
						"endline": 3354,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3307,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && isStaticArray!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parse",
						"line": 3380,
						"type": "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar keyval = ':', dchar comma = ',')",
						"parameters": [
							{
								"name": "s",
								"type": "Source",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "lbracket",
								"deco": "w",
								"default": "'['"
							},
							{
								"name": "rbracket",
								"deco": "w",
								"default": "']'"
							},
							{
								"name": "keyval",
								"deco": "w",
								"default": "':'"
							},
							{
								"name": "comma",
								"deco": "w",
								"default": "','"
							}
						],
						"endline": 3415,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "parse",
				"line": 3380,
				"comment": " Parses an associative array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), key-value separator (default $(D\n ':')), and element seprator (by default $(D ',')).\n",
				"parameters": [
					{
						"name": "Target",
						"kind": "type"
					},
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isExactSomeString!Source && isAssociativeArray!Target && !is(Target == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 59,
						"name": "text",
						"line": 3638,
						"type": "string(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3638,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "text",
				"line": 3638,
				"comment": " Convenience functions for converting any number and types of\n arguments into _text (the three character widths).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3659_1345)\n---\nassert( text(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"c);\nassert(wtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"w);\nassert(dtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"d);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3659_1345)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 62,
						"name": "wtext",
						"line": 3640,
						"type": "wstring(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3640,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "wtext",
				"line": 3640,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 62,
						"name": "dtext",
						"line": 3642,
						"type": "dstring(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3642,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "dtext",
				"line": 3642,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "octal",
						"line": 3688,
						"type": "@property int()",
						"endline": 3692,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "octal",
				"line": 3688,
				"comment": "The $(D octal) facility provides a means to declare a number in base 8.\nUsing $(D octal!177) or $(D octal!\"177\") for 127 represented in octal\n(same as 0177 in C).\n\nThe rules for strings are the usual for literals: If it can fit in an\n$(D int), it is an $(D int). Otherwise, it is a $(D long). But, if the\nuser specifically asks for a $(D long) with the $(D L) suffix, always\ngive the $(D long). Give an unsigned iff it is asked for with the $(D\nU) or $(D u) suffix. _Octals created from integers preserve the type\nof the passed-in integral.\n\nSee_Also:\n    $(LREF parse) for parsing octal strings at runtime.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3723_1347)\n---\n// same as 0177\nauto x = octal!177;\n// octal is a compile-time device\nenum y = octal!160;\n// Create an unsigned octal\nauto z = octal!\"1_000_000u\";\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3723_1347)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3759_1348)\n---\nint a = octal!(int, \"10\");\n\nassert(a == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3759_1348)\n",
				"parameters": [
					{
						"name": "num",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "octalFitsInInt!num && !literalIsLong!num && !literalIsUnsigned!num",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "octal",
						"line": 3695,
						"type": "@property long()",
						"endline": 3699,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "octal",
				"line": 3695,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "num",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "(!octalFitsInInt!num || literalIsLong!num) && !literalIsUnsigned!num",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "octal",
						"line": 3702,
						"type": "@property uint()",
						"endline": 3706,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "octal",
				"line": 3702,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "num",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "octalFitsInInt!num && !literalIsLong!num && literalIsUnsigned!num",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "octal",
						"line": 3709,
						"type": "@property ulong()",
						"endline": 3713,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "octal",
				"line": 3709,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "num",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "(!octalFitsInInt!num || literalIsLong!num) && literalIsUnsigned!num",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "octal",
						"line": 3719,
						"init": "octal!(typeof(s), to!string(s))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"auto",
							"enum"
						]
					}
				],
				"name": "octal",
				"line": 3716,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "s",
						"kind": "alias"
					}
				],
				"constraint": "isIntegral!(typeof(s))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 4148,
						"type": "pure nothrow @safe T*(T* chunk)",
						"parameters": [
							{
								"name": "chunk",
								"type": "T*"
							}
						],
						"endline": 4152,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 4148,
				"comment": "Given a pointer $(D chunk) to uninitialized memory (but already typed\nas $(D T)), constructs an object of non-$(D class) type $(D T) at that\naddress.\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 4165,
						"type": "T*(T* chunk, auto ref Args args)",
						"parameters": [
							{
								"name": "chunk",
								"type": "T*"
							},
							{
								"name": "args",
								"type": "Args",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 4170,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 4165,
				"comment": "Given a pointer $(D chunk) to uninitialized memory (but already typed\nas a non-class type $(D T)), constructs an object of type $(D T) at\nthat address from arguments $(D args).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "!is(T == struct) && Args.length == 1",
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 4172,
						"type": "T*(T* chunk, auto ref Args args)",
						"parameters": [
							{
								"name": "chunk",
								"type": "T*"
							},
							{
								"name": "args",
								"type": "Args",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 4177,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 4172,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(T == struct)",
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 5050,
						"type": "T(void[] chunk, auto ref Args args)",
						"parameters": [
							{
								"name": "chunk",
								"type": "void[]"
							},
							{
								"name": "args",
								"type": "Args",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 5074,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 5050,
				"comment": "Given a raw memory area $(D chunk), constructs an object of $(D class)\ntype $(D T) at that address. The constructor is passed the arguments\n$(D Args). The $(D chunk) must be as least as large as $(D T) needs\nand should have an alignment multiple of $(D T)'s alignment. (The size\nof a $(D class) instance is obtained by using $(D\n__traits(classInstanceSize, T))).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(T == class)",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emplace",
						"line": 5097,
						"type": "T*(void[] chunk, auto ref Args args)",
						"parameters": [
							{
								"name": "chunk",
								"type": "void[]"
							},
							{
								"name": "args",
								"type": "Args",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 5102,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "emplace",
				"line": 5097,
				"comment": "Given a raw memory area $(D chunk), constructs an object of non-$(D\nclass) type $(D T) at that address. The constructor is passed the\narguments $(D args), if any. The $(D chunk) must be as least as large\nas $(D T) needs and should have an alignment multiple of $(D T)'s\nalignment.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5105_1392)\n---\nstruct S\n{\n    int a, b;\n}\nauto p = new void[S.sizeof];\nS s;\ns.a = 42;\ns.b = 43;\nauto s1 = emplace!S(p, s);\nassert(s1.a == 42 && s1.b == 43);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5105_1392)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "!is(T == class)",
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "unsigned",
						"line": 5203,
						"type": "(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 5206,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "unsigned",
				"line": 5203,
				"comment": "    Returns the corresponding _unsigned value for $(D x) (e.g. if $(D x) has type\n    $(D int), it returns $(D cast(uint) x)). The advantage compared to the cast\n    is that you do not need to rewrite the cast if $(D x) later changes type\n    (e.g from $(D int) to $(D long)).\n\n    Note that the result is always mutable even if the original type was const\n    or immutable. In order to retain the constness, use $(XREF traits, Unsigned).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5209_1397)\n---\nimmutable int s = 42;\nauto u1 = unsigned(s); //not qualified\nstatic assert(is(typeof(u1) == uint));\nUnsigned!(typeof(s)) u2 = unsigned(s); //same qualification\nstatic assert(is(typeof(u2) == immutable uint));\nimmutable u3 = unsigned(s); //explicitly qualified\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5209_1397)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "signed",
						"line": 5277,
						"type": "(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 5280,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "signed",
				"line": 5277,
				"comment": "    Returns the corresponding _signed value for $(D x) (e.g. if $(D x) has type\n    $(D uint), it returns $(D cast(int) x)). The advantage compared to the cast\n    is that you do not need to rewrite the cast if $(D x) later changes type\n    (e.g from $(D uint) to $(D ulong)).\n\n    Note that the result is always mutable even if the original type was const\n    or immutable. In order to retain the constness, use $(XREF traits, Signed).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5283_1400)\n---\nimmutable uint u = 42;\nauto s1 = signed(u); //not qualified\nstatic assert(is(typeof(s1) == int));\nSigned!(typeof(u)) s2 = signed(u); //same qualification\nstatic assert(is(typeof(s2) == immutable int));\nimmutable s3 = signed(u); //explicitly qualified\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5283_1400)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "to",
								"line": 5355,
								"type": "ref @system (auto ref T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T",
										"storageClass": [
											"auto",
											"ref"
										]
									}
								],
								"endline": 5369,
								"char": 14,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "to",
						"line": 5355,
						"comment": "        Params:\n            To    = The type _to cast _to.\n            value = The value _to cast. It must be of type $(D From),\n                    otherwise a compile-time error is emitted.\n\n        Returns:\n            the value after the cast, returned by reference if possible.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5372_1403)\n---\n// Regular cast, which has been verified to be legal by the programmer:\n{\n    long x;\n    auto y = cast(int) x;\n}\n\n// However this will still compile if 'x' is changed to be a pointer:\n{\n    long* x;\n    auto y = cast(int) x;\n}\n\n// castFrom provides a more reliable alternative to casting:\n{\n    long x;\n    auto y = castFrom!long.to!int(x);\n}\n\n// Changing the type of 'x' will now issue a compiler error,\n// allowing bad casts to be caught before it's too late:\n{\n    long* x;\n    static assert (\n        !__traits(compiles, castFrom!long.to!int(x))\n    );\n\n    // if cast is still needed, must be changed to:\n    auto y = castFrom!(long*).to!int(x);\n}\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5372_1403)\n",
						"parameters": [
							{
								"name": "To",
								"kind": "type"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 14,
						"kind": "template"
					}
				],
				"name": "castFrom",
				"line": 5344,
				"comment": "    A wrapper on top of the built-in cast operator that allows one to restrict\n    casting of the original type of the value.\n\n    A common issue with using a raw cast is that it may silently continue to\n    compile even if the value's type has changed during refactoring,\n    which breaks the initial assumption about the cast.\n\n    Params:\n        From  = The type to cast from. The programmer must ensure it is legal\n                to make this cast.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5444_1404)\n---\n// test all the hex digits\nstatic assert( (\"0123456789abcdefABCDEF\").isHexLiteral);\n// empty or white strings are not valid\nstatic assert( \"\\r\\n\\t\".isHexLiteral);\n// but are accepted if the count of hex digits is even\nstatic assert( \"A\\r\\n\\tB\".isHexLiteral);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5444_1404)\n",
				"parameters": [
					{
						"name": "From",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hexString",
						"line": 5522,
						"init": "hexStrImpl(hexData)",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					}
				],
				"name": "hexString",
				"line": 5519,
				"comment": "Converts a hex literal to a string at compile time.\n\nTakes a string made of hexadecimal digits and returns\nthe matching string by converting each pair of digits to a character.\nThe input string can also include white characters, which can be used\nto keep the literal string readable in the source code.\n\nThe function is intended to replace the hexadecimal literal strings\nstarting with $(D 'x'), which could be removed to simplify the core language.\n\nParams:\n    hexData = string to be converted.\n\nReturns:\n    a $(D string), a $(D wstring) or a $(D dstring), according to the type of hexData.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5540_1406)\n---\n// conversion at compile time\nauto string1 = hexString!\"304A314B\";\nassert(string1 == \"0J1K\");\nauto string2 = hexString!\"304A314B\"w;\nassert(string2 == \"0J1K\"w);\nauto string3 = hexString!\"304A314B\"d;\nassert(string3 == \"0J1K\"d);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5540_1406)\n",
				"parameters": [
					{
						"name": "hexData",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "hexData.isHexLiteral",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hexString",
						"line": 5529,
						"init": "hexStrImpl(hexData)",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					}
				],
				"name": "hexString",
				"line": 5526,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "hexData",
						"deco": "Ayu",
						"kind": "value"
					}
				],
				"constraint": "hexData.isHexLiteral",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hexString",
						"line": 5536,
						"init": "hexStrImpl(hexData)",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					}
				],
				"name": "hexString",
				"line": 5533,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "hexData",
						"deco": "Ayw",
						"kind": "value"
					}
				],
				"constraint": "hexData.isHexLiteral",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "A one-stop shop for converting values from one type to another.\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Shin Fujishiro,\n           Adam D. Ruppe,\n           Kenji Hara\n\nSource:    $(PHOBOSSRC std/_conv.d)\n\nMacros:\nWIKI = Phobos/StdConv\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/numeric.d",
		"name": "std.numeric",
		"members": [
			{
				"members": [
					{
						"name": "signed",
						"line": 41,
						"value": "1",
						"comment": "Adds a sign bit to allow for signed numbers.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "storeNormalized",
						"line": 49,
						"value": "2",
						"comment": " Store values in normalized form by default. The actual precision of the\n significand is extended by 1 bit by assuming an implicit leading bit of 1\n instead of 0. i.e. $(D 1.nnnn) instead of $(D 0.nnnn).\n True for all $(LUCKY IEE754) types\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "allowDenorm",
						"line": 55,
						"value": "4",
						"comment": " Stores the significand in $(LUCKY IEEE754 denormalized) form when the\n exponent is 0. Required to express the value 0.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "infinity",
						"line": 58,
						"value": "8",
						"comment": "Allows the storage of $(LUCKY IEEE754 _infinity) values.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nan",
						"line": 61,
						"value": "16",
						"comment": "Allows the storage of $(LUCKY IEEE754 Not a Number) values.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "probability",
						"line": 68,
						"value": "32",
						"comment": " If set, select an exponent bias such that max_exp = 1.\n i.e. so that the maximum value is >= 1.0 and < 2.0.\n Ignored if the exponent bias is manually specified.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "negativeUnsigned",
						"line": 71,
						"value": "64",
						"comment": "If set, unsigned custom floats are assumed to be negative.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "allowDenormZeroOnly",
						"line": 76,
						"value": "134",
						"comment": "If set, 0 is the only allowed $(LUCKY IEEE754 denormalized) number.\n Requires allowDenorm and storeNormalized.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ieee",
						"line": 79,
						"value": "31",
						"comment": "Include _all of the $(LUCKY IEEE754) options.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "none",
						"line": 82,
						"value": "0",
						"comment": "Include none of the above options.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CustomFloatFlags",
				"line": 38,
				"comment": "Format flags for CustomFloat.\n",
				"baseDeco": "i",
				"char": 8,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "CustomFloat",
						"line": 137,
						"type": "CustomFloat!(CustomFloatParams!bits)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CustomFloat",
				"line": 134,
				"comment": " Allows user code to define custom floating-point formats. These formats are\n for storage only; all operations on them are performed by first implicitly\n extracting them to $(D real) first. After the operation is completed the\n result can be stored in a custom floating-point value via assignment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL148_1408)\n---\n// Define a 16-bit floating point values\nCustomFloat!16                                x;     // Using the number of bits\nCustomFloat!(10, 5)                           y;     // Using the precision and exponent width\nCustomFloat!(10, 5,CustomFloatFlags.ieee)     z;     // Using the precision, exponent width and format flags\nCustomFloat!(10, 5,CustomFloatFlags.ieee, 15) w;     // Using the precision, exponent width, format flags and exponent offset bias\n\n// Use the 16-bit floats mostly like normal numbers\nw = x*y - 1;\n\n// Functions calls require conversion\nz = sin(+x)           + cos(+y);                     // Use unary plus to concisely convert to a real\nz = sin(x.get!float)  + cos(y.get!float);            // Or use get!T\nz = sin(cast(float)x) + cos(cast(float)y);           // Or use cast(T) to explicitly convert\n\n// Define a 8-bit custom float for storing probabilities\nalias Probability = CustomFloat!(4, 4, CustomFloatFlags.ieee^CustomFloatFlags.probability^CustomFloatFlags.signed );\nauto p = Probability(0.5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL148_1408)\n",
				"parameters": [
					{
						"name": "bits",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "bits == 8 || bits == 16 || bits == 32 || bits == 64 || bits == 80",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CustomFloat",
						"line": 144,
						"type": "CustomFloat!(CustomFloatParams!(precision, exponentWidth, flags))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CustomFloat",
				"line": 141,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "precision",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "exponentWidth",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "flags",
						"defaultValue": "CustomFloatFlags.ieee",
						"deco": "E3std7numeric16CustomFloatFlags",
						"kind": "value"
					}
				],
				"constraint": "((flags & flags.signed) + precision + exponentWidth) % 8 == 0 && precision + exponentWidth > 0",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CustomFloat",
						"line": 170,
						"members": [
							{
								"endchar": 5,
								"name": "dig",
								"line": 424,
								"comment": "Returns: number of decimal digits of precision\n",
								"type": "@property size_t()",
								"endline": 429,
								"char": 29,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 5,
								"name": "epsilon",
								"line": 432,
								"comment": "Returns: smallest increment to the value 1\n",
								"type": "@property CustomFloat()",
								"endline": 452,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"name": "mant_dig",
								"line": 455,
								"comment": "the number of bits in mantissa\n",
								"init": "precision + ((flags & Flags.storeNormalized) != 0)",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 72,
								"name": "max_10_exp",
								"line": 458,
								"comment": "Returns: maximum int value such that 10<sup>max_10_exp</sup> is representable\n",
								"type": "@property int()",
								"endline": 458,
								"char": 26,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"name": "max_exp",
								"line": 461,
								"comment": "maximum int value such that 2<sup>max_exp-1</sup> is representable\n",
								"init": "exponent_max - bias + ((~flags & (Flags.infinity | flags.nan)) != 0)",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 79,
								"name": "min_10_exp",
								"line": 464,
								"comment": "Returns: minimum int value such that 10<sup>min_10_exp</sup> is representable\n",
								"type": "@property int()",
								"endline": 464,
								"char": 26,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"name": "min_exp",
								"line": 467,
								"comment": "minimum int value such that 2<sup>min_exp-1</sup> is representable as a normalized value\n",
								"init": "cast(T_signed_exp)-bias + 1 + ((flags & Flags.allowDenorm) != 0)",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "max",
								"line": 470,
								"comment": "Returns: largest representable value that's not infinity\n",
								"type": "@property CustomFloat()",
								"endline": 478,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 5,
								"name": "min_normal",
								"line": 481,
								"comment": "Returns: smallest representable normalized value that's not 0\n",
								"type": "@property CustomFloat()",
								"endline": 491,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"endchar": 47,
								"name": "re",
								"line": 494,
								"comment": "Returns: real part\n",
								"type": "@property CustomFloat()",
								"endline": 494,
								"char": 27,
								"kind": "function"
							},
							{
								"endchar": 67,
								"name": "im",
								"line": 497,
								"comment": "Returns: imaginary part\n",
								"type": "@property CustomFloat()",
								"endline": 497,
								"char": 34,
								"kind": "function",
								"storageClass": [
									"static"
								]
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 500,
										"type": "(F input)",
										"parameters": [
											{
												"name": "input",
												"type": "F"
											}
										],
										"endline": 503,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 500,
								"comment": "Initialize from any $(D real) compatible type.\n",
								"parameters": [
									{
										"name": "F",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, cast(real)input)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 506,
										"type": "void(F input)",
										"parameters": [
											{
												"name": "input",
												"type": "F"
											}
										],
										"endline": 512,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 506,
								"comment": "Self assignment\n",
								"parameters": [
									{
										"name": "F",
										"type": "CustomFloat",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 515,
										"type": "void(F input)",
										"parameters": [
											{
												"name": "input",
												"type": "F"
											}
										],
										"endline": 545,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 515,
								"comment": "Assigns from any $(D real) compatible type.\n",
								"parameters": [
									{
										"name": "F",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, cast(real)input)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "get",
										"line": 548,
										"type": "@property F()",
										"endline": 570,
										"char": 17,
										"kind": "function"
									}
								],
								"name": "get",
								"line": 548,
								"comment": "Fetches the stored value either as a $(D float), $(D double) or $(D real).\n",
								"parameters": [
									{
										"name": "F",
										"kind": "type"
									}
								],
								"constraint": "staticIndexOf!(Unqual!F, float, double, real) >= 0",
								"char": 17,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opCast",
										"line": 573,
										"type": "T()",
										"endline": 573,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opCast",
								"line": 573,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, get!T)",
								"char": 7,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opUnary",
										"line": 576,
										"type": "real()",
										"endline": 587,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opUnary",
								"line": 576,
								"comment": "Convert the CustomFloat to a real and perform the relavent operator on the result\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "__traits(compiles, mixin(op ~ \"(get!real)\")) || op == \"++\" || op == \"--\"",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 590,
										"type": "real(T b)",
										"parameters": [
											{
												"name": "b",
												"type": "T"
											}
										],
										"endline": 594,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 590,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, mixin(\"get!real\" ~ op ~ \"b\"))",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 597,
										"type": "real(T a)",
										"parameters": [
											{
												"name": "a",
												"type": "T"
											}
										],
										"endline": 602,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 597,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, mixin(\"a\" ~ op ~ \"get!real\")) && !__traits(compiles, mixin(\"get!real\" ~ op ~ \"b\"))",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCmp",
										"line": 605,
										"type": "int(auto ref T b)",
										"parameters": [
											{
												"name": "b",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 611,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 605,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, cast(real)b)",
								"char": 9,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 614,
										"type": "void(auto ref T b)",
										"parameters": [
											{
												"name": "b",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 618,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 614,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "__traits(compiles, mixin(\"get!real\" ~ op ~ \"cast(real)b\"))",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"members": [
											{
												"endchar": 9,
												"name": "toString",
												"line": 625,
												"type": "void(scope void delegate(const(char)[]) sink, FormatSpec!char fmt)",
												"parameters": [
													{
														"name": "sink",
														"type": "void delegate(const(char)[])",
														"storageClass": [
															"scope"
														]
													},
													{
														"name": "fmt",
														"type": "FormatSpec!char"
													}
												],
												"endline": 628,
												"char": 14,
												"kind": "function"
											}
										],
										"name": "toString",
										"line": 625,
										"parameters": [],
										"char": 14,
										"kind": "template"
									}
								],
								"name": "toString",
								"line": 621,
								"comment": "ditto\n",
								"parameters": [],
								"char": 5,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "CustomFloat",
				"line": 170,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "precision",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "exponentWidth",
						"deco": "k",
						"kind": "value"
					},
					{
						"name": "flags",
						"deco": "E3std7numeric16CustomFloatFlags",
						"kind": "value"
					},
					{
						"name": "bias",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "((flags & flags.signed) + precision + exponentWidth) % 8 == 0 && precision + exponentWidth > 0",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "FPTemporary",
						"line": 701,
						"deco": "e",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "FPTemporary",
				"line": 698,
				"comment": "Defines the fastest type to use when storing temporaries of a\ncalculation intended to ultimately yield a result of type $(D F)\n(where $(D F) must be one of $(D float), $(D double), or $(D\nreal)). When doing a multi-step computation, you may want to store\nintermediate results as $(D FPTemporary!F).\n\nThe necessity of $(D FPTemporary) stems from the optimized\nfloating-point operations and registers present in virtually all\nprocessors. When adding numbers in the example above, the addition may\nin fact be done in $(D real) precision internally. In that case,\nstoring the intermediate $(D result) in $(D double format) is not only\nless precise, it is also (surprisingly) slower, because a conversion\nfrom $(D real) to $(D double) is performed every pass through the\nloop. This being a lose-lose situation, $(D FPTemporary!F) has been\ndefined as the $(I fastest) type to use for calculations at precision\n$(D F). There is no need to define a type for the $(I most accurate)\ncalculations, as that is always $(D real).\n\nFinally, there is no guarantee that using $(D FPTemporary!F) will\nalways be fastest, as the speed of floating-point calculations depends\non very many factors.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL705_1411)\n---\n// Average numbers in an array\ndouble avg(in double[] a)\n{\n    if (a.length == 0) return 0;\n    FPTemporary!double result = 0;\n    foreach (e; a) result += e;\n    return result / a.length;\n}\n\nauto a = [1.0, 2.0, 3.0];\nassert(approxEqual(avg(a), 2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL705_1411)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "secantMethod",
								"line": 729,
								"type": "Num(Num xn_1, Num xn)",
								"parameters": [
									{
										"name": "xn_1",
										"type": "Num"
									},
									{
										"name": "xn",
										"type": "Num"
									}
								],
								"endline": 744,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "secantMethod",
						"line": 729,
						"parameters": [
							{
								"name": "Num",
								"kind": "type"
							}
						],
						"char": 9,
						"kind": "template"
					}
				],
				"name": "secantMethod",
				"line": 726,
				"comment": "Implements the $(WEB tinyurl.com/2zb9yr, secant method) for finding a\nroot of the function $(D fun) starting from points $(D [xn_1, x_n])\n(ideally close to the root). $(D Num) may be $(D float), $(D double),\nor $(D real).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL748_1412)\n---\nfloat f(float x)\n{\n    return cos(x) - x*x*x;\n}\nauto x = secantMethod!(f)(0f, 1f);\nassert(approxEqual(x, 0.865474));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL748_1412)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 808,
						"type": "T(scope DF f, in T a, in T b, scope DT tolerance)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "a",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "b",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "tolerance",
								"type": "DT",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 825,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 808,
				"comment": "  Find a real root of a real function f(x) via bracketing.\n\n Given a function $(D f) and a range $(D [a..b]) such that $(D f(a))\n and $(D f(b)) have opposite signs or at least one of them equals Â±0,\n returns the value of $(D x) in\n the range which is closest to a root of $(D f(x)).  If $(D f(x))\n has more than one root in the range, one will be chosen\n arbitrarily.  If $(D f(x)) returns NaN, NaN will be returned;\n otherwise, this algorithm is guaranteed to succeed.\n\n Uses an algorithm based on TOMS748, which uses inverse cubic\n interpolation whenever possible, otherwise reverting to parabolic\n or secant interpolation. Compared to TOMS748, this implementation\n improves worst-case performance by a factor of more than 100, and\n typical performance by a factor of 2. For 80-bit reals, most\n problems require 8 to 15 calls to $(D f(x)) to achieve full machine\n precision. The worst-case performance (pathological cases) is\n approximately twice the number of bits.\n\n References: \"On Enclosing Simple Roots of Nonlinear Equations\",\n G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,\n pp733-744 (1993).  Fortran code available from $(WEB\n www.netlib.org,www.netlib.org) as algorithm TOMS478.\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					},
					{
						"name": "DT",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T && is(typeof(tolerance(T.init, T.init)) : bool) && is(typeof(f(T.init)) == R, R) && isFloatingPoint!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 828,
						"type": "T(scope DF f, in T a, in T b)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "a",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "b",
								"type": "T",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 831,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 828,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 866,
						"type": "Tuple!(T, T, R, R)(scope DF f, in T ax, in T bx, in R fax, in R fbx, scope DT tolerance)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "ax",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "bx",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fax",
								"type": "R",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fbx",
								"type": "R",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "tolerance",
								"type": "DT",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 1170,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 866,
				"comment": " Find root of a real function f(x) by bracketing, allowing the\n termination condition to be specified.\n\n Params:\n\n f = Function to be analyzed\n\n ax = Left bound of initial range of $(D f) known to contain the\n root.\n\n bx = Right bound of initial range of $(D f) known to contain the\n root.\n\n fax = Value of $(D f(ax)).\n\n fbx = Value of $(D f(bx)). $(D fax) and $(D fbx) should have opposite signs.\n ($(D f(ax)) and $(D f(bx)) are commonly known in advance.)\n\n\n tolerance = Defines an early termination condition. Receives the\n             current upper and lower bounds on the root. The\n             delegate must return $(D true) when these bounds are\n             acceptable. If this function always returns $(D false),\n             full machine precision will be achieved.\n\n Returns:\n\n A tuple consisting of two ranges. The first two elements are the\n range (in $(D x)) of the root, while the second pair of elements\n are the corresponding function values at those points. If an exact\n root was found, both of the first two elements will contain the\n root, and the second pair of elements will be 0.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					},
					{
						"name": "DT",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T && is(typeof(tolerance(T.init, T.init)) : bool) && is(typeof(f(T.init)) == R) && isFloatingPoint!R",
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 1173,
						"type": "Tuple!(T, T, R, R)(scope DF f, in T ax, in T bx, in R fax, in R fbx)",
						"parameters": [
							{
								"name": "f",
								"type": "DF",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "ax",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "bx",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fax",
								"type": "R",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "fbx",
								"type": "R",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1176,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 1173,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "DF",
						"kind": "type"
					}
				],
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findRoot",
						"line": 1179,
						"type": "T(scope R delegate(T) f, in T a, in T b, scope bool delegate(T lo, T hi) tolerance = (T a, T b) => false)",
						"parameters": [
							{
								"name": "f",
								"type": "R delegate(T)",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "a",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "b",
								"type": "T",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "tolerance",
								"type": "bool delegate(T lo, T hi)",
								"storageClass": [
									"scope"
								],
								"default": ""
							}
						],
						"endline": 1183,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "findRoot",
				"line": 1179,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "euclideanDistance",
						"line": 1411,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1424,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "euclideanDistance",
				"line": 1411,
				"comment": "Computes $(LUCKY Euclidean distance) between input ranges $(D a) and\n$(D b). The two ranges must have the same length. The three-parameter\nversion stops computation as soon as the distance is greater than or\nequal to $(D limit) (this is useful to save computation if a small\ndistance is sought).\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "euclideanDistance",
						"line": 1428,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b, F limit)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							},
							{
								"name": "limit",
								"type": "F"
							}
						],
						"endline": 1447,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "euclideanDistance",
				"line": 1428,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dotProduct",
						"line": 1470,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1483,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "dotProduct",
				"line": 1470,
				"comment": "Computes the $(LUCKY dot product) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration.\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && !(isArray!Range1 && isArray!Range2)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dotProduct",
						"line": 1487,
						"type": "CommonType!(F1, F2)(in F1[] avector, in F2[] bvector)",
						"parameters": [
							{
								"name": "avector",
								"type": "F1[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "bvector",
								"type": "F2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1537,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "dotProduct",
				"line": 1487,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "F1",
						"kind": "type"
					},
					{
						"name": "F2",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cosineSimilarity",
						"line": 1565,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1581,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "cosineSimilarity",
				"line": 1565,
				"comment": "Computes the $(LUCKY cosine similarity) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration. If either range has all-zero elements, return 0.\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "normalize",
						"line": 1606,
						"type": "bool(R range, ElementType!R sum = 1)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "sum",
								"type": "ElementType!R",
								"default": "1"
							}
						],
						"endline": 1644,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "normalize",
				"line": 1606,
				"comment": "Normalizes values in $(D range) by multiplying each element with a\nnumber chosen such that values sum up to $(D sum). If elements in $(D\nrange) sum to zero, assigns $(D sum / range.length) to\nall. Normalization makes sense only if all elements in $(D range) are\npositive. $(D normalize) assumes that is the case without checking it.\n\nReturns: $(D true) if normalization completed normally, $(D false) if\nall elements in $(D range) were zero or if $(D range) is empty.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1647_1420)\n---\ndouble[] a = [];\nassert(!normalize(a));\na = [ 1.0, 3.0 ];\nassert(normalize(a));\nassert(a == [ 0.25, 0.75 ]);\na = [ 0.0, 0.0 ];\nassert(!normalize(a));\nassert(a == [ 0.5, 0.5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1647_1420)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sumOfLog2s",
						"line": 1663,
						"type": "ElementType!Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1682,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "sumOfLog2s",
				"line": 1663,
				"comment": "Compute the sum of binary logarithms of the input range $(D r).\nThe error of this method is much smaller than with a naive sum of log2.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1685_1421)\n---\nassert(sumOfLog2s(new double[0]) == 0);\nassert(sumOfLog2s([0.0L]) == -real.infinity);\nassert(sumOfLog2s([-0.0L]) == -real.infinity);\nassert(sumOfLog2s([2.0L]) == 1);\nassert(sumOfLog2s([-2.0L]).isNaN());\nassert(sumOfLog2s([real.nan]).isNaN());\nassert(sumOfLog2s([-real.nan]).isNaN());\nassert(sumOfLog2s([real.infinity]) == real.infinity);\nassert(sumOfLog2s([-real.infinity]).isNaN());\nassert(sumOfLog2s([ 0.25, 0.25, 0.25, 0.125 ]) == -9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1685_1421)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isFloatingPoint!(ElementType!Range)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entropy",
						"line": 1707,
						"type": "ElementType!Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1716,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "entropy",
				"line": 1707,
				"comment": "Computes $(LUCKY _entropy) of input range $(D r) in bits. This\nfunction assumes (without checking) that the values in $(D r) are all\nin $(D [0, 1]). For the entropy to be meaningful, often $(D r) should\nbe normalized too (i.e., its values should sum to 1). The\ntwo-parameter version stops evaluating as soon as the intermediate\nresult is greater than or equal to $(D max).\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entropy",
						"line": 1719,
						"type": "ElementType!Range(Range r, F max)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "max",
								"type": "F"
							}
						],
						"endline": 1731,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "entropy",
				"line": 1719,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !is(CommonType!(ElementType!Range, F) == void)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "kullbackLeiblerDivergence",
						"line": 1759,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1776,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "kullbackLeiblerDivergence",
				"line": 1759,
				"comment": "Computes the $(LUCKY Kullback-Leibler divergence) between input ranges\n$(D a) and $(D b), which is the sum $(D ai * log(ai / bi)). The base\nof logarithm is 2. The ranges are assumed to contain elements in $(D\n[0, 1]). Usually the ranges are normalized probability distributions,\nbut this is not required or checked by $(D\nkullbackLeiblerDivergence). If any element $(D bi) is zero and the\ncorresponding element $(D ai) nonzero, returns infinity. (Otherwise,\nif $(D ai == 0 && bi == 0), the term $(D ai * log(ai / bi)) is\nconsidered zero.) If the inputs are normalized, the result is\npositive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1779_1423)\n---\ndouble[] p = [ 0.0, 0, 0, 1 ];\nassert(kullbackLeiblerDivergence(p, p) == 0);\ndouble[] p1 = [ 0.25, 0.25, 0.25, 0.25 ];\nassert(kullbackLeiblerDivergence(p1, p1) == 0);\nassert(kullbackLeiblerDivergence(p, p1) == 2);\nassert(kullbackLeiblerDivergence(p1, p) == double.infinity);\ndouble[] p2 = [ 0.2, 0.2, 0.2, 0.4 ];\nassert(approxEqual(kullbackLeiblerDivergence(p1, p2), 0.0719281));\nassert(approxEqual(kullbackLeiblerDivergence(p2, p1), 0.0780719));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1779_1423)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "jensenShannonDivergence",
						"line": 1804,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							}
						],
						"endline": 1827,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "jensenShannonDivergence",
				"line": 1804,
				"comment": "Computes the $(LUCKY Jensen-Shannon divergence) between $(D a) and $(D\nb), which is the sum $(D (ai * log(2 * ai / (ai + bi)) + bi * log(2 *\nbi / (ai + bi))) / 2). The base of logarithm is 2. The ranges are\nassumed to contain elements in $(D [0, 1]). Usually the ranges are\nnormalized probability distributions, but this is not required or\nchecked by $(D jensenShannonDivergence). If the inputs are normalized,\nthe result is bounded within $(D [0, 1]). The three-parameter version\nstops evaluations as soon as the intermediate result is greater than\nor equal to $(D limit).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1860_1424)\n---\ndouble[] p = [ 0.0, 0, 0, 1 ];\nassert(jensenShannonDivergence(p, p) == 0);\ndouble[] p1 = [ 0.25, 0.25, 0.25, 0.25 ];\nassert(jensenShannonDivergence(p1, p1) == 0);\nassert(approxEqual(jensenShannonDivergence(p1, p), 0.548795));\ndouble[] p2 = [ 0.2, 0.2, 0.2, 0.4 ];\nassert(approxEqual(jensenShannonDivergence(p1, p2), 0.0186218));\nassert(approxEqual(jensenShannonDivergence(p2, p1), 0.0186218));\nassert(approxEqual(jensenShannonDivergence(p2, p1, 0.005), 0.00602366));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1860_1424)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(CommonType!(ElementType!Range1, ElementType!Range2))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "jensenShannonDivergence",
						"line": 1831,
						"type": "CommonType!(ElementType!Range1, ElementType!Range2)(Range1 a, Range2 b, F limit)",
						"parameters": [
							{
								"name": "a",
								"type": "Range1"
							},
							{
								"name": "b",
								"type": "Range2"
							},
							{
								"name": "limit",
								"type": "F"
							}
						],
						"endline": 1857,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "jensenShannonDivergence",
				"line": 1831,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(CommonType!(ElementType!Range1, ElementType!Range2).init >= F.init) : bool)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gapWeightedSimilarity",
						"line": 1944,
						"type": "F(R1 s, R2 t, F lambda)",
						"parameters": [
							{
								"name": "s",
								"type": "R1"
							},
							{
								"name": "t",
								"type": "R2"
							},
							{
								"name": "lambda",
								"type": "F"
							}
						],
						"endline": 1988,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "gapWeightedSimilarity",
				"line": 1944,
				"comment": "The so-called \"all-lengths gap-weighted string kernel\" computes a\nsimilarity measure between $(D s) and $(D t) based on all of their\ncommon subsequences of all lengths. Gapped subsequences are also\nincluded.\n\nTo understand what $(D gapWeightedSimilarity(s, t, lambda)) computes,\nconsider first the case $(D lambda = 1) and the strings $(D s =\n[\"Hello\", \"brave\", \"new\", \"world\"]) and $(D t = [\"Hello\", \"new\",\n\"world\"]). In that case, $(D gapWeightedSimilarity) counts the\nfollowing matches:\n\n$(OL $(LI three matches of length 1, namely $(D \"Hello\"), $(D \"new\"),\nand $(D \"world\");) $(LI three matches of length 2, namely ($(D\n\"Hello\", \"new\")), ($(D \"Hello\", \"world\")), and ($(D \"new\", \"world\"));)\n$(LI one match of length 3, namely ($(D \"Hello\", \"new\", \"world\")).))\n\nThe call $(D gapWeightedSimilarity(s, t, 1)) simply counts all of\nthese matches and adds them up, returning 7.\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 1) == 7);\n----\n\nNote how the gaps in matching are simply ignored, for example ($(D\n\"Hello\", \"new\")) is deemed as good a match as ($(D \"new\",\n\"world\")). This may be too permissive for some applications. To\neliminate gapped matches entirely, use $(D lambda = 0):\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0) == 4);\n----\n\nThe call above eliminated the gapped matches ($(D \"Hello\", \"new\")),\n($(D \"Hello\", \"world\")), and ($(D \"Hello\", \"new\", \"world\")) from the\ntally. That leaves only 4 matches.\n\nThe most interesting case is when gapped matches still participate in\nthe result, but not as strongly as ungapped matches. The result will\nbe a smooth, fine-grained similarity measure between the input\nstrings. This is where values of $(D lambda) between 0 and 1 enter\ninto play: gapped matches are $(I exponentially penalized with the\nnumber of gaps) with base $(D lambda). This means that an ungapped\nmatch adds 1 to the return value; a match with one gap in either\nstring adds $(D lambda) to the return value; ...; a match with a total\nof $(D n) gaps in both strings adds $(D pow(lambda, n)) to the return\nvalue. In the example above, we have 4 matches without gaps, 2 matches\nwith one gap, and 1 match with three gaps. The latter match is ($(D\n\"Hello\", \"world\")), which has two gaps in the first string and one gap\nin the second string, totaling to three gaps. Summing these up we get\n$(D 4 + 2 * lambda + pow(lambda, 3)).\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);\n----\n\n$(D gapWeightedSimilarity) is useful wherever a smooth similarity\nmeasure between sequences allowing for approximate matches is\nneeded. The examples above are given with words, but any sequences\nwith elements comparable for equality are allowed, e.g. characters or\nnumbers. $(D gapWeightedSimilarity) uses a highly optimized dynamic\nprogramming implementation that needs $(D 16 * min(s.length,\nt.length)) extra bytes of memory and $(BIGOH s.length * t.length) time\nto complete.\n",
				"parameters": [
					{
						"name": "comp",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R1 && hasLength!R1 && isRandomAccessRange!R2 && hasLength!R2",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gapWeightedSimilarityNormalized",
						"line": 2021,
						"type": "Select!(isFloatingPoint!F, F, double)(R1 s, R2 t, F lambda, F sSelfSim = F.init, F tSelfSim = F.init)",
						"parameters": [
							{
								"name": "s",
								"type": "R1"
							},
							{
								"name": "t",
								"type": "R2"
							},
							{
								"name": "lambda",
								"type": "F"
							},
							{
								"name": "sSelfSim",
								"type": "F",
								"default": "F.init"
							},
							{
								"name": "tSelfSim",
								"type": "F",
								"default": "F.init"
							}
						],
						"endline": 2042,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "gapWeightedSimilarityNormalized",
				"line": 2021,
				"comment": "The similarity per $(D gapWeightedSimilarity) has an issue in that it\ngrows with the lengths of the two strings, even though the strings are\nnot actually very similar. For example, the range $(D [\"Hello\",\n\"world\"]) is increasingly similar with the range $(D [\"Hello\",\n\"world\", \"world\", \"world\",...]) as more instances of $(D \"world\") are\nappended. To prevent that, $(D gapWeightedSimilarityNormalized)\ncomputes a normalized version of the similarity that is computed as\n$(D gapWeightedSimilarity(s, t, lambda) /\nsqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,\nlambda))). The function $(D gapWeightedSimilarityNormalized) (a\nso-called normalized kernel) is bounded in $(D [0, 1]), reaches $(D 0)\nonly for ranges that don't match in any position, and $(D 1) only for\nidentical ranges.\n\nThe optional parameters $(D sSelfSim) and $(D tSelfSim) are meant for\navoiding duplicate computation. Many applications may have already\ncomputed $(D gapWeightedSimilarity(s, s, lambda)) and/or $(D\ngapWeightedSimilarity(t, t, lambda)). In that case, they can be passed\nas $(D sSelfSim) and $(D tSelfSim), respectively.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2045_1426)\n---\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, s, 1) == 15);\nassert(gapWeightedSimilarity(t, t, 1) == 7);\nassert(gapWeightedSimilarity(s, t, 1) == 7);\nassert(approxEqual(gapWeightedSimilarityNormalized(s, t, 1),\n                7.0 / sqrt(15.0 * 7), 0.01));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2045_1426)\n",
				"parameters": [
					{
						"name": "comp",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R1 && hasLength!R1 && isRandomAccessRange!R2 && hasLength!R2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "GapWeightedSimilarityIncremental",
						"line": 2069,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2087,
								"comment": "Constructs an object given two ranges $(D s) and $(D t) and a penalty\n$(D lambda). Constructor completes in $(BIGOH s.length * t.length)\ntime and computes all matches of length 1.\n",
								"type": "(Range s, Range t, F lambda)",
								"parameters": [
									{
										"name": "s",
										"type": "Range"
									},
									{
										"name": "t",
										"type": "Range"
									},
									{
										"name": "lambda",
										"type": "F"
									}
								],
								"endline": 2141,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 2146,
								"comment": "    Returns: $(D this).\n",
								"type": "ref GapWeightedSimilarityIncremental()",
								"endline": 2149,
								"char": 42,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 2155,
								"comment": "    Computes the match of the popFront length. Completes in $(BIGOH s.length *\n    t.length) time.\n",
								"type": "void()",
								"endline": 2233,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 48,
								"name": "front",
								"line": 2239,
								"comment": "    Returns: The gapped similarity at the current match length (initially\n    1, grows with each call to $(D popFront)).\n",
								"type": "@property F()",
								"endline": 2239,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 2244,
								"comment": "    Returns: Whether there are more matches.\n",
								"type": "@property bool()",
								"endline": 2253,
								"char": 20,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "GapWeightedSimilarityIncremental",
				"line": 2069,
				"comment": "Similar to $(D gapWeightedSimilarity), just works in an incremental\nmanner by first revealing the matches of length 1, then gapped matches\nof length 2, and so on. The memory requirement is $(BIGOH s.length *\nt.length). The time complexity is $(BIGOH s.length * t.length) time\nfor computing each step. Continuing on the previous example:\n\nThe implementation is based on the pseudocode in Fig. 4 of the paper\n$(WEB jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf,\n\"Efï¬cient Computation of Gapped Substring Kernels on Large Alphabets\")\nby Rousu et al., with additional algorithmic and systems-level\noptimizations.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2266_1427)\n---\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nauto simIter = gapWeightedSimilarityIncremental(s, t, 1.0);\nassert(simIter.front == 3); // three 1-length matches\nsimIter.popFront();\nassert(simIter.front == 3); // three 2-length matches\nsimIter.popFront();\nassert(simIter.front == 1); // one 3-length match\nsimIter.popFront();\nassert(simIter.empty);     // no more match\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2266_1427)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gapWeightedSimilarityIncremental",
						"line": 2259,
						"type": "GapWeightedSimilarityIncremental!(R, F)(R r1, R r2, F penalty)",
						"parameters": [
							{
								"name": "r1",
								"type": "R"
							},
							{
								"name": "r2",
								"type": "R"
							},
							{
								"name": "penalty",
								"type": "F"
							}
						],
						"endline": 2263,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "gapWeightedSimilarityIncremental",
				"line": 2259,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "F",
						"kind": "type"
					}
				],
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "gcd",
						"line": 2354,
						"type": "T(T a, T b)",
						"parameters": [
							{
								"name": "a",
								"type": "T"
							},
							{
								"name": "b",
								"type": "T"
							}
						],
						"endline": 2374,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "gcd",
				"line": 2354,
				"comment": "Computes the greatest common divisor of $(D a) and $(D b) by using\nEuclid's algorithm.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2377_1430)\n---\nassert(gcd(2 * 5 * 7 * 7, 5 * 7 * 11) == 5 * 7);\nconst int a = 5 * 13 * 23 * 23, b = 13 * 59;\nassert(gcd(a, b) == 13);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2377_1430)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"name": "Fft",
				"line": 2401,
				"comment": "A class for performing fast Fourier transforms of power of two sizes.\n This class encapsulates a large amount of state that is reusable when\n performing multiple FFTs of sizes smaller than or equal to that specified\n in the constructor.  This results in substantial speedups when performing\n multiple FFTs with a known maximum size.  However,\n a free function API is provided for convenience if you need to perform a\n one-off FFT.\n\n References:\n $(WEB en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 2697,
						"comment": "Create an $(D Fft) object for computing fast Fourier transforms of\n power of two sizes of $(D size) or smaller.  $(D size) must be a\n power of two.\n",
						"deco": "FmZC3std7numeric3Fft",
						"parameters": [
							{
								"name": "size",
								"deco": "m"
							}
						],
						"endline": 2703,
						"originalType": "(size_t size)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fft",
								"line": 2726,
								"type": "const Complex!F[](R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 2741,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "fft",
						"line": 2726,
						"comment": "Compute the Fourier transform of range using the $(BIGOH N log N)\n Cooley-Tukey Algorithm.  $(D range) must be a random-access range with\n slicing and a length equal to $(D size) as provided at the construction of\n this object.  The contents of range can be either  numeric types,\n which will be interpreted as pure real values, or complex types with\n properties or members $(D .re) and $(D .im) that can be read.\n\n Note:  Pure real FFTs are automatically detected and the relevant\n        optimizations are performed.\n\n Returns:  An array of complex numbers representing the transformed data in\n           the frequency domain.\n\n Conventions: The exponent is negative and the factor is one,\n              i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].\n",
						"parameters": [
							{
								"defaultDeco": "d",
								"name": "F",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isFloatingPoint!F && isRandomAccessRange!R",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "fft",
								"line": 2749,
								"type": "const void(R range, Ret buf)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "buf",
										"type": "Ret"
									}
								],
								"endline": 2784,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "fft",
						"line": 2749,
						"comment": "Same as the overload, but allows for the results to be stored in a user-\n provided buffer.  The buffer must be of the same length as range, must be\n a random-access range, must have slicing, and must contain elements that are\n complex-like.  This means that they must have a .re and a .im member or\n property that can be both read and written and are floating point numbers.\n",
						"parameters": [
							{
								"name": "Ret",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Ret && isComplexLike!(ElementType!Ret) && hasSlicing!Ret",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "inverseFft",
								"line": 2798,
								"type": "const Complex!F[](R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 2813,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "inverseFft",
						"line": 2798,
						"comment": " Computes the inverse Fourier transform of a range.  The range must be a\n random access range with slicing, have a length equal to the size\n provided at construction of this object, and contain elements that are\n either of type std.complex.Complex or have essentially\n the same compile-time interface.\n\n Returns:  The time-domain signal.\n\n Conventions: The exponent is positive and the factor is 1/N, i.e.,\n              output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].\n",
						"parameters": [
							{
								"defaultDeco": "d",
								"name": "F",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!R && isComplexLike!(ElementType!R) && isFloatingPoint!F",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "inverseFft",
								"line": 2820,
								"type": "const void(R range, Ret buf)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "buf",
										"type": "Ret"
									}
								],
								"endline": 2835,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "inverseFft",
						"line": 2820,
						"comment": " Inverse FFT that allows a user-supplied buffer to be provided.  The buffer\n must be a random access range with slicing, and its elements\n must be some complex-like type.\n",
						"parameters": [
							{
								"name": "Ret",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Ret && isComplexLike!(ElementType!Ret) && hasSlicing!Ret",
						"char": 10,
						"kind": "template"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fft",
						"line": 2862,
						"type": "Complex!F[](R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2866,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "fft",
				"line": 2862,
				"comment": "Convenience functions that create an $(D Fft) object, run the FFT or inverse\n FFT and return the result.  Useful for one-off FFTs.\n\n Note:  In addition to convenience, these functions are slightly more\n        efficient than manually creating an Fft object for a single use,\n        as the Fft object is deterministically destroyed before these\n        functions return.\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fft",
						"line": 2869,
						"type": "void(R range, Ret buf)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "buf",
								"type": "Ret"
							}
						],
						"endline": 2873,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "fft",
				"line": 2869,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Ret",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inverseFft",
						"line": 2876,
						"type": "Complex!F[](R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2880,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "inverseFft",
				"line": 2876,
				"comment": "ditto\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inverseFft",
						"line": 2883,
						"type": "void(R range, Ret buf)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "buf",
								"type": "Ret"
							}
						],
						"endline": 2887,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "inverseFft",
				"line": 2883,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Ret",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This module is a port of a growing fragment of the $(D_PARAM numeric)\nheader in Alexander Stepanov's $(LINK2 http://sgi.com/tech/stl,\nStandard Template Library), with a few additions.\n\nMacros:\n\nWIKI = Phobos/StdNumeric\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n                   Don Clugston, Robert Jacques\nSource:    $(PHOBOSSRC std/_numeric.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/path.d",
		"name": "std.path",
		"members": [
			{
				"name": "dirSeparator",
				"line": 65,
				"comment": " String used to separate directory names in a path.  Under\n    POSIX this is a slash, under Windows a backslash.\n",
				"deco": "Aya",
				"init": "\"/\"",
				"char": 37,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "pathSeparator",
				"line": 75,
				"comment": " Path separator string.  A colon under POSIX, a semicolon\n    under Windows.\n",
				"deco": "Aya",
				"init": "\":\"",
				"char": 37,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"endchar": 1,
				"name": "isDirSeparator",
				"line": 87,
				"comment": " Determines whether the given character is a directory separator.\n\n    On Windows, this includes both $(D `\\`) and $(D `/`).\n    On POSIX, it's just $(D `/`).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 92,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 268,
						"value": "false",
						"comment": "File names are case insensitive\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 271,
						"value": "true",
						"comment": "File names are case sensitive\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "osDefault",
						"line": 277,
						"value": "true",
						"comment": " The default (or most common) setting for the current platform.\n        That is, $(D no) on Windows and Mac OS X, and $(D yes) on all\n        POSIX systems except OS X (Linux, *BSD, etc.).\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CaseSensitive",
				"line": 265,
				"comment": " This $(D enum) is used as a template argument to functions which\n    compare file names, and determines whether the comparison is\n    case sensitive or not.\n",
				"baseDeco": "b",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "baseName",
						"line": 328,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 349,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "baseName",
				"line": 328,
				"comment": " Returns the name of a file, without any leading directory\n    and with an optional suffix chopped off.\n\n    If $(D suffix) is specified, it will be compared to $(D path)\n    using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (baseName(\"dir/file.ext\")         == \"file.ext\");\n    assert (baseName(\"dir/file.ext\", \".ext\") == \"file\");\n    assert (baseName(\"dir/file.ext\", \".xyz\") == \"file.ext\");\n    assert (baseName(\"dir/filename\", \"name\") == \"file\");\n    assert (baseName(\"dir/subdir/\")          == \"subdir\");\n\n    version (Windows)\n    {\n        assert (baseName(`d:file.ext`)      == \"file.ext\");\n        assert (baseName(`d:\\dir\\file.ext`) == \"file.ext\");\n    }\n    ---\n\n    Note:\n    This function $(I only) strips away the specified suffix, which\n    doesn't necessarily have to represent an extension.\n    To remove the extension from a path, regardless of what the extension\n    is, use $(LREF stripExtension).\n    To obtain the filename without leading directories and without\n    an extension, combine the functions like this:\n    ---\n    assert (baseName(stripExtension(\"dir/file.ext\")) == \"file\");\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html,\n    the POSIX requirements for the 'basename' shell utility)\n    (with suitable adaptations for Windows paths).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "baseName",
						"line": 352,
						"type": "pure @safe inout(C)[](inout(C)[] path, in C1[] suffix)",
						"parameters": [
							{
								"name": "path",
								"type": "inout(C)[]"
							},
							{
								"name": "suffix",
								"type": "C1[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 364,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "baseName",
				"line": 352,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "C1",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C && isSomeChar!C1",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dirName",
						"line": 462,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 508,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "dirName",
				"line": 462,
				"comment": " Returns the directory part of a path.  On Windows, this\n    includes the drive letter if present.\n\n    Params:\n        path = filespec\n\n    Returns:\n        slice of $(D path) or \".\"\n\n    Examples:\n    ---\n    assert (dirName(\"file\")        == \".\");\n    assert (dirName(\"dir/file\")    == \"dir\");\n    assert (dirName(\"/file\")       == \"/\");\n    assert (dirName(\"dir/subdir/\") == \"dir\");\n\n    version (Windows)\n    {\n        assert (dirName(\"d:file\")      == \"d:\");\n        assert (dirName(`d:\\dir\\file`) == `d:\\dir`);\n        assert (dirName(`d:\\file`)     == `d:\\`);\n        assert (dirName(`dir\\subdir\\`) == `dir`);\n    }\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html,\n    the POSIX requirements for the 'dirname' shell utility)\n    (with suitable adaptations for Windows paths).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rootName",
						"line": 612,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 644,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "rootName",
				"line": 612,
				"comment": " Returns the root directory of the specified path, or $(D null) if the\n    path is not rooted.\n\n    Params:\n        path = filespec\n\n    Returns:\n        slice of $(D path)\n\n    Examples:\n    ---\n    assert (rootName(\"foo\") is null);\n    assert (rootName(\"/foo\") == \"/\");\n\n    version (Windows)\n    {\n        assert (rootName(`\\foo`) == `\\`);\n        assert (rootName(`c:\\foo`) == `c:\\`);\n        assert (rootName(`\\\\server\\share\\foo`) == `\\\\server\\share`);\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "driveName",
						"line": 705,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 720,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "driveName",
				"line": 705,
				"comment": "    Get the drive portion of a path.\n\n    Params:\n        path = string or range of characters\n\n    Returns:\n        A slice of $(D _path) that is the drive, or an empty range if the drive\n        is not specified.  In the case of UNC paths, the network share\n        is returned.\n\n        Always returns an empty range on POSIX.\n\n    Examples:\n    ---\n    version (Windows)\n    {\n        assert (driveName(`d:\\file`) == \"d:\");\n        assert (driveName(`\\\\server\\share\\file`) == `\\\\server\\share`);\n        assert (driveName(`dir\\file`).empty);\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripDrive",
						"line": 772,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 782,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stripDrive",
				"line": 772,
				"comment": " Strips the drive from a Windows path.  On POSIX, the path is returned\n    unaltered.\n\n    Example:\n    ---\n    version (Windows)\n    {\n        assert (stripDrive(`d:\\dir\\file`) == `\\dir\\file`);\n        assert (stripDrive(`\\\\server\\share\\dir\\file`) == `\\dir\\file`);\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "extension",
						"line": 880,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 893,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "extension",
				"line": 880,
				"comment": " Returns the _extension part of a file name, including the dot.\n\n    If there is no _extension, $(D null) is returned.\n\n    Examples:\n    ---\n    assert (extension(\"file\").empty);\n    assert (extension(\"file.ext\")       == \".ext\");\n    assert (extension(\"file.ext1.ext2\") == \".ext2\");\n    assert (extension(\"file.\")          == \".\");\n    assert (extension(\".file\").empty);\n    assert (extension(\".file.ext\")      == \".ext\");\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripExtension",
						"line": 941,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 947,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stripExtension",
				"line": 941,
				"comment": " Remove extension from path.\n\n    Params:\n        path = string or range to be sliced\n\n    Returns:\n        slice of path with the extension (if any) stripped off\n\n    Examples:\n    ---\n    assert (stripExtension(\"file\")           == \"file\");\n    assert (stripExtension(\"file.ext\")       == \"file\");\n    assert (stripExtension(\"file.ext1.ext2\") == \"file.ext1\");\n    assert (stripExtension(\"file.\")          == \"file\");\n    assert (stripExtension(\".file\")          == \".file\");\n    assert (stripExtension(\".file.ext\")      == \".file\");\n    assert (stripExtension(\"dir/file.ext\")   == \"dir/file\");\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setExtension",
						"line": 993,
						"type": "immutable(Unqual!C1)[](in C1[] path, in C2[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "C1[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "ext",
								"type": "C2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1005,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "setExtension",
				"line": 993,
				"comment": " Returns a string containing the _path given by $(D path), but where\n    the extension has been set to $(D ext).\n\n    If the filename already has an extension, it is replaced.   If not, the\n    extension is simply appended to the filename.  Including a leading dot\n    in $(D ext) is optional.\n\n    If the extension is empty, this function is equivalent to\n    $(LREF stripExtension).\n\n    This function normally allocates a new string (the possible exception\n    being the case when path is immutable and doesn't already have an\n    extension).\n\n    Examples:\n    ---\n    assert (setExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (setExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (setExtension(\"file.old\", \"\")     == \"file\");\n    assert (setExtension(\"file.old\", \"new\")  == \"file.new\");\n    assert (setExtension(\"file.old\", \".new\") == \"file.new\");\n    ---\n\n    See_Also:\n        $(LREF withExtension) which does not allocate and returns a lazy range.\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && !is(C1 == immutable) && is(Unqual!C1 == Unqual!C2)",
				"char": 24,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setExtension",
						"line": 1008,
						"type": "immutable(C1)[](immutable(C1)[] path, const(C2)[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "immutable(C1)[]"
							},
							{
								"name": "ext",
								"type": "const(C2)[]"
							}
						],
						"endline": 1023,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "setExtension",
				"line": 1008,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && is(Unqual!C1 == Unqual!C2)",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "withExtension",
						"line": 1064,
						"type": "(R path, C[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							},
							{
								"name": "ext",
								"type": "C[]"
							}
						],
						"endline": 1077,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "withExtension",
				"line": 1064,
				"comment": " Replace existing extension on filespec with new one.\n\n Params:\n      path = string or random access range representing a filespec\n Returns:\n      Range with $(D path)'s extension (if any) replaced with $(D ext).\n      The element encoding type of the returned range will be the same as $(D path)'s.\n See_Also:\n      $(LREF setExtension)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1080_1446)\n---\nimport std.array;\nassert (withExtension(\"file\", \"ext\").array == \"file.ext\");\nassert (withExtension(\"file\"w, \".ext\"w).array == \"file.ext\");\nassert (withExtension(\"file.ext\"w, \".\").array == \"file.\");\n\nimport std.utf : byChar, byWchar;\nassert (withExtension(\"file\".byChar, \"ext\").array == \"file.ext\");\nassert (withExtension(\"file\"w.byWchar, \".ext\"w).array == \"file.ext\"w);\nassert (withExtension(\"file.ext\"w.byWchar, \".\").array == \"file.\"w);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1080_1446)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)) && isSomeChar!C",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "defaultExtension",
						"line": 1111,
						"type": "immutable(Unqual!C1)[](in C1[] path, in C2[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "C1[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "ext",
								"type": "C2[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1116,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "defaultExtension",
				"line": 1111,
				"comment": " Returns the _path given by $(D path), with the extension given by\n    $(D ext) appended if the path doesn't already have one.\n\n    Including the dot in the extension is optional.\n\n    This function always allocates a new string, except in the case when\n    path is immutable and already has an extension.\n\n    Examples:\n    ---\n    assert (defaultExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (defaultExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (defaultExtension(\"file.\", \"ext\")     == \"file.\");\n    assert (defaultExtension(\"file.old\", \"new\")  == \"file.old\");\n    assert (defaultExtension(\"file.old\", \".new\") == \"file.old\");\n    ---\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && is(Unqual!C1 == Unqual!C2)",
				"char": 24,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "withDefaultExtension",
						"line": 1147,
						"type": "(R path, C[] ext)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							},
							{
								"name": "ext",
								"type": "C[]"
							}
						],
						"endline": 1170,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "withDefaultExtension",
				"line": 1147,
				"comment": " Set the extension of $(D path) to $(D ext) if $(D path) doesn't have one.\n\n Params:\n      path = filespec as string or range\n      ext = extension, may have leading '.'\n Returns:\n      range with the result\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1173_1448)\n---\nimport std.array;\nassert (withDefaultExtension(\"file\", \"ext\").array == \"file.ext\");\nassert (withDefaultExtension(\"file\"w, \".ext\").array == \"file.ext\"w);\nassert (withDefaultExtension(\"file.\", \"ext\").array == \"file.\");\nassert (withDefaultExtension(\"file\", \"\").array == \"file.\");\n\nimport std.utf : byChar, byWchar;\nassert (withDefaultExtension(\"file\".byChar, \"ext\").array == \"file.ext\");\nassert (withDefaultExtension(\"file\"w.byWchar, \".ext\").array == \"file.ext\"w);\nassert (withDefaultExtension(\"file.\".byChar, \"ext\"d).array == \"file.\");\nassert (withDefaultExtension(\"file\".byChar, \"\").array == \"file.\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1173_1448)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "(isRandomAccessRange!R && hasSlicing!R && hasLength!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)) && isSomeChar!C",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "buildPath",
						"line": 1207,
						"type": "immutable(ElementEncodingType!(ElementType!Range))[](Range segments)",
						"parameters": [
							{
								"name": "segments",
								"type": "Range"
							}
						],
						"endline": 1244,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "buildPath",
				"line": 1207,
				"comment": " Combines one or more path segments.\n\n    This function takes a set of path segments, given as an input\n    range of string elements or as a set of string arguments,\n    and concatenates them with each other.  Directory separators\n    are inserted between segments if necessary.  If any of the\n    path segments are absolute (as defined by $(LREF isAbsolute)), the\n    preceding segments will be dropped.\n\n    On Windows, if one of the path segments are rooted, but not absolute\n    (e.g. $(D `\\foo`)), all preceding path segments down to the previous\n    root will be dropped.  (See below for an example.)\n\n    This function always allocates memory to hold the resulting path.\n    The variadic overload is guaranteed to only perform a single\n    allocation, as is the range version if $(D paths) is a forward\n    range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1255_1449)\n---\nversion (Posix)\n{\n    assert (buildPath(\"foo\", \"bar\", \"baz\") == \"foo/bar/baz\");\n    assert (buildPath(\"/foo/\", \"bar/baz\")  == \"/foo/bar/baz\");\n    assert (buildPath(\"/foo\", \"/bar\")      == \"/bar\");\n}\n\nversion (Windows)\n{\n    assert (buildPath(\"foo\", \"bar\", \"baz\") == `foo\\bar\\baz`);\n    assert (buildPath(`c:\\foo`, `bar\\baz`) == `c:\\foo\\bar\\baz`);\n    assert (buildPath(\"foo\", `d:\\bar`)     == `d:\\bar`);\n    assert (buildPath(\"foo\", `\\bar`)       == `\\bar`);\n    assert (buildPath(`c:\\foo`, `\\bar`)    == `c:\\bar`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1255_1449)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeString!(ElementType!Range)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "buildPath",
						"line": 1247,
						"type": "pure nothrow @safe immutable(C)[](const(C)[][] paths...)",
						"parameters": [
							{
								"name": "paths",
								"type": "const(C)[][]"
							}
						],
						"endline": 1252,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "buildPath",
				"line": 1247,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chainPath",
						"line": 1381,
						"type": "(R1 r1, R2 r2, Ranges ranges)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							},
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 1434,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chainPath",
				"line": 1381,
				"comment": " Concatenate path segments together to form one path.\n\n Params:\n      r1 = first segment\n      r2 = second segment\n      ranges = 0 or more segments\n Returns:\n      Lazy range which is the concatenation of r1, r2 and ranges with path separators.\n      The resulting element type is that of r1.\n See_Also:\n      $(LREF buildPath)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1437_1452)\n---\nimport std.array;\nversion (Posix)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == \"foo/bar/baz\");\n    assert (chainPath(\"/foo/\", \"bar/baz\").array  == \"/foo/bar/baz\");\n    assert (chainPath(\"/foo\", \"/bar\").array      == \"/bar\");\n}\n\nversion (Windows)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == `foo\\bar\\baz`);\n    assert (chainPath(`c:\\foo`, `bar\\baz`).array == `c:\\foo\\bar\\baz`);\n    assert (chainPath(\"foo\", `d:\\bar`).array     == `d:\\bar`);\n    assert (chainPath(\"foo\", `\\bar`).array       == `\\bar`);\n    assert (chainPath(`c:\\foo`, `\\bar`).array    == `c:\\bar`);\n}\n\nimport std.utf : byChar;\nversion (Posix)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == \"foo/bar/baz\");\n    assert (chainPath(\"/foo/\".byChar, \"bar/baz\").array  == \"/foo/bar/baz\");\n    assert (chainPath(\"/foo\", \"/bar\".byChar).array      == \"/bar\");\n}\n\nversion (Windows)\n{\n    assert (chainPath(\"foo\", \"bar\", \"baz\").array == `foo\\bar\\baz`);\n    assert (chainPath(`c:\\foo`.byChar, `bar\\baz`).array == `c:\\foo\\bar\\baz`);\n    assert (chainPath(\"foo\", `d:\\bar`).array     == `d:\\bar`);\n    assert (chainPath(\"foo\", `\\bar`.byChar).array       == `\\bar`);\n    assert (chainPath(`c:\\foo`, `\\bar`w).array    == `c:\\bar`);\n}\n}\n\n\n/** Performs the same task as $(LREF buildPath),\nwhile at the same time resolving current/parent directory\nsymbols ($(D \".\") and $(D \"..\")) and removing superfluous\ndirectory separators.\nIt will return \".\" if the path leads to the starting directory.\nOn Windows, slashes are replaced with backslashes.\n\nUsing buildNormalizedPath on null paths will always return null.\n\nNote that this function does not resolve symbolic links.\n\nThis function always allocates memory to hold the resulting path.\nUse $(LREF asNormalizedPath) to not allocate memory.\n\nExamples:\n---\nassert (buildNormalizedPath(\"foo\", \"..\") == \".\");\n\nversion (Posix)\n{\n    assert (buildNormalizedPath(\"/foo/./bar/..//baz/\") == \"/foo/baz\");\n    assert (buildNormalizedPath(\"../foo/.\") == \"../foo\");\n    assert (buildNormalizedPath(\"/foo\", \"bar/baz/\") == \"/foo/bar/baz\");\n    assert (buildNormalizedPath(\"/foo\", \"/bar/..\", \"baz\") == \"/baz\");\n    assert (buildNormalizedPath(\"foo/./bar\", \"../../\", \"../baz\") == \"../baz\");\n    assert (buildNormalizedPath(\"/foo/./bar\", \"../../baz\") == \"/baz\");\n}\n\nversion (Windows)\n{\n    assert (buildNormalizedPath(`c:\\foo\\.\\bar/..\\\\baz\\`) == `c:\\foo\\baz`);\n    assert (buildNormalizedPath(`..\\foo\\.`) == `..\\foo`);\n    assert (buildNormalizedPath(`c:\\foo`, `bar\\baz\\`) == `c:\\foo\\bar\\baz`);\n    assert (buildNormalizedPath(`c:\\foo`, `bar/..`) == `c:\\foo`);\n    assert (buildNormalizedPath(`\\\\server\\share\\foo`, `..\\bar`) == `\\\\server\\share\\bar`);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1437_1452)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "(isRandomAccessRange!R1 && hasSlicing!R1 && hasLength!R1 && isSomeChar!(ElementType!R1) || is(StringTypeOf!R1)) && (isRandomAccessRange!R2 && hasSlicing!R2 && hasLength!R2 && isSomeChar!(ElementType!R2) || is(StringTypeOf!R2)) && (Ranges.length == 0 || is(typeof(chainPath(r2, ranges))))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "buildNormalizedPath",
						"line": 1513,
						"type": "pure nothrow @trusted immutable(C)[](const(C[])[] paths...)",
						"parameters": [
							{
								"name": "paths",
								"type": "const(C[])[]"
							}
						],
						"endline": 1529,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "buildNormalizedPath",
				"line": 1513,
				"comment": " Performs the same task as $(LREF buildPath),\n    while at the same time resolving current/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    It will return \".\" if the path leads to the starting directory.\n    On Windows, slashes are replaced with backslashes.\n\n    Using buildNormalizedPath on null paths will always return null.\n\n    Note that this function does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n    Use $(LREF asNormalizedPath) to not allocate memory.\n\n    Examples:\n    ---\n    assert (buildNormalizedPath(\"foo\", \"..\") == \".\");\n\n    version (Posix)\n    {\n        assert (buildNormalizedPath(\"/foo/./bar/..//baz/\") == \"/foo/baz\");\n        assert (buildNormalizedPath(\"../foo/.\") == \"../foo\");\n        assert (buildNormalizedPath(\"/foo\", \"bar/baz/\") == \"/foo/bar/baz\");\n        assert (buildNormalizedPath(\"/foo\", \"/bar/..\", \"baz\") == \"/baz\");\n        assert (buildNormalizedPath(\"foo/./bar\", \"../../\", \"../baz\") == \"../baz\");\n        assert (buildNormalizedPath(\"/foo/./bar\", \"../../baz\") == \"/baz\");\n    }\n\n    version (Windows)\n    {\n        assert (buildNormalizedPath(`c:\\foo\\.\\bar/..\\\\baz\\`) == `c:\\foo\\baz`);\n        assert (buildNormalizedPath(`..\\foo\\.`) == `..\\foo`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar\\baz\\`) == `c:\\foo\\bar\\baz`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar/..`) == `c:\\foo`);\n        assert (buildNormalizedPath(`\\\\server\\share\\foo`, `..\\bar`) == `\\\\server\\share\\bar`);\n    }\n    ---\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asNormalizedPath",
						"line": 1681,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 1820,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asNormalizedPath",
				"line": 1681,
				"comment": " Normalize a path by resolving current/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    It will return \".\" if the path leads to the starting directory.\n    On Windows, slashes are replaced with backslashes.\n\n    Using asNormalizedPath on empty paths will always return an empty path.\n\n    Does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n    Use $(LREF buildNormalizedPath) to allocate memory and return a string.\n\n    Params:\n        path = string or random access range representing the _path to normalize\n\n    Returns:\n        normalized path as a forward range\n\n    Examples:\n    ---\n    import std.array;\n    assert (asNormalizedPath(\"foo/..\").array == \".\");\n\n    version (Posix)\n    {\n        assert (asNormalizedPath(\"/foo/./bar/..//baz/\").array == \"/foo/baz\");\n        assert (asNormalizedPath(\"../foo/.\").array == \"../foo\");\n        assert (asNormalizedPath(\"/foo/bar/baz/\").array == \"/foo/bar/baz\");\n        assert (asNormalizedPath(\"foo/./bar/../../\", \"../baz\").array == \"../baz\");\n        assert (asNormalizedPath(\"/foo/./bar/../../baz\").array == \"/baz\");\n    }\n\n    version (Windows)\n    {\n        assert (asNormalizedPath(`c:\\foo\\.\\bar/..\\\\baz\\`).array == `c:\\foo\\baz`);\n        assert (asNormalizedPath(`..\\foo\\.`).array == `..\\foo`);\n        assert (asNormalizedPath(`c:\\foo\\bar\\baz\\`).array == `c:\\foo\\bar\\baz`);\n        assert (asNormalizedPath(`c:\\foo\\bar/..`).array == `c:\\foo`);\n        assert (asNormalizedPath(`\\\\server\\share\\foo\\..\\bar`).array == `\\\\server\\share\\bar`);\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!(ElementEncodingType!R) && (isRandomAccessRange!R && hasSlicing!R && hasLength!R || isNarrowString!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "pathSplitter",
						"line": 2051,
						"type": "(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 2212,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "pathSplitter",
				"line": 2051,
				"comment": " Slice up a path into its elements.\n\n    Params:\n        path = string or slicable random access range\n\n    Returns:\n        bidirectional range of slices of `path`\n\n    Examples:\n    ---\n    assert (equal(pathSplitter(\"/\"), [\"/\"]));\n    assert (equal(pathSplitter(\"/foo/bar\"), [\"/\", \"foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"//foo/bar\"), [\"//foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"foo/../bar//./\"), [\"foo\", \"..\", \"bar\", \".\"]));\n\n    version (Windows)\n    {\n        assert (equal(pathSplitter(`foo\\..\\bar\\/.\\`), [\"foo\", \"..\", \"bar\", \".\"]));\n        assert (equal(pathSplitter(\"c:\"), [\"c:\"]));\n        assert (equal(pathSplitter(`c:\\foo\\bar`), [`c:\\`, \"foo\", \"bar\"]));\n        assert (equal(pathSplitter(`c:foo\\bar`), [\"c:foo\", \"bar\"]));\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasSlicing!R || isSomeString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isRooted",
						"line": 2310,
						"type": "bool(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"endline": 2317,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isRooted",
				"line": 2310,
				"comment": " Determines whether a path starts at a root directory.\n\n    On POSIX, this function returns true if and only if the path starts\n    with a slash (/).\n    ---\n    version (Posix)\n    {\n        assert (isRooted(\"/\"));\n        assert (isRooted(\"/foo\"));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"../foo\"));\n    }\n    ---\n\n    On Windows, this function returns true if the path starts at\n    the root directory of the current drive, of some other drive,\n    or of a network drive.\n    ---\n    version (Windows)\n    {\n        assert (isRooted(`\\`));\n        assert (isRooted(`\\foo`));\n        assert (isRooted(`d:\\foo`));\n        assert (isRooted(`\\\\foo\\bar`));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"d:foo\"));\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAbsolute",
						"line": 2380,
						"type": "pure nothrow @safe bool(R path)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							}
						],
						"char": 10,
						"kind": "function"
					}
				],
				"name": "isAbsolute",
				"line": 2380,
				"comment": " Determines whether a path is absolute or not.\n\n    Examples:\n    On POSIX, an absolute path starts at the root directory.\n    (In fact, $(D _isAbsolute) is just an alias for $(LREF isRooted).)\n    ---\n    version (Posix)\n    {\n        assert (isAbsolute(\"/\"));\n        assert (isAbsolute(\"/foo\"));\n        assert (!isAbsolute(\"foo\"));\n        assert (!isAbsolute(\"../foo\"));\n    }\n    ---\n\n    On Windows, an absolute path starts at the root directory of\n    a specific drive.  Hence, it must start with $(D `d:\\`) or $(D `d:/`),\n    where $(D d) is the drive letter.  Alternatively, it may be a\n    network path, i.e. a path starting with a double (back)slash.\n    ---\n    version (Windows)\n    {\n        assert (isAbsolute(`d:\\`));\n        assert (isAbsolute(`d:\\foo`));\n        assert (isAbsolute(`\\\\foo\\bar`));\n        assert (!isAbsolute(`\\`));\n        assert (!isAbsolute(`\\foo`));\n        assert (!isAbsolute(\"d:foo\"));\n    }\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && isSomeChar!(ElementType!R) || is(StringTypeOf!R)",
				"char": 10,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "absolutePath",
				"line": 2461,
				"comment": " Tranforms $(D path) into an absolute _path.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is empty, return $(D null).)\n        $(LI If $(D path) is already absolute, return it.)\n        $(LI Otherwise, append $(D path) to $(D base) and return\n            the result. If $(D base) is not specified, the current\n            working directory is used.)\n    )\n    The function allocates memory if and only if it gets to the third stage\n    of this algorithm.\n\n    Params:\n        path = the relative path to transform\n\n    Returns:\n        string of transformed path\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n\n    See_Also:\n        $(LREF asAbsolutePath) which does not allocate\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2473_1460)\n---\nversion (Posix)\n{\n    assert (absolutePath(\"some/file\", \"/foo/bar\")  == \"/foo/bar/some/file\");\n    assert (absolutePath(\"../file\", \"/foo/bar\")    == \"/foo/bar/../file\");\n    assert (absolutePath(\"/some/file\", \"/foo/bar\") == \"/some/file\");\n}\n\nversion (Windows)\n{\n    assert (absolutePath(`some\\file`, `c:\\foo\\bar`)    == `c:\\foo\\bar\\some\\file`);\n    assert (absolutePath(`..\\file`, `c:\\foo\\bar`)      == `c:\\foo\\bar\\..\\file`);\n    assert (absolutePath(`c:\\some\\file`, `c:\\foo\\bar`) == `c:\\some\\file`);\n    assert (absolutePath(`\\`, `c:\\`)                   == `c:\\`);\n    assert (absolutePath(`\\some\\file`, `c:\\foo\\bar`)   == `c:\\some\\file`);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2473_1460)\n",
				"deco": "FNaNfAyaLAyaZAya",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					},
					{
						"name": "base",
						"storageClass": [
							"lazy"
						],
						"deco": "Aya",
						"default": "getcwd()"
					}
				],
				"endline": 2470,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asAbsolutePath",
						"line": 2527,
						"type": "(R1 path)",
						"parameters": [
							{
								"name": "path",
								"type": "R1"
							}
						],
						"endline": 2536,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asAbsolutePath",
				"line": 2527,
				"comment": " Tranforms $(D path) into an absolute _path.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is empty, return $(D null).)\n        $(LI If $(D path) is already absolute, return it.)\n        $(LI Otherwise, append $(D path) to the current working directory,\n        which allocates memory.)\n    )\n\n    Params:\n        path = the relative path to transform\n\n    Returns:\n        the transformed path as a lazy range\n\n    See_Also:\n        $(LREF absolutePath) which returns an allocated string\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2539_1462)\n---\nimport std.array;\nassert(asAbsolutePath(cast(string)null).array == \"\");\nversion (Posix)\n{\n    assert(asAbsolutePath(\"/foo\").array == \"/foo\");\n}\nversion (Windows)\n{\n    assert(asAbsolutePath(\"c:/foo\").array == \"c:/foo\");\n}\nasAbsolutePath(\"foo\");\n}\n\n/** Translates $(D path) into a relative _path.\n\nThe returned _path is relative to $(D base), which is by default\ntaken to be the current working directory.  If specified,\n$(D base) must be an absolute _path, and it is always assumed\nto refer to a directory.  If $(D path) and $(D base) refer to\nthe same directory, the function returns $(D `.`).\n\nThe following algorithm is used:\n$(OL\n    $(LI If $(D path) is a relative directory, return it unaltered.)\n    $(LI Find a common root between $(D path) and $(D base).\n        If there is no common root, return $(D path) unaltered.)\n    $(LI Prepare a string with as many $(D `../`) or $(D `..\\`) as\n        necessary to reach the common root from base path.)\n    $(LI Append the remaining segments of $(D path) to the string\n        and return.)\n)\n\nIn the second step, path components are compared using $(D filenameCmp!cs),\nwhere $(D cs) is an optional template parameter determining whether\nthe comparison is case sensitive or not.  See the\n$(LREF filenameCmp) documentation for details.\n\nThis function allocates memory.\n\nSee_Also:\n    $(LREF asRelativePath) which does not allocate memory\n\nExamples:\n---\nassert (relativePath(\"foo\") == \"foo\");\n\nversion (Posix)\n{\n    assert (relativePath(\"foo\", \"/bar\") == \"foo\");\n    assert (relativePath(\"/foo/bar\", \"/foo/bar\") == \".\");\n    assert (relativePath(\"/foo/bar\", \"/foo/baz\") == \"../bar\");\n    assert (relativePath(\"/foo/bar/baz\", \"/foo/woo/wee\") == \"../../bar/baz\");\n    assert (relativePath(\"/foo/bar/baz\", \"/foo/bar\") == \"baz\");\n}\nversion (Windows)\n{\n    assert (relativePath(\"foo\", `c:\\bar`) == \"foo\");\n    assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\bar`) == \".\");\n    assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\baz`) == `..\\bar`);\n    assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`) == `..\\..\\bar\\baz`);\n    assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`) == \"baz\");\n    assert (relativePath(`c:\\foo\\bar`, `d:\\foo`) == `c:\\foo\\bar`);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2539_1462)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R1 && isSomeChar!(ElementType!R1) || isNarrowString!R1",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "relativePath",
						"line": 2609,
						"type": "string(string path, lazy string base = getcwd())",
						"parameters": [
							{
								"name": "path",
								"type": "string"
							},
							{
								"name": "base",
								"type": "string",
								"storageClass": [
									"lazy"
								],
								"default": "getcwd()"
							}
						],
						"endline": 2620,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "relativePath",
				"line": 2609,
				"comment": " Translates $(D path) into a relative _path.\n\n    The returned _path is relative to $(D base), which is by default\n    taken to be the current working directory.  If specified,\n    $(D base) must be an absolute _path, and it is always assumed\n    to refer to a directory.  If $(D path) and $(D base) refer to\n    the same directory, the function returns $(D `.`).\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is a relative directory, return it unaltered.)\n        $(LI Find a common root between $(D path) and $(D base).\n            If there is no common root, return $(D path) unaltered.)\n        $(LI Prepare a string with as many $(D `../`) or $(D `..\\`) as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of $(D path) to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    This function allocates memory.\n\n    See_Also:\n        $(LREF asRelativePath) which does not allocate memory\n\n    Examples:\n    ---\n    assert (relativePath(\"foo\") == \"foo\");\n\n    version (Posix)\n    {\n        assert (relativePath(\"foo\", \"/bar\") == \"foo\");\n        assert (relativePath(\"/foo/bar\", \"/foo/bar\") == \".\");\n        assert (relativePath(\"/foo/bar\", \"/foo/baz\") == \"../bar\");\n        assert (relativePath(\"/foo/bar/baz\", \"/foo/woo/wee\") == \"../../bar/baz\");\n        assert (relativePath(\"/foo/bar/baz\", \"/foo/bar\") == \"baz\");\n    }\n    version (Windows)\n    {\n        assert (relativePath(\"foo\", `c:\\bar`) == \"foo\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\bar`) == \".\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\baz`) == `..\\bar`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`) == `..\\..\\bar\\baz`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`) == \"baz\");\n        assert (relativePath(`c:\\foo\\bar`, `d:\\foo`) == `c:\\foo\\bar`);\n    }\n    ---\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asRelativePath",
						"line": 2677,
						"type": "(R path, string base)",
						"parameters": [
							{
								"name": "path",
								"type": "R"
							},
							{
								"name": "base",
								"type": "string"
							}
						],
						"endline": 2722,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asRelativePath",
				"line": 2677,
				"comment": " Transforms `path` into a _path relative to `base`.\n\n    The returned _path is relative to `base`, which is usually\n    the current working directory.\n    `base` must be an absolute _path, and it is always assumed\n    to refer to a directory.  If `path` and `base` refer to\n    the same directory, the function returns `'.'`.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If `path` is a relative directory, return it unaltered.)\n        $(LI Find a common root between `path` and `base`.\n            If there is no common root, return `path` unaltered.)\n        $(LI Prepare a string with as many `../`) or `..\\` as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of `path` to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using `filenameCmp!cs`,\n    where `cs` is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Params:\n        path = _path to transform\n        base = absolute path\n        cs = whether filespec comparisons are sensitive or not; defaults to\n         `CaseSensitive.osDefault`\n\n    Returns:\n        a random access range of the transformed _path\n\n    See_Also:\n        $(LREF relativePath)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2725_1466)\n---\nimport std.array;\nversion (Posix)\n{\n    assert (asRelativePath(\"foo\", \"/bar\").array == \"foo\");\n    assert (asRelativePath(\"/foo/bar\", \"/foo/bar\").array == \".\");\n    assert (asRelativePath(\"/foo/bar\", \"/foo/baz\").array == \"../bar\");\n    assert (asRelativePath(\"/foo/bar/baz\", \"/foo/woo/wee\").array == \"../../bar/baz\");\n    assert (asRelativePath(\"/foo/bar/baz\", \"/foo/bar\").array == \"baz\");\n}\nelse version (Windows)\n{\n    assert (asRelativePath(\"foo\", `c:\\bar`).array == \"foo\");\n    assert (asRelativePath(`c:\\foo\\bar`, `c:\\foo\\bar`).array == \".\");\n    assert (asRelativePath(`c:\\foo\\bar`, `c:\\foo\\baz`).array == `..\\bar`);\n    assert (asRelativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`).array == `..\\..\\bar\\baz`);\n    assert (asRelativePath(`c:/foo/bar/baz`, `c:\\foo\\woo\\wee`).array == `..\\..\\bar\\baz`);\n    assert (asRelativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`).array == \"baz\");\n    assert (asRelativePath(`c:\\foo\\bar`, `d:\\foo`).array == `c:\\foo\\bar`);\n    assert (asRelativePath(`\\\\foo\\bar`, `c:\\foo`).array == `\\\\foo\\bar`);\n}\nelse\n    static assert(0);\n}\n\n\n/** Compares filename characters and return $(D < 0) if $(D a < b), $(D 0) if\n$(D a == b) and $(D > 0) if $(D a > b).\n\nThis function can perform a case-sensitive or a case-insensitive\ncomparison.  This is controlled through the $(D cs) template parameter\nwhich, if not specified, is given by\n$(LREF CaseSensitive)$(D .osDefault).\n\nOn Windows, the backslash and slash characters ($(D `\\`) and $(D `/`))\nare considered equal.\n\nExamples:\n---\nassert (filenameCharCmp('a', 'a') == 0);\nassert (filenameCharCmp('a', 'b') < 0);\nassert (filenameCharCmp('b', 'a') > 0);\n\nversion (linux)\n{\n    // Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)\n    assert (filenameCharCmp('A', 'a') < 0);\n    assert (filenameCharCmp('a', 'A') > 0);\n}\nversion (Windows)\n{\n    // Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)\n    assert (filenameCharCmp('a', 'A') == 0);\n    assert (filenameCharCmp('a', 'B') < 0);\n    assert (filenameCharCmp('A', 'b') < 0);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2725_1466)\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && isSomeChar!(ElementType!R) || isNarrowString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "filenameCharCmp",
						"line": 2784,
						"type": "pure nothrow @safe int(dchar a, dchar b)",
						"parameters": [
							{
								"name": "a",
								"deco": "w"
							},
							{
								"name": "b",
								"deco": "w"
							}
						],
						"endline": 2795,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "filenameCharCmp",
				"line": 2784,
				"comment": " Compares filename characters and return $(D < 0) if $(D a < b), $(D 0) if\n    $(D a == b) and $(D > 0) if $(D a > b).\n\n    This function can perform a case-sensitive or a case-insensitive\n    comparison.  This is controlled through the $(D cs) template parameter\n    which, if not specified, is given by\n    $(LREF CaseSensitive)$(D .osDefault).\n\n    On Windows, the backslash and slash characters ($(D `\\`) and $(D `/`))\n    are considered equal.\n\n    Examples:\n    ---\n    assert (filenameCharCmp('a', 'a') == 0);\n    assert (filenameCharCmp('a', 'b') < 0);\n    assert (filenameCharCmp('b', 'a') > 0);\n\n    version (linux)\n    {\n        // Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)\n        assert (filenameCharCmp('A', 'a') < 0);\n        assert (filenameCharCmp('a', 'A') > 0);\n    }\n    version (Windows)\n    {\n        // Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)\n        assert (filenameCharCmp('a', 'A') == 0);\n        assert (filenameCharCmp('a', 'B') < 0);\n        assert (filenameCharCmp('A', 'b') < 0);\n    }\n    ---\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "filenameCmp",
						"line": 2868,
						"type": "int(Range1 filename1, Range2 filename2)",
						"parameters": [
							{
								"name": "filename1",
								"type": "Range1"
							},
							{
								"name": "filename2",
								"type": "Range2"
							}
						],
						"endline": 2903,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "filenameCmp",
				"line": 2868,
				"comment": " Compares file names and returns\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.\n\n    Treatment of invalid UTF encodings is implementation defined.\n\n    Params:\n        cs = case sensitivity\n        filename1 = range for first file name\n        filename2 = range for second file name\n\n    Returns:\n        $(D < 0) if $(D filename1 < filename2),\n        $(D 0) if $(D filename1 == filename2) and\n        $(D > 0) if $(D filename1 > filename2).\n\n    See_Also:\n        $(LREF filenameCharCmp)\n\n    Examples:\n    ---\n    assert (filenameCmp(\"abc\", \"abc\") == 0);\n    assert (filenameCmp(\"abc\", \"abd\") < 0);\n    assert (filenameCmp(\"abc\", \"abb\") > 0);\n    assert (filenameCmp(\"abc\", \"abcd\") < 0);\n    assert (filenameCmp(\"abcd\", \"abc\") > 0);\n\n    version (linux)\n    {\n        // Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") < 0);\n        assert (filenameCmp(\"abc\", \"Abc\") > 0);\n    }\n    version (Windows)\n    {\n        // Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") == 0);\n        assert (filenameCmp(\"abc\", \"Abc\") == 0);\n        assert (filenameCmp(\"Abc\", \"abD\") < 0);\n        assert (filenameCmp(\"abc\", \"AbB\") > 0);\n    }\n    ---\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isSomeChar!(ElementEncodingType!Range1) && isInputRange!Range2 && isSomeChar!(ElementEncodingType!Range2)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "globMatch",
						"line": 2993,
						"type": "pure nothrow @safe bool(Range path, const(C)[] pattern)",
						"parameters": [
							{
								"name": "path",
								"type": "Range"
							},
							{
								"name": "pattern",
								"type": "const(C)[]"
							}
						],
						"endline": 3140,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "globMatch",
				"line": 2993,
				"comment": " Matches a pattern against a path.\n\n    Some characters of pattern have a special meaning (they are\n    $(I meta-characters)) and can't be escaped. These are:\n\n    $(BOOKTABLE,\n    $(TR $(TD $(D *))\n         $(TD Matches 0 or more instances of any character.))\n    $(TR $(TD $(D ?))\n         $(TD Matches exactly one instance of any character.))\n    $(TR $(TD $(D [)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that appears\n              between the brackets.))\n    $(TR $(TD $(D [!)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that does not\n              appear between the brackets after the exclamation mark.))\n    $(TR $(TD $(D {)$(I string1)$(D ,)$(I string2)$(D ,)&hellip;$(D }))\n         $(TD Matches either of the specified strings.))\n    )\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Note that directory\n    separators and dots don't stop a meta-character from matching\n    further portions of the path.\n\n    Returns:\n    $(D true) if pattern matches path, $(D false) otherwise.\n\n    See_also:\n    $(LINK2 http://en.wikipedia.org/wiki/Glob_%28programming%29,Wikipedia: _glob (programming))\n\n    Examples:\n    -----\n    assert (globMatch(\"foo.bar\", \"*\"));\n    assert (globMatch(\"foo.bar\", \"*.*\"));\n    assert (globMatch(`foo/foo\\bar`, \"f*b*r\"));\n    assert (globMatch(\"foo.bar\", \"f???bar\"));\n    assert (globMatch(\"foo.bar\", \"[fg]???bar\"));\n    assert (globMatch(\"foo.bar\", \"[!gh]*bar\"));\n    assert (globMatch(\"bar.fooz\", \"bar.{foo,bif}z\"));\n    assert (globMatch(\"bar.bifz\", \"bar.{foo,bif}z\"));\n\n    version (Windows)\n    {\n        // Same as calling globMatch!(CaseSensitive.no)(path, pattern)\n        assert (globMatch(\"foo\", \"Foo\"));\n        assert (globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    version (linux)\n    {\n        // Same as calling globMatch!(CaseSensitive.yes)(path, pattern)\n        assert (!globMatch(\"foo\", \"Foo\"));\n        assert (!globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    -----\n",
				"parameters": [
					{
						"name": "cs",
						"defaultValue": "CaseSensitive.osDefault",
						"deco": "E3std4path13CaseSensitive",
						"kind": "value"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && isSomeChar!C && is(Unqual!C == Unqual!(ElementEncodingType!Range))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValidFilename",
						"line": 3226,
						"type": "bool(Range filename)",
						"parameters": [
							{
								"name": "filename",
								"type": "Range"
							}
						],
						"endline": 3272,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValidFilename",
				"line": 3226,
				"comment": " Checks that the given file or directory name is valid.\n\n    The maximum length of $(D filename) is given by the constant\n    $(D core.stdc.stdio.FILENAME_MAX).  (On Windows, this number is\n    defined as the maximum number of UTF-16 code points, and the\n    test will therefore only yield strictly correct results when\n    $(D filename) is a string of $(D wchar)s.)\n\n    On Windows, the following criteria must be satisfied\n    ($(LINK2 http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx,source)):\n    $(UL\n        $(LI $(D filename) must not contain any characters whose integer\n            representation is in the range 0-31.)\n        $(LI $(D filename) must not contain any of the following $(I reserved\n            characters): <>:\"/\\|?*)\n        $(LI $(D filename) may not end with a space ($(D ' ')) or a period\n            ($(D '.')).)\n    )\n\n    On POSIX, $(D filename) may not contain a forward slash ($(D '/')) or\n    the null character ($(D '\\0')).\n\n    Params:\n        filename = string to check\n\n    Returns:\n        $(D true) if and only if $(D filename) is not\n        empty, not too long, and does not contain invalid characters.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3276_1470)\n---\nimport std.utf : byCodeUnit;\n\nassert(isValidFilename(\"hello.exe\".byCodeUnit));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3276_1470)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "is(StringTypeOf!Range) || isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValidPath",
						"line": 3358,
						"type": "bool(Range path)",
						"parameters": [
							{
								"name": "path",
								"type": "Range"
							}
						],
						"endline": 3454,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValidPath",
				"line": 3358,
				"comment": " Checks whether $(D path) is a valid _path.\n\n    Generally, this function checks that $(D path) is not empty, and that\n    each component of the path either satisfies $(LREF isValidFilename)\n    or is equal to $(D \".\") or $(D \"..\").\n    It does $(I not) check whether the _path points to an existing file\n    or directory; use $(XREF file,exists) for this purpose.\n\n    On Windows, some special rules apply:\n    $(UL\n        $(LI If the second character of $(D path) is a colon ($(D ':')),\n            the first character is interpreted as a drive letter, and\n            must be in the range A-Z (case insensitive).)\n        $(LI If $(D path) is on the form $(D `\\\\$(I server)\\$(I share)\\...`)\n            (UNC path), $(LREF isValidFilename) is applied to $(I server)\n            and $(I share) as well.)\n        $(LI If $(D path) starts with $(D `\\\\?\\`) (long UNC path), the\n            only requirement for the rest of the string is that it does\n            not contain the null character.)\n        $(LI If $(D path) starts with $(D `\\\\.\\`) (Win32 device namespace)\n            this function returns $(D false); such paths are beyond the scope\n            of this module.)\n    )\n\n    Params:\n        path = string or Range of characters to check\n\n    Returns:\n        true if $(D path) is a valid _path.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3459_1472)\n---\nassert (isValidPath(\"/foo/bar\"));\nassert (!isValidPath(\"/foo\\0/bar\"));\nassert (isValidPath(\"/\"));\nassert (isValidPath(\"a\"));\n\nversion (Windows)\n{\n    assert (isValidPath(`c:\\`));\n    assert (isValidPath(`c:\\foo`));\n    assert (isValidPath(`c:\\foo\\.\\bar\\\\\\..\\`));\n    assert (!isValidPath(`!:\\foo`));\n    assert (!isValidPath(`c::\\foo`));\n    assert (!isValidPath(`c:\\foo?`));\n    assert (!isValidPath(`c:\\foo.`));\n\n    assert (isValidPath(`\\\\server\\share`));\n    assert (isValidPath(`\\\\server\\share\\foo`));\n    assert (isValidPath(`\\\\server\\share\\\\foo`));\n    assert (!isValidPath(`\\\\\\server\\share\\foo`));\n    assert (!isValidPath(`\\\\server\\\\share\\foo`));\n    assert (!isValidPath(`\\\\ser*er\\share\\foo`));\n    assert (!isValidPath(`\\\\server\\sha?e\\foo`));\n    assert (!isValidPath(`\\\\server\\share\\|oo`));\n\n    assert (isValidPath(`\\\\?\\<>:\"?*|/\\..\\.`));\n    assert (!isValidPath(\"\\\\\\\\?\\\\foo\\0bar\"));\n\n    assert (!isValidPath(`\\\\.\\PhysicalDisk1`));\n    assert (!isValidPath(`\\\\`));\n}\n\nimport std.utf : byCodeUnit;\nassert (isValidPath(\"/foo/bar\".byCodeUnit));\n}\n\n\n\n\n/** Performs tilde expansion in paths on POSIX systems.\nOn Windows, this function does nothing.\n\nThere are two ways of using tilde expansion in a path. One\ninvolves using the tilde alone or followed by a path separator. In\nthis case, the tilde will be expanded with the value of the\nenvironment variable $(D HOME).  The second way is putting\na username after the tilde (i.e. $(D ~john/Mail)). Here,\nthe username will be searched for in the user database\n(i.e. $(D /etc/passwd) on Unix systems) and will expand to\nwhatever path is stored there.  The username is considered the\nstring after the tilde ending at the first instance of a path\nseparator.\n\nNote that using the $(D ~user) syntax may give different\nvalues from just $(D ~) if the environment variable doesn't\nmatch the value stored in the user database.\n\nWhen the environment variable version is used, the path won't\nbe modified if the environment variable doesn't exist or it\nis empty. When the database version is used, the path won't be\nmodified if the user doesn't exist in the database or there is\nnot enough memory to perform the query.\n\nThis function performs several memory allocations.\n\nReturns:\n$(D inputPath) with the tilde expanded, or just $(D inputPath)\nif it could not be expanded.\nFor Windows, $(D expandTilde) merely returns its argument $(D inputPath).\n\nExamples:\n-----\nvoid processFile(string path)\n{\n    // Allow calling this function with paths such as ~/foo\n    auto fullPath = expandTilde(path);\n    ...\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3459_1472)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "is(StringTypeOf!Range) || isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "expandTilde",
				"line": 3540,
				"comment": " Performs tilde expansion in paths on POSIX systems.\n    On Windows, this function does nothing.\n\n    There are two ways of using tilde expansion in a path. One\n    involves using the tilde alone or followed by a path separator. In\n    this case, the tilde will be expanded with the value of the\n    environment variable $(D HOME).  The second way is putting\n    a username after the tilde (i.e. $(D ~john/Mail)). Here,\n    the username will be searched for in the user database\n    (i.e. $(D /etc/passwd) on Unix systems) and will expand to\n    whatever path is stored there.  The username is considered the\n    string after the tilde ending at the first instance of a path\n    separator.\n\n    Note that using the $(D ~user) syntax may give different\n    values from just $(D ~) if the environment variable doesn't\n    match the value stored in the user database.\n\n    When the environment variable version is used, the path won't\n    be modified if the environment variable doesn't exist or it\n    is empty. When the database version is used, the path won't be\n    modified if the user doesn't exist in the database or there is\n    not enough memory to perform the query.\n\n    This function performs several memory allocations.\n\n    Returns:\n    $(D inputPath) with the tilde expanded, or just $(D inputPath)\n    if it could not be expanded.\n    For Windows, $(D expandTilde) merely returns its argument $(D inputPath).\n\n    Examples:\n    -----\n    void processFile(string path)\n    {\n        // Allow calling this function with paths such as ~/foo\n        auto fullPath = expandTilde(path);\n        ...\n    }\n    -----\n",
				"deco": "FNbAyaZAya",
				"parameters": [
					{
						"name": "inputPath",
						"deco": "Aya"
					}
				],
				"endline": 3686,
				"char": 8,
				"kind": "function"
			}
		],
		"comment": " This module is used to manipulate _path strings.\n\n    All functions, with the exception of $(LREF expandTilde) (and in some\n    cases $(LREF absolutePath) and $(LREF relativePath)), are pure\n    string manipulation functions; they don't depend on any state outside\n    the program, nor do they perform any actual file system actions.\n    This has the consequence that the module does not make any distinction\n    between a _path that points to a directory and a _path that points to a\n    file, and it does not know whether or not the object pointed to by the\n    _path actually exists in the file system.\n    To differentiate between these cases, use $(XREF file,isDir) and\n    $(XREF file,exists).\n\n    Note that on Windows, both the backslash ($(D `\\`)) and the slash ($(D `/`))\n    are in principle valid directory separators.  This module treats them\n    both on equal footing, but in cases where a $(I new) separator is\n    added, a backslash will be used.  Furthermore, the $(LREF buildNormalizedPath)\n    function will replace all slashes with backslashes on that platform.\n\n    In general, the functions in this module assume that the input paths\n    are well-formed.  (That is, they should not contain invalid characters,\n    they should follow the file system's _path format, etc.)  The result\n    of calling a function on an ill-formed _path is undefined.  When there\n    is a chance that a _path or a file name is invalid (for instance, when it\n    has been input by the user), it may sometimes be desirable to use the\n    $(LREF isValidFilename) and $(LREF isValidPath) functions to check\n    this.\n\n    Most functions do not perform any memory allocations, and if a string is\n    returned, it is usually a slice of an input string.  If a function\n    allocates, this is explicitly mentioned in the documentation.\n\n    Upgrading:\n        $(WEB digitalmars.com/d/1.0/phobos/std_path.html#fnmatch) can\n        be replaced with $(D globMatch).\n\n    Authors:\n        Lars Tandle Kyllingstad,\n        $(WEB digitalmars.com, Walter Bright),\n        Grzegorz Adam Hankiewicz,\n        Thomas K$(UUML)hne,\n        $(WEB erdani.org, Andrei Alexandrescu)\n    Copyright:\n        Copyright (c) 2000-2014, the authors. All rights reserved.\n    License:\n        $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Source:\n        $(PHOBOSSRC std/_path.d)\n    Macros:\n        WIKI = Phobos/StdPath\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/file.d",
		"name": "std.file",
		"members": [
			{
				"members": [
					{
						"offset": 72,
						"name": "errno",
						"line": 98,
						"comment": "        OS error code.\n",
						"deco": "yk",
						"originalType": "uint",
						"char": 20,
						"kind": "variable",
						"storageClass": [
							"immutable"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 109,
						"comment": "        Constructor which takes an error message.\n\n        Params:\n            name = Name of file for which the error occurred.\n            msg  = Message describing the error.\n            file = The file where the error occurred.\n            line = The line where the error occurred.\n",
						"deco": "FNaNfxAaxAaAyamZC3std4file13FileException",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "msg",
								"deco": "xAa"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 117,
						"originalType": "pure @safe (in char[] name, in char[] msg, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 139,
						"comment": "        Constructor which takes the error number ($(LUCKY GetLastError)\n        in Windows, $(D_PARAM errno) in Posix).\n\n        Params:\n            name  = Name of file for which the error occurred.\n            errno = The error number.\n            file  = The file where the error occurred.\n                    Defaults to $(D __FILE__).\n            line  = The line where the error occurred.\n                    Defaults to $(D __LINE__).\n",
						"deco": "FNexAakAyamZC3std4file13FileException",
						"parameters": [
							{
								"name": "name",
								"deco": "xAa"
							},
							{
								"name": "errno",
								"deco": "k",
								"default": "cast(uint)errno()"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							}
						],
						"endline": 147,
						"originalType": "@trusted (in char[] name, uint errno = .errno, string file = __FILE__, size_t line = __LINE__)",
						"char": 25,
						"kind": "constructor"
					}
				],
				"name": "FileException",
				"line": 93,
				"comment": "    Exception thrown for file I/O errors.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "read",
				"line": 191,
				"comment": "Read entire contents of file $(D name) and returns it as an untyped\narray. If the file size is larger than $(D upTo), only $(D upTo)\nbytes are read.\n\nExample:\n\n----\nimport std.file, std.stdio;\nvoid main()\n{\n   auto bytes = cast(ubyte[]) read(\"filename\", 5);\n   if (bytes.length == 5)\n       writefln(\"The fifth byte of the file is 0x%x\", bytes[4]);\n}\n----\n\nReturns: Untyped array of bytes _read.\n\nThrows: $(D FileException) on error.\n",
				"deco": "FNexAamZAv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "upTo",
						"deco": "m",
						"default": "18446744073709551615LU"
					}
				],
				"endline": 235,
				"originalType": "@trusted void[](in char[] name, size_t upTo = size_t.max)",
				"char": 24,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readText",
						"line": 344,
						"type": "@safe S(in char[] name)",
						"parameters": [
							{
								"name": "name",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 351,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "readText",
				"line": 344,
				"comment": "Read and validates (using $(XREF utf, validate)) a text file. $(D S)\ncan be a type of array of characters of any width and constancy. No\nwidth conversion is performed; if the width of the characters in file\n$(D name) is different from the width of elements of $(D S),\nvalidation will fail.\n\nReturns: Array of characters read.\n\nThrows: $(D FileException) on file error, $(D UTFException) on UTF\ndecoding error.\n\nExample:\n\n----\nenforce(system(\"echo abc>deleteme\") == 0);\nscope(exit) remove(\"deleteme\");\nenforce(chomp(readText(\"deleteme\")) == \"abc\");\n----\n",
				"parameters": [
					{
						"name": "S",
						"default": "string",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "write",
				"line": 377,
				"comment": "Write $(D buffer) to file $(D name).\nThrows: $(D FileException) on error.\n\nExample:\n\n----\nimport std.file;\nvoid main()\n{\n   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\n   write(\"filename\", a);\n   assert(cast(int[]) read(\"filename\") == a);\n}\n----\n",
				"deco": "FNexAaxAvZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "buffer",
						"deco": "xAv"
					}
				],
				"endline": 396,
				"originalType": "@trusted void(in char[] name, const void[] buffer)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "append",
				"line": 416,
				"comment": "Appends $(D buffer) to file $(D name).\nThrows: $(D FileException) on error.\n\nExample:\n\n----\nimport std.file;\nvoid main()\n{\n   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\n   write(\"filename\", a);\n   int[] b = [ 13, 21 ];\n   append(\"filename\", b);\n   assert(cast(int[]) read(\"filename\") == a ~ b);\n}\n----\n",
				"deco": "FNexAaxAvZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "buffer",
						"deco": "xAv"
					}
				],
				"endline": 436,
				"originalType": "@trusted void(in char[] name, in void[] buffer)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "rename",
				"line": 461,
				"comment": " Rename file $(D from) to $(D to).\n If the target file exists, it is overwritten.\n Throws: $(D FileException) on error.\n",
				"deco": "FNexAaxAaZv",
				"parameters": [
					{
						"name": "from",
						"deco": "xAa"
					},
					{
						"name": "to",
						"deco": "xAa"
					}
				],
				"endline": 476,
				"originalType": "@trusted void(in char[] from, in char[] to)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "remove",
				"line": 495,
				"comment": "Delete file $(D name).\nThrows: $(D FileException) on error.\n",
				"deco": "FNexAaZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 508,
				"originalType": "@trusted void(in char[] name)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getSize",
				"line": 530,
				"comment": "Get size of file $(D name) in bytes.\n\nThrows: $(D FileException) on error (e.g., file not found).\n",
				"deco": "FNfxAaZm",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 551,
				"originalType": "@safe ulong(in char[] name)",
				"char": 7,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getTimes",
				"line": 576,
				"comment": "    Get the access and modified times of file or folder $(D name).\n\n    Params:\n        name             = File/Folder name to get times for.\n        accessTime       = Time the file/folder was last accessed.\n        modificationTime = Time the file/folder was last modified.\n\n    Throws:\n        $(D FileException) on error.\n",
				"deco": "FNfxAaJS3std8datetime7SysTimeJS3std8datetime7SysTimeZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "accessTime",
						"storageClass": [
							"out"
						],
						"deco": "S3std8datetime7SysTime"
					},
					{
						"name": "modificationTime",
						"storageClass": [
							"out"
						],
						"deco": "S3std8datetime7SysTime"
					}
				],
				"endline": 601,
				"originalType": "@safe void(in char[] name, out SysTime accessTime, out SysTime modificationTime)",
				"char": 6,
				"kind": "function"
			},
			{
				"name": "getTimesWin",
				"line": 675,
				"comment": "    $(BLUE This function is Windows-Only.)\n\n    Get creation/access/modified times of file $(D name).\n\n    This is the same as $(D getTimes) except that it also gives you the file\n    creation time - which isn't possible on Posix systems.\n\n    Params:\n        name                 = File name to get times for.\n        fileCreationTime     = Time the file was created.\n        fileAccessTime       = Time the file was last accessed.\n        fileModificationTime = Time the file was last modified.\n\n    Throws:\n        $(D FileException) on error.\n",
				"deco": "FNfxAaJS3std8datetime7SysTimeJS3std8datetime7SysTimeJS3std8datetime7SysTimeZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "fileCreationTime",
						"storageClass": [
							"out"
						],
						"deco": "S3std8datetime7SysTime"
					},
					{
						"name": "fileAccessTime",
						"storageClass": [
							"out"
						],
						"deco": "S3std8datetime7SysTime"
					},
					{
						"name": "fileModificationTime",
						"storageClass": [
							"out"
						],
						"deco": "S3std8datetime7SysTime"
					}
				],
				"originalType": "@safe void(in char[] name, out SysTime fileCreationTime, out SysTime fileAccessTime, out SysTime fileModificationTime)",
				"char": 23,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "setTimes",
				"line": 769,
				"comment": "    Set access/modified times of file or folder $(D name).\n\n    Params:\n        name             = File/Folder name to get times for.\n        accessTime       = Time the file/folder was last accessed.\n        modificationTime = Time the file/folder was last modified.\n\n    Throws:\n        $(D FileException) on error.\n",
				"deco": "FNfxAaS3std8datetime7SysTimeS3std8datetime7SysTimeZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "accessTime",
						"deco": "S3std8datetime7SysTime"
					},
					{
						"name": "modificationTime",
						"deco": "S3std8datetime7SysTime"
					}
				],
				"endline": 827,
				"originalType": "@safe void(in char[] name, SysTime accessTime, SysTime modificationTime)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "timeLastModified",
				"line": 861,
				"comment": "    Returns the time that the given file was last modified.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
				"deco": "FNfxAaZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 884,
				"originalType": "@safe SysTime(in char[] name)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "timeLastModified",
				"line": 917,
				"comment": "    Returns the time that the given file was last modified. If the\n    file does not exist, returns $(D returnIfMissing).\n\n    A frequent usage pattern occurs in build automation tools such as\n    $(WEB gnu.org/software/make, make) or $(WEB\n    en.wikipedia.org/wiki/Apache_Ant, ant). To check whether file $(D\n    target) must be rebuilt from file $(D source) (i.e., $(D target) is\n    older than $(D source) or does not exist), use the comparison\n    below. The code throws a $(D FileException) if $(D source) does not\n    exist (as it should). On the other hand, the $(D SysTime.min) default\n    makes a non-existing $(D target) seem infinitely old so the test\n    correctly prompts building it.\n\n    Params:\n        name            = The name of the file to get the modification time for.\n        returnIfMissing = The time to return if the given file does not exist.\n\nExamples:\n--------------------\nif(timeLastModified(source) >= timeLastModified(target, SysTime.min))\n{\n    // must (re)build\n}\nelse\n{\n    // target is up-to-date\n}\n--------------------\n",
				"deco": "FNfxAaS3std8datetime7SysTimeZS3std8datetime7SysTime",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "returnIfMissing",
						"deco": "S3std8datetime7SysTime"
					}
				],
				"endline": 943,
				"originalType": "@safe SysTime(in char[] name, SysTime returnIfMissing)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "exists",
				"line": 968,
				"comment": "    Returns whether the given file (or directory) exists.\n",
				"deco": "FNbNiNexAaZb",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 1001,
				"originalType": "nothrow @nogc @trusted bool(in char[] name)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getAttributes",
				"line": 1033,
				"comment": " Returns the attributes of the given file.\n\n Note that the file attributes on Windows and Posix systems are\n completely different. On Windows, they're what is returned by $(WEB\n msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx,\n GetFileAttributes), whereas on Posix systems, they're the $(LUCKY\n st_mode) value which is part of the $(D stat struct) gotten by\n calling the $(WEB en.wikipedia.org/wiki/Stat_%28Unix%29, $(D stat))\n function.\n\n On Posix systems, if the given file is a symbolic link, then\n attributes are the attributes of the file pointed to by the symbolic\n link.\n\n Params:\n name = The file to get the attributes of.\n\n Throws: $(D FileException) on error.\n",
				"deco": "FNfxAaZk",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 1059,
				"originalType": "@safe uint(in char[] name)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "getLinkAttributes",
				"line": 1078,
				"comment": "    If the given file is a symbolic link, then this returns the attributes of the\n    symbolic link itself rather than file that it points to. If the given file\n    is $(I not) a symbolic link, then this function returns the same result\n    as getAttributes.\n\n    On Windows, getLinkAttributes is identical to getAttributes. It exists on\n    Windows so that you don't have to special-case code for Windows when dealing\n    with symbolic links.\n\n    Params:\n        name = The file to get the symbolic link attributes of.\n\n    Throws:\n        $(D FileException) on error.\n",
				"deco": "FNfxAaZk",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 1094,
				"originalType": "@safe uint(in char[] name)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "setAttributes",
				"line": 1103,
				"comment": "    Set the attributes of the given file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
				"deco": "FNfxAakZv",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "attributes",
						"deco": "k"
					}
				],
				"endline": 1122,
				"originalType": "@safe void(in char[] name, uint attributes)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isDir",
				"line": 1140,
				"comment": "    Returns whether the given file is a directory.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExamples:\n--------------------\nassert(!\"/etc/fonts/fonts.conf\".isDir);\nassert(\"/usr/share/include\".isDir);\n--------------------\n",
				"deco": "FNdNfxAaZb",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 1150,
				"originalType": "@property @safe bool(in char[] name)",
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "attrIsDir",
				"line": 1185,
				"comment": "    Returns whether the given file attributes are for a directory.\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\nassert(!attrIsDir(getAttributes(\"/etc/fonts/fonts.conf\")));\nassert(!attrIsDir(getLinkAttributes(\"/etc/fonts/fonts.conf\")));\n--------------------\n",
				"deco": "FNaNbNiNfkZb",
				"parameters": [
					{
						"name": "attributes",
						"deco": "k"
					}
				],
				"endline": 1195,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isFile",
				"line": 1257,
				"comment": "    Returns whether the given file (or directory) is a file.\n\n    On Windows, if a file is not a directory, then it's a file. So,\n    either $(D isFile) or $(D isDir) will return true for any given file.\n\n    On Posix systems, if $(D isFile) is $(D true), that indicates that the file\n    is a regular file (e.g. not a block not device). So, on Posix systems, it's\n    possible for both $(D isFile) and $(D isDir) to be $(D false) for a\n    particular file (in which case, it's a special file). You can use\n    $(D getAttributes) to get the attributes to figure out what type of special\n    it is, or you can use $(D DirEntry) to get at its $(D statBuf), which is the\n    result from $(D stat). In either case, see the man page for $(D stat) for\n    more information.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExamples:\n--------------------\nassert(\"/etc/fonts/fonts.conf\".isFile);\nassert(!\"/usr/share/include\".isFile);\n--------------------\n",
				"deco": "FNdNfxAaZb",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 1263,
				"originalType": "@property @safe bool(in char[] name)",
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "attrIsFile",
				"line": 1309,
				"comment": "    Returns whether the given file attributes are for a file.\n\n    On Windows, if a file is not a directory, it's a file. So, either\n    $(D attrIsFile) or $(D attrIsDir) will return $(D true) for the\n    attributes of any given file.\n\n    On Posix systems, if $(D attrIsFile) is $(D true), that indicates that the\n    file is a regular file (e.g. not a block not device). So, on Posix systems,\n    it's possible for both $(D attrIsFile) and $(D attrIsDir) to be $(D false)\n    for a particular file (in which case, it's a special file). If a file is a\n    special file, you can use the attributes to check what type of special file\n    it is (see the man page for $(D stat) for more information).\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\nassert(attrIsFile(getAttributes(\"/etc/fonts/fonts.conf\")));\nassert(attrIsFile(getLinkAttributes(\"/etc/fonts/fonts.conf\")));\n--------------------\n",
				"deco": "FNaNbNiNfkZb",
				"parameters": [
					{
						"name": "attributes",
						"deco": "k"
					}
				],
				"endline": 1319,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSymlink",
				"line": 1366,
				"comment": "    Returns whether the given file is a symbolic link.\n\n    On Windows, returns $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
				"deco": "FNdNfxAaZb",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					}
				],
				"endline": 1372,
				"originalType": "@property @safe bool(in char[] name)",
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "attrIsSymlink",
				"line": 1465,
				"comment": "    Returns whether the given file attributes are for a symbolic link.\n\n    On Windows, return $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\ncore.sys.posix.unistd.symlink(\"/etc/fonts/fonts.conf\", \"/tmp/alink\");\n\nassert(!getAttributes(\"/tmp/alink\").isSymlink);\nassert(getLinkAttributes(\"/tmp/alink\").isSymlink);\n--------------------\n",
				"deco": "FNaNbNiNfkZb",
				"parameters": [
					{
						"name": "attributes",
						"deco": "k"
					}
				],
				"endline": 1471,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "chdir",
				"line": 1478,
				"comment": " Change directory to $(D pathname).\n Throws: $(D FileException) on error.\n",
				"deco": "FNfxAaZv",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAa"
					}
				],
				"endline": 1496,
				"originalType": "@safe void(in char[] pathname)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "mkdir",
				"line": 1504,
				"comment": "Make directory $(D pathname).\n\nThrows: $(D FileException) on Posix or $(D WindowsException) on Windows\n        if an error occured.\n",
				"deco": "FNfxAaZv",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAa"
					}
				],
				"endline": 1522,
				"originalType": "@safe void(in char[] pathname)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "mkdirRecurse",
				"line": 1551,
				"comment": " Make directory and all parent directories as needed.\n\n Throws: $(D FileException) on error.\n",
				"deco": "FxAaZv",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAa"
					}
				],
				"endline": 1562,
				"originalType": "void(in char[] pathname)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "rmdir",
				"line": 1613,
				"comment": "Remove directory $(D pathname).\n\nThrows: $(D FileException) on error.\n",
				"deco": "FxAaZv",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAa"
					}
				],
				"endline": 1625,
				"originalType": "void(in char[] pathname)",
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "symlink",
						"line": 1644,
						"type": "@safe void(const(C1)[] original, const(C2)[] link)",
						"parameters": [
							{
								"name": "original",
								"type": "const(C1)[]"
							},
							{
								"name": "link",
								"type": "const(C2)[]"
							}
						],
						"char": 23,
						"kind": "function"
					}
				],
				"name": "symlink",
				"line": 1644,
				"comment": "    $(BLUE This function is Posix-Only.)\n\n    Creates a symlink.\n\n    Params:\n        original = The file to link from.\n        link     = The symlink to create.\n\n    Note:\n        Relative paths are relative to the current working directory,\n        not the files being linked to or from.\n\n    Throws:\n        $(D FileException) on error (which includes if the symlink already\n        exists).\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"char": 23,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "readLink",
						"line": 1710,
						"type": "@safe string(const(C)[] link)",
						"parameters": [
							{
								"name": "link",
								"type": "const(C)[]"
							}
						],
						"char": 25,
						"kind": "function"
					}
				],
				"name": "readLink",
				"line": 1710,
				"comment": "    $(BLUE This function is Posix-Only.)\n\n    Returns the path to the file pointed to by a symlink. Note that the\n    path could be either relative or absolute depending on the symlink.\n    If the path is relative, it's relative to the symlink, not the current\n    working directory.\n\n    Throws:\n        $(D FileException) on error.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"char": 25,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "getcwd",
				"line": 1800,
				"comment": " Get the current working directory.\n Throws: $(D FileException) on error.\n",
				"deco": "FZAya",
				"endline": 1806,
				"char": 29,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "thisExePath",
				"line": 1826,
				"comment": " Returns the full path of the current executable.\n\n Throws:\n $(XREF object, Exception)\n",
				"deco": "FNeZAya",
				"endline": 1898,
				"char": 17,
				"kind": "function"
			},
			{
				"name": "DirEntry",
				"line": 1914,
				"comment": "        Info on a file, similar to what you'd get from stat on a Posix system.\n",
				"members": [
					{
						"name": "this",
						"line": 1925,
						"comment": "            Constructs a DirEntry for the given file (or directory).\n\n            Params:\n                path = The file (or directory) to get a DirEntry for.\n\n            Throws:\n                $(D FileException) if the file does not exist.\n",
						"deco": "FNcAyaZS3std4file8DirEntry",
						"parameters": [
							{
								"name": "path",
								"deco": "Aya"
							}
						],
						"originalType": "ref (string path)",
						"char": 9,
						"kind": "constructor"
					},
					{
						"name": "name",
						"line": 1948,
						"comment": "            Returns the path to the file represented by this $(D DirEntry).\n\nExamples:\n--------------------\nauto de1 = DirEntry(\"/etc/fonts/fonts.conf\");\nassert(de1.name == \"/etc/fonts/fonts.conf\");\n\nauto de2 = DirEntry(\"/usr/share/include\");\nassert(de2.name == \"/usr/share/include\");\n--------------------\n",
						"deco": "xFNdZAya",
						"char": 26,
						"kind": "function"
					},
					{
						"name": "isDir",
						"line": 1964,
						"comment": "            Returns whether the file represented by this $(D DirEntry) is a\n            directory.\n\nExamples:\n--------------------\nauto de1 = DirEntry(\"/etc/fonts/fonts.conf\");\nassert(!de1.isDir);\n\nauto de2 = DirEntry(\"/usr/share/include\");\nassert(de2.isDir);\n--------------------\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "isFile",
						"line": 1990,
						"comment": "            Returns whether the file represented by this $(D DirEntry) is a file.\n\n            On Windows, if a file is not a directory, then it's a file. So,\n            either $(D isFile) or $(D isDir) will return $(D true).\n\n            On Posix systems, if $(D isFile) is $(D true), that indicates that\n            the file is a regular file (e.g. not a block not device). So, on\n            Posix systems, it's possible for both $(D isFile) and $(D isDir) to\n            be $(D false) for a particular file (in which case, it's a special\n            file). You can use $(D attributes) or $(D statBuf) to get more\n            information about a special file (see the stat man page for more\n            details).\n\nExamples:\n--------------------\nauto de1 = DirEntry(\"/etc/fonts/fonts.conf\");\nassert(de1.isFile);\n\nauto de2 = DirEntry(\"/usr/share/include\");\nassert(!de2.isFile);\n--------------------\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "isSymlink",
						"line": 1999,
						"comment": "            Returns whether the file represented by this $(D DirEntry) is a\n            symbolic link.\n\n            On Windows, return $(D true) when the file is either a symbolic\n            link or a junction point.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "size",
						"line": 2005,
						"comment": "            Returns the size of the the file represented by this $(D DirEntry)\n            in bytes.\n",
						"deco": "FNdZm",
						"char": 25,
						"kind": "function"
					},
					{
						"name": "timeCreated",
						"line": 2013,
						"comment": "            $(BLUE This function is Windows-Only.)\n\n            Returns the creation time of the file represented by this\n            $(D DirEntry).\n",
						"deco": "xFNdZS3std8datetime7SysTime",
						"char": 27,
						"kind": "function"
					},
					{
						"name": "timeLastAccessed",
						"line": 2024,
						"comment": "            Returns the time that the file represented by this $(D DirEntry) was\n            last accessed.\n\n            Note that many file systems do not update the access time for files\n            (generally for performance reasons), so there's a good chance that\n            $(D timeLastAccessed) will return the same value as\n            $(D timeLastModified).\n",
						"deco": "FNdZS3std8datetime7SysTime",
						"char": 27,
						"kind": "function"
					},
					{
						"name": "timeLastModified",
						"line": 2030,
						"comment": "            Returns the time that the file represented by this $(D DirEntry) was\n            last modified.\n",
						"deco": "FNdZS3std8datetime7SysTime",
						"char": 27,
						"kind": "function"
					},
					{
						"name": "attributes",
						"line": 2046,
						"comment": "            Returns the attributes of the file represented by this $(D DirEntry).\n\n            Note that the file attributes on Windows and Posix systems are\n            completely different. On, Windows, they're what is returned by\n            $(D GetFileAttributes)\n            $(WEB msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx, GetFileAttributes)\n            Whereas, an Posix systems, they're the $(D st_mode) value which is\n            part of the $(D stat) struct gotten by calling $(D stat).\n\n            On Posix systems, if the file represented by this $(D DirEntry) is a\n            symbolic link, then attributes are the attributes of the file\n            pointed to by the symbolic link.\n",
						"deco": "FNdZk",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "linkAttributes",
						"line": 2058,
						"comment": "            On Posix systems, if the file represented by this $(D DirEntry) is a\n            symbolic link, then $(D linkAttributes) are the attributes of the\n            symbolic link itself. Otherwise, $(D linkAttributes) is identical to\n            $(D attributes).\n\n            On Windows, $(D linkAttributes) is identical to $(D attributes). It\n            exists on Windows so that you don't have to special-case code for\n            Windows when dealing with symbolic links.\n",
						"deco": "FNdZk",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "statBuf",
						"line": 2068,
						"comment": "            $(BLUE This function is Posix-Only.)\n\n            The $(D stat) struct gotten from calling $(D stat).\n",
						"deco": "FNdZS4core3sys5posix3sys4stat6stat_t",
						"char": 26,
						"kind": "function"
					}
				],
				"char": 5,
				"kind": "struct"
			},
			{
				"name": "preserveAttributesDefault",
				"line": 2462,
				"comment": "Defaults to PreserveAttributes.yes on Windows, and the opposite on all other platforms.\n",
				"deco": "E3std8typecons53__T4FlagVAyaa18_707265736572766541747472696275746573Z4Flag",
				"originalType": "PreserveAttributes",
				"char": 24,
				"kind": "variable"
			},
			{
				"endchar": 1,
				"name": "copy",
				"line": 2481,
				"comment": "Copy file $(D from) to file $(D to). File timestamps are preserved.\nFile attributes are preserved, if $(D preserve) equals $(D PreserveAttributes.yes).\nOn Windows only $(D PreserveAttributes.yes) (the default on Windows) is supported.\nIf the target file exists, it is overwritten.\n\nThrows: $(D FileException) on error.\n",
				"deco": "FxAaxAaE3std8typecons53__T4FlagVAyaa18_707265736572766541747472696275746573Z4FlagZv",
				"parameters": [
					{
						"name": "from",
						"deco": "xAa"
					},
					{
						"name": "to",
						"deco": "xAa"
					},
					{
						"name": "preserve",
						"deco": "E3std8typecons53__T4FlagVAyaa18_707265736572766541747472696275746573Z4Flag",
						"default": "preserveAttributesDefault"
					}
				],
				"endline": 2541,
				"originalType": "void(in char[] from, in char[] to, PreserveAttributes preserve = preserveAttributesDefault)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "rmdirRecurse",
				"line": 2574,
				"comment": "    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n",
				"deco": "FxAaZv",
				"parameters": [
					{
						"name": "pathname",
						"deco": "xAa"
					}
				],
				"endline": 2579,
				"originalType": "void(in char[] pathname)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "rmdirRecurse",
				"line": 2589,
				"comment": "    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n",
				"deco": "FKS3std4file8DirEntryZv",
				"parameters": [
					{
						"name": "de",
						"storageClass": [
							"ref"
						],
						"deco": "S3std4file8DirEntry"
					}
				],
				"endline": 2612,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "rmdirRecurse",
				"line": 2619,
				"comment": "ditto\n",
				"deco": "FS3std4file8DirEntryZv",
				"parameters": [
					{
						"name": "de",
						"deco": "S3std4file8DirEntry"
					}
				],
				"endline": 2622,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "shallow",
						"line": 2683,
						"value": "0",
						"comment": " Only spans one directory.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "depth",
						"line": 2687,
						"value": "1",
						"comment": " Spans the directory depth-first, i.e. the content of any\n     subdirectory is spanned before that subdirectory itself. Useful\n     e.g. when recursively deleting files.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "breadth",
						"line": 2690,
						"value": "2",
						"comment": " Spans the directory breadth-first, i.e. the content of any\n     subdirectory is spanned right after that subdirectory itself.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SpanMode",
				"line": 2680,
				"comment": " Dictates directory spanning policy for $(D_PARAM dirEntries) (see below).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "dirEntries",
				"line": 2966,
				"comment": "    Returns an input range of DirEntry that lazily iterates a given directory,\n    also provides two ways of foreach iteration. The iteration variable can be of\n    type $(D_PARAM string) if only the name is needed, or $(D_PARAM DirEntry)\n    if additional details are needed. The span mode dictates the how the\n    directory is traversed. The name of the each directory entry iterated\n    contains the absolute path.\n\n    Params:\n        path = The directory to iterate over.\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\n    Throws:\n        $(D FileException) if the directory does not exist.\n\nExamples:\n--------------------\n// Iterate a directory in depth\nforeach (string name; dirEntries(\"destroy/me\", SpanMode.depth))\n{\n remove(name);\n}\n// Iterate a directory in breadth\nforeach (string name; dirEntries(\".\", SpanMode.breadth))\n{\n writeln(name);\n}\n// Iterate a directory and get detailed info about it\nforeach (DirEntry e; dirEntries(\"dmd-testing\", SpanMode.breadth))\n{\n writeln(e.name, \"\\t\", e.size);\n}\n// Iterate over all *.d files in current directory and all its subdirectories\nauto dFiles = filter!`endsWith(a.name,\".d\")`(dirEntries(\".\",SpanMode.depth));\nforeach(d; dFiles)\n    writeln(d.name);\n// Hook it up with std.parallelism to compile them all in parallel:\nforeach(d; parallel(dFiles, 1)) //passes by 1 file to each thread\n{\n    string cmd = \"dmd -c \"  ~ d.name;\n    writeln(cmd);\n    std.process.system(cmd);\n}\n--------------------\nExample:\nDuplicate functionality of D1's $(D std.file.listdir()):$(DDOX_UNITTEST_HEADER __unittestL2972_1503)\n---\nstring[] listdir(string pathname)\n{\n    import std.file;\n    import std.path;\n    import std.algorithm;\n    import std.array;\n\n    return std.file.dirEntries(pathname, SpanMode.shallow)\n        .filter!(a => a.isFile)\n        .map!(a => std.path.baseName(a.name))\n        .array;\n}\n\nvoid main(string[] args)\n{\n    import std.stdio;\n\n    string[] files = listdir(args[1]);\n    writefln(\"%s\", files);\n }\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2972_1503)\n",
				"deco": "FAyaE3std4file8SpanModebZS3std4file11DirIterator",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					},
					{
						"name": "mode",
						"deco": "E3std4file8SpanMode"
					},
					{
						"name": "followSymlink",
						"deco": "b",
						"default": "true"
					}
				],
				"endline": 2969,
				"originalType": "(string path, SpanMode mode, bool followSymlink = true)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"endchar": 1,
				"name": "dirEntries",
				"line": 3083,
				"comment": "    Convenience wrapper for filtering file names with a glob pattern.\n\n    Params:\n        path = The directory to iterate over.\n        pattern  = String with wildcards, such as $(RED \"*.d\"). The supported\n                   wildcard strings are described under\n                   $(XREF _path, globMatch).\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\n    Throws:\n        $(D FileException) if the directory does not exist.\n\nExamples:\n--------------------\n// Iterate over all D source files in current directory and all its\n// subdirectories\nauto dFiles = dirEntries(\".\",\"*.{d,di}\",SpanMode.depth);\nforeach(d; dFiles)\n    writeln(d.name);\n--------------------\n",
				"deco": "FAyaAyaE3std4file8SpanModebZS3std9algorithm9iteration121__T12FilterResultS76_D3std4file10dirEntriesFAyaAyaE3std4file8SpanModebZ1fMFS3std4file8DirEntryZbTS3std4file11DirIteratorZ12FilterResult",
				"parameters": [
					{
						"name": "path",
						"deco": "Aya"
					},
					{
						"name": "pattern",
						"deco": "Aya"
					},
					{
						"name": "mode",
						"deco": "E3std4file8SpanMode"
					},
					{
						"name": "followSymlink",
						"deco": "b",
						"default": "true"
					}
				],
				"endline": 3089,
				"originalType": "(string path, string pattern, SpanMode mode, bool followSymlink = true)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "slurp",
						"line": 3194,
						"type": "Select!(Types.length == 1, Types[0][], Tuple!Types[])(string filename, in char[] format)",
						"parameters": [
							{
								"name": "filename",
								"type": "string"
							},
							{
								"name": "format",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 3213,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "slurp",
				"line": 3194,
				"comment": "Reads an entire file into an array.\n\nExample:\n----\n// Load file; each line is an int followed by comma, whitespace and a\n// double.\nauto a = slurp!(int, double)(\"filename\", \"%s, %s\");\n----\n\nBugs:\n$(D slurp) expects file names to be encoded in $(B CP_ACP) on $(I Windows)\ninstead of UTF-8 (as it internally uses $(XREF stdio, File),\nsee $(BUGZILLA 7648)) thus must not be used in $(I Windows)\nor cross-platform applications other than with an immediate ASCII string as\na file name to prevent accidental changes to result in incorrect behavior.\n",
				"parameters": [
					{
						"name": "Types",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "tempDir",
				"line": 3257,
				"comment": "Returns the path to a directory for temporary files.\n\nOn Windows, this function returns the result of calling the Windows API function\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/aa364992.aspx, $(D GetTempPath)).\n\nOn POSIX platforms, it searches through the following list of directories\nand returns the first one which is found to exist:\n$(OL\n    $(LI The directory given by the $(D TMPDIR) environment variable.)\n    $(LI The directory given by the $(D TEMP) environment variable.)\n    $(LI The directory given by the $(D TMP) environment variable.)\n    $(LI $(D /tmp))\n    $(LI $(D /var/tmp))\n    $(LI $(D /usr/tmp))\n)\n\nOn all platforms, $(D tempDir) returns $(D \".\") on failure, representing\nthe current working directory.\n\nThe return value of the function is cached, so the procedures described\nabove will only be performed the first time the function is called.  All\nsubsequent runs will return the same string, regardless of whether\nenvironment variables and directory structures have changed in the\nmeantime.\n\nThe POSIX $(D tempDir) algorithm is inspired by Python's\n$(LINK2 http://docs.python.org/library/tempfile.html#tempfile.tempdir, $(D tempfile.tempdir)).\n",
				"deco": "FNeZAya",
				"endline": 3294,
				"char": 8,
				"kind": "function"
			}
		],
		"comment": "Utilities for manipulating files and scanning directories. Functions\nin this module handle files as a unit, e.g., read or write one _file\nat a time. For opening files and manipulating them via handles refer\nto module $(LINK2 std_stdio.html,$(D std.stdio)).\n\nMacros:\nWIKI = Phobos/StdFile\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis\nSource:    $(PHOBOSSRC std/_file.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/bigint.d",
		"name": "std.bigint",
		"members": [
			{
				"name": "BigInt",
				"line": 43,
				"comment": " A struct representing an arbitrary precision integer.\n\n All arithmetic operations are supported, except unsigned shift right (>>>).\n Bitwise operations (|, &, ^, ~) are supported, and behave as if BigInt was\n an infinite length 2's complement number.\n\n BigInt implements value semantics using copy-on-write. This means that\n assignment is cheap, but operations such as x++ will cause heap\n allocation. (But note that for most bigint operations, heap allocation is\n inevitable anyway.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL824_1528)\n---\nBigInt a = \"9588669891916142\";\nBigInt b = \"7452469135154800\";\nauto c = a * b;\nassert(c == BigInt(\"71459266416693160362545788781600\"));\nauto d = b * a;\nassert(d == BigInt(\"71459266416693160362545788781600\"));\nassert(d == c);\nd = c * BigInt(\"794628672112\");\nassert(d == BigInt(\"56783581982794522489042432639320434378739200\"));\nauto e = c + d;\nassert(e == BigInt(\"56783581982865981755459125799682980167520800\"));\nauto f = d + c;\nassert(f == e);\nauto g = f - c;\nassert(g == d);\ng = f - d;\nassert(g == c);\ne = 12345678;\ng = c + e;\nauto h = g / b;\nauto i = g % b;\nassert(h == a);\nassert(i == e);\nBigInt j = \"-0x9A56_57f4_7B83_AB78\";\nj ^^= 11;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL824_1528)\n",
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 54,
								"type": "pure (T s)",
								"parameters": [
									{
										"name": "s",
										"type": "T"
									}
								],
								"endline": 78,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 54,
						"comment": "Construct a BigInt from a decimal or hexadecimal string.\n\nThe number must be in the form of a D decimal or hex literal:\n\nIt may have a leading + or - sign; followed by \"0x\" if hexadecimal.\n\nUnderscores are permitted.\n\nBUG: Should throw a IllegalArgumentException/ConvError if invalid character found\n",
						"parameters": [
							{
								"name": "T",
								"deco": "Axa",
								"kind": "type"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 81,
								"type": "pure nothrow (T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 85,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 81,
						"comment": "Construct a BigInt from a built-in integral type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL88_1509)\n---\nulong data = 1_000_000_000_000;\nauto bigData = BigInt(data);\nassert(data == BigInt(\"1_000_000_000_000\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL88_1509)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 96,
								"type": "pure nothrow (T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 99,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 96,
						"comment": "Construct a BigInt from another BigInt.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL102_1510)\n---\nconst(BigInt) b1 = BigInt(\"1_234_567_890\");\nBigInt b2 = BigInt(b1);\nassert(b2 == BigInt(\"1_234_567_890\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL102_1510)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == BigInt)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 110,
								"type": "pure nothrow BigInt(T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 115,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opAssign",
						"line": 110,
						"comment": "Assignment from built-in integer types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL118_1511)\n---\nauto b = BigInt(\"123\");\nb = 456;\nassert(b == BigInt(\"456\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL118_1511)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 126,
								"type": "pure @nogc BigInt(T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 131,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opAssign",
						"line": 126,
						"comment": "Assignment from another BigInt.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL134_1512)\n---\nauto b1 = BigInt(\"123\");\nauto b2 = BigInt(\"456\");\nb2 = b1;\nassert(b2 == BigInt(\"123\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL134_1512)\n",
						"parameters": [
							{
								"name": "T",
								"deco": "S3std6bigint6BigInt",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 146,
								"type": "pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 228,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 146,
						"comment": " Implements assignment operators from built-in integers of the form\n $(D BigInt op= integer).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL231_1513)\n---\nauto b = BigInt(\"1_000_000_000\");\n\nb += 12345;\nassert(b == BigInt(\"1_000_012_345\"));\n\nb /= 5;\nassert(b == BigInt(\"200_002_469\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL231_1513)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\" || op == \"*\" || op == \"/\" || op == \"%\" || op == \">>\" || op == \"<<\" || op == \"^^\" || op == \"|\" || op == \"&\" || op == \"^\") && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 245,
								"type": "pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 289,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 245,
						"comment": " Implements assignment operators of the form $(D BigInt op= BigInt).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL292_1514)\n---\nauto x = BigInt(\"123\");\nauto y = BigInt(\"321\");\nx += y;\nassert(x == BigInt(\"444\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL292_1514)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"-\" || op == \"*\" || op == \"|\" || op == \"&\" || op == \"^\" || op == \"/\" || op == \"%\") && is(T : BigInt)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 303,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 310,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 303,
						"comment": " Implements binary operators between BigInts.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL313_1515)\n---\nauto x = BigInt(\"123\");\nauto y = BigInt(\"456\");\nBigInt z = x * y;\nassert(z == BigInt(\"56088\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL313_1515)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"*\" || op == \"-\" || op == \"|\" || op == \"&\" || op == \"^\" || op == \"/\" || op == \"%\") && is(T : BigInt)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 324,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 331,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 324,
						"comment": " Implements binary operators between BigInt's and built-in integers.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL334_1516)\n---\nauto x = BigInt(\"123\");\nx *= 300;\nassert(x == BigInt(\"36900\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL334_1516)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"*\" || op == \"-\" || op == \"/\" || op == \"|\" || op == \"&\" || op == \"^\" || op == \">>\" || op == \"<<\" || op == \"^^\") && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 353,
								"type": "const pure nothrow (T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 383,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "opBinary",
						"line": 353,
						"comment": "        Implements a narrowing remainder operation with built-in integer types.\n\n        This binary operator returns a narrower, built-in integer type\n        where applicable, according to the following table.\n\n        $(TABLE ,\n        $(TR $(TD `BigInt`) $(TD $(CODE_PERCENT)) $(TD `long`) $(TD $(RARR)) $(TD `long`))\n        $(TR $(TD `BigInt`) $(TD $(CODE_PERCENT)) $(TD `ulong`) $(TD $(RARR)) $(TD `BigInt`))\n        $(TR $(TD `BigInt`) $(TD $(CODE_PERCENT)) $(TD other type) $(TD $(RARR)) $(TD `int`))\n        )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL386_1517)\n---\nauto  x  = BigInt(\"1_000_000_500\");\nlong  l  = 1_000_000L;\nulong ul = 2_000_000UL;\nint   i  = 500_000;\nshort s  = 30_000;\n\nassert(is(typeof(x % l)  == long)   && x % l  == 500L);\nassert(is(typeof(x % ul) == BigInt) && x % ul == BigInt(500));\nassert(is(typeof(x % i)  == int)    && x % i  == 500);\nassert(is(typeof(x % s)  == int)    && x % s  == 10500);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL386_1517)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"%\" && isIntegral!T",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 404,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 408,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 404,
						"comment": "        Implements operators with built-in integers on the left-hand side and\n        BigInt on the right-hand side.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL411_1518)\n---\nauto x = BigInt(\"100\");\nBigInt y = 123 + x;\nassert(y == BigInt(\"223\"));\n\nBigInt z = 123 - x;\nassert(z == BigInt(\"23\"));\n\n// Dividing a built-in integer type by BigInt always results in\n// something that fits in a built-in type, so the built-in type is\n// returned, not BigInt.\nassert(is(typeof(1000 / x) == int));\nassert(1000 / x == 10);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL411_1518)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"+\" || op == \"*\" || op == \"|\" || op == \"&\" || op == \"^\") && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 429,
								"type": "const pure nothrow BigInt(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 441,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 429,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "op == \"-\" && isIntegral!T",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinaryRight",
								"line": 445,
								"type": "const pure nothrow T(T x)",
								"parameters": [
									{
										"name": "x",
										"type": "T"
									}
								],
								"endline": 466,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "opBinaryRight",
						"line": 445,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "(op == \"%\" || op == \"/\") && isIntegral!T",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 472,
								"type": "const pure nothrow BigInt()",
								"endline": 486,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 472,
						"comment": "        Implements BigInt unary operators.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL505_1519)\n---\nauto x = BigInt(\"1234\");\nassert(-x == BigInt(\"-1234\"));\n\n++x;\nassert(x == BigInt(\"1235\"));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL505_1519)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"+\" || op == \"-\" || op == \"~\"",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opUnary",
								"line": 490,
								"type": "pure nothrow BigInt()",
								"endline": 502,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opUnary",
						"line": 490,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"++\" || op == \"--\"",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 518,
								"type": "const pure @nogc bool(auto ref const BigInt y)",
								"parameters": [
									{
										"name": "y",
										"type": "BigInt",
										"storageClass": [
											"auto",
											"const",
											"ref"
										]
									}
								],
								"endline": 521,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opEquals",
						"line": 518,
						"comment": "        Implements BigInt equality test with other BigInt's and built-in\n        integer types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL532_1520)\n---\nauto x = BigInt(\"12345\");\nauto y = BigInt(\"12340\");\nint z = 12345;\nint w = 54321;\n\nassert(x == x);\nassert(x != y);\nassert(x == y + 5);\nassert(x == z);\nassert(x != w);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL532_1520)\n",
						"parameters": [],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 524,
								"type": "const pure nothrow @nogc bool(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 529,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opEquals",
						"line": 524,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 549,
								"type": "const pure nothrow @nogc T()",
								"endline": 552,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 549,
						"comment": "        Implements casting to bool.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL555_1521)\n---\n// Non-zero values are regarded as true\nauto x = BigInt(\"1\");\nauto y = BigInt(\"10\");\nassert(x);\nassert(y);\n\n// Zero value is regarded as false\nauto z = BigInt(\"0\");\nassert(!z);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL555_1521)\n",
						"parameters": [
							{
								"name": "T",
								"deco": "b",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 574,
								"type": "const pure nothrow @nogc T()",
								"endline": 576,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 574,
						"comment": "        Implements casting to/from qualified BigInt's.\n\n        Warning: Casting to/from $(D const) or $(D immutable) may break type\n        system guarantees. Use with care.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL579_1522)\n---\nconst(BigInt) x = BigInt(\"123\");\nBigInt y = cast() x;    // cast away const\nassert(y == x);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL579_1522)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!T == BigInt)",
						"char": 7,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 593,
						"comment": "        Implements 3-way comparisons of BigInt with BigInt or BigInt with\n        built-in integers.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL617_1523)\n---\nauto x = BigInt(\"100\");\nauto y = BigInt(\"10\");\nint z = 50;\nconst int w = 200;\n\nassert(y < x);\nassert(x > z);\nassert(z > y);\nassert(x < w);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL617_1523)\n",
						"deco": "xFNaNbNiKxS3std6bigint6BigIntZi",
						"parameters": [
							{
								"name": "y",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std6bigint6BigInt"
							}
						],
						"endline": 597,
						"originalType": "const pure nothrow @nogc int(ref const BigInt y)",
						"char": 9,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCmp",
								"line": 600,
								"type": "const pure nothrow @nogc int(T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T"
									}
								],
								"endline": 606,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opCmp",
						"line": 600,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isIntegral!T",
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCmp",
								"line": 608,
								"type": "const pure nothrow @nogc int(const T y)",
								"parameters": [
									{
										"name": "y",
										"type": "T",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 614,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opCmp",
						"line": 608,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "T",
								"deco": "S3std6bigint6BigInt",
								"kind": "type"
							}
						],
						"char": 9,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toLong",
						"line": 634,
						"comment": "        Returns: The value of this BigInt as a long, or +/- long.max if outside\n        the representable range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL643_1524)\n---\nauto b = BigInt(\"12345\");\nlong l = b.toLong();\nassert(l == 12345);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL643_1524)\n",
						"deco": "xFNaNbNiNfZl",
						"endline": 640,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toInt",
						"line": 654,
						"comment": "        Returns: The value of this BigInt as an int, or +/- int.max if outside\n        the representable range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL663_1525)\n---\nauto big = BigInt(\"5_000_000\");\nauto i = big.toInt();\nassert(i == 5_000_000);\n\n// Numbers that are too big to fit into an int will be clamped to int.max.\nauto tooBig = BigInt(\"5_000_000_000\");\ni = tooBig.toInt();\nassert(i == int.max);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL663_1525)\n",
						"deco": "xFNaNbNiNfZi",
						"endline": 660,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "uintLength",
						"line": 677,
						"comment": "Number of significant uints which are used in storing this number.\n\nThe absolute value of this BigInt is always &lt; 2$(SUPERSCRIPT 32*uintLength)\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 680,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "ulongLength",
						"line": 684,
						"comment": "Number of significant ulongs which are used in storing this number.\n\nThe absolute value of this BigInt is always &lt; 2$(SUPERSCRIPT 64*ulongLength)\n",
						"deco": "xFNaNbNdNiNfZm",
						"endline": 687,
						"originalType": "const pure nothrow @nogc @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 704,
						"comment": " Convert the BigInt to string, passing it to the given sink.\n\n Params:\n  sink = A delegate for accepting possibly piecewise segments of the\n      formatted string.\n  formatString = A format string specifying the output format.\n\n $(TABLE  Available output formats:,\n $(TR $(TD \"d\") $(TD  Decimal))\n $(TR $(TD \"x\") $(TD  Hexadecimal, lower case))\n $(TR $(TD \"X\") $(TD  Hexadecimal, upper case))\n $(TR $(TD \"s\") $(TD  Default formatting (same as \"d\") ))\n $(TR $(TD null) $(TD Default formatting (same as \"d\") ))\n )\nExample:\n$(D toString) is rarely directly invoked; the usual way of using it is via\n        $(LINK2 std_format.html#format, std.format.format):$(DDOX_UNITTEST_HEADER __unittestL765_1526)\n---\nimport std.format : format;\n\nauto x = BigInt(\"1_000_000\");\nx *= 12345;\n\nassert(format(\"%d\", x) == \"12345000000\");\nassert(format(\"%X\", x) == \"2_DFD1C040\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL765_1526)\n",
						"deco": "xFMDFAxaZvAyaZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							},
							{
								"name": "formatString",
								"deco": "Aya"
							}
						],
						"endline": 709,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 712,
						"comment": "ditto\n",
						"deco": "xFMDFAxaZvKS3std6format18__T10FormatSpecTaZ10FormatSpecZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							},
							{
								"name": "f",
								"storageClass": [
									"ref"
								],
								"deco": "S3std6format18__T10FormatSpecTaZ10FormatSpec"
							}
						],
						"endline": 759,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 781,
						"comment": "        Returns: A unique hash of the BigInt's value suitable for use in a hash\n        table.\nExample:\n$(D toHash) is rarely directly invoked; it is implicitly used when\n        BigInt is used as the key of an associative array.$(DDOX_UNITTEST_HEADER __unittestL790_1527)\n---\nstring[BigInt] aa;\naa[BigInt(123)] = \"abc\";\naa[BigInt(456)] = \"def\";\n\nassert(aa[BigInt(123)] == \"abc\");\nassert(aa[BigInt(456)] == \"def\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL790_1527)\n",
						"deco": "xFNbNfZm",
						"endline": 784,
						"originalType": "const nothrow @safe size_t()",
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "toDecimalString",
				"line": 861,
				"comment": "Params:\n    x = The $(D BigInt) to convert to a decimal $(D string).\n\nReturns:\n    A $(D string) that represents the $(D BigInt) as a decimal number.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL870_1529)\n---\nauto x = BigInt(\"123\");\nx *= 1000;\nx += 456;\n\nauto xstr = x.toDecimalString();\nassert(xstr == \"123456\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL870_1529)\n",
				"deco": "FxS3std6bigint6BigIntZAya",
				"parameters": [
					{
						"name": "x",
						"deco": "xS3std6bigint6BigInt"
					}
				],
				"endline": 867,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toHex",
				"line": 889,
				"comment": "Params:\n    x = The $(D BigInt) to convert to a hexadecimal $(D string).\n\nReturns:\n    A $(D string) that represents the $(D BigInt) as a hexadecimal (base 16)\n    number.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL898_1530)\n---\nauto x = BigInt(\"123\");\nx *= 1000;\nx += 456;\n\nauto xstr = x.toHex();\nassert(xstr == \"1E240\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL898_1530)\n",
				"deco": "FxS3std6bigint6BigIntZAya",
				"parameters": [
					{
						"name": "x",
						"deco": "xS3std6bigint6BigInt"
					}
				],
				"endline": 895,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "absUnsign",
						"line": 918,
						"type": "Unsigned!T(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 933,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "absUnsign",
				"line": 918,
				"comment": " Returns the absolute value of x converted to the corresponding unsigned\ntype.\n\nParams:\n    x = The integral value to return the absolute value of.\n\nReturns:\n    The absolute value of x.\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 12,
				"kind": "template"
			}
		],
		"comment": " Arbitrary-precision ('bignum') arithmetic.\n\n Performance is optimized for numbers below ~1000 decimal digits.\n For X86 machines, highly optimised assembly routines are used.\n\n The following algorithms are currently implemented:\n $(UL\n $(LI Karatsuba multiplication)\n $(LI Squaring is optimized independently of multiplication)\n $(LI Divide-and-conquer division)\n $(LI Binary exponentiation)\n )\n\n For very large numbers, consider using the $(WEB gmplib.org, GMP library) instead.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Don Clugston\n Source: $(PHOBOSSRC std/_bigint.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/regex/package.d",
		"name": "std.regex",
		"members": [
			{
				"members": [
					{
						"name": "Regex",
						"line": 288,
						"type": "std.regex.internal.ir.Regex!Char",
						"char": 8,
						"kind": "alias"
					}
				],
				"name": "Regex",
				"line": 288,
				"comment": "    $(D Regex) object holds regular expression pattern in compiled form.\n\n    Instances of this object are constructed via calls to $(D regex).\n    This is an intended form for caching and storage of frequently\n    used regular expressions.\n\n    Examples:\n\n    Test if this object doesn't contain any compiled pattern.\n    ---\n    Regex!char r;\n    assert(r.empty);\n    r = regex(\"\"); // Note: \"\" is a valid regex pattern.\n    assert(!r.empty);\n    ---\n\n    Getting a range of all the named captures in the regex.\n    ----\n    import std.range;\n    import std.algorithm;\n\n    auto re = regex(`(?P<name>\\w+) = (?P<var>\\d+)`);\n    auto nc = re.namedCaptures;\n    static assert(isRandomAccessRange!(typeof(nc)));\n    assert(!nc.empty);\n    assert(nc.length == 2);\n    assert(nc.equal([\"name\", \"var\"]));\n    assert(nc[0] == \"name\");\n    assert(nc[1..$].equal([\"var\"]));\n    ----\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "StaticRegex",
						"line": 297,
						"type": "std.regex.internal.ir.StaticRegex!Char",
						"char": 8,
						"kind": "alias"
					}
				],
				"name": "StaticRegex",
				"line": 297,
				"comment": "    A $(D StaticRegex) is $(D Regex) object that contains D code specially\n    generated at compile-time to speed up matching.\n\n    Implicitly convertible to normal $(D Regex),\n    however doing so will result in losing this additional capability.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "regex",
						"line": 310,
						"type": "@trusted (S pattern, const(char)[] flags = \"\")",
						"parameters": [
							{
								"name": "pattern",
								"type": "S"
							},
							{
								"name": "flags",
								"type": "const(char)[]",
								"default": "\"\""
							}
						],
						"endline": 318,
						"char": 22,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "regex",
				"line": 310,
				"comment": "    Compile regular expression pattern for the later execution.\n    Returns: $(D Regex) object that works on inputs having\n    the same character width as $(D pattern).\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n\n    Throws: $(D RegexException) if there were any errors during compilation.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ctRegex",
						"line": 355,
						"init": "ctRegexImpl!(pattern, flags).nr",
						"char": 13,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "ctRegex",
				"line": 355,
				"comment": "    Compile regular expression using CTFE\n    and generate optimized native machine code for matching it.\n\n    Returns: StaticRegex object for faster matching.\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n",
				"parameters": [
					{
						"name": "pattern",
						"kind": "alias"
					},
					{
						"name": "flags",
						"defaultAlias": "[]",
						"kind": "alias"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Captures",
						"line": 367,
						"members": [
							{
								"endchar": 5,
								"name": "pre",
								"line": 419,
								"comment": "Slice of input prior to the match.\n",
								"type": "@property R()",
								"endline": 422,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "post",
								"line": 425,
								"comment": "Slice of input immediately after the match.\n",
								"type": "@property R()",
								"endline": 428,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "hit",
								"line": 431,
								"comment": "Slice of matched portion of input.\n",
								"type": "@property R()",
								"endline": 435,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 438,
								"comment": "Range interface.\n",
								"type": "@property R()",
								"endline": 442,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 445,
								"comment": "ditto\n",
								"type": "@property R()",
								"endline": 449,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 452,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 456,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popBack",
								"line": 459,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 463,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 63,
								"name": "empty",
								"line": 466,
								"comment": "ditto\n",
								"type": "const @property bool()",
								"endline": 466,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 469,
										"type": "R(size_t i)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 475,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opIndex",
								"line": 469,
								"comment": "ditto\n",
								"parameters": [],
								"char": 7,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 64,
										"name": "opCast",
										"line": 488,
										"type": "const nothrow @safe bool()",
										"endline": 488,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "opCast",
								"line": 488,
								"comment": "        Explicit cast to bool.\n        Useful as a shorthand for !(x.empty) in if and assert statements.\n\n        ---\n        import std.regex;\n\n        assert(!matchFirst(\"nothing\", \"something\"));\n        ---\n",
								"parameters": [
									{
										"name": "T",
										"deco": "b",
										"kind": "type"
									}
								],
								"char": 16,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 506,
										"type": "R(String i)",
										"parameters": [
											{
												"name": "i",
												"type": "String"
											}
										],
										"endline": 511,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opIndex",
								"line": 506,
								"comment": "        Lookup named submatch.\n\n        ---\n        import std.regex;\n        import std.range;\n\n        auto c = matchFirst(\"a = 42;\", regex(`(?P<var>\\w+)\\s*=\\s*(?P<value>\\d+);`));\n        assert(c[\"var\"] == \"a\");\n        assert(c[\"value\"] == \"42\");\n        popFrontN(c, 2);\n        //named groups are unaffected by range primitives\n        assert(c[\"var\"] ==\"a\");\n        assert(c.front == \"42\");\n        ----\n",
								"parameters": [
									{
										"name": "String",
										"kind": "type"
									}
								],
								"constraint": "isSomeString!String",
								"char": 7,
								"kind": "template"
							},
							{
								"endchar": 69,
								"name": "length",
								"line": 514,
								"comment": "Number of matches in this object.\n",
								"type": "const @property size_t()",
								"endline": 514,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 44,
								"name": "captures",
								"line": 517,
								"comment": "A hook for compatibility with original std.regex.\n",
								"type": "@property ref ()",
								"endline": 517,
								"char": 19,
								"kind": "function"
							}
						],
						"char": 17,
						"kind": "struct"
					}
				],
				"name": "Captures",
				"line": 367,
				"comment": "    $(D Captures) object contains submatches captured during a call\n    to $(D match) or iteration over $(D RegexMatch) range.\n\n    First element of range is the whole match.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL521_1551)\n---\nauto c = matchFirst(\"@abc#\", regex(`(\\w)(\\w)(\\w)`));\nassert(c.pre == \"@\"); // Part of input preceding match\nassert(c.post == \"#\"); // Immediately after match\nassert(c.hit == c[0] && c.hit == \"abc\"); // The whole match\nassert(c[2] == \"b\");\nassert(c.front == \"abc\");\nc.popFront();\nassert(c.front == \"a\");\nassert(c.back == \"c\");\nc.popBack();\nassert(c.back == \"b\");\npopFrontN(c, 2);\nassert(c.empty);\n\nassert(!matchFirst(\"nothing\", \"something\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL521_1551)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "DIndex",
						"default": "size_t",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RegexMatch",
						"line": 549,
						"members": [
							{
								"endchar": 5,
								"name": "pre",
								"line": 599,
								"comment": "Shorthands for front.pre, front.post, front.hit.\n",
								"type": "@property R()",
								"endline": 602,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "post",
								"line": 605,
								"comment": "ditto\n",
								"type": "@property R()",
								"endline": 608,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "hit",
								"line": 611,
								"comment": "ditto\n",
								"type": "@property R()",
								"endline": 614,
								"char": 17,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 628,
								"comment": "        Functionality for processing subsequent matches of global regexes via range interface:\n        ---\n        import std.regex;\n        auto m = matchAll(\"Hello, world!\", regex(`\\w+`));\n        assert(m.front.hit == \"Hello\");\n        m.popFront();\n        assert(m.front.hit == \"world\");\n        m.popFront();\n        assert(m.empty);\n        ---\n",
								"type": "@property ()",
								"endline": 631,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 634,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 648,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 31,
								"name": "save",
								"line": 651,
								"comment": "ditto\n",
								"type": "()",
								"endline": 651,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 54,
								"name": "empty",
								"line": 654,
								"comment": "Test if this match object is empty.\n",
								"type": "@property bool()",
								"endline": 654,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 40,
										"name": "opCast",
										"line": 657,
										"type": "T()",
										"endline": 657,
										"char": 7,
										"kind": "function"
									}
								],
								"name": "opCast",
								"line": 657,
								"comment": "Same as !(x.empty), provided for its convenience  in conditional statements.\n",
								"parameters": [
									{
										"name": "T",
										"deco": "b",
										"kind": "type"
									}
								],
								"char": 7,
								"kind": "template"
							},
							{
								"endchar": 50,
								"name": "captures",
								"line": 660,
								"comment": "Same as .front, provided for compatibility with original std.regex.\n",
								"type": "@property ()",
								"endline": 660,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"char": 17,
						"kind": "struct"
					}
				],
				"name": "RegexMatch",
				"line": 549,
				"comment": "    A regex engine state, as returned by $(D match) family of functions.\n\n    Effectively it's a forward range of Captures!R, produced\n    by lazily searching for matches in a given input.\n\n    $(D alias Engine) specifies an engine type to use during matching,\n    and is automatically deduced in a call to $(D match)/$(D bmatch).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "Engine",
						"defaultAlias": "ThompsonMatcher",
						"kind": "alias"
					}
				],
				"constraint": "isSomeString!R",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "match",
						"line": 776,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 781,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "match",
				"line": 776,
				"comment": "    Start matching $(D input) to regex pattern $(D re),\n    using Thompson NFA matching scheme.\n\n    The use of this function is $(RED discouraged) - use either of\n    $(LREF matchAll) or $(LREF matchFirst).\n\n    Delegating  the kind of operation\n    to \"g\" flag is soon to be phased out along with the\n    ability to choose the exact matching scheme. The choice of\n    matching scheme to use depends highly on the pattern kind and\n    can done automatically on case by case basis.\n\n    Returns: a $(D RegexMatch) object holding engine state after first match.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "match",
						"line": 784,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 789,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "match",
				"line": 784,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchFirst",
						"line": 816,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 821,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchFirst",
				"line": 816,
				"comment": "    Find the first (leftmost) slice of the $(D input) that\n    matches the pattern $(D re). This function picks the most suitable\n    regular expression engine depending on the pattern properties.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar/dchar) that contains a pattern in the form of\n        compiled  bytecode. )\n      $(LI StaticRegex!char (wchar/dchar) that contains a pattern in the form of\n        compiled native machine code. )\n    )\n\n    Returns:\n    $(LREF Captures) containing the extent of a match together with all submatches\n    if there was a match, otherwise an empty $(LREF Captures) object.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchFirst",
						"line": 824,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 829,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchFirst",
				"line": 824,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchAll",
						"line": 859,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 864,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchAll",
				"line": 859,
				"comment": "    Initiate a search for all non-overlapping matches to the pattern $(D re)\n    in the given $(D input). The result is a lazy range of matches generated\n    as they are encountered in the input going left to right.\n\n    This function picks the most suitable regular expression engine\n    depending on the pattern properties.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar/dchar) that contains a pattern in the form of\n        compiled  bytecode. )\n      $(LI StaticRegex!char (wchar/dchar) that contains a pattern in the form of\n        compiled native machine code. )\n    )\n\n    Returns:\n    $(LREF RegexMatch) object that represents matcher state\n    after the first match was found or an empty one if not present.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "matchAll",
						"line": 867,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 872,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "matchAll",
				"line": 867,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bmatch",
						"line": 939,
						"type": "(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 944,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "bmatch",
				"line": 939,
				"comment": "    Start matching of $(D input) to regex pattern $(D re),\n    using traditional $(LUCKY backtracking) matching scheme.\n\n    The use of this function is $(RED discouraged) - use either of\n    $(LREF matchAll) or $(LREF matchFirst).\n\n    Delegating  the kind of operation\n    to \"g\" flag is soon to be phased out along with the\n    ability to choose the exact matching scheme. The choice of\n    matching scheme to use depends highly on the pattern kind and\n    can done automatically on case by case basis.\n\n    Returns: a $(D RegexMatch) object holding engine\n    state after first match.\n\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(RegEx == Regex!(BasicElementOf!R))",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bmatch",
						"line": 947,
						"type": "(R input, String re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "String"
							}
						],
						"endline": 952,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "bmatch",
				"line": 947,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isSomeString!String",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirst",
						"line": 1053,
						"type": "R(R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1057,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replaceFirst",
				"line": 1053,
				"comment": "    Construct a new string from $(D input) by replacing the first match with\n    a string generated from it according to the $(D format) specifier.\n\n    To replace all matches use $(LREF replaceAll).\n\n    Params:\n    input = string to search\n    re = compiled regular expression to use\n    format = format string to generate replacements from,\n    see $(S_LINK Replace format string, the format string).\n\n    Returns:\n    A string of the same type with the first match (if any) replaced.\n    If no match is found returns the input string itself.\n\n    Example:\n    ---\n    assert(replaceFirst(\"noon\", regex(\"n\"), \"[$&]\") == \"[n]oon\");\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirst",
						"line": 1082,
						"type": "R(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1086,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replaceFirst",
				"line": 1082,
				"comment": "    This is a general replacement tool that construct a new string by replacing\n    matches of pattern $(D re) in the $(D input). Unlike the other overload\n    there is no format string instead captures are passed to\n    to a user-defined functor $(D fun) that returns a new string\n    to use as replacement.\n\n    This version replaces the first match in $(D input),\n    see $(LREF replaceAll) to replace the all of the matches.\n\n    Returns:\n    A new string of the same type as $(D input) with all matches\n    replaced by return values of $(D fun). If no matches found\n    returns the $(D input) itself.\n\n    Example:\n    ---\n    string list = \"#21 out of 46\";\n    string newList = replaceFirst!(cap => to!string(to!int(cap.hit)+1))\n        (list, regex(`[0-9]+`));\n    assert(newList == \"#22 out of 46\");\n    ---\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "replaceFirstInto",
						"line": 1109,
						"type": "@trusted void(ref Sink sink, R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1116,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceFirstInto",
				"line": 1109,
				"comment": "    A variation on $(LREF replaceFirst) that instead of allocating a new string\n    on each call outputs the result piece-wise to the $(D sink). In particular\n    this enables efficient construction of a final output incrementally.\n\n    Like in $(LREF replaceFirst) family of functions there is an overload\n    for the substitution guided by the $(D format) string\n    and the one with the user defined callback.\n\n    Example:\n    ---\n    import std.array;\n    string m1 = \"first message\\n\";\n    string m2 = \"second message\\n\";\n    auto result = appender!string();\n    replaceFirstInto(result, m1, regex(`([a-z]+) message`), \"$1\");\n    //equivalent of the above with user-defined callback\n    replaceFirstInto!(cap=>cap[1])(result, m2, regex(`([a-z]+) message`));\n    assert(result.data == \"first\\nsecond\\n\");\n    ---\n",
				"parameters": [
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirstInto",
						"line": 1119,
						"type": "@trusted void(Sink sink, R input, RegEx re)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1124,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceFirstInto",
				"line": 1119,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceAll",
						"line": 1169,
						"type": "@trusted R(R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1173,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "replaceAll",
				"line": 1169,
				"comment": "    Construct a new string from $(D input) by replacing all of the\n    fragments that match a pattern $(D re) with a string generated\n    from the match according to the $(D format) specifier.\n\n    To replace only the first match use $(LREF replaceFirst).\n\n    Params:\n    input = string to search\n    re = compiled regular expression to use\n    format = format string to generate replacements from,\n    see $(S_LINK Replace format string, the format string).\n\n    Returns:\n    A string of the same type as $(D input) with the all\n    of the matches (if any) replaced.\n    If no match is found returns the input string itself.\n\n    Example:\n    ---\n    // Comify a number\n    auto com = regex(r\"(?<=\\d)(?=(\\d\\d\\d)+\\b)\",\"g\");\n    assert(replaceAll(\"12000 + 42100 = 54100\", com, \",\") == \"12,000 + 42,100 = 54,100\");\n    ---\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceAll",
						"line": 1207,
						"type": "@trusted R(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1211,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "replaceAll",
				"line": 1207,
				"comment": "    This is a general replacement tool that construct a new string by replacing\n    matches of pattern $(D re) in the $(D input). Unlike the other overload\n    there is no format string instead captures are passed to\n    to a user-defined functor $(D fun) that returns a new string\n    to use as replacement.\n\n    This version replaces all of the matches found in $(D input),\n    see $(LREF replaceFirst) to replace the first match only.\n\n    Returns:\n    A new string of the same type as $(D input) with all matches\n    replaced by return values of $(D fun). If no matches found\n    returns the $(D input) itself.\n\n    Params:\n    input = string to search\n    re = compiled regular expression\n    fun = delegate to use\n\n    Example:\n    Capitalize the letters 'a' and 'r':\n    ---\n    string baz(Captures!(string) m)\n    {\n        return std.string.toUpper(m.hit);\n    }\n    auto s = replaceAll!(baz)(\"Strap a rocket engine on a chicken.\",\n            regex(\"[ar]\"));\n    assert(s == \"StRAp A Rocket engine on A chicken.\");\n    ---\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "replaceAllInto",
						"line": 1234,
						"type": "@trusted void(Sink sink, R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1241,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceAllInto",
				"line": 1234,
				"comment": "    A variation on $(LREF replaceAll) that instead of allocating a new string\n    on each call outputs the result piece-wise to the $(D sink). In particular\n    this enables efficient construction of a final output incrementally.\n\n    As with $(LREF replaceAll) there are 2 overloads - one with a format string,\n    the other one with a user defined functor.\n\n    Example:\n    ---\n    //swap all 3 letter words and bring it back\n    string text = \"How are you doing?\";\n    auto sink = appender!(char[])();\n    replaceAllInto!(cap => retro(cap[0]))(sink, text, regex(`\\b\\w{3}\\b`));\n    auto swapped = sink.data.dup; // make a copy explicitly\n    assert(swapped == \"woH era uoy doing?\");\n    sink.clear();\n    replaceAllInto!(cap => retro(cap[0]))(sink, swapped, regex(`\\b\\w{3}\\b`));\n    assert(sink.data == text);\n    ---\n",
				"parameters": [
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && is(C : dchar) && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceAllInto",
						"line": 1244,
						"type": "@trusted void(Sink sink, R input, RegEx re)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1249,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "replaceAllInto",
				"line": 1244,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, dchar) && isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 1313,
						"type": "R(R input, RegEx re, const(C)[] format)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							},
							{
								"name": "format",
								"type": "const(C)[]"
							}
						],
						"endline": 1317,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 1313,
				"comment": "    Old API for replacement, operation depends on flags of pattern $(D re).\n    With \"g\" flag it performs the equivalent of $(LREF replaceAll) otherwise it\n    works the same as $(LREF replaceFirst).\n\n    The use of this function is $(RED discouraged), please use $(LREF replaceAll)\n    or $(LREF replaceFirst) explicitly.\n",
				"parameters": [
					{
						"name": "scheme",
						"defaultAlias": "match",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 1320,
						"type": "R(R input, RegEx re)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "re",
								"type": "RegEx"
							}
						],
						"endline": 1324,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 1320,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R && isRegexFor!(RegEx, R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Splitter",
						"line": 1337,
						"members": [
							{
								"endchar": 5,
								"name": "front",
								"line": 1368,
								"comment": "Forward range primitives.\n",
								"type": "@property Range()",
								"endline": 1375,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 1378,
								"comment": "ditto\n",
								"type": "@property bool()",
								"endline": 1381,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 1384,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 1398,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 1401,
								"comment": "ditto\n",
								"type": "@property ()",
								"endline": 1404,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"char": 8,
						"kind": "struct"
					}
				],
				"name": "Splitter",
				"line": 1337,
				"comment": "Range that splits a string using a regular expression as a\nseparator.\n\nExample:\n----\nauto s1 = \", abc, de,  fg, hi, \";\nassert(equal(splitter(s1, regex(\", *\")),\n    [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"]));\n----\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"defaultAlias": "Regex",
						"kind": "alias"
					}
				],
				"constraint": "isSomeString!Range && isRegexFor!(RegEx, Range)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 1411,
						"type": "Splitter!(Range, RegEx)(Range r, RegEx pat)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "pat",
								"type": "RegEx"
							}
						],
						"endline": 1415,
						"char": 32,
						"kind": "function"
					}
				],
				"name": "splitter",
				"line": 1411,
				"comment": "    A helper function, creates a $(D Splitter) on range $(D r) separated by regex $(D pat).\n    Captured subexpressions have no effect on the resulting range.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "is(BasicElementOf!Range : dchar) && isRegexFor!(RegEx, Range)",
				"char": 32,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1418,
						"type": "@trusted String[](String input, RegEx rx)",
						"parameters": [
							{
								"name": "input",
								"type": "String"
							},
							{
								"name": "rx",
								"type": "RegEx"
							}
						],
						"endline": 1425,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "split",
				"line": 1418,
				"comment": "An eager version of $(D splitter) that creates an array with splitted slices of $(D input).\n",
				"parameters": [
					{
						"name": "String",
						"kind": "type"
					},
					{
						"name": "RegEx",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!String && isRegexFor!(RegEx, String)",
				"char": 26,
				"kind": "template"
			},
			{
				"name": "RegexException",
				"line": 1428,
				"comment": "Exception object thrown in case of errors during regex compilation.\n",
				"deco": "C3std5regex8internal2ir14RegexException",
				"char": 8,
				"kind": "alias"
			}
		],
		"comment": "  $(LUCKY Regular expressions) are a commonly used method of pattern matching\n  on strings, with $(I regex) being a catchy word for a pattern in this domain\n  specific language. Typical problems usually solved by regular expressions\n  include validation of user input and the ubiquitous find & replace\n  in text processing utilities.\n\n  $(SECTION Synopsis)\n  ---\n  import std.regex;\n  import std.stdio;\n  void main()\n  {\n      // Print out all possible dd/mm/yy(yy) dates found in user input.\n      auto r = regex(r\"\\b[0-9][0-9]?/[0-9][0-9]?/[0-9][0-9](?:[0-9][0-9])?\\b\");\n      foreach(line; stdin.byLine)\n      {\n        // matchAll() returns a range that can be iterated\n        // to get all subsequent matches.\n        foreach(c; matchAll(line, r))\n            writeln(c.hit);\n      }\n  }\n  ...\n\n  // Create a static regex at compile-time, which contains fast native code.\n  auto ctr = ctRegex!(`^.*/([^/]+)/?$`);\n\n  // It works just like a normal regex:\n  auto c2 = matchFirst(\"foo/bar\", ctr);   // First match found here, if any\n  assert(!c2.empty);   // Be sure to check if there is a match before examining contents!\n  assert(c2[1] == \"bar\");   // Captures is a range of submatches: 0 = full match.\n\n  ...\n\n  // The result of the $(D matchAll) is directly testable with if/assert/while.\n  // e.g. test if a string consists of letters:\n  assert(matchFirst(\"Letter\", `^\\p{L}+$`));\n\n\n  ---\n  $(SECTION Syntax and general information)\n  The general usage guideline is to keep regex complexity on the side of simplicity,\n  as its capabilities reside in purely character-level manipulation.\n  As such it's ill-suited for tasks involving higher level invariants\n  like matching an integer number $(U bounded) in an [a,b] interval.\n  Checks of this sort of are better addressed by additional post-processing.\n\n  The basic syntax shouldn't surprise experienced users of regular expressions.\n  For an introduction to $(D std.regex) see a\n  $(WEB dlang.org/regular-expression.html, short tour) of the module API\n  and its abilities.\n\n  There are other web resources on regular expressions to help newcomers,\n  and a good $(WEB www.regular-expressions.info, reference with tutorial)\n  can easily be found.\n\n  This library uses a remarkably common ECMAScript syntax flavor\n  with the following extensions:\n  $(UL\n    $(LI Named subexpressions, with Python syntax. )\n    $(LI Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.)\n    $(LI Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.)\n  )\n\n  $(REG_START Pattern syntax )\n  $(I std.regex operates on codepoint level,\n    'character' in this table denotes a single Unicode codepoint.)\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_TITLE Atoms, Match single characters )\n    $(REG_ROW any character except [{|*+?()^$, Matches the character itself. )\n    $(REG_ROW ., In single line mode matches any character.\n      Otherwise it matches any character except '\\n' and '\\r'. )\n    $(REG_ROW [class], Matches a single character\n      that belongs to this character class. )\n    $(REG_ROW [^class], Matches a single character that\n      does $(U not) belong to this character class.)\n    $(REG_ROW \\cC, Matches the control character corresponding to letter C)\n    $(REG_ROW \\xXX, Matches a character with hexadecimal value of XX. )\n    $(REG_ROW \\uXXXX, Matches a character  with hexadecimal value of XXXX. )\n    $(REG_ROW \\U00YYYYYY, Matches a character with hexadecimal value of YYYYYY. )\n    $(REG_ROW \\f, Matches a formfeed character. )\n    $(REG_ROW \\n, Matches a linefeed character. )\n    $(REG_ROW \\r, Matches a carriage return character. )\n    $(REG_ROW \\t, Matches a tab character. )\n    $(REG_ROW \\v, Matches a vertical tab character. )\n    $(REG_ROW \\d, Matches any Unicode digit. )\n    $(REG_ROW \\D, Matches any character except Unicode digits. )\n    $(REG_ROW \\w, Matches any word character (note: this includes numbers).)\n    $(REG_ROW \\W, Matches any non-word character.)\n    $(REG_ROW \\s, Matches whitespace, same as \\p{White_Space}.)\n    $(REG_ROW \\S, Matches any character except those recognized as $(I \\s ). )\n    $(REG_ROW \\\\, Matches \\ character. )\n    $(REG_ROW \\c where c is one of [|*+?(), Matches the character c itself. )\n    $(REG_ROW \\p{PropertyName}, Matches a character that belongs\n        to the Unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW  \\P{PropertyName}, Matches a character that does not belong\n        to the Unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW \\p{InBasicLatin}, Matches any character that is part of\n          the BasicLatin Unicode $(U block).)\n    $(REG_ROW \\P{InBasicLatin}, Matches any character except ones in\n          the BasicLatin Unicode $(U block).)\n    $(REG_ROW \\p{Cyrillic}, Matches any character that is part of\n        Cyrillic $(U script).)\n    $(REG_ROW \\P{Cyrillic}, Matches any character except ones in\n        Cyrillic $(U script).)\n    $(REG_TITLE Quantifiers, Specify repetition of other elements)\n    $(REG_ROW *, Matches previous character/subexpression 0 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW *?, Matches previous character/subexpression 0 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW +, Matches previous character/subexpression 1 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW +?, Matches previous character/subexpression 1 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW {n}, Matches previous character/subexpression exactly n times. )\n    $(REG_ROW {n&#44}, Matches previous character/subexpression n times or more.\n      Greedy version - tries as many times as possible. )\n    $(REG_ROW {n&#44}?, Matches previous character/subexpression n times or more.\n      Lazy version - stops as early as possible.)\n    $(REG_ROW {n&#44m}, Matches previous character/subexpression n to m times.\n      Greedy version - tries as many times as possible, but no more than m times. )\n    $(REG_ROW {n&#44m}?, Matches previous character/subexpression n to m times.\n      Lazy version - stops as early as possible, but no less then n times.)\n    $(REG_TITLE Other, Subexpressions & alternations )\n    $(REG_ROW (regex),  Matches subexpression regex,\n      saving matched portion of text for later retrieval. )\n    $(REG_ROW (?:regex), Matches subexpression regex,\n      $(U not) saving matched portion of text. Useful to speed up matching. )\n    $(REG_ROW A|B, Matches subexpression A, or failing that, matches B. )\n    $(REG_ROW (?P&lt;name&gt;regex), Matches named subexpression\n        regex labeling it with name 'name'.\n        When referring to a matched portion of text,\n        names work like aliases in addition to direct numbers.\n     )\n    $(REG_TITLE Assertions, Match position rather than character )\n    $(REG_ROW ^, Matches at the begining of input or line (in multiline mode).)\n    $(REG_ROW $, Matches at the end of input or line (in multiline mode). )\n    $(REG_ROW \\b, Matches at word boundary. )\n    $(REG_ROW \\B, Matches when $(U not) at word boundary. )\n    $(REG_ROW (?=regex), Zero-width lookahead assertion.\n        Matches at a point where the subexpression\n        regex could be matched starting from the current position.\n      )\n    $(REG_ROW (?!regex), Zero-width negative lookahead assertion.\n        Matches at a point where the subexpression\n        regex could $(U not) be matched starting from the current position.\n      )\n    $(REG_ROW (?<=regex), Zero-width lookbehind assertion. Matches at a point\n        where the subexpression regex could be matched ending\n        at the current position (matching goes backwards).\n      )\n    $(REG_ROW  (?<!regex), Zero-width negative lookbehind assertion.\n      Matches at a point where the subexpression regex could $(U not)\n      be matched ending at the current position (matching goes backwards).\n     )\n  )\n\n  $(REG_START Character classes )\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_ROW Any atom, Has the same meaning as outside of a character class.)\n    $(REG_ROW a-z, Includes characters a, b, c, ..., z. )\n    $(REG_ROW [a||b]&#44 [a--b]&#44 [a~~b]&#44 [a&&b], Where a, b are arbitrary classes,\n     means union, set difference, symmetric set difference, and intersection respectively.\n     $(I Any sequence of character class elements implicitly forms a union.) )\n  )\n\n  $(REG_START Regex flags )\n  $(REG_TABLE\n    $(REG_TITLE Flag, Semantics )\n    $(REG_ROW g, Global regex, repeat over the whole input. )\n    $(REG_ROW i, Case insensitive matching. )\n    $(REG_ROW m, Multi-line mode, match ^, $ on start and end line separators\n       as well as start and end of input.)\n    $(REG_ROW s, Single-line mode, makes . match '\\n' and '\\r' as well. )\n    $(REG_ROW x, Free-form syntax, ignores whitespace in pattern,\n      useful for formatting complex regular expressions. )\n  )\n\n  $(SECTION Unicode support)\n\n  This library provides full Level 1 support* according to\n    $(WEB unicode.org/reports/tr18/, UTS 18). Specifically:\n  $(UL\n    $(LI 1.1 Hex notation via any of \\uxxxx, \\U00YYYYYY, \\xZZ.)\n    $(LI 1.2 Unicode properties.)\n    $(LI 1.3 Character classes with set operations.)\n    $(LI 1.4 Word boundaries use the full set of \"word\" characters.)\n    $(LI 1.5 Using simple casefolding to match case\n        insensitively across the full range of codepoints.)\n    $(LI 1.6 Respecting line breaks as any of\n        \\u000A | \\u000B | \\u000C | \\u000D | \\u0085 | \\u2028 | \\u2029 | \\u000D\\u000A.)\n    $(LI 1.7 Operating on codepoint level.)\n  )\n  *With exception of point 1.1.1, as of yet, normalization of input\n    is expected to be enforced by user.\n\n    $(SECTION Replace format string)\n\n    A set of functions in this module that do the substitution rely\n    on a simple format to guide the process. In particular the table below\n    applies to the $(D format) argument of\n    $(LREF replaceFirst) and $(LREF replaceAll).\n\n    The format string can reference parts of match using the following notation.\n    $(REG_TABLE\n        $(REG_TITLE Format specifier, Replaced by )\n        $(REG_ROW $&amp;, the whole match. )\n        $(REG_ROW $(DOLLAR)$(BACKTICK), part of input $(I preceding) the match. )\n        $(REG_ROW $', part of input $(I following) the match. )\n        $(REG_ROW $$, '$' character. )\n        $(REG_ROW \\c &#44 where c is any character, the character c itself. )\n        $(REG_ROW \\\\, '\\' character. )\n        $(REG_ROW &#36;1 .. &#36;99, submatch number 1 to 99 respectively. )\n    )\n\n  $(SECTION Slicing and zero memory allocations orientation)\n\n  All matches returned by pattern matching functionality in this library\n    are slices of the original input. The notable exception is the $(D replace)\n    family of functions  that generate a new string from the input.\n\n    In cases where producing the replacement is the ultimate goal\n    $(LREF replaceFirstInto) and $(LREF replaceAllInto) could come in handy\n    as functions that  avoid allocations even for replacement.\n\n    Copyright: Copyright Dmitry Olshansky, 2011-\n\n  License: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n  Authors: Dmitry Olshansky,\n\n    API and utility constructs are modeled after the original $(D std.regex)\n  by Walter Bright and Andrei Alexandrescu.\n\n  Source: $(PHOBOSSRC std/regex/_package.d)\n\nMacros:\n    REG_ROW = $(TR $(TD $(I $1 )) $(TD $+) )\n    REG_TITLE = $(TR $(TD $(B $1)) $(TD $(B $2)) )\n    REG_TABLE = <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\" > $0 </table>\n    REG_START = <h3><div align=\"center\"> $0 </div></h3>\n    SECTION = <h3><a id=\"$1\">$0</a></h3>\n    S_LINK = <a href=\"#$1\">$+</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/demangle.d",
		"name": "std.demangle",
		"members": [
			{
				"endchar": 1,
				"name": "demangle",
				"line": 85,
				"comment": " Demangle D mangled names.\n\n If it is not a D mangled name, it returns its argument name.\n Example:\n        This program reads standard in and writes it to standard out,\n        pretty-printing any found D mangled names.\n-------------------\nimport core.stdc.stdio : stdin;\nimport std.stdio;\nimport std.ascii;\nimport std.demangle;\n\nvoid test(int x, float y) { }\n\nint main()\n{\n    string buffer;\n    bool inword;\n    int c;\n\n    writefln(\"Try typing in: %s\", test.mangleof);\n    while ((c = fgetc(stdin)) != EOF)\n    {\n        if (inword)\n        {\n            if (c == '_' || isAlphaNum(c))\n                buffer ~= cast(char) c;\n            else\n            {\n                inword = false;\n                write(demangle(buffer), cast(char) c);\n            }\n        }\n        else\n        {   if (c == '_' || isAlpha(c))\n            {\n                inword = true;\n                buffer.length = 0;\n                buffer ~= cast(char) c;\n            }\n            else\n                write(cast(char) c);\n        }\n    }\n    if (inword)\n        write(demangle(buffer));\n    return 0;\n}\n-------------------\n",
				"deco": "FAyaZAya",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"endline": 91,
				"char": 8,
				"kind": "function"
			}
		],
		"comment": " Demangle D mangled names.\n\n Macros:\n  WIKI = Phobos/StdDemangle\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Thomas K$(UUML)hne, Frits van Bommel\n Source:    $(PHOBOSSRC std/_demangle.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/system.d",
		"name": "std.system",
		"members": [
			{
				"members": [
					{
						"name": "win32",
						"line": 32,
						"value": "1",
						"comment": "Microsoft 32 bit Windows systems\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "win64",
						"line": 33,
						"value": "2",
						"comment": "Microsoft 64 bit Windows systems\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "linux",
						"line": 34,
						"value": "3",
						"comment": "All Linux Systems\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "osx",
						"line": 35,
						"value": "4",
						"comment": "Mac OS X\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "freeBSD",
						"line": 36,
						"value": "5",
						"comment": "FreeBSD\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "solaris",
						"line": 37,
						"value": "6",
						"comment": "Solaris\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "android",
						"line": 38,
						"value": "7",
						"comment": "Android\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "otherPosix",
						"line": 39,
						"value": "8",
						"comment": "Other Posix Systems\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "OS",
				"line": 30,
				"comment": "        Operating system.\n\n        Note:\n            This is for cases where you need a value representing the OS at\n            runtime. If you're doing something which should compile differently\n            on different OSes, then please use $(D version(Windows)),\n            $(D version(linux)), etc.\n\n        See_Also:\n            <a href=\"../version.html#PredefinedVersions\">Predefined Versions</a>\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "os",
				"line": 46,
				"comment": "The OS that the program was compiled for.\n",
				"deco": "yE3std6system2OS",
				"originalType": "OS",
				"init": "cast(OS)3",
				"char": 30,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"members": [
					{
						"name": "bigEndian",
						"line": 67,
						"value": "0",
						"comment": "Big endian byte order\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "littleEndian",
						"line": 68,
						"value": "1",
						"comment": "Little endian byte order\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "Endian",
				"line": 65,
				"comment": "        Byte order endianness.\n\n        Note:\n            This is intended for cases where you need to deal with endianness at\n            runtime. If you're doing something which should compile differently\n            depending on whether you're compiling on a big endian or little\n            endian machine, then please use $(D version(BigEndian)) and\n            $(D version(LittleEndian)).\n\n        See_Also:\n            <a href=\"../version.html#PredefinedVersions\">Predefined Versions</a>\n",
				"baseDeco": "i",
				"char": 5,
				"kind": "enum"
			},
			{
				"name": "endian",
				"line": 72,
				"comment": "The endianness that the program was compiled for.\n",
				"deco": "yE3std6system6Endian",
				"originalType": "Endian",
				"init": "cast(Endian)1",
				"char": 34,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			}
		],
		"comment": " Information about the target operating system, environment, and CPU.\n\n Macros:\n      WIKI = Phobos/StdSystem\n\n  Copyright: Copyright Digital Mars 2000 - 2011\n  License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n  Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n  Source:    $(PHOBOSSRC std/_system.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/typetuple.d",
		"name": "std.typetuple",
		"members": [
			{
				"name": "TypeTuple",
				"line": 16,
				"comment": " Alternate name for $(LREF AliasSeq) for legacy compatibility.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL19_1630)\n---\nimport std.typetuple;\nalias TL = TypeTuple!(int, double);\n\nint foo(TL td)  // same as int foo(int, double);\n{\n    return td[0] + cast(int)td[1];\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL19_1630)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL31_1631)\n---\nalias TL = TypeTuple!(int, double);\n\nalias Types = TypeTuple!(TL, char);\nstatic assert(is(Types == TypeTuple!(int, double, char)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL31_1631)\n",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " This module was renamed to disambiguate the term tuple, use $(DDLINK std_meta, std.meta, std.meta) instead.\n\n Copyright: Copyright Digital Mars 2005 - 2015.\n License: $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:\n Source:    $(PHOBOSSRC std/_typetuple.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/json.d",
		"name": "std.json",
		"members": [
			{
				"members": [
					{
						"name": "nan",
						"line": 66,
						"value": "\"NaN\"",
						"comment": "string representation of floating-point NaN\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "inf",
						"line": 67,
						"value": "\"Infinite\"",
						"comment": "string representation of floating-point Infinity\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "negativeInf",
						"line": 68,
						"value": "\"-Infinite\"",
						"comment": "string representation of floating-point negative Infinity\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "JSONFloatLiteral",
				"line": 64,
				"comment": "String literals used to represent special float values within JSON strings.\n",
				"baseDeco": "Aya",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 75,
						"value": "0",
						"comment": "standard parsing\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "specialFloatLiterals",
						"line": 76,
						"value": "1",
						"comment": "encode NaN and Inf float values as strings\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "JSONOptions",
				"line": 74,
				"comment": "Flags that control how json is encoded and parsed.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "NULL",
						"line": 85,
						"value": "cast(byte)0",
						"comment": "Indicates the type of a $(D JSONValue).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "STRING",
						"line": 86,
						"value": "1",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "INTEGER",
						"line": 87,
						"value": "2",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "UINTEGER",
						"line": 88,
						"value": "3",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "FLOAT",
						"line": 89,
						"value": "4",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "OBJECT",
						"line": 90,
						"value": "5",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ARRAY",
						"line": 91,
						"value": "6",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "TRUE",
						"line": 92,
						"value": "7",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "FALSE",
						"line": 93,
						"value": "8",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "JSON_TYPE",
				"line": 82,
				"comment": "JSON type enumeration\n",
				"baseDeco": "g",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "JSONValue",
				"line": 99,
				"comment": "JSON value node\n",
				"members": [
					{
						"endchar": 5,
						"name": "type",
						"line": 118,
						"comment": "      Returns the JSON_TYPE of the value stored in this structure.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL123_1632)\n---\nstring s = \"{ \\\"language\\\": \\\"D\\\" }\";\nJSONValue j = parseJSON(s);\nassert(j.type == JSON_TYPE.OBJECT);\nassert(j[\"language\"].type == JSON_TYPE.STRING);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL123_1632)\n",
						"deco": "xFNaNbNdNiNfZE3std4json9JSON_TYPE",
						"endline": 121,
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "type",
						"line": 139,
						"comment": "        $(RED Deprecated. Instead, please assign the value with the adequate\n              type to $(D JSONValue) directly. This will be removed in\n              June 2015.)\n\n        Sets the _type of this $(D JSONValue). Previous content is cleared.\n",
						"deco": "FNdE3std4json9JSON_TYPEZE3std4json9JSON_TYPE",
						"parameters": [
							{
								"name": "newType",
								"deco": "E3std4json9JSON_TYPE"
							}
						],
						"endline": 172,
						"char": 25,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "str",
						"line": 176,
						"comment": "Value getter/setter for $(D JSON_TYPE.STRING).\n\nThrows $(D JSONException) for read access if $(D type) is not $(D JSON_TYPE.STRING).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL189_1633)\n---\nJSONValue j = [ \"language\": \"D\" ];\n\n// get value\nassert(j[\"language\"].str == \"D\");\n\n// change existing key to new string\nj[\"language\"].str = \"Perl\";\nassert(j[\"language\"].str == \"Perl\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL189_1633)\n",
						"deco": "NgFNaNdZNgAya",
						"endline": 181,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "str",
						"line": 183,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiAyaZAya",
						"parameters": [
							{
								"name": "v",
								"deco": "Aya"
							}
						],
						"endline": 187,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "integer",
						"line": 203,
						"comment": "Value getter/setter for $(D JSON_TYPE.INTEGER).\n\nThrows $(D JSONException) for read access if $(D type) is not $(D JSON_TYPE.INTEGER).\n",
						"deco": "NgFNaNdNfZNgl",
						"endline": 208,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "integer",
						"line": 210,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiNflZl",
						"parameters": [
							{
								"name": "v",
								"deco": "l"
							}
						],
						"endline": 214,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "uinteger",
						"line": 218,
						"comment": "Value getter/setter for $(D JSON_TYPE.UINTEGER).\n\nThrows $(D JSONException) for read access if $(D type) is not $(D JSON_TYPE.UINTEGER).\n",
						"deco": "NgFNaNdNfZNgm",
						"endline": 223,
						"char": 28,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "uinteger",
						"line": 225,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiNfmZm",
						"parameters": [
							{
								"name": "v",
								"deco": "m"
							}
						],
						"endline": 229,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "floating",
						"line": 233,
						"comment": "Value getter/setter for $(D JSON_TYPE.FLOAT).\n\nThrows $(D JSONException) for read access if $(D type) is not $(D JSON_TYPE.FLOAT).\n",
						"deco": "NgFNaNdNfZNgd",
						"endline": 238,
						"char": 29,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "floating",
						"line": 240,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiNfdZd",
						"parameters": [
							{
								"name": "v",
								"deco": "d"
							}
						],
						"endline": 244,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "object",
						"line": 248,
						"comment": "Value getter/setter for $(D JSON_TYPE.OBJECT).\n\nThrows $(D JSONException) for read access if $(D type) is not $(D JSON_TYPE.OBJECT).\n",
						"deco": "NgFNaNcNdZNgHAyaS3std4json9JSONValue",
						"endline": 253,
						"char": 44,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "object",
						"line": 255,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiHAyaS3std4json9JSONValueZHAyaS3std4json9JSONValue",
						"parameters": [
							{
								"name": "v",
								"deco": "HAyaS3std4json9JSONValue"
							}
						],
						"endline": 259,
						"char": 33,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "array",
						"line": 263,
						"comment": "Value getter/setter for $(D JSON_TYPE.ARRAY).\n\nThrows $(D JSONException) for read access if $(D type) is not $(D JSON_TYPE.ARRAY).\n",
						"deco": "NgFNaNcNdZNgAS3std4json9JSONValue",
						"endline": 268,
						"char": 38,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "array",
						"line": 270,
						"comment": "ditto\n",
						"deco": "FNaNbNdNiAS3std4json9JSONValueZAS3std4json9JSONValue",
						"parameters": [
							{
								"name": "v",
								"deco": "AS3std4json9JSONValue"
							}
						],
						"endline": 274,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isNull",
						"line": 277,
						"comment": "Test whether the type is $(D JSON_TYPE.NULL)\n",
						"deco": "xFNaNbNdNiNfZb",
						"endline": 280,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 381,
								"type": "(T arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "T"
									}
								],
								"endline": 384,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 381,
						"comment": " Constructor for $(D JSONValue). If $(D arg) is a $(D JSONValue)\n its value and type will be copied to the new $(D JSONValue).\n Note that this is a shallow copy: if type is $(D JSON_TYPE.OBJECT)\n or $(D JSON_TYPE.ARRAY) then only the reference to the data will\n be copied.\n Otherwise, $(D arg) must be implicitly convertible to one of the\n following types: $(D typeof(null)), $(D string), $(D ulong),\n $(D long), $(D double), an associative array $(D V[K]) for any $(D V)\n and $(D K) i.e. a JSON object, any array or $(D bool). The type will\n be set accordingly.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL397_1634)\n---\nJSONValue j = JSONValue( \"a string\" );\nj = JSONValue(42);\n\nj = JSONValue( [1, 2, 3] );\nassert(j.type == JSON_TYPE.ARRAY);\n\nj = JSONValue( [\"language\": \"D\"] );\nassert(j.type == JSON_TYPE.OBJECT);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL397_1634)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "!isStaticArray!T",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 386,
								"type": "(ref T arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "T",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 389,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 386,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isStaticArray!T",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 391,
								"type": "inout (inout T arg)",
								"parameters": [
									{
										"name": "arg",
										"type": "T",
										"storageClass": [
											"inout"
										]
									}
								],
								"endline": 395,
								"char": 5,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 391,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "T",
								"deco": "S3std4json9JSONValue",
								"kind": "type"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 421,
						"comment": "Array syntax for json arrays.\n\nThrows $(D JSONException) if $(D type) is not $(D JSON_TYPE.ARRAY).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL430_1635)\n---\nJSONValue j = JSONValue( [42, 43, 44] );\nassert( j[0].integer == 42 );\nassert( j[1].integer == 43 );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL430_1635)\n",
						"deco": "NgFNaNcmZNgS3std4json9JSONValue",
						"parameters": [
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 428,
						"originalType": "inout pure ref inout(JSONValue)(size_t i)",
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 439,
						"comment": "Hash syntax for json objects.\n\nThrows $(D JSONException) if $(D type) is not $(D JSON_TYPE.OBJECT).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL447_1636)\n---\nJSONValue j = JSONValue( [\"language\": \"D\"] );\nassert( j[\"language\"].str == \"D\" );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL447_1636)\n",
						"deco": "NgFNaNcAyaZNgS3std4json9JSONValue",
						"parameters": [
							{
								"name": "k",
								"deco": "Aya"
							}
						],
						"endline": 445,
						"char": 26,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opIndexAssign",
								"line": 458,
								"type": "pure void(auto ref T value, string key)",
								"parameters": [
									{
										"name": "value",
										"type": "T",
										"storageClass": [
											"auto",
											"ref"
										]
									},
									{
										"name": "key",
										"type": "string"
									}
								],
								"endline": 467,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opIndexAssign",
						"line": 458,
						"comment": "Operator sets $(D value) for element of JSON object by $(D key)\n\nIf JSON value is null, then operator initializes it with object and then\n\nsets $(D value) for it.\n\nThrows $(D JSONException) if $(D type) is not $(D JSON_TYPE.OBJECT)\n\nor $(D JSON_TYPE.NULL).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL469_1637)\n---\nJSONValue j = JSONValue( [\"language\": \"D\"] );\nj[\"language\"].str = \"Perl\";\nassert( j[\"language\"].str == \"Perl\" );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL469_1637)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL485_1638)\n---\nJSONValue j = JSONValue( [\"Perl\", \"C\"] );\nj[1].str = \"D\";\nassert( j[1].str == \"D\" );\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL485_1638)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL543_1639)\n---\nJSONValue j = [ \"language\": \"D\", \"author\": \"walter\" ];\nstring a = (\"author\" in j).str;\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL543_1639)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 582,
						"comment": "Implements the foreach $(D opApply) interface for json arrays.\n",
						"deco": "FDFmKS3std4json9JSONValueZiZi",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFmKS3std4json9JSONValueZi"
							}
						],
						"endline": 596,
						"originalType": "int(int delegate(size_t index, ref JSONValue) dg)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 599,
						"comment": "Implements the foreach $(D opApply) interface for json objects.\n",
						"deco": "FDFAyaKS3std4json9JSONValueZiZi",
						"parameters": [
							{
								"name": "dg",
								"deco": "DFAyaKS3std4json9JSONValueZi"
							}
						],
						"endline": 613,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 617,
						"comment": "Implicitly calls $(D toJSON) on this JSONValue.\n\n$(I options) can be used to tweak the conversion behavior.\n",
						"deco": "xFxE3std4json11JSONOptionsZAya",
						"parameters": [
							{
								"name": "options",
								"deco": "xE3std4json11JSONOptions",
								"default": "cast(JSONOptions)0"
							}
						],
						"endline": 620,
						"originalType": "const string(in JSONOptions options = JSONOptions.none)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toPrettyString",
						"line": 625,
						"comment": "Implicitly calls $(D toJSON) on this JSONValue, like $(D toString), but\n\nalso passes $(I true) as $(I pretty) argument.\n\n$(I options) can be used to tweak the conversion behavior\n",
						"deco": "xFxE3std4json11JSONOptionsZAya",
						"parameters": [
							{
								"name": "options",
								"deco": "xE3std4json11JSONOptions",
								"default": "cast(JSONOptions)0"
							}
						],
						"endline": 628,
						"originalType": "const string(in JSONOptions options = JSONOptions.none)",
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseJSON",
						"line": 639,
						"type": "JSONValue(T json, int maxDepth = -1, JSONOptions options = JSONOptions.none)",
						"parameters": [
							{
								"name": "json",
								"type": "T"
							},
							{
								"name": "maxDepth",
								"deco": "i",
								"default": "-1"
							},
							{
								"name": "options",
								"type": "JSONOptions",
								"default": "JSONOptions.none"
							}
						],
						"endline": 959,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "parseJSON",
				"line": 639,
				"comment": "Parses a serialized string and returns a tree of JSON values.\nThrows a $(XREF json,JSONException) if the depth exceeds the max depth.\nParams:\n    json = json-formatted string to parse\n    maxDepth = maximum depth of nesting allowed, -1 disables depth checking\n    options = enable decoding string representations of NaN/Inf as float values\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!T",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseJSON",
						"line": 968,
						"type": "JSONValue(T json, JSONOptions options)",
						"parameters": [
							{
								"name": "json",
								"type": "T"
							},
							{
								"name": "options",
								"type": "JSONOptions"
							}
						],
						"endline": 972,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "parseJSON",
				"line": 968,
				"comment": "Parses a serialized string and returns a tree of JSON values.\nThrows a $(XREF json,JSONException) if the depth exceeds the max depth.\nParams:\n    json = json-formatted string to parse\n    options = enable decoding string representations of NaN/Inf as float values\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!T",
				"char": 11,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "toJSON",
				"line": 983,
				"comment": "Takes a tree of JSON values and returns the serialized string.\n\nAny Object types will be serialized in a key-sorted order.\n\nIf $(D pretty) is false no whitespaces are generated.\nIf $(D pretty) is true serialized string is formatted to be human-readable.\nSet the $(specialFloatLiterals) flag is set in $(D options) to encode NaN/Infinity as strings.\n",
				"deco": "FxPS3std4json9JSONValuexbxE3std4json11JSONOptionsZAya",
				"parameters": [
					{
						"name": "root",
						"deco": "xPS3std4json9JSONValue"
					},
					{
						"name": "pretty",
						"deco": "xb",
						"default": "false"
					},
					{
						"name": "options",
						"deco": "xE3std4json11JSONOptions",
						"default": "cast(JSONOptions)0"
					}
				],
				"endline": 1148,
				"originalType": "string(in JSONValue* root, in bool pretty = false, in JSONOptions options = JSONOptions.none)",
				"char": 8,
				"kind": "function"
			},
			{
				"members": [],
				"name": "JSONException",
				"line": 1163,
				"comment": "Exception thrown on JSON errors\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "JavaScript Object Notation\n\nSynopsis:\n----\n    //parse a file or string of json into a usable structure\n    string s = \"{ \\\"language\\\": \\\"D\\\", \\\"rating\\\": 3.14, \\\"code\\\": \\\"42\\\" }\";\n    JSONValue j = parseJSON(s);\n    writeln(\"Language: \", j[\"language\"].str(),\n            \" Rating: \", j[\"rating\"].floating()\n    );\n\n    // j and j[\"language\"] return JSONValue,\n    // j[\"language\"].str returns a string\n\n    //check a type\n    long x;\n    if (j[\"code\"].type() == JSON_TYPE.INTEGER)\n    {\n        x = j[\"code\"].integer;\n    }\n    else\n    {\n        x = to!int(j[\"code\"].str);\n    }\n\n    // create a json struct\n    JSONValue jj = [ \"language\": \"D\" ];\n    // rating doesnt exist yet, so use .object to assign\n    jj.object[\"rating\"] = JSONValue(3.14);\n    // create an array to assign to list\n    jj.object[\"list\"] = JSONValue( [\"a\", \"b\", \"c\"] );\n    // list already exists, so .object optional\n    jj[\"list\"].array ~= JSONValue(\"D\");\n\n    s = j.toString();\n    writeln(s);\n----\n\nCopyright: Copyright Jeremie Pelletier 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   Jeremie Pelletier, David Herberth\nReferences: $(LINK http://json.org/)\nSource:    $(PHOBOSSRC std/_json.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/stdio.d",
		"name": "std.stdio",
		"members": [
			{
				"name": "KeepTerminator",
				"line": 31,
				"comment": "If flag $(D KeepTerminator) is set to $(D KeepTerminator.yes), then the delimiter\nis included in the strings returned.\n",
				"deco": "E3std8typecons45__T4FlagVAyaa14_6b6565705465726d696e61746f72Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "File",
				"line": 336,
				"comment": "Encapsulates a $(D FILE*). Generally D does not attempt to provide\nthin wrappers over equivalent functions in the C standard library, but\nmanipulating $(D FILE*) values directly is unsafe and error-prone in\nmany ways. The $(D File) type ensures safe manipulation, automatic\nfile closing, and a lot of convenience.\n\nThe underlying $(D FILE*) handle is maintained in a reference-counted\nmanner, such that as soon as the last $(D File) variable bound to a\ngiven $(D FILE*) goes out of scope, the underlying $(D FILE*) is\nautomatically closed.\n\nBugs:\n$(D File) expects file names to be encoded in $(B CP_ACP) on $(I Windows)\ninstead of UTF-8 ($(BUGZILLA 7648)) thus must not be used in $(I Windows)\nor cross-platform applications other than with an immediate ASCII string as\na file name to prevent accidental changes to result in incorrect behavior.\nOne can use $(XREF file, read)/$(XREF file, write)/$(XREF stream, _File)\ninstead.\n\nExample:\n----\n// test.d\nvoid main(string args[])\n{\n    auto f = File(\"test.txt\", \"w\"); // open for writing\n    f.write(\"Hello\");\n    if (args.length > 1)\n    {\n        auto g = f; // now g and f write to the same file\n                    // internal reference count is 2\n        g.write(\", \", args[1]);\n        // g exits scope, reference count decreases to 1\n    }\n    f.writeln(\"!\");\n    // f exits scope, reference count falls to zero,\n    // underlying $(D FILE*) is closed.\n}\n----\n<pre class=console>\n% rdmd test.d Jimmy\n% cat test.txt\nHello, Jimmy!\n% __\n</pre>\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 380,
						"comment": "Constructor taking the name of the file to open and the open mode\n(with the same semantics as in the C standard library $(WEB\ncplusplus.com/reference/clibrary/cstdio/fopen.html, fopen)\nfunction).\n\nCopying one $(D File) object to another results in the two $(D File)\nobjects referring to the same underlying file.\n\nThe destructor automatically closes the file as soon as no $(D File)\nobject refers to it anymore.\n\nThrows: $(D ErrnoException) if the file could not be opened.\n",
						"deco": "FNcNfAyaxAaZS3std5stdio4File",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"rb\""
							}
						],
						"endline": 403,
						"originalType": "ref @safe (string name, in char[] stdioOpenmode = \"rb\")",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opAssign",
						"line": 422,
						"comment": "Assigns a file to another. The target of the assignment gets detached\nfrom whatever file it was attached to, and attaches itself to the new\nfile.\n",
						"deco": "FNfS3std5stdio4FileZv",
						"parameters": [
							{
								"name": "rhs",
								"deco": "S3std5stdio4File"
							}
						],
						"endline": 427,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "open",
						"line": 437,
						"comment": "First calls $(D detach) (throwing on failure), and then attempts to\n_open file $(D name) with mode $(D stdioOpenmode). The mode has the\nsame semantics as in the C standard library $(WEB\ncplusplus.com/reference/clibrary/cstdio/fopen.html, fopen) function.\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FNfAyaxAaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"rb\""
							}
						],
						"endline": 441,
						"originalType": "@safe void(string name, in char[] stdioOpenmode = \"rb\")",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "popen",
						"line": 450,
						"comment": "First calls $(D detach) (throwing on failure), and then runs a command\nby calling the C standard library function $(WEB\nopengroup.org/onlinepubs/007908799/xsh/_popen.html, _popen).\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FNfAyaxAaZv",
						"parameters": [
							{
								"name": "command",
								"deco": "Aya"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"r\""
							}
						],
						"endline": 458,
						"originalType": "@safe void(string command, in char[] stdioOpenmode = \"r\")",
						"char": 25,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fdopen",
						"line": 467,
						"comment": "First calls $(D detach) (throwing on failure), and then attempts to\nassociate the given file descriptor with the $(D File). The mode must\nbe compatible with the mode of the file descriptor.\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FNfixAaZv",
						"parameters": [
							{
								"name": "fd",
								"deco": "i"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa",
								"default": "\"rb\""
							}
						],
						"endline": 470,
						"originalType": "@safe void(int fd, in char[] stdioOpenmode = \"rb\")",
						"char": 10,
						"kind": "function"
					},
					{
						"name": "windowsHandleOpen",
						"line": 521,
						"comment": "First calls $(D detach) (throwing on failure), and then attempts to\nassociate the given Windows $(D HANDLE) with the $(D File). The mode must\nbe compatible with the access attributes of the handle. Windows only.\n\nThrows: $(D ErrnoException) in case of error.\n",
						"deco": "FixAaZv",
						"parameters": [
							{
								"name": "handle",
								"deco": "i"
							},
							{
								"name": "stdioOpenmode",
								"deco": "xAa"
							}
						],
						"originalType": "void(HANDLE handle, in char[] stdioOpenmode)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isOpen",
						"line": 557,
						"comment": " Returns $(D true) if the file is opened.\n",
						"deco": "xFNaNbNdNfZb",
						"endline": 560,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "eof",
						"line": 568,
						"comment": "Returns $(D true) if the file is at end (see $(WEB\ncplusplus.com/reference/clibrary/cstdio/feof.html, feof)).\n\nThrows: $(D Exception) if the file is not opened.\n",
						"deco": "xFNaNdNeZb",
						"endline": 574,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "name",
						"line": 579,
						"comment": " Returns the name of the last opened file, if any.\nIf a $(D File) was created with $(LREF tmpfile) and $(LREF wrapFile)\nit has no name.\n",
						"deco": "xFNaNbNdNfZAya",
						"endline": 582,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "error",
						"line": 589,
						"comment": "If the file is not opened, returns $(D false). Otherwise, returns\n$(WEB cplusplus.com/reference/clibrary/cstdio/ferror.html, ferror) for\nthe file handle.\n",
						"deco": "xFNaNbNdNeZb",
						"endline": 592,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "detach",
						"line": 611,
						"comment": "Detaches from the underlying file. If the sole owner, calls $(D close).\n\nThrows: $(D ErrnoException) on failure if closing the file.\n",
						"deco": "FNfZv",
						"endline": 622,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "close",
						"line": 650,
						"comment": "If the file was unopened, succeeds vacuously. Otherwise closes the\nfile (by calling $(WEB\ncplusplus.com/reference/clibrary/cstdio/fclose.html, fclose)),\nthrowing on error. Even if an exception is thrown, afterwards the $(D\nFile) object is empty. This is different from $(D detach) in that it\nalways closes the file; consequently, all other $(D File) objects\nreferring to the same handle will see a closed file henceforth.\n\nThrows: $(D ErrnoException) on error.\n",
						"deco": "FNeZv",
						"endline": 683,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearerr",
						"line": 690,
						"comment": "If the file is not opened, succeeds vacuously. Otherwise, returns\n$(WEB cplusplus.com/reference/clibrary/cstdio/_clearerr.html,\n_clearerr) for the file handle.\n",
						"deco": "FNaNbNfZv",
						"endline": 694,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "flush",
						"line": 704,
						"comment": "Flushes the C $(D FILE) buffers.\n\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/_fflush.html, _fflush)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened or if the call to $(D fflush) fails.\n",
						"deco": "FNeZv",
						"endline": 710,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sync",
						"line": 738,
						"comment": "Forces any data buffered by the OS to be written to disk.\nCall $(LREF flush) before calling this function to flush the C $(D FILE) buffers first.\n\nThis function calls\n$(WEB msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx,\n$(D FlushFileBuffers)) on Windows and\n$(WEB pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html,\n$(D fsync)) on POSIX for the file handle.\n\nThrows: $(D Exception) if the file is not opened or if the OS call fails.\n",
						"deco": "FNeZv",
						"endline": 751,
						"char": 10,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "rawRead",
								"line": 767,
								"type": "T[](T[] buffer)",
								"parameters": [
									{
										"name": "buffer",
										"type": "T[]"
									}
								],
								"endline": 797,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "rawRead",
						"line": 767,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/fread.html, fread) for the\nfile handle. The number of items to read and the size of\neach item is inferred from the size and type of the input array, respectively.\n\nReturns: The slice of $(D buffer) containing the data that was actually read.\nThis will be shorter than $(D buffer) if EOF was reached before the buffer\ncould be filled.\n\nThrows: $(D Exception) if $(D buffer) is empty.\n        $(D ErrnoException) if the file is not opened or the call to $(D fread) fails.\n\n$(D rawRead) always reads in binary mode on Windows.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "rawWrite",
								"line": 826,
								"type": "void(in T[] buffer)",
								"parameters": [
									{
										"name": "buffer",
										"type": "T[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 855,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "rawWrite",
						"line": 826,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/fwrite.html, fwrite) for the file\nhandle. The number of items to write and the size of each\nitem is inferred from the size and type of the input array, respectively. An\nerror is thrown if the buffer could not be written in its entirety.\n\n$(D rawWrite) always writes in binary mode on Windows.\n\nThrows: $(D ErrnoException) if the file is not opened or if the call to $(D fwrite) fails.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "seek",
						"line": 876,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/fseek.html, fseek)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D fseek) fails.\n",
						"deco": "FNeliZv",
						"parameters": [
							{
								"name": "offset",
								"deco": "l"
							},
							{
								"name": "origin",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 894,
						"originalType": "@trusted void(long offset, int origin = SEEK_SET)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "tell",
						"line": 935,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/ftell.html, ftell) for the\nmanaged file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D ftell) fails.\n",
						"deco": "xFNdNeZm",
						"endline": 952,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "rewind",
						"line": 974,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/_rewind.html, _rewind)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n",
						"deco": "FNfZv",
						"endline": 980,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setvbuf",
						"line": 989,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/_setvbuf.html, _setvbuf) for\nthe file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D setvbuf) fails.\n",
						"deco": "FNemiZv",
						"parameters": [
							{
								"name": "size",
								"deco": "m"
							},
							{
								"name": "mode",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 996,
						"originalType": "@trusted void(size_t size, int mode = _IOFBF)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setvbuf",
						"line": 1005,
						"comment": "Calls $(WEB cplusplus.com/reference/clibrary/cstdio/_setvbuf.html,\n_setvbuf) for the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $(D setvbuf) fails.\n",
						"deco": "FNeAviZv",
						"parameters": [
							{
								"name": "buf",
								"deco": "Av"
							},
							{
								"name": "mode",
								"deco": "i",
								"default": "0"
							}
						],
						"endline": 1013,
						"originalType": "@trusted void(void[] buf, int mode = _IOFBF)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "lock",
						"line": 1077,
						"comment": "Locks the specified file segment. If the file segment is already locked\nby another process, waits until the existing lock is released.\nIf both $(D start) and $(D length) are zero, the entire file is locked.\n\nLocks created using $(D lock) and $(D tryLock) have the following properties:\n$(UL\n $(LI All locks are automatically released when the process terminates.)\n $(LI Locks are not inherited by child processes.)\n $(LI Closing a file will release all locks associated with the file. On POSIX,\n      even locks acquired via a different $(D File) will be released as well.)\n $(LI Not all NFS implementations correctly implement file locking.)\n)\n",
						"deco": "FE3std5stdio8LockTypemmZv",
						"parameters": [
							{
								"name": "lockType",
								"deco": "E3std5stdio8LockType",
								"default": "cast(LockType)1"
							},
							{
								"name": "start",
								"deco": "m",
								"default": "0LU"
							},
							{
								"name": "length",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 1101,
						"originalType": "void(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "tryLock",
						"line": 1109,
						"comment": "Attempts to lock the specified file segment.\nIf both $(D start) and $(D length) are zero, the entire file is locked.\nReturns: $(D true) if the lock was successful, and $(D false) if the\nspecified file segment was already locked.\n",
						"deco": "FE3std5stdio8LockTypemmZb",
						"parameters": [
							{
								"name": "lockType",
								"deco": "E3std5stdio8LockType",
								"default": "cast(LockType)1"
							},
							{
								"name": "start",
								"deco": "m",
								"default": "0LU"
							},
							{
								"name": "length",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 1142,
						"originalType": "bool(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "unlock",
						"line": 1147,
						"comment": "Removes the lock over the specified file segment.\n",
						"deco": "FmmZv",
						"parameters": [
							{
								"name": "start",
								"deco": "m",
								"default": "0LU"
							},
							{
								"name": "length",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 1166,
						"originalType": "void(ulong start = 0, ulong length = 0)",
						"char": 10,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "write",
								"line": 1251,
								"type": "void(S args)",
								"parameters": [
									{
										"name": "args",
										"type": "S"
									}
								],
								"endline": 1292,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "write",
						"line": 1251,
						"comment": "Writes its arguments in text format to the file.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "S",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writeln",
								"line": 1300,
								"type": "void(S args)",
								"parameters": [
									{
										"name": "args",
										"type": "S"
									}
								],
								"endline": 1303,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writeln",
						"line": 1300,
						"comment": "Writes its arguments in text format to the file, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "S",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writef",
								"line": 1312,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 1317,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writef",
						"line": 1312,
						"comment": "Writes its arguments in text format to the file, according to the\nformat in the first argument.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writefln",
								"line": 1326,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 1333,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writefln",
						"line": 1326,
						"comment": "Writes its arguments in text format to the file, according to the\nformat in the first argument, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readln",
								"line": 1368,
								"type": "S(dchar terminator = '\\x0a')",
								"parameters": [
									{
										"name": "terminator",
										"deco": "w",
										"default": "'\\x0a'"
									}
								],
								"endline": 1374,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "readln",
						"line": 1368,
						"comment": "Read line from the file handle and return it as a specified type.\n\nThis version manages its own read buffer, which means one memory allocation per call. If you are not\nretaining a reference to the read data, consider the $(D File.readln(buf)) version, which may offer\nbetter performance as it can reuse its read buffer.\n\nParams:\n    S = Template parameter; the type of the allocated buffer, and the type returned. Defaults to $(D string).\n    terminator = Line terminator (by default, $(D '\\n')).\n\nNote:\n    String terminators are not supported due to ambiguity with readln(buf) below.\n\nReturns:\n    The line that was read, including the line terminator character.\n\nThrows:\n    $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode conversion error.\n\nExample:\n---\n// Reads $(D stdin) and writes it to $(D stdout).\nimport std.stdio;\n\nvoid main()\n{\n    string line;\n    while ((line = stdin.readln()) !is null)\n        write(line);\n}\n---\n",
						"parameters": [
							{
								"name": "S",
								"default": "string",
								"kind": "type"
							}
						],
						"constraint": "isSomeString!S",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readln",
								"line": 1467,
								"type": "size_t(ref C[] buf, dchar terminator = '\\x0a')",
								"parameters": [
									{
										"name": "buf",
										"type": "C[]",
										"storageClass": [
											"ref"
										]
									},
									{
										"name": "terminator",
										"deco": "w",
										"default": "'\\x0a'"
									}
								],
								"endline": 1496,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "readln",
						"line": 1467,
						"comment": "Read line from the file handle and write it to $(D buf[]), including\nterminating character.\n\nThis can be faster than $(D line = File.readln()) because you can reuse\nthe buffer for each call. Note that reusing the buffer means that you\nmust copy the previous contents if you wish to retain them.\n\nParams:\nbuf = Buffer used to store the resulting line data. buf is\nresized as necessary.\nterminator = Line terminator (by default, $(D '\\n')). Use\n$(XREF ascii, newline) for portability (unless the file was opened in\ntext mode).\n\nReturns:\n0 for end of file, otherwise number of characters read\n\nThrows: $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode\nconversion error.\n\nExample:\n---\n// Read lines from $(D stdin) into a string\n// Ignore lines starting with '#'\n// Write the string to $(D stdout)\n\nvoid main()\n{\n    string output;\n    char[] buf;\n\n    while (stdin.readln(buf))\n    {\n        if (buf[0] == '#')\n            continue;\n\n        output ~= buf;\n    }\n\n    write(output);\n}\n---\n\nThis method can be more efficient than the one in the previous example\nbecause $(D stdin.readln(buf)) reuses (if possible) memory allocated\nfor $(D buf), whereas $(D line = stdin.readln()) makes a new memory allocation\nfor every line.\n",
						"parameters": [
							{
								"name": "C",
								"kind": "type"
							}
						],
						"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readln",
								"line": 1499,
								"type": "size_t(ref C[] buf, R terminator)",
								"parameters": [
									{
										"name": "buf",
										"type": "C[]",
										"storageClass": [
											"ref"
										]
									},
									{
										"name": "terminator",
										"type": "R"
									}
								],
								"endline": 1521,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "readln",
						"line": 1499,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "C",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum) && isBidirectionalRange!R && is(typeof(terminator.front == (dchar).init))",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "readf",
								"line": 1551,
								"type": "uint(in char[] format, Data data)",
								"parameters": [
									{
										"name": "format",
										"type": "char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "data",
										"type": "Data"
									}
								],
								"endline": 1558,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "readf",
						"line": 1551,
						"comment": " Read data from the file according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n",
						"parameters": [
							{
								"name": "Data",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "tmpfile",
						"line": 1584,
						"comment": " Returns a temporary file by calling $(WEB\n cplusplus.com/reference/clibrary/cstdio/_tmpfile.html, _tmpfile).\n Note that the created file has no $(LREF name).\n",
						"deco": "FNfZS3std5stdio4File",
						"endline": 1591,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "wrapFile",
						"line": 1597,
						"comment": "Unsafe function that wraps an existing $(D FILE*). The resulting $(D\nFile) never takes the initiative in closing the file.\nNote that the created file has no $(LREF name)\n",
						"deco": "FNfPOS4core4stdc5stdio8_IO_FILEZS3std5stdio4File",
						"parameters": [
							{
								"name": "f",
								"deco": "POS4core4stdc5stdio8_IO_FILE"
							}
						],
						"endline": 1603,
						"originalType": "@safe File(FILE* f)",
						"char": 29,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "getFP",
						"line": 1608,
						"comment": "Returns the $(D FILE*) corresponding to this object.\n",
						"deco": "FNaNfZPOS4core4stdc5stdio8_IO_FILE",
						"endline": 1615,
						"originalType": "pure @safe FILE*()",
						"char": 11,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fileno",
						"line": 1626,
						"comment": "Returns the file number corresponding to this object.\n",
						"deco": "xFNdNeZi",
						"endline": 1632,
						"char": 38,
						"kind": "function"
					},
					{
						"name": "windowsHandle",
						"line": 1638,
						"comment": "Returns the underlying operating system $(D HANDLE) (Windows only).\n",
						"deco": "FNdZi",
						"originalType": "@property HANDLE()",
						"char": 22,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLine",
								"line": 1819,
								"type": "(KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a')",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator",
										"default": "KeepTerminator.no"
									},
									{
										"name": "terminator",
										"type": "Terminator",
										"default": "'\\x0a'"
									}
								],
								"endline": 1825,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLine",
						"line": 1819,
						"comment": "Returns an input range set up to read from the file handle one line\nat a time.\n\nThe element type for the range will be $(D Char[]). Range primitives\nmay throw $(D StdioException) on I/O error.\n\nNote:\nEach $(D front) will not persist after $(D\npopFront) is called, so the caller must copy its contents (e.g. by\ncalling $(D to!string)) when retention is needed. If the caller needs\nto retain a copy of every line, use the $(LREF byLineCopy) function\ninstead.\n\nParams:\nChar = Character type for each line, defaulting to $(D char).\nkeepTerminator = Use $(D KeepTerminator.yes) to include the\nterminator at the end of each line.\nterminator = Line separator ($(D '\\n') by default). Use\n$(XREF ascii, newline) for portability (unless the file was opened in\ntext mode).\n\nExample:\n----\nimport std.algorithm, std.stdio, std.string;\n// Count words in a file using ranges.\nvoid main()\n{\n    auto file = File(\"file.txt\"); // Open for reading\n    const wordCount = file.byLine()            // Read lines\n                          .map!split           // Split into words\n                          .map!(a => a.length) // Count words per line\n                          .sum();              // Total word count\n    writeln(wordCount);\n}\n----\n\nExample:\n----\nimport std.range, std.stdio;\n// Read lines using foreach.\nvoid main()\n{\n    auto file = File(\"file.txt\"); // Open for reading\n    auto range = file.byLine();\n    // Print first three lines\n    foreach (line; range.take(3))\n        writeln(line);\n    // Print remaining lines beginning with '#'\n    foreach (line; range)\n    {\n        if (!line.empty && line[0] == '#')\n            writeln(line);\n    }\n}\n----\nNotice that neither example accesses the line data returned by\n$(D front) after the corresponding $(D popFront) call is made (because\nthe contents may well have changed).\n",
						"parameters": [
							{
								"defaultDeco": "a",
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "a",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "isScalarType!Terminator",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLine",
								"line": 1828,
								"type": "(KeepTerminator keepTerminator, Terminator terminator)",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator"
									},
									{
										"name": "terminator",
										"type": "Terminator"
									}
								],
								"endline": 1833,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLine",
						"line": 1828,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "a",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!(ElementEncodingType!Terminator) == Char)",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLineCopy",
								"line": 1956,
								"type": "(KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a')",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator",
										"default": "KeepTerminator.no"
									},
									{
										"name": "terminator",
										"type": "Terminator",
										"default": "'\\x0a'"
									}
								],
								"endline": 1962,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLineCopy",
						"line": 1956,
						"comment": "Returns an input range set up to read from the file handle one line\nat a time. Each line will be newly allocated. $(D front) will cache\nits value to allow repeated calls without unnecessary allocations.\n\nNote: Due to caching byLineCopy can be more memory-efficient than\n$(D File.byLine.map!idup).\n\nThe element type for the range will be $(D Char[]). Range\nprimitives may throw $(D StdioException) on I/O error.\n\nParams:\nChar = Character type for each line, defaulting to $(D immutable char).\nkeepTerminator = Use $(D KeepTerminator.yes) to include the\nterminator at the end of each line.\nterminator = Line separator ($(D '\\n') by default). Use\n$(XREF ascii, newline) for portability (unless the file was opened in\ntext mode).\n\nExample:\n----\nimport std.algorithm, std.array, std.stdio;\n// Print sorted lines of a file.\nvoid main()\n{\n    auto sortedLines = File(\"file.txt\")   // Open for reading\n                       .byLineCopy()      // Read persistent lines\n                       .array()           // into an array\n                       .sort();           // then sort them\n    foreach (line; sortedLines)\n        writeln(line);\n}\n----\nSee_Also:\n$(XREF file,readText)\n",
						"parameters": [
							{
								"defaultDeco": "a",
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "ya",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "isScalarType!Terminator",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "byLineCopy",
								"line": 1965,
								"type": "(KeepTerminator keepTerminator, Terminator terminator)",
								"parameters": [
									{
										"name": "keepTerminator",
										"type": "KeepTerminator"
									},
									{
										"name": "terminator",
										"type": "Terminator"
									}
								],
								"endline": 1970,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "byLineCopy",
						"line": 1965,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Terminator",
								"kind": "type"
							},
							{
								"defaultDeco": "ya",
								"name": "Char",
								"kind": "type"
							}
						],
						"constraint": "is(Unqual!(ElementEncodingType!Terminator) == Unqual!Char)",
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "byChunk",
						"line": 2293,
						"comment": "Returns an input range set up to read from the file handle a chunk at a\ntime.\n\nThe element type for the range will be $(D ubyte[]). Range primitives\nmay throw $(D StdioException) on I/O error.\n\nExample:\n---------\nvoid main()\n{\n    // Read standard input 4KB at a time\n    foreach (ubyte[] buffer; stdin.byChunk(4096))\n    {\n        ... use buffer ...\n    }\n}\n---------\n\nThe parameter may be a number (as shown in the example above) dictating the\nsize of each chunk. Alternatively, $(D byChunk) accepts a\nuser-provided buffer that it uses directly.\n\nExample:\n---------\nvoid main()\n{\n    // Read standard input 4KB at a time\n    foreach (ubyte[] buffer; stdin.byChunk(new ubyte[4096]))\n    {\n        ... use buffer ...\n    }\n}\n---------\n\nIn either case, the content of the buffer is reused across calls. That means\n$(D front) will not persist after $(D popFront) is called, so if retention is\nneeded, the caller must copy its contents (e.g. by calling $(D buffer.dup)).\n\nIn the  example above, $(D buffer.length) is 4096 for all iterations, except\nfor the last one, in which case $(D buffer.length) may be less than 4096 (but\nalways greater than zero).\n\nWith the mentioned limitations, $(D byChunks) works with any algorithm\ncompatible with input ranges.\n\nExample:\n---\n// Efficient file copy, 1MB at a time.\nimport std.algorithm, std.stdio;\nvoid main()\n{\n    stdin.byChunk(1024 * 1024).copy(stdout.lockingTextWriter());\n}\n---\n\n$(XREF_PACK algorithm,iteration,joiner) can be used to join chunks together into\na single range lazily.\nExample:\n---\nimport std.algorithm, std.stdio;\nvoid main()\n{\n    //Range of ranges\n    static assert(is(typeof(stdin.byChunk(4096).front) == ubyte[]));\n    //Range of elements\n    static assert(is(typeof(stdin.byChunk(4096).joiner.front) == ubyte));\n}\n---\n\nReturns: A call to $(D byChunk) returns a range initialized with the $(D File)\nobject and the appropriate buffer.\n\nThrows: If the user-provided size is zero or the user-provided buffer\nis empty, throws an $(D Exception). In case of an I/O error throws\n$(D StdioException).\n",
						"deco": "FmZS3std5stdio4File7ByChunk",
						"parameters": [
							{
								"name": "chunkSize",
								"deco": "m"
							}
						],
						"endline": 2296,
						"originalType": "(size_t chunkSize)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "byChunk",
						"line": 2298,
						"comment": "Ditto\n",
						"deco": "FAhZS3std5stdio4File7ByChunk",
						"parameters": [
							{
								"name": "buffer",
								"deco": "Ah"
							}
						],
						"endline": 2301,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "lockingTextWriter",
						"line": 2536,
						"comment": " Returns an output range that locks the file and allows fast writing to it.\n\nSee $(LREF byChunk) for an example.\n",
						"deco": "FNfZS3std5stdio4File17LockingTextWriter",
						"endline": 2539,
						"originalType": "@safe ()",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "size",
						"line": 2542,
						"comment": "Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.\n",
						"deco": "FNdNfZm",
						"endline": 2551,
						"char": 21,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "read",
						"line": 2735,
						"value": "0",
						"comment": "Specifies a _read (shared) lock. A _read lock denies all processes\n\nwrite access to the specified region of the file, including the\n\nprocess that first locks the region. All processes can _read the\n\nlocked region. Multiple simultaneous _read locks are allowed, as\n\nlong as there are no exclusive locks.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "readWrite",
						"line": 2740,
						"value": "1",
						"comment": "Specifies a read/write (exclusive) lock. A read/write lock denies all\n\nother processes both read and write access to the locked file region.\n\nIf a segment has an exclusive lock, it may not have any shared locks\n\nor other exclusive locks.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "LockType",
				"line": 2728,
				"comment": "Used to specify the lock type for $(D File.lock) and $(D File.tryLock).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "isFileHandle",
						"line": 2920,
						"init": "is(T : FILE*) || is(T : File)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFileHandle",
				"line": 2918,
				"comment": " Indicates whether $(D T) is a file handle of some kind.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "isStreamingDevice",
				"line": 2935,
				"comment": " $(RED Deprecated. Please use $(D isFileHandle) instead. This alias will be\n       removed in June 2015.)\n",
				"storageClass": [
					"deprecated"
				],
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "write",
						"line": 2950,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 2953,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "write",
				"line": 2950,
				"comment": "For each argument $(D arg) in $(D args), format the argument (as per\n$(LINK2 std_conv.html, to!(string)(arg))) and write the resulting\nstring to $(D args[0]). A call without any arguments will fail to\ncompile.\n\nThrows: In case of an I/O error, throws an $(D StdioException).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "!is(T[0] : File)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "writeln",
						"line": 2986,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3021,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "writeln",
				"line": 2986,
				"comment": " Equivalent to $(D write(args, '\\n')).  Calling $(D writeln) without\n arguments is valid and just prints a newline to the standard\n output.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "writef",
						"line": 3161,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3164,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "writef",
				"line": 3161,
				"comment": "Writes formatted data to standard output (without a trailing newline).\n\nParams:\nargs = The first argument $(D args[0]) should be the format string, specifying\nhow to format the rest of the arguments. For a full description of the syntax\nof the format string and how it controls the formatting of the rest of the\narguments, please refer to the documentation for $(XREF format,\nformattedWrite).\n\nNote: In older versions of Phobos, it used to be possible to write:\n\n------\nwritef(stderr, \"%s\", \"message\");\n------\n\nto print a message to $(D stderr). This syntax is no longer supported, and has\nbeen superceded by:\n\n------\nstderr.writef(\"%s\", \"message\");\n------\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "writefln",
						"line": 3192,
						"type": "void(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 3195,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "writefln",
				"line": 3192,
				"comment": " Equivalent to $(D writef(args, '\\n')).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readf",
						"line": 3242,
						"type": "uint(in char[] format, A args)",
						"parameters": [
							{
								"name": "format",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "args",
								"type": "A"
							}
						],
						"endline": 3245,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "readf",
				"line": 3242,
				"comment": " Read data from $(D stdin) according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n",
				"parameters": [
					{
						"name": "A",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readln",
						"line": 3287,
						"type": "S(dchar terminator = '\\x0a')",
						"parameters": [
							{
								"name": "terminator",
								"deco": "w",
								"default": "'\\x0a'"
							}
						],
						"endline": 3291,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "readln",
				"line": 3287,
				"comment": " Read line from $(D stdin).\n\n This version manages its own read buffer, which means one memory allocation per call. If you are not\n retaining a reference to the read data, consider the $(D readln(buf)) version, which may offer\n better performance as it can reuse its read buffer.\n\n Returns:\n        The line that was read, including the line terminator character.\n Params:\n        S = Template parameter; the type of the allocated buffer, and the type returned. Defaults to $(D string).\n        terminator = Line terminator (by default, $(D '\\n')).\n Note:\n        String terminators are not supported due to ambiguity with readln(buf) below.\n Throws:\n        $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode conversion error.\n Example:\n        Reads $(D stdin) and writes it to $(D stdout).\n---\nimport std.stdio;\n\nvoid main()\n{\n    string line;\n    while ((line = readln()) !is null)\n        write(line);\n}\n---\n",
				"parameters": [
					{
						"name": "S",
						"default": "string",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readln",
						"line": 3321,
						"type": "size_t(ref C[] buf, dchar terminator = '\\x0a')",
						"parameters": [
							{
								"name": "buf",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "terminator",
								"deco": "w",
								"default": "'\\x0a'"
							}
						],
						"endline": 3325,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "readln",
				"line": 3321,
				"comment": " Read line from $(D stdin) and write it to buf[], including terminating character.\n\n This can be faster than $(D line = readln()) because you can reuse\n the buffer for each call. Note that reusing the buffer means that you\n must copy the previous contents if you wish to retain them.\n\n Returns:\n        $(D size_t) 0 for end of file, otherwise number of characters read\n Params:\n        buf = Buffer used to store the resulting line data. buf is resized as necessary.\n        terminator = Line terminator (by default, $(D '\\n')). Use $(XREF ascii, newline)\n        for portability (unless the file was opened in text mode).\n Throws:\n        $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode conversion error.\n Example:\n        Reads $(D stdin) and writes it to $(D stdout).\n---\nimport std.stdio;\n\nvoid main()\n{\n    char[] buf;\n    while (readln(buf))\n        write(buf);\n}\n---\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "readln",
						"line": 3328,
						"type": "size_t(ref C[] buf, R terminator)",
						"parameters": [
							{
								"name": "buf",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "terminator",
								"type": "R"
							}
						],
						"endline": 3333,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "readln",
				"line": 3328,
				"comment": " ditto\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C && is(Unqual!C == C) && !is(C == enum) && isBidirectionalRange!R && is(typeof(terminator.front == (dchar).init))",
				"char": 8,
				"kind": "template"
			},
			{
				"endchar": 5,
				"name": "popen",
				"line": 3399,
				"comment": " Convenience function that forwards to $(D core.sys.posix.stdio.popen)\n with appropriately-constructed C-style strings.\n",
				"deco": "FNbNiNexAaxAaZPOS4core4stdc5stdio8_IO_FILE",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "mode",
						"deco": "xAa",
						"default": "\"r\""
					}
				],
				"endline": 3405,
				"originalType": "nothrow @nogc @trusted FILE*(in char[] name, in char[] mode = \"r\")",
				"char": 11,
				"kind": "function"
			},
			{
				"name": "lines",
				"line": 3466,
				"comment": " Iterates through the lines of a file by using $(D foreach).\n\n Example:\n\n---------\nvoid main()\n{\n  foreach (string line; lines(stdin))\n  {\n    ... use line ...\n  }\n}\n---------\nThe line terminator ($(D '\\n') by default) is part of the string read (it\ncould be missing in the last line of the file). Several types are\nsupported for $(D line), and the behavior of $(D lines)\nchanges accordingly:\n\n$(OL $(LI If $(D line) has type $(D string), $(D\nwstring), or $(D dstring), a new string of the respective type\nis allocated every read.) $(LI If $(D line) has type $(D\nchar[]), $(D wchar[]), $(D dchar[]), the line's content\nwill be reused (overwritten) across reads.) $(LI If $(D line)\nhas type $(D immutable(ubyte)[]), the behavior is similar to\ncase (1), except that no UTF checking is attempted upon input.) $(LI\nIf $(D line) has type $(D ubyte[]), the behavior is\nsimilar to case (2), except that no UTF checking is attempted upon\ninput.))\n\nIn all cases, a two-symbols versions is also accepted, in which case\nthe first symbol (of integral type, e.g. $(D ulong) or $(D\nuint)) tracks the zero-based number of the current line.\n\nExample:\n----\n  foreach (ulong i, string line; lines(stdin))\n  {\n    ... use line ...\n  }\n----\n\n In case of an I/O error, an $(D StdioException) is thrown.\n\nSee_Also:\n$(LREF byLine)\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3478,
						"comment": "    Constructor.\n    Params:\n    f = File to read lines from.\n    terminator = Line separator ($(D '\\n') by default).\n",
						"deco": "FNcS3std5stdio4FilewZS3std5stdio5lines",
						"parameters": [
							{
								"name": "f",
								"deco": "S3std5stdio4File"
							},
							{
								"name": "terminator",
								"deco": "w",
								"default": "'\\x0a'"
							}
						],
						"endline": 3482,
						"originalType": "ref (File f, dchar terminator = '\\x0a')",
						"char": 5,
						"kind": "constructor"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "chunks",
				"line": 3730,
				"comment": "Iterates through a file a chunk at a time by using $(D foreach).\n\nExample:\n\n---------\nvoid main()\n{\n    foreach (ubyte[] buffer; chunks(stdin, 4096))\n    {\n        ... use buffer ...\n    }\n}\n---------\n\nThe content of $(D buffer) is reused across calls. In the\n example above, $(D buffer.length) is 4096 for all iterations,\n except for the last one, in which case $(D buffer.length) may\n be less than 4096 (but always greater than zero).\n\n In case of an I/O error, an $(D StdioException) is thrown.\n",
				"deco": "FS3std5stdio4FilemZS3std5stdio10ChunksImpl",
				"parameters": [
					{
						"name": "f",
						"deco": "S3std5stdio4File"
					},
					{
						"name": "size",
						"deco": "m"
					}
				],
				"endline": 3733,
				"originalType": "(File f, size_t size)",
				"char": 6,
				"kind": "function",
				"storageClass": [
					"auto"
				]
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "errno",
						"line": 3833,
						"comment": "Operating system error code.\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 3838,
						"comment": "Initialize with a message and an error code.\n",
						"deco": "FAyakZC3std5stdio14StdioException",
						"parameters": [
							{
								"name": "message",
								"deco": "Aya"
							},
							{
								"name": "e",
								"deco": "k",
								"default": "cast(uint)errno()"
							}
						],
						"endline": 3869,
						"originalType": "(string message, uint e = core.stdc.errno.errno)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCall",
						"line": 3872,
						"comment": " Convenience functions that throw an $(D StdioException).\n",
						"deco": "FAyaZv",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							}
						],
						"endline": 3875,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "opCall",
						"line": 3878,
						"comment": "ditto\n",
						"deco": "FZv",
						"endline": 3881,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					}
				],
				"name": "StdioException",
				"line": 3829,
				"comment": " Thrown if I/O errors happen.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "stdin",
				"line": 3906,
				"comment": " The standard input stream.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3908_1692)\n---\n// Read stdin, sort lines, write to stdout\nimport std.stdio, std.array, std.algorithm : sort, copy;\n\nvoid main() {\n    stdin                       // read from stdin\n    .byLineCopy(KeepTerminator.yes) // copying each line\n    .array()                    // convert to array of lines\n    .sort()                     // sort the lines\n    .copy(                      // copy output of .sort to an OutputRange\n        stdout.lockingTextWriter()); // the OutputRange\n}\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3908_1692)\n",
				"deco": "S3std5stdio4File",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"name": "stdout",
				"line": 3923,
				"comment": "The standard output stream.\n",
				"deco": "S3std5stdio4File",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"name": "stderr",
				"line": 3924,
				"comment": "The standard error stream.\n",
				"deco": "S3std5stdio4File",
				"char": 10,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"endchar": 5,
				"name": "openNetwork",
				"line": 4351,
				"comment": " Experimental network access via the File interface\n\n        Opens a TCP connection to the given host and port, then returns\n        a File struct with read and write access through the same interface\n        as any other file (meaning writef and the byLine ranges work!).\n\n        Authors:\n                Adam D. Ruppe\n\n        Bugs:\n                Only works on Linux\n",
				"deco": "FAyatZS3std5stdio4File",
				"parameters": [
					{
						"name": "host",
						"deco": "Aya"
					},
					{
						"name": "port",
						"deco": "t"
					}
				],
				"endline": 4389,
				"char": 10,
				"kind": "function"
			}
		],
		"comment": "Standard I/O functions that extend $(B core.stdc.stdio).  $(B core.stdc.stdio)\nis $(D_PARAM public)ally imported when importing $(B std.stdio).\n\nSource: $(PHOBOSSRC std/_stdio.d)\nMacros:\nWIKI=Phobos/StdStdio\n\nCopyright: Copyright Digital Mars 2007-.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Alex RÃ¸nne Petersen\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/meta.d",
		"name": "std.meta",
		"members": [
			{
				"members": [
					{
						"name": "AliasSeq",
						"line": 39,
						"type": "TList",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "AliasSeq",
				"line": 37,
				"comment": " Creates a sequence of zero or more aliases. This is most commonly\n used as template parameters or arguments.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL43_1694)\n---\nimport std.meta;\nalias TL = AliasSeq!(int, double);\n\nint foo(TL td)  // same as int foo(int, double);\n{\n    return td[0] + cast(int)td[1];\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL43_1694)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL55_1695)\n---\nalias TL = AliasSeq!(int, double);\n\nalias Types = AliasSeq!(TL, char);\nstatic assert(is(Types == AliasSeq!(int, double, char)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL55_1695)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "staticIndexOf",
						"line": 70,
						"init": "genericIndexOf!(T, TList).index",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "staticIndexOf",
				"line": 68,
				"comment": " Returns the index of the first occurrence of type T in the\n sequence of zero or more types TList.\n If not found, -1 is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL80_1696)\n---\nimport std.stdio;\n\nvoid foo()\n{\n    writefln(\"The index of long is %s\",\n             staticIndexOf!(long, AliasSeq!(int, long, double)));\n    // prints: The index of long is 1\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL80_1696)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "staticIndexOf",
						"line": 76,
						"init": "genericIndexOf!(T, TList).index",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "staticIndexOf",
				"line": 74,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "IndexOf",
				"line": 143,
				"comment": "Kept for backwards compatibility\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "Erase",
						"line": 151,
						"type": "GenericErase!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Erase",
				"line": 149,
				"comment": " Returns a typetuple created from TList with the first occurrence,\n if any, of T removed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL161_1698)\n---\nalias Types = AliasSeq!(int, long, double, char);\nalias TL = Erase!(long, Types);\nstatic assert(is(TL == AliasSeq!(int, double, char)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL161_1698)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Erase",
						"line": 157,
						"type": "GenericErase!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Erase",
				"line": 155,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "EraseAll",
						"line": 209,
						"type": "GenericEraseAll!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "EraseAll",
				"line": 207,
				"comment": " Returns a typetuple created from TList with the all occurrences,\n if any, of T removed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL219_1700)\n---\nalias Types = AliasSeq!(int, long, long, int);\n\nalias TL = EraseAll!(long, Types);\nstatic assert(is(TL == AliasSeq!(int, int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL219_1700)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "EraseAll",
						"line": 215,
						"type": "GenericEraseAll!(T, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "EraseAll",
				"line": 213,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "NoDuplicates",
				"line": 267,
				"comment": " Returns a typetuple created from TList with the all duplicate\n types removed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL277_1702)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = NoDuplicates!(Types);\nstatic assert(is(TL == AliasSeq!(int, long, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL277_1702)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 300,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 298,
				"comment": " Returns a typetuple created from TList with the first occurrence\n of type T, if found, replaced with type U.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL322_1704)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = Replace!(long, char, Types);\nstatic assert(is(TL == AliasSeq!(int, char, long, int, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL322_1704)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 306,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 304,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 312,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 310,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Replace",
						"line": 318,
						"type": "GenericReplace!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Replace",
				"line": 316,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 380,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 378,
				"comment": " Returns a typetuple created from TList with all occurrences\n of type T, if found, replaced with type U.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL402_1706)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = ReplaceAll!(long, char, Types);\nstatic assert(is(TL == AliasSeq!(int, char, char, int, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL402_1706)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 386,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 384,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 392,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 390,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ReplaceAll",
						"line": 398,
						"type": "GenericReplaceAll!(T, U, TList).result",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ReplaceAll",
				"line": 396,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					},
					{
						"name": "U",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Reverse",
				"line": 457,
				"comment": " Returns a typetuple created from TList with the order reversed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL473_1708)\n---\nalias Types = AliasSeq!(int, long, long, int, float);\n\nalias TL = Reverse!(Types);\nstatic assert(is(TL == AliasSeq!(float, int, long, long, int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL473_1708)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "MostDerived",
				"line": 485,
				"comment": " Returns the type from TList that is the most derived from type T.\n If none are found, T is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL496_1709)\n---\nclass A { }\nclass B : A { }\nclass C : B { }\nalias Types = AliasSeq!(A, C, B);\n\nMostDerived!(Object, Types) x;  // x is declared as type C\nstatic assert(is(typeof(x) == C));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL496_1709)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "DerivedToFront",
				"line": 511,
				"comment": " Returns the typetuple TList with the types sorted so that the most\n derived types come first.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL524_1710)\n---\nclass A { }\nclass B : A { }\nclass C : B { }\nalias Types = AliasSeq!(A, C, B);\n\nalias TL = DerivedToFront!(Types);\nstatic assert(is(TL == AliasSeq!(C, B, A)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL524_1710)\n",
				"parameters": [
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "staticMap",
				"line": 538,
				"comment": "Evaluates to $(D AliasSeq!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL558_1711)\n---\nimport std.traits : Unqual;\nalias TL = staticMap!(Unqual, int, const int, immutable int);\nstatic assert(is(TL == AliasSeq!(int, int, int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL558_1711)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "allSatisfy",
				"line": 588,
				"comment": "Tests whether all given items satisfy a template predicate, i.e. evaluates to\n$(D F!(T[0]) && F!(T[1]) && ... && F!(T[$ - 1])).\n\nEvaluation is $(I not) short-circuited if a false result is encountered; the\ntemplate predicate must be instantiable with all the given items.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL607_1713)\n---\nimport std.traits : isIntegral;\n\nstatic assert(!allSatisfy!(isIntegral, int, double));\nstatic assert( allSatisfy!(isIntegral, int, long));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL607_1713)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "anySatisfy",
				"line": 622,
				"comment": "Tests whether any given items satisfy a template predicate, i.e. evaluates to\n$(D F!(T[0]) || F!(T[1]) || ... || F!(T[$ - 1])).\n\nEvaluation is $(I not) short-circuited if a true result is encountered; the\ntemplate predicate must be instantiable with all the given items.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL641_1714)\n---\nimport std.traits : isIntegral;\n\nstatic assert(!anySatisfy!(isIntegral, string, double));\nstatic assert( anySatisfy!(isIntegral, int, double));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL641_1714)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Filter",
				"line": 654,
				"comment": " Filters an $(D AliasSeq) using a template predicate. Returns a\n $(D AliasSeq) of the elements which satisfy the predicate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL677_1715)\n---\nimport std.traits : isNarrowString, isUnsigned;\n\nalias Types1 = AliasSeq!(string, wstring, dchar[], char[], dstring, int);\nalias TL1 = Filter!(isNarrowString, Types1);\nstatic assert(is(TL1 == AliasSeq!(string, wstring, char[])));\n\nalias Types2 = AliasSeq!(int, byte, ubyte, dstring, dchar, uint, ulong);\nalias TL2 = Filter!(isUnsigned, Types2);\nstatic assert(is(TL2 == AliasSeq!(ubyte, uint, ulong)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL677_1715)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "TList",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"name": "templateNot",
								"line": 724,
								"init": "!pred!T",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							}
						],
						"name": "templateNot",
						"line": 724,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "templateNot",
				"line": 722,
				"comment": " Negates the passed template predicate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL728_1717)\n---\nimport std.traits : isPointer;\n\nalias isNoPointer = templateNot!isPointer;\nstatic assert(!isNoPointer!(int*));\nstatic assert(allSatisfy!(isNoPointer, string, char, float));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL728_1717)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [],
						"name": "templateAnd",
						"line": 758,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					}
				],
				"name": "templateAnd",
				"line": 756,
				"comment": " Combines several template predicates using logical AND, i.e. constructs a new\n predicate which evaluates to true for a given input T if and only if all of\n the passed predicates are true for T.\n\n The predicates are evaluated from left to right, aborting evaluation in a\n short-cut manner if a false result is encountered, in which case the latter\n instantiations do not need to compile.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL775_1719)\n---\nimport std.traits : isNumeric, isUnsigned;\n\nalias storesNegativeNumbers = templateAnd!(isNumeric, templateNot!isUnsigned);\nstatic assert(storesNegativeNumbers!int);\nstatic assert(!storesNegativeNumbers!string && !storesNegativeNumbers!uint);\n\n// An empty list of predicates always yields true.\nalias alwaysTrue = templateAnd!();\nstatic assert(alwaysTrue!int);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL775_1719)\n",
				"parameters": [
					{
						"name": "Preds",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [],
						"name": "templateOr",
						"line": 816,
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					}
				],
				"name": "templateOr",
				"line": 814,
				"comment": " Combines several template predicates using logical OR, i.e. constructs a new\n predicate which evaluates to true for a given input T if and only at least\n one of the passed predicates is true for T.\n\n The predicates are evaluated from left to right, aborting evaluation in a\n short-cut manner if a true result is encountered, in which case the latter\n instantiations do not need to compile.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL833_1721)\n---\nimport std.traits : isPointer, isUnsigned;\n\nalias isPtrOrUnsigned = templateOr!(isPointer, isUnsigned);\nstatic assert( isPtrOrUnsigned!uint &&  isPtrOrUnsigned!(short*));\nstatic assert(!isPtrOrUnsigned!int  && !isPtrOrUnsigned!(string));\n\n// An empty list of predicates never yields true.\nalias alwaysFalse = templateOr!();\nstatic assert(!alwaysFalse!int);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL833_1721)\n",
				"parameters": [
					{
						"name": "Preds",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " Templates to manipulate template argument lists (also known as type lists).\n\n Some operations on alias sequences are built in to the language,\n such as TL[$(I n)] which gets the $(I n)th type from the\n alias sequence. TL[$(I lwr) .. $(I upr)] returns a new type\n list that is a slice of the old one.\n\n Several templates in this module use or operate on eponymous templates that\n take a single argument and evaluate to a boolean constant. Such templates\n are referred to as $(I template predicates).\n\n References:\n  Based on ideas in Table 3.1 from\n  $(LINK2 http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768,\n      Modern C++ Design),\n   Andrei Alexandrescu (Addison-Wesley Professional, 2001)\n Macros:\n  WIKI = Phobos/StdTypeTuple\n\n Copyright: Copyright Digital Mars 2005 - 2015.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:\n     $(WEB digitalmars.com, Walter Bright),\n     $(WEB klickverbot.at, David Nadlinger)\n Source:    $(PHOBOSSRC std/_typetuple.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/uri.d",
		"name": "std.uri",
		"members": [
			{
				"members": [],
				"name": "URIException",
				"line": 44,
				"comment": " This Exception is thrown if something goes wrong when encoding or\ndecoding a URI.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decode",
						"line": 348,
						"type": "string(in Char[] encodedURI)",
						"parameters": [
							{
								"name": "encodedURI",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 352,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "decode",
				"line": 348,
				"comment": " Decodes the URI string encodedURI into a UTF-8 string and returns it.\n Escape sequences that resolve to reserved URI characters are not replaced.\n Escape sequences that resolve to the '#' character are not replaced.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeComponent",
						"line": 359,
						"type": "string(in Char[] encodedURIComponent)",
						"parameters": [
							{
								"name": "encodedURIComponent",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 363,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "decodeComponent",
				"line": 359,
				"comment": " Decodes the URI string encodedURI into a UTF-8 string and returns it. All\n escape sequences are decoded.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 370,
						"type": "string(in Char[] uri)",
						"parameters": [
							{
								"name": "uri",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 374,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 370,
				"comment": " Encodes the UTF-8 string uri into a URI and returns that URI. Any character\n not a valid URI character is escaped. The '#' character is not escaped.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encodeComponent",
						"line": 381,
						"type": "string(in Char[] uriComponent)",
						"parameters": [
							{
								"name": "uriComponent",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 385,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encodeComponent",
				"line": 381,
				"comment": " Encodes the UTF-8 string uriComponent into a URI and returns that URI.\n Any character not a letter, digit, or one of -_.!~*'() is escaped.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uriLength",
						"line": 394,
						"type": "size_t(in Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 444,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "uriLength",
				"line": 394,
				"comment": " Does string s[] start with a URL?\n Returns:\n  -1   it does not\n  len  it does, and s[0..len] is the slice of s[] that is that URL\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL447_1727)\n---\nstring s1 = \"http://www.digitalmars.com/~fred/fredsRX.html#foo end!\";\nassert (uriLength(s1) == 49);\nstring s2 = \"no uri here\";\nassert (uriLength(s2) == -1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL447_1727)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "emailLength",
						"line": 464,
						"type": "size_t(in Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 507,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "emailLength",
				"line": 464,
				"comment": " Does string s[] start with an email address?\n Returns:\n  -1    it does not\n  len   it does, and s[0..i] is the slice of s[] that is that email address\n References:\n  RFC2822\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL510_1728)\n---\nstring s1 = \"my.e-mail@www.example-domain.com with garbage added\";\nassert (emailLength(s1) == 32);\nstring s2 = \"no email address here\";\nassert (emailLength(s2) == -1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL510_1728)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 8,
				"kind": "template"
			}
		],
		"comment": " Encode and decode Uniform Resource Identifiers (URIs).\n URIs are used in internet transfer protocols.\n Valid URI characters consist of letters, digits,\n and the characters $(B ;/?:@&amp;=+$,-_.!~*'())\n Reserved URI characters are $(B ;/?:@&amp;=+$,)\n Escape sequences consist of $(B %) followed by two hex digits.\n\n See_Also:\n  $(LINK2 http://www.ietf.org/rfc/rfc3986.txt, RFC 3986)<br>\n  $(LINK2 http://en.wikipedia.org/wiki/Uniform_resource_identifier, Wikipedia)\n Macros:\n  WIKI = Phobos/StdUri\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_uri.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/csv.d",
		"name": "std.csv",
		"members": [
			{
				"members": [
					{
						"offset": 72,
						"name": "row",
						"line": 112,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "col",
						"line": 112,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 17,
						"kind": "variable"
					}
				],
				"name": "CSVException",
				"line": 109,
				"comment": " Exception containing the row and column for when an exception was thrown.\n\n Numbering of both row and col start at one and corresponds to the location\n in the file rather than any specified header. Special consideration should\n be made when there is failure to match the header see $(LREF\n HeaderMismatchException) for details.\n\n When performing type conversions, $(XREF ConvException) is stored in the $(D\n next) field.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 88,
						"name": "partialData",
						"line": 172,
						"comment": "Data pulled from input before finding a problem\n\n\n\nThis field is populated when using $(LREF csvReader)\n\nbut not by $(LREF csvNextToken) as this data will have\n\nalready been fed to the output range.\n",
						"deco": "Ayw",
						"char": 13,
						"kind": "variable"
					}
				],
				"name": "IncompleteCellException",
				"line": 165,
				"comment": " Exception thrown when a Token is identified to not be completed: a quote is\n found in an unquoted field, data continues after a closing quote, or the\n quoted field was not closed before data was empty.\n",
				"base": "std.csv.CSVException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "HeaderMismatchException",
				"line": 214,
				"comment": " Exception thrown under different conditions based on the type of $(D\n Contents).\n\n Structure, Class, and Associative Array\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n  )\n\n Other\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n     $(LI Order did not match that found in the input)\n  )\n\n Since a row and column is not meaningful when a column specified by the\n header is not found in the data, both row and col will be zero. Otherwise\n row is always one and col is the first instance found in header that\n occurred before the previous starting at one.\n",
				"base": "std.csv.CSVException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "ignore",
						"line": 255,
						"value": "0",
						"comment": "No exceptions are thrown due to incorrect CSV.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "throwException",
						"line": 257,
						"value": "1",
						"comment": "Use exceptions when input has incorrect CSV.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Malformed",
				"line": 252,
				"comment": " Determines the behavior for when an error is detected.\n\n Disabling exception will follow these rules:\n $(UL\n     $(LI A quote can appear in a field if the field was not quoted.)\n     $(LI If in a quoted field any quote by itself, not at the end of a\n     field, will end processing for that field.)\n     $(LI The field is ended when there is no input, even if the quote was\n     not closed.)\n     $(LI If the given header does not match the order in the input, the\n     content will return as it is found in the input.)\n     $(LI If the given header contains columns not found in the input they\n     will be ignored.)\n  )\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvReader",
						"line": 329,
						"type": "(Range input, Separator delimiter = ',', Separator quote = '\"')",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							},
							{
								"name": "delimiter",
								"type": "Separator",
								"default": "','"
							},
							{
								"name": "quote",
								"type": "Separator",
								"default": "'\"'"
							}
						],
						"endline": 338,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "csvReader",
				"line": 329,
				"comment": " Returns an input range for iterating over records found in $(D\n input).\n\n The $(D Contents) of the input can be provided if all the records are the\n same type such as all integer data:\n\n -------\n string str = `76,26,22`;\n int[] ans = [76,26,22];\n auto records = csvReader!int(str);\n\n foreach(record; records)\n {\n     assert(equal(record, ans));\n }\n -------\n\n Example using a struct with modified delimiter:\n\n -------\n string str = \"Hello;65;63.63\\nWorld;123;3673.562\";\n struct Layout\n {\n     string name;\n     int value;\n     double other;\n }\n\n auto records = csvReader!Layout(str,';');\n\n foreach(record; records)\n {\n     writeln(record.name);\n     writeln(record.value);\n     writeln(record.other);\n }\n -------\n\n Specifying $(D ErrorLevel) as Malformed.ignore will lift restrictions\n on the format. This example shows that an exception is not thrown when\n finding a quote in a field not quoted.\n\n -------\n string str = \"A \\\" is now part of the data\";\n auto records = csvReader!(string,Malformed.ignore)(str);\n auto record = records.front;\n\n assert(record.front == str);\n -------\n\n Returns:\n        An input range R as defined by\n        $(XREF_PACK range,primitives,isInputRange). When $(D Contents) is a\n        struct, class, or an associative array, the element type of R is\n        $(D Contents), otherwise the element type of R is itself a range with\n        element type $(D Contents).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n",
				"parameters": [
					{
						"name": "Contents",
						"default": "string",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isSomeChar!Separator && !is(Contents T : T[U], U : string)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvReader",
						"line": 414,
						"type": "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							},
							{
								"name": "header",
								"type": "Header"
							},
							{
								"name": "delimiter",
								"type": "Separator",
								"default": "','"
							},
							{
								"name": "quote",
								"type": "Separator",
								"default": "'\"'"
							}
						],
						"endline": 427,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "csvReader",
				"line": 414,
				"comment": " An optional $(D header) can be provided. The first record will be read in\n as the header. If $(D Contents) is a struct then the header provided is\n expected to correspond to the fields in the struct. When $(D Contents) is\n not a type which can contain the entire record, the $(D header) must be\n provided in the same order as the input or an exception is thrown.\n\n Read only column \"b\":\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader!int(str, [\"b\"]);\n\n auto ans = [[65],[123]];\n foreach(record; records)\n {\n     assert(equal(record, ans.front));\n     ans.popFront();\n }\n -------\n\n Read from header of different order:\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n struct Layout\n {\n     int value;\n     double other;\n     string name;\n }\n\n auto records = csvReader!Layout(str, [\"b\",\"c\",\"a\"]);\n -------\n\n The header can also be left empty if the input contains a header but\n all columns should be iterated. The header from the input can always\n be accessed from the header field.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader(str, null);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Returns:\n        An input range R as defined by\n        $(XREF_PACK range,primitives,isInputRange). When $(D Contents) is a\n        struct, class, or an associative array, the element type of R is\n        $(D Contents), otherwise the element type of R is itself a range with\n        element type $(D Contents).\n\n        The returned range provides a header field for accessing the header\n        from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n",
				"parameters": [
					{
						"name": "Contents",
						"default": "string",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Header",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isSomeChar!Separator && isForwardRange!Header && isSomeString!(ElementType!Header)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvReader",
						"line": 430,
						"type": "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							},
							{
								"name": "header",
								"type": "Header"
							},
							{
								"name": "delimiter",
								"type": "Separator",
								"default": "','"
							},
							{
								"name": "quote",
								"type": "Separator",
								"default": "'\"'"
							}
						],
						"endline": 442,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "csvReader",
				"line": 430,
				"comment": "\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1117_1748)\n---\nimport std.algorithm;\n\nstring str = `76;^26^;22`;\nint[] ans = [76,26,22];\nauto records = CsvReader!(int,Malformed.ignore,string,char,string[])\n      (str, ';', '^');\n\nforeach(record; records)\n{\n    assert(equal(record, ans));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1117_1748)\n",
				"parameters": [
					{
						"name": "Contents",
						"default": "string",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Header",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isSomeChar!Separator && is(Header : typeof(null))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "csvNextToken",
						"line": 1363,
						"type": "void(ref Range input, ref Output ans, Separator sep, Separator quote, bool startQuoted = false)",
						"parameters": [
							{
								"name": "input",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "ans",
								"type": "Output",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "sep",
								"type": "Separator"
							},
							{
								"name": "quote",
								"type": "Separator"
							},
							{
								"name": "startQuoted",
								"deco": "b",
								"default": "false"
							}
						],
						"endline": 1463,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "csvNextToken",
				"line": 1363,
				"comment": " Lower level control over parsing CSV\n\n This function consumes the input. After each call the input will\n start with either a delimiter or record break (\\n, \\r\\n, \\r) which\n must be removed for subsequent calls.\n\n params:\n       input = Any CSV input\n       ans   = The first field in the input\n       sep   = The character to represent a comma in the specification\n       quote = The character to represent a quote in the specification\n       startQuoted = Whether the input should be considered to already be in\n quotes\n\n Throws:\n       $(LREF IncompleteCellException) When a quote is found in an unquoted\n       field, data continues after a closing quote, or the quoted field was\n       not closed before data was empty.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1466_1749)\n---\nimport std.array : appender;\nstring str = \"65,63\\n123,3673\";\n\nauto a = appender!(char[])();\n\ncsvNextToken(str,a,',','\"');\nassert(a.data == \"65\");\nassert(str == \",63\\n123,3673\");\n\nstr.popFront();\na.shrinkTo(0);\ncsvNextToken(str,a,',','\"');\nassert(a.data == \"63\");\nassert(str == \"\\n123,3673\");\n\nstr.popFront();\na.shrinkTo(0);\ncsvNextToken(str,a,',','\"');\nassert(a.data == \"123\");\nassert(str == \",3673\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1466_1749)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "ErrorLevel",
						"defaultValue": "Malformed.throwException",
						"deco": "E3std3csv9Malformed",
						"kind": "value"
					},
					{
						"name": "Separator",
						"kind": "type"
					},
					{
						"name": "Output",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Separator && isInputRange!Range && is(Unqual!(ElementType!Range) == dchar) && isOutputRange!(Output, dchar)",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": " Implements functionality to read Comma Separated Values and its variants\n from a input range of $(D dchar).\n\n Comma Separated Values provide a simple means to transfer and store\n tabular data. It has been common for programs to use their own\n variant of the CSV format. This parser will loosely follow the\n $(WEB tools.ietf.org/html/rfc4180, RFC-4180). CSV input should adhered\n to the following criteria, differences from RFC-4180 in parentheses.\n\n $(UL\n     $(LI A record is separated by a new line (CRLF,LF,CR))\n     $(LI A final record may end with a new line)\n     $(LI A header may be provided as the first record in input)\n     $(LI A record has fields separated by a comma (customizable))\n     $(LI A field containing new lines, commas, or double quotes\n          should be enclosed in double quotes (customizable))\n     $(LI Double quotes in a field are escaped with a double quote)\n     $(LI Each record should contain the same number of fields)\n   )\n\n Example:\n\n -------\n import std.algorithm;\n import std.array;\n import std.csv;\n import std.stdio;\n import std.typecons;\n\n void main()\n {\n     auto text = \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n     foreach(record; csvReader!(Tuple!(string, string, int))(text))\n     {\n         writefln(\"%s works as a %s and earns $%d per year\",\n                  record[0], record[1], record[2]);\n     }\n\n     // To read the same string from the file \"filename.csv\":\n\n     auto file = File(\"filename.csv\", \"r\");\n     foreach(record;\n         file.byLine.joiner(\"\\n\").csvReader!(Tuple!(string, string, int)))\n     {\n         writefln(\"%s works as a %s and earns $%d per year\",\n                  record[0], record[1], record[2]);\n     }\n }\n }\n -------\n\n When an input contains a header the $(D Contents) can be specified as an\n associative array. Passing null to signify that a header is present.\n\n -------\n auto text = \"Name,Occupation,Salary\\r\"\n     \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n foreach(record; csvReader!(string[string])\n         (text, null))\n {\n     writefln(\"%s works as a %s and earns $%s per year.\",\n              record[\"Name\"], record[\"Occupation\"],\n              record[\"Salary\"]);\n }\n -------\n\n This module allows content to be iterated by record stored in a struct,\n class, associative array, or as a range of fields. Upon detection of an\n error an CSVException is thrown (can be disabled). csvNextToken has been\n made public to allow for attempted recovery.\n\n Disabling exceptions will lift many restrictions specified above. A quote\n can appear in a field if the field was not quoted. If in a quoted field any\n quote by itself, not at the end of a field, will end processing for that\n field. The field is ended when there is no input, even if the quote was not\n closed.\n\n   See_Also:\n      $(WEB en.wikipedia.org/wiki/Comma-separated_values, Wikipedia\n      Comma-separated values)\n\n   Copyright: Copyright 2011\n   License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n   Authors:   Jesse Phillips\n   Source:    $(PHOBOSSRC std/_csv.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/encoding.d",
		"name": "std.encoding",
		"members": [
			{
				"name": "INVALID_SEQUENCE",
				"line": 363,
				"comment": " Special value returned by $(D safeDecode)\n",
				"deco": "w",
				"init": "'\\Uffffffff'",
				"char": 12,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [],
				"name": "AsciiChar",
				"line": 647,
				"comment": " Defines various character sets.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "AsciiString",
				"line": 649,
				"comment": "Ditto\n",
				"deco": "AyE3std8encoding9AsciiChar",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "Latin1Char",
				"line": 727,
				"comment": " Defines an Latin1-encoded character.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Latin1String",
				"line": 732,
				"comment": "Defines an Latin1-encoded string (as an array of $(D\nimmutable(Latin1Char))).\n\n\n",
				"deco": "AyE3std8encoding10Latin1Char",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "Windows1252Char",
				"line": 803,
				"comment": " Defines a Windows1252-encoded character.\n",
				"baseDeco": "h",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Windows1252String",
				"line": 808,
				"comment": "Defines an Windows1252-encoded string (as an array of $(D\nimmutable(Windows1252Char))).\n\n\n",
				"deco": "AyE3std8encoding15Windows1252Char",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "isValidCodePoint",
				"line": 1252,
				"comment": "Returns true if c is a valid code point\n\n Note that this includes the non-character code points U+FFFE and U+FFFF,\n since these are valid code points (even though they are not valid\n characters).\n\n Supersedes:\n This function supersedes $(D std.utf.startsValidDchar()).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 1255,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encodingName",
						"line": 1265,
						"type": "@property string()",
						"endline": 1268,
						"char": 18,
						"kind": "function"
					}
				],
				"name": "encodingName",
				"line": 1265,
				"comment": " Returns the name of an encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1271_1757)\n---\nassert(encodingName!(char) == \"UTF-8\");\nassert(encodingName!(wchar) == \"UTF-16\");\nassert(encodingName!(dchar) == \"UTF-32\");\nassert(encodingName!(AsciiChar) == \"ASCII\");\nassert(encodingName!(Latin1Char) == \"ISO-8859-1\");\nassert(encodingName!(Windows1252Char) == \"windows-1252\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1271_1757)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 18,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "canEncode",
						"line": 1290,
						"type": "bool(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1293,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "canEncode",
				"line": 1290,
				"comment": " Returns true iff it is possible to represent the specified codepoint\n in the encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1296_1758)\n---\nassert( canEncode!(Latin1Char)('A'));\nassert(!canEncode!(AsciiChar)('\\u00A0'));\nassert( canEncode!(Latin1Char)('\\u00A0'));\nassert( canEncode!(Windows1252Char)('\\u20AC'));\nassert(!canEncode!(Windows1252Char)('\\u20AD'));\nassert(!canEncode!(Windows1252Char)('\\uFFFD'));\nassert(!canEncode!(char)(cast(dchar)0x110000));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1296_1758)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValidCodeUnit",
						"line": 1317,
						"type": "bool(E c)",
						"parameters": [
							{
								"name": "c",
								"type": "E"
							}
						],
						"endline": 1320,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValidCodeUnit",
				"line": 1317,
				"comment": " Returns true if the code unit is legal. For example, the byte 0x80 would\n not be legal in ASCII, because ASCII code units must always be in the range\n 0x00 to 0x7F.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code unit to be tested\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1323_1759)\n---\nassert(!isValidCodeUnit(cast(char)0xC0));\nassert(!isValidCodeUnit(cast(char)0xFF));\nassert( isValidCodeUnit(cast(wchar)0xD800));\nassert(!isValidCodeUnit(cast(dchar)0xD800));\nassert(!isValidCodeUnit(cast(AsciiChar)0xA0));\nassert( isValidCodeUnit(cast(Windows1252Char)0x80));\nassert(!isValidCodeUnit(cast(Windows1252Char)0x81));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1323_1759)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isValid",
						"line": 1347,
						"type": "bool(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1350,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isValid",
				"line": 1347,
				"comment": " Returns true if the string is encoded correctly\n\n Supersedes:\n This function supersedes std.utf.validate(), however note that this\n function returns a bool indicating whether the input was valid or not,\n whereas the older function would throw an exception.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1353_1760)\n---\nassert( isValid(\"\\u20AC100\"));\nassert(!isValid(cast(char[3])[167, 133, 175]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1353_1760)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "validLength",
						"line": 1368,
						"type": "size_t(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1378,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "validLength",
				"line": 1368,
				"comment": " Returns the length of the longest possible substring, starting from\n the first code unit, which is validly encoded.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sanitize",
						"line": 1396,
						"type": "immutable(E)[](immutable(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "immutable(E)[]"
							}
						],
						"endline": 1433,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "sanitize",
				"line": 1396,
				"comment": " Sanitizes a string by replacing malformed code unit sequences with valid\n code unit sequences. The result is guaranteed to be valid for this encoding.\n\n If the input string is already valid, this function returns the original,\n otherwise it constructs a new string by replacing all illegal code unit\n sequences with the encoding's replacement character, Invalid sequences will\n be replaced with the Unicode replacement character (U+FFFD) if the\n character repertoire contains it, otherwise invalid sequences will be\n replaced with '?'.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sanitized\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1436_1761)\n---\nassert(sanitize(\"hello \\xF0\\x80world\") == \"hello \\xEF\\xBF\\xBDworld\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1436_1761)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "firstSequence",
						"line": 1452,
						"type": "size_t(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1464,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "firstSequence",
				"line": 1452,
				"comment": "Returns the length of the first encoded sequence.\n\nThe input to this function MUST be validly encoded.\nThis is enforced by the function's in-contract.\n\nStandards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\nParams:\ns = the string to be sliced\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1467_1762)\n---\nassert(firstSequence(\"\\u20AC1000\") == \"\\u20AC\".length);\nassert(firstSequence(\"hel\") == \"h\".length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1467_1762)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastSequence",
						"line": 1484,
						"type": "size_t(const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							}
						],
						"endline": 1495,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "lastSequence",
				"line": 1484,
				"comment": " Returns the length of the last encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sliced\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1498_1763)\n---\nassert(lastSequence(\"1000\\u20AC\") == \"\\u20AC\".length);\nassert(lastSequence(\"hellÃ¶\") == \"Ã¶\".length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1498_1763)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "index",
						"line": 1519,
						"type": "ptrdiff_t(const(E)[] s, int n)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]"
							},
							{
								"name": "n",
								"deco": "i"
							}
						],
						"endline": 1530,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "index",
				"line": 1519,
				"comment": " Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supersedes:\n This function supersedes std.utf.toUTFindex().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be counted\n    n = the current code point index\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1533_1764)\n---\nassert(index(\"\\u20AC100\",1) == 3);\nassert(index(\"hÃ¤llo\",2) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1533_1764)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decode",
						"line": 1557,
						"type": "dchar(ref S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1567,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decode",
				"line": 1557,
				"comment": " Decodes a single code point.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supersedes:\n This function supersedes std.utf.decode(), however, note that the\n function codePoints() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeReverse",
						"line": 1583,
						"type": "dchar(ref const(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "const(E)[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1592,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decodeReverse",
				"line": 1583,
				"comment": " Decodes a single code point from the end of a string.\n\n This function removes one or more code units from the end of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "safeDecode",
						"line": 1609,
						"type": "dchar(ref S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1617,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "safeDecode",
				"line": 1609,
				"comment": " Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n This function will accept an invalidly encoded string as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encodedLength",
						"line": 1633,
						"type": "size_t(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1641,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encodedLength",
				"line": 1633,
				"comment": " Returns the number of code units required to encode a single code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1664,
						"type": "E[](dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1672,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1664,
				"comment": " Encodes a single code point.\n\n This function encodes a single code point into one or more code units.\n It returns a string containing those code units.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode(), however, note that the\n function codeUnits() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1700,
						"type": "size_t(dchar c, E[] array)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "array",
								"type": "E[]"
							}
						],
						"endline": 1710,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1700,
				"comment": " Encodes a single code point into an array.\n\n This function encodes a single code point into one or more code units\n The code units are stored in a user-supplied fixed-size array,\n which must be passed by reference.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode(), however, note that the\n function codeUnits() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c     = the code point to be encoded\n    array = the destination array\n\n Returns:\n          the number of code units written to the array\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1836,
						"type": "void(dchar c, void delegate(E) dg)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "dg",
								"type": "void delegate(E)"
							}
						],
						"endline": 1844,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1836,
				"comment": " Encodes a single code point to a delegate.\n\n This function encodes a single code point into one or more code units.\n The code units are passed one at a time to the supplied delegate.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode(), however, note that the\n function codeUnits() supersedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c  = the code point to be encoded\n    dg = the delegate to invoke for each code unit\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 1856,
						"type": "size_t(in Src[] s, R range)",
						"parameters": [
							{
								"name": "s",
								"type": "Src[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 1864,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 1856,
				"comment": "Encodes the contents of $(D s) in units of type $(D Tgt), writing the result to an\noutput range.\n\nReturns: The number of $(D Tgt) elements written.\nParams:\nTgt = Element type of $(D range).\ns = Input array.\nrange = Output range.\n",
				"parameters": [
					{
						"name": "Tgt",
						"kind": "type"
					},
					{
						"name": "Src",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codePoints",
						"line": 1898,
						"type": "CodePoints!E(immutable(E)[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "immutable(E)[]"
							}
						],
						"endline": 1906,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "codePoints",
				"line": 1898,
				"comment": " Returns a foreachable struct which can bidirectionally iterate over all\n code points in a string.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n You can foreach either\n with or without an index. If an index is specified, it will be initialized\n at each iteration with the offset into the string at which the code point\n begins.\n\n Supersedes:\n This function supersedes std.utf.decode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be decoded\n\n Examples:\n --------------------------------------------------------\n string s = \"hello world\";\n foreach(c;codePoints(s))\n {\n     // do something with c (which will always be a dchar)\n }\n --------------------------------------------------------\n\n Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)\n in that the latter will fall over on encountering U+FFFF.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1909_1766)\n---\nstring s = \"hello\";\nstring t;\nforeach(c;codePoints(s))\n{\n    t ~= cast(char)c;\n}\nassert(s == t);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1909_1766)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codeUnits",
						"line": 1938,
						"type": "CodeUnits!E(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 1946,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "codeUnits",
				"line": 1938,
				"comment": " Returns a foreachable struct which can bidirectionally iterate over all\n code units in a code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type in the template parameter.\n\n Supersedes:\n This function supersedes std.utf.encode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1949_1767)\n---\nchar[] a;\nforeach(c;codeUnits!(char)(cast(dchar)'\\u20AC'))\n{\n    a ~= c;\n}\nassert(a.length == 3);\nassert(a[0] == 0xE2);\nassert(a[1] == 0x82);\nassert(a[2] == 0xAC);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1949_1767)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transcode",
						"line": 1980,
						"type": "void(immutable(Src)[] s, out immutable(Dst)[] r)",
						"parameters": [
							{
								"name": "s",
								"type": "immutable(Src)[]"
							},
							{
								"name": "r",
								"type": "immutable(Dst)[]",
								"storageClass": [
									"out"
								]
							}
						],
						"endline": 2027,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "transcode",
				"line": 1980,
				"comment": " Convert a string from one encoding to another.\n\n Supersedes:\n This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and\n std.utf.toUTF32()\n (but note that to!() supersedes it more conveniently).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = Source string. $(B Must) be validly encoded.\n        This is enforced by the function's in-contract.\n    r = Destination string\n\n See_Also:\n    $(XREF conv, to)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2030_1768)\n---\nwstring ws;\n// transcode from UTF-8 to UTF-16\ntranscode(\"hello world\",ws);\nassert(ws == \"hello world\"w);\n\nLatin1String ls;\n// transcode from UTF-16 to ISO-8859-1\ntranscode(ws, ls);\nassert(ws == \"hello world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2030_1768)\n",
				"parameters": [
					{
						"name": "Src",
						"kind": "type"
					},
					{
						"name": "Dst",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "EncodingException",
				"line": 2085,
				"comment": " The base class for exceptions thrown by this module\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "EncodingScheme",
				"line": 2093,
				"comment": " Abstract base class of all encoding schemes\n",
				"members": [
					{
						"endchar": 5,
						"name": "register",
						"line": 2114,
						"comment": " Registers a subclass of EncodingScheme.\n\n This function allows user-defined subclasses of EncodingScheme to\n be declared in other modules.\n\n Examples:\n ----------------------------------------------\n class Amiga1251 : EncodingScheme\n {\n     shared static this()\n     {\n         EncodingScheme.register(\"path.to.Amiga1251\");\n     }\n }\n ----------------------------------------------\n",
						"deco": "FAyaZv",
						"parameters": [
							{
								"name": "className",
								"deco": "Aya"
							}
						],
						"endline": 2123,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "create",
						"line": 2137,
						"comment": " Obtains a subclass of EncodingScheme which is capable of encoding\n and decoding the named encoding scheme.\n\n This function is only aware of EncodingSchemes which have been\n registered with the register() function.\n\n Examples:\n ---------------------------------------------------\n auto scheme = EncodingScheme.create(\"Amiga-1251\");\n ---------------------------------------------------\n",
						"deco": "FAyaZC3std8encoding14EncodingScheme",
						"parameters": [
							{
								"name": "encodingName",
								"deco": "Aya"
							}
						],
						"endline": 2146,
						"char": 27,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"name": "toString",
						"line": 2153,
						"comment": " Returns the standard name of the encoding scheme\n",
						"deco": "xFZAya",
						"char": 34,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "names",
						"line": 2158,
						"comment": " Returns an array of all known names for this encoding scheme\n",
						"deco": "xFZAAya",
						"char": 27,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "canEncode",
						"line": 2164,
						"comment": " Returns true if the character c can be represented\n in this encoding scheme.\n",
						"deco": "xFwZb",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"char": 23,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "encodedLength",
						"line": 2177,
						"comment": " Returns the number of ubytes required to encode this code point.\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n    the number of ubytes required.\n",
						"deco": "xFwZm",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"originalType": "const size_t(dchar c)",
						"char": 25,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "encode",
						"line": 2196,
						"comment": " Encodes a single code point into a user-supplied, fixed-size buffer.\n\n This function encodes a single code point into one or more ubytes.\n The supplied buffer must be code unit aligned.\n (For example, UTF-16LE or UTF-16BE must be wchar-aligned,\n UTF-32LE or UTF-32BE must be dchar-aligned, etc.)\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c      = the code point to be encoded\n    buffer = the destination array\n\n Returns:\n    the number of ubytes written.\n",
						"deco": "xFwAhZm",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "buffer",
								"deco": "Ah"
							}
						],
						"originalType": "const size_t(dchar c, ubyte[] buffer)",
						"char": 25,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "decode",
						"line": 2209,
						"comment": " Decodes a single code point.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n The input to this function MUST be validly encoded.\n\n Params:\n    s = the array whose first code point is to be decoded\n",
						"deco": "xFKAxhZw",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "Axh"
							}
						],
						"char": 24,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "safeDecode",
						"line": 2224,
						"comment": " Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n This function will accept an invalidly encoded array as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Params:\n    s = the array whose first code point is to be decoded\n",
						"deco": "xFKAxhZw",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "Axh"
							}
						],
						"char": 24,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "replacementSequence",
						"line": 2233,
						"comment": " Returns the sequence of ubytes to be used to represent\n any character which cannot be represented in the encoding scheme.\n\n Normally this will be a representation of some substitution\n character, such as U+FFFD or '?'.\n",
						"deco": "xFNdZAyh",
						"char": 47,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 5,
						"name": "isValid",
						"line": 2242,
						"comment": " Returns true if the array is encoded correctly\n\n Params:\n    s = the array to be tested\n",
						"deco": "FAxhZb",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2251,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "validLength",
						"line": 2260,
						"comment": " Returns the length of the longest possible substring, starting from\n the first element, which is validly encoded.\n\n Params:\n    s = the array to be tested\n",
						"deco": "FAxhZm",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2270,
						"originalType": "size_t(const(ubyte)[] s)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sanitize",
						"line": 2284,
						"comment": " Sanitizes an array by replacing malformed ubyte sequences with valid\n ubyte sequences. The result is guaranteed to be valid for this\n encoding scheme.\n\n If the input array is already valid, this function returns the\n original, otherwise it constructs a new array by replacing all illegal\n sequences with the encoding scheme's replacement sequence.\n\n Params:\n    s = the string to be sanitized\n",
						"deco": "FAyhZAyh",
						"parameters": [
							{
								"name": "s",
								"deco": "Ayh"
							}
						],
						"endline": 2321,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 2334,
							"deco": "FZv",
							"endline": 2334,
							"char": 5,
							"kind": "function"
						},
						"name": "firstSequence",
						"line": 2332,
						"comment": " Returns the length of the first encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the array to be sliced\n",
						"deco": "FAxhZm",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2344,
						"originalType": "size_t(const(ubyte)[] s)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 2357,
							"deco": "FZv",
							"endline": 2357,
							"char": 5,
							"kind": "function"
						},
						"name": "count",
						"line": 2355,
						"comment": " Returns the total number of code points encoded in a ubyte array.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n",
						"deco": "FAxhZm",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							}
						],
						"endline": 2369,
						"originalType": "size_t(const(ubyte)[] s)",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 2383,
							"deco": "FZv",
							"endline": 2383,
							"char": 5,
							"kind": "function"
						},
						"name": "index",
						"line": 2381,
						"comment": " Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n    n = the current code point index\n",
						"deco": "FAxhmZl",
						"parameters": [
							{
								"name": "s",
								"deco": "Axh"
							},
							{
								"name": "n",
								"deco": "m"
							}
						],
						"endline": 2392,
						"originalType": "ptrdiff_t(const(ubyte)[] s, size_t n)",
						"char": 15,
						"kind": "function"
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeASCII",
				"line": 2413,
				"comment": " EncodingScheme to handle ASCII\n\n This scheme recognises the following names:\n                 \"ANSI_X3.4-1968\",\n                 \"ANSI_X3.4-1986\",\n                 \"ASCII\",\n                 \"IBM367\",\n                 \"ISO646-US\",\n                 \"ISO_646.irv:1991\",\n                 \"US-ASCII\",\n                 \"cp367\",\n                 \"csASCII\"\n                 \"iso-ir-6\",\n                 \"us\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeLatin1",
				"line": 2499,
				"comment": " EncodingScheme to handle Latin-1\n\n This scheme recognises the following names:\n                 \"CP819\",\n                 \"IBM819\",\n                 \"ISO-8859-1\",\n                 \"ISO_8859-1\",\n                 \"ISO_8859-1:1987\",\n                 \"csISOLatin1\",\n                 \"iso-ir-100\",\n                 \"l1\",\n                 \"latin1\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeWindows1252",
				"line": 2575,
				"comment": " EncodingScheme to handle Windows-1252\n\n This scheme recognises the following names:\n                 \"windows-1252\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeUtf8",
				"line": 2643,
				"comment": " EncodingScheme to handle UTF-8\n\n This scheme recognises the following names:\n                 \"UTF-8\"\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeUtf16Native",
				"line": 2712,
				"comment": " EncodingScheme to handle UTF-16 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-16LE\" (little-endian architecture only)\n                 \"UTF-16BE\" (big-endian architecture only)\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "EncodingSchemeUtf32Native",
				"line": 2807,
				"comment": " EncodingScheme to handle UTF-32 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-32LE\" (little-endian architecture only)\n                 \"UTF-32BE\" (big-endian architecture only)\n",
				"base": "std.encoding.EncodingScheme",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "Classes and functions for handling and transcoding between various encodings.\n\nFor cases where the _encoding is known at compile-time, functions are provided\nfor arbitrary _encoding and decoding of characters, arbitrary transcoding\nbetween strings of different type, as well as validation and sanitization.\n\nEncodings currently supported are UTF-8, UTF-16, UTF-32, ASCII, ISO-8859-1\n(also known as LATIN-1), and WINDOWS-1252.\n\n$(UL\n$(LI The type $(D AsciiChar) represents an ASCII character.)\n$(LI The type $(D AsciiString) represents an ASCII string.)\n$(LI The type $(D Latin1Char) represents an ISO-8859-1 character.)\n$(LI The type $(D Latin1String) represents an ISO-8859-1 string.)\n$(LI The type $(D Windows1252Char) represents a Windows-1252 character.)\n$(LI The type $(D Windows1252String) represents a Windows-1252 string.))\n\nFor cases where the _encoding is not known at compile-time, but is\nknown at run-time, we provide the abstract class $(D EncodingScheme)\nand its subclasses.  To construct a run-time encoder/decoder, one does\ne.g.\n\n----------------------------------------------------\n    auto e = EncodingScheme.create(\"utf-8\");\n----------------------------------------------------\n\nThis library supplies $(D EncodingScheme) subclasses for ASCII,\nISO-8859-1 (also known as LATIN-1), WINDOWS-1252, UTF-8, and (on\nlittle-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian\narchitectures) UTF-16BE and UTF-32BE.\n\nThis library provides a mechanism whereby other modules may add $(D\nEncodingScheme) subclasses for any other _encoding.\n\nMacros:\n    WIKI=Phobos/StdEncoding\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std/_encoding.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/mmfile.d",
		"name": "std.mmfile",
		"members": [
			{
				"name": "MmFile",
				"line": 54,
				"comment": " MmFile objects control the memory mapped file resource.\n",
				"members": [
					{
						"members": [
							{
								"name": "read",
								"line": 61,
								"value": "0",
								"comment": "Read existing file\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "readWriteNew",
								"line": 62,
								"value": "1",
								"comment": "Delete existing file, write new file\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "readWrite",
								"line": 63,
								"value": "2",
								"comment": "Read/Write existing file, create if not existing\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "readCopyOnWrite",
								"line": 64,
								"value": "3",
								"comment": "Read/Write existing file, copy on write\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Mode",
						"line": 59,
						"comment": " The mode the memory mapped file is opened with.\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 73,
						"comment": " Open memory mapped file filename for reading.\n File is closed when the object instance is deleted.\n Throws:\n  std.file.FileException\n",
						"deco": "FAyaZC3std6mmfile6MmFile",
						"parameters": [
							{
								"name": "filename",
								"deco": "Aya"
							}
						],
						"endline": 76,
						"originalType": "(string filename)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 169,
						"comment": " Open memory mapped file filename in mode.\n File is closed when the object instance is deleted.\n Params:\n  filename = name of the file.\n      If null, an anonymous file mapping is created.\n  mode = access mode defined above.\n  size =  the size of the file. If 0, it is taken to be the\n      size of the existing file.\n  address = the preferred address to map the file to,\n      although the system is not required to honor it.\n      If null, the system selects the most convenient address.\n  window = preferred block size of the amount of data to map at one time\n      with 0 meaning map the entire file. The window size must be a\n      multiple of the memory allocation page size.\n Throws:\n  std.file.FileException\n",
						"deco": "FAyaE3std6mmfile6MmFile4ModemPvmZC3std6mmfile6MmFile",
						"parameters": [
							{
								"name": "filename",
								"deco": "Aya"
							},
							{
								"name": "mode",
								"deco": "E3std6mmfile6MmFile4Mode"
							},
							{
								"name": "size",
								"deco": "m"
							},
							{
								"name": "address",
								"deco": "Pv"
							},
							{
								"name": "window",
								"deco": "m",
								"default": "0LU"
							}
						],
						"endline": 350,
						"originalType": "(string filename, Mode mode, ulong size, void* address, size_t window = 0)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "~this",
						"line": 355,
						"comment": " Flushes pending output and closes the memory mapped file.\n",
						"deco": "FZv",
						"endline": 382,
						"char": 5,
						"kind": "destructor"
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 408,
						"comment": " Gives size in bytes of the memory mapped file.\n",
						"deco": "xFNdZm",
						"endline": 412,
						"char": 21,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "mode",
						"line": 417,
						"comment": " Read-only property returning the file mode.\n",
						"deco": "FZE3std6mmfile6MmFile4Mode",
						"endline": 421,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 426,
						"comment": " Returns entire file contents as an array.\n",
						"deco": "FZAv",
						"endline": 430,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 435,
						"comment": " Returns slice of file contents as an array.\n",
						"deco": "FmmZAv",
						"parameters": [
							{
								"name": "i1",
								"deco": "m"
							},
							{
								"name": "i2",
								"deco": "m"
							}
						],
						"endline": 442,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 447,
						"comment": " Returns byte at index i in file.\n",
						"deco": "FmZh",
						"parameters": [
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 453,
						"char": 11,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 458,
						"comment": " Sets and returns byte at index i in file to value.\n",
						"deco": "FhmZh",
						"parameters": [
							{
								"name": "value",
								"deco": "h"
							},
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 464,
						"char": 11,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Read and write memory mapped files.\n Macros:\n  WIKI=Phobos/StdMmfile\n\n Copyright: Copyright Digital Mars 2004 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Matthew Wilson\n Source:    $(PHOBOSSRC std/_mmfile.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/complex.d",
		"name": "std.complex",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "complex",
						"line": 36,
						"type": "pure nothrow @nogc @safe (R re)",
						"parameters": [
							{
								"name": "re",
								"type": "R"
							}
						],
						"endline": 42,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "complex",
				"line": 36,
				"comment": " Helper function that returns a _complex number with the specified\n    real and imaginary parts.\n\n    Params:\n        R = (template parameter) type of real part of complex number\n        I = (template parameter) type of imaginary part of complex number\n\n        re = real part of complex number to be constructed\n        im = (optional) imaginary part of complex number\n\n    Returns:\n        $(D Complex) instance with real and imaginary parts set\n        to the values provided as input.  If neither $(D re) nor\n        $(D im) are floating-point numbers, the return type will\n        be $(D Complex!double).  Otherwise, the return type is\n        deduced using $(D std.traits.CommonType!(R, I)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL55_1791)\n---\nauto a = complex(1.0);\nstatic assert (is(typeof(a) == Complex!double));\nassert (a.re == 1.0);\nassert (a.im == 0.0);\n\nauto b = complex(2.0L);\nstatic assert (is(typeof(b) == Complex!real));\nassert (b.re == 2.0L);\nassert (b.im == 0.0L);\n\nauto c = complex(1.0, 2.0);\nstatic assert (is(typeof(c) == Complex!double));\nassert (c.re == 1.0);\nassert (c.im == 2.0);\n\nauto d = complex(3.0, 4.0L);\nstatic assert (is(typeof(d) == Complex!real));\nassert (d.re == 3.0);\nassert (d.im == 4.0L);\n\nauto e = complex(1);\nstatic assert (is(typeof(e) == Complex!double));\nassert (e.re == 1);\nassert (e.im == 0);\n\nauto f = complex(1L, 2);\nstatic assert (is(typeof(f) == Complex!double));\nassert (f.re == 1L);\nassert (f.im == 2);\n\nauto g = complex(3, 4.0L);\nstatic assert (is(typeof(g) == Complex!real));\nassert (g.re == 3);\nassert (g.im == 4.0L);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL55_1791)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "is(R : double)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "complex",
						"line": 45,
						"type": "pure nothrow @nogc @safe (R re, I im)",
						"parameters": [
							{
								"name": "re",
								"type": "R"
							},
							{
								"name": "im",
								"type": "I"
							}
						],
						"endline": 52,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "complex",
				"line": 45,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "type"
					}
				],
				"constraint": "is(R : double) && is(I : double)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Complex",
						"line": 97,
						"members": [
							{
								"name": "re",
								"line": 102,
								"comment": " The real part of the number.\n",
								"type": "T",
								"char": 7,
								"kind": "variable"
							},
							{
								"name": "im",
								"line": 105,
								"comment": " The imaginary part of the number.\n",
								"type": "T",
								"char": 7,
								"kind": "variable"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 116,
								"comment": " Converts the complex number to a string representation.\n\n    The second form of this function is usually not called directly;\n    instead, it is used via $(XREF string,format), as shown in the examples\n    below.  Supported format characters are 'e', 'f', 'g', 'a', and 's'.\n\n    See the $(LINK2 std_format.html, std.format) and $(XREF string, format)\n    documentation for more information.\n",
								"type": "const string()",
								"endline": 124,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "toString",
										"line": 144,
										"type": "const void(scope void delegate(const(Char)[]) sink, FormatSpec!Char formatSpec)",
										"parameters": [
											{
												"name": "sink",
												"type": "void delegate(const(Char)[])",
												"storageClass": [
													"scope"
												]
											},
											{
												"name": "formatSpec",
												"type": "FormatSpec!Char"
											}
										],
										"endline": 153,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "toString",
								"line": 144,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Char",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Complex",
				"line": 97,
				"comment": " A complex number parametrised by a type $(D T), which must be either\n    $(D float), $(D double) or $(D real).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "abs",
						"line": 653,
						"type": "pure nothrow @nogc @safe T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 657,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "abs",
				"line": 653,
				"comment": " Calculates the absolute value (or modulus) of a complex number.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sqAbs",
						"line": 671,
						"type": "pure nothrow @nogc @safe T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 674,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "sqAbs",
				"line": 671,
				"comment": "   Calculates the squared modulus of a complex number.\n   For genericity, if called on a real number, $(D sqAbs) returns its square.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sqAbs",
						"line": 688,
						"type": "pure nothrow @nogc @safe T(T x)",
						"parameters": [
							{
								"name": "x",
								"type": "T"
							}
						],
						"endline": 692,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "sqAbs",
				"line": 688,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "arg",
						"line": 705,
						"type": "pure nothrow @nogc @safe T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 709,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "arg",
				"line": 705,
				"comment": " Calculates the argument (or phase) of a complex number.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "conj",
						"line": 721,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 724,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "conj",
				"line": 721,
				"comment": " Returns the complex conjugate of a complex number.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fromPolar",
						"line": 734,
						"type": "pure nothrow @nogc @safe Complex!(CommonType!(T, U))(T modulus, U argument)",
						"parameters": [
							{
								"name": "modulus",
								"type": "T"
							},
							{
								"name": "argument",
								"type": "U"
							}
						],
						"endline": 739,
						"char": 29,
						"kind": "function"
					}
				],
				"name": "fromPolar",
				"line": 734,
				"comment": " Constructs a complex number given its absolute value and argument.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "type"
					}
				],
				"char": 29,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sin",
						"line": 751,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 757,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "sin",
				"line": 751,
				"comment": " Trigonometric functions.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cos",
						"line": 767,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 773,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "cos",
				"line": 767,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "expi",
				"line": 792,
				"comment": " Calculates cos(y) + i sin(y).\n\n    Note:\n    $(D expi) is included here for convenience and for easy migration of code\n    that uses $(XREF math,_expi).  Unlike $(XREF math,_expi), which uses the\n    x87 $(I fsincos) instruction when possible, this function is no faster\n    than calculating cos(y) and sin(y) separately.\n",
				"deco": "FNaNbNiNeeZS3std7complex14__T7ComplexTeZ7Complex",
				"parameters": [
					{
						"name": "y",
						"deco": "e"
					}
				],
				"endline": 796,
				"char": 14,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sqrt",
						"line": 809,
						"type": "pure nothrow @nogc @safe Complex!T(Complex!T z)",
						"parameters": [
							{
								"name": "z",
								"type": "Complex!T"
							}
						],
						"endline": 851,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "sqrt",
				"line": 809,
				"comment": " Square root.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			}
		],
		"comment": " This module contains the $(LREF Complex) type, which is used to represent\n    _complex numbers, along with related mathematical operations and functions.\n\n    $(LREF Complex) will eventually $(LINK2 ../deprecate.html, replace)\n    the built-in types $(D cfloat), $(D cdouble), $(D creal), $(D ifloat),\n    $(D idouble), and $(D ireal).\n\n    Authors:    Lars Tandle Kyllingstad, Don Clugston\n    Copyright:  Copyright (c) 2010, Lars T. Kyllingstad.\n    License:    $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Source:     $(PHOBOSSRC std/_complex.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/parallelism.d",
		"name": "std.parallelism",
		"members": [
			{
				"members": [
					{
						"name": "Task",
						"line": 438,
						"members": [
							{
								"name": "ReturnType",
								"line": 516,
								"comment": "    The return type of the function called by this $(D Task).  This can be\n    $(D void).\n",
								"type": "typeof(fun(_args))",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "spinForce",
								"line": 585,
								"comment": "    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    busy spin until it's done, then return the return value.  If it threw\n    an exception, rethrow that exception.\n\n    This function should be used when you expect the result of the\n    $(D Task) to be available on a timescale shorter than that of an OS\n    context switch.\n",
								"type": "@property ref @trusted ReturnType()",
								"endline": 602,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "yieldForce",
								"line": 613,
								"comment": "    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    wait on a condition variable.  If it threw an exception, rethrow that\n    exception.\n\n    This function should be used for expensive functions, as waiting on a\n    condition variable introduces latency, but avoids wasted CPU cycles.\n",
								"type": "@property ref @trusted ReturnType()",
								"endline": 647,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "workForce",
								"line": 658,
								"comment": "    If this $(D Task) was not started yet, execute it in the current\n    thread.  If it is finished, return its result.  If it is in progress,\n    execute any other $(D Task) from the $(D TaskPool) instance that\n    this $(D Task) was submitted to until this one\n    is finished.  If it threw an exception, rethrow that exception.\n    If no other tasks are available or this $(D Task) was executed using\n    $(D executeInNewThread), wait on a condition variable.\n",
								"type": "@property ref @trusted ReturnType()",
								"endline": 721,
								"char": 30,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "done",
								"line": 729,
								"comment": "    Returns $(D true) if the $(D Task) is finished executing.\n\n    Throws:  Rethrows any exception thrown during the execution of the\n             $(D Task).\n",
								"type": "@property @trusted bool()",
								"endline": 733,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "executeInNewThread",
								"line": 743,
								"comment": "    Create a new thread for executing this $(D Task), execute it in the\n    newly created thread, then terminate the thread.  This can be used for\n    future/promise parallelism.  An explicit priority may be given\n    to the $(D Task).  If one is provided, its value is forwarded to\n    $(D core.thread.Thread.priority). See $(XREF parallelism, task) for\n    usage example.\n",
								"type": "@trusted void()",
								"endline": 746,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "executeInNewThread",
								"line": 749,
								"comment": "Ditto\n",
								"type": "@trusted void(int priority)",
								"parameters": [
									{
										"name": "priority",
										"deco": "i"
									}
								],
								"endline": 752,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Task",
				"line": 438,
				"comment": "$(D Task) represents the fundamental unit of work.  A $(D Task) may be\nexecuted in parallel with any other $(D Task).  Using this struct directly\nallows future/promise _parallelism.  In this paradigm, a function (or delegate\nor other callable) is executed in a thread other than the one it was called\nfrom.  The calling thread does not block while the function is being executed.\nA call to $(D workForce), $(D yieldForce), or $(D spinForce) is used to\nensure that the $(D Task) has finished executing and to obtain the return\nvalue, if any.  These functions and $(D done) also act as full memory barriers,\nmeaning that any memory writes made in the thread that executed the $(D Task)\nare guaranteed to be visible in the calling thread after one of these functions\nreturns.\n\nThe $(XREF parallelism, task) and $(XREF parallelism, scopedTask) functions can\nbe used to create an instance of this struct.  See $(D task) for usage examples.\n\nFunction results are returned from $(D yieldForce), $(D spinForce) and\n$(D workForce) by ref.  If $(D fun) returns by ref, the reference will point\nto the returned reference of $(D fun).  Otherwise it will point to a\nfield in this struct.\n\nCopying of this struct is disabled, since it would provide no useful semantics.\nIf you want to pass this struct around, you should do so by reference or\npointer.\n\nBugs:  Changes to $(D ref) and $(D out) arguments are not propagated to the\n       call site, only to $(D args) in this struct.\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "task",
						"line": 841,
						"type": "(Args args)",
						"parameters": [
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 844,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "task",
				"line": 841,
				"comment": "Creates a $(D Task) on the GC heap that calls an alias.  This may be executed\nvia $(D Task.executeInNewThread) or by submitting to a\n$(XREF parallelism, TaskPool).  A globally accessible instance of\n$(D TaskPool) is provided by $(XREF parallelism, taskPool).\n\nReturns:  A pointer to the $(D Task).\n\nExamples:\n---\n// Read two files into memory at the same time.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task!read(\"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\n---\n// Sorts an array using a parallel quick sort algorithm.\n// The first partition is done serially.  Both recursion\n// branches are then executed in parallel.\n//\n// Timings for sorting an array of 1,000,000 doubles on\n// an Athlon 64 X2 dual core machine:\n//\n// This implementation:               176 milliseconds.\n// Equivalent serial implementation:  280 milliseconds\nvoid parallelSort(T)(T[] data)\n{\n    // Sort small subarrays serially.\n    if(data.length < 100)\n    {\n         std.algorithm.sort(data);\n         return;\n    }\n\n    // Partition the array.\n    swap(data[$ / 2], data[$ - 1]);\n    auto pivot = data[$ - 1];\n    bool lessThanPivot(T elem) { return elem < pivot; }\n\n    auto greaterEqual = partition!lessThanPivot(data[0..$ - 1]);\n    swap(data[$ - greaterEqual.length - 1], data[$ - 1]);\n\n    auto less = data[0..$ - greaterEqual.length - 1];\n    greaterEqual = data[$ - greaterEqual.length..$];\n\n    // Execute both recursion branches in parallel.\n    auto recurseTask = task!parallelSort(greaterEqual);\n    taskPool.put(recurseTask);\n    parallelSort(less);\n    recurseTask.yieldForce;\n}\n---\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "task",
						"line": 877,
						"type": "(F delegateOrFp, Args args)",
						"parameters": [
							{
								"name": "delegateOrFp",
								"type": "F"
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 881,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "task",
				"line": 877,
				"comment": "Creates a $(D Task) on the GC heap that calls a function pointer, delegate, or\nclass/struct with overloaded opCall.\n\nExamples:\n---\n// Read two files in at the same time again,\n// but this time use a function pointer instead\n// of an alias to represent std.file.read.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task(&read, \"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\nNotes: This function takes a non-scope delegate, meaning it can be\n       used with closures.  If you can't allocate a closure due to objects\n       on the stack that have scoped destruction, see $(D scopedTask), which\n       takes a scope delegate.\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(delegateOrFp(args))) && !isSafeTask!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "task",
						"line": 904,
						"type": "@trusted (F fun, Args args)",
						"parameters": [
							{
								"name": "fun",
								"type": "F"
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 908,
						"char": 15,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "task",
				"line": 904,
				"comment": "Version of $(D task) usable from $(D @safe) code.  Usage mechanics are\nidentical to the non-@safe case, but safety introduces some restrictions:\n\n1.  $(D fun) must be @safe or @trusted.\n\n2.  $(D F) must not have any unshared aliasing as defined by\n    $(XREF traits, hasUnsharedAliasing).  This means it\n    may not be an unshared delegate or a non-shared class or struct\n    with overloaded $(D opCall).  This also precludes accepting template\n    alias parameters.\n\n3.  $(D Args) must not have unshared aliasing.\n\n4.  $(D fun) must not return by reference.\n\n5.  The return type must not have unshared aliasing unless $(D fun) is\n    $(D pure) or the $(D Task) is executed via $(D executeInNewThread) instead\n    of using a $(D TaskPool).\n\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(fun(args))) && isSafeTask!F",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "scopedTask",
						"line": 931,
						"type": "(Args args)",
						"parameters": [
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 936,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "scopedTask",
				"line": 931,
				"comment": "These functions allow the creation of $(D Task) objects on the stack rather\nthan the GC heap.  The lifetime of a $(D Task) created by $(D scopedTask)\ncannot exceed the lifetime of the scope it was created in.\n\n$(D scopedTask) might be preferred over $(D task):\n\n1.  When a $(D Task) that calls a delegate is being created and a closure\n    cannot be allocated due to objects on the stack that have scoped\n    destruction.  The delegate overload of $(D scopedTask) takes a $(D scope)\n    delegate.\n\n2.  As a micro-optimization, to avoid the heap allocation associated with\n    $(D task) or with the creation of a closure.\n\nUsage is otherwise identical to $(D task).\n\nNotes:  $(D Task) objects created using $(D scopedTask) will automatically\ncall $(D Task.yieldForce) in their destructor if necessary to ensure\nthe $(D Task) is complete before the stack frame they reside on is destroyed.\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "scopedTask",
						"line": 939,
						"type": "(scope F delegateOrFp, Args args)",
						"parameters": [
							{
								"name": "delegateOrFp",
								"type": "F",
								"storageClass": [
									"scope"
								]
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 945,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "scopedTask",
				"line": 939,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(delegateOrFp(args))) && !isSafeTask!F",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "scopedTask",
						"line": 948,
						"type": "@trusted (F fun, Args args)",
						"parameters": [
							{
								"name": "fun",
								"type": "F"
							},
							{
								"name": "args",
								"type": "Args"
							}
						],
						"endline": 954,
						"char": 15,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "scopedTask",
				"line": 948,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(fun(args))) && isSafeTask!F",
				"char": 15,
				"kind": "template"
			},
			{
				"name": "totalCPUs",
				"line": 960,
				"comment": "The total number of CPU cores available on the current machine, as reported by\nthe operating system.\n",
				"deco": "yk",
				"originalType": "uint",
				"char": 16,
				"kind": "variable",
				"storageClass": [
					"immutable"
				]
			},
			{
				"name": "TaskPool",
				"line": 1017,
				"comment": "This class encapsulates a task queue and a set of worker threads.  Its purpose\nis to efficiently map a large number of $(D Task)s onto a smaller number of\nthreads.  A task queue is a FIFO queue of $(D Task) objects that have been\nsubmitted to the $(D TaskPool) and are awaiting execution.  A worker thread is a\nthread that executes the $(D Task) at the front of the queue when one is\navailable and sleeps when the queue is empty.\n\nThis class should usually be used via the global instantiation\navailable via the $(XREF parallelism, taskPool) property.\nOccasionally it is useful to explicitly instantiate a $(D TaskPool):\n\n1.  When you want $(D TaskPool) instances with multiple priorities, for example\n    a low priority pool and a high priority pool.\n\n2.  When the threads in the global task pool are waiting on a synchronization\n    primitive (for example a mutex), and you want to parallelize the code that\n    needs to run before these threads can be resumed.\n",
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1427,
						"comment": "    Default constructor that initializes a $(D TaskPool) with\n    $(D totalCPUs) - 1 worker threads.  The minus 1 is included because the\n    main thread will also be available to do work.\n\n    Note:  On single-core machines, the primitives provided by $(D TaskPool)\n           operate transparently in single-threaded mode.\n",
						"deco": "FNeZC3std11parallelism8TaskPool",
						"endline": 1430,
						"originalType": "@trusted ()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1435,
						"comment": "    Allows for custom number of worker threads.\n",
						"deco": "FNemZC3std11parallelism8TaskPool",
						"parameters": [
							{
								"name": "nWorkers",
								"deco": "m"
							}
						],
						"endline": 1460,
						"originalType": "@trusted (size_t nWorkers)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "parallel",
								"line": 1533,
								"type": "ParallelForeach!R(R range, size_t workUnitSize)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "workUnitSize",
										"type": "size_t"
									}
								],
								"endline": 1538,
								"char": 23,
								"kind": "function"
							}
						],
						"name": "parallel",
						"line": 1533,
						"comment": "    Implements a parallel foreach loop over a range.  This works by implicitly\n    creating and submitting one $(D Task) to the $(D TaskPool) for each worker\n    thread.  A work unit is a set of consecutive elements of $(D range) to\n    be processed by a worker thread between communication with any other\n    thread.  The number of elements processed per work unit is controlled by the\n    $(D workUnitSize) parameter.  Smaller work units provide better load\n    balancing, but larger work units avoid the overhead of communicating\n    with other threads frequently to fetch the next work unit.  Large work\n    units also avoid false sharing in cases where the range is being modified.\n    The less time a single iteration of the loop takes, the larger\n    $(D workUnitSize) should be.  For very expensive loop bodies,\n    $(D workUnitSize) should  be 1.  An overload that chooses a default work\n    unit size is also available.\n\n    Examples:\n    ---\n    // Find the logarithm of every number from 1 to\n    // 10_000_000 in parallel.\n    auto logs = new double[10_000_000];\n\n    // Parallel foreach works with or without an index\n    // variable.  It can be iterate by ref if range.front\n    // returns by ref.\n\n    // Iterate over logs using work units of size 100.\n    foreach(i, ref elem; taskPool.parallel(logs, 100))\n    {\n        elem = log(i + 1.0);\n    }\n\n    // Same thing, but use the default work unit size.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // Parallel foreach:  388 milliseconds\n    // Regular foreach:   619 milliseconds\n    foreach(i, ref elem; taskPool.parallel(logs))\n    {\n        elem = log(i + 1.0);\n    }\n    ---\n\n    Notes:\n\n    The memory usage of this implementation is guaranteed to be constant\n    in $(D range.length).\n\n    Breaking from a parallel foreach loop via a break, labeled break,\n    labeled continue, return or goto statement throws a\n    $(D ParallelForeachError).\n\n    In the case of non-random access ranges, parallel foreach buffers lazily\n    to an array of size $(D workUnitSize) before executing the parallel portion\n    of the loop.  The exception is that, if a parallel foreach is executed\n    over a range returned by $(D asyncBuf) or $(D map), the copying is elided\n    and the buffers are simply swapped.  In this case $(D workUnitSize) is\n    ignored and the work unit size is set to the  buffer size of $(D range).\n\n    A memory barrier is guaranteed to be executed on exit from the loop,\n    so that results produced by all threads are visible in the calling thread.\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside a parallel foreach loop,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown by any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 23,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "parallel",
								"line": 1542,
								"type": "ParallelForeach!R(R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 1557,
								"char": 23,
								"kind": "function"
							}
						],
						"name": "parallel",
						"line": 1542,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 23,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "amap",
										"line": 1645,
										"type": "(Args args)",
										"parameters": [
											{
												"name": "args",
												"type": "Args"
											}
										],
										"endline": 1753,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "amap",
								"line": 1645,
								"comment": "        Eager parallel map.  The eagerness of this function means it has less\n        overhead than the lazily evaluated $(D TaskPool.map) and should be\n        preferred where the memory requirements of eagerness are acceptable.\n        $(D functions) are the functions to be evaluated, passed as template\n        alias parameters in a style similar to\n        $(XREF_PACK algorithm,iteration,map).\n        The first argument must be a random access range. For performance\n        reasons, amap will assume the range elements have not yet been\n        initialized. Elements will be overwritten without calling a destructor\n        nor doing an assignment. As such, the range must not contain meaningful\n        data: either un-initialized objects, or objects in their $(D .init)\n        state.\n\n        ---\n        auto numbers = iota(100_000_000.0);\n\n        // Find the square roots of numbers.\n        //\n        // Timings on an Athlon 64 X2 dual core machine:\n        //\n        // Parallel eager map:                   0.802 s\n        // Equivalent serial implementation:     1.768 s\n        auto squareRoots = taskPool.amap!sqrt(numbers);\n        ---\n\n        Immediately after the range argument, an optional work unit size argument\n        may be provided.  Work units as used by $(D amap) are identical to those\n        defined for parallel foreach.  If no work unit size is provided, the\n        default work unit size is used.\n\n        ---\n        // Same thing, but make work unit size 100.\n        auto squareRoots = taskPool.amap!sqrt(numbers, 100);\n        ---\n\n        An output range for returning the results may be provided as the last\n        argument.  If one is not provided, an array of the proper type will be\n        allocated on the garbage collected heap.  If one is provided, it must be a\n        random access range with assignable elements, must have reference\n        semantics with respect to assignment to its elements, and must have the\n        same length as the input range.  Writing to adjacent elements from\n        different threads must be safe.\n\n        ---\n        // Same thing, but explicitly allocate an array\n        // to return the results in.  The element type\n        // of the array may be either the exact type\n        // returned by functions or an implicit conversion\n        // target.\n        auto squareRoots = new float[numbers.length];\n        taskPool.amap!sqrt(numbers, squareRoots);\n\n        // Multiple functions, explicit output range, and\n        // explicit work unit size.\n        auto results = new Tuple!(float, real)[numbers.length];\n        taskPool.amap!(sqrt, log)(numbers, 100, results);\n        ---\n\n        Note:\n\n        A memory barrier is guaranteed to be executed after all results are written\n        but before returning so that results produced by all threads are visible\n        in the calling thread.\n\n        Tips:\n\n        To perform the mapping operation in place, provide the same range for the\n        input and output range.\n\n        To parallelize the copying of a range with expensive to evaluate elements\n        to an array, pass an identity function (a function that just returns\n        whatever argument is provided to it) to $(D amap).\n\n        $(B Exception Handling):\n\n        When at least one exception is thrown from inside the map functions,\n        the submission of additional $(D Task) objects is terminated as soon as\n        possible, in a non-deterministic manner.  All currently executing or\n        enqueued work units are allowed to complete.  Then, all exceptions that\n        were thrown from any work unit are chained using $(D Throwable.next) and\n        rethrown.  The order of the exception chaining is non-deterministic.\n",
								"parameters": [
									{
										"name": "Args",
										"kind": "tuple"
									}
								],
								"constraint": "isRandomAccessRange!(Args[0])",
								"char": 14,
								"kind": "template"
							}
						],
						"name": "amap",
						"line": 1560,
						"comment": "\n",
						"parameters": [
							{
								"name": "functions",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "map",
										"line": 1829,
										"type": "(S source, size_t bufSize = 100, size_t workUnitSize = size_t.max)",
										"parameters": [
											{
												"name": "source",
												"type": "S"
											},
											{
												"name": "bufSize",
												"type": "size_t",
												"default": "100"
											},
											{
												"name": "workUnitSize",
												"type": "size_t",
												"default": "size_t.max"
											}
										],
										"endline": 2090,
										"char": 9,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "map",
								"line": 1829,
								"comment": "        A semi-lazy parallel map that can be used for pipelining.  The map\n        functions are evaluated for the first $(D bufSize) elements and stored in a\n        buffer and made available to $(D popFront).  Meanwhile, in the\n        background a second buffer of the same size is filled.  When the first\n        buffer is exhausted, it is swapped with the second buffer and filled while\n        the values from what was originally the second buffer are read.  This\n        implementation allows for elements to be written to the buffer without\n        the need for atomic operations or synchronization for each write, and\n        enables the mapping function to be evaluated efficiently in parallel.\n\n        $(D map) has more overhead than the simpler procedure used by $(D amap)\n        but avoids the need to keep all results in memory simultaneously and works\n        with non-random access ranges.\n\n        Params:\n\n        source = The input range to be mapped.  If $(D source) is not random\n        access it will be lazily buffered to an array of size $(D bufSize) before\n        the map function is evaluated.  (For an exception to this rule, see Notes.)\n\n        bufSize = The size of the buffer to store the evaluated elements.\n\n        workUnitSize = The number of elements to evaluate in a single\n        $(D Task).  Must be less than or equal to $(D bufSize), and\n        should be a fraction of $(D bufSize) such that all worker threads can be\n        used.  If the default of size_t.max is used, workUnitSize will be set to\n        the pool-wide default.\n\n        Returns:  An input range representing the results of the map.  This range\n                  has a length iff $(D source) has a length.\n\n        Notes:\n\n        If a range returned by $(D map) or $(D asyncBuf) is used as an input to\n        $(D map), then as an optimization the copying from the output buffer\n        of the first range to the input buffer of the second range is elided, even\n        though the ranges returned by $(D map) and $(D asyncBuf) are non-random\n        access ranges.  This means that the $(D bufSize) parameter passed to the\n        current call to $(D map) will be ignored and the size of the buffer\n        will be the buffer size of $(D source).\n\n        Examples:\n        ---\n        // Pipeline reading a file, converting each line\n        // to a number, taking the logarithms of the numbers,\n        // and performing the additions necessary to find\n        // the sum of the logarithms.\n\n        auto lineRange = File(\"numberList.txt\").byLine();\n        auto dupedLines = std.algorithm.map!\"a.idup\"(lineRange);\n        auto nums = taskPool.map!(to!double)(dupedLines);\n        auto logs = taskPool.map!log10(nums);\n\n        double sum = 0;\n        foreach(elem; logs)\n        {\n            sum += elem;\n        }\n        ---\n\n        $(B Exception Handling):\n\n        Any exceptions thrown while iterating over $(D source)\n        or computing the map function are re-thrown on a call to $(D popFront) or,\n        if thrown during construction, are simply allowed to propagate to the\n        caller.  In the case of exceptions thrown while computing the map function,\n        the exceptions are chained as in $(D TaskPool.amap).\n",
								"parameters": [
									{
										"name": "S",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!S",
								"char": 9,
								"kind": "template"
							}
						],
						"name": "map",
						"line": 1757,
						"comment": "\n",
						"parameters": [
							{
								"name": "functions",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "asyncBuf",
								"line": 2136,
								"type": "(S source, size_t bufSize = 100)",
								"parameters": [
									{
										"name": "source",
										"type": "S"
									},
									{
										"name": "bufSize",
										"type": "size_t",
										"default": "100"
									}
								],
								"endline": 2271,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "asyncBuf",
						"line": 2136,
						"comment": "    Given a $(D source) range that is expensive to iterate over, returns an\n    input range that asynchronously buffers the contents of\n    $(D source) into a buffer of $(D bufSize) elements in a worker thread,\n    while making previously buffered elements from a second buffer, also of size\n    $(D bufSize), available via the range interface of the returned\n    object.  The returned range has a length iff $(D hasLength!S).\n    $(D asyncBuf) is useful, for example, when performing expensive operations\n    on the elements of ranges that represent data on a disk or network.\n\n    Examples:\n    ---\n    import std.conv, std.stdio;\n\n    void main()\n    {\n        // Fetch lines of a file in a background thread\n        // while processing previously fetched lines,\n        // dealing with byLine's buffer recycling by\n        // eagerly duplicating every line.\n        auto lines = File(\"foo.txt\").byLine();\n        auto duped = std.algorithm.map!\"a.idup\"(lines);\n\n        // Fetch more lines in the background while we\n        // process the lines already read into memory\n        // into a matrix of doubles.\n        double[][] matrix;\n        auto asyncReader = taskPool.asyncBuf(duped);\n\n        foreach(line; asyncReader)\n        {\n            auto ls = line.split(\"\\t\");\n            matrix ~= to!(double[])(ls);\n        }\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source) are re-thrown on a\n    call to $(D popFront) or, if thrown during construction, simply\n    allowed to propagate to the caller.\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!S",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "asyncBuf",
								"line": 2336,
								"type": "(C1 next, C2 empty, size_t initialBufSize = 0, size_t nBuffers = 100)",
								"parameters": [
									{
										"name": "next",
										"type": "C1"
									},
									{
										"name": "empty",
										"type": "C2"
									},
									{
										"name": "initialBufSize",
										"type": "size_t",
										"default": "0"
									},
									{
										"name": "nBuffers",
										"type": "size_t",
										"default": "100"
									}
								],
								"endline": 2344,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "asyncBuf",
						"line": 2336,
						"comment": "    Given a callable object $(D next) that writes to a user-provided buffer and\n    a second callable object $(D empty) that determines whether more data is\n    available to write via $(D next), returns an input range that\n    asynchronously calls $(D next) with a set of size $(D nBuffers) of buffers\n    and makes the results available in the order they were obtained via the\n    input range interface of the returned object.  Similarly to the\n    input range overload of $(D asyncBuf), the first half of the buffers\n    are made available via the range interface while the second half are\n    filled and vice-versa.\n\n    Params:\n\n    next = A callable object that takes a single argument that must be an array\n           with mutable elements.  When called, $(D next) writes data to\n           the array provided by the caller.\n\n    empty = A callable object that takes no arguments and returns a type\n            implicitly convertible to $(D bool).  This is used to signify\n            that no more data is available to be obtained by calling $(D next).\n\n    initialBufSize = The initial size of each buffer.  If $(D next) takes its\n                     array by reference, it may resize the buffers.\n\n    nBuffers = The number of buffers to cycle through when calling $(D next).\n\n    Examples:\n    ---\n    // Fetch lines of a file in a background\n    // thread while processing previously fetched\n    // lines, without duplicating any lines.\n    auto file = File(\"foo.txt\");\n\n    void next(ref char[] buf)\n    {\n        file.readln(buf);\n    }\n\n    // Fetch more lines in the background while we\n    // process the lines already read into memory\n    // into a matrix of doubles.\n    double[][] matrix;\n    auto asyncReader = taskPool.asyncBuf(&next, &file.eof);\n\n    foreach(line; asyncReader)\n    {\n        auto ls = line.split(\"\\t\");\n        matrix ~= to!(double[])(ls);\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D range) are re-thrown on a\n    call to $(D popFront).\n\n    Warning:\n\n    Using the range returned by this function in a parallel foreach loop\n    will not work because buffers may be overwritten while the task that\n    processes them is in queue.  This is checked for at compile time\n    and will result in a static assertion failure.\n",
						"parameters": [
							{
								"name": "C1",
								"kind": "type"
							},
							{
								"name": "C2",
								"kind": "type"
							}
						],
						"constraint": "is(typeof(C2.init()) : bool) && ParameterTypeTuple!C1.length == 1 && ParameterTypeTuple!C2.length == 0 && isArray!(ParameterTypeTuple!C1[0])",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"members": [
									{
										"endchar": 9,
										"name": "reduce",
										"line": 2433,
										"type": "(Args args)",
										"parameters": [
											{
												"name": "args",
												"type": "Args"
											}
										],
										"endline": 2722,
										"char": 14,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "reduce",
								"line": 2433,
								"comment": "        Parallel reduce on a random access range.  Except as otherwise noted,\n        usage is similar to $(XREF_PACK algorithm,iteration,_reduce).  This\n        function works by splitting the range to be reduced into work units,\n        which are slices to be reduced in parallel.  Once the results from all\n        work units are computed, a final serial reduction is performed on these\n        results to compute the final answer. Therefore, care must be taken to\n        choose the seed value appropriately.\n\n        Because the reduction is being performed in parallel, $(D functions)\n        must be associative.  For notational simplicity, let # be an\n        infix operator representing $(D functions).  Then, (a # b) # c must equal\n        a # (b # c).  Floating point addition is not associative\n        even though addition in exact arithmetic is.  Summing floating\n        point numbers using this function may give different results than summing\n        serially.  However, for many practical purposes floating point addition\n        can be treated as associative.\n\n        Note that, since $(D functions) are assumed to be associative,\n        additional optimizations are made to the serial portion of the reduction\n        algorithm. These take advantage of the instruction level parallelism of\n        modern CPUs, in addition to the thread-level parallelism that the rest\n        of this module exploits.  This can lead to better than linear speedups\n        relative to $(XREF_PACK algorithm,iteration,_reduce), especially for\n        fine-grained benchmarks like dot products.\n\n        An explicit seed may be provided as the first argument.  If\n        provided, it is used as the seed for all work units and for the final\n        reduction of results from all work units.  Therefore, if it is not the\n        identity value for the operation being performed, results may differ\n        from those generated by $(XREF_PACK algorithm,iteration,_reduce) or\n        depending on how many work units are used.  The next argument must be\n        the range to be reduced.\n        ---\n        // Find the sum of squares of a range in parallel, using\n        // an explicit seed.\n        //\n        // Timings on an Athlon 64 X2 dual core machine:\n        //\n        // Parallel reduce:                     72 milliseconds\n        // Using std.algorithm.reduce instead:  181 milliseconds\n        auto nums = iota(10_000_000.0f);\n        auto sumSquares = taskPool.reduce!\"a + b\"(\n            0.0, std.algorithm.map!\"a * a\"(nums)\n        );\n        ---\n\n        If no explicit seed is provided, the first element of each work unit\n        is used as a seed.  For the final reduction, the result from the first\n        work unit is used as the seed.\n        ---\n        // Find the sum of a range in parallel, using the first\n        // element of each work unit as the seed.\n        auto sum = taskPool.reduce!\"a + b\"(nums);\n        ---\n\n        An explicit work unit size may be specified as the last argument.\n        Specifying too small a work unit size will effectively serialize the\n        reduction, as the final reduction of the result of each work unit will\n        dominate computation time.  If $(D TaskPool.size) for this instance\n        is zero, this parameter is ignored and one work unit is used.\n        ---\n        // Use a work unit size of 100.\n        auto sum2 = taskPool.reduce!\"a + b\"(nums, 100);\n\n        // Work unit size of 100 and explicit seed.\n        auto sum3 = taskPool.reduce!\"a + b\"(0.0, nums, 100);\n        ---\n\n        Parallel reduce supports multiple functions, like\n        $(D std.algorithm.reduce).\n        ---\n        // Find both the min and max of nums.\n        auto minMax = taskPool.reduce!(min, max)(nums);\n        assert(minMax[0] == reduce!min(nums));\n        assert(minMax[1] == reduce!max(nums));\n        ---\n\n        $(B Exception Handling):\n\n        After this function is finished executing, any exceptions thrown\n        are chained together via $(D Throwable.next) and rethrown.  The chaining\n        order is non-deterministic.\n",
								"parameters": [
									{
										"name": "Args",
										"kind": "tuple"
									}
								],
								"char": 14,
								"kind": "template"
							}
						],
						"name": "reduce",
						"line": 2347,
						"comment": "\n",
						"parameters": [
							{
								"name": "functions",
								"kind": "tuple"
							}
						],
						"char": 5,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "workerIndex",
						"line": 2764,
						"comment": "    Gets the index of the current thread relative to this $(D TaskPool).  Any\n    thread not in this pool will receive an index of 0.  The worker threads in\n    this pool receive unique indices of 1 through $(D this.size).\n\n    This function is useful for maintaining worker-local resources.\n\n    Examples:\n    ---\n    // Execute a loop that computes the greatest common\n    // divisor of every number from 0 through 999 with\n    // 42 in parallel.  Write the results out to\n    // a set of files, one for each thread.  This allows\n    // results to be written out without any synchronization.\n\n    import std.conv, std.range, std.numeric, std.stdio;\n\n    void main()\n    {\n        auto filesHandles = new File[taskPool.size + 1];\n        scope(exit) {\n            foreach(ref handle; fileHandles) {\n                handle.close();\n            }\n        }\n\n        foreach(i, ref handle; fileHandles)\n        {\n            handle = File(\"workerResults\" ~ to!string(i) ~ \".txt\");\n        }\n\n        foreach(num; parallel(iota(1_000)))\n        {\n            auto outHandle = fileHandles[taskPool.workerIndex];\n            outHandle.writeln(num, '\\t', gcd(num, 42));\n        }\n    }\n    ---\n",
						"deco": "xFNbNdNfZm",
						"endline": 2769,
						"originalType": "const nothrow @property @safe size_t()",
						"char": 12,
						"kind": "function"
					},
					{
						"members": [
							{
								"name": "WorkerLocalStorage",
								"line": 2816,
								"members": [
									{
										"endchar": 9,
										"name": "get",
										"line": 2909,
										"comment": "        Get the current thread's instance.  Returns by ref.\n        Note that calling $(D get) from any thread\n        outside the $(D TaskPool) that created this instance will return the\n        same reference, so an instance of worker-local storage should only be\n        accessed from one thread outside the pool that created it.  If this\n        rule is violated, undefined behavior will result.\n\n        If assertions are enabled and $(D toRange) has been called, then this\n        WorkerLocalStorage instance is no longer worker-local and an assertion\n        failure will result when calling this method.  This is not checked\n        when assertions are disabled for performance reasons.\n",
										"type": "@property ref T()",
										"endline": 2916,
										"char": 15,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "get",
										"line": 2922,
										"comment": "        Assign a value to the current thread's instance.  This function has\n        the same caveats as its overload.\n",
										"type": "@property void(T val)",
										"parameters": [
											{
												"name": "val",
												"type": "T"
											}
										],
										"endline": 2930,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "toRange",
										"line": 2942,
										"comment": "        Returns a range view of the values for all threads, which can be used\n        to further process the results of each thread after running the parallel\n        part of your algorithm.  Do not use this method in the parallel portion\n        of your algorithm.\n\n        Calling this function sets a flag indicating that this struct is no\n        longer worker-local, and attempting to use the $(D get) method again\n        will result in an assertion failure if assertions are enabled.\n",
										"type": "@property WorkerLocalStorageRange!T()",
										"endline": 2959,
										"char": 35,
										"kind": "function"
									}
								],
								"char": 12,
								"kind": "struct"
							}
						],
						"name": "WorkerLocalStorage",
						"line": 2816,
						"comment": "    Struct for creating worker-local storage.  Worker-local storage is\n    thread-local storage that exists only for worker threads in a given\n    $(D TaskPool) plus a single thread outside the pool.  It is allocated on the\n    garbage collected heap in a way that avoids _false sharing, and doesn't\n    necessarily have global scope within any thread.  It can be accessed from\n    any worker thread in the $(D TaskPool) that created it, and one thread\n    outside this $(D TaskPool).  All threads outside the pool that created a\n    given instance of worker-local storage share a single slot.\n\n    Since the underlying data for this struct is heap-allocated, this struct\n    has reference semantics when passed between functions.\n\n    The main uses cases for $(D WorkerLocalStorageStorage) are:\n\n    1.  Performing parallel reductions with an imperative, as opposed to\n    functional, programming style.  In this case, it's useful to treat\n    $(D WorkerLocalStorageStorage) as local to each thread for only the parallel\n    portion of an algorithm.\n\n    2.  Recycling temporary buffers across iterations of a parallel foreach loop.\n\n    Examples:\n    ---\n    // Calculate pi as in our synopsis example, but\n    // use an imperative instead of a functional style.\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0L / n;\n\n    auto sums = taskPool.workerLocalStorage(0.0L);\n    foreach(i; parallel(iota(n)))\n    {\n        immutable x = ( i - 0.5L ) * delta;\n        immutable toAdd = delta / ( 1.0 + x * x );\n        sums.get += toAdd;\n    }\n\n    // Add up the results from each worker thread.\n    real pi = 0;\n    foreach(threadResult; sums.toRange)\n    {\n        pi += 4.0L * threadResult;\n    }\n    ---\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "WorkerLocalStorageRange",
								"line": 2974,
								"members": [],
								"char": 12,
								"kind": "struct"
							}
						],
						"name": "WorkerLocalStorageRange",
						"line": 2974,
						"comment": "    Range primitives for worker-local storage.  The purpose of this is to\n    access results produced by each worker thread from a single thread once you\n    are no longer using the worker-local storage from multiple threads.\n    Do not use this struct in the parallel portion of your algorithm.\n\n    The proper way to instantiate this object is to call\n    $(D WorkerLocalStorage.toRange).  Once instantiated, this object behaves\n    as a finite random-access range with assignable, lvalue elements and\n    a length equal to the number of worker threads in the $(D TaskPool) that\n    created it plus 1.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "workerLocalStorage",
								"line": 3059,
								"type": "WorkerLocalStorage!T(lazy T initialVal = T.init)",
								"parameters": [
									{
										"name": "initialVal",
										"type": "T",
										"storageClass": [
											"lazy"
										],
										"default": "T.init"
									}
								],
								"endline": 3074,
								"char": 26,
								"kind": "function"
							}
						],
						"name": "workerLocalStorage",
						"line": 3059,
						"comment": "    Creates an instance of worker-local storage, initialized with a given\n    value.  The value is $(D lazy) so that you can, for example, easily\n    create one instance of a class for each worker.  For usage example,\n    see the $(D WorkerLocalStorage) struct.\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 26,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "stop",
						"line": 3087,
						"comment": "    Signals to all worker threads to terminate as soon as they are finished\n    with their current $(D Task), or immediately if they are not executing a\n    $(D Task).  $(D Task)s that were in queue will not be executed unless\n    a call to $(D Task.workForce), $(D Task.yieldForce) or $(D Task.spinForce)\n    causes them to be executed.\n\n    Use only if you have waited on every $(D Task) and therefore know the\n    queue is empty, or if you speculatively executed some tasks and no longer\n    need the results.\n",
						"deco": "FNeZv",
						"endline": 3093,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "finish",
						"line": 3108,
						"comment": "    Signals worker threads to terminate when the queue becomes empty.\n\n    If blocking argument is true, wait for all worker threads to terminate\n    before returning.  This option might be used in applications where\n    task results are never consumed-- e.g. when $(D TaskPool) is employed as a\n    rudimentary scheduler for tasks which communicate by means other than\n    return values.\n\n    Warning:  Calling this function with $(D blocking = true) from a worker\n              thread that is a member of the same $(D TaskPool) that\n              $(D finish) is being called on will result in a deadlock.\n",
						"deco": "FNebZv",
						"parameters": [
							{
								"name": "blocking",
								"deco": "b",
								"default": "false"
							}
						],
						"endline": 3136,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "size",
						"line": 3139,
						"comment": "Returns the number of worker threads in the pool.\n",
						"deco": "xFNaNbNdNfZm",
						"endline": 3142,
						"originalType": "const pure nothrow @property @safe size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "put",
								"line": 3176,
								"type": "void(ref Task!(fun, Args) task)",
								"parameters": [
									{
										"name": "task",
										"type": "Task!(fun, Args)",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 3181,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "put",
						"line": 3176,
						"comment": "    Put a $(D Task) object on the back of the task queue.  The $(D Task)\n    object may be passed by pointer or reference.\n\n    Example:\n    ---\n    import std.file;\n\n    // Create a task.\n    auto t = task!read(\"foo.txt\");\n\n    // Add it to the queue to be executed.\n    taskPool.put(t);\n    ---\n\n    Notes:\n\n    @trusted overloads of this function are called for $(D Task)s if\n    $(XREF traits, hasUnsharedAliasing) is false for the $(D Task)'s\n    return type or the function the $(D Task) executes is $(D pure).\n    $(D Task) objects that meet all other requirements specified in the\n    $(D @trusted) overloads of $(D task) and $(D scopedTask) may be created\n    and executed from $(D @safe) code via $(D Task.executeInNewThread) but\n    not via $(D TaskPool).\n\n    While this function takes the address of variables that may\n    be on the stack, some overloads are marked as @trusted.\n    $(D Task) includes a destructor that waits for the task to complete\n    before destroying the stack frame it is allocated on.  Therefore,\n    it is impossible for the stack frame to be destroyed before the task is\n    complete and no longer referenced by a $(D TaskPool).\n",
						"parameters": [
							{
								"name": "fun",
								"kind": "alias"
							},
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "!isSafeReturn!(typeof(task))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "put",
								"line": 3184,
								"type": "void(Task!(fun, Args)* task)",
								"parameters": [
									{
										"name": "task",
										"type": "Task!(fun, Args)*"
									}
								],
								"endline": 3189,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "put",
						"line": 3184,
						"comment": "Ditto\n",
						"parameters": [
							{
								"name": "fun",
								"kind": "alias"
							},
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "!isSafeReturn!(typeof(*task))",
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 3221,
						"comment": "    These properties control whether the worker threads are daemon threads.\n    A daemon thread is automatically terminated when all non-daemon threads\n    have terminated.  A non-daemon thread will prevent a program from\n    terminating as long as it has not terminated.\n\n    If any $(D TaskPool) with non-daemon threads is active, either $(D stop)\n    or $(D finish) must be called on it before the program can terminate.\n\n    The worker treads in the $(D TaskPool) instance returned by the\n    $(D taskPool) property are daemon by default.  The worker threads of\n    manually instantiated task pools are non-daemon by default.\n\n    Note:  For a size zero pool, the getter arbitrarily returns true and the\n           setter has no effect.\n",
						"deco": "FNdNeZb",
						"endline": 3226,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "isDaemon",
						"line": 3229,
						"comment": "Ditto\n",
						"deco": "FNdNebZv",
						"parameters": [
							{
								"name": "newVal",
								"deco": "b"
							}
						],
						"endline": 3237,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "priority",
						"line": 3248,
						"comment": "    These functions allow getting and setting the OS scheduling priority of\n    the worker threads in this $(D TaskPool).  They forward to\n    $(D core.thread.Thread.priority), so a given priority value here means the\n    same thing as an identical priority value in $(D core.thread).\n\n    Note:  For a size zero pool, the getter arbitrarily returns\n           $(D core.thread.Thread.PRIORITY_MIN) and the setter has no effect.\n",
						"deco": "FNdNeZi",
						"endline": 3252,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "priority",
						"line": 3255,
						"comment": "Ditto\n",
						"deco": "FNdNeiZv",
						"parameters": [
							{
								"name": "newPriority",
								"deco": "i"
							}
						],
						"endline": 3264,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "taskPool",
				"line": 3274,
				"comment": "Returns a lazily initialized global instantiation of $(D TaskPool).\nThis function can safely be called concurrently from multiple non-worker\nthreads.  The worker threads in this pool are daemon threads, meaning that it\nis not necessary to call $(D TaskPool.stop) or $(D TaskPool.finish) before\nterminating the main thread.\n",
				"deco": "FNdNeZC3std11parallelism8TaskPool",
				"endline": 3294,
				"char": 20,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "defaultPoolThreads",
				"line": 3308,
				"comment": "These properties get and set the number of worker threads in the $(D TaskPool)\ninstance returned by $(D taskPool).  The default value is $(D totalCPUs) - 1.\nCalling the setter after the first call to $(D taskPool) does not changes\nnumber of worker threads in the instance returned by $(D taskPool).\n",
				"deco": "FNdNeZk",
				"endline": 3311,
				"char": 16,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "defaultPoolThreads",
				"line": 3314,
				"comment": "Ditto\n",
				"deco": "FNdNekZv",
				"parameters": [
					{
						"name": "newVal",
						"deco": "k"
					}
				],
				"endline": 3317,
				"char": 16,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parallel",
						"line": 3337,
						"type": "ParallelForeach!R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 3340,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "parallel",
				"line": 3337,
				"comment": "Convenience functions that forwards to $(D taskPool.parallel).  The\npurpose of these is to make parallel foreach less verbose and more\nreadable.\n\nExample:\n---\n// Find the logarithm of every number from\n// 1 to 1_000_000 in parallel, using the\n// default TaskPool instance.\nauto logs = new double[1_000_000];\n\nforeach(i, ref elem; parallel(logs)) {\n    elem = log(i + 1.0);\n}\n---\n\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parallel",
						"line": 3343,
						"type": "ParallelForeach!R(R range, size_t workUnitSize)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "workUnitSize",
								"type": "size_t"
							}
						],
						"endline": 3346,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "parallel",
				"line": 3343,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			}
		],
		"comment": "$(D std._parallelism) implements high-level primitives for SMP _parallelism.\nThese include parallel foreach, parallel reduce, parallel eager map, pipelining\nand future/promise _parallelism.  $(D std._parallelism) is recommended when the\nsame operation is to be executed in parallel on different data, or when a\nfunction is to be executed in a background thread and its result returned to a\nwell-defined main thread.  For communication between arbitrary threads, see\n$(D std.concurrency).\n\n$(D std._parallelism) is based on the concept of a $(D Task).  A $(D Task) is an\nobject that represents the fundamental unit of work in this library and may be\nexecuted in parallel with any other $(D Task).  Using $(D Task)\ndirectly allows programming with a future/promise paradigm.  All other\nsupported _parallelism paradigms (parallel foreach, map, reduce, pipelining)\nrepresent an additional level of abstraction over $(D Task).  They\nautomatically create one or more $(D Task) objects, or closely related types\nthat are conceptually identical but not part of the public API.\n\nAfter creation, a $(D Task) may be executed in a new thread, or submitted\nto a $(D TaskPool) for execution.  A $(D TaskPool) encapsulates a task queue\nand its worker threads.  Its purpose is to efficiently map a large\nnumber of $(D Task)s onto a smaller number of threads.  A task queue is a\nFIFO queue of $(D Task) objects that have been submitted to the\n$(D TaskPool) and are awaiting execution.  A worker thread is a thread that\nis associated with exactly one task queue.  It executes the $(D Task) at the\nfront of its queue when the queue has work available, or sleeps when\nno work is available.  Each task queue is associated with zero or\nmore worker threads.  If the result of a $(D Task) is needed before execution\nby a worker thread has begun, the $(D Task) can be removed from the task queue\nand executed immediately in the thread where the result is needed.\n\nWarning:  Unless marked as $(D @trusted) or $(D @safe), artifacts in\n          this module allow implicit data sharing between threads and cannot\n          guarantee that client code is free from low level data races.\n\nSynopsis:\n\n---\nimport std.algorithm, std.parallelism, std.range;\n\nvoid main() {\n    // Parallel reduce can be combined with\n    // std.algorithm.map to interesting effect.\n    // The following example (thanks to Russel Winder)\n    // calculates pi by quadrature  using\n    // std.algorithm.map and TaskPool.reduce.\n    // getTerm is evaluated in parallel as needed by\n    // TaskPool.reduce.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // TaskPool.reduce:       12.170 s\n    // std.algorithm.reduce:  24.065 s\n\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0 / n;\n\n    real getTerm(int i)\n    {\n        immutable x = ( i - 0.5 ) * delta;\n        return delta / ( 1.0 + x * x ) ;\n    }\n\n    immutable pi = 4.0 * taskPool.reduce!\"a + b\"(\n        std.algorithm.map!getTerm(iota(n))\n    );\n}\n---\n\nSource:    $(PHOBOSSRC std/_parallelism.d)\nAuthor:  David Simcha\nCopyright:  Copyright (c) 2009-2011, David Simcha.\nLicense:    $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/uni.d",
		"name": "std.uni",
		"members": [
			{
				"name": "lineSep",
				"line": 690,
				"comment": "Constant $(CODEPOINT) (0x2028) - line separator.\n",
				"deco": "w",
				"init": "'\\U00002028'",
				"char": 19,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "paraSep",
				"line": 691,
				"comment": "Constant $(CODEPOINT) (0x2029) - paragraph separator.\n",
				"deco": "w",
				"init": "'\\U00002029'",
				"char": 19,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "nelSep",
				"line": 692,
				"comment": "Constant $(CODEPOINT) (0x0085) - next line.\n",
				"deco": "w",
				"init": "'\\x85'",
				"char": 19,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [],
				"name": "isCodepointSet",
				"line": 1825,
				"comment": "    Tests if T is some kind a set of code points. Intended for template constraints.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isIntegralPair",
						"line": 1846,
						"init": "is(typeof((T x)\n{\nV a = x[0];\nV b = x[1];\n}\n)) && !is(typeof((T x)\n{\nV c = x[2];\n}\n))",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isIntegralPair",
				"line": 1844,
				"comment": "    Tests if $(D T) is a pair of integers that implicitly convert to $(D V).\n    The following code must compile for any pair $(D T):\n    ---\n    (T x){ V a = x[0]; V b = x[1];}\n    ---\n    The following must not compile:\n     ---\n    (T x){ V c = x[2];}\n    ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"defaultDeco": "k",
						"name": "V",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"name": "CodepointSet",
				"line": 1855,
				"comment": "    The recommended default type for set of $(CODEPOINTS).\n    For details, see the current implementation: $(LREF InversionList).\n",
				"deco": "S3std3uni38__T13InversionListTS3std3uni8GcPolicyZ13InversionList",
				"char": 8,
				"kind": "alias"
			},
			{
				"name": "CodepointInterval",
				"line": 1868,
				"comment": "    The recommended type of $(XREF _typecons, Tuple)\n    to represent [a, b$(RPAREN) intervals of $(CODEPOINTS). As used in $(LREF InversionList).\n    Any interval type should pass $(LREF isIntegralPair) trait.\n",
				"members": [],
				"char": 8,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "InversionList",
						"line": 1963,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 1972,
										"type": "pure (Set set)",
										"parameters": [
											{
												"name": "set",
												"type": "Set"
											}
										],
										"endline": 1982,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 1972,
								"comment": "        Construct from another code point set of any type.\n",
								"parameters": [
									{
										"name": "Set",
										"kind": "type"
									}
								],
								"constraint": "isCodepointSet!Set",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 1987,
										"type": "pure (Range intervals)",
										"parameters": [
											{
												"name": "intervals",
												"type": "Range"
											}
										],
										"endline": 1998,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 1987,
								"comment": "        Construct a set from a forward range of code point intervals.\n",
								"parameters": [
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "isForwardRange!Range && isIntegralPair!(ElementType!Range)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 2047,
										"type": "(uint[] intervals...)",
										"parameters": [
											{
												"name": "intervals",
												"type": "uint[]"
											}
										],
										"endline": 2062,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 2047,
								"comment": "        Construct a set from plain values of code point intervals.\n        Example:\n        ---\n        import std.algorithm;\n        auto set = CodepointSet('a', 'z'+1, 'Ð°', 'Ñ'+1);\n        foreach(v; 'a'..'z'+1)\n            assert(set[v]);\n        // Cyrillic lowercase interval\n        foreach(v; 'Ð°'..'Ñ'+1)\n            assert(set[v]);\n        //specific order is not required, intervals may interesect\n        auto set2 = CodepointSet('Ð°', 'Ñ'+1, 'a', 'd', 'b', 'z'+1);\n        //the same end result\n        assert(set2.byInterval.equal(set.byInterval));\n        ---\n",
								"parameters": [],
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "byInterval",
								"line": 2074,
								"comment": "        Get range that spans all of the $(CODEPOINT) intervals in this $(LREF InversionList).\n\n        Example:\n        ---\n        import std.algorithm, std.typecons;\n        auto set = CodepointSet('A', 'D'+1, 'a', 'd'+1);\n        set.byInterval.equal([tuple('A', 'E'), tuple('a', 'e')]);\n        ---\n",
								"type": "@property ()",
								"endline": 2077,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "opIndex",
								"line": 2091,
								"comment": "        Tests the presence of code point $(D val) in this set.\n\n        Example:\n        ---\n        auto gothic = unicode.Gothic;\n        // Gothic letter ahsa\n        assert(gothic['\\U00010330']);\n        // no ascii in Gothic obviously\n        assert(!gothic['$']);\n        ---\n",
								"type": "const bool(uint val)",
								"parameters": [
									{
										"name": "val",
										"deco": "k"
									}
								],
								"endline": 2096,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 2112,
								"comment": "Number of $(CODEPOINTS) in this set\n",
								"type": "@property size_t()",
								"endline": 2120,
								"char": 22,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 2159,
										"type": "This(U rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "U"
											}
										],
										"endline": 2194,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 2159,
								"comment": "        $(P Sets support natural syntax for set algebra, namely: )\n        $(BOOKTABLE ,\n            $(TR $(TH Operator) $(TH Math notation) $(TH Description) )\n            $(TR $(TD &) $(TD a â© b) $(TD intersection) )\n            $(TR $(TD |) $(TD a âª b) $(TD union) )\n            $(TR $(TD -) $(TD a â b) $(TD subtraction) )\n            $(TR $(TD ~) $(TD a ~ b) $(TD symmetric set difference i.e. (a âª b) \\ (a â© b)) )\n        )\n\n        Example:\n        ---\n        auto lower = unicode.LowerCase;\n        auto upper = unicode.UpperCase;\n        auto ascii = unicode.ASCII;\n\n        assert((lower & upper).empty); // no intersection\n        auto lowerASCII = lower & ascii;\n        assert(lowerASCII.byCodepoint.equal(iota('a', 'z'+1)));\n        // throw away all of the lowercase ASCII\n        assert((ascii - lower).length == 128 - 26);\n\n        auto onlyOneOf = lower ~ ascii;\n        assert(!onlyOneOf['Î']); // not ASCII and not lowercase\n        assert(onlyOneOf['$']); // ASCII and not lowercase\n        assert(!onlyOneOf['a']); // ASCII and lowercase\n        assert(onlyOneOf['Ñ']); // not ASCII but lowercase\n\n        // throw away all cased letters from ASCII\n        auto noLetters = ascii - (lower | upper);\n        assert(noLetters.length == 128 - 26*2);\n        ---\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isCodepointSet!U || is(U : dchar)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2197,
										"type": "ref This(U rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "U"
											}
										],
										"endline": 2223,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2197,
								"comment": "The 'op=' versions of the above overloaded operators.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isCodepointSet!U || is(U : dchar)",
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 2229,
										"type": "const bool(U ch)",
										"parameters": [
											{
												"name": "ch",
												"type": "U"
											}
										],
										"endline": 2233,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 2229,
								"comment": "        Tests the presence of codepoint $(D ch) in this set,\n        the same as $(LREF opIndex).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2236_1831)\n---\nassert('Ñ' in unicode.Cyrillic);\nassert(!('z' in unicode.Cyrillic));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2236_1831)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"in\"",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "is(U : dchar)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opUnary",
										"line": 2249,
										"type": "()",
										"endline": 2252,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "opUnary",
								"line": 2249,
								"comment": " Obtains a set that is the inversion of this set.\n\n See_Also: $(LREF inverted)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"!\"",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "byCodepoint",
								"line": 2264,
								"comment": "        A range that spans each $(CODEPOINT) in this set.\n\n        Example:\n        ---\n        import std.algorithm;\n        auto set = unicode.ASCII;\n        set.byCodepoint.equal(iota(0, 0x80));\n        ---\n",
								"type": "@property ()",
								"endline": 2302,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 2330,
								"comment": " Obtain a textual representation of this InversionList\n in form of open-right intervals.\n\n The formatting flag is applied individually to each value, for example:\n $(LI $(B %s) and $(B %d) format the intervals as a [low..high$(RPAREN) range of integrals)\n $(LI $(B %x) formats the intervals as a [low..high$(RPAREN) range of lowercase hex characters)\n $(LI $(B %X) formats the intervals as a [low..high$(RPAREN) range of uppercase hex characters)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2354_1832)\n---\nimport std.conv : to;\nimport std.format : format;\nimport std.uni : unicode;\n\nassert(unicode.Cyrillic.to!string ==\n    \"[1024..1157) [1159..1320) [7467..7468) [7544..7545) [11744..11776) [42560..42648) [42655..42656)\");\n\n// The specs '%s' and '%d' are equivalent to the to!string call above.\nassert(format(\"%d\", unicode.Cyrillic) == unicode.Cyrillic.to!string);\n\nassert(format(\"%#x\", unicode.Cyrillic) ==\n    \"[0x400..0x485) [0x487..0x528) [0x1d2b..0x1d2c) [0x1d78..0x1d79) [0x2de0..0x2e00) [0xa640..0xa698) [0xa69f..0xa6a0)\");\n\nassert(format(\"%#X\", unicode.Cyrillic) ==\n    \"[0X400..0X485) [0X487..0X528) [0X1D2B..0X1D2C) [0X1D78..0X1D79) [0X2DE0..0X2E00) [0XA640..0XA698) [0XA69F..0XA6A0)\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2354_1832)\n",
								"type": "void(scope void delegate(const(char)[]) sink, FormatSpec!char fmt)",
								"parameters": [
									{
										"name": "sink",
										"type": "void delegate(const(char)[])",
										"storageClass": [
											"scope"
										]
									},
									{
										"name": "fmt",
										"type": "FormatSpec!char"
									}
								],
								"endline": 2351,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "add",
										"line": 2395,
										"type": "ref (uint a, uint b)",
										"parameters": [
											{
												"name": "a",
												"deco": "k"
											},
											{
												"name": "b",
												"deco": "k"
											}
										],
										"endline": 2399,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "add",
								"line": 2395,
								"comment": "        Add an interval [a, b$(RPAREN) to this set.\n\n        Example:\n        ---\n        CodepointSet someSet;\n        someSet.add('0', '5').add('A','Z'+1);\n        someSet.add('5', '9'+1);\n        assert(someSet['0']);\n        assert(someSet['5']);\n        assert(someSet['9']);\n        assert(someSet['Z']);\n        ---\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2427_1834)\n---\nassert(unicode.Cyrillic.intersect('-').byInterval.empty);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2427_1834)\n",
								"parameters": [],
								"char": 9,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "inverted",
								"line": 2481,
								"comment": "        Obtains a set that is the inversion of this set.\n\n        See the '!' $(LREF opUnary) for the same but using operators.\n\n        Example:\n        ---\n        set = unicode.ASCII;\n        // union with the inverse gets all of the code points in the Unicode\n        assert((set | set.inverted).length == 0x110000);\n        // no intersection with the inverse\n        assert((set & set.inverted).empty);\n        ---\n",
								"type": "@property ()",
								"endline": 2501,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "toSourceCode",
								"line": 2545,
								"comment": "        Generates string with D source code of unary function with name of\n        $(D funcName) taking a single $(D dchar) argument. If $(D funcName) is empty\n        the code is adjusted to be a lambda function.\n\n        The function generated tests if the $(CODEPOINT) passed\n        belongs to this set or not. The result is to be used with string mixin.\n        The intended usage area is aggressive optimization via meta programming\n        in parser generators and the like.\n\n        Note: Use with care for relatively small or regular sets. It\n        could end up being slower then just using multi-staged tables.\n\n        Example:\n        ---\n        import std.stdio;\n\n        // construct set directly from [a, b$RPAREN intervals\n        auto set = CodepointSet(10, 12, 45, 65, 100, 200);\n        writeln(set);\n        writeln(set.toSourceCode(\"func\"));\n        ---\n\n        The above outputs something along the lines of:\n        ---\n        bool func(dchar ch)  @safe pure nothrow @nogc\n        {\n            if(ch < 45)\n            {\n                if(ch == 10 || ch == 11) return true;\n                return false;\n            }\n            else if (ch < 65) return true;\n            else\n            {\n                if(ch < 100) return false;\n                if(ch < 200) return true;\n                return false;\n            }\n        }\n        ---\n",
								"type": "string(string funcName = \"\")",
								"parameters": [
									{
										"name": "funcName",
										"type": "string",
										"default": "\"\""
									}
								],
								"endline": 2638,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 2649,
								"comment": "        True if this set doesn't contain any $(CODEPOINTS).\n        Example:\n        ---\n        CodepointSet emptySet;\n        assert(emptySet.length == 0);\n        assert(emptySet.empty);\n        ---\n",
								"type": "const @property bool()",
								"endline": 2652,
								"char": 20,
								"kind": "function"
							}
						],
						"char": 17,
						"kind": "struct"
					}
				],
				"name": "InversionList",
				"line": 1963,
				"comment": "    $(P\n    $(D InversionList) is a set of $(CODEPOINTS)\n    represented as an array of open-right [a, b$(RPAREN)\n    intervals (see $(LREF CodepointInterval) above).\n    The name comes from the way the representation reads left to right.\n    For instance a set of all values [10, 50$(RPAREN), [80, 90$(RPAREN),\n    plus a singular value 60 looks like this:\n    )\n    ---\n    10, 50, 60, 61, 80, 90\n    ---\n    $(P\n    The way to read this is: start with negative meaning that all numbers\n    smaller then the next one are not present in this set (and positive\n    - the contrary). Then switch positive/negative after each\n    number passed from left to right.\n    )\n    $(P This way negative spans until 10, then positive until 50,\n    then negative until 60, then positive until 61, and so on.\n    As seen this provides a space-efficient storage of highly redundant data\n    that comes in long runs. A description which Unicode $(CHARACTER)\n    properties fit nicely. The technique itself could be seen as a variation\n    on $(LUCKY RLE encoding).\n    )\n\n    $(P Sets are value types (just like $(D int) is) thus they\n        are never aliased.\n    )\n        Example:\n        ---\n        auto a = CodepointSet('a', 'z'+1);\n        auto b = CodepointSet('A', 'Z'+1);\n        auto c = a;\n        a = a | b;\n        assert(a == CodepointSet('A', 'Z'+1, 'a', 'z'+1));\n        assert(a != c);\n        ---\n    $(P See also $(LREF unicode) for simpler construction of sets\n        from predefined ones.\n    )\n\n    $(P Memory usage is 8 bytes per each contiguous interval in a set.\n    The value semantics are achieved by using the\n    $(WEB en.wikipedia.org/wiki/Copy-on-write, COW) technique\n    and thus it's $(RED not) safe to cast this type to $(D_KEYWORD shared).\n    )\n\n    Note:\n    $(P It's not recommended to rely on the template parameters\n    or the exact type of a current $(CODEPOINT) set in $(D std.uni).\n    The type and parameters may change when the standard\n    allocators design is finalized.\n    Use $(LREF isCodepointSet) with templates or just stick with the default\n    alias $(LREF CodepointSet) throughout the whole code base.\n    )\n",
				"parameters": [
					{
						"name": "SP",
						"default": "GcPolicy",
						"kind": "type"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "codepointSetTrie",
								"line": 4195,
								"type": "(Set set)",
								"parameters": [
									{
										"name": "set",
										"type": "Set"
									}
								],
								"endline": 4202,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "codepointSetTrie",
						"line": 4195,
						"parameters": [
							{
								"name": "Set",
								"kind": "type"
							}
						],
						"constraint": "isCodepointSet!Set",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "codepointSetTrie",
				"line": 4192,
				"comment": "    A shorthand for creating a custom multi-level fixed Trie\n    from a $(D CodepointSet). $(D sizes) are numbers of bits per level,\n    with the most significant bits used first.\n\n    Note: The sum of $(D sizes) must be equal 21.\n\n    See_Also: $(LREF toTrie), which is even simpler.\n\n    Example:\n    ---\n    {\n        import std.stdio;\n        auto set = unicode(\"Number\");\n        auto trie = codepointSetTrie!(8, 5, 8)(set);\n        writeln(\"Input code points to test:\");\n        foreach(line; stdin.byLine)\n        {\n            int count=0;\n            foreach(dchar ch; line)\n                if(trie[ch])// is number\n                    count++;\n            writefln(\"Contains %d number code points.\", count);\n        }\n    }\n    ---\n",
				"parameters": [
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CodepointSetTrie",
						"line": 4210,
						"type": "typeof(TrieBuilder!(bool, dchar, lastDchar + 1, Prefix)(false).build())",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CodepointSetTrie",
				"line": 4206,
				"comment": "Type of Trie generated by codepointSetTrie function.\n",
				"parameters": [
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "codepointTrie",
								"line": 4285,
								"type": "(T[dchar] map, T defValue = T.init)",
								"parameters": [
									{
										"name": "map",
										"type": "T[dchar]"
									},
									{
										"name": "defValue",
										"type": "T",
										"default": "T.init"
									}
								],
								"endline": 4288,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "codepointTrie",
						"line": 4285,
						"parameters": [],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "codepointTrie",
								"line": 4291,
								"type": "(R range, T defValue = T.init)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									},
									{
										"name": "defValue",
										"type": "T",
										"default": "T.init"
									}
								],
								"endline": 4299,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "codepointTrie",
						"line": 4291,
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!R && is(typeof(ElementType!R.init[0]) : T) && is(typeof(ElementType!R.init[1]) : dchar)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "codepointTrie",
				"line": 4271,
				"comment": "    A slightly more general tool for building fixed $(D Trie)\n    for the Unicode data.\n\n    Specifically unlike $(D codepointSetTrie) it's allows creating mappings\n    of $(D dchar) to an arbitrary type $(D T).\n\n    Note: Overload taking $(D CodepointSet)s will naturally convert\n    only to bool mapping $(D Trie)s.\n\n    Example:\n    ---\n    // pick characters from the Greek script\n    auto set = unicode.Greek;\n\n    // a user-defined property (or an expensive function)\n    // that we want to look up\n    static uint luckFactor(dchar ch)\n    {\n        // here we consider a character lucky\n        // if its code point has a lot of identical hex-digits\n        // e.g. arabic letter DDAL (\\u0688) has a \"luck factor\" of 2\n        ubyte[6] nibbles; // 6 4-bit chunks of code point\n        uint value = ch;\n        foreach(i; 0..6)\n        {\n            nibbles[i] = value & 0xF;\n            value >>= 4;\n        }\n        uint luck;\n        foreach(n; nibbles)\n            luck = cast(uint)max(luck, count(nibbles[], n));\n        return luck;\n    }\n\n    // only unsigned built-ins are supported at the moment\n    alias LuckFactor = BitPacked!(uint, 3);\n\n    // create a temporary associative array (AA)\n    LuckFactor[dchar] map;\n    foreach(ch; set.byCodepoint)\n        map[ch] = luckFactor(ch);\n\n    // bits per stage are chosen randomly, fell free to optimize\n    auto trie = codepointTrie!(LuckFactor, 8, 5, 8)(map);\n\n    // from now on the AA is not needed\n    foreach(ch; set.byCodepoint)\n        assert(trie[ch] == luckFactor(ch)); // verify\n    // CJK is not Greek, thus it has the default value\n    assert(trie['\\u4444'] == 0);\n    // and here is a couple of quite lucky Greek characters:\n    // Greek small letter epsilon with dasia\n    assert(trie['\\u1F11'] == 3);\n    // Ancient Greek metretes sign\n    assert(trie['\\U00010181'] == 3);\n    ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CodepointTrie",
						"line": 4357,
						"type": "typeof(TrieBuilder!(T, dchar, lastDchar + 1, Prefix)(T.init).build())",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CodepointTrie",
				"line": 4353,
				"comment": "Type of Trie as generated by codepointTrie function.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "sizes",
						"kind": "tuple"
					}
				],
				"constraint": "sumOfIntegerTuple!sizes == 21",
				"char": 8,
				"kind": "template"
			},
			{
				"name": "MatcherConcept",
				"line": 4528,
				"comment": "    Conceptual type that outlines the common properties of all UTF Matchers.\n\n    Note: For illustration purposes only, every method\n    call results in assertion failure.\n    Use $(LREF utfMatcher) to obtain a concrete matcher\n    for UTF-8 or UTF-16 encodings.\n",
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "match",
								"line": 4547,
								"type": "bool(ref Range inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Range",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 4551,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "match",
						"line": 4547,
						"comment": "        $(P Perform a semantic equivalent 2 operations:\n        decoding a $(CODEPOINT) at front of $(D inp) and testing if\n        it belongs to the set of $(CODEPOINTS) of this matcher. )\n\n        $(P The effect on $(D inp) depends on the kind of function called:)\n\n        $(P Match. If the codepoint is found in the set then range $(D inp)\n        is advanced by its size in $(S_LINK Code unit, code units),\n        otherwise the range is not modifed.)\n\n        $(P Skip. The range is always advanced by the size\n        of the tested $(CODEPOINT) regardless of the result of test.)\n\n        $(P Test. The range is left unaffected regardless\n        of the result of test.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4567_1845)\n---\nstring truth = \"2Â² = 4\";\nauto m = utfMatcher!char(unicode.Number);\nassert(m.match(truth)); // '2' is a number all right\nassert(truth == \"Â² = 4\"); // skips on match\nassert(m.match(truth)); // so is the superscript '2'\nassert(!m.match(truth)); // space is not a number\nassert(truth == \" = 4\"); // unaffected on no match\nassert(!m.skip(truth)); // same test ...\nassert(truth == \"= 4\"); // but skips a codepoint regardless\nassert(!m.test(truth)); // '=' is not a number\nassert(truth == \"= 4\"); // test never affects argument\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4567_1845)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4604_1846)\n---\nauto m = utfMatcher!char(unicode.Number);\nstring square = \"2Â²\";\n// about sub-matchers\nassert(!m.subMatcher!(2,3,4).test(square)); // ASCII no covered\nassert(m.subMatcher!1.match(square)); // ASCII-only, works\nassert(!m.subMatcher!1.test(square)); // unicode 'Â²'\nassert(m.subMatcher!(2,3,4).match(square));  //\nassert(square == \"\");\nwstring wsquare = \"2Â²\";\nauto m16 = utfMatcher!wchar(unicode.Number);\n// may keep ref, but the orignal (m16) must be kept alive\nauto bmp = m16.subMatcher!1;\nassert(bmp.match(wsquare)); // Okay, in basic multilingual plan\nassert(bmp.match(wsquare)); // And 'Â²' too\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4604_1846)\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Range && is(ElementType!Range : char)",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "skip",
								"line": 4554,
								"type": "bool(ref Range inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Range",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 4558,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "skip",
						"line": 4554,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Range && is(ElementType!Range : char)",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "test",
								"line": 4561,
								"type": "bool(ref Range inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Range",
										"storageClass": [
											"ref"
										]
									}
								],
								"endline": 4565,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "test",
						"line": 4561,
						"comment": "ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRandomAccessRange!Range && is(ElementType!Range : char)",
						"char": 17,
						"kind": "template"
					}
				],
				"char": 8,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "isUtfMatcher",
						"line": 4626,
						"init": "__traits(compiles, ()\n{\nC[] s;\nauto d = s.decoder;\nM m;\nassert(is(typeof(m.match(d)) == bool));\nassert(is(typeof(m.test(d)) == bool));\nstatic if (is(typeof(m.skip(d))))\n{\nassert(is(typeof(m.skip(d)) == bool));\nassert(is(typeof(m.skip(s)) == bool));\n}\n\nassert(is(typeof(m.match(s)) == bool));\nassert(is(typeof(m.test(s)) == bool));\n}\n)",
						"char": 13,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUtfMatcher",
				"line": 4626,
				"comment": "    Test if $(D M) is an UTF Matcher for ranges of $(D Char).\n",
				"parameters": [
					{
						"name": "M",
						"kind": "type"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "utfMatcher",
						"line": 5208,
						"type": "@trusted (Set set)",
						"parameters": [
							{
								"name": "set",
								"type": "Set"
							}
						],
						"endline": 5220,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "utfMatcher",
				"line": 5208,
				"comment": "    Constructs a matcher object\n    to classify $(CODEPOINTS) from the $(D set) for encoding\n    that has $(D Char) as code unit.\n\n    See $(LREF MatcherConcept) for API outline.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Set",
						"kind": "type"
					}
				],
				"constraint": "isCodepointSet!Set",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toTrie",
						"line": 5432,
						"type": "(Set set)",
						"parameters": [
							{
								"name": "set",
								"type": "Set"
							}
						],
						"endline": 5446,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toTrie",
				"line": 5432,
				"comment": "    Convenience function to construct optimal configurations for\n    packed Trie from any $(D set) of $(CODEPOINTS).\n\n    The parameter $(D level) indicates the number of trie levels to use,\n    allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs\n    speed-size wise.\n\n    $(P Level 1 is fastest and the most memory hungry (a bit array). )\n    $(P Level 4 is the slowest and has the smallest footprint. )\n\n    See the $(S_LINK Synopsis, Synopsis) section for example.\n\n    Note:\n    Level 4 stays very practical (being faster and more predictable)\n    compared to using direct lookup on the $(D set) itself.\n\n\n",
				"parameters": [
					{
						"name": "level",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "Set",
						"kind": "type"
					}
				],
				"constraint": "isCodepointSet!Set",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toDelegate",
						"line": 5458,
						"type": "(Set set)",
						"parameters": [
							{
								"name": "set",
								"type": "Set"
							}
						],
						"endline": 5464,
						"char": 13,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toDelegate",
				"line": 5458,
				"comment": "    $(P Builds a $(D Trie) with typically optimal speed-size trade-off\n    and wraps it into a delegate of the following type:\n    $(D bool delegate(dchar ch)). )\n\n    $(P Effectively this creates a 'tester' lambda suitable\n    for algorithms like std.algorithm.find that take unary predicates. )\n\n    See the $(S_LINK Synopsis, Synopsis) section for example.\n",
				"parameters": [
					{
						"name": "Set",
						"kind": "type"
					}
				],
				"constraint": "isCodepointSet!Set",
				"char": 13,
				"kind": "template"
			},
			{
				"name": "unicode",
				"line": 6080,
				"comment": "    A single entry point to lookup Unicode $(CODEPOINT) sets by name or alias of\n    a block, script or general category.\n\n    It uses well defined standard rules of property name lookup.\n    This includes fuzzy matching of names, so that\n    'White_Space', 'white-SpAce' and 'whitespace' are all considered equal\n    and yield the same set of white space $(CHARACTERS).\n",
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "opDispatch",
								"line": 6117,
								"type": "pure @property ()",
								"endline": 6123,
								"char": 27,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "opDispatch",
						"line": 6117,
						"comment": "        Performs the lookup of set of $(CODEPOINTS)\n        with compile-time correctness checking.\n        This short-cut version combines 3 searches:\n        across blocks, scripts, and common binary properties.\n\n        Note that since scripts and blocks overlap the\n        usual trick to disambiguate is used - to get a block use\n        $(D unicode.InBlockName), to search a script\n        use $(D unicode.ScriptName).\n\n        See_Also: $(LREF block), $(LREF script)\n        and (not included in this search) $(LREF hangulSyllableType).\n\n        Example:\n        ---\n        auto ascii = unicode.ASCII;\n        assert(ascii['A']);\n        assert(ascii['~']);\n        assert(!ascii['\\u00e0']);\n        // matching is case-insensitive\n        assert(ascii == unicode.ascII);\n        assert(!ascii['Ã ']);\n        // underscores, '-' and whitespace in names are ignored too\n        auto latin = unicode.in_latin1_Supplement;\n        assert(latin['Ã ']);\n        assert(!latin['$']);\n        // BTW Latin 1 Supplement is a block, hence \"In\" prefix\n        assert(latin == unicode(\"In Latin 1 Supplement\"));\n        import std.exception;\n        // run-time look up throws if no such set is found\n        assert(collectException(unicode(\"InCyrilliac\")));\n        ---\n",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"char": 27,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCall",
								"line": 6135,
								"type": "(in C[] name)",
								"parameters": [
									{
										"name": "name",
										"type": "C[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 6139,
								"char": 17,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "opCall",
						"line": 6135,
						"comment": "        The same lookup across blocks, scripts, or binary properties,\n        but performed at run-time.\n        This version is provided for cases where $(D name)\n        is not known beforehand; otherwise compile-time\n        checked $(LREF opDispatch) is typically a better choice.\n\n        See the $(S_LINK Unicode properties, table of properties) for available\n        sets.\n",
						"parameters": [
							{
								"name": "C",
								"kind": "type"
							}
						],
						"constraint": "is(C : dchar)",
						"char": 17,
						"kind": "template"
					},
					{
						"name": "block",
						"line": 6158,
						"comment": "        Narrows down the search for sets of $(CODEPOINTS) to all Unicode blocks.\n\n        Note:\n        Here block names are unambiguous as no scripts are searched\n        and thus to search use simply $(D unicode.block.BlockName) notation.\n\n        See $(S_LINK Unicode properties, table of properties) for available sets.\n\n        Example:\n        ---\n        // use .block for explicitness\n        assert(unicode.block.Greek_and_Coptic == unicode.InGreek_and_Coptic);\n        ---\n\n        See_Also: $(S_LINK Unicode properties, table of properties).\n",
						"members": [],
						"char": 5,
						"kind": "struct"
					},
					{
						"name": "script",
						"line": 6182,
						"comment": "        Narrows down the search for sets of $(CODEPOINTS) to all Unicode scripts.\n\n        See the $(S_LINK Unicode properties, table of properties) for available\n        sets.\n\n        Example:\n        ---\n        auto arabicScript = unicode.script.arabic;\n        auto arabicBlock = unicode.block.arabic;\n        // there is an intersection between script and block\n        assert(arabicBlock['Ø']);\n        assert(arabicScript['Ø']);\n        // but they are different\n        assert(arabicBlock != arabicScript);\n        assert(arabicBlock == unicode.inArabic);\n        assert(arabicScript == unicode.arabic);\n        ---\n",
						"members": [],
						"char": 5,
						"kind": "struct"
					},
					{
						"name": "hangulSyllableType",
						"line": 6208,
						"comment": "        Fetch a set of $(CODEPOINTS) that have the given hangul syllable type.\n\n        Other non-binary properties (once supported) follow the same\n        notation - $(D unicode.propertyName.propertyValue) for compile-time\n        checked access and $(D unicode.propertyName(propertyValue))\n        for run-time checked one.\n\n        See the $(S_LINK Unicode properties, table of properties) for available\n        sets.\n\n        Example:\n        ---\n        // L here is syllable type not Letter as in unicode.L short-cut\n        auto leadingVowel = unicode.hangulSyllableType(\"L\");\n        // check that some leading vowels are present\n        foreach(vowel; '\\u1110'..'\\u115F')\n            assert(leadingVowel[vowel]);\n        assert(leadingVowel == unicode.hangulSyllableType.L);\n        ---\n",
						"members": [],
						"char": 5,
						"kind": "struct"
					}
				],
				"char": 14,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "graphemeStride",
						"line": 6452,
						"type": "size_t(in C[] input, size_t index)",
						"parameters": [
							{
								"name": "input",
								"type": "C[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 6459,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "graphemeStride",
				"line": 6452,
				"comment": "    Computes the length of grapheme cluster starting at $(D index).\n    Both the resulting length and the $(D index) are measured\n    in $(S_LINK Code unit, code units).\n\n    Params:\n        C = type that is implicitly convertible to $(D dchars)\n        input = array of grapheme clusters\n        index = starting index into $(D input[])\n\n    Returns:\n        length of grapheme cluster\n\n    Example:\n    ---\n    // ASCII as usual is 1 code unit, 1 code point etc.\n    assert(graphemeStride(\"  \", 1) == 1);\n    // A + combing ring above\n    string city = \"A\\u030Arhus\";\n    size_t first = graphemeStride(city, 0);\n    assert(first == 3); //\\u030A has 2 UTF-8 code units\n    assert(city[0..first] == \"A\\u030A\");\n    assert(city[first..$] == \"rhus\");\n    ---\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C : dchar)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeGrapheme",
						"line": 6482,
						"type": "Grapheme(ref Input inp)",
						"parameters": [
							{
								"name": "inp",
								"type": "Input",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 6486,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "decodeGrapheme",
				"line": 6482,
				"comment": "    Reads one full grapheme cluster from an input range of dchar $(D inp).\n\n    For examples see the $(LREF Grapheme) below.\n\n    Note:\n    This function modifies $(D inp) and thus $(D inp)\n    must be an L-value.\n",
				"parameters": [
					{
						"name": "Input",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Input && is(Unqual!(ElementType!Input) == dchar)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byGrapheme",
						"line": 6513,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 6549,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byGrapheme",
				"line": 6513,
				"comment": "    $(P Iterate a string by grapheme.)\n\n    $(P Useful for doing string manipulation that needs to be aware\n    of graphemes.)\n\n    See_Also:\n        $(LREF byCodePoint)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6552_1876)\n---\nimport std.conv;\nimport std.range;\nimport std.algorithm;\nauto text = \"noe\\u0308l\"; // noÃ«l using e + combining diaeresis\nassert(text.walkLength == 5); // 5 code points\n\nauto gText = text.byGrapheme;\nassert(gText.walkLength == 4); // 4 graphemes\n\nassert(gText.take(3).equal(\"noe\\u0308\".byGrapheme));\nassert(gText.drop(3).equal(\"l\".byGrapheme));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6552_1876)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodePoint",
						"line": 6615,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 6655,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byCodePoint",
				"line": 6615,
				"comment": "    $(P Lazily transform a range of $(LREF Grapheme)s to a range of code points.)\n\n    $(P Useful for converting the result to a string after doing operations\n    on graphemes.)\n\n    $(P Acts as the identity function when given a range of code points.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6665_1878)\n---\nimport std.conv : text;\nimport std.range;\n\nstring s = \"noe\\u0308l\"; // noÃ«l\n\n// reverse it and convert the result to a string\nstring reverse = s.byGrapheme\n    .array\n    .retro\n    .byCodePoint\n    .text;\n\nassert(reverse == \"le\\u0308on\"); // lÃ«on\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6665_1878)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == Grapheme)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodePoint",
						"line": 6658,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 6662,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "byCodePoint",
				"line": 6658,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar)",
				"char": 7,
				"kind": "template"
			},
			{
				"name": "Grapheme",
				"line": 6733,
				"comment": "    $(P A structure designed to effectively pack $(CHARACTERS)\n    of a $(CLUSTER).\n    )\n\n    $(P $(D Grapheme) has value semantics so 2 copies of a $(D Grapheme)\n    always refer to distinct objects. In most actual scenarios a $(D Grapheme)\n    fits on the stack and avoids memory allocation overhead for all but quite\n    long clusters.\n    )\n\n    Example:\n    ---\n    import std.algorithm;\n    string bold = \"ku\\u0308hn\";\n\n    // note that decodeGrapheme takes parameter by ref\n    // slicing a grapheme yields a range of dchar\n    assert(decodeGrapheme(bold)[].equal(\"k\"));\n\n    // the next grapheme is 2 characters long\n    auto wideOne = decodeGrapheme(bold);\n    assert(wideOne.length == 2);\n    assert(wideOne[].equal(\"u\\u0308\"));\n\n    // the usual range manipulation is possible\n    assert(wideOne[].filter!isMark.equal(\"\\u0308\"));\n    ---\n\n    See_Also: $(LREF decodeGrapheme), $(LREF graphemeStride)\n",
				"members": [
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 6752,
						"comment": "Gets a $(CODEPOINT) at the given index in this cluster.\n",
						"deco": "xFNaNbNiNemZw",
						"parameters": [
							{
								"name": "index",
								"deco": "m"
							}
						],
						"endline": 6756,
						"originalType": "const pure nothrow @nogc @trusted dchar(size_t index)",
						"char": 11,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 6775,
						"comment": "        Writes a $(CODEPOINT) $(D ch) at given index in this cluster.\n\n        Warning:\n        Use of this facility may invalidate grapheme cluster,\n        see also $(LREF Grapheme.valid).\n\n        Example:\n        ---\n        auto g = Grapheme(\"A\\u0302\");\n        assert(g[0] == 'A');\n        assert(g.valid);\n        g[1] = '~'; // ASCII tilda is not a combining mark\n        assert(g[1] == '~');\n        assert(!g.valid);\n        ---\n",
						"deco": "FNaNbNiNewmZv",
						"parameters": [
							{
								"name": "ch",
								"deco": "w"
							},
							{
								"name": "index",
								"deco": "m"
							}
						],
						"endline": 6779,
						"originalType": "pure nothrow @nogc @trusted void(dchar ch, size_t index)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 6787,
						"comment": "        Random-access range over Grapheme's $(CHARACTERS).\n\n        Warning: Invalidates when this Grapheme leaves the scope,\n        attempts to use it then would lead to memory corruption.\n",
						"deco": "FNaNbNimmZS3std3uni41__T16SliceOverIndexedTS3std3uni8GraphemeZ16SliceOverIndexed",
						"parameters": [
							{
								"name": "a",
								"deco": "m"
							},
							{
								"name": "b",
								"deco": "m"
							}
						],
						"endline": 6790,
						"originalType": "pure nothrow @nogc @system (size_t a, size_t b)",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "opSlice",
						"line": 6793,
						"comment": "ditto\n",
						"deco": "FNaNbNiZS3std3uni41__T16SliceOverIndexedTS3std3uni8GraphemeZ16SliceOverIndexed",
						"endline": 6796,
						"originalType": "pure nothrow @nogc @system ()",
						"char": 18,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 6799,
						"comment": "Grapheme cluster length in $(CODEPOINTS).\n",
						"deco": "xFNaNbNdNiNeZm",
						"endline": 6802,
						"originalType": "const pure nothrow @nogc @property @trusted size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 6825,
								"type": "ref (dchar ch)",
								"parameters": [
									{
										"name": "ch",
										"deco": "w"
									}
								],
								"endline": 6852,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 6825,
						"comment": "        Append $(CHARACTER) $(D ch) to this grapheme.\n        Warning:\n        Use of this facility may invalidate grapheme cluster,\n        see also $(D valid).\n\n        Example:\n        ---\n        auto g = Grapheme(\"A\");\n        assert(g.valid);\n        g ~= '\\u0301';\n        assert(g[].equal(\"A\\u0301\"));\n        assert(g.valid);\n        g ~= \"B\";\n        // not a valid grapheme cluster anymore\n        assert(!g.valid);\n        // still could be useful though\n        assert(g[].equal(\"A\\u0301B\"));\n        ---\n        See_Also: $(LREF Grapheme.valid)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 6855,
								"type": "ref (Input inp)",
								"parameters": [
									{
										"name": "inp",
										"type": "Input"
									}
								],
								"endline": 6866,
								"char": 9,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 6855,
						"comment": "Append all $(CHARACTERS) from the input range $(D inp) to this Grapheme.\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							},
							{
								"name": "Input",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Input && is(ElementType!Input : dchar)",
						"char": 9,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "valid",
								"line": 6877,
								"type": "@property bool()",
								"endline": 6882,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "valid",
						"line": 6877,
						"comment": "        True if this object contains valid extended grapheme cluster.\n        Decoding primitives of this module always return a valid $(D Grapheme).\n\n        Appending to and direct manipulation of grapheme's $(CHARACTERS) may\n        render it no longer valid. Certain applications may chose to use\n        Grapheme as a \"small string\" of any $(CODEPOINTS) and ignore this property\n        entirely.\n",
						"parameters": [],
						"char": 20,
						"kind": "template"
					}
				],
				"char": 10,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sicmp",
						"line": 7085,
						"type": "int(S1 str1, S2 str2)",
						"parameters": [
							{
								"name": "str1",
								"type": "S1"
							},
							{
								"name": "str2",
								"type": "S2"
							}
						],
						"endline": 7127,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "sicmp",
				"line": 7085,
				"comment": "    $(P Does basic case-insensitive comparison of strings $(D str1) and $(D str2).\n    This function uses simpler comparison rule thus achieving better performance\n    than $(LREF icmp). However keep in mind the warning below.)\n\n    Params:\n        str1 = a string or a $(D ForwardRange) of $(D dchar)s\n        str2 = a string or a $(D ForwardRange) of $(D dchar)s\n\n    Returns:\n        An $(D int) that is 0 if the strings match,\n        &lt;0 if $(D str1) is lexicographically \"less\" than $(D str2),\n        &gt;0 if $(D str1) is lexicographically \"greater\" than $(D str2)\n\n    Warning:\n    This function only handles 1:1 $(CODEPOINT) mapping\n    and thus is not sufficient for certain alphabets\n    like German, Greek and few others.\n\n    Example:\n    ---\n    assert(sicmp(\"ÐÐ²Ð³ÑÑÑ\", \"Ð°Ð²Ð³ÑÑÐ¢\") == 0);\n    // Greek also works as long as there is no 1:M mapping in sight\n    assert(sicmp(\"ÎÎ\", \"ÏÏ\") == 0);\n    // things like the following won't get matched as equal\n    // Greek small letter iota with dialytika and tonos\n    assert(sicmp(\"Î\", \"\\u03B9\\u0308\\u0301\") != 0);\n\n    // while icmp has no problem with that\n    assert(icmp(\"Î\", \"\\u03B9\\u0308\\u0301\") == 0);\n    assert(icmp(\"ÎÎ\", \"ÏÏ\") == 0);\n    ---\n\n    See_Also:\n        $(LREF icmp)\n        $(XREF_PACK algorithm,comparison,cmp)\n",
				"parameters": [
					{
						"name": "S1",
						"kind": "type"
					},
					{
						"name": "S2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!S1 && is(Unqual!(ElementType!S1) == dchar) && isForwardRange!S2 && is(Unqual!(ElementType!S2) == dchar)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "icmp",
						"line": 7191,
						"type": "int(S1 str1, S2 str2)",
						"parameters": [
							{
								"name": "str1",
								"type": "S1"
							},
							{
								"name": "str2",
								"type": "S2"
							}
						],
						"endline": 7221,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "icmp",
				"line": 7191,
				"comment": "    $(P Does case insensitive comparison of $(D str1) and $(D str2).\n    Follows the rules of full case-folding mapping.\n    This includes matching as equal german Ã with \"ss\" and\n    other 1:M $(CODEPOINT) mappings unlike $(LREF sicmp).\n    The cost of $(D icmp) being pedantically correct is\n    slightly worse performance.\n    )\n\n    Example:\n    ---\n    assert(icmp(\"RuÃland\", \"Russland\") == 0);\n    assert(icmp(\"á¾© -> \\u1F70\\u03B9\", \"\\u1F61\\u03B9 -> á¾²\") == 0);\n    ---\n",
				"parameters": [
					{
						"name": "S1",
						"kind": "type"
					},
					{
						"name": "S2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!S1 && is(Unqual!(ElementType!S1) == dchar) && isForwardRange!S2 && is(Unqual!(ElementType!S2) == dchar)",
				"char": 5,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "combiningClass",
				"line": 7387,
				"comment": "    $(P Returns the $(S_LINK Combining class, combining class) of $(D ch).)\n\n    Example:\n    ---\n    // shorten the code\n    alias CC = combiningClass;\n\n    // combining tilda\n    assert(CC('\\u0303') == 230);\n    // combining ring below\n    assert(CC('\\u0325') == 220);\n    // the simple consequence is that  \"tilda\" should be\n    // placed after a \"ring below\" in a sequence\n    ---\n",
				"deco": "FNaNbNiNfwZh",
				"parameters": [
					{
						"name": "ch",
						"deco": "w"
					}
				],
				"endline": 7390,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "Canonical",
						"line": 7405,
						"value": "0",
						"comment": "Canonical decomposition. The result is canonically equivalent sequence.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "Compatibility",
						"line": 7411,
						"value": "1",
						"comment": "         Compatibility decomposition. The result is compatibility equivalent sequence.\n         Note: Compatibility decomposition is a $(B lossy) conversion,\n         typically suitable only for fuzzy matching and internal processing.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "UnicodeDecomposition",
				"line": 7403,
				"comment": "Unicode character decomposition type.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "compose",
				"line": 7443,
				"comment": "    Try to canonically compose 2 $(CHARACTERS).\n    Returns the composed $(CHARACTER) if they do compose and dchar.init otherwise.\n\n    The assumption is that $(D first) comes before $(D second) in the original text,\n    usually meaning that the first is a starter.\n\n    Note: Hangul syllables are not covered by this function.\n    See $(D composeJamo) below.\n\n    Example:\n    ---\n    assert(compose('A','\\u0308') == '\\u00C4');\n    assert(compose('A', 'B') == dchar.init);\n    assert(compose('C', '\\u0301') == '\\u0106');\n    // note that the starter is the first one\n    // thus the following doesn't compose\n    assert(compose('\\u0308', 'A') == dchar.init);\n    ---\n",
				"deco": "FNaNbNewwZw",
				"parameters": [
					{
						"name": "first",
						"deco": "w"
					},
					{
						"name": "second",
						"deco": "w"
					}
				],
				"endline": 7462,
				"char": 14,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decompose",
						"line": 7488,
						"type": "Grapheme(dchar ch)",
						"parameters": [
							{
								"name": "ch",
								"deco": "w"
							}
						],
						"endline": 7507,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "decompose",
				"line": 7488,
				"comment": "    Returns a full $(S_LINK Canonical decomposition, Canonical)\n    (by default) or $(S_LINK Compatibility decomposition, Compatibility)\n    decomposition of $(CHARACTER) $(D ch).\n    If no decomposition is available returns a $(LREF Grapheme)\n    with the $(D ch) itself.\n\n    Note:\n    This function also decomposes hangul syllables\n    as prescribed by the standard.\n\n    See_Also: $(LREF decomposeHangul) for a restricted version\n    that takes into account only hangul syllables  but\n    no other decompositions.\n\n    Example:\n    ---\n    import std.algorithm;\n    assert(decompose('Ä')[].equal(\"C\\u0302\"));\n    assert(decompose('D')[].equal(\"D\"));\n    assert(decompose('\\uD4DC')[].equal(\"\\u1111\\u1171\\u11B7\"));\n    assert(decompose!Compatibility('Â¹').equal(\"1\"));\n    ---\n",
				"parameters": [
					{
						"name": "decompType",
						"defaultValue": "Canonical",
						"deco": "E3std3uni20UnicodeDecomposition",
						"kind": "value"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "decomposeHangul",
				"line": 7600,
				"comment": "    Decomposes a Hangul syllable. If $(D ch) is not a composed syllable\n    then this function returns $(LREF Grapheme) containing only $(D ch) as is.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7617_1889)\n---\nimport std.algorithm;\nassert(decomposeHangul('\\uD4DB')[].equal(\"\\u1111\\u1171\\u11B6\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7617_1889)\n",
				"deco": "FNewZS3std3uni8Grapheme",
				"parameters": [
					{
						"name": "ch",
						"deco": "w"
					}
				],
				"endline": 7614,
				"char": 10,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "composeJamo",
				"line": 7632,
				"comment": "    Try to compose hangul syllable out of a leading consonant ($(D lead)),\n    a $(D vowel) and optional $(D trailing) consonant jamos.\n\n    On success returns the composed LV or LVT hangul syllable.\n\n    If any of $(D lead) and $(D vowel) are not a valid hangul jamo\n    of the respective $(CHARACTER) class returns dchar.init.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7646_1890)\n---\nassert(composeJamo('\\u1111', '\\u1171', '\\u11B6') == '\\uD4DB');\n// leaving out T-vowel, or passing any codepoint\n// that is not trailing consonant composes an LV-syllable\nassert(composeJamo('\\u1111', '\\u1171') == '\\uD4CC');\nassert(composeJamo('\\u1111', '\\u1171', ' ') == '\\uD4CC');\nassert(composeJamo('\\u1111', 'A') == dchar.init);\nassert(composeJamo('A', '\\u1171') == dchar.init);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7646_1890)\n",
				"deco": "FNaNbNiNewwwZw",
				"parameters": [
					{
						"name": "lead",
						"deco": "w"
					},
					{
						"name": "vowel",
						"deco": "w"
					},
					{
						"name": "trailing",
						"deco": "w",
						"default": "'\\U0000ffff'"
					}
				],
				"endline": 7643,
				"originalType": "pure nothrow @nogc @trusted dchar(dchar lead, dchar vowel, dchar trailing = (dchar).init)",
				"char": 7,
				"kind": "function"
			},
			{
				"members": [],
				"name": "NormalizationForm",
				"line": 7684,
				"comment": "    Enumeration type for normalization forms,\n    passed as template parameter for functions like $(LREF normalize).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "NFC",
				"line": 7696,
				"value": "(NormalizationForm).NFC",
				"comment": "        Shorthand aliases from values indicating normalization forms.\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"name": "NFD",
				"line": 7698,
				"value": "(NormalizationForm).NFD",
				"comment": "ditto\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"name": "NFKC",
				"line": 7700,
				"value": "(NormalizationForm).NFKC",
				"comment": "ditto\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"name": "NFKD",
				"line": 7702,
				"value": "(NormalizationForm).NFKD",
				"comment": "ditto\n",
				"char": 5,
				"kind": "enum member"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "normalize",
						"line": 7716,
						"type": "inout(C)[](inout(C)[] input)",
						"parameters": [
							{
								"name": "input",
								"type": "inout(C)[]"
							}
						],
						"endline": 7805,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "normalize",
				"line": 7716,
				"comment": "    Returns $(D input) string normalized to the chosen form.\n    Form C is used by default.\n\n    For more information on normalization forms see\n    the $(S_LINK Normalization, normalization section).\n\n    Note:\n    In cases where the string in question is already normalized,\n    it is returned unmodified and no memory allocation happens.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7808_1892)\n---\n// any encoding works\nwstring greet = \"Hello world\";\nassert(normalize(greet) is greet); // the same exact slice\n\n// An example of a character with all 4 forms being different:\n// Greek upsilon with acute and hook symbol (code point 0x03D3)\nassert(normalize!NFC(\"Ï\") == \"\\u03D3\");\nassert(normalize!NFD(\"Ï\") == \"\\u03D2\\u0301\");\nassert(normalize!NFKC(\"Ï\") == \"\\u038E\");\nassert(normalize!NFKD(\"Ï\") == \"\\u03A5\\u0301\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7808_1892)\n",
				"parameters": [
					{
						"name": "norm",
						"defaultValue": "NFC",
						"deco": "E3std3uni17NormalizationForm",
						"kind": "value"
					},
					{
						"name": "C",
						"kind": "type"
					}
				],
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "allowedIn",
						"line": 7966,
						"type": "bool(dchar ch)",
						"parameters": [
							{
								"name": "ch",
								"deco": "w"
							}
						],
						"endline": 7969,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "allowedIn",
				"line": 7966,
				"comment": "    Tests if dchar $(D ch) is always allowed (Quick_Check=YES) in normalization\n    form $(D norm).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7972_1894)\n---\n// e.g. Cyrillic is always allowed, so is ASCII\nassert(allowedIn!NFC('Ñ'));\nassert(allowedIn!NFD('Ñ'));\nassert(allowedIn!NFKC('Ñ'));\nassert(allowedIn!NFKD('Ñ'));\nassert(allowedIn!NFC('Z'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7972_1894)\n",
				"parameters": [
					{
						"name": "norm",
						"deco": "E3std3uni17NormalizationForm",
						"kind": "value"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isWhite",
				"line": 8051,
				"comment": "    Whether or not $(D c) is a Unicode whitespace $(CHARACTER).\n    (general Unicode category: Part of C0(tab, vertical tab, form feed,\n    carriage return, and linefeed characters), Zs, Zl, Zp, and NEL(U+0085))\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 8054,
				"char": 13,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isLower",
				"line": 8060,
				"comment": "    Return whether $(D c) is a Unicode lowercase $(CHARACTER).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 8066,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isUpper",
				"line": 8093,
				"comment": "    Return whether $(D c) is a Unicode uppercase $(CHARACTER).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 8099,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toLower",
				"line": 8129,
				"comment": "    If $(D c) is a Unicode uppercase $(CHARACTER), then its lowercase equivalent\n    is returned. Otherwise $(D c) is returned.\n\n    Warning: certain alphabets like German and Greek have no 1:1\n    upper-lower mapping. Use overload of toLower which takes full string instead.\n",
				"deco": "FNaNbNiNfwZw",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 8146,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asLowerCase",
						"line": 8315,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 8329,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asLowerCase",
				"line": 8315,
				"comment": " Convert input range or string to upper or lower case.\n\n Does not allocate memory.\n Characters in UTF-8 or UTF-16 format that cannot be decoded\n are treated as $(XREF utf, replacementDchar).\n\n Params:\n      str = string or range of characters\n\n Returns:\n      an InputRange of dchars\n\n See_Also:\n      $(LREF toUpper), $(LREF toLower)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8349_1899)\n---\nimport std.algorithm: equal;\n\nassert(\"hEllo\".asUpperCase.equal(\"HELLO\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8349_1899)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asUpperCase",
						"line": 8332,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 8346,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asUpperCase",
				"line": 8332,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "asCapitalized",
						"line": 8507,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 8521,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "asCapitalized",
				"line": 8507,
				"comment": " Capitalize input range or string, meaning convert the first\n character to upper case and subsequent characters to lower case.\n\n Does not allocate memory.\n Characters in UTF-8 or UTF-16 format that cannot be decoded\n are treated as $(XREF utf, replacementDchar).\n\n Params:\n      str = string or range of characters\n\n Returns:\n      an InputRange of dchars\n\n See_Also:\n      $(LREF toUpper), $(LREF toLower)\n      $(LREF asUpperCase), $(LREF asLowerCase)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8524_1901)\n---\nimport std.algorithm: equal;\n\nassert(\"hEllo\".asCapitalized.equal(\"Hello\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8524_1901)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toLowerInPlace",
						"line": 8837,
						"type": "pure @trusted void(ref C[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 8841,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "toLowerInPlace",
				"line": 8837,
				"comment": "    Converts $(D s) to lowercase (by performing Unicode lowercase mapping) in place.\n    For a few characters string length may increase after the transformation,\n    in such a case the function reallocates exactly once.\n    If $(D s) does not have any uppercase characters, then $(D s) is unaltered.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C == char) || is(C == wchar) || is(C == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUpperInPlace",
						"line": 8859,
						"type": "pure @trusted void(ref C[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "C[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 8863,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "toUpperInPlace",
				"line": 8859,
				"comment": "    Converts $(D s) to uppercase  (by performing Unicode uppercase mapping) in place.\n    For a few characters string length may increase after the transformation,\n    in such a case the function reallocates exactly once.\n    If $(D s) does not have any lowercase characters, then $(D s) is unaltered.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(C == char) || is(C == wchar) || is(C == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toLower",
						"line": 8880,
						"type": "pure @trusted S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 8884,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toLower",
				"line": 8880,
				"comment": "    Returns a string which is identical to $(D s) except that all of its\n    characters are converted to lowercase (by preforming Unicode lowercase mapping).\n    If none of $(D s) characters were affected, then $(D s) itself is returned.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "toUpper",
				"line": 8991,
				"comment": "    If $(D c) is a Unicode lowercase $(CHARACTER), then its uppercase equivalent\n    is returned. Otherwise $(D c) is returned.\n\n    Warning:\n    Certain alphabets like German and Greek have no 1:1\n    upper-lower mapping. Use overload of toUpper which takes full string instead.\n\n    toUpper can be used as an argument to $(XREF_PACK algorithm,iteration,map)\n    to produce an algorithm that can convert a range of characters to upper case\n    without allocating memory.\n    A string can then be produced by using $(XREF_PACK algorithm,mutation,copy)\n    to send it to an $(XREF array, appender).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL9011_1909)\n---\nimport std.algorithm;\nimport std.uni;\nimport std.array;\n\nauto abuf = appender!(char[])();\n\"hello\".map!toUpper.copy(&abuf);\nassert(abuf.data == \"HELLO\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL9011_1909)\n",
				"deco": "FNaNbNiNfwZw",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9008,
				"char": 7,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUpper",
						"line": 9043,
						"type": "pure @trusted S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 9047,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "toUpper",
				"line": 9043,
				"comment": "    Returns a string which is identical to $(D s) except that all of its\n    characters are converted to uppercase (by preforming Unicode uppercase mapping).\n    If none of $(D s) characters were affected, then $(D s) itself is returned.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isAlpha",
				"line": 9151,
				"comment": "    Returns whether $(D c) is a Unicode alphabetic $(CHARACTER)\n    (general Unicode category: Alphabetic).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9169,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isMark",
				"line": 9186,
				"comment": "    Returns whether $(D c) is a Unicode mark\n    (general Unicode category: Mn, Me, Mc).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9189,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isNumber",
				"line": 9205,
				"comment": "    Returns whether $(D c) is a Unicode numerical $(CHARACTER)\n    (general Unicode category: Nd, Nl, No).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9208,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPunctuation",
				"line": 9225,
				"comment": "    Returns whether $(D c) is a Unicode punctuation $(CHARACTER)\n    (general Unicode category: Pd, Ps, Pe, Pc, Po, Pi, Pf).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9228,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSymbol",
				"line": 9248,
				"comment": "    Returns whether $(D c) is a Unicode symbol $(CHARACTER)\n    (general Unicode category: Sm, Sc, Sk, So).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9251,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSpace",
				"line": 9271,
				"comment": "    Returns whether $(D c) is a Unicode space $(CHARACTER)\n    (general Unicode category: Zs)\n    Note: This doesn't include '\\n', '\\r', \\t' and other non-space $(CHARACTER).\n    For commonly used less strict semantics see $(LREF isWhite).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9274,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isGraphical",
				"line": 9293,
				"comment": "    Returns whether $(D c) is a Unicode graphical $(CHARACTER)\n    (general Unicode category: L, M, N, P, S, Zs).\n\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9296,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isControl",
				"line": 9315,
				"comment": "    Returns whether $(D c) is a Unicode control $(CHARACTER)\n    (general Unicode category: Cc).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9318,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isFormat",
				"line": 9338,
				"comment": "    Returns whether $(D c) is a Unicode formatting $(CHARACTER)\n    (general Unicode category: Cf).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9341,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isPrivateUse",
				"line": 9359,
				"comment": "    Returns whether $(D c) is a Unicode Private Use $(CODEPOINT)\n    (general Unicode category: Co).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9364,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSurrogate",
				"line": 9371,
				"comment": "    Returns whether $(D c) is a Unicode surrogate $(CODEPOINT)\n    (general Unicode category: Cs).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9374,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSurrogateHi",
				"line": 9380,
				"comment": "    Returns whether $(D c) is a Unicode high surrogate (lead surrogate).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9383,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSurrogateLo",
				"line": 9389,
				"comment": "    Returns whether $(D c) is a Unicode low surrogate (trail surrogate).\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9392,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isNonCharacter",
				"line": 9400,
				"comment": "    Returns whether $(D c) is a Unicode non-character i.e.\n    a $(CODEPOINT) with no assigned abstract character.\n    (general Unicode category: Cn)\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 9403,
				"char": 6,
				"kind": "function"
			}
		],
		"comment": "    $(P The $(D std.uni) module provides an implementation\n    of fundamental Unicode algorithms and data structures.\n    This doesn't include UTF encoding and decoding primitives,\n    see $(XREF _utf, decode) and $(XREF _utf, encode) in std.utf\n    for this functionality. )\n\n    $(P All primitives listed operate on Unicode characters and\n    sets of characters. For functions which operate on ASCII characters\n    and ignore Unicode $(CHARACTERS), see $(LINK2 std_ascii.html, std.ascii).\n    For definitions of Unicode $(CHARACTER), $(CODEPOINT) and other terms\n    used throughout this module see the $(S_LINK Terminology, terminology) section\n    below.\n    )\n\n    $(P The focus of this module is the core needs of developing Unicode-aware\n    applications. To that effect it provides the following optimized primitives:\n    )\n    $(UL\n    $(LI Character classification by category and common properties:\n        $(LREF isAlpha), $(LREF isWhite) and others.\n    )\n    $(LI\n        Case-insensitive string comparison ($(LREF sicmp), $(LREF icmp)).\n    )\n    $(LI\n        Converting text to any of the four normalization forms via $(LREF normalize).\n    )\n    $(LI\n        Decoding ($(LREF decodeGrapheme))  and iteration ($(LREF byGrapheme), $(LREF graphemeStride))\n        by user-perceived characters, that is by $(LREF Grapheme) clusters.\n    )\n    $(LI\n        Decomposing and composing of individual character(s) according to canonical\n        or compatibility rules, see $(LREF compose) and $(LREF decompose),\n        including the specific version for Hangul syllables $(LREF composeJamo)\n        and $(LREF decomposeHangul).\n    )\n    )\n    $(P It's recognized that an application may need further enhancements\n    and extensions, such as less commonly known algorithms,\n    or tailoring existing ones for region specific needs. To help users\n    with building any extra functionality beyond the core primitives,\n    the module provides:\n    )\n    $(UL\n    $(LI\n        $(LREF CodepointSet), a type for easy manipulation of sets of characters.\n        Besides the typical set algebra it provides an unusual feature:\n        a D source code generator for detection of $(CODEPOINTS) in this set.\n        This is a boon for meta-programming parser frameworks,\n        and is used internally to power classification in small\n        sets like $(LREF isWhite).\n    )\n    $(LI\n        A way to construct optimal packed multi-stage tables also known as a\n        special case of $(LUCKY Trie).\n        The functions $(LREF codepointTrie), $(LREF codepointSetTrie)\n        construct custom tries that map dchar to value.\n        The end result is a fast and predictable $(BIGOH 1) lookup that powers\n        functions like $(LREF isAlpha) and $(LREF combiningClass),\n        but for user-defined data sets.\n    )\n    $(LI\n        A useful technique for Unicode-aware parsers that perform\n        character classification of encoded $(CODEPOINTS)\n        is to avoid unnecassary decoding at all costs.\n        $(LREF utfMatcher) provides an improvement over the usual workflow\n        of decode-classify-process, combining the decoding and classification\n        steps. By extracting necessary bits directly from encoded\n        $(S_LINK Code unit, code units) matchers achieve\n        significant performance improvements. See $(LREF MatcherConcept) for\n        the common interface of UTF matchers.\n    )\n    $(LI\n        Generally useful building blocks for customized normalization:\n        $(LREF combiningClass) for querying combining class\n        and $(LREF allowedIn) for testing the Quick_Check\n        property of a given normalization form.\n    )\n    $(LI\n        Access to a large selection of commonly used sets of $(CODEPOINTS).\n        $(S_LINK Unicode properties, Supported sets) include Script,\n        Block and General Category. The exact contents of a set can be\n        observed in the CLDR utility, on the\n        $(WEB www.unicode.org/cldr/utility/properties.jsp, property index) page\n        of the Unicode website.\n        See $(LREF unicode) for easy and (optionally) compile-time checked set\n        queries.\n    )\n    )\n    $(SECTION Synopsis)\n    ---\n    import std.uni;\n    void main()\n    {\n        // initialize code point sets using script/block or property name\n        // now 'set' contains code points from both scripts.\n        auto set = unicode(\"Cyrillic\") | unicode(\"Armenian\");\n        // same thing but simpler and checked at compile-time\n        auto ascii = unicode.ASCII;\n        auto currency = unicode.Currency_Symbol;\n\n        // easy set ops\n        auto a = set & ascii;\n        assert(a.empty); // as it has no intersection with ascii\n        a = set | ascii;\n        auto b = currency - a; // subtract all ASCII, Cyrillic and Armenian\n\n        // some properties of code point sets\n        assert(b.length > 45); // 46 items in Unicode 6.1, even more in 6.2\n        // testing presence of a code point in a set\n        // is just fine, it is O(logN)\n        assert(!b['$']);\n        assert(!b['\\u058F']); // Armenian dram sign\n        assert(b['Â¥']);\n\n        // building fast lookup tables, these guarantee O(1) complexity\n        // 1-level Trie lookup table essentially a huge bit-set ~262Kb\n        auto oneTrie = toTrie!1(b);\n        // 2-level far more compact but typically slightly slower\n        auto twoTrie = toTrie!2(b);\n        // 3-level even smaller, and a bit slower yet\n        auto threeTrie = toTrie!3(b);\n        assert(oneTrie['Â£']);\n        assert(twoTrie['Â£']);\n        assert(threeTrie['Â£']);\n\n        // build the trie with the most sensible trie level\n        // and bind it as a functor\n        auto cyrillicOrArmenian = toDelegate(set);\n        auto balance = find!(cyrillicOrArmenian)(\"Hello Õ¨Õ¶Õ¯Õ¥Ö!\");\n        assert(balance == \"Õ¨Õ¶Õ¯Õ¥Ö!\");\n        // compatible with bool delegate(dchar)\n        bool delegate(dchar) bindIt = cyrillicOrArmenian;\n\n        // Normalization\n        string s = \"Plain ascii (and not only), is always normalized!\";\n        assert(s is normalize(s));// is the same string\n\n        string nonS = \"A\\u0308ffin\"; // A ligature\n        auto nS = normalize(nonS); // to NFC, the W3C endorsed standard\n        assert(nS == \"Ãffin\");\n        assert(nS != nonS);\n        string composed = \"Ãffin\";\n\n        assert(normalize!NFD(composed) == \"A\\u0308ffin\");\n        // to NFKD, compatibility decomposition useful for fuzzy matching/searching\n        assert(normalize!NFKD(\"2Â¹â°\") == \"210\");\n    }\n    ---\n    $(SECTION Terminology)\n    $(P The following is a list of important Unicode notions\n    and definitions. Any conventions used specifically in this\n    module alone are marked as such. The descriptions are based on the formal\n    definition as found in $(WEB www.unicode.org/versions/Unicode6.2.0/ch03.pdf,\n    chapter three of The Unicode Standard Core Specification.)\n    )\n\n    $(P $(DEF Abstract character) A unit of information used for the organization,\n    control, or representation of textual data.\n    Note that:\n        $(UL\n        $(LI When representing data, the nature of that data\n        is generally symbolic as opposed to some other\n        kind of data (for example, visual).)\n\n        $(LI An abstract character has no concrete form\n        and should not be confused with a $(S_LINK Glyph, glyph).)\n\n        $(LI An abstract character does not necessarily\n        correspond to what a user thinks of as a âcharacterâ\n         and should not be confused with a $(LREF Grapheme).)\n\n        $(LI The abstract characters encoded (see Encoded character)\n        are known as Unicode abstract characters.)\n\n        $(LI Abstract characters not directly\n        encoded by the Unicode Standard can often be\n        represented by the use of combining character sequences.)\n        )\n    )\n\n    $(P $(DEF Canonical decomposition)\n    The decomposition of a character or character sequence\n    that results from recursively applying the canonical\n    mappings found in the Unicode Character Database\n    and these described in Conjoining Jamo Behavior\n    (section 12 of\n    $(WEB www.unicode.org/uni2book/ch03.pdf, Unicode Conformance)).\n    )\n\n    $(P $(DEF Canonical composition)\n    The precise definition of the Canonical composition\n    is the algorithm as specified in $(WEB www.unicode.org/uni2book/ch03.pdf,\n    Unicode Conformance) section 11.\n    Informally it's the process that does the reverse of the canonical\n    decomposition with the addition of certain rules\n    that e.g. prevent legacy characters from appearing in the composed result.\n    )\n\n    $(P $(DEF Canonical equivalent)\n    Two character sequences are said to be canonical equivalents if\n    their full canonical decompositions are identical.\n    )\n\n    $(P $(DEF Character) Typically differs by context.\n    For the purpose of this documentation the term $(I character)\n    implies $(I encoded character), that is, a code point having\n    an assigned abstract character (a symbolic meaning).\n    )\n\n    $(P $(DEF Code point) Any value in the Unicode codespace;\n    that is, the range of integers from 0 to 10FFFF (hex).\n    Not all code points are assigned to encoded characters.\n    )\n\n    $(P $(DEF Code unit) The minimal bit combination that can represent\n    a unit of encoded text for processing or interchange.\n    Depending on the encoding this could be:\n    8-bit code units in the UTF-8 ($(D char)),\n    16-bit code units in the UTF-16 ($(D wchar)),\n    and 32-bit code units in the UTF-32 ($(D dchar)).\n    $(I Note that in UTF-32, a code unit is a code point\n    and is represented by the D $(D dchar) type.)\n    )\n\n    $(P $(DEF Combining character) A character with the General Category\n     of Combining Mark(M).\n        $(UL\n            $(LI All characters with non-zero canonical combining class\n            are combining characters, but the reverse is not the case:\n            there are combining characters with a zero combining class.\n            )\n            $(LI These characters are not normally used in isolation\n            unless they are being described. They include such characters\n            as accents, diacritics, Hebrew points, Arabic vowel signs,\n            and Indic matras.\n            )\n        )\n    )\n\n    $(P $(DEF Combining class)\n        A numerical value used by the Unicode Canonical Ordering Algorithm\n        to determine which sequences of combining marks are to be\n        considered canonically equivalent and  which are not.\n    )\n\n    $(P $(DEF Compatibility decomposition)\n    The decomposition of a character or character sequence that results\n    from recursively applying both the compatibility mappings and\n    the canonical mappings found in the Unicode Character Database, and those\n    described in Conjoining Jamo Behavior no characters\n    can be further decomposed.\n    )\n\n    $(P $(DEF Compatibility equivalent)\n    Two character sequences are said to be compatibility\n    equivalents if their full compatibility decompositions are identical.\n    )\n\n    $(P $(DEF Encoded character) An association (or mapping)\n    between an abstract character and a code point.\n    )\n\n    $(P $(DEF Glyph) The actual, concrete image of a glyph representation\n    having been rasterized or otherwise imaged onto some display surface.\n    )\n\n    $(P $(DEF Grapheme base) A character with the property\n     Grapheme_Base, or any standard Korean syllable block.\n    )\n\n    $(P $(DEF Grapheme cluster) Defined as the text between\n        grapheme boundaries  as specified by Unicode Standard Annex #29,\n        $(WEB www.unicode.org/reports/tr29/, Unicode text segmentation).\n        Important general properties of a grapheme:\n        $(UL\n            $(LI The grapheme cluster represents a horizontally segmentable\n            unit of text, consisting of some grapheme base (which may\n            consist of a Korean syllable) together with any number of\n            nonspacing marks applied to it.\n            )\n            $(LI  A grapheme cluster typically starts with a grapheme base\n            and then extends across any subsequent sequence of nonspacing marks.\n            A grapheme cluster is most directly relevant to text rendering and\n            processes such as cursor placement and text selection in editing,\n            but may also be relevant to comparison and searching.\n            )\n            $(LI For many processes, a grapheme cluster behaves as if it was a\n            single character with the same properties as its grapheme base.\n            Effectively, nonspacing marks apply $(I graphically) to the base,\n            but do not change its properties.\n            )\n        )\n        $(P This module defines a number of primitives that work with graphemes:\n        $(LREF Grapheme), $(LREF decodeGrapheme) and $(LREF graphemeStride).\n        All of them are using $(I extended grapheme) boundaries\n        as defined in the aforementioned standard annex.\n        )\n    )\n\n\n    $(P $(DEF Nonspacing mark) A combining character with the\n        General Category of Nonspacing Mark (Mn) or Enclosing Mark (Me).\n    )\n\n    $(P $(DEF Spacing mark) A combining character that is not a nonspacing mark.)\n\n\n    $(SECTION Normalization)\n\n    $(P The concepts of $(S_LINK Canonical equivalent, canonical equivalent)\n     or $(S_LINK Compatibility equivalent, compatibility equivalent)\n    characters in the Unicode Standard make it necessary to have a full, formal\n    definition of equivalence for Unicode strings.\n    String equivalence is determined by a process called normalization,\n    whereby strings are converted into forms which are compared\n    directly for identity. This is the primary goal of the normalization process,\n    see the function $(LREF normalize) to convert into any of\n    the four defined forms.\n    )\n\n    $(P A very important attribute of the Unicode Normalization Forms\n    is that they must remain stable between versions of the Unicode Standard.\n    A Unicode string normalized to a particular Unicode Normalization Form\n    in one version of the standard is guaranteed to remain in that Normalization\n    Form for implementations of future versions of the standard.\n    )\n\n    $(P The Unicode Standard specifies four normalization forms.\n    Informally, two of these forms are defined by maximal decomposition\n    of equivalent sequences, and two of these forms are defined\n    by maximal $(I composition) of equivalent sequences.\n        $(UL\n        $(LI Normalization Form D (NFD): The $(S_LINK Canonical decomposition,\n            canonical decomposition) of a character sequence.)\n        $(LI Normalization Form KD (NFKD): The $(S_LINK Compatibility decomposition,\n            compatibility decomposition) of a character sequence.)\n        $(LI Normalization Form C (NFC): The canonical composition of the\n            $(S_LINK Canonical decomposition, canonical decomposition)\n            of a coded character sequence.)\n        $(LI Normalization Form KC (NFKC): The canonical composition\n        of the $(S_LINK Compatibility decomposition,\n            compatibility decomposition) of a character sequence)\n        )\n    )\n\n    $(P The choice of the normalization form depends on the particular use case.\n    NFC is the best form for general text, since it's more compatible with\n    strings converted from legacy encodings. NFKC is the preferred form for\n    identifiers, especially where there are security concerns. NFD and NFKD\n    are the most useful for internal processing.\n    )\n\n    $(SECTION Construction of lookup tables)\n\n    $(P The Unicode standard describes a set of algorithms that\n    depend on having the ability to quickly look up various properties\n    of a code point. Given the the codespace of about 1 million $(CODEPOINTS),\n    it is not a trivial task to provide a space-efficient solution for\n    the multitude of properties.)\n\n    $(P Common approaches such as hash-tables or binary search over\n     sorted code point intervals (as in $(LREF InversionList)) are insufficient.\n     Hash-tables have enormous memory footprint and binary search\n     over intervals is not fast enough for some heavy-duty algorithms.\n     )\n\n    $(P The recommended solution (see Unicode Implementation Guidelines)\n    is using multi-stage tables that are an implementation of the\n    $(WEB en.wikipedia.org/wiki/Trie, Trie) data structure with integer\n    keys and a fixed number of stages. For the remainder of the section\n    this will be called a fixed trie. The following describes a particular\n    implementation that is aimed for the speed of access at the expense\n    of ideal size savings.\n    )\n\n    $(P Taking a 2-level Trie as an example the principle of operation is as follows.\n        Split the number of bits in a key (code point, 21 bits) into 2 components\n        (e.g. 15 and 8).  The first is the number of bits in the index of the trie\n         and the other is number of bits in each page of the trie.\n        The layout of the trie is then an array of size 2^^bits-of-index followed\n        an array of memory chunks of size 2^^bits-of-page/bits-per-element.\n    )\n\n    $(P The number of pages is variable (but not less then 1)\n        unlike the number of entries in the index. The slots of the index\n        all have to contain a number of a page that is present. The lookup is then\n        just a couple of operations - slice the upper bits,\n        lookup an index for these, take a page at this index and use\n        the lower bits as an offset within this page.\n\n        Assuming that pages are laid out consequently\n        in one array at $(D pages), the pseudo-code is:\n    )\n    ---\n    auto elemsPerPage = (2 ^^ bits_per_page) / Value.sizeOfInBits;\n    pages[index[n >> bits_per_page]][n & (elemsPerPage - 1)];\n    ---\n    $(P Where if $(D elemsPerPage) is a power of 2 the whole process is\n    a handful of simple instructions and 2 array reads. Subsequent levels\n    of the trie are introduced by recursing on this notion - the index array\n    is treated as values. The number of bits in index is then again\n    split into 2 parts, with pages over 'current-index' and the new 'upper-index'.\n    )\n\n    $(P For completeness a level 1 trie is simply an array.\n    The current implementation takes advantage of bit-packing values\n    when the range is known to be limited in advance (such as $(D bool)).\n    See also $(LREF BitPacked) for enforcing it manually.\n    The major size advantage however comes from the fact\n    that multiple $(B identical pages on every level are merged) by construction.\n    )\n\n    $(P The process of constructing a trie is more involved and is hidden from\n    the user in a form of the convenience functions $(LREF codepointTrie),\n    $(LREF codepointSetTrie) and the even more convenient $(LREF toTrie).\n    In general a set or built-in AA with $(D dchar) type\n    can be turned into a trie. The trie object in this module\n    is read-only (immutable); it's effectively frozen after construction.\n    )\n\n    $(SECTION Unicode properties)\n\n    $(P This is a full list of Unicode properties accessible through $(LREF unicode)\n    with specific helpers per category nested within. Consult the\n    $(WEB www.unicode.org/cldr/utility/properties.jsp, CLDR utility)\n    when in doubt about the contents of a particular set.)\n\n    $(P General category sets listed below are only accessible with the\n    $(LREF unicode) shorthand accessor.)\n    $(BOOKTABLE $(B General category ),\n         $(TR $(TH Abb.) $(TH Long form)\n            $(TH Abb.) $(TH Long form)$(TH Abb.) $(TH Long form))\n        $(TR $(TD L) $(TD Letter)\n            $(TD Cn) $(TD Unassigned)  $(TD Po) $(TD Other_Punctuation))\n        $(TR $(TD Ll) $(TD Lowercase_Letter)\n            $(TD Co) $(TD Private_Use) $(TD Ps) $(TD Open_Punctuation))\n        $(TR $(TD Lm) $(TD Modifier_Letter)\n            $(TD Cs) $(TD Surrogate)   $(TD S) $(TD Symbol))\n        $(TR $(TD Lo) $(TD Other_Letter)\n            $(TD N) $(TD Number)  $(TD Sc) $(TD Currency_Symbol))\n        $(TR $(TD Lt) $(TD Titlecase_Letter)\n          $(TD Nd) $(TD Decimal_Number)  $(TD Sk) $(TD Modifier_Symbol))\n        $(TR $(TD Lu) $(TD Uppercase_Letter)\n          $(TD Nl) $(TD Letter_Number)   $(TD Sm) $(TD Math_Symbol))\n        $(TR $(TD M) $(TD Mark)\n          $(TD No) $(TD Other_Number)    $(TD So) $(TD Other_Symbol))\n        $(TR $(TD Mc) $(TD Spacing_Mark)\n          $(TD P) $(TD Punctuation) $(TD Z) $(TD Separator))\n        $(TR $(TD Me) $(TD Enclosing_Mark)\n          $(TD Pc) $(TD Connector_Punctuation)   $(TD Zl) $(TD Line_Separator))\n        $(TR $(TD Mn) $(TD Nonspacing_Mark)\n          $(TD Pd) $(TD Dash_Punctuation)    $(TD Zp) $(TD Paragraph_Separator))\n        $(TR $(TD C) $(TD Other)\n          $(TD Pe) $(TD Close_Punctuation) $(TD Zs) $(TD Space_Separator))\n        $(TR $(TD Cc) $(TD Control) $(TD Pf)\n          $(TD Final_Punctuation)   $(TD -) $(TD Any))\n        $(TR $(TD Cf) $(TD Format)\n          $(TD Pi) $(TD Initial_Punctuation) $(TD -) $(TD ASCII))\n    )\n    $(P Sets for other commonly useful properties that are\n    accessible with $(LREF unicode):)\n    $(BOOKTABLE $(B Common binary properties),\n        $(TR $(TH Name) $(TH Name) $(TH Name))\n        $(TR $(TD Alphabetic)  $(TD Ideographic) $(TD Other_Uppercase))\n        $(TR $(TD ASCII_Hex_Digit) $(TD IDS_Binary_Operator) $(TD Pattern_Syntax))\n        $(TR $(TD Bidi_Control)    $(TD ID_Start)    $(TD Pattern_White_Space))\n        $(TR $(TD Cased)   $(TD IDS_Trinary_Operator)    $(TD Quotation_Mark))\n        $(TR $(TD Case_Ignorable)  $(TD Join_Control)    $(TD Radical))\n        $(TR $(TD Dash)    $(TD Logical_Order_Exception) $(TD Soft_Dotted))\n        $(TR $(TD Default_Ignorable_Code_Point)    $(TD Lowercase)   $(TD STerm))\n        $(TR $(TD Deprecated)  $(TD Math)    $(TD Terminal_Punctuation))\n        $(TR $(TD Diacritic)   $(TD Noncharacter_Code_Point) $(TD Unified_Ideograph))\n        $(TR $(TD Extender)    $(TD Other_Alphabetic)    $(TD Uppercase))\n        $(TR $(TD Grapheme_Base)   $(TD Other_Default_Ignorable_Code_Point)  $(TD Variation_Selector))\n        $(TR $(TD Grapheme_Extend) $(TD Other_Grapheme_Extend)   $(TD White_Space))\n        $(TR $(TD Grapheme_Link)   $(TD Other_ID_Continue)   $(TD XID_Continue))\n        $(TR $(TD Hex_Digit)   $(TD Other_ID_Start)  $(TD XID_Start))\n        $(TR $(TD Hyphen)  $(TD Other_Lowercase) )\n        $(TR $(TD ID_Continue) $(TD Other_Math)  )\n    )\n    $(P Bellow is the table with block names accepted by $(LREF unicode.block).\n    Note that the shorthand version $(LREF unicode) requires \"In\"\n    to be prepended to the names of blocks so as to disambiguate\n    scripts and blocks.)\n\n    $(BOOKTABLE $(B Blocks),\n        $(TR $(TD Aegean Numbers)    $(TD Ethiopic Extended) $(TD Mongolian))\n        $(TR $(TD Alchemical Symbols)    $(TD Ethiopic Extended-A)   $(TD Musical Symbols))\n        $(TR $(TD Alphabetic Presentation Forms) $(TD Ethiopic Supplement)   $(TD Myanmar))\n        $(TR $(TD Ancient Greek Musical Notation)    $(TD General Punctuation)   $(TD Myanmar Extended-A))\n        $(TR $(TD Ancient Greek Numbers) $(TD Geometric Shapes)  $(TD New Tai Lue))\n        $(TR $(TD Ancient Symbols)   $(TD Georgian)  $(TD NKo))\n        $(TR $(TD Arabic)    $(TD Georgian Supplement)   $(TD Number Forms))\n        $(TR $(TD Arabic Extended-A) $(TD Glagolitic)    $(TD Ogham))\n        $(TR $(TD Arabic Mathematical Alphabetic Symbols)    $(TD Gothic)    $(TD Ol Chiki))\n        $(TR $(TD Arabic Presentation Forms-A)   $(TD Greek and Coptic)  $(TD Old Italic))\n        $(TR $(TD Arabic Presentation Forms-B)   $(TD Greek Extended)    $(TD Old Persian))\n        $(TR $(TD Arabic Supplement) $(TD Gujarati)  $(TD Old South Arabian))\n        $(TR $(TD Armenian)  $(TD Gurmukhi)  $(TD Old Turkic))\n        $(TR $(TD Arrows)    $(TD Halfwidth and Fullwidth Forms) $(TD Optical Character Recognition))\n        $(TR $(TD Avestan)   $(TD Hangul Compatibility Jamo) $(TD Oriya))\n        $(TR $(TD Balinese)  $(TD Hangul Jamo)   $(TD Osmanya))\n        $(TR $(TD Bamum) $(TD Hangul Jamo Extended-A)    $(TD Phags-pa))\n        $(TR $(TD Bamum Supplement)  $(TD Hangul Jamo Extended-B)    $(TD Phaistos Disc))\n        $(TR $(TD Basic Latin)   $(TD Hangul Syllables)  $(TD Phoenician))\n        $(TR $(TD Batak) $(TD Hanunoo)   $(TD Phonetic Extensions))\n        $(TR $(TD Bengali)   $(TD Hebrew)    $(TD Phonetic Extensions Supplement))\n        $(TR $(TD Block Elements)    $(TD High Private Use Surrogates)   $(TD Playing Cards))\n        $(TR $(TD Bopomofo)  $(TD High Surrogates)   $(TD Private Use Area))\n        $(TR $(TD Bopomofo Extended) $(TD Hiragana)  $(TD Rejang))\n        $(TR $(TD Box Drawing)   $(TD Ideographic Description Characters)    $(TD Rumi Numeral Symbols))\n        $(TR $(TD Brahmi)    $(TD Imperial Aramaic)  $(TD Runic))\n        $(TR $(TD Braille Patterns)  $(TD Inscriptional Pahlavi) $(TD Samaritan))\n        $(TR $(TD Buginese)  $(TD Inscriptional Parthian)    $(TD Saurashtra))\n        $(TR $(TD Buhid) $(TD IPA Extensions)    $(TD Sharada))\n        $(TR $(TD Byzantine Musical Symbols) $(TD Javanese)  $(TD Shavian))\n        $(TR $(TD Carian)    $(TD Kaithi)    $(TD Sinhala))\n        $(TR $(TD Chakma)    $(TD Kana Supplement)   $(TD Small Form Variants))\n        $(TR $(TD Cham)  $(TD Kanbun)    $(TD Sora Sompeng))\n        $(TR $(TD Cherokee)  $(TD Kangxi Radicals)   $(TD Spacing Modifier Letters))\n        $(TR $(TD CJK Compatibility) $(TD Kannada)   $(TD Specials))\n        $(TR $(TD CJK Compatibility Forms)   $(TD Katakana)  $(TD Sundanese))\n        $(TR $(TD CJK Compatibility Ideographs)  $(TD Katakana Phonetic Extensions)  $(TD Sundanese Supplement))\n        $(TR $(TD CJK Compatibility Ideographs Supplement)   $(TD Kayah Li)  $(TD Superscripts and Subscripts))\n        $(TR $(TD CJK Radicals Supplement)   $(TD Kharoshthi)    $(TD Supplemental Arrows-A))\n        $(TR $(TD CJK Strokes)   $(TD Khmer) $(TD Supplemental Arrows-B))\n        $(TR $(TD CJK Symbols and Punctuation)   $(TD Khmer Symbols) $(TD Supplemental Mathematical Operators))\n        $(TR $(TD CJK Unified Ideographs)    $(TD Lao)   $(TD Supplemental Punctuation))\n        $(TR $(TD CJK Unified Ideographs Extension A)    $(TD Latin-1 Supplement)    $(TD Supplementary Private Use Area-A))\n        $(TR $(TD CJK Unified Ideographs Extension B)    $(TD Latin Extended-A)  $(TD Supplementary Private Use Area-B))\n        $(TR $(TD CJK Unified Ideographs Extension C)    $(TD Latin Extended Additional) $(TD Syloti Nagri))\n        $(TR $(TD CJK Unified Ideographs Extension D)    $(TD Latin Extended-B)  $(TD Syriac))\n        $(TR $(TD Combining Diacritical Marks)   $(TD Latin Extended-C)  $(TD Tagalog))\n        $(TR $(TD Combining Diacritical Marks for Symbols)   $(TD Latin Extended-D)  $(TD Tagbanwa))\n        $(TR $(TD Combining Diacritical Marks Supplement)    $(TD Lepcha)    $(TD Tags))\n        $(TR $(TD Combining Half Marks)  $(TD Letterlike Symbols)    $(TD Tai Le))\n        $(TR $(TD Common Indic Number Forms) $(TD Limbu) $(TD Tai Tham))\n        $(TR $(TD Control Pictures)  $(TD Linear B Ideograms)    $(TD Tai Viet))\n        $(TR $(TD Coptic)    $(TD Linear B Syllabary)    $(TD Tai Xuan Jing Symbols))\n        $(TR $(TD Counting Rod Numerals) $(TD Lisu)  $(TD Takri))\n        $(TR $(TD Cuneiform) $(TD Low Surrogates)    $(TD Tamil))\n        $(TR $(TD Cuneiform Numbers and Punctuation) $(TD Lycian)    $(TD Telugu))\n        $(TR $(TD Currency Symbols)  $(TD Lydian)    $(TD Thaana))\n        $(TR $(TD Cypriot Syllabary) $(TD Mahjong Tiles) $(TD Thai))\n        $(TR $(TD Cyrillic)  $(TD Malayalam) $(TD Tibetan))\n        $(TR $(TD Cyrillic Extended-A)   $(TD Mandaic)   $(TD Tifinagh))\n        $(TR $(TD Cyrillic Extended-B)   $(TD Mathematical Alphanumeric Symbols) $(TD Transport And Map Symbols))\n        $(TR $(TD Cyrillic Supplement)   $(TD Mathematical Operators)    $(TD Ugaritic))\n        $(TR $(TD Deseret)   $(TD Meetei Mayek)  $(TD Unified Canadian Aboriginal Syllabics))\n        $(TR $(TD Devanagari)    $(TD Meetei Mayek Extensions)   $(TD Unified Canadian Aboriginal Syllabics Extended))\n        $(TR $(TD Devanagari Extended)   $(TD Meroitic Cursive)  $(TD Vai))\n        $(TR $(TD Dingbats)  $(TD Meroitic Hieroglyphs)  $(TD Variation Selectors))\n        $(TR $(TD Domino Tiles)  $(TD Miao)  $(TD Variation Selectors Supplement))\n        $(TR $(TD Egyptian Hieroglyphs)  $(TD Miscellaneous Mathematical Symbols-A)  $(TD Vedic Extensions))\n        $(TR $(TD Emoticons) $(TD Miscellaneous Mathematical Symbols-B)  $(TD Vertical Forms))\n        $(TR $(TD Enclosed Alphanumerics)    $(TD Miscellaneous Symbols) $(TD Yijing Hexagram Symbols))\n        $(TR $(TD Enclosed Alphanumeric Supplement)  $(TD Miscellaneous Symbols and Arrows)  $(TD Yi Radicals))\n        $(TR $(TD Enclosed CJK Letters and Months)   $(TD Miscellaneous Symbols And Pictographs) $(TD Yi Syllables))\n        $(TR $(TD Enclosed Ideographic Supplement)   $(TD Miscellaneous Technical)   )\n        $(TR $(TD Ethiopic)  $(TD Modifier Tone Letters) )\n    )\n\n    $(P Bellow is the table with script names accepted by $(LREF unicode.script)\n    and by the shorthand version $(LREF unicode):)\n    $(BOOKTABLE $(B Scripts),\n        $(TR $(TD Arabic)  $(TD Hanunoo) $(TD Old_Italic))\n        $(TR $(TD Armenian)    $(TD Hebrew)  $(TD Old_Persian))\n        $(TR $(TD Avestan) $(TD Hiragana)    $(TD Old_South_Arabian))\n        $(TR $(TD Balinese)    $(TD Imperial_Aramaic)    $(TD Old_Turkic))\n        $(TR $(TD Bamum)   $(TD Inherited)   $(TD Oriya))\n        $(TR $(TD Batak)   $(TD Inscriptional_Pahlavi)   $(TD Osmanya))\n        $(TR $(TD Bengali) $(TD Inscriptional_Parthian)  $(TD Phags_Pa))\n        $(TR $(TD Bopomofo)    $(TD Javanese)    $(TD Phoenician))\n        $(TR $(TD Brahmi)  $(TD Kaithi)  $(TD Rejang))\n        $(TR $(TD Braille) $(TD Kannada) $(TD Runic))\n        $(TR $(TD Buginese)    $(TD Katakana)    $(TD Samaritan))\n        $(TR $(TD Buhid)   $(TD Kayah_Li)    $(TD Saurashtra))\n        $(TR $(TD Canadian_Aboriginal) $(TD Kharoshthi)  $(TD Sharada))\n        $(TR $(TD Carian)  $(TD Khmer)   $(TD Shavian))\n        $(TR $(TD Chakma)  $(TD Lao) $(TD Sinhala))\n        $(TR $(TD Cham)    $(TD Latin)   $(TD Sora_Sompeng))\n        $(TR $(TD Cherokee)    $(TD Lepcha)  $(TD Sundanese))\n        $(TR $(TD Common)  $(TD Limbu)   $(TD Syloti_Nagri))\n        $(TR $(TD Coptic)  $(TD Linear_B)    $(TD Syriac))\n        $(TR $(TD Cuneiform)   $(TD Lisu)    $(TD Tagalog))\n        $(TR $(TD Cypriot) $(TD Lycian)  $(TD Tagbanwa))\n        $(TR $(TD Cyrillic)    $(TD Lydian)  $(TD Tai_Le))\n        $(TR $(TD Deseret) $(TD Malayalam)   $(TD Tai_Tham))\n        $(TR $(TD Devanagari)  $(TD Mandaic) $(TD Tai_Viet))\n        $(TR $(TD Egyptian_Hieroglyphs)    $(TD Meetei_Mayek)    $(TD Takri))\n        $(TR $(TD Ethiopic)    $(TD Meroitic_Cursive)    $(TD Tamil))\n        $(TR $(TD Georgian)    $(TD Meroitic_Hieroglyphs)    $(TD Telugu))\n        $(TR $(TD Glagolitic)  $(TD Miao)    $(TD Thaana))\n        $(TR $(TD Gothic)  $(TD Mongolian)   $(TD Thai))\n        $(TR $(TD Greek)   $(TD Myanmar) $(TD Tibetan))\n        $(TR $(TD Gujarati)    $(TD New_Tai_Lue) $(TD Tifinagh))\n        $(TR $(TD Gurmukhi)    $(TD Nko) $(TD Ugaritic))\n        $(TR $(TD Han) $(TD Ogham)   $(TD Vai))\n        $(TR $(TD Hangul)  $(TD Ol_Chiki)    $(TD Yi))\n    )\n\n    $(P Bellow is the table of names accepted by $(LREF unicode.hangulSyllableType).)\n    $(BOOKTABLE $(B Hangul syllable type),\n        $(TR $(TH Abb.) $(TH Long form))\n        $(TR $(TD L)   $(TD Leading_Jamo))\n        $(TR $(TD LV)  $(TD LV_Syllable))\n        $(TR $(TD LVT) $(TD LVT_Syllable) )\n        $(TR $(TD T)   $(TD Trailing_Jamo))\n        $(TR $(TD V)   $(TD Vowel_Jamo))\n    )\n    References:\n        $(WEB www.digitalmars.com/d/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org/wiki/Unicode, Wikipedia),\n        $(WEB www.unicode.org, The Unicode Consortium),\n        $(WEB www.unicode.org/reports/tr15/, Unicode normalization forms),\n        $(WEB www.unicode.org/reports/tr29/, Unicode text segmentation)\n        $(WEB www.unicode.org/uni2book/ch05.pdf,\n            Unicode Implementation Guidelines)\n        $(WEB www.unicode.org/uni2book/ch03.pdf,\n            Unicode Conformance)\n    Trademarks:\n        Unicode(tm) is a trademark of Unicode, Inc.\n\n    Macros:\n        WIKI=Phobos/StdUni\n\n    Copyright: Copyright 2013 -\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Dmitry Olshansky\n    Source:    $(PHOBOSSRC std/_uni.d)\n    Standards: $(WEB www.unicode.org/versions/Unicode6.2.0/, Unicode v6.2)\n\nMacros:\n\nSECTION = <h3><a id=\"$1\">$0</a></h3>\nDEF = <div><a id=\"$1\"><i>$0</i></a></div>\nS_LINK = <a href=\"#$1\">$+</a>\nCODEPOINT = $(S_LINK Code point, code point)\nCODEPOINTS = $(S_LINK Code point, code points)\nCHARACTER = $(S_LINK Character, character)\nCHARACTERS = $(S_LINK Character, characters)\nCLUSTER = $(S_LINK Grapheme cluster, grapheme cluster)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/xml.d",
		"name": "std.xml",
		"members": [
			{
				"endchar": 1,
				"name": "isChar",
				"line": 147,
				"comment": " Returns true if the character is a character according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 169,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isSpace",
				"line": 214,
				"comment": " Returns true if the character is whitespace according to the XML standard\n\n Only the following characters are considered whitespace in XML - space, tab,\n carriage return and linefeed\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 217,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isDigit",
				"line": 227,
				"comment": " Returns true if the character is a digit according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 233,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isLetter",
				"line": 252,
				"comment": " Returns true if the character is a letter according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 255,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isIdeographic",
				"line": 266,
				"comment": " Returns true if the character is an ideographic character according to the\n XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 275,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isBaseChar",
				"line": 301,
				"comment": " Returns true if the character is a base character according to the XML\n standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 304,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isCombiningChar",
				"line": 315,
				"comment": " Returns true if the character is a combining character according to the\n XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 318,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "isExtender",
				"line": 328,
				"comment": " Returns true if the character is an extender according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n",
				"deco": "FwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 331,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "encode",
						"line": 357,
						"type": "S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 383,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "encode",
				"line": 357,
				"comment": " Encodes a string by replacing all characters which need to be escaped with\n appropriate predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n If the string is not modified, the original will be returned.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be encoded\n\n Returns: The encoded string\n\n Examples:\n --------------\n writefln(encode(\"a > b\")); // writes \"a &gt; b\"\n --------------\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [],
				"name": "DecodeMode",
				"line": 403,
				"comment": " Mode to use for decoding.\n\n $(DDOC_ENUM_MEMBERS NONE) Do not decode\n $(DDOC_ENUM_MEMBERS LOOSE) Decode, but ignore errors\n $(DDOC_ENUM_MEMBERS STRICT) Decode, and throw exception on error\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "decode",
				"line": 442,
				"comment": " Decodes a string by unescaping all predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n This function decodes the entities &amp;amp;, &amp;quot;, &amp;apos;,\n &amp;lt; and &amp;gt,\n as well as decimal and hexadecimal entities such as &amp;#x20AC;\n\n If the string does not contain an ampersand, the original will be returned.\n\n Note that the \"mode\" parameter can be one of DecodeMode.NONE (do not\n decode), DecodeMode.LOOSE (decode, but ignore errors), or DecodeMode.STRICT\n (decode, and throw a DecodeException in the event of an error).\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be decoded\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if mode == DecodeMode.STRICT and decode fails\n\n Returns: The decoded string\n\n Examples:\n --------------\n writefln(decode(\"a &gt; b\")); // writes \"a > b\"\n --------------\n",
				"deco": "FAyaE3std3xml10DecodeModeZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "Aya"
					},
					{
						"name": "mode",
						"deco": "E3std3xml10DecodeMode",
						"default": "cast(DecodeMode)1"
					}
				],
				"endline": 494,
				"originalType": "string(string s, DecodeMode mode = DecodeMode.LOOSE)",
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"offset": 120,
						"name": "prolog",
						"line": 544,
						"comment": " Contains all text which occurs before the root element.\n Defaults to &lt;?xml version=\"1.0\"?&gt;\n",
						"deco": "Aya",
						"init": "\"<?xml version=\\\"1.0\\\"?>\"",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 136,
						"name": "epilog",
						"line": 549,
						"comment": " Contains all text which occurs after the root element.\n Defaults to the empty string\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 562,
						"comment": " Constructs a Document by parsing XML text.\n\n This function creates a complete DOM (Document Object Model) tree.\n\n The input to this function MUST be valid XML.\n This is enforced by DocumentParser's in contract.\n\n Params:\n      s = the complete XML text.\n",
						"deco": "FAyaZC3std3xml8Document",
						"parameters": [
							{
								"name": "s",
								"deco": "Aya"
							}
						],
						"endline": 576,
						"originalType": "(string s)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 584,
						"comment": " Constructs a Document from a Tag.\n\n Params:\n      tag = the start tag of the document.\n",
						"deco": "FxC3std3xml3TagZC3std3xml8Document",
						"parameters": [
							{
								"name": "tag",
								"deco": "xC3std3xml3Tag"
							}
						],
						"endline": 587,
						"originalType": "(const(Tag) tag)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 600,
						"comment": " Compares two Documents for equality\n\n Examples:\n --------------\n Document d1,d2;\n if (d1 == d2) { }\n --------------\n",
						"deco": "xFC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 608,
						"char": 23,
						"kind": "function",
						"overrides": [
							"std.xml.Element.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 622,
						"comment": " Compares two Documents\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n\n Examples:\n --------------\n Document d1,d2;\n if (d1 < d2) { }\n --------------\n",
						"deco": "xFC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 633,
						"char": 22,
						"kind": "function",
						"overrides": [
							"std.xml.Element.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toHash",
						"line": 641,
						"comment": " Returns the hash of a Document\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n",
						"deco": "xFNbNeZm",
						"endline": 644,
						"originalType": "const @trusted size_t()",
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.xml.Element.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 650,
						"comment": " Returns the string representation of a Document. (That is, the\n complete XML of a document).\n",
						"deco": "xFZAya",
						"endline": 653,
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.xml.Element.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Document",
				"line": 538,
				"comment": " Class representing an XML document.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n",
				"base": "std.xml.Element",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 16,
						"name": "tag",
						"line": 664,
						"comment": "The start tag of the element\n",
						"deco": "C3std3xml3Tag",
						"originalType": "Tag",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "items",
						"line": 665,
						"comment": "The element's items\n",
						"deco": "AC3std3xml4Item",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "texts",
						"line": 666,
						"comment": "The element's text items\n",
						"deco": "AC3std3xml4Text",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "cdatas",
						"line": 667,
						"comment": "The element's CData items\n",
						"deco": "AC3std3xml5CData",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 72,
						"name": "comments",
						"line": 668,
						"comment": "The element's comments\n",
						"deco": "AC3std3xml7Comment",
						"char": 15,
						"kind": "variable"
					},
					{
						"offset": 88,
						"name": "pis",
						"line": 669,
						"comment": "The element's processing instructions\n",
						"deco": "AC3std3xml21ProcessingInstruction",
						"char": 29,
						"kind": "variable"
					},
					{
						"offset": 104,
						"name": "elements",
						"line": 670,
						"comment": "The element's child elements\n",
						"deco": "AC3std3xml7Element",
						"char": 15,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 686,
						"comment": " Constructs an Element given a name and a string to be used as a Text\n interior.\n\n Params:\n      name = the name of the element.\n      interior = (optional) the string interior.\n\n Examples:\n -------------------------------------------------------\n auto element = new Element(\"title\",\"Serenity\")\n     // constructs the element <title>Serenity</title>\n -------------------------------------------------------\n",
						"deco": "FAyaAyaZC3std3xml7Element",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "interior",
								"deco": "Aya",
								"default": "null"
							}
						],
						"endline": 690,
						"originalType": "(string name, string interior = null)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 698,
						"comment": " Constructs an Element from a Tag.\n\n Params:\n      tag_ = the start or empty tag of the element.\n",
						"deco": "FxC3std3xml3TagZC3std3xml7Element",
						"parameters": [
							{
								"name": "tag_",
								"deco": "xC3std3xml3Tag"
							}
						],
						"endline": 704,
						"originalType": "(const(Tag) tag_)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 718,
						"comment": " Append a text item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new Text(\"hello\");\n --------------\n",
						"deco": "FC3std3xml4TextZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml4Text"
							}
						],
						"endline": 722,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 736,
						"comment": " Append a CData item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new CData(\"hello\");\n --------------\n",
						"deco": "FC3std3xml5CDataZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml5CData"
							}
						],
						"endline": 740,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 754,
						"comment": " Append a comment to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new Comment(\"hello\");\n --------------\n",
						"deco": "FC3std3xml7CommentZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml7Comment"
							}
						],
						"endline": 758,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 772,
						"comment": " Append a processing instruction to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new ProcessingInstruction(\"hello\");\n --------------\n",
						"deco": "FC3std3xml21ProcessingInstructionZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml21ProcessingInstruction"
							}
						],
						"endline": 776,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 792,
						"comment": " Append a complete element to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n Element other = new Element(\"br\");\n element ~= other;\n    // appends element representing <br />\n --------------\n",
						"deco": "FC3std3xml7ElementZv",
						"parameters": [
							{
								"name": "item",
								"deco": "C3std3xml7Element"
							}
						],
						"endline": 796,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 831,
						"comment": " Compares two Elements for equality\n\n Examples:\n --------------\n Element e1,e2;\n if (e1 == e2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 841,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 855,
						"comment": " Compares two Elements\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n\n Examples:\n --------------\n Element e1,e2;\n if (e1 < e2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 866,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 874,
						"comment": " Returns the hash of an Element\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 879,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "text",
						"line": 895,
						"comment": " Returns the decoded interior of an element.\n\n The element is assumed to contain text <i>only</i>. So, for\n example, given XML such as \"&lt;title&gt;Good &amp;amp;\n Bad&lt;/title&gt;\", will return \"Good &amp; Bad\".\n\n Params:\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if decode fails\n",
						"deco": "xFE3std3xml10DecodeModeZAya",
						"parameters": [
							{
								"name": "mode",
								"deco": "E3std3xml10DecodeMode",
								"default": "cast(DecodeMode)1"
							}
						],
						"endline": 905,
						"originalType": "const string(DecodeMode mode = DecodeMode.LOOSE)",
						"char": 16,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "pretty",
						"line": 914,
						"comment": " Returns an indented string representation of this item\n\n Params:\n      indent = (optional) number of spaces by which to indent this\n          element. Defaults to 2.\n",
						"deco": "xFkZAAya",
						"parameters": [
							{
								"name": "indent",
								"deco": "k",
								"default": "2u"
							}
						],
						"endline": 939,
						"originalType": "const string[](uint indent = 2)",
						"char": 27,
						"kind": "function",
						"overrides": [
							"std.xml.Item.pretty"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 950,
						"comment": " Returns the string representation of an Element\n\n Examples:\n --------------\n auto element = new Element(\"br\");\n writefln(element.toString()); // writes \"<br />\"\n --------------\n",
						"deco": "xFZAya",
						"endline": 958,
						"char": 25,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Element",
				"line": 662,
				"comment": " Class representing an XML element.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TagType",
				"line": 972,
				"comment": " Tag types.\n\n $(DDOC_ENUM_MEMBERS START) Used for start tags\n $(DDOC_ENUM_MEMBERS END) Used for end tags\n $(DDOC_ENUM_MEMBERS EMPTY) Used for empty tags\n\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "Tag",
				"line": 986,
				"comment": " Class representing an XML tag.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n The class invariant guarantees\n <ul>\n <li> that $(B type) is a valid enum TagType value</li>\n <li> that $(B name) consists of valid characters</li>\n <li> that each attribute name consists of valid characters</li>\n </ul>\n",
				"members": [
					{
						"offset": 16,
						"name": "type",
						"line": 988,
						"comment": "Type of tag\n",
						"deco": "E3std3xml7TagType",
						"init": "cast(TagType)0",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "name",
						"line": 989,
						"comment": "Tag name\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "attr",
						"line": 990,
						"comment": "Associative array of attributes\n",
						"deco": "HAyaAya",
						"char": 20,
						"kind": "variable"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1032,
						"comment": " Constructs an instance of Tag with a specified name and type\n\n The constructor does not initialize the attributes. To initialize the\n attributes, you access the $(B attr) member variable.\n\n Params:\n      name = the Tag's name\n      type = (optional) the Tag's type. If omitted, defaults to\n          TagType.START.\n\n Examples:\n --------------\n auto tag = new Tag(\"img\",Tag.EMPTY);\n tag.attr[\"src\"] = \"http://example.com/example.jpg\";\n --------------\n",
						"deco": "FAyaE3std3xml7TagTypeZC3std3xml3Tag",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							},
							{
								"name": "type",
								"deco": "E3std3xml7TagType",
								"default": "cast(TagType)0"
							}
						],
						"endline": 1036,
						"originalType": "(string name, TagType type = TagType.START)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 1098,
						"comment": " Compares two Tags for equality\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n\n Examples:\n --------------\n Tag tag1,tag2\n if (tag1 == tag2) { }\n --------------\n",
						"deco": "xFC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1106,
						"char": 23,
						"kind": "function",
						"overrides": [
							"object.Object.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 1117,
						"comment": " Compares two Tags\n\n Examples:\n --------------\n Tag tag1,tag2\n if (tag1 < tag2) { }\n --------------\n",
						"deco": "xFC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1126,
						"char": 22,
						"kind": "function",
						"overrides": [
							"object.Object.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toHash",
						"line": 1134,
						"comment": " Returns the hash of a Tag\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1137,
						"originalType": "const size_t()",
						"char": 25,
						"kind": "function",
						"overrides": [
							"object.Object.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 1148,
						"comment": " Returns the string representation of a Tag\n\n Examples:\n --------------\n auto tag = new Tag(\"book\",TagType.START);\n writefln(tag.toString()); // writes \"<book>\"\n --------------\n",
						"deco": "xFZAya",
						"endline": 1152,
						"char": 25,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 66,
						"name": "isStart",
						"line": 1179,
						"comment": " Returns true if the Tag is a start tag\n\n Examples:\n --------------\n if (tag.isStart) { }\n --------------\n",
						"deco": "xFNdZb",
						"endline": 1179,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 66,
						"name": "isEnd",
						"line": 1189,
						"comment": " Returns true if the Tag is an end tag\n\n Examples:\n --------------\n if (tag.isEnd) { }\n --------------\n",
						"deco": "xFNdZb",
						"endline": 1189,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 66,
						"name": "isEmpty",
						"line": 1199,
						"comment": " Returns true if the Tag is an empty tag\n\n Examples:\n --------------\n if (tag.isEmpty) { }\n --------------\n",
						"deco": "xFNdZb",
						"endline": 1199,
						"char": 24,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1225,
						"comment": " Construct a comment\n\n Params:\n      content = the body of the comment\n\n Throws: CommentException if the comment body is illegal (contains \"--\"\n or exactly equals \"-\")\n\n Examples:\n --------------\n auto item = new Comment(\"This is a comment\");\n    // constructs <!--This is a comment-->\n --------------\n",
						"deco": "FAyaZC3std3xml7Comment",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1230,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1241,
						"comment": " Compares two comments for equality\n\n Examples:\n --------------\n Comment item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1246,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1260,
						"comment": " Compares two comments\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n\n Examples:\n --------------\n Comment item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1266,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1274,
						"comment": " Returns the hash of a Comment\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1274,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 73,
						"name": "toString",
						"line": 1279,
						"comment": " Returns a string representation of this comment\n",
						"deco": "xFZAya",
						"endline": 1279,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1281,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1281,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Comment",
				"line": 1206,
				"comment": " Class representing a comment\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1305,
						"comment": " Construct a character data section\n\n Params:\n      content = the body of the character data segment\n\n Throws: CDataException if the segment body is illegal (contains \"]]>\")\n\n Examples:\n --------------\n auto item = new CData(\"<b>hello</b>\");\n    // constructs <![CDATA[<b>hello</b>]]>\n --------------\n",
						"deco": "FAyaZC3std3xml5CData",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1309,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1320,
						"comment": " Compares two CDatas for equality\n\n Examples:\n --------------\n CData item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1325,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1339,
						"comment": " Compares two CDatas\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n\n Examples:\n --------------\n CData item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1345,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1353,
						"comment": " Returns the hash of a CData\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1353,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 72,
						"name": "toString",
						"line": 1358,
						"comment": " Returns a string representation of this CData section\n",
						"deco": "xFZAya",
						"endline": 1358,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1360,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1360,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "CData",
				"line": 1287,
				"comment": " Class representing a Character Data section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1383,
						"comment": " Construct a text (aka PCData) section\n\n Params:\n      content = the text. This function encodes the text before\n      insertion, so it is safe to insert any text\n\n Examples:\n --------------\n auto Text = new CData(\"a < b\");\n    // constructs a &lt; b\n --------------\n",
						"deco": "FAyaZC3std3xml4Text",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1386,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1397,
						"comment": " Compares two text sections for equality\n\n Examples:\n --------------\n Text item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1402,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1416,
						"comment": " Compares two text sections\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n\n Examples:\n --------------\n Text item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1422,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1430,
						"comment": " Returns the hash of a text section\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1430,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 56,
						"name": "toString",
						"line": 1435,
						"comment": " Returns a string representation of this Text section\n",
						"deco": "xFZAya",
						"endline": 1435,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 78,
						"name": "isEmptyXML",
						"line": 1440,
						"comment": " Returns true if the content is the empty string\n",
						"deco": "xFNdZb",
						"endline": 1440,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "Text",
				"line": 1366,
				"comment": " Class representing a text (aka Parsed Character Data) section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1464,
						"comment": " Construct an XML Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: XIException if the segment body is illegal (contains \">\")\n\n Examples:\n --------------\n auto item = new XMLInstruction(\"ATTLIST\");\n    // constructs <!ATTLIST>\n --------------\n",
						"deco": "FAyaZC3std3xml14XMLInstruction",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1468,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1479,
						"comment": " Compares two XML instructions for equality\n\n Examples:\n --------------\n XMLInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1484,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1498,
						"comment": " Compares two XML instructions\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n\n Examples:\n --------------\n XMLInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1504,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1512,
						"comment": " Returns the hash of an XMLInstruction\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1512,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 69,
						"name": "toString",
						"line": 1517,
						"comment": " Returns a string representation of this XmlInstruction\n",
						"deco": "xFZAya",
						"endline": 1517,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1519,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1519,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "XMLInstruction",
				"line": 1446,
				"comment": " Class representing an XML Instruction section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1543,
						"comment": " Construct a Processing Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: PIException if the segment body is illegal (contains \"?>\")\n\n Examples:\n --------------\n auto item = new ProcessingInstruction(\"php\");\n    // constructs <?php?>\n --------------\n",
						"deco": "FAyaZC3std3xml21ProcessingInstruction",
						"parameters": [
							{
								"name": "content",
								"deco": "Aya"
							}
						],
						"endline": 1547,
						"originalType": "(string content)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1558,
						"comment": " Compares two processing instructions for equality\n\n Examples:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1563,
						"char": 19,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opEquals"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1577,
						"comment": " Compares two processing instructions\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n\n Examples:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"endline": 1583,
						"char": 18,
						"kind": "function",
						"overrides": [
							"std.xml.Item.opCmp"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 60,
						"name": "toHash",
						"line": 1591,
						"comment": " Returns the hash of a ProcessingInstruction\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n",
						"deco": "xFNbNfZm",
						"endline": 1591,
						"originalType": "const size_t()",
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toHash"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 70,
						"name": "toString",
						"line": 1596,
						"comment": " Returns a string representation of this ProcessingInstruction\n",
						"deco": "xFZAya",
						"endline": 1596,
						"char": 21,
						"kind": "function",
						"overrides": [
							"std.xml.Item.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 64,
						"name": "isEmptyXML",
						"line": 1598,
						"comment": "Returns false always\n",
						"deco": "xFNdZb",
						"endline": 1598,
						"char": 29,
						"kind": "function",
						"overrides": [
							"std.xml.Item.isEmptyXML"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"name": "ProcessingInstruction",
				"line": 1525,
				"comment": " Class representing a Processing Instruction section\n",
				"base": "std.xml.Item",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Item",
				"line": 1604,
				"comment": " Abstract base class for XML items\n",
				"members": [
					{
						"name": "opEquals",
						"line": 1607,
						"comment": "Compares with another Item of same type for equality\n",
						"deco": "FC6ObjectZb",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"char": 28,
						"kind": "function",
						"overrides": [
							"object.Object.opEquals"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "opCmp",
						"line": 1610,
						"comment": "Compares with another Item of same type\n",
						"deco": "FC6ObjectZi",
						"parameters": [
							{
								"name": "o",
								"deco": "C6Object"
							}
						],
						"char": 27,
						"kind": "function",
						"overrides": [
							"object.Object.opCmp"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "toHash",
						"line": 1613,
						"comment": "Returns the hash of this item\n",
						"deco": "xFNbNfZm",
						"originalType": "const size_t()",
						"char": 30,
						"kind": "function",
						"overrides": [
							"object.Object.toHash"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"name": "toString",
						"line": 1616,
						"comment": "Returns a string representation of this item\n",
						"deco": "xFZAya",
						"char": 30,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"abstract",
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "pretty",
						"line": 1624,
						"comment": " Returns an indented string representation of this item\n\n Params:\n      indent = number of spaces by which to indent child elements\n",
						"deco": "xFkZAAya",
						"parameters": [
							{
								"name": "indent",
								"deco": "k"
							}
						],
						"endline": 1628,
						"char": 14,
						"kind": "function"
					},
					{
						"name": "isEmptyXML",
						"line": 1631,
						"comment": "Returns true if the item represents empty XML text\n",
						"deco": "xFNdZb",
						"char": 29,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					}
				],
				"char": 10,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 1662,
						"comment": " Constructs a DocumentParser.\n\n The input to this function MUST be valid XML.\n This is enforced by the function's in contract.\n\n Params:\n      xmlText_ = the entire XML document as text\n\n",
						"deco": "FAyaZC3std3xml14DocumentParser",
						"parameters": [
							{
								"name": "xmlText_",
								"deco": "Aya"
							}
						],
						"endline": 1683,
						"originalType": "(string xmlText_)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "DocumentParser",
				"line": 1648,
				"comment": " Class for parsing an XML Document.\n\n This is a subclass of ElementParser. Most of the useful functions are\n documented there.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Bugs:\n      Currently only supports UTF documents.\n\n      If there is an encoding attribute in the prolog, it is ignored.\n\n",
				"base": "std.xml.ElementParser",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "ElementParser",
				"line": 1697,
				"comment": " Class for parsing an XML element.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Note that you cannot construct instances of this class directly. You can\n construct a DocumentParser (which is a subclass of ElementParser), but\n otherwise, Instances of ElementParser will be created for you by the\n library, and passed your way via onStartTag handlers.\n\n",
				"members": [
					{
						"endchar": 53,
						"name": "tag",
						"line": 1737,
						"comment": " The Tag at the start of the element being parsed. You can read this to\n determine the tag's name and attributes.\n",
						"deco": "xFNdZxC3std3xml3Tag",
						"endline": 1737,
						"char": 26,
						"kind": "function"
					},
					{
						"offset": 144,
						"name": "onStartTag",
						"line": 1773,
						"comment": " Register a handler which will be called whenever a start tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n start tag.\n\n Examples:\n --------------\n // Call this function whenever a <podcast> start tag is encountered\n onStartTag[\"podcast\"] = (ElementParser xml)\n {\n     // Your code here\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n\n // call myEpisodeStartHandler (defined elsewhere) whenever an <episode>\n // start tag is encountered\n onStartTag[\"episode\"] = &myEpisodeStartHandler;\n\n // call delegate dg for all other start tags\n onStartTag[null] = dg;\n --------------\n\n This library will supply your function with a new instance of\n ElementHandler, which may be used to parse inside the element whose\n start tag was just found, or to identify the tag attributes of the\n element, etc.\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt;\n and &lt;br/&gt;.\n",
						"deco": "HAyaDFC3std3xml13ElementParserZv",
						"originalType": "ParserHandler[string]",
						"char": 27,
						"kind": "variable"
					},
					{
						"offset": 152,
						"name": "onEndTag",
						"line": 1804,
						"comment": " Register a handler which will be called whenever an end tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n end tag.\n\n Examples:\n --------------\n // Call this function whenever a </podcast> end tag is encountered\n onEndTag[\"podcast\"] = (in Element e)\n {\n     // Your code here\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n\n // call myEpisodeEndHandler (defined elsewhere) whenever an </episode>\n // end tag is encountered\n onEndTag[\"episode\"] = &myEpisodeEndHandler;\n\n // call delegate dg for all other end tags\n onEndTag[null] = dg;\n --------------\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt;\n and &lt;br/&gt;.\n",
						"deco": "HAyaDFxC3std3xml7ElementZv",
						"originalType": "ElementHandler[string]",
						"char": 28,
						"kind": "variable"
					},
					{
						"endchar": 69,
						"name": "onText",
						"line": 1829,
						"comment": " Register a handler which will be called whenever text is encountered.\n\n Examples:\n --------------\n // Call this function whenever text is encountered\n onText = (string s)\n {\n     // Your code here\n\n     // The passed parameter s will have been decoded by the time you see\n     // it, and so may contain any character.\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1829,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 65,
						"name": "onTextRaw",
						"line": 1855,
						"comment": " Register an alternative handler which will be called whenever text\n is encountered. This differs from onText in that onText will decode\n the text, whereas onTextRaw will not. This allows you to make design\n choices, since onText will be more accurate, but slower, while\n onTextRaw will be faster, but less accurate. Of course, you can\n still call decode() within your handler, if you want, but you'd\n probably want to use onTextRaw only in circumstances where you\n know that decoding is unnecessary.\n\n Examples:\n --------------\n // Call this function whenever text is encountered\n onText = (string s)\n {\n     // Your code here\n\n     // The passed parameter s will NOT have been decoded.\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1855,
						"originalType": "void(Handler handler)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 71,
						"name": "onCData",
						"line": 1876,
						"comment": " Register a handler which will be called whenever a character data\n segment is encountered.\n\n Examples:\n --------------\n // Call this function whenever a CData section is encountered\n onCData = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <![CDATA[\n     // nor closing ]]>\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1876,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 75,
						"name": "onComment",
						"line": 1897,
						"comment": " Register a handler which will be called whenever a comment is\n encountered.\n\n Examples:\n --------------\n // Call this function whenever a comment is encountered\n onComment = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <!-- nor\n     // closing -->\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1897,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 65,
						"name": "onPI",
						"line": 1918,
						"comment": " Register a handler which will be called whenever a processing\n instruction is encountered.\n\n Examples:\n --------------\n // Call this function whenever a processing instruction is encountered\n onPI = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <? nor\n     // closing ?>\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1918,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 65,
						"name": "onXI",
						"line": 1941,
						"comment": " Register a handler which will be called whenever an XML instruction is\n encountered.\n\n Examples:\n --------------\n // Call this function whenever an XML instruction is encountered\n // (Note: XML instructions may only occur preceding the root tag of a\n // document).\n onPI = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <! nor\n     // closing >\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n",
						"deco": "FNdDFAyaZvZv",
						"parameters": [
							{
								"name": "handler",
								"deco": "DFAyaZv"
							}
						],
						"endline": 1941,
						"originalType": "@property void(Handler handler)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "parse",
						"line": 1952,
						"comment": " Parse an XML element.\n\n Parsing will continue until the end of the current element. Any items\n encountered for which a handler has been registered will invoke that\n handler.\n\n Throws: various kinds of XMLException\n",
						"deco": "FZv",
						"endline": 2073,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 2078,
						"comment": " Returns that part of the element which has already been parsed\n",
						"deco": "xFZAya",
						"endline": 2082,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					}
				],
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "check",
				"line": 2631,
				"comment": " Check an entire XML document for well-formedness\n\n Params:\n      s = the document to be checked, passed as a string\n\n Throws: CheckException if the document is not well formed\n\n CheckException's toString() method will yield the complete hierarchy of\n parse failure (the XML equivalent of a stack trace), giving the line and\n column number of every failure at every level.\n",
				"deco": "FAyaZv",
				"parameters": [
					{
						"name": "s",
						"deco": "Aya"
					}
				],
				"endline": 2644,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [],
				"name": "XMLException",
				"line": 2743,
				"comment": " The base class for exceptions thrown by this module\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "CommentException",
				"line": 2748,
				"comment": "Thrown during Comment constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "CDataException",
				"line": 2752,
				"comment": "Thrown during CData constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "XIException",
				"line": 2756,
				"comment": "Thrown during XMLInstruction constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "PIException",
				"line": 2760,
				"comment": "Thrown during ProcessingInstruction constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TextException",
				"line": 2764,
				"comment": "Thrown during Text constructor\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "DecodeException",
				"line": 2768,
				"comment": "Thrown during decode()\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "InvalidTypeException",
				"line": 2772,
				"comment": "Thrown if comparing with wrong type\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TagException",
				"line": 2776,
				"comment": "Thrown when parsing for Tags\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "err",
						"line": 2784,
						"comment": "Parent in hierarchy\n",
						"deco": "C3std3xml14CheckException",
						"originalType": "CheckException",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "msg",
						"line": 2790,
						"comment": " Name of production rule which failed to parse,\n or specific error message\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 112,
						"name": "line",
						"line": 2791,
						"comment": "Line number at which parse failure occurred\n",
						"deco": "m",
						"originalType": "size_t",
						"init": "0LU",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 120,
						"name": "column",
						"line": 2792,
						"comment": "Column number at which parse failure occurred\n",
						"deco": "m",
						"originalType": "size_t",
						"init": "0LU",
						"char": 12,
						"kind": "variable"
					}
				],
				"name": "CheckException",
				"line": 2782,
				"comment": " Thrown during check()\n",
				"base": "std.xml.XMLException",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "$(RED Warning: This module is considered out-dated and not up to Phobos'\n      current standards. It will remain until we have a suitable replacement,\n      but be aware that it will not remain long term.)\n\nClasses and functions for creating and parsing XML\n\nThe basic architecture of this module is that there are standalone functions,\nclasses for constructing an XML document from scratch (Tag, Element and\nDocument), and also classes for parsing a pre-existing XML file (ElementParser\nand DocumentParser). The parsing classes <i>may</i> be used to build a\nDocument, but that is not their primary purpose. The handling capabilities of\nDocumentParser and ElementParser are sufficiently customizable that you can\nmake them do pretty much whatever you want.\n\nExample: This example creates a DOM (Document Object Model) tree\n    from an XML file.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\nimport std.file;\n\n// books.xml is used in various samples throughout the Microsoft XML Core\n// Services (MSXML) SDK.\n//\n// See http://msdn2.microsoft.com/en-us/library/ms762271(VS.85).aspx\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    // Check for well-formedness\n    check(s);\n\n    // Make a DOM tree\n    auto doc = new Document(s);\n\n    // Plain-print it\n    writeln(doc);\n}\n------------------------------------------------------------------------------\n\nExample: This example does much the same thing, except that the file is\n    deconstructed and reconstructed by hand. This is more work, but the\n    techniques involved offer vastly more power.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\n\nstruct Book\n{\n    string id;\n    string author;\n    string title;\n    string genre;\n    string price;\n    string pubDate;\n    string description;\n}\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    // Check for well-formedness\n    check(s);\n\n    // Take it apart\n    Book[] books;\n\n    auto xml = new DocumentParser(s);\n    xml.onStartTag[\"book\"] = (ElementParser xml)\n    {\n        Book book;\n        book.id = xml.tag.attr[\"id\"];\n\n        xml.onEndTag[\"author\"]       = (in Element e) { book.author      = e.text(); };\n        xml.onEndTag[\"title\"]        = (in Element e) { book.title       = e.text(); };\n        xml.onEndTag[\"genre\"]        = (in Element e) { book.genre       = e.text(); };\n        xml.onEndTag[\"price\"]        = (in Element e) { book.price       = e.text(); };\n        xml.onEndTag[\"publish-date\"] = (in Element e) { book.pubDate     = e.text(); };\n        xml.onEndTag[\"description\"]  = (in Element e) { book.description = e.text(); };\n\n        xml.parse();\n\n        books ~= book;\n    };\n    xml.parse();\n\n    // Put it back together again;\n    auto doc = new Document(new Tag(\"catalog\"));\n    foreach(book;books)\n    {\n        auto element = new Element(\"book\");\n        element.tag.attr[\"id\"] = book.id;\n\n        element ~= new Element(\"author\",      book.author);\n        element ~= new Element(\"title\",       book.title);\n        element ~= new Element(\"genre\",       book.genre);\n        element ~= new Element(\"price\",       book.price);\n        element ~= new Element(\"publish-date\",book.pubDate);\n        element ~= new Element(\"description\", book.description);\n\n        doc ~= element;\n    }\n\n    // Pretty-print it\n    writefln(join(doc.pretty(3),\"\\n\"));\n}\n-------------------------------------------------------------------------------\nMacros:\n    WIKI=Phobos/StdXml\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std/_xml.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/stdiobase.d",
		"name": "std.stdiobase",
		"members": [],
		"comment": " The only purpose of this module is to do the static construction for\n std.stdio, to eliminate cyclic construction errors.\n\n Copyright: Copyright Andrei Alexandrescu 2008 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB erdani.org, Andrei Alexandrescu)\n Source:    $(PHOBOSSRC std/_stdiobase.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/utf.d",
		"name": "std.utf",
		"members": [
			{
				"members": [],
				"name": "UTFException",
				"line": 36,
				"comment": "    Exception thrown on errors in std.utf functions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "isValidDchar",
				"line": 189,
				"comment": "    Returns whether $(D c) is a valid UTF-32 character.\n\n    $(D '\\uFFFE') and $(D '\\uFFFF') are considered valid by $(D isValidDchar),\n    as they are permitted for internal use by an application, but they are\n    not allowed for interchange by the Unicode standard.\n",
				"deco": "FNaNbNiNfwZb",
				"parameters": [
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 199,
				"char": 19,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 248,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 260,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 248,
				"comment": "    $(D stride) returns the length of the UTF-8 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-8 strings and ranges of $(D char). If no\n    index is passed, then an input range will work, but if an index is passed,\n    then a random-access range is required.\n\n    $(D index) defaults to $(D 0) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-8 sequence, a value between 1 and 4\n        (as per $(WEB tools.ietf.org/html/rfc3629#section-3, RFC 3629$(COMMA) section 3)).\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not the start of a\n        valid UTF-8 sequence.\n\n    Notes:\n        $(D stride) will only analyze the first $(D str[index]) element. It\n        will not fully verify the validity of UTF-8 sequence, nor even verify\n        the presence of the sequence: it will not actually guarantee that\n        $(D index + stride(str, index) <= str.length).\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 263,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 276,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 263,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isInputRange!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 393,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 421,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 393,
				"comment": "    $(D strideBack) returns the length of the UTF-8 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-8 strings and bidirectional ranges of\n    $(D char). If no index is passed, then a bidirectional range will work, but\n    if an index is passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not one past the\n        end of a valid UTF-8 sequence.\n\n    Notes:\n        $(D strideBack) will not fully verify the validity of the UTF-8\n        sequence. It will, however, guarantee that\n        $(D index - stride(str, index)) is a valid index.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 424,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 429,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 424,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(char[])) || isRandomAccessRange!S && hasLength!S && is(Unqual!(ElementType!S) == char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 538,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 546,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 538,
				"comment": "    $(D stride) returns the length of the UTF-16 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-16 strings and ranges of $(D wchar). If no\n    index is passed, then an input range will work, but if an index is passed,\n    then a random-access range is required.\n\n    $(D index) defaults to $(D 0) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not the start of a\n        valid UTF-16 sequence.\n\n    Notes:\n        $(D stride) will only analyze the first $(D str[index]) element. It\n        will not fully verify the validity of UTF-16 sequence, nor even verify\n        the presence of the sequence: it will not actually guarantee that\n        $(D index + stride(str, index) <= str.length).\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == wchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 549,
						"type": "pure @safe uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 553,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 549,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[]))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 656,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 666,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 656,
				"comment": "    $(D strideBack) returns the length of the UTF-16 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-16 strings and ranges of $(D wchar). If\n    no index is passed, then a bidirectional range will work, but if an index is\n    passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not one past the\n        end of a valid UTF-16 sequence.\n\n    Notes:\n        $(D stride) will only analyze the element at $(D str[index - 1])\n        element. It will not fully verify the validity of UTF-16 sequence, nor\n        even verify the presence of the sequence: it will not actually\n        guarantee that $(D stride(str, index) <= index).\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[])) || isRandomAccessRange!S && is(Unqual!(ElementType!S) == wchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 669,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 681,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 669,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(wchar[])) || isBidirectionalRange!S && is(Unqual!(ElementType!S) == wchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 763,
						"type": "uint(auto ref S str, size_t index = 0)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t",
								"default": "0"
							}
						],
						"endline": 772,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "stride",
				"line": 763,
				"comment": "    $(D stride) returns the length of the UTF-32 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-32 strings and ranges of $(D dchar).\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n\n    Throws:\n        Never.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "is(S : const(dchar[])) || isInputRange!S && is(Unqual!(ElementEncodingType!S) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 858,
						"type": "uint(auto ref S str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 865,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 858,
				"comment": "    $(D strideBack) returns the length of the UTF-32 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-32 strings and ranges of $(D dchar). If\n    no index is passed, then a bidirectional range will work, but if an index is\n    passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n\n    Throws:\n        Never.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!S && is(Unqual!(ElementEncodingType!S) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strideBack",
						"line": 868,
						"type": "uint(auto ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 873,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strideBack",
				"line": 868,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!S && is(Unqual!(ElementEncodingType!S) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUCSindex",
						"line": 950,
						"type": "pure @safe size_t(const(C)[] str, size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 973,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "toUCSindex",
				"line": 950,
				"comment": "    Given $(D index) into $(D str) and assuming that $(D index) is at the start\n    of a UTF sequence, $(D toUCSindex) determines the number of UCS characters\n    up to $(D index). So, $(D index) is the index of a code unit at the\n    beginning of a code point, and the return value is how many code points into\n    the string that that code point is.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL976_1942)\n---\nassert(toUCSindex(`hello world`, 7) == 7);\nassert(toUCSindex(`hello world`w, 7) == 7);\nassert(toUCSindex(`hello world`d, 7) == 7);\n\nassert(toUCSindex(`Ma ChÃ©rie`, 7) == 6);\nassert(toUCSindex(`Ma ChÃ©rie`w, 7) == 7);\nassert(toUCSindex(`Ma ChÃ©rie`d, 7) == 7);\n\nassert(toUCSindex(`ãããã®æå® / ããããã¨ç§å­¦è`, 9) == 3);\nassert(toUCSindex(`ãããã®æå® / ããããã¨ç§å­¦è`w, 9) == 9);\nassert(toUCSindex(`ãããã®æå® / ããããã¨ç§å­¦è`d, 9) == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL976_1942)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUTFindex",
						"line": 997,
						"type": "pure @safe size_t(const(C)[] str, size_t n)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1013,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "toUTFindex",
				"line": 997,
				"comment": "    Given a UCS index $(D n) into $(D str), returns the UTF index.\n    So, $(D n) is how many code points into the string the code point is, and\n    the array index of the code unit is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1016_1943)\n---\nassert(toUTFindex(`hello world`, 7) == 7);\nassert(toUTFindex(`hello world`w, 7) == 7);\nassert(toUTFindex(`hello world`d, 7) == 7);\n\nassert(toUTFindex(`Ma ChÃ©rie`, 6) == 7);\nassert(toUTFindex(`Ma ChÃ©rie`w, 7) == 7);\nassert(toUTFindex(`Ma ChÃ©rie`d, 7) == 7);\n\nassert(toUTFindex(`ãããã®æå® / ããããã¨ç§å­¦è`, 3) == 9);\nassert(toUTFindex(`ãããã®æå® / ããããã¨ç§å­¦è`w, 9) == 9);\nassert(toUTFindex(`ãããã®æå® / ããããã¨ç§å­¦è`d, 9) == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1016_1943)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decode",
						"line": 1056,
						"type": "dchar(auto ref S str, ref size_t index)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"auto",
									"ref"
								]
							},
							{
								"name": "index",
								"type": "size_t",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1073,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decode",
				"line": 1056,
				"comment": "    Decodes and returns the code point starting at $(D str[index]). $(D index)\n    is advanced to one past the decoded code point. If the code point is not\n    well-formed, then a $(D UTFException) is thrown and $(D index) remains\n    unchanged.\n\n    decode will only work with strings and random access ranges of code units\n    with length and slicing, whereas $(LREF decodeFront) will work with any\n    input range of code units.\n\n    Params:\n        useReplacementDchar = if invalid UTF, return replacementDchar rather than throwing\n        str = input string or indexable Range\n        index = starting index into s[]; incremented by number of code units processed\n\n    Returns:\n        decoded character\n\n    Throws:\n        $(LREF UTFException) if $(D str[index]) is not the start of a valid UTF\n        sequence and useReplacementDchar is UseReplacementDchar.no\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "Flag!\"useReplacementDchar\".no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isSomeString!S && isRandomAccessRange!S && hasSlicing!S && hasLength!S && isSomeChar!(ElementType!S)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeFront",
						"line": 1116,
						"type": "dchar(ref S str, out size_t numCodeUnits)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "numCodeUnits",
								"type": "size_t",
								"storageClass": [
									"out"
								]
							}
						],
						"endline": 1150,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decodeFront",
				"line": 1116,
				"comment": "    $(D decodeFront) is a variant of $(LREF decode) which specifically decodes\n    the first code point. Unlike $(LREF decode), $(D decodeFront) accepts any\n    input range of code units (rather than just a string or random access\n    range). It also takes the range by $(D ref) and pops off the elements as it\n    decodes them. If $(D numCodeUnits) is passed in, it gets set to the number\n    of code units which were in the code point which was decoded.\n\n    Params:\n        useReplacementDchar = if invalid UTF, return replacementDchar rather than throwing\n        str = input string or indexable Range\n        numCodeUnits = set to number of code units processed\n\n    Returns:\n        decoded character\n\n    Throws:\n        $(LREF UTFException) if $(D str.front) is not the start of a valid UTF\n        sequence. If an exception is thrown, then there is no guarantee as to\n        the number of code units which were popped off, as it depends on the\n        type of range being used and how many code units had to be popped off\n        before the code point was determined to be invalid.\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "Flag!\"useReplacementDchar\".no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "!isSomeString!S && isInputRange!S && isSomeChar!(ElementType!S)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "decodeFront",
						"line": 1180,
						"type": "dchar(ref S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1185,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "decodeFront",
				"line": 1180,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "useReplacementDchar",
						"defaultValue": "Flag!\"useReplacementDchar\".no",
						"deco": "E3std8typecons55__T4FlagVAyaa19_7573655265706c6163656d656e744463686172Z4Flag",
						"kind": "value"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!S && isSomeChar!(ElementType!S)",
				"char": 7,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "encode",
				"line": 1907,
				"comment": "    Encodes $(D c) into the static array, $(D buf), and returns the actual\n    length of the encoded character (a number between $(D 1) and $(D 4) for\n    $(D char[4]) buffers and a number between $(D 1) and $(D 2) for\n    $(D wchar[2]) buffers).\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n",
				"deco": "FNaNfKG4awZm",
				"parameters": [
					{
						"name": "buf",
						"storageClass": [
							"ref"
						],
						"deco": "G4a"
					},
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 1945,
				"originalType": "pure @safe size_t(ref char[4] buf, dchar c)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "encode",
				"line": 1976,
				"comment": "Ditto\n",
				"deco": "FNaNfKG2uwZm",
				"parameters": [
					{
						"name": "buf",
						"storageClass": [
							"ref"
						],
						"deco": "G2u"
					},
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 1997,
				"originalType": "pure @safe size_t(ref wchar[2] buf, dchar c)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "encode",
				"line": 2029,
				"comment": "    Encodes $(D c) in $(D str)'s encoding and appends it to $(D str).\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n",
				"deco": "FNaNfKAawZv",
				"parameters": [
					{
						"name": "str",
						"storageClass": [
							"ref"
						],
						"deco": "Aa"
					},
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 2078,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "encode",
				"line": 2131,
				"comment": "ditto\n",
				"deco": "FNaNfKAuwZv",
				"parameters": [
					{
						"name": "str",
						"storageClass": [
							"ref"
						],
						"deco": "Au"
					},
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 2159,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "encode",
				"line": 2185,
				"comment": "ditto\n",
				"deco": "FNaNfKAwwZv",
				"parameters": [
					{
						"name": "str",
						"storageClass": [
							"ref"
						],
						"deco": "Aw"
					},
					{
						"name": "c",
						"deco": "w"
					}
				],
				"endline": 2192,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codeLength",
						"line": 2221,
						"type": "pure nothrow @nogc @safe ubyte(dchar c)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 2241,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "codeLength",
				"line": 2221,
				"comment": "    Returns the number of code units that are required to encode the code point\n    $(D c) when $(D C) is the character type used to encode it.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2244_1958)\n---\nassert(codeLength!char('a') == 1);\nassert(codeLength!wchar('a') == 1);\nassert(codeLength!dchar('a') == 1);\n\nassert(codeLength!char('\\U0010FFFF') == 4);\nassert(codeLength!wchar('\\U0010FFFF') == 2);\nassert(codeLength!dchar('\\U0010FFFF') == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2244_1958)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "codeLength",
						"line": 2262,
						"type": "size_t(InputRange input)",
						"parameters": [
							{
								"name": "input",
								"type": "InputRange"
							}
						],
						"endline": 2277,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "codeLength",
				"line": 2262,
				"comment": "    Returns the number of code units that are required to encode $(D str)\n    in a string whose character type is $(D C). This is particularly useful\n    when slicing one string with the length of another and the two string\n    types use different character types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2280_1959)\n---\nimport std.conv : to;\nassert(codeLength!char(\"hello world\") ==\n       to!string(\"hello world\").length);\nassert(codeLength!wchar(\"hello world\") ==\n       to!wstring(\"hello world\").length);\nassert(codeLength!dchar(\"hello world\") ==\n       to!dstring(\"hello world\").length);\n\nassert(codeLength!char(`ãã­ã°ã©ãã³ã°`) ==\n       to!string(`ãã­ã°ã©ãã³ã°`).length);\nassert(codeLength!wchar(`ãã­ã°ã©ãã³ã°`) ==\n       to!wstring(`ãã­ã°ã©ãã³ã°`).length);\nassert(codeLength!dchar(`ãã­ã°ã©ãã³ã°`) ==\n       to!dstring(`ãã­ã°ã©ãã³ã°`).length);\n\nstring haystack = `Ãtre sans la veritÃ©, Ã§a, ce ne serait pas bien.`;\nwstring needle = `Ãtre sans la veritÃ©`;\nassert(haystack[codeLength!char(needle) .. $] ==\n       `, Ã§a, ce ne serait pas bien.`);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2280_1959)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "InputRange",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!InputRange && is(ElementType!InputRange : dchar)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "validate",
						"line": 2376,
						"type": "pure @safe void(in S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 2384,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "validate",
				"line": 2376,
				"comment": "    Checks to see if $(D str) is well-formed unicode or not.\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "toUTF8",
				"line": 2442,
				"comment": " Encodes string $(D_PARAM s) into UTF-8 and returns the encoded string.\n",
				"deco": "FNaNfxAaZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAa"
					}
				],
				"endline": 2446,
				"originalType": "pure @safe string(in char[] s)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF8",
				"line": 2449,
				"comment": "ditto\n",
				"deco": "FNaNfxAuZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAu"
					}
				],
				"endline": 2472,
				"originalType": "pure @safe string(in wchar[] s)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF8",
				"line": 2475,
				"comment": "ditto\n",
				"deco": "FNaNfxAwZAya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAw"
					}
				],
				"endline": 2500,
				"originalType": "pure @safe string(in dchar[] s)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF16",
				"line": 2528,
				"comment": " Encodes string $(D s) into UTF-16 and returns the encoded string.\n",
				"deco": "FNaNfxAaZAyu",
				"parameters": [
					{
						"name": "s",
						"deco": "xAa"
					}
				],
				"endline": 2551,
				"originalType": "pure @safe wstring(in char[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF16",
				"line": 2554,
				"comment": "ditto\n",
				"deco": "FNaNfxAuZAyu",
				"parameters": [
					{
						"name": "s",
						"deco": "xAu"
					}
				],
				"endline": 2558,
				"originalType": "pure @safe wstring(in wchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF16",
				"line": 2561,
				"comment": "ditto\n",
				"deco": "FNaNfxAwZAyu",
				"parameters": [
					{
						"name": "s",
						"deco": "xAw"
					}
				],
				"endline": 2574,
				"originalType": "pure @safe wstring(in dchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF32",
				"line": 2582,
				"comment": " Encodes string $(D_PARAM s) into UTF-32 and returns the encoded string.\n",
				"deco": "FNaNfxAaZAyw",
				"parameters": [
					{
						"name": "s",
						"deco": "xAa"
					}
				],
				"endline": 2600,
				"originalType": "pure @safe dstring(in char[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF32",
				"line": 2603,
				"comment": "ditto\n",
				"deco": "FNaNfxAuZAyw",
				"parameters": [
					{
						"name": "s",
						"deco": "xAu"
					}
				],
				"endline": 2621,
				"originalType": "pure @safe dstring(in wchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toUTF32",
				"line": 2624,
				"comment": "ditto\n",
				"deco": "FNaNfxAwZAyw",
				"parameters": [
					{
						"name": "s",
						"deco": "xAw"
					}
				],
				"endline": 2628,
				"originalType": "pure @safe dstring(in dchar[] s)",
				"char": 9,
				"kind": "function"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "toUTFz",
								"line": 2674,
								"type": "pure @safe P(S str)",
								"parameters": [
									{
										"name": "str",
										"type": "S"
									}
								],
								"endline": 2677,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "toUTFz",
						"line": 2674,
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					}
				],
				"name": "toUTFz",
				"line": 2672,
				"comment": "    Returns a C-style zero-terminated string equivalent to $(D str). $(D str)\n    must not contain embedded $(D '\\0')'s as any C function will treat the first\n    $(D '\\0') that it sees as the end of the string. If $(D str.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(D toUTFz) accepts any type of string and is templated on the type of\n    character pointer that you wish to convert to. It will avoid allocating a\n    new string if it can, but there's a decent chance that it will end up having\n    to allocate a new string - particularly when dealing with character types\n    other than $(D char).\n\n    $(RED Warning 1:) If the result of $(D toUTFz) equals $(D str.ptr), then if\n    anything alters the character one past the end of $(D str) (which is the\n    $(D '\\0') character terminating the string), then the string won't be\n    zero-terminated anymore. The most likely scenarios for that are if you\n    append to $(D str) and no reallocation takes place or when $(D str) is a\n    slice of a larger array, and you alter the character in the larger array\n    which is one character past the end of $(D str). Another case where it could\n    occur would be if you had a mutable character array immediately after\n    $(D str) in memory (for example, if they're member variables in a\n    user-defined type with one declared right after the other) and that\n    character array happened to start with $(D '\\0'). Such scenarios will never\n    occur if you immediately use the zero-terminated string after calling\n    $(D toUTFz) and the C function using it doesn't keep a reference to it.\n    Also, they are unlikely to occur even if you save the zero-terminated string\n    (the cases above would be among the few examples of where it could happen).\n    However, if you save the zero-terminate string and want to be absolutely\n    certain that the string stays zero-terminated, then simply append a\n    $(D '\\0') to the string and use its $(D ptr) property rather than calling\n    $(D toUTFz).\n\n    $(RED Warning 2:) When passing a character pointer to a C function, and the\n    C function keeps it around for any reason, make sure that you keep a\n    reference to it in your D code. Otherwise, it may go away during a garbage\n    collection cycle and cause a nasty bug when the C code tries to use it.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2681_1964)\n---\nauto p1 = toUTFz!(char*)(\"hello world\");\nauto p2 = toUTFz!(const(char)*)(\"hello world\");\nauto p3 = toUTFz!(immutable(char)*)(\"hello world\");\nauto p4 = toUTFz!(char*)(\"hello world\"d);\nauto p5 = toUTFz!(const(wchar)*)(\"hello world\");\nauto p6 = toUTFz!(immutable(dchar)*)(\"hello world\"w);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2681_1964)\n",
				"parameters": [
					{
						"name": "P",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toUTF16z",
						"line": 2885,
						"type": "pure @safe const(wchar)*(const(C)[] str)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							}
						],
						"endline": 2889,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "toUTF16z",
				"line": 2885,
				"comment": "    $(D toUTF16z) is a convenience function for $(D toUTFz!(const(wchar)*)).\n\n    Encodes string $(D s) into UTF-16 and returns the encoded string.\n    $(D toUTF16z) is suitable for calling the 'W' functions in the Win32 API\n    that take an $(D LPWSTR) or $(D LPCWSTR) argument.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 2944,
						"type": "pure nothrow @nogc @trusted size_t(const(C)[] str)",
						"parameters": [
							{
								"name": "str",
								"type": "const(C)[]"
							}
						],
						"endline": 2948,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 2944,
				"comment": "    Returns the total number of code points encoded in $(D str).\n\n    Supercedes: This function supercedes $(LREF toUCSindex).\n\n    Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 8,
				"kind": "template"
			},
			{
				"name": "replacementDchar",
				"line": 3069,
				"comment": " Inserted in place of invalid UTF sequences.\n\n References:\n      $(LINK http://en.wikipedia.org/wiki/Replacement_character#Replacement_character)\n",
				"deco": "w",
				"init": "'\\U0000fffd'",
				"char": 12,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodeUnit",
						"line": 3082,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3134,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byCodeUnit",
				"line": 3082,
				"comment": " Iterate a range of char, wchar, or dchars by code unit.\n\n The purpose is to bypass the special case decoding that\n $(XREF array,front) does to character arrays.\n Params:\n      r = input range of characters, or array of characters\n Returns:\n      input range\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isAutodecodableString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byCodeUnit",
						"line": 3137,
						"type": "ref (R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3142,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byCodeUnit",
				"line": 3137,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "!isAutodecodableString!R && isInputRange!R && isSomeChar!(ElementEncodingType!R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChar",
						"line": 3240,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3256,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChar",
				"line": 3240,
				"comment": " Iterate an input range of characters by char, wchar, or dchar.\n\n UTF sequences that cannot be converted to UTF-8 are replaced by U+FFFD\n per \"5.22 Best Practice for U+FFFD Substitution\" of the Unicode Standard 6.2.\n Hence, byChar, byWchar, and byDchar are not symmetric.\n This algorithm is lazy, and does not allocate memory.\n Purity, nothrow, and safety are inferred from the r parameter.\n Params:\n      r = input range of characters, or array of characters\n Returns:\n      input range\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isAutodecodableString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byWchar",
						"line": 3259,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3271,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byWchar",
				"line": 3259,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isAutodecodableString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byDchar",
						"line": 3274,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3279,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byDchar",
				"line": 3274,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isAutodecodableString!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChar",
						"line": 3283,
						"type": "ref (R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3395,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChar",
				"line": 3283,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "!isAutodecodableString!R && isInputRange!R && isSomeChar!(ElementEncodingType!R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byWchar",
						"line": 3446,
						"type": "ref (R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3537,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byWchar",
				"line": 3446,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "!isAutodecodableString!R && isInputRange!R && isSomeChar!(ElementEncodingType!R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byDchar",
						"line": 3583,
						"type": "ref (R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3765,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byDchar",
				"line": 3583,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "!isAutodecodableString!R && isInputRange!R && isSomeChar!(ElementEncodingType!R)",
				"char": 10,
				"kind": "template"
			},
			{
				"members": [],
				"name": "byUTF",
				"line": 3908,
				"comment": " Select byChar, byWchar, or byDchar based on the type C.\n\n Params:\n    C = char, wchar, or dchar\n\n Returns:\n    corresponding alias to $(LREF byChar), $(LREF byWchar), or $(LREF byDchar)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3921_1975)\n---\nforeach (c; \"h\".byUTF!char())\n    assert(c == 'h');\nforeach (c; \"h\".byUTF!wchar())\n    assert(c == 'h');\nforeach (c; \"h\".byUTF!dchar())\n    assert(c == 'h');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3921_1975)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "    Encode and decode UTF-8, UTF-16 and UTF-32 strings.\n\n    UTF character support is restricted to\n    $(D '\\u0000' &lt;= character &lt;= '\\U0010FFFF').\n\n    See_Also:\n        $(LINK2 http://en.wikipedia.org/wiki/Unicode, Wikipedia)<br>\n        $(LINK http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8)<br>\n        $(LINK http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335)\n    Macros:\n        WIKI = Phobos/StdUtf\n\n    Copyright: Copyright Digital Mars 2000 - 2012.\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_utf.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/stdint.d",
		"name": "std.stdint",
		"members": [],
		"comment": "\n    D constrains integral types to specific sizes. But efficiency\n    of different sizes varies from machine to machine,\n    pointer sizes vary, and the maximum integer size varies.\n    <b>stdint</b> offers a portable way of trading off size\n    vs efficiency, in a manner compatible with the <tt>stdint.h</tt>\n    definitions in C.\n\n    The exact aliases are types of exactly the specified number of bits.\n    The at least aliases are at least the specified number of bits\n    large, and can be larger.\n    The fast aliases are the fastest integral type supported by the\n    processor that is at least as wide as the specified number of bits.\n\n    The aliases are:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Exact Alias\n    <th>Description\n    <th>At Least Alias\n    <th>Description\n    <th>Fast Alias\n    <th>Description\n    <tr>\n    <td>int8_t\n    <td>exactly 8 bits signed\n    <td>int_least8_t\n    <td>at least 8 bits signed\n    <td>int_fast8_t\n    <td>fast 8 bits signed\n    <tr>\n    <td>uint8_t\n    <td>exactly 8 bits unsigned\n    <td>uint_least8_t\n    <td>at least 8 bits unsigned\n    <td>uint_fast8_t\n    <td>fast 8 bits unsigned\n\n    <tr>\n    <td>int16_t\n    <td>exactly 16 bits signed\n    <td>int_least16_t\n    <td>at least 16 bits signed\n    <td>int_fast16_t\n    <td>fast 16 bits signed\n    <tr>\n    <td>uint16_t\n    <td>exactly 16 bits unsigned\n    <td>uint_least16_t\n    <td>at least 16 bits unsigned\n    <td>uint_fast16_t\n    <td>fast 16 bits unsigned\n\n    <tr>\n    <td>int32_t\n    <td>exactly 32 bits signed\n    <td>int_least32_t\n    <td>at least 32 bits signed\n    <td>int_fast32_t\n    <td>fast 32 bits signed\n    <tr>\n    <td>uint32_t\n    <td>exactly 32 bits unsigned\n    <td>uint_least32_t\n    <td>at least 32 bits unsigned\n    <td>uint_fast32_t\n    <td>fast 32 bits unsigned\n\n    <tr>\n    <td>int64_t\n    <td>exactly 64 bits signed\n    <td>int_least64_t\n    <td>at least 64 bits signed\n    <td>int_fast64_t\n    <td>fast 64 bits signed\n    <tr>\n    <td>uint64_t\n    <td>exactly 64 bits unsigned\n    <td>uint_least64_t\n    <td>at least 64 bits unsigned\n    <td>uint_fast64_t\n    <td>fast 64 bits unsigned\n    </table>\n\n    The ptr aliases are integral types guaranteed to be large enough\n    to hold a pointer without losing bits:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Alias\n    <th>Description\n    <tr>\n    <td>intptr_t\n    <td>signed integral type large enough to hold a pointer\n    <tr>\n    <td>uintptr_t\n    <td>unsigned integral type large enough to hold a pointer\n    </table>\n\n    The max aliases are the largest integral types:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Alias\n    <th>Description\n    <tr>\n    <td>intmax_t\n    <td>the largest signed integral type\n    <tr>\n    <td>uintmax_t\n    <td>the largest unsigned integral type\n    </table>\n\n Macros:\n  WIKI=Phobos/StdStdint\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_stdint.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/string.d",
		"name": "std.string",
		"members": [
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 187,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std6string15StringException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 193,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "StringException",
				"line": 178,
				"comment": "    Exception thrown on errors in std.string functions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"endchar": 1,
				"name": "fromStringz",
				"line": 205,
				"comment": "    Returns a D-style array of $(D char) given a zero-terminated C-style string.\n    The returned array will retain the same type qualifiers as the input.\n\n    $(RED Important Note:) The returned array is a slice of the original buffer.\n    The original data is not changed and not copied.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL211_1976)\n---\nassert(fromStringz(null) == null);\nassert(fromStringz(\"foo\") == \"foo\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL211_1976)\n",
				"deco": "FNaNbNiPNgaZANga",
				"parameters": [
					{
						"name": "cString",
						"deco": "PNga"
					}
				],
				"endline": 208,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toStringz",
				"line": 228,
				"comment": "    Returns a C-style zero-terminated string equivalent to $(D s). $(D s)\n    must not contain embedded $(D '\\0')'s as any C function will treat the first\n    $(D '\\0') that it sees as the end of the string. If $(D s.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(RED Important Note:) When passing a $(D char*) to a C function, and the C\n    function keeps it around for any reason, make sure that you keep a reference\n    to it in your D code. Otherwise, it may go away during a garbage collection\n    cycle and cause a nasty bug when the C code tries to use it.\n",
				"deco": "FNaNbNeAxaZPya",
				"parameters": [
					{
						"name": "s",
						"deco": "Axa"
					}
				],
				"endline": 270,
				"char": 18,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "toStringz",
				"line": 273,
				"comment": " Ditto\n",
				"deco": "FNaNbNexAyaZPya",
				"parameters": [
					{
						"name": "s",
						"deco": "xAya"
					}
				],
				"endline": 290,
				"originalType": "pure nothrow @trusted immutable(char)*(in string s)",
				"char": 18,
				"kind": "function"
			},
			{
				"name": "CaseSensitive",
				"line": 330,
				"comment": "   Flag indicating whether a search is case-sensitive.\n",
				"deco": "E3std8typecons43__T4FlagVAyaa13_6361736553656e736974697665Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 346,
						"type": "ptrdiff_t(Range s, in dchar c, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "Range"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 469,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 346,
				"comment": "    Searches for character in range.\n\n    Params:\n        s = string or InputRange of characters to search in correct UTF format\n        c = character to search for\n        cs = CaseSensitive.yes or CaseSensitive.no\n\n    Returns:\n        the index of the first occurrence of $(D c) in $(D s). If $(D c)\n        is not found, then $(D -1) is returned.\n        If the parameters are not valid UTF, the result will still\n        be in the range [-1 .. s.length], but will not be reliable otherwise.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 545,
						"type": "ptrdiff_t(Range s, in dchar c, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "Range"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 575,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 545,
				"comment": "    Searches for character in range starting at index startIdx.\n\n    Params:\n        s = string or InputRange of characters to search in correct UTF format\n        c = character to search for\n        startIdx = starting index to a well-formed code point\n        cs = CaseSensitive.yes or CaseSensitive.no\n\n    Returns:\n        the index of the first occurrence of $(D c) in $(D s). If $(D c)\n        is not found, then $(D -1) is returned.\n        If the parameters are not valid UTF, the result will still\n        be in the range [-1 .. s.length], but will not be reliable otherwise.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 641,
						"type": "ptrdiff_t(Range s, const(Char)[] sub, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "Range"
							},
							{
								"name": "sub",
								"type": "const(Char)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 712,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 641,
				"comment": "    Searches for substring in $(D s).\n\n    Params:\n        s = string or ForwardRange of characters to search in correct UTF format\n        sub = substring to search for\n        cs = CaseSensitive.yes or CaseSensitive.no\n\n    Returns:\n        the index of the first occurrence of $(D sub) in $(D s). If $(D sub)\n        is not found, then $(D -1) is returned.\n        If the arguments are not valid UTF, the result will still\n        be in the range [-1 .. s.length], but will not be reliable otherwise.\n\n    Bugs:\n        Does not work with case insensitive strings where the mapping of\n        tolower and toupper is not 1:1.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) && isSomeChar!Char",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOf",
						"line": 794,
						"type": "@safe ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char1)[]"
							},
							{
								"name": "sub",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 807,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOf",
				"line": 794,
				"comment": "    Returns the index of the first occurrence of $(D sub) in $(D s) with\n    respect to the start index $(D startIdx). If $(D sub) is not found, then\n    $(D -1) is returned. If $(D sub) is found the value of the returned index\n    is at least $(D startIdx). $(D startIdx) represents a codeunit index in\n    $(D s). If the sequence starting at $(D startIdx) does not represent a well\n    formed codepoint, then a $(XREF utf,UTFException) may be thrown.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n",
				"parameters": [
					{
						"name": "Char1",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char1 && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 874,
						"type": "pure @safe ptrdiff_t(const(Char)[] s, in dchar c, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char)[]"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 934,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 874,
				"comment": "    Returns the index of the last occurrence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 986,
						"type": "pure @safe ptrdiff_t(const(Char)[] s, in dchar c, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char)[]"
							},
							{
								"name": "c",
								"storageClass": [
									"in"
								],
								"deco": "w"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 996,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 986,
				"comment": "    Returns the index of the last occurrence of $(D c) in $(D s). If $(D c) is\n    not found, then $(D -1) is returned. The $(D startIdx) slices $(D s) in\n    the following way $(D s[0 .. startIdx]). $(D startIdx) represents a\n    codeunit index in $(D s). If the sequence ending at $(D startIdx) does not\n    represent a well formed codepoint, then a $(XREF utf,UTFException) may be\n    thrown.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 1038,
						"type": "pure @safe ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char1)[]"
							},
							{
								"name": "sub",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1113,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 1038,
				"comment": "    Returns the index of the last occurrence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n",
				"parameters": [
					{
						"name": "Char1",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char1 && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOf",
						"line": 1203,
						"type": "pure @safe ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "s",
								"type": "const(Char1)[]"
							},
							{
								"name": "sub",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1213,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOf",
				"line": 1203,
				"comment": "    Returns the index of the last occurrence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned. The $(D startIdx) slices $(D s) in\n    the following way $(D s[0 .. startIdx]). $(D startIdx) represents a\n    codeunit index in $(D s). If the sequence ending at $(D startIdx) does not\n    represent a well formed codepoint, then a $(XREF utf,UTFException) may be\n    thrown.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n",
				"parameters": [
					{
						"name": "Char1",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char1 && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfAny",
						"line": 1392,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1397,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfAny",
				"line": 1392,
				"comment": "    Returns the index of the first occurence of any of the elements in $(D\n    needles) in $(D haystack). If no element of $(D needles) is found,\n    then $(D -1) is returned.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1400_1992)\n---\nimport std.conv : to;\n\nptrdiff_t i = \"helloWorld\".indexOfAny(\"Wr\");\nassert(i == 5);\ni = \"Ã¶Ã¤llo world\".indexOfAny(\"lo \");\nassert(i == 4, to!string(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1400_1992)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfAny",
						"line": 1467,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1481,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfAny",
				"line": 1467,
				"comment": "    Returns the index of the first occurence of any of the elements in $(D\n    needles) in $(D haystack). If no element of $(D needles) is found,\n    then $(D -1) is returned. The $(D startIdx) slices $(D s) in the following\n    way $(D haystack[startIdx .. $]). $(D startIdx) represents a codeunit\n    index in $(D haystack). If the sequence ending at $(D startIdx) does not\n    represent a well formed codepoint, then a $(XREF utf,UTFException) may be\n    thrown.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        startIdx = slices haystack like this $(D haystack[startIdx .. $]). If\n        the startIdx is greater equal the length of haystack the functions\n        returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1484_1994)\n---\nimport std.conv : to;\n\nptrdiff_t i = \"helloWorld\".indexOfAny(\"Wr\", 4);\nassert(i == 5);\n\ni = \"Foo Ã¶Ã¤llo world\".indexOfAny(\"lh\", 3);\nassert(i == 8, to!string(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1484_1994)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfAny",
						"line": 1553,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1558,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfAny",
				"line": 1553,
				"comment": "    Returns the index of the last occurence of any of the elements in $(D\n    needles) in $(D haystack). If no element of $(D needles) is found,\n    then $(D -1) is returned.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1561_1996)\n---\nptrdiff_t i = \"helloWorld\".lastIndexOfAny(\"Wlo\");\nassert(i == 8);\n\ni = \"Foo Ã¶Ã¤Ã¶llo world\".lastIndexOfAny(\"Ã¶F\");\nassert(i == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1561_1996)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfAny",
						"line": 1641,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t stopIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "stopIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1652,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfAny",
				"line": 1641,
				"comment": "    Returns the index of the last occurence of any of the elements in $(D\n    needles) in $(D haystack). If no element of $(D needles) is found,\n    then $(D -1) is returned. The $(D stopIdx) slices $(D s) in the following\n    way $(D s[0 .. stopIdx]). $(D stopIdx) represents a codeunit index in\n    $(D s). If the sequence ending at $(D startIdx) does not represent a well\n    formed codepoint, then a $(XREF utf,UTFException) may be thrown.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        stopIdx = slices haystack like this $(D haystack[0 .. stopIdx]). If\n        the stopIdx is greater equal the length of haystack the functions\n        returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1655_1998)\n---\nimport std.conv : to;\n\nptrdiff_t i = \"helloWorld\".lastIndexOfAny(\"Wlo\", 4);\nassert(i == 3);\n\ni = \"Foo Ã¶Ã¤Ã¶llo world\".lastIndexOfAny(\"Ã¶F\", 3);\nassert(i == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1655_1998)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfNeither",
						"line": 1730,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1736,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfNeither",
				"line": 1730,
				"comment": "    Returns the index of the first occurence of any character not an elements\n    in $(D needles) in $(D haystack). If all element of $(D haystack) are\n    element of $(D needles) $(D -1) is returned.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1739_2000)\n---\nassert(indexOfNeither(\"def\", \"a\") == 0);\nassert(indexOfNeither(\"def\", \"de\") == 2);\nassert(indexOfNeither(\"dfefffg\", \"dfe\") == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1739_2000)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexOfNeither",
						"line": 1805,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t startIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "startIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1821,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "indexOfNeither",
				"line": 1805,
				"comment": "    Returns the index of the first occurence of any character not an elements\n    in $(D needles) in $(D haystack). If all element of $(D haystack) are\n    element of $(D needles) $(D -1) is returned.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        startIdx = slices haystack like this $(D haystack[startIdx .. $]). If\n        the startIdx is greater equal the length of haystack the functions\n        returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1824_2002)\n---\nassert(indexOfNeither(\"abba\", \"a\", 2) == 2);\nassert(indexOfNeither(\"def\", \"de\", 1) == 2);\nassert(indexOfNeither(\"dfefffg\", \"dfe\", 4) == 6);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1824_2002)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfNeither",
						"line": 1886,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1892,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfNeither",
				"line": 1886,
				"comment": "    Returns the last index of the first occurence of any character that is not\n    an elements in $(D needles) in $(D haystack). If all element of\n    $(D haystack) are element of $(D needles) $(D -1) is returned.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1895_2004)\n---\nassert(lastIndexOfNeither(\"abba\", \"a\") == 2);\nassert(lastIndexOfNeither(\"def\", \"f\") == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1895_2004)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lastIndexOfNeither",
						"line": 1961,
						"type": "pure @safe ptrdiff_t(const(Char)[] haystack, const(Char2)[] needles, in size_t stopIdx, in CaseSensitive cs = CaseSensitive.yes)",
						"parameters": [
							{
								"name": "haystack",
								"type": "const(Char)[]"
							},
							{
								"name": "needles",
								"type": "const(Char2)[]"
							},
							{
								"name": "stopIdx",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "cs",
								"type": "CaseSensitive",
								"storageClass": [
									"in"
								],
								"default": "CaseSensitive.yes"
							}
						],
						"endline": 1973,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "lastIndexOfNeither",
				"line": 1961,
				"comment": "    Returns the last index of the first occurence of any character that is not\n    an elements in $(D needles) in $(D haystack). If all element of\n    $(D haystack) are element of $(D needles) $(D -1) is returned.\n\n    Params:\n    haystack = String to search for needles in.\n    needles = Strings to search for in haystack.\n        stopIdx = slices haystack like this $(D haystack[0 .. stopIdx]) If\n        the stopIdx is greater equal the length of haystack the functions\n        returns $(D -1).\n        cs = Indicates whether the comparisons are case sensitive.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1976_2006)\n---\nassert(lastIndexOfNeither(\"def\", \"rsa\", 3) == -1);\nassert(lastIndexOfNeither(\"abba\", \"a\", 2) == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1976_2006)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "Char2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char && isSomeChar!Char2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "representation",
						"line": 2040,
						"type": "pure nothrow @nogc @safe (Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]"
							}
						],
						"endline": 2045,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "representation",
				"line": 2040,
				"comment": " Returns the _representation of a string, which has the same type\n as the string except the character type is replaced by $(D ubyte),\n $(D ushort), or $(D uint) depending on the character width.\n\n Params:\n     s = The string to return the _representation of.\n\n Returns:\n     The _representation of the passed string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2048_2008)\n---\nstring s = \"hello\";\nstatic assert(is(typeof(representation(s)) == immutable(ubyte)[]));\nassert(representation(s) is cast(immutable(ubyte)[]) s);\nassert(representation(s) == [0x68, 0x65, 0x6c, 0x6c, 0x6f]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2048_2008)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "capitalize",
						"line": 2100,
						"type": "pure @trusted S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 2136,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "capitalize",
				"line": 2100,
				"comment": " Capitalize the first character of $(D s) and convert the rest of $(D s)\n to lowercase.\n\n Params:\n     s = The string to _capitalize.\n\n Returns:\n     The capitalized string.\n\n See_Also:\n      $(XREF uni, toCapitalized) for a lazy range version that doesn't allocate memory\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"name": "KeepTerminator",
				"line": 2201,
				"comment": "    Split $(D s) into an array of lines according to the unicode standard using\n    $(D '\\r'), $(D '\\n'), $(D \"\\r\\n\"), $(XREF uni, lineSep),\n    $(XREF uni, paraSep), $(D U+0085) (NEL), $(D '\\v')  and $(D '\\f')\n    as delimiters. If $(D keepTerm) is set to $(D KeepTerminator.yes), then the\n    delimiter is included in the strings returned.\n\n    Does not throw on invalid UTF; such is simply passed unchanged\n    to the output.\n\n    Allocates memory; use $(LREF lineSplitter) for an alternative that\n    does not.\n\n    Adheres to $(WEB http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf, Unicode 7.0).\n\n  Params:\n    s = a string of $(D chars), $(D wchars), or $(D dchars)\n    keepTerm = whether delimiter is included or not in the results\n  Returns:\n    array of strings, each element is a line that is a slice of $(D s)\n  See_Also:\n    $(LREF lineSplitter)\n    $(XREF algorithm, splitter)\n    $(XREF regex, splitter)\n",
				"deco": "E3std8typecons45__T4FlagVAyaa14_6b6565705465726d696e61746f72Z4Flag",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitLines",
						"line": 2203,
						"type": "pure @safe S[](S s, in KeepTerminator keepTerm = KeepTerminator.no)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "keepTerm",
								"type": "KeepTerminator",
								"storageClass": [
									"in"
								],
								"default": "KeepTerminator.no"
							}
						],
						"endline": 2284,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "splitLines",
				"line": 2203,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lineSplitter",
						"line": 2377,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 2514,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "lineSplitter",
				"line": 2377,
				"comment": "  Split an array or slicable range of characters into a range of lines\n    using $(D '\\r'), $(D '\\n'), $(D '\\v'), $(D '\\f'), $(D \"\\r\\n\"),\n    $(XREF uni, lineSep), $(XREF uni, paraSep) and $(D '\\u0085') (NEL)\n    as delimiters. If $(D keepTerm) is set to $(D KeepTerminator.yes), then the\n    delimiter is included in the slices returned.\n\n    Does not throw on invalid UTF; such is simply passed unchanged\n    to the output.\n\n    Adheres to $(WEB http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf, Unicode 7.0).\n\n    Does not allocate memory.\n\n  Params:\n    r = array of $(D chars), $(D wchars), or $(D dchars) or a slicable range\n    keepTerm = whether delimiter is included or not in the results\n  Returns:\n    range of slices of the input range $(D r)\n\n  See_Also:\n    $(LREF splitLines)\n    $(XREF algorithm, splitter)\n    $(XREF regex, splitter)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2584_2013)\n---\nauto s = \"\\rpeter\\n\\rpaul\\r\\njerry\\u2028ice\\u2029cream\\n\\nsunday\\nmon\\u2030day\\n\";\nauto lines = s.lineSplitter();\nstatic immutable witness = [\"\", \"peter\", \"\", \"paul\", \"jerry\", \"ice\", \"cream\", \"\", \"sunday\", \"mon\\u2030day\"];\nuint i;\nforeach (line; lines)\n{\n    assert(line == witness[i++]);\n}\nassert(i == witness.length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2584_2013)\n",
				"parameters": [
					{
						"name": "keepTerm",
						"defaultValue": "KeepTerminator.no",
						"deco": "E3std8typecons45__T4FlagVAyaa14_6b6565705465726d696e61746f72Z4Flag",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "hasSlicing!Range && hasLength!Range || isSomeString!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripLeft",
						"line": 2608,
						"type": "Range(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 2633,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripLeft",
				"line": 2608,
				"comment": "    Strips leading whitespace (as defined by $(XREF uni, isWhite)).\n\n    Params:\n        str = string or ForwardRange of characters\n\n    Returns: $(D str) stripped of leading whitespace.\n\n    Postconditions: $(D str) and the returned value\n    will share the same tail (see $(XREF array, sameTail)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2636_2014)\n---\nimport std.uni : lineSep, paraSep;\nassert(stripLeft(\"     hello world     \") ==\n       \"hello world     \");\nassert(stripLeft(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\\n\\t\\v\\r\");\nassert(stripLeft(\"hello world\") ==\n       \"hello world\");\nassert(stripLeft([lineSep] ~ \"hello world\" ~ lineSep) ==\n       \"hello world\" ~ [lineSep]);\nassert(stripLeft([paraSep] ~ \"hello world\" ~ paraSep) ==\n       \"hello world\" ~ [paraSep]);\n\nimport std.utf : byChar;\nimport std.array;\nassert(stripLeft(\"     hello world     \"w.byChar).array ==\n       \"hello world     \");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2636_2014)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripRight",
						"line": 2666,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 2756,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stripRight",
				"line": 2666,
				"comment": "    Strips trailing whitespace (as defined by $(XREF uni, isWhite)).\n\n    Params:\n        str = string or random access range of characters\n\n    Returns:\n        slice of $(D str) stripped of trailing whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2760_2015)\n---\nimport std.uni : lineSep, paraSep;\nassert(stripRight(\"     hello world     \") ==\n       \"     hello world\");\nassert(stripRight(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"\\n\\t\\v\\rhello world\");\nassert(stripRight(\"hello world\") ==\n       \"hello world\");\nassert(stripRight([lineSep] ~ \"hello world\" ~ lineSep) ==\n       [lineSep] ~ \"hello world\");\nassert(stripRight([paraSep] ~ \"hello world\" ~ paraSep) ==\n       [paraSep] ~ \"hello world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2760_2015)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!Range || isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strip",
						"line": 2810,
						"type": "(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 2816,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "strip",
				"line": 2810,
				"comment": "    Strips both leading and trailing whitespace (as defined by\n    $(XREF uni, isWhite)).\n\n    Params:\n        str = string or random access range of characters\n\n    Returns:\n        slice of $(D str) stripped of leading and trailing whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2819_2017)\n---\nimport std.uni : lineSep, paraSep;\nassert(strip(\"     hello world     \") ==\n       \"hello world\");\nassert(strip(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\");\nassert(strip(\"hello world\") ==\n       \"hello world\");\nassert(strip([lineSep] ~ \"hello world\" ~ [lineSep]) ==\n       \"hello world\");\nassert(strip([paraSep] ~ \"hello world\" ~ [paraSep]) ==\n       \"hello world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2819_2017)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!Range || isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chomp",
						"line": 2901,
						"type": "Range(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 2953,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chomp",
				"line": 2901,
				"comment": "    If $(D str) ends with $(D delimiter), then $(D str) is returned without\n    $(D delimiter) on its end. If it $(D str) does $(I not) end with\n    $(D delimiter), then it is returned unchanged.\n\n    If no $(D delimiter) is given, then one trailing  $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(D '\\f'), $(D '\\v'), $(XREF uni, lineSep), $(XREF uni, paraSep), or $(XREF uni, nelSep)\n    is removed from the end of $(D str). If $(D str) does not end with any of those characters,\n    then it is returned unchanged.\n\n    Params:\n        str = string or indexable range of characters\n        delimiter = string of characters to be sliced off end of str[]\n\n    Returns:\n        slice of str\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2996_2020)\n---\nimport std.utf : decode;\nimport std.uni : lineSep, paraSep, nelSep;\nassert(chomp(\" hello world  \\n\\r\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\r\\n\") == \" hello world  \");\nassert(chomp(\" hello world  \\f\") == \" hello world  \");\nassert(chomp(\" hello world  \\v\") == \" hello world  \");\nassert(chomp(\" hello world  \\n\\n\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\n\\n \") == \" hello world  \\n\\n \");\nassert(chomp(\" hello world  \\n\\n\" ~ [lineSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [paraSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [ nelSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world\") == \" hello world\");\nassert(chomp(\"\") == \"\");\n\nassert(chomp(\" hello world\", \"orld\") == \" hello w\");\nassert(chomp(\" hello world\", \" he\") == \" hello world\");\nassert(chomp(\"\", \"hello\") == \"\");\n\n// Don't decode pointlessly\nassert(chomp(\"hello\\xFE\", \"\\r\") == \"hello\\xFE\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2996_2020)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isSomeChar!(ElementEncodingType!Range) || isSomeString!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chomp",
						"line": 2956,
						"type": "Range(Range str, const(C2)[] delimiter)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							},
							{
								"name": "delimiter",
								"type": "const(C2)[]"
							}
						],
						"endline": 2992,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chomp",
				"line": 2956,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "(isBidirectionalRange!Range && isSomeChar!(ElementEncodingType!Range) || isSomeString!Range) && isSomeChar!C2",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chompPrefix",
						"line": 3093,
						"type": "Range(Range str, const(C2)[] delimiter)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							},
							{
								"name": "delimiter",
								"type": "const(C2)[]"
							}
						],
						"endline": 3126,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chompPrefix",
				"line": 3093,
				"comment": "    If $(D str) starts with $(D delimiter), then the part of $(D str) following\n    $(D delimiter) is returned. If $(D str) does $(I not) start with\n\n    $(D delimiter), then it is returned unchanged.\n\n    Params:\n        str = string or forward range of characters\n        delimiter = string of characters to be sliced off front of str[]\n\n    Returns:\n        slice of str\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3129_2022)\n---\nassert(chompPrefix(\"hello world\", \"he\") == \"llo world\");\nassert(chompPrefix(\"hello world\", \"hello w\") == \"orld\");\nassert(chompPrefix(\"hello world\", \" world\") == \"hello world\");\nassert(chompPrefix(\"\", \"hello\") == \"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3129_2022)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "(isForwardRange!Range && isSomeChar!(ElementEncodingType!Range) || isSomeString!Range) && isSomeChar!C2",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chop",
						"line": 3185,
						"type": "Range(Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 3239,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "chop",
				"line": 3185,
				"comment": "    Returns $(D str) without its last character, if there is one. If $(D str)\n    ends with $(D \"\\r\\n\"), then both are removed. If $(D str) is empty, then\n    then it is returned unchanged.\n\n    Params:\n        str = string (must be valid UTF)\n    Returns:\n        slice of str\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3242_2024)\n---\nassert(chop(\"hello world\") == \"hello worl\");\nassert(chop(\"hello world\\n\") == \"hello world\");\nassert(chop(\"hello world\\r\") == \"hello world\");\nassert(chop(\"hello world\\n\\r\") == \"hello world\\n\");\nassert(chop(\"hello world\\r\\n\") == \"hello world\");\nassert(chop(\"Walter Bright\") == \"Walter Brigh\");\nassert(chop(\"\") == \"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3242_2024)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!Range || isBidirectionalRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "leftJustify",
						"line": 3327,
						"type": "S(S s, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3332,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "leftJustify",
				"line": 3327,
				"comment": "    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        s = string\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        GC allocated string\n\n    See_Also:\n        $(LREF leftJustifier), which does not allocate\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "leftJustifier",
						"line": 3351,
						"type": "(Range r, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3416,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "leftJustifier",
				"line": 3351,
				"comment": "    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        r = string or range of characters\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        a lazy range of the left justified result\n\n    See_Also:\n        $(LREF rightJustifier)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3420_2027)\n---\nimport std.algorithm : equal;\nimport std.utf : byChar;\nassert(leftJustifier(\"hello\", 2).equal(\"hello\".byChar));\nassert(leftJustifier(\"hello\", 7).equal(\"hello  \".byChar));\nassert(leftJustifier(\"hello\", 7, 'x').equal(\"helloxx\".byChar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3420_2027)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rightJustify",
						"line": 3455,
						"type": "S(S s, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3460,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "rightJustify",
				"line": 3455,
				"comment": "    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        s = string\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        GC allocated string\n\n    See_Also:\n        $(LREF rightJustifier), which does not allocate\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "rightJustifier",
						"line": 3479,
						"type": "(Range r, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3574,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "rightJustifier",
				"line": 3479,
				"comment": "    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n\n    Params:\n        r = string or forward range of characters\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        a lazy range of the right justified result\n\n    See_Also:\n        $(LREF leftJustifier)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3578_2029)\n---\nimport std.algorithm : equal;\nimport std.utf : byChar;\nassert(rightJustifier(\"hello\", 2).equal(\"hello\".byChar));\nassert(rightJustifier(\"hello\", 7).equal(\"  hello\".byChar));\nassert(rightJustifier(\"hello\", 7, 'x').equal(\"xxhello\".byChar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3578_2029)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "center",
						"line": 3613,
						"type": "S(S s, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3618,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "center",
				"line": 3613,
				"comment": "    Center $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "centerJustifier",
						"line": 3675,
						"type": "(Range r, size_t width, dchar fillChar = ' ')",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "width",
								"type": "size_t"
							},
							{
								"name": "fillChar",
								"deco": "w",
								"default": "' '"
							}
						],
						"endline": 3703,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "centerJustifier",
				"line": 3675,
				"comment": "    Center justify $(D r) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D r) doesn't fill.\n\n    Params:\n        r = string or forward range of characters\n        width = minimum field width\n        fillChar = used to pad end up to $(D width) characters\n\n    Returns:\n        a lazy range of the center justified result\n\n    See_Also:\n        $(LREF leftJustifier)\n        $(LREF rightJustifier)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3707_2032)\n---\nimport std.algorithm : equal;\nimport std.utf : byChar;\nassert(centerJustifier(\"hello\", 2).equal(\"hello\".byChar));\nassert(centerJustifier(\"hello\", 8).equal(\" hello  \".byChar));\nassert(centerJustifier(\"hello\", 7, 'x').equal(\"xhellox\".byChar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3707_2032)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "detab",
						"line": 3766,
						"type": "pure S(S s, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 3771,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "detab",
				"line": 3766,
				"comment": "    Replace each tab character in $(D s) with the number of spaces necessary\n    to align the following character at the next tab stop.\n\n    Params:\n        s = string\n        tabSize = distance between tab stops\n\n    Returns:\n        GC allocated string with tabs replaced with spaces\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "detabber",
						"line": 3784,
						"type": "(Range r, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 3891,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "detabber",
				"line": 3784,
				"comment": "    Replace each tab character in $(D r) with the number of spaces necessary\n    to align the following character at the next tab stop.\n\n    Params:\n        r = string or forward range\n        tabSize = distance between tab stops\n\n    Returns:\n        lazy forward range with tabs replaced with spaces\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3894_2034)\n---\nimport std.array;\n\nassert(detabber(\" \\n\\tx\", 9).array == \" \\n         x\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3894_2034)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3934_2036)\n---\nimport std.utf;\nimport std.array;\n\nassert(detabber(\" \\u2029\\t\".byChar, 9).array == \" \\u2029         \");\nauto r = \"hel\\tx\".byWchar.detabber();\nassert(r.front == 'h' && r.front == 'h');\nauto s = r.save;\nr.popFront();\nr.popFront();\nassert(r.front == 'l');\nassert(s.front == 'h');\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3934_2036)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entab",
						"line": 3964,
						"type": "@trusted S(S s, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 3969,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "entab",
				"line": 3964,
				"comment": "    Replaces spaces in $(D s) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        s       = String to convert.\n        tabSize = Tab columns are $(D tabSize) spaces apart.\n\n    Returns:\n        GC allocated string with spaces replaced with tabs;\n        use $(LREF entabber) to not allocate.\n\n    See_Also:\n        $(LREF entabber)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3972_2037)\n---\nassert(entab(\"        x \\n\") == \"\\tx\\n\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3972_2037)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "entabber",
						"line": 3991,
						"type": "(Range r, size_t tabSize = 8)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "tabSize",
								"type": "size_t",
								"default": "8"
							}
						],
						"endline": 4208,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "entabber",
				"line": 3991,
				"comment": "    Replaces spaces in range $(D r) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        r = string or forward range\n        tabSize = distance between tab stops\n\n    Returns:\n        lazy forward range with spaces replaced with tabs\n\n    See_Also:\n        $(LREF entab)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4211_2038)\n---\nimport std.array;\nassert(entabber(\"        x \\n\").array == \"\\tx\\n\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4211_2038)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4301,
						"type": "pure @safe C1[](C1[] str, in dchar[dchar] transTable, const(C2)[] toRemove = null)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "dchar[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]",
								"default": "null"
							}
						],
						"endline": 4310,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4301,
				"comment": "    Replaces the characters in $(D str) which are keys in $(D transTable) with\n    their corresponding values in $(D transTable). $(D transTable) is an AA\n    where its keys are $(D dchar) and its values are either $(D dchar) or some\n    type of string. Also, if $(D toRemove) is given, the characters in it are\n    removed from $(D str) prior to translation. $(D str) itself is unaltered.\n    A copy with the changes is returned.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4313_2041)\n---\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\nassert(translate(\"hello world\", transTable2) == \"h5llorange worangerld\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4313_2041)\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeChar!C2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4381,
						"type": "pure @safe C1[](C1[] str, in S[dchar] transTable, const(C2)[] toRemove = null)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "S[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]",
								"default": "null"
							}
						],
						"endline": 4390,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4381,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeString!S && isSomeChar!C2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4456,
						"type": "void(C1[] str, in dchar[dchar] transTable, const(C2)[] toRemove, Buffer buffer)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "dchar[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]"
							},
							{
								"name": "buffer",
								"type": "Buffer"
							}
						],
						"endline": 4463,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4456,
				"comment": "    This is an overload of $(D translate) which takes an existing buffer to write the contents to.\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\n        buffer     = An output range to write the contents to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4466_2045)\n---\nimport std.array : appender;\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nauto buffer = appender!(dchar[])();\ntranslate(\"hello world\", transTable1, null, buffer);\nassert(buffer.data == \"h5ll7 w7rld\");\n\nbuffer.clear();\ntranslate(\"hello world\", transTable1, \"low\", buffer);\nassert(buffer.data == \"h5 rd\");\n\nbuffer.clear();\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\ntranslate(\"hello world\", transTable2, null, buffer);\nassert(buffer.data == \"h5llorange worangerld\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4466_2045)\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					},
					{
						"name": "Buffer",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeChar!C2 && isOutputRange!(Buffer, C1)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4503,
						"type": "void(C1[] str, in S[dchar] transTable, const(C2)[] toRemove, Buffer buffer)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "transTable",
								"type": "S[dchar]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "const(C2)[]"
							},
							{
								"name": "buffer",
								"type": "Buffer"
							}
						],
						"endline": 4510,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4503,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C2",
						"kind": "type"
					},
					{
						"name": "Buffer",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C1 && isSomeString!S && isSomeChar!C2 && isOutputRange!(Buffer, S)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4569,
						"type": "pure nothrow @trusted C[](in char[] str, in char[] transTable, in char[] toRemove = null)",
						"parameters": [
							{
								"name": "str",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "transTable",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "char[]",
								"storageClass": [
									"in"
								],
								"default": "null"
							}
						],
						"endline": 4599,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4569,
				"comment": "    This is an $(I $(RED ASCII-only)) overload of $(LREF _translate). It\n    will $(I not) work with Unicode. It exists as an optimization for the\n    cases where Unicode processing is not necessary.\n\n    Unlike the other overloads of $(LREF _translate), this one does not take\n    an AA. Rather, it takes a $(D string) generated by $(LREF makeTransTable).\n\n    The array generated by $(D makeTransTable) is $(D 256) elements long such that\n    the index is equal to the ASCII character being replaced and the value is\n    equal to the character that it's being replaced with. Note that translate\n    does not decode any of the characters, so you can actually pass it Extended\n    ASCII characters if you want to (ASCII only actually uses $(D 128)\n    characters), but be warned that Extended ASCII characters are not valid\n    Unicode and therefore will result in a $(D UTFException) being thrown from\n    most other Phobos functions.\n\n    Also, because no decoding occurs, it is possible to use this overload to\n    translate ASCII characters within a proper UTF-8 string without altering the\n    other, non-ASCII characters. It's replacing any code unit greater than\n    $(D 127) with another code unit or replacing any code unit with another code\n    unit greater than $(D 127) which will cause UTF validation issues.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTransTable).\n        toRemove   = The characters to remove from the string.\n",
				"parameters": [
					{
						"defaultDeco": "ya",
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "is(Unqual!C == char)",
				"char": 5,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "makeTrans",
				"line": 4608,
				"comment": " Do same thing as $(LREF makeTransTable) but allocate the translation table\n on the GC heap.\n\n Use $(LREF makeTransTable) instead.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4614_2047)\n---\nauto transTable1 = makeTrans(\"eo5\", \"57q\");\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4614_2047)\n",
				"deco": "FNaNbNexAaxAaZAya",
				"parameters": [
					{
						"name": "from",
						"deco": "xAa"
					},
					{
						"name": "to",
						"deco": "xAa"
					}
				],
				"endline": 4611,
				"originalType": "pure nothrow @trusted string(in char[] from, in char[] to)",
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "makeTransTable",
				"line": 4633,
				"comment": " Construct 256 character translation table, where characters in from[] are replaced\n by corresponding characters in to[].\n\n Params:\n      from = array of chars, less than or equal to 256 in length\n      to = corresponding array of chars to translate to\n Returns:\n      translation array\n",
				"deco": "FNaNbNiNfxAaxAaZG256a",
				"parameters": [
					{
						"name": "from",
						"deco": "xAa"
					},
					{
						"name": "to",
						"deco": "xAa"
					}
				],
				"endline": 4653,
				"originalType": "pure nothrow @nogc @safe char[256](in char[] from, in char[] to)",
				"char": 11,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "translate",
						"line": 4707,
						"type": "pure @trusted void(in char[] str, in char[] transTable, in char[] toRemove, Buffer buffer)",
						"parameters": [
							{
								"name": "str",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "transTable",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "toRemove",
								"type": "char[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "buffer",
								"type": "Buffer"
							}
						],
						"endline": 4726,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "translate",
				"line": 4707,
				"comment": "    This is an $(I $(RED ASCII-only)) overload of $(D translate) which takes an existing buffer to write the contents to.\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTransTable).\n        toRemove   = The characters to remove from the string.\n        buffer     = An output range to write the contents to.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4729_2049)\n---\nimport std.array : appender;\nauto buffer = appender!(char[])();\nauto transTable1 = makeTransTable(\"eo5\", \"57q\");\ntranslate(\"hello world\", transTable1, null, buffer);\nassert(buffer.data == \"h5ll7 w7rld\");\n\nbuffer.clear();\ntranslate(\"hello world\", transTable1, \"low\", buffer);\nassert(buffer.data == \"h5 rd\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4729_2049)\n",
				"parameters": [
					{
						"defaultDeco": "ya",
						"name": "C",
						"kind": "type"
					},
					{
						"name": "Buffer",
						"kind": "type"
					}
				],
				"constraint": "is(Unqual!C == char) && isOutputRange!(Buffer, char)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inPattern",
						"line": 4762,
						"type": "pure @nogc @safe bool(dchar c, in S pattern)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "pattern",
								"type": "S",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 4792,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "inPattern",
				"line": 4762,
				"comment": " See if character c is in the pattern.\n Patterns:\n\n  A <i>pattern</i> is an array of characters much like a <i>character\n  class</i> in regular expressions. A sequence of characters\n  can be given, such as \"abcde\". The '-' can represent a range\n  of characters, as \"a-e\" represents the same pattern as \"abcde\".\n  \"a-fA-F0-9\" represents all the hex characters.\n  If the first character of a pattern is '^', then the pattern\n  is negated, i.e. \"^0-9\" means any character except a digit.\n  The functions inPattern, <b>countchars</b>, <b>removeschars</b>,\n  and <b>squeeze</b>\n  use patterns.\n\n Note: In the future, the pattern syntax may be improved\n  to be more like regular expression character classes.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inPattern",
						"line": 4831,
						"type": "pure @nogc @safe bool(dchar c, S[] patterns)",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							},
							{
								"name": "patterns",
								"type": "S[]"
							}
						],
						"endline": 4841,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "inPattern",
				"line": 4831,
				"comment": " See if character c is in the intersection of the patterns.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countchars",
						"line": 4848,
						"type": "pure @nogc @safe size_t(S s, in S1 pattern)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "pattern",
								"type": "S1",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 4856,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "countchars",
				"line": 4848,
				"comment": " Count characters in s that match pattern.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					},
					{
						"name": "S1",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S && isSomeString!S1",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "removechars",
						"line": 4877,
						"type": "pure @safe S(S s, in S pattern)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "pattern",
								"type": "S",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 4904,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "removechars",
				"line": 4877,
				"comment": " Return string that is s with all characters removed that match pattern.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "squeeze",
						"line": 4929,
						"type": "S(S s, in S pattern = null)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "pattern",
								"type": "S",
								"storageClass": [
									"in"
								],
								"default": "null"
							}
						],
						"endline": 4970,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "squeeze",
				"line": 4929,
				"comment": " Return string where sequences of a character in s[] from pattern[]\n are replaced with a single instance of that character.\n If pattern is null, it defaults to all characters.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "munch",
						"line": 5006,
						"type": "pure @nogc @safe S1(ref S1 s, S2 pattern)",
						"parameters": [
							{
								"name": "s",
								"type": "S1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "pattern",
								"type": "S2"
							}
						],
						"endline": 5019,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "munch",
				"line": 5006,
				"comment": " Finds the position $(D_PARAM pos) of the first character in $(D_PARAM\n s) that does not match $(D_PARAM pattern) (in the terminology used by\n $(LINK2 std_string.html,inPattern)). Updates $(D_PARAM s =\n s[pos..$]). Returns the slice from the beginning of the original\n (before update) string up to, and excluding, $(D_PARAM pos).\n\nThe $(D_PARAM munch) function is mostly convenient for skipping\ncertain category of characters (e.g. whitespace) when parsing\nstrings. (In such cases, the return value is not used.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5022_2054)\n---\nstring s = \"123abc\";\nstring t = munch(s, \"0123456789\");\nassert(t == \"123\" && s == \"abc\");\nt = munch(s, \"0123456789\");\nassert(t == \"\" && s == \"abc\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5022_2054)\n",
				"parameters": [
					{
						"name": "S1",
						"kind": "type"
					},
					{
						"name": "S2",
						"kind": "type"
					}
				],
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "succ",
						"line": 5050,
						"type": "pure @safe S(S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 5094,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "succ",
				"line": 5050,
				"comment": " Return string that is the 'successor' to s[].\n If the rightmost character is a-zA-Z0-9, it is incremented within\n its case or digits. If it generates a carry, the process is\n repeated with the one to its immediate left.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5097_2056)\n---\nassert(succ(\"1\") == \"2\");\nassert(succ(\"9\") == \"10\");\nassert(succ(\"999\") == \"1000\");\nassert(succ(\"zz99\") == \"aaa00\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5097_2056)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "tr",
						"line": 5163,
						"type": "C1[](C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null)",
						"parameters": [
							{
								"name": "str",
								"type": "C1[]"
							},
							{
								"name": "from",
								"type": "const(C2)[]"
							},
							{
								"name": "to",
								"type": "const(C3)[]"
							},
							{
								"name": "modifiers",
								"type": "const(C4)[]",
								"default": "null"
							}
						],
						"endline": 5275,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "tr",
				"line": 5163,
				"comment": "    Replaces the characters in $(D str) which are in $(D from) with the\n    the corresponding characters in $(D to) and returns the resulting string.\n\n    $(D tr) is based on\n    $(WEB pubs.opengroup.org/onlinepubs/9699919799/utilities/_tr.html, Posix's tr),\n    though it doesn't do everything that the Posix utility does.\n\n    Params:\n        str       = The original string.\n        from      = The characters to replace.\n        to        = The characters to replace with.\n        modifiers = String containing modifiers.\n\n    Modifiers:\n        $(BOOKTABLE,\n        $(TR $(TD Modifier) $(TD Description))\n        $(TR $(TD $(D 'c')) $(TD Complement the list of characters in $(D from)))\n        $(TR $(TD $(D 'd')) $(TD Removes matching characters with no corresponding\n                              replacement in $(D to)))\n        $(TR $(TD $(D 's')) $(TD Removes adjacent duplicates in the replaced\n                              characters))\n        )\n\n    If the modifier $(D 'd') is present, then the number of characters in\n    $(D to) may be only $(D 0) or $(D 1).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is empty, then\n    $(D to) is taken to be the same as $(D from).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is shorter than\n    $(D from), then $(D to) is extended by replicating the last character in\n    $(D to).\n\n    Both $(D from) and $(D to) may contain ranges using the $(D '-') character\n    (e.g. $(D \"a-d\") is synonymous with $(D \"abcd\").) Neither accept a leading\n    $(D '^') as meaning the complement of the string (use the $(D 'c') modifier\n    for that).\n",
				"parameters": [
					{
						"name": "C1",
						"kind": "type"
					},
					{
						"name": "C2",
						"kind": "type"
					},
					{
						"name": "C3",
						"kind": "type"
					},
					{
						"defaultDeco": "ya",
						"name": "C4",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "isNumeric",
				"line": 5370,
				"comment": " [in] string s can be formatted in the following ways:\n\n Integer Whole Number:\n (for byte, ubyte, short, ushort, int, uint, long, and ulong)\n ['+'|'-']digit(s)[U|L|UL]\n\n examples: 123, 123UL, 123L, +123U, -123L\n\n Floating-Point Number:\n (for float, double, real, ifloat, idouble, and ireal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|inf|-inf]\n\n examples: +123., -123.01, 123.3e-10f, 123.3e-10fi, 123.3e-10L\n\n (for cfloat, cdouble, and creal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+]\n         [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|nan+nani|inf|-inf]\n\n examples: nan, -123e-1+456.9e-10Li, +123e+10+456i, 123+456\n\n [in] bool bAllowSep\n False by default, but when set to true it will accept the\n separator characters $(D ',') and $(D '__') within the string, but these\n characters should be stripped from the string before using any\n of the conversion functions like toInt(), toFloat(), and etc\n else an error will occur.\n\n Also please note, that no spaces are allowed within the string\n anywhere whether it's a leading, trailing, or embedded space(s),\n thus they too must be stripped from the string before using this\n function, or any of the conversion functions.\n",
				"deco": "FNaNfAxaxbZb",
				"parameters": [
					{
						"name": "s",
						"deco": "Axa"
					},
					{
						"name": "bAllowSep",
						"deco": "xb",
						"default": "false"
					}
				],
				"endline": 5477,
				"originalType": "pure @safe bool(const(char)[] s, in bool bAllowSep = false)",
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "soundexer",
						"line": 5578,
						"type": "char[4](Range str)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							}
						],
						"endline": 5631,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "soundexer",
				"line": 5578,
				"comment": " Soundex algorithm.\n\n The Soundex algorithm converts a word into 4 characters\n based on how the word sounds phonetically. The idea is that\n two spellings that sound alike will have the same Soundex\n value, which means that Soundex can be used for fuzzy matching\n of names.\n\n Params:\n  str = String or InputRange to convert to Soundex representation.\n\n Returns:\n  The four character array with the Soundex result in it.\n  The array has zero's in it if there is no Soundex representation for the string.\n\n See_Also:\n  $(LINK2 http://en.wikipedia.org/wiki/Soundex, Wikipedia),\n  $(LUCKY The Soundex Indexing System)\n  $(LREF soundex)\n\n Bugs:\n  Only works well with English names.\n  There are other arguably better Soundex algorithms,\n  but this one is the standard one.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isSomeChar!(ElementEncodingType!Range)",
				"char": 9,
				"kind": "template"
			},
			{
				"endchar": 1,
				"name": "soundex",
				"line": 5648,
				"comment": " Like $(LREF soundexer), but with different parameters\n and return value.\n\n Params:\n  str = String to convert to Soundex representation.\n  buffer = Optional 4 char array to put the resulting Soundex\n      characters into. If null, the return value\n      buffer will be allocated on the heap.\n Returns:\n  The four character array with the Soundex result in it.\n  Returns null if there is no Soundex representation for the string.\n See_Also:\n  $(LREF soundexer)\n",
				"deco": "FNaNbNfAxaAaZAa",
				"parameters": [
					{
						"name": "str",
						"deco": "Axa"
					},
					{
						"name": "buffer",
						"deco": "Aa",
						"default": "null"
					}
				],
				"endline": 5673,
				"char": 8,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "abbrev",
				"line": 5764,
				"comment": " Construct an associative array consisting of all\n abbreviations that uniquely map to the strings in values.\n\n This is useful in cases where the user is expected to type\n in one of a known set of strings, and the program will helpfully\n autocomplete the string once sufficient characters have been\n entered that uniquely identify it.\n Example:\n ---\n import std.stdio;\n import std.string;\n\n void main()\n {\n    static string[] list = [ \"food\", \"foxy\" ];\n\n    auto abbrevs = std.string.abbrev(list);\n\n    foreach (key, value; abbrevs)\n    {\n       writefln(\"%s => %s\", key, value);\n    }\n }\n ---\n produces the output:\n <pre>\n fox =&gt; foxy\n food =&gt; food\n foxy =&gt; foxy\n foo =&gt; food\n </pre>\n",
				"deco": "FNaNfAAyaZHAyaAya",
				"parameters": [
					{
						"name": "values",
						"deco": "AAya"
					}
				],
				"endline": 5809,
				"char": 16,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "column",
						"line": 5864,
						"type": "size_t(Range str, in size_t tabsize = 8)",
						"parameters": [
							{
								"name": "str",
								"type": "Range"
							},
							{
								"name": "tabsize",
								"type": "size_t",
								"storageClass": [
									"in"
								],
								"default": "8"
							}
						],
						"endline": 5905,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "column",
				"line": 5864,
				"comment": " Compute _column number at the end of the printed form of the string,\n assuming the string starts in the leftmost _column, which is numbered\n starting from 0.\n\n Tab characters are expanded into enough spaces to bring the _column number\n to the next multiple of tabsize.\n If there are multiple lines in the string, the _column number of the last\n line is returned.\n\n Params:\n    str = string or InputRange to be analyzed\n    tabsize = number of columns a tab character represents\n\n Returns:\n    column number\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5908_2069)\n---\nimport std.utf : byChar, byWchar, byDchar;\n\nassert(column(\"1234 \") == 5);\nassert(column(\"1234 \"w) == 5);\nassert(column(\"1234 \"d) == 5);\n\nassert(column(\"1234 \".byChar()) == 5);\nassert(column(\"1234 \"w.byWchar()) == 5);\nassert(column(\"1234 \"d.byDchar()) == 5);\n\n// Tab stops are set at 8 spaces by default; tab characters insert enough\n// spaces to bring the column position to the next multiple of 8.\nassert(column(\"\\t\") == 8);\nassert(column(\"1\\t\") == 8);\nassert(column(\"\\t1\") == 9);\nassert(column(\"123\\t\") == 8);\n\n// Other tab widths are possible by specifying it explicitly:\nassert(column(\"\\t\", 4) == 4);\nassert(column(\"1\\t\", 4) == 4);\nassert(column(\"\\t1\", 4) == 5);\nassert(column(\"123\\t\", 4) == 4);\n\n// New lines reset the column number.\nassert(column(\"abc\\n\") == 0);\nassert(column(\"abc\\n1\") == 1);\nassert(column(\"abcdefg\\r1234\") == 4);\nassert(column(\"abc\\u20281\") == 1);\nassert(column(\"abc\\u20291\") == 1);\nassert(column(\"abc\\u00851\") == 1);\nassert(column(\"abc\\u00861\") == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5908_2069)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!Range || isInputRange!Range && isSomeChar!(Unqual!(ElementEncodingType!Range))",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "wrap",
						"line": 5978,
						"type": "pure @safe S(S s, in size_t columns = 80, S firstindent = null, S indent = null, in size_t tabsize = 8)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "columns",
								"type": "size_t",
								"storageClass": [
									"in"
								],
								"default": "80"
							},
							{
								"name": "firstindent",
								"type": "S",
								"default": "null"
							},
							{
								"name": "indent",
								"type": "S",
								"default": "null"
							},
							{
								"name": "tabsize",
								"type": "size_t",
								"storageClass": [
									"in"
								],
								"default": "8"
							}
						],
						"endline": 6042,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "wrap",
				"line": 5978,
				"comment": " Wrap text into a paragraph.\n\n The input text string s is formed into a paragraph\n by breaking it up into a sequence of lines, delineated\n by \\n, such that the number of columns is not exceeded\n on each line.\n The last line is terminated with a \\n.\n Params:\n  s = text string to be wrapped\n  columns = maximum number of _columns in the paragraph\n  firstindent = string used to _indent first line of the paragraph\n  indent = string to use to _indent following lines of the paragraph\n  tabsize = column spacing of tabs in firstindent[] and indent[]\n Returns:\n  resulting paragraph as an allocated string\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "outdent",
						"line": 6083,
						"type": "pure @safe S(S str)",
						"parameters": [
							{
								"name": "str",
								"type": "S"
							}
						],
						"endline": 6086,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "outdent",
				"line": 6083,
				"comment": " Removes one level of indentation from a multi-line string.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n Does not allocate memory if it does not throw.\n\n Params:\n     str = multi-line string\n\n Returns:\n      outdented string\n\n Throws:\n     StringException if indentation is done with different sequences\n     of whitespace characters.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6089_2072)\n---\nenum pretty = q{\n   import std.stdio;\n   void main() {\n       writeln(\"Hello\");\n   }\n}.outdent();\n\nenum ugly = q{\nimport std.stdio;\nvoid main() {\nwriteln(\"Hello\");\n}\n};\n\nassert(pretty == ugly);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6089_2072)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "outdent",
						"line": 6125,
						"type": "pure @safe S[](S[] lines)",
						"parameters": [
							{
								"name": "lines",
								"type": "S[]"
							}
						],
						"endline": 6182,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "outdent",
				"line": 6125,
				"comment": " Removes one level of indentation from an array of single-line strings.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n Params:\n     lines = array of single-line strings\n\n Returns:\n      lines[] is rewritten in place with outdented lines\n\n Throws:\n     StringException if indentation is done with different sequences\n     of whitespace characters.\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeUTF",
						"line": 6293,
						"type": "pure (T[] arr)",
						"parameters": [
							{
								"name": "arr",
								"type": "T[]"
							}
						],
						"endline": 6301,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assumeUTF",
				"line": 6293,
				"comment": " Assume the given array of integers $(D arr) is a well-formed UTF string and\nreturn it typed as a UTF string.\n\n$(D ubyte) becomes $(D char), $(D ushort) becomes $(D wchar) and $(D uint)\nbecomes $(D dchar). Type qualifiers are preserved.\n\nParams:\n    arr = array of bytes, ubytes, shorts, ushorts, ints, or uints\n\nReturns:\n    arr retyped as an array of chars, wchars, or dchars\n\nSee_Also: $(LREF representation)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6304_2074)\n---\nstring a = \"HÃ¶lo World\";\nimmutable(ubyte)[] b = a.representation;\nstring c = b.assumeUTF;\n\nassert(a == c);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6304_2074)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "staticIndexOf!(Unqual!T, ubyte, ushort, uint) != -1",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "String handling functions.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions) )\n$(TR $(TDNW Searching)\n    $(TD\n         $(MYREF column)\n         $(MYREF inPattern)\n         $(MYREF indexOf)\n         $(MYREF indexOfAny)\n         $(MYREF indexOfNeither)\n         $(MYREF lastIndexOf)\n         $(MYREF lastIndexOfAny)\n         $(MYREF lastIndexOfNeither)\n    )\n)\n$(TR $(TDNW Comparison)\n    $(TD\n         $(MYREF countchars)\n         $(MYREF isNumeric)\n    )\n)\n$(TR $(TDNW Mutation)\n    $(TD\n         $(MYREF capitalize)\n         $(MYREF munch)\n         $(MYREF removechars)\n         $(MYREF squeeze)\n    )\n)\n$(TR $(TDNW Pruning and Filling)\n    $(TD\n         $(MYREF center)\n         $(MYREF chomp)\n         $(MYREF chompPrefix)\n         $(MYREF chop)\n         $(MYREF detabber)\n         $(MYREF detab)\n         $(MYREF entab)\n         $(MYREF leftJustify)\n         $(MYREF outdent)\n         $(MYREF rightJustify)\n         $(MYREF strip)\n         $(MYREF stripLeft)\n         $(MYREF stripRight)\n         $(MYREF wrap)\n    )\n)\n$(TR $(TDNW Substitution)\n    $(TD\n         $(MYREF abbrev)\n         $(MYREF soundex)\n         $(MYREF soundexer)\n         $(MYREF succ)\n         $(MYREF tr)\n         $(MYREF translate)\n    )\n)\n$(TR $(TDNW Miscellaneous)\n    $(TD\n         $(MYREF assumeUTF)\n         $(MYREF fromStringz)\n         $(MYREF lineSplitter)\n         $(MYREF representation)\n         $(MYREF splitLines)\n         $(MYREF toStringz)\n    )\n)))\n\nObjects of types $(D _string), $(D wstring), and $(D dstring) are value types\nand cannot be mutated element-by-element. For using mutation during building\nstrings, use $(D char[]), $(D wchar[]), or $(D dchar[]). The $(D xxxstring)\ntypes are preferable because they don't exhibit undesired aliasing, thus\nmaking code more robust.\n\nThe following functions are publicly imported:\n\n$(BOOKTABLE ,\n$(TR $(TH Module) $(TH Functions) )\n$(LEADINGROW Publicly imported functions)\n    $(TR $(TD std.algorithm)\n        $(TD\n         $(SHORTXREF_PACK algorithm,comparison,cmp)\n         $(SHORTXREF_PACK algorithm,searching,count)\n         $(SHORTXREF_PACK algorithm,searching,endsWith)\n         $(SHORTXREF_PACK algorithm,searching,startsWith)\n    ))\n    $(TR $(TD std.array)\n        $(TD\n         $(SHORTXREF array, join)\n         $(SHORTXREF array, replace)\n         $(SHORTXREF array, replaceInPlace)\n         $(SHORTXREF array, split)\n    ))\n    $(TR $(TD std.format)\n        $(TD\n         $(SHORTXREF format, format)\n         $(SHORTXREF format, sformat)\n    ))\n    $(TR $(TD std.uni)\n        $(TD\n         $(SHORTXREF uni, icmp)\n         $(SHORTXREF uni, toLower)\n         $(SHORTXREF uni, toLowerInPlace)\n         $(SHORTXREF uni, toUpper)\n         $(SHORTXREF uni, toUpperInPlace)\n    ))\n)\n\nThere is a rich set of functions for _string handling defined in other modules.\nFunctions related to Unicode and ASCII are found in $(LINK2 std_uni.html, std.uni)\nand $(LINK2 std_ascii.html, std.ascii), respectively. Other functions that have a\nwider generality than just strings can be found in $(LINK2 std_algorithm.html,\nstd.algorithm) and $(LINK2 std_range.html, std.range).\n\nSee_Also:\n    $(LIST\n    $(LINK2 std_algorithm.html, std.algorithm) and\n    $(LINK2 std_range.html, std.range)\n    for generic range algorithms\n    ,\n    $(LINK2 std_ascii.html, std.ascii)\n    for functions that work with ASCII strings\n    ,\n    $(LINK2 std_uni.html, std.uni)\n    for functions that work with unicode strings\n    )\n\nMacros: WIKI = Phobos/StdString\n        SHORTXREF=$(XREF2 $1, $2, $(TT $2))\n        SHORTXREF_PACK=$(XREF_PACK_NAMED  $2, $(TT $3),$1, $3)\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB digitalmars.com, Walter Bright),\n         $(WEB erdani.org, Andrei Alexandrescu),\n         and Jonathan M Davis\n\nSource:    $(PHOBOSSRC std/_string.d)\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/signals.d",
		"name": "std.signals",
		"members": [
			{
				"members": [
					{
						"name": "slot_t",
						"line": 154,
						"comment": " A slot is implemented as a delegate.\n The slot_t is the type of the delegate.\n The delegate must be to an instance of a class or an interface\n to a class instance.\n Delegates to struct instances or nested functions must not be\n used as slots.\n",
						"type": "void delegate(T1)",
						"char": 5,
						"kind": "alias"
					},
					{
						"endchar": 5,
						"name": "emit",
						"line": 159,
						"comment": " Call each of the connected slots, passing the argument(s) i to them.\n",
						"type": "void(T1 i)",
						"parameters": [
							{
								"name": "i",
								"type": "T1"
							}
						],
						"endline": 165,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "connect",
						"line": 170,
						"comment": " Add a slot to the list of slots to be called when emit() is called.\n",
						"type": "void(slot_t slot)",
						"parameters": [
							{
								"name": "slot",
								"type": "slot_t"
							}
						],
						"endline": 202,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					},
					{
						"endchar": 5,
						"name": "disconnect",
						"line": 207,
						"comment": " Remove a slot from the list of slots to be called when emit() is called.\n",
						"type": "void(slot_t slot)",
						"parameters": [
							{
								"name": "slot",
								"type": "slot_t"
							}
						],
						"endline": 223,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"final"
						]
					}
				],
				"name": "Signal",
				"line": 142,
				"comment": " Mixin to create a signal within a class object.\n\n Different signals can be added to a class by naming the mixins.\n\n Example:\n---\nimport std.signals;\nimport std.stdio;\n\nclass Observer\n{   // our slot\n    void watch(string msg, int i)\n    {\n        writefln(\"Observed msg '%s' and value %s\", msg, i);\n    }\n}\n\nclass Foo\n{\n    int value() { return _value; }\n\n    int value(int v)\n    {\n        if (v != _value)\n        {   _value = v;\n            // call all the connected slots with the two parameters\n            emit(\"setting new value\", v);\n        }\n        return v;\n    }\n\n    // Mix in all the code we need to make Foo into a signal\n    mixin Signal!(string, int);\n\n  private :\n    int _value;\n}\n\nvoid main()\n{\n    Foo a = new Foo;\n    Observer o = new Observer;\n\n    a.value = 3;                // should not call o.watch()\n    a.connect(&o.watch);        // o.watch is the slot\n    a.value = 4;                // should call o.watch()\n    a.disconnect(&o.watch);     // o.watch is no longer a slot\n    a.value = 5;                // so should not call o.watch()\n    a.connect(&o.watch);        // connect again\n    a.value = 6;                // should call o.watch()\n    destroy(o);                 // destroying o should automatically disconnect it\n    a.value = 7;                // should not call o.watch()\n}\n---\n which should print:\n <pre>\n Observed msg 'setting new value' and value 4\n Observed msg 'setting new value' and value 6\n </pre>\n\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "tuple"
					}
				],
				"char": 7,
				"kind": "template"
			}
		],
		"comment": " Signals and Slots are an implementation of the Observer Pattern.\n Essentially, when a Signal is emitted, a list of connected Observers\n (called slots) are called.\n\n There have been several D implementations of Signals and Slots.\n This version makes use of several new features in D, which make\n using it simpler and less error prone. In particular, it is no\n longer necessary to instrument the slots.\n\n References:\n      $(LUCKY A Deeper Look at Signals and Slots)$(BR)\n      $(LINK2 http://en.wikipedia.org/wiki/Observer_pattern, Observer pattern)$(BR)\n      $(LINK2 http://en.wikipedia.org/wiki/Signals_and_slots, Wikipedia)$(BR)\n      $(LINK2 http://boost.org/doc/html/$(SIGNALS).html, Boost Signals)$(BR)\n      $(LINK2 http://qt-project.org/doc/qt-5/signalsandslots.html, Qt)$(BR)\n\n      There has been a great deal of discussion in the D newsgroups\n      over this, and several implementations:\n\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html, signal slots library)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Signals_and_Slots_in_D_42387.html, Signals and Slots in D)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Dynamic_binding_--_Qt_s_Signals_and_Slots_vs_Objective-C_42260.html, Dynamic binding -- Qt's Signals and Slots vs Objective-C)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Dissecting_the_SS_42377.html, Dissecting the SS)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/dwt/about_harmonia_454.html, about harmonia)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/announce/1502.html, Another event handling module)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/41825.html, Suggestion: signal/slot mechanism)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/13251.html, Signals and slots?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/10714.html, Signals and slots ready for evaluation)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/1393.html, Signals &amp; Slots for Walter)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/28456.html, Signal/Slot mechanism?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/19470.html, Modern Features?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16592.html, Delegates vs interfaces)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16583.html, The importance of component programming (properties$(COMMA) signals and slots$(COMMA) etc))$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16368.html, signals and slots)$(BR)\n\n Bugs:\n      Slots can only be delegates formed from class objects or\n      interfaces to class objects. If a delegate to something else\n      is passed to connect(), such as a struct member function,\n      a nested function or a COM interface, undefined behavior\n      will result.\n\n      Not safe for multiple threads operating on the same signals\n      or slots.\n Macros:\n      WIKI = Phobos/StdSignals\n      SIGNALS=signals\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_signals.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/variant.d",
		"name": "std.variant",
		"members": [
			{
				"members": [],
				"name": "maxSize",
				"line": 77,
				"comment": "    Gives the $(D sizeof) the largest type given.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "VariantN",
						"line": 130,
						"members": [
							{
								"name": "AllowedTypes",
								"line": 135,
								"comment": "    The list of allowed types. If empty, any type is allowed.\n",
								"type": "This2Variant!(VariantN, AllowedTypesParam)",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"name": "allowed",
										"line": 152,
										"deco": "b",
										"init": "is(T == VariantN) || (AllowedTypes.length == 0 || staticIndexOf!(T, AllowedTypes) >= 0)",
										"char": 19,
										"kind": "variable",
										"storageClass": [
											"enum"
										]
									}
								],
								"name": "allowed",
								"line": 150,
								"comment": " Tells whether a type $(D T) is statically allowed for\n storage inside a $(D VariantN) object by looking\n $(D T) up in $(D AllowedTypes).\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 550,
										"type": "(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 555,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 550,
								"comment": " Constructs a $(D VariantN) value given an argument of a\n generic type. Statically rejects disallowed types.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 558,
										"type": "(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 562,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 558,
								"comment": "Allows assignment from a subset algebraic type\n",
								"parameters": [
									{
										"name": "T",
										"type": "VariantN!(tsize, Types)",
										"kind": "type"
									},
									{
										"name": "tsize",
										"type": "size_t",
										"kind": "value"
									},
									{
										"name": "Types",
										"kind": "tuple"
									}
								],
								"constraint": "!is(T : VariantN) && Types.length > 0 && allSatisfy!(allowed, Types)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opAssign",
										"line": 583,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 641,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAssign",
								"line": 583,
								"comment": " Assigns a $(D VariantN) from a generic\n argument. Statically rejects disallowed types.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "hasValue",
								"line": 671,
								"comment": " Returns true if and only if the $(D VariantN) object\n holds a valid value (has been initialized with, or assigned\n from, a valid value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL678_2079)\n---\nVariant a;\nassert(!a.hasValue);\nVariant b;\na = b;\nassert(!a.hasValue); // still no value\na = 5;\nassert(a.hasValue);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL678_2079)\n",
								"type": "const pure nothrow @property bool()",
								"endline": 675,
								"char": 20,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "peek",
										"line": 696,
										"type": "inout @property inout(T)*()",
										"endline": 707,
										"char": 25,
										"kind": "function"
									}
								],
								"name": "peek",
								"line": 696,
								"comment": " If the $(D VariantN) object holds a value of the\n $(I exact) type $(D T), returns a pointer to that\n value. Otherwise, returns $(D null). In cases\n where $(D T) is statically disallowed, $(D\n peek) will not compile.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL710_2080)\n---\nVariant a = 5;\nauto b = a.peek!(int);\nassert(b !is null);\n*b = 6;\nassert(a == 6);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL710_2080)\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 25,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "type",
								"line": 723,
								"comment": " Returns the $(D typeid) of the currently held value.\n",
								"type": "const nothrow @property @trusted TypeInfo()",
								"endline": 730,
								"char": 24,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "convertsTo",
										"line": 739,
										"type": "const @property bool()",
										"endline": 743,
										"char": 20,
										"kind": "function"
									}
								],
								"name": "convertsTo",
								"line": 739,
								"comment": " Returns $(D true) if and only if the $(D VariantN)\n object holds an object implicitly convertible to type $(D\n U). Implicit convertibility is defined as per\n $(LINK2 std_traits.html#ImplicitConversionTargets,ImplicitConversionTargets).\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 20,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "get",
										"line": 756,
										"type": "inout @property inout(T)()",
										"endline": 769,
										"char": 24,
										"kind": "function"
									}
								],
								"name": "get",
								"line": 756,
								"comment": "    Returns the value stored in the `VariantN` object, either by specifying the\n    needed type or the index in the list of allowed types. The latter overload\n    only applies to bounded variants (e.g. $(LREF Algebraic)).\n\n    Params:\n    T = The requested type. The currently stored value must implicitly convert\n    to the requested type, in fact `DecayStaticToDynamicArray!T`. If an\n    implicit conversion is not possible, throws a `VariantException`.\n    index = The index of the type among `AllowedTypesParam`, zero-based.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 24,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "get",
										"line": 772,
										"type": "inout @property ()",
										"endline": 780,
										"char": 20,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "get",
								"line": 772,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "index",
										"deco": "k",
										"kind": "value"
									}
								],
								"constraint": "index < AllowedTypes.length",
								"char": 20,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "coerce",
										"line": 792,
										"type": "@property T()",
										"endline": 834,
										"char": 17,
										"kind": "function"
									}
								],
								"name": "coerce",
								"line": 792,
								"comment": " Returns the value stored in the $(D VariantN) object,\n explicitly converted (coerced) to the requested type $(D\n T). If $(D T) is a string type, the value is formatted as\n a string. If the $(D VariantN) object is a string, a\n parse of the string to type $(D T) is attempted. If a\n conversion is not possible, throws a $(D\n VariantException).\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 17,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "toString",
								"line": 840,
								"comment": " Formats the stored value as a string.\n",
								"type": "string()",
								"endline": 845,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opEquals",
										"line": 852,
										"type": "const bool(auto ref T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T",
												"storageClass": [
													"auto",
													"ref"
												]
											}
										],
										"endline": 860,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 852,
								"comment": " Comparison for equality used by the \"==\" and \"!=\"  operators.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCmp",
										"line": 874,
										"type": "int(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 888,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "opCmp",
								"line": 874,
								"comment": " Ordering comparison used by the \"<\", \"<=\", \">\", and \">=\"\n operators. In case comparison is not sensible between the held\n value and $(D rhs), an exception is thrown.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 9,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "toHash",
								"line": 894,
								"comment": " Computes the hash of the held value.\n",
								"type": "const nothrow @safe size_t()",
								"endline": 897,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opAdd",
										"line": 983,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 983,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAdd",
								"line": 983,
								"comment": " Arithmetic between $(D VariantN) objects and numeric\n values. All arithmetic operations return a $(D VariantN)\n object typed depending on the types of both values\n involved. The conversion rules mimic D's built-in rules for\n arithmetic conversions.\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opSub",
										"line": 985,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 985,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opSub",
								"line": 985,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opMul",
										"line": 996,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 996,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opMul",
								"line": 996,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opDiv",
										"line": 998,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 998,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opDiv",
								"line": 998,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opMod",
										"line": 1005,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1005,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opMod",
								"line": 1005,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 62,
										"name": "opAnd",
										"line": 1012,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1012,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAnd",
								"line": 1012,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 61,
										"name": "opOr",
										"line": 1014,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1014,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opOr",
								"line": 1014,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 62,
										"name": "opXor",
										"line": 1016,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1016,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opXor",
								"line": 1016,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 63,
										"name": "opShl",
										"line": 1018,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1018,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShl",
								"line": 1018,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 63,
										"name": "opShr",
										"line": 1025,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1025,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShr",
								"line": 1025,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opUShr",
										"line": 1032,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1032,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opUShr",
								"line": 1032,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCat",
										"line": 1039,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1044,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opCat",
								"line": 1039,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opAddAssign",
										"line": 1054,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1054,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAddAssign",
								"line": 1054,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opSubAssign",
										"line": 1056,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1056,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opSubAssign",
								"line": 1056,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opMulAssign",
										"line": 1058,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1058,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opMulAssign",
								"line": 1058,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opDivAssign",
										"line": 1060,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1060,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opDivAssign",
								"line": 1060,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opModAssign",
										"line": 1062,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1062,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opModAssign",
								"line": 1062,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opAndAssign",
										"line": 1064,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1064,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opAndAssign",
								"line": 1064,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opOrAssign",
										"line": 1066,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1066,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opOrAssign",
								"line": 1066,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 65,
										"name": "opXorAssign",
										"line": 1068,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1068,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opXorAssign",
								"line": 1068,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 66,
										"name": "opShlAssign",
										"line": 1070,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1070,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShlAssign",
								"line": 1070,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 66,
										"name": "opShrAssign",
										"line": 1072,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1072,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opShrAssign",
								"line": 1072,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 67,
										"name": "opUShrAssign",
										"line": 1074,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1074,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opUShrAssign",
								"line": 1074,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opCatAssign",
										"line": 1076,
										"type": "VariantN(T rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "T"
											}
										],
										"endline": 1081,
										"char": 14,
										"kind": "function"
									}
								],
								"name": "opCatAssign",
								"line": 1076,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"char": 14,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndex",
										"line": 1088,
										"type": "Variant(K i)",
										"parameters": [
											{
												"name": "i",
												"type": "K"
											}
										],
										"endline": 1093,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opIndex",
								"line": 1088,
								"comment": " Array and associative array operations. If a $(D\n VariantN) contains an (associative) array, it can be indexed\n into. Otherwise, an exception is thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1096_2081)\n---\nauto a = Variant(new int[10]);\na[5] = 42;\nassert(a[5] == 42);\nint[int] hash = [ 42:24 ];\na = hash;\nassert(a[42] == 24);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1096_2081)\nExample:\nCaveat:\n    Due to limitations in current language, read-modify-write\n    operations $(D op=) will not work properly:$(DDOX_UNITTEST_HEADER __unittestL1110_2082)\n---\nVariant a = new int[10];\na[5] = 42;\na[5] += 8;\n//assert(a[5] == 50); // will fail, a[5] is still 42\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1110_2082)\n",
								"parameters": [
									{
										"name": "K",
										"kind": "type"
									}
								],
								"char": 13,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndexAssign",
										"line": 1128,
										"type": "Variant(T value, N i)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											},
											{
												"name": "i",
												"type": "N"
											}
										],
										"endline": 1133,
										"char": 13,
										"kind": "function"
									}
								],
								"name": "opIndexAssign",
								"line": 1128,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									},
									{
										"name": "N",
										"kind": "type"
									}
								],
								"char": 13,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 1139,
								"comment": " If the $(D VariantN) contains an (associative) array,\n returns the length of that array. Otherwise, throws an\n exception.\n",
								"type": "@property size_t()",
								"endline": 1142,
								"char": 22,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opApply",
										"line": 1148,
										"type": "int(scope Delegate dg)",
										"parameters": [
											{
												"name": "dg",
												"type": "Delegate",
												"storageClass": [
													"scope"
												]
											}
										],
										"endline": 1178,
										"char": 9,
										"kind": "function"
									}
								],
								"name": "opApply",
								"line": 1148,
								"comment": "       If the $(D VariantN) contains an array, applies $(D dg) to each\n       element of the array in turn. Otherwise, throws an exception.\n",
								"parameters": [
									{
										"name": "Delegate",
										"kind": "type"
									}
								],
								"constraint": "is(Delegate == delegate)",
								"char": 9,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "VariantN",
				"line": 130,
				"comment": " $(D VariantN) is a back-end type seldom used directly by user\n code. Two commonly-used types using $(D VariantN) as\n back-end are:\n\n $(OL $(LI $(B Algebraic): A closed discriminated union with a\n limited type universe (e.g., $(D Algebraic!(int, double,\n string)) only accepts these three types and rejects anything\n else).) $(LI $(B Variant): An open discriminated union allowing an\n unbounded set of types. If any of the types in the $(D Variant)\n are larger than the largest built-in type, they will automatically\n be boxed. This means that even large types will only be the size\n of a pointer within the $(D Variant), but this also implies some\n overhead. $(D Variant) can accommodate all primitive types and\n all user-defined types.))\n\n Both $(D Algebraic) and $(D Variant) share $(D\n VariantN)'s interface. (See their respective documentations below.)\n\n $(D VariantN) is a discriminated union type parameterized\n with the largest size of the types stored ($(D maxDataSize))\n and with the list of allowed types ($(D AllowedTypes)). If\n the list is empty, then any type up of size up to $(D\n maxDataSize) (rounded up for alignment) can be stored in a\n $(D VariantN) object without being boxed (types larger\n than this will be boxed).\n\n",
				"parameters": [
					{
						"name": "maxDataSize",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "AllowedTypesParam",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Algebraic",
						"line": 1348,
						"type": "VariantN!(maxSize!T, T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Algebraic",
				"line": 1346,
				"comment": "Algebraic data type restricted to a closed set of possible\ntypes. It's an alias for a $(LREF VariantN) with an\nappropriately-constructed maximum size. `Algebraic` is\nuseful when it is desirable to restrict what a discriminated type\ncould hold to the end of defining simpler and more efficient\nmanipulation.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1352_2097)\n---\nauto v = Algebraic!(int, double, string)(5);\nassert(v.peek!(int));\nv = 3.14;\nassert(v.peek!(double));\n// auto x = v.peek!(long); // won't compile, type long not allowed\n// v = '1'; // won't compile, type char not allowed\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1352_2097)\nExample:\n$(H4 Self-Referential Types)\n\nA useful and popular use of algebraic data structures is for defining $(LUCKY\nself-referential data structures), i.e. structures that embed references to\nvalues of their own type within.\n\nThis is achieved with `Algebraic` by using `This` as a placeholder whenever a\nreference to the type being defined is needed. The `Algebraic` instantiation\nwill perform $(LUCKY alpha renaming) on its constituent types, replacing `This`\nwith the self-referenced type. The structure of the type involving `This` may\nbe arbitrarily complex.$(DDOX_UNITTEST_HEADER __unittestL1375_2098)\n---\n// A tree is either a leaf or a branch of two other trees\nalias Tree(Leaf) = Algebraic!(Leaf, Tuple!(This*, This*));\nTree!int tree = tuple(new Tree!int(42), new Tree!int(43));\nTree!int* right = tree.get!1[1];\nassert(*right == 43);\n\n// An object is a double, a string, or a hash of objects\nalias Obj = Algebraic!(double, string, This[string]);\nObj obj = \"hello\";\nassert(obj.get!1 == \"hello\");\nobj = 42.0;\nassert(obj.get!0 == 42);\nobj = [\"customer\": Obj(\"John\"), \"paid\": Obj(23.95)];\nassert(obj.get!2[\"customer\"] == \"John\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1375_2098)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Variant",
				"line": 1401,
				"comment": "`Variant` is an alias for `VariantN` instantiated with the largest of `creal`,\n`char[]`, and `void delegate()`. This ensures that `Variant` is large enough\nto hold all of D's predefined types unboxed, including all numeric types,\npointers, delegates, and class references.  You may want to use\n$(D VariantN) directly with a different maximum size either for\nstoring larger types unboxed, or for saving memory.\n",
				"deco": "S3std7variant18__T8VariantNVmi32Z8VariantN",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "variantArray",
						"line": 1410,
						"type": "Variant[](T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 1418,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "variantArray",
				"line": 1410,
				"comment": " Returns an array of variants constructed from $(D args).\n\n This is by design. During construction the $(D Variant) needs\n static type information about the type being held, so as to store a\n pointer to function for fast retrieval.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1421_2099)\n---\nauto a = variantArray(1, 3.14, \"Hi!\");\nassert(a[1] == 3.14);\nauto b = Variant(a); // variant array as variant\nassert(b[1] == 3.14);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1421_2099)\nExample:\nCode that needs functionality similar to the $(D boxArray)\nfunction in the $(D std.boxer) module can achieve it like this:$(DDOX_UNITTEST_HEADER __unittestL1432_2100)\n---\n/* old\nBox[] fun(...)\n{\n    // ...\n    return boxArray(_arguments, _argptr);\n}\n*/\n// new\nVariant[] fun(T...)(T args)\n{\n    // ...\n    return variantArray(args);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1432_2100)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "source",
						"line": 1466,
						"comment": "The source type in the conversion or comparison\n",
						"deco": "C8TypeInfo",
						"originalType": "TypeInfo",
						"char": 14,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "target",
						"line": 1468,
						"comment": "The target type in the conversion or comparison\n",
						"deco": "C8TypeInfo",
						"originalType": "TypeInfo",
						"char": 14,
						"kind": "variable"
					}
				],
				"name": "VariantException",
				"line": 1463,
				"comment": "\n/**\n Thrown in three cases:\n\n $(OL $(LI An uninitialized Variant is used in any way except\n assignment and $(D hasValue);) $(LI A $(D get) or\n $(D coerce) is attempted with an incompatible target type;)\n $(LI A comparison between $(D Variant) objects of\n incompatible types is attempted.))\n\n",
				"base": "object.Exception",
				"char": 8,
				"kind": "class"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "visit",
								"line": 2007,
								"type": "(VariantType variant)",
								"parameters": [
									{
										"name": "variant",
										"type": "VariantType"
									}
								],
								"endline": 2011,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "visit",
						"line": 2007,
						"parameters": [
							{
								"name": "VariantType",
								"kind": "type"
							}
						],
						"constraint": "isAlgebraic!VariantType",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "visit",
				"line": 2004,
				"comment": " Applies a delegate or function to the given Algebraic depending on the held type,\n ensuring that all types are handled by the visiting functions.\n\n The delegate or function having the currently held value as parameter is called\n with $(D variant)'s current value. Visiting handlers are passed\n in the template parameter list.\n It is statically ensured that all types of\n $(D variant) are handled across all handlers.\n $(D visit) allows delegates and static functions to be passed\n as parameters.\n\n If a function without parameters is specified, this function is called\n when variant doesn't hold a value. Exactly one parameter-less function\n is allowed.\n\n Duplicate overloads matching the same type in one of the visitors are disallowed.\n\n Returns: The return type of visit is deduced from the visiting functions and must be\n the same across all overloads.\n Throws: If no parameter-less, error function is specified:\n $(D VariantException) if $(D variant) doesn't hold a value.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2015_2122)\n---\nAlgebraic!(int, string) variant;\n\nvariant = 10;\nassert(variant.visit!((string s) => cast(int)s.length,\n                      (int i)    => i)()\n                      == 10);\nvariant = \"string\";\nassert(variant.visit!((int i) => i,\n                      (string s) => cast(int)s.length)()\n                      == 6);\n\n// Error function usage\nAlgebraic!(int, string) emptyVar;\nauto rslt = emptyVar.visit!((string s) => cast(int)s.length,\n                      (int i)    => i,\n                      () => -1)();\nassert(rslt == -1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2015_2122)\n",
				"parameters": [
					{
						"name": "Handler",
						"kind": "tuple"
					}
				],
				"constraint": "Handler.length > 0",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "tryVisit",
								"line": 2113,
								"type": "(VariantType variant)",
								"parameters": [
									{
										"name": "variant",
										"type": "VariantType"
									}
								],
								"endline": 2117,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "tryVisit",
						"line": 2113,
						"parameters": [
							{
								"name": "VariantType",
								"kind": "type"
							}
						],
						"constraint": "isAlgebraic!VariantType",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "tryVisit",
				"line": 2110,
				"comment": " Behaves as $(D visit) but doesn't enforce that all types are handled\n by the visiting functions.\n\n If a parameter-less function is specified it is called when\n either $(D variant) doesn't hold a value or holds a type\n which isn't handled by the visiting functions.\n\n Returns: The return type of tryVisit is deduced from the visiting functions and must be\n the same across all overloads.\n Throws: If no parameter-less, error function is specified: $(D VariantException) if\n         $(D variant) doesn't hold a value or\n         if $(D variant) holds a value which isn't handled by the visiting\n         functions.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2121_2125)\n---\nAlgebraic!(int, string) variant;\n\nvariant = 10;\nauto which = -1;\nvariant.tryVisit!((int i) { which = 0; })();\nassert(which == 0);\n\n// Error function usage\nvariant = \"test\";\nvariant.tryVisit!((int i) { which = 0; },\n                  ()      { which = -100; })();\nassert(which == -100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2121_2125)\n",
				"parameters": [
					{
						"name": "Handler",
						"kind": "tuple"
					}
				],
				"constraint": "Handler.length > 0",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a\n$(WEB erdani.org/publications/cuj-04-2002.html,discriminated union)\ntype (a.k.a.\n$(WEB en.wikipedia.org/wiki/Tagged_union,tagged union),\n$(WEB en.wikipedia.org/wiki/Algebraic_data_type,algebraic type)).\nSuch types are useful\nfor type-uniform binary interfaces, interfacing with scripting\nlanguages, and comfortable exploratory programming.\n\nMacros:\n WIKI = Phobos/StdVariant\n\nSynopsis:\n----\nVariant a; // Must assign before use, otherwise exception ensues\n// Initialize with an integer; make the type int\nVariant b = 42;\nassert(b.type == typeid(int));\n// Peek at the value\nassert(b.peek!(int) !is null && *b.peek!(int) == 42);\n// Automatically convert per language rules\nauto x = b.get!(real);\n// Assign any other type, including other variants\na = b;\na = 3.14;\nassert(a.type == typeid(double));\n// Implicit conversions work just as with built-in types\nassert(a < b);\n// Check for convertibility\nassert(!a.convertsTo!(int)); // double not convertible to int\n// Strings and all other arrays are supported\na = \"now I'm a string\";\nassert(a == \"now I'm a string\");\na = new int[42]; // can also assign arrays\nassert(a.length == 42);\na[5] = 7;\nassert(a[5] == 7);\n// Can also assign class values\nclass Foo {}\nauto foo = new Foo;\na = foo;\nassert(*a.peek!(Foo) == foo); // and full type information is preserved\n----\n\nA $(LREF Variant) object can hold a value of any type, with very few\nrestrictions (such as `shared` types and noncopyable types). Setting the value\nis as immediate as assigning to the `Variant` object. To read back the value of\nthe appropriate type `T`, use the $(LREF get!T) call. To query whether a\n`Variant` currently holds a value of type `T`, use $(LREF peek!T). To fetch the\nexact type currently held, call $(LREF type), which returns the `TypeInfo` of\nthe current value.\n\nIn addition to $(LREF Variant), this module also defines the $(LREF Algebraic)\ntype constructor. Unlike `Variant`, `Algebraic` only allows a finite set of\ntypes, which are specified in the instantiation (e.g. $(D Algebraic!(int,\nstring)) may only hold an `int` or a `string`).\n\nCredits: Reviewed by Brad Roberts. Daniel Keep provided a detailed code review\nprompting the following improvements: (1) better support for arrays; (2) support\nfor associative arrays; (3) friendlier behavior towards the garbage collector.\nCopyright: Copyright Andrei Alexandrescu 2007 - 2015.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nSource:    $(PHOBOSSRC std/_variant.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/md.d",
		"name": "std.digest.md",
		"members": [
			{
				"name": "MD5",
				"line": 98,
				"comment": " Template API MD5 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL403_2140)\n---\n//Simple example, hashing a string using md5Of helper function\nubyte[16] hash = md5Of(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"900150983CD24FB0D6963F7D28E17F72\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL403_2140)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL412_2141)\n---\n//Using the basic API\nMD5 hash;\nhash.start();\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[16] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL412_2141)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL424_2142)\n---\n//Let's use the template features:\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n    hash.put(cast(ubyte)0);\n}\nMD5 md5;\nmd5.start();\ndoSomething(md5);\nassert(toHexString(md5.finish()) == \"93B885ADFE0DA089CDF634904FD59F71\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL424_2142)\n",
				"members": [
					{
						"endchar": 9,
						"name": "put",
						"line": 301,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n\n Examples:\n ----\n MD5 dig;\n dig.put(cast(ubyte)0); //single ubyte\n dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n ubyte[10] buf;\n dig.put(buf); //buffer\n ----\n",
						"deco": "FNaNbNiNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 335,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "start",
						"line": 353,
						"comment": " Used to (re)initialize the MD5 digest.\n\n Note:\n For this MD5 Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\n\n Examples:\n --------\n MD5 digest;\n //digest.start(); //Not necessary\n digest.put(0);\n --------\n",
						"deco": "FNaNbNiNfZv",
						"endline": 356,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "finish",
						"line": 362,
						"comment": " Returns the finished MD5 hash. This also calls $(LREF start) to\n reset the internal state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL392_2139)\n---\n//Simple example\nMD5 hash;\nhash.start();\nhash.put(cast(ubyte)0);\nubyte[16] result = hash.finish();\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL392_2139)\n",
						"deco": "FNaNbNiNeZG16h",
						"endline": 390,
						"char": 19,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "md5Of",
						"line": 497,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 500,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "md5Of",
				"line": 497,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,digest) using the\n MD5 implementation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL503_2145)\n---\nubyte[16] hash = md5Of(\"abc\");\nassert(hash == digest!MD5(\"abc\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL503_2145)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "MD5Digest",
				"line": 516,
				"comment": " OOP API MD5 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!MD5), see\n there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL519_2146)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto md5 = new MD5Digest();\nubyte[] hash = md5.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"900150983CD24FB0D6963F7D28E17F72\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL519_2146)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL529_2147)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n dig.put(cast(ubyte)0);\n}\nauto md5 = new MD5Digest();\ntest(md5);\n\n//Let's use a custom buffer:\nubyte[16] buf;\nubyte[] result = md5.finish(buf[]);\nassert(toHexString(result) == \"93B885ADFE0DA089CDF634904FD59F71\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL529_2147)\n",
				"deco": "C3std6digest6digest39__T13WrapperDigestTS3std6digest2md3MD5Z13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " Computes MD5 hashes of arbitrary data. MD5 hashes are 16 byte quantities that are like a\n checksum or CRC, but are more robust.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF MD5)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF MD5Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF md5Of))\n)\n)\n)\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n CTFE:\n Digests do not work in CTFE\n\n Authors:\n Piotr Szturmaj, Kai Nacke, Johannes Pfau $(BR)\n The routines and algorithms are derived from the $(I RSA Data Security, Inc. MD5 Message-Digest Algorithm).\n\n References:\n      $(LINK2 http://en.wikipedia.org/wiki/Md5, Wikipedia on MD5)\n\n Source: $(PHOBOSSRC std/digest/_md.d)\n\n Macros:\n WIKI = Phobos/StdMd5\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL53_2137)\n---\n//Template API\nimport std.digest.md;\n\n//Feeding data\nubyte[1024] data;\nMD5 md5;\nmd5.start();\nmd5.put(data[]);\nmd5.start(); //Start again\nmd5.put(data[]);\nauto hash = md5.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL53_2137)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL69_2138)\n---\n//OOP API\nimport std.digest.md;\n\nauto md5 = new MD5Digest();\nubyte[] hash = md5.digest(\"abc\");\nassert(toHexString(hash) == \"900150983CD24FB0D6963F7D28E17F72\");\n\n//Feeding data\nubyte[1024] data;\nmd5.put(data[]);\nmd5.reset(); //Start again\nmd5.put(data[]);\nhash = md5.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL69_2138)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/digest.d",
		"name": "std.digest.digest",
		"members": [
			{
				"name": "ExampleDigest",
				"line": 201,
				"comment": " This documents the general structure of a Digest in the template API.\n All digest implementations should implement the following members and therefore pass\n the $(LREF isDigest) test.\n\n Note:\n $(UL\n $(LI A digest must be a struct (value type) to pass the $(LREF isDigest) test.)\n $(LI A digest passing the $(LREF isDigest) test is always an $(D OutputRange))\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL255_2153)\n---\n//Using the OutputRange feature\nimport std.algorithm : copy;\nimport std.range : repeat;\nimport std.digest.md;\n\nauto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);\nauto ctx = makeDigest!MD5();\ncopy(oneMillionRange, &ctx); //Note: You must pass a pointer to copy!\nassert(ctx.finish().toHexString() == \"7707D6AE4E027C70EEA2A935C2296F21\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL255_2153)\n",
				"members": [
					{
						"endchar": 13,
						"name": "put",
						"line": 219,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n The following usages of $(D put) must work for any type which\n passes $(LREF isDigest):\n Examples:\n ----\n ExampleDigest dig;\n dig.put(cast(ubyte)0); //single ubyte\n dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n ubyte[10] buf;\n dig.put(buf); //buffer\n ----\n",
						"deco": "FNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 222,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 13,
						"name": "start",
						"line": 229,
						"comment": " This function is used to (re)initialize the digest.\n It must be called before using the digest and it also works as a 'reset' function\n if the digest has already processed data.\n",
						"deco": "FNeZv",
						"endline": 232,
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 13,
						"name": "finish",
						"line": 247,
						"comment": " The finish function returns the final hash sum and resets the Digest.\n\n Note:\n The actual type returned by finish depends on the digest implementation.\n $(D ubyte[16]) is just used as an example. It is guaranteed that the type is a\n static array of ubytes.\n\n $(UL\n $(LI Use $(LREF DigestType) to obtain the actual return type.)\n $(LI Use $(LREF digestLength) to obtain the length of the ubyte array.)\n )\n",
						"deco": "FNeZG16h",
						"endline": 250,
						"char": 32,
						"kind": "function"
					}
				],
				"char": 5,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "isDigest",
						"line": 284,
						"deco": "b",
						"init": "isOutputRange!(T, const(ubyte)[]) && isOutputRange!(T, ubyte) && is(T == struct) && is(typeof(()\n{\nT dig = void;\ndig.put(cast(ubyte)0, cast(ubyte)0);\ndig.start();\nauto value = dig.finish();\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isDigest",
				"line": 281,
				"comment": " Use this to check if a type is a digest. See $(LREF ExampleDigest) to see what\n a type must provide to pass this check.\n\n Note:\n This is very useful as a template constraint (see examples)\n\n BUGS:\n $(UL\n $(LI Does not yet verify that put takes scope parameters.)\n $(LI Should check that finish() returns a ubyte[num] array)\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL296_2154)\n---\nimport std.digest.crc;\nstatic assert(isDigest!CRC32);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL296_2154)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL302_2155)\n---\nimport std.digest.crc;\nvoid myFunction(T)() if(isDigest!T)\n{\n    T dig;\n    dig.start();\n    auto result = dig.finish();\n}\nmyFunction!CRC32();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL302_2155)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "DigestType",
				"line": 317,
				"comment": " Use this template to get the type which is returned by a digest's $(LREF finish) method.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL333_2156)\n---\nimport std.digest.crc;\nassert(is(DigestType!(CRC32) == ubyte[4]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL333_2156)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL339_2157)\n---\nimport std.digest.crc;\nCRC32 dig;\ndig.start();\nDigestType!CRC32 result = dig.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL339_2157)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasPeek",
						"line": 360,
						"deco": "b",
						"init": "isDigest!T && is(typeof(()\n{\nT dig = void;\nDigestType!T val = dig.peek();\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasPeek",
				"line": 358,
				"comment": " Used to check if a digest supports the $(D peek) method.\n Peek has exactly the same function signatures as finish, but it doesn't reset\n the digest's internal state.\n\n Note:\n $(UL\n $(LI This is very useful as a template constraint (see examples))\n $(LI This also checks if T passes $(LREF isDigest))\n )\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL369_2158)\n---\nimport std.digest.crc, std.digest.md;\nassert(!hasPeek!(MD5));\nassert(hasPeek!CRC32);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL369_2158)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL376_2159)\n---\nimport std.digest.crc;\nvoid myFunction(T)() if(hasPeek!T)\n{\n    T dig;\n    dig.start();\n    auto result = dig.peek();\n}\nmyFunction!CRC32();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL376_2159)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "digest",
						"line": 407,
						"type": "DigestType!Hash(auto ref Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 415,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "digest",
				"line": 407,
				"comment": " This is a convenience function to calculate a hash using the template API.\n Every digest passing the $(LREF isDigest) test can be used with this function.\n\n Params:\n  range= an $(D InputRange) with $(D ElementType) $(D ubyte), $(D ubyte[]) or $(D ubyte[num])\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL418_2160)\n---\nimport std.digest.md;\nimport std.range : repeat;\nauto testRange = repeat!ubyte(cast(ubyte)'a', 100);\nauto md5 = digest!MD5(testRange);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL418_2160)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "!isArray!Range && isDigestibleRange!Range",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "digest",
						"line": 432,
						"type": "DigestType!Hash(scope const T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T",
								"storageClass": [
									"scope",
									"const"
								]
							}
						],
						"endline": 439,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "digest",
				"line": 432,
				"comment": " This overload of the digest function handles arrays.\n\n Params:\n  data= one or more arrays of any type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL442_2161)\n---\nimport std.digest.md, std.digest.sha, std.digest.crc;\nauto md5   = digest!MD5(  \"The quick brown fox jumps over the lazy dog\");\nauto sha1  = digest!SHA1( \"The quick brown fox jumps over the lazy dog\");\nauto crc32 = digest!CRC32(\"The quick brown fox jumps over the lazy dog\");\nassert(toHexString(crc32) == \"39A34F41\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL442_2161)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL452_2162)\n---\nimport std.digest.crc;\nauto crc32 = digest!CRC32(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\nassert(toHexString(crc32) == \"39A34F41\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL452_2162)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isArray, typeof(data))",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "hexDigest",
						"line": 468,
						"type": "char[digestLength!Hash * 2](ref Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 472,
						"char": 29,
						"kind": "function"
					}
				],
				"name": "hexDigest",
				"line": 468,
				"comment": " This is a convenience function similar to $(LREF digest), but it returns the string\n representation of the hash. Every digest passing the $(LREF isDigest) test can be used with this\n function.\n\n Params:\n  order= the order in which the bytes are processed (see $(LREF toHexString))\n  range= an $(D InputRange) with $(D ElementType) $(D ubyte), $(D ubyte[]) or $(D ubyte[num])\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL475_2163)\n---\nimport std.digest.md;\nimport std.range : repeat;\nauto testRange = repeat!ubyte(cast(ubyte)'a', 100);\nassert(hexDigest!MD5(testRange) == \"36A92CC94A9E0FA21F625F8BFB007ADF\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL475_2163)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "!isArray!Range && isDigestibleRange!Range",
				"char": 29,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "hexDigest",
						"line": 490,
						"type": "char[digestLength!Hash * 2](scope const T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T",
								"storageClass": [
									"scope",
									"const"
								]
							}
						],
						"endline": 494,
						"char": 29,
						"kind": "function"
					}
				],
				"name": "hexDigest",
				"line": 490,
				"comment": " This overload of the hexDigest function handles arrays.\n\n Params:\n  order= the order in which the bytes are processed (see $(LREF toHexString))\n  data= one or more arrays of any type\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL497_2164)\n---\nimport std.digest.crc;\nassert(hexDigest!(CRC32, Order.decreasing)(\"The quick brown fox jumps over the lazy dog\") == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL497_2164)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL503_2165)\n---\nimport std.digest.crc;\nassert(hexDigest!(CRC32, Order.decreasing)(\"The quick \", \"brown \", \"fox jumps over the lazy dog\") == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL503_2165)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isArray, typeof(data))",
				"char": 29,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeDigest",
						"line": 513,
						"type": "Hash()",
						"endline": 518,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "makeDigest",
				"line": 513,
				"comment": " This is a convenience function which returns an initialized digest, so it's not necessary to call\n start manually.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL521_2166)\n---\nimport std.digest.md;\nauto md5 = makeDigest!MD5();\nmd5.put(0);\nassert(toHexString(md5.finish()) == \"93B885ADFE0DA089CDF634904FD59F71\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL521_2166)\n",
				"parameters": [
					{
						"name": "Hash",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "Digest",
				"line": 540,
				"comment": " This describes the OOP API. To understand when to use the template API and when to use the OOP API,\n see the module documentation at the top of this page.\n\n The Digest interface is the base interface which is implemented by all digests.\n\n Note:\n A Digest implementation is always an $(D OutputRange)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL601_2167)\n---\n//Using the OutputRange feature\nimport std.algorithm : copy;\nimport std.range : repeat;\nimport std.digest.md;\n\nauto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);\nauto ctx = new MD5Digest();\ncopy(oneMillionRange, ctx);\nassert(ctx.finish().toHexString() == \"7707D6AE4E027C70EEA2A935C2296F21\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL601_2167)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL615_2168)\n---\nimport std.digest.md, std.digest.sha, std.digest.crc;\nubyte[] md5   = (new MD5Digest()).digest(\"The quick brown fox jumps over the lazy dog\");\nubyte[] sha1  = (new SHA1Digest()).digest(\"The quick brown fox jumps over the lazy dog\");\nubyte[] crc32 = (new CRC32Digest()).digest(\"The quick brown fox jumps over the lazy dog\");\nassert(crcHexString(crc32) == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL615_2168)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL625_2169)\n---\nimport std.digest.crc;\nubyte[] crc32 = (new CRC32Digest()).digest(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\nassert(crcHexString(crc32) == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL625_2169)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL640_2171)\n---\nvoid test(Digest dig)\n{\n    dig.put(cast(ubyte)0); //single ubyte\n    dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n    ubyte[10] buf;\n    dig.put(buf); //buffer\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL640_2171)\n",
				"members": [
					{
						"name": "put",
						"line": 559,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n\n Examples:\n ----\n void test(Digest dig)\n {\n     dig.put(cast(ubyte)0); //single ubyte\n     dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n     ubyte[10] buf;\n     dig.put(buf); //buffer\n }\n ----\n",
						"deco": "FNbNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"char": 31,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "reset",
						"line": 567,
						"comment": " Resets the internal state of the digest.\n Note:\n $(LREF finish) calls this internally, so it's not necessary to call\n $(D reset) manually after a call to $(LREF finish).\n",
						"deco": "FNbNeZv",
						"char": 31,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "length",
						"line": 573,
						"comment": " This is the length in bytes of the hash value which is returned by $(LREF finish).\n It's also the required size of a buffer passed to $(LREF finish).\n",
						"deco": "xFNbNdNeZm",
						"originalType": "const nothrow @property @trusted size_t()",
						"char": 43,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "finish",
						"line": 579,
						"comment": " The finish function returns the hash value. It takes an optional buffer to copy the data\n into. If a buffer is passed, it must be at least $(LREF length) bytes big.\n",
						"deco": "FNbNeZAh",
						"char": 34,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "finish",
						"line": 581,
						"comment": "ditto\n",
						"deco": "FNbMAhZAh",
						"parameters": [
							{
								"name": "buf",
								"storageClass": [
									"scope"
								],
								"deco": "Ah"
							}
						],
						"char": 25,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"endchar": 9,
						"name": "digest",
						"line": 591,
						"comment": " This is a convenience function to calculate the hash of a value using the OOP API.\n",
						"deco": "FNbNeMAxAvXAh",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "AxAv"
							}
						],
						"endline": 597,
						"char": 40,
						"kind": "function",
						"storageClass": [
							"final",
							"abstract"
						]
					}
				],
				"char": 1,
				"kind": "interface"
			},
			{
				"members": [
					{
						"name": "increasing",
						"line": 658,
						"value": "false",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "decreasing",
						"line": 659,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Order",
				"line": 656,
				"comment": " See $(LREF toHexString)\n",
				"baseDeco": "b",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 675,
						"type": "char[num * 2](in ubyte[num] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[num]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 710,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "toHexString",
				"line": 675,
				"comment": " Used to convert a hash value (a static or dynamic array of ubytes) to a string.\n Can be used with the OOP and with the template API.\n\n The additional order parameter can be used to specify the order of the input data.\n By default the data is processed in increasing order, starting at index 0. To process it in the\n opposite order, pass Order.decreasing as a parameter.\n\n The additional letterCase parameter can be used to specify the case of the output data.\n By default the output is in upper case. To change it to the lower case\n pass LetterCase.lower as a parameter.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL764_2172)\n---\nimport std.digest.crc;\n//Test with template API:\nauto crc32 = digest!CRC32(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\n//Lower case variant:\nassert(toHexString!(LetterCase.lower)(crc32) == \"39a34f41\");\n//Usually CRCs are printed in this order, though:\nassert(toHexString!(Order.decreasing)(crc32) == \"414FA339\");\nassert(toHexString!(LetterCase.lower, Order.decreasing)(crc32) == \"414fa339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL764_2172)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL777_2173)\n---\nimport std.digest.crc;\n// With OOP API\nauto crc32 = (new CRC32Digest()).digest(\"The quick \", \"brown \", \"fox jumps over the lazy dog\");\n//Usually CRCs are printed in this order, though:\nassert(toHexString!(Order.decreasing)(crc32) == \"414FA339\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL777_2173)\n",
				"parameters": [
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "num",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "letterCase",
						"defaultValue": "LetterCase.upper",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 713,
						"type": "(in ubyte[num] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[num]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 716,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toHexString",
				"line": 713,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "letterCase",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "num",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 719,
						"type": "string(in ubyte[] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 753,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "toHexString",
				"line": 719,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					},
					{
						"name": "letterCase",
						"defaultValue": "LetterCase.upper",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "toHexString",
						"line": 756,
						"type": "(in ubyte[] digest)",
						"parameters": [
							{
								"name": "digest",
								"type": "ubyte[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 759,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "toHexString",
				"line": 756,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "letterCase",
						"deco": "E3std5ascii10LetterCase",
						"kind": "value"
					},
					{
						"name": "order",
						"defaultValue": "Order.increasing",
						"deco": "E3std6digest6digest5Order",
						"kind": "value"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "digestLength",
						"line": 818,
						"type": "size_t",
						"init": "(ReturnType!(T.finish)).length",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "digestLength",
				"line": 816,
				"comment": " This helper is used internally in the WrapperDigest template, but it might be\n useful for other purposes as well. It returns the length (in bytes) of the hash value\n produced by T.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isDigest!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "WrapperDigest",
						"line": 826,
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 835,
								"comment": " Initializes the digest.\n",
								"type": "()",
								"endline": 838,
								"char": 9,
								"kind": "constructor"
							},
							{
								"endchar": 9,
								"name": "put",
								"line": 845,
								"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n",
								"type": "nothrow @trusted void(scope const(ubyte)[] data...)",
								"parameters": [
									{
										"name": "data",
										"type": "const(ubyte)[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"endline": 848,
								"char": 31,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "reset",
								"line": 856,
								"comment": " Resets the internal state of the digest.\n Note:\n $(LREF finish) calls this internally, so it's not necessary to call\n $(D reset) manually after a call to $(LREF finish).\n",
								"type": "nothrow @trusted void()",
								"endline": 859,
								"char": 31,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "length",
								"line": 865,
								"comment": " This is the length in bytes of the hash value which is returned by $(LREF finish).\n It's also the required size of a buffer passed to $(LREF finish).\n",
								"type": "const pure nothrow @property @trusted size_t()",
								"endline": 868,
								"char": 43,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "finish",
								"line": 887,
								"comment": " The finish function returns the hash value. It takes an optional buffer to copy the data\n into. If a buffer is passed, it must have a length at least $(LREF length) bytes.\n\n Examples:\n --------\n\n import std.digest.md;\n ubyte[16] buf;\n auto hash = new WrapperDigest!MD5();\n hash.put(cast(ubyte)0);\n auto result = hash.finish(buf[]);\n //The result is now in result (and in buf). If you pass a buffer which is bigger than\n //necessary, result will have the correct length, but buf will still have it's original\n //length\n --------\n",
								"type": "nothrow ubyte[](scope ubyte[] buf)",
								"parameters": [
									{
										"name": "buf",
										"type": "ubyte[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"endline": 898,
								"char": 25,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "finish",
								"line": 901,
								"comment": "ditto\n",
								"type": "nothrow @trusted ubyte[]()",
								"endline": 907,
								"char": 34,
								"kind": "function"
							},
							{
								"name": "peek",
								"line": 917,
								"comment": " Works like $(D finish) but does not reset the internal state, so it's possible\n to continue putting data into this WrapperDigest after a call to peek.\n\n These functions are only available if $(D hasPeek!T) is true.\n",
								"type": "const @trusted ubyte[](scope ubyte[] buf)",
								"parameters": [
									{
										"name": "buf",
										"type": "ubyte[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"char": 30,
								"kind": "function"
							},
							{
								"name": "peek",
								"line": 919,
								"comment": "ditto\n",
								"type": "const @trusted ubyte[]()",
								"char": 30,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "WrapperDigest",
				"line": 826,
				"comment": " Wraps a template API hash struct into a Digest interface.\n Modules providing digest implementations will usually provide\n an alias for this template (e.g. MD5Digest, SHA1Digest, ...).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL947_2175)\n---\nimport std.digest.md;\n//Simple example\nauto hash = new WrapperDigest!MD5();\nhash.put(cast(ubyte)0);\nauto result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL947_2175)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL957_2176)\n---\n//using a supplied buffer\nimport std.digest.md;\nubyte[16] buf;\nauto hash = new WrapperDigest!MD5();\nhash.put(cast(ubyte)0);\nauto result = hash.finish(buf[]);\n//The result is now in result (and in buf). If you pass a buffer which is bigger than\n//necessary, result will have the correct length, but buf will still have it's original\n//length\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL957_2176)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isDigest!T",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " This module describes the _digest APIs used in Phobos. All digests follow\n these APIs. Additionally, this module contains useful helper methods which\n can be used with every _digest type.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF isDigest) $(MYREF DigestType) $(MYREF hasPeek)\n  $(MYREF ExampleDigest) $(MYREF _digest) $(MYREF hexDigest) $(MYREF makeDigest)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF Digest)\n)\n)\n$(TR $(TDNW Helper functions) $(TD $(MYREF toHexString))\n)\n$(TR $(TDNW Implementation helpers) $(TD $(MYREF digestLength) $(MYREF WrapperDigest))\n)\n)\n)\n\n APIs:\n There are two APIs for digests: The template API and the OOP API. The template API uses structs\n and template helpers like $(LREF isDigest). The OOP API implements digests as classes inheriting\n the $(LREF Digest) interface. All digests are named so that the template API struct is called \"$(B x)\"\n and the OOP API class is called \"$(B x)Digest\". For example we have $(D MD5) <--> $(D MD5Digest),\n $(D CRC32) <--> $(D CRC32Digest), etc.\n\n The template API is slightly more efficient. It does not have to allocate memory dynamically,\n all memory is allocated on the stack. The OOP API has to allocate in the finish method if no\n buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate,\n but the $(LREF Digest) classes still have to be created using $(D new) which allocates them using the GC.\n\n The OOP API is useful to change the _digest function and/or _digest backend at 'runtime'. The benefit here\n is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.\n\n If just one specific _digest type and backend is needed, the template API is usually a good fit.\n In this simplest case, the template API can even be used without templates: Just use the \"$(B x)\" structs\n directly.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:\n Johannes Pfau\n\n Source:    $(PHOBOSSRC std/_digest/_digest.d)\n\n CTFE:\n Digests do not work in CTFE\n\n TODO:\n Digesting single bits (as opposed to bytes) is not implemented. This will be done as another\n template constraint helper (hasBitDigesting!T) and an additional interface (BitDigest)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL71_2149)\n---\nimport std.digest.crc;\n\n//Simple example\nchar[8] hexHash = hexDigest!CRC32(\"The quick brown fox jumps over the lazy dog\");\nassert(hexHash == \"39A34F41\");\n\n//Simple example, using the API manually\nCRC32 context = makeDigest!CRC32();\ncontext.put(cast(ubyte[])\"The quick brown fox jumps over the lazy dog\");\nubyte[4] hash = context.finish();\nassert(toHexString(hash) == \"39A34F41\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL71_2149)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL87_2150)\n---\n//Generating the hashes of a file, idiomatic D way\nimport std.digest.crc, std.digest.sha, std.digest.md;\nimport std.stdio;\n\n// Digests a file and prints the result.\nvoid digestFile(Hash)(string filename) if(isDigest!Hash)\n{\n    auto file = File(filename);\n    auto result = digest!Hash(file.byChunk(4096 * 1024));\n    writefln(\"%s (%s) = %s\", Hash.stringof, filename, toHexString(result));\n}\n\nvoid main(string[] args)\n{\n    foreach (name; args[1 .. $])\n    {\n        digestFile!MD5(name);\n        digestFile!SHA1(name);\n        digestFile!CRC32(name);\n    }\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL87_2150)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL112_2151)\n---\n//Generating the hashes of a file using the template API\nimport std.digest.crc, std.digest.sha, std.digest.md;\nimport std.stdio;\n// Digests a file and prints the result.\nvoid digestFile(Hash)(ref Hash hash, string filename) if(isDigest!Hash)\n{\n    File file = File(filename);\n\n    //As digests imlement OutputRange, we could use std.algorithm.copy\n    //Let's do it manually for now\n    foreach (buffer; file.byChunk(4096 * 1024))\n        hash.put(buffer);\n\n    auto result = hash.finish();\n    writefln(\"%s (%s) = %s\", Hash.stringof, filename, toHexString(result));\n}\n\nvoid uMain(string[] args)\n{\n    MD5 md5;\n    SHA1 sha1;\n    CRC32 crc32;\n\n    md5.start();\n    sha1.start();\n    crc32.start();\n\n    foreach (arg; args[1 .. $])\n    {\n        digestFile(md5, arg);\n        digestFile(sha1, arg);\n        digestFile(crc32, arg);\n    }\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL112_2151)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL151_2152)\n---\nimport std.digest.crc, std.digest.sha, std.digest.md;\nimport std.stdio;\n\n// Digests a file and prints the result.\nvoid digestFile(Digest hash, string filename)\n{\n    File file = File(filename);\n\n    //As digests implement OutputRange, we could use std.algorithm.copy\n    //Let's do it manually for now\n    foreach (buffer; file.byChunk(4096 * 1024))\n      hash.put(buffer);\n\n    ubyte[] result = hash.finish();\n    writefln(\"%s (%s) = %s\", typeid(hash).toString(), filename, toHexString(result));\n}\n\nvoid umain(string[] args)\n{\n    auto md5 = new MD5Digest();\n    auto sha1 = new SHA1Digest();\n    auto crc32 = new CRC32Digest();\n\n    foreach (arg; args[1 .. $])\n    {\n      digestFile(md5, arg);\n      digestFile(sha1, arg);\n      digestFile(crc32, arg);\n    }\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL151_2152)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/sha.d",
		"name": "std.digest.sha",
		"members": [
			{
				"members": [
					{
						"name": "SHA",
						"line": 205,
						"members": [
							{
								"endchar": 9,
								"name": "start",
								"line": 684,
								"comment": " SHA initialization. Begins an SHA1/SHA2 operation.\n\n Note:\n For this SHA Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\n\n Examples:\n --------\n SHA1 digest;\n //digest.start(); //Not necessary\n digest.put(0);\n --------\n",
								"type": "pure nothrow @nogc @safe void()",
								"endline": 687,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "put",
								"line": 694,
								"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL738_2180)\n---\ntypeof(this) dig;\ndig.put(cast(ubyte)0); //single ubyte\ndig.put(cast(ubyte)0, cast(ubyte)0); //variadic\nubyte[10] buf;\ndig.put(buf); //buffer\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL738_2180)\n",
								"type": "pure nothrow @nogc @trusted void(scope const(ubyte)[] input...)",
								"parameters": [
									{
										"name": "input",
										"type": "const(ubyte)[]",
										"storageClass": [
											"scope"
										]
									}
								],
								"endline": 736,
								"char": 14,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "finish",
								"line": 752,
								"comment": " Returns the finished SHA hash. This also calls $(LREF start) to\n reset the internal state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL808_2181)\n---\n//Simple example\nSHA1 hash;\nhash.start();\nhash.put(cast(ubyte)0);\nubyte[20] result = hash.finish();\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL808_2181)\n",
								"type": "pure nothrow @nogc @trusted ubyte[digestSize / 8]()",
								"endline": 806,
								"char": 29,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SHA",
				"line": 205,
				"comment": " Template API SHA1/SHA2 implementation. Supports: SHA-1, SHA-224, SHA-256,\n SHA-384, SHA-512, SHA-512/224 and SHA-512/256.\n\n The blockSize and digestSize are in bits. However, it's likely easier to\n simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512,\n SHA512_224 and SHA512_256.\n\n See $(D std.digest.digest) for differences between template and OOP API.\n",
				"parameters": [
					{
						"name": "blockSize",
						"deco": "i",
						"kind": "value"
					},
					{
						"name": "digestSize",
						"deco": "i",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "SHA1",
				"line": 818,
				"comment": "SHA alias for SHA-1, hash is ubyte[20]\n",
				"deco": "S3std6digest3sha20__T3SHAVii512Vii160Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA224",
				"line": 819,
				"comment": "SHA alias for SHA-224, hash is ubyte[28]\n",
				"deco": "S3std6digest3sha20__T3SHAVii512Vii224Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA256",
				"line": 820,
				"comment": "SHA alias for SHA-256, hash is ubyte[32]\n",
				"deco": "S3std6digest3sha20__T3SHAVii512Vii256Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA384",
				"line": 821,
				"comment": "SHA alias for SHA-384, hash is ubyte[48]\n",
				"deco": "S3std6digest3sha21__T3SHAVii1024Vii384Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512",
				"line": 822,
				"comment": "SHA alias for SHA-512, hash is ubyte[64]\n",
				"deco": "S3std6digest3sha21__T3SHAVii1024Vii512Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_224",
				"line": 823,
				"comment": "SHA alias for SHA-512/224, hash is ubyte[28]\n",
				"deco": "S3std6digest3sha21__T3SHAVii1024Vii224Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_256",
				"line": 824,
				"comment": "SHA alias for SHA-512/256, hash is ubyte[32]\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL827_2182)\n---\n//Simple example, hashing a string using sha1Of helper function\nubyte[20] hash = sha1Of(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n//The same, but using SHA-224\nubyte[28] hash224 = sha224Of(\"abc\");\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL827_2182)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL840_2183)\n---\n//Using the basic API\nSHA1 hash;\nhash.start();\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[20] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL840_2183)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL852_2184)\n---\n//Let's use the template features:\n//Note: When passing a SHA1 to a function, it must be passed by reference!\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n  hash.put(cast(ubyte)0);\n}\nSHA1 sha;\nsha.start();\ndoSomething(sha);\nassert(toHexString(sha.finish()) == \"5BA93C9DB0CFF93F52B521D7420E43F6EDA2784F\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL852_2184)\n",
				"deco": "S3std6digest3sha21__T3SHAVii1024Vii256Z3SHA",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha1Of",
						"line": 1100,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1103,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha1Of",
				"line": 1100,
				"comment": " These are convenience aliases for $(XREF_PACK digest,digest,digest) using the\n SHA implementation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1136_2187)\n---\nubyte[20] hash = sha1Of(\"abc\");\nassert(hash == digest!SHA1(\"abc\"));\n\nubyte[28] hash224 = sha224Of(\"abc\");\nassert(hash224 == digest!SHA224(\"abc\"));\n\nubyte[32] hash256 = sha256Of(\"abc\");\nassert(hash256 == digest!SHA256(\"abc\"));\n\nubyte[48] hash384 = sha384Of(\"abc\");\nassert(hash384 == digest!SHA384(\"abc\"));\n\nubyte[64] hash512 = sha512Of(\"abc\");\nassert(hash512 == digest!SHA512(\"abc\"));\n\nubyte[28] hash512_224 = sha512_224Of(\"abc\");\nassert(hash512_224 == digest!SHA512_224(\"abc\"));\n\nubyte[32] hash512_256 = sha512_256Of(\"abc\");\nassert(hash512_256 == digest!SHA512_256(\"abc\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1136_2187)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha224Of",
						"line": 1105,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1108,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha224Of",
				"line": 1105,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha256Of",
						"line": 1110,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1113,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha256Of",
				"line": 1110,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha384Of",
						"line": 1115,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1118,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha384Of",
				"line": 1115,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha512Of",
						"line": 1120,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1123,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha512Of",
				"line": 1120,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha512_224Of",
						"line": 1125,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1128,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha512_224Of",
				"line": 1125,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sha512_256Of",
						"line": 1130,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 1133,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sha512_256Of",
				"line": 1130,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "SHA1Digest",
				"line": 1178,
				"comment": " OOP API SHA1 and SHA2 implementations.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!SHA1), see\n there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1187_2189)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto sha = new SHA1Digest();\nubyte[] hash = sha.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n//The same, but using SHA-224\nauto sha224 = new SHA224Digest();\nubyte[] hash224 = sha224.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1187_2189)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1203_2190)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n  dig.put(cast(ubyte)0);\n}\nauto sha = new SHA1Digest();\ntest(sha);\n\n//Let's use a custom buffer:\nubyte[20] buf;\nubyte[] result = sha.finish(buf[]);\nassert(toHexString(result) == \"5BA93C9DB0CFF93F52B521D7420E43F6EDA2784F\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1203_2190)\n",
				"deco": "C3std6digest6digest62__T13WrapperDigestTS3std6digest3sha20__T3SHAVii512Vii160Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA224Digest",
				"line": 1179,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest62__T13WrapperDigestTS3std6digest3sha20__T3SHAVii512Vii224Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA256Digest",
				"line": 1180,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest62__T13WrapperDigestTS3std6digest3sha20__T3SHAVii512Vii256Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA384Digest",
				"line": 1181,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVii1024Vii384Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512Digest",
				"line": 1182,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVii1024Vii512Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_224Digest",
				"line": 1183,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVii1024Vii224Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "SHA512_256Digest",
				"line": 1184,
				"comment": "ditto\n",
				"deco": "C3std6digest6digest63__T13WrapperDigestTS3std6digest3sha21__T3SHAVii1024Vii256Z3SHAZ13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " Computes SHA1 and SHA2 hashes of arbitrary data. SHA hashes are 20 to 64 byte\n quantities (depending on the SHA algorithm) that are like a checksum or CRC,\n but are more robust.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF SHA1)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF SHA1Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF sha1Of))\n)\n)\n)\n\n SHA2 comes in several different versions, all supported by this module:\n SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n CTFE:\n Digests do not work in CTFE\n\n Authors:\n The routines and algorithms are derived from the\n $(I Secure Hash Signature Standard (SHS) (FIPS PUB 180-2)). $(BR )\n Kai Nacke, Johannes Pfau, Nick Sabalausky\n\n References:\n $(UL\n $(LI $(LINK2 http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf, FIPS PUB180-2))\n $(LI $(LINK2 http://software.intel.com/en-us/articles/improving-the-performance-of-the-secure-hash-algorithm-1/, Fast implementation of SHA1))\n $(LI $(LINK2 http://en.wikipedia.org/wiki/Secure_Hash_Algorithm, Wikipedia article about SHA))\n )\n\n Source: $(PHOBOSSRC std/digest/_sha.d)\n\n Macros:\n      WIKI = Phobos/StdSha1\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL63_2177)\n---\n//Template API\nimport std.digest.sha;\n\nubyte[20] hash1 = sha1Of(\"abc\");\nassert(toHexString(hash1) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\nubyte[28] hash224 = sha224Of(\"abc\");\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n//Feeding data\nubyte[1024] data;\nSHA1 sha1;\nsha1.start();\nsha1.put(data[]);\nsha1.start(); //Start again\nsha1.put(data[]);\nhash1 = sha1.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL63_2177)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL85_2178)\n---\n//OOP API\nimport std.digest.sha;\n\nauto sha1 = new SHA1Digest();\nubyte[] hash1 = sha1.digest(\"abc\");\nassert(toHexString(hash1) == \"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\nauto sha224 = new SHA224Digest();\nubyte[] hash224 = sha224.digest(\"abc\");\nassert(toHexString(hash224) == \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n//Feeding data\nubyte[1024] data;\nsha1.put(data[]);\nsha1.reset(); //Start again\nsha1.put(data[]);\nhash1 = sha1.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL85_2178)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/crc.d",
		"name": "std.digest.crc",
		"members": [
			{
				"name": "CRC32",
				"line": 151,
				"comment": " Template API CRC32 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL231_2197)\n---\n//Simple example, hashing a string using crc32Of helper function\nubyte[4] hash = crc32Of(\"abc\");\n//Let's get a hash string\nassert(crcHexString(hash) == \"352441C2\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL231_2197)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL240_2198)\n---\n//Using the basic API\nCRC32 hash;\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[4] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL240_2198)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL251_2199)\n---\n//Let's use the template features:\n//Note: When passing a CRC32 to a function, it must be passed by reference!\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n  hash.put(cast(ubyte)0);\n}\nCRC32 crc;\ncrc.start();\ndoSomething(crc);\nassert(crcHexString(crc.finish()) == \"D202EF8D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL251_2199)\n",
				"members": [
					{
						"endchar": 9,
						"name": "put",
						"line": 163,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL169_2194)\n---\nCRC32 dig;\ndig.put(cast(ubyte)0); //single ubyte\ndig.put(cast(ubyte)0, cast(ubyte)0); //variadic\nubyte[10] buf;\ndig.put(buf); //buffer\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL169_2194)\n",
						"deco": "FNaNbNiNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 167,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "start",
						"line": 187,
						"comment": " Used to initialize the CRC32 digest.\n\n Note:\n For this CRC32 Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL192_2195)\n---\nCRC32 digest;\n//digest.start(); //Not necessary\ndigest.put(0);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL192_2195)\n",
						"deco": "FNaNbNiNfZv",
						"endline": 190,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "finish",
						"line": 203,
						"comment": " Returns the finished CRC32 hash. This also calls $(LREF start) to\n reset the internal state.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL210_2196)\n---\n//Simple example\nCRC32 hash;\nhash.put(cast(ubyte)0);\nubyte[4] result = hash.finish();\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL210_2196)\n",
						"deco": "FNaNbNiNfZG4h",
						"endline": 208,
						"char": 18,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "peek",
						"line": 222,
						"comment": " Works like $(D finish) but does not reset the internal state, so it's possible\n to continue putting data into this CRC32 after a call to peek.\n",
						"deco": "xFNaNbNiNfZG4h",
						"endline": 227,
						"char": 18,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "crc32Of",
						"line": 322,
						"type": "ubyte[4](T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 325,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "crc32Of",
				"line": 322,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,digest) using the\n CRC32 implementation.\n\n Params:\n      data = $(D InputRange) of $(D ElementType) implicitly convertible to\n             $(D ubyte), $(D ubyte[]) or $(D ubyte[num]) or one or more arrays\n             of any type.\n\n Returns:\n      CRC32 of data\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL328_2202)\n---\nubyte[] data = [4,5,7,25];\nassert(data.crc32Of == [167, 180, 199, 131]);\n\nimport std.utf : byChar;\nassert(\"hello\"d.byChar.crc32Of == [134, 166, 16, 54]);\n\nubyte[4] hash = \"abc\".crc32Of();\nassert(hash == digest!CRC32(\"ab\", \"c\"));\n\nimport std.range : iota;\nenum ubyte S = 5, F = 66;\nassert(iota(S, F).crc32Of == [59, 140, 234, 154]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL328_2202)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 10,
				"kind": "template"
			},
			{
				"name": "crcHexString",
				"line": 348,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,toHexString)\n producing the usual CRC32 string output.\n",
				"char": 8,
				"kind": "alias"
			},
			{
				"name": "crcHexString",
				"line": 350,
				"comment": "ditto\n",
				"char": 8,
				"kind": "alias"
			},
			{
				"name": "CRC32Digest",
				"line": 360,
				"comment": " OOP API CRC32 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!CRC32), see\n there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL363_2203)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto crc = new CRC32Digest();\nubyte[] hash = crc.digest(\"abc\");\n//Let's get a hash string\nassert(crcHexString(hash) == \"352441C2\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL363_2203)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL373_2204)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n dig.put(cast(ubyte)0);\n}\nauto crc = new CRC32Digest();\ntest(crc);\n\n//Let's use a custom buffer:\nubyte[4] buf;\nubyte[] result = crc.finish(buf[]);\nassert(crcHexString(result) == \"D202EF8D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL373_2204)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL390_2205)\n---\n//Simple example\nauto hash = new CRC32Digest();\nhash.put(cast(ubyte)0);\nubyte[] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL390_2205)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL399_2206)\n---\n//using a supplied buffer\nubyte[4] buf;\nauto hash = new CRC32Digest();\nhash.put(cast(ubyte)0);\nubyte[] result = hash.finish(buf[]);\n//The result is now in result (and in buf. If you pass a buffer which is bigger than\n//necessary, result will have the correct length, but buf will still have it's original\n//length)\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL399_2206)\n",
				"deco": "C3std6digest6digest42__T13WrapperDigestTS3std6digest3crc5CRC32Z13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": "Cyclic Redundancy Check (32-bit) implementation.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF CRC32)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF CRC32Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF crcHexString) $(MYREF crc32Of))\n)\n)\n)\n\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n Note:\n CRCs are usually printed with the MSB first. When using\n $(XREF_PACK digest,digest,toHexString) the result will be in an unexpected\n order. Use $(XREF_PACK digest,digest,toHexString)'s optional order parameter\n to specify decreasing order for the correct result. The $(LREF crcHexString)\n alias can also be used for this purpose.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n Authors:   Pavel \"EvilOne\" Minayev, Alex RÃ¸nne Petersen, Johannes Pfau\n\n References:\n      $(LINK2 http://en.wikipedia.org/wiki/Cyclic_redundancy_check, Wikipedia on CRC)\n\n Source: $(PHOBOSSRC std/digest/_crc.d)\n\n Macros:\n WIKI = Phobos/StdUtilDigestCRC32\n\n Standards:\n Implements the 'common' IEEE CRC32 variant\n (LSB-first order, Initial value uint.max, complement result)\n\n CTFE:\n Digests do not work in CTFE\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL71_2192)\n---\n//Template API\nimport std.digest.crc;\n\nubyte[4] hash = crc32Of(\"The quick brown fox jumps over the lazy dog\");\nassert(crcHexString(hash) == \"414FA339\");\n\n//Feeding data\nubyte[1024] data;\nCRC32 crc;\ncrc.put(data[]);\ncrc.start(); //Start again\ncrc.put(data[]);\nhash = crc.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL71_2192)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL89_2193)\n---\n//OOP API\nimport std.digest.crc;\n\nauto crc = new CRC32Digest();\nubyte[] hash = crc.digest(\"The quick brown fox jumps over the lazy dog\");\nassert(crcHexString(hash) == \"414FA339\"); //352441c2\n\n//Feeding data\nubyte[1024] data;\ncrc.put(data[]);\ncrc.reset(); //Start again\ncrc.put(data[]);\nhash = crc.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL89_2193)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/digest/ripemd.d",
		"name": "std.digest.ripemd",
		"members": [
			{
				"name": "RIPEMD160",
				"line": 102,
				"comment": " Template API RIPEMD160 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL561_2210)\n---\n//Simple example, hashing a string using ripemd160Of helper function\nubyte[20] hash = ripemd160Of(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL561_2210)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL570_2211)\n---\n//Using the basic API\nRIPEMD160 hash;\nhash.start();\nubyte[1024] data;\n//Initialize data here...\nhash.put(data);\nubyte[20] result = hash.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL570_2211)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL582_2212)\n---\n//Let's use the template features:\nvoid doSomething(T)(ref T hash) if(isDigest!T)\n{\n    hash.put(cast(ubyte)0);\n}\nRIPEMD160 md;\nmd.start();\ndoSomething(md);\nassert(toHexString(md.finish()) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL582_2212)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL596_2213)\n---\n//Simple example\nRIPEMD160 hash;\nhash.start();\nhash.put(cast(ubyte)0);\nubyte[20] result = hash.finish();\nassert(toHexString(result) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL596_2213)\n",
				"members": [
					{
						"endchar": 9,
						"name": "put",
						"line": 457,
						"comment": " Use this to feed the digest with data.\n Also implements the $(XREF_PACK range,primitives,isOutputRange)\n interface for $(D ubyte) and $(D const(ubyte)[]).\n\n Examples:\n ----\n RIPEMD160 dig;\n dig.put(cast(ubyte)0); //single ubyte\n dig.put(cast(ubyte)0, cast(ubyte)0); //variadic\n ubyte[10] buf;\n dig.put(buf); //buffer\n ----\n",
						"deco": "FNaNbNiNeMAxhXv",
						"parameters": [
							{
								"name": "data",
								"storageClass": [
									"scope"
								],
								"deco": "Axh"
							}
						],
						"endline": 491,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "start",
						"line": 509,
						"comment": " Used to (re)initialize the RIPEMD160 digest.\n\n Note:\n For this RIPEMD160 Digest implementation calling start after default construction\n is not necessary. Calling start is only necessary to reset the Digest.\n\n Generic code which deals with different Digest types should always call start though.\n\n Examples:\n --------\n RIPEMD160 digest;\n //digest.start(); //Not necessary\n digest.put(0);\n --------\n",
						"deco": "FNaNbNiNfZv",
						"endline": 512,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "finish",
						"line": 528,
						"comment": " Returns the finished RIPEMD160 hash. This also calls $(LREF start) to\n reset the internal state.\n\n Examples:\n --------\n //Simple example\n RIPEMD160 hash;\n hash.start();\n hash.put(cast(ubyte)0);\n ubyte[20] result = hash.finish();\n assert(toHexString(result) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n --------\n",
						"deco": "FNaNbNiNeZG20h",
						"endline": 557,
						"char": 19,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ripemd160Of",
						"line": 666,
						"type": "(T data)",
						"parameters": [
							{
								"name": "data",
								"type": "T"
							}
						],
						"endline": 669,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "ripemd160Of",
				"line": 666,
				"comment": " This is a convenience alias for $(XREF_PACK digest,digest,digest) using the\n RIPEMD160 implementation.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL672_2216)\n---\nubyte[20] hash = ripemd160Of(\"abc\");\nassert(hash == digest!RIPEMD160(\"abc\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL672_2216)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"name": "RIPEMD160Digest",
				"line": 685,
				"comment": " OOP API RIPEMD160 implementation.\n See $(D std.digest.digest) for differences between template and OOP API.\n\n This is an alias for $(D $(XREF_PACK digest,digest,WrapperDigest)!RIPEMD160),\n see there for more information.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL688_2217)\n---\n//Simple example, hashing a string using Digest.digest helper function\nauto md = new RIPEMD160Digest();\nubyte[] hash = md.digest(\"abc\");\n//Let's get a hash string\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL688_2217)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL698_2218)\n---\n//Let's use the OOP features:\nvoid test(Digest dig)\n{\n  dig.put(cast(ubyte)0);\n}\nauto md = new RIPEMD160Digest();\ntest(md);\n\n//Let's use a custom buffer:\nubyte[20] buf;\nubyte[] result = md.finish(buf[]);\nassert(toHexString(result) == \"C81B94933420221A7AC004A90242D8B1D3E5070D\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL698_2218)\n",
				"deco": "C3std6digest6digest49__T13WrapperDigestTS3std6digest6ripemd9RIPEMD160Z13WrapperDigest",
				"char": 1,
				"kind": "alias"
			}
		],
		"comment": " Computes RIPEMD-160 hashes of arbitrary data. RIPEMD-160 hashes are 20 byte quantities\n that are like a checksum or CRC, but are more robust.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Template API) $(TD $(MYREF RIPEMD160)\n)\n)\n$(TR $(TDNW OOP API) $(TD $(MYREF RIPEMD160Digest))\n)\n$(TR $(TDNW Helpers) $(TD $(MYREF ripemd160Of))\n)\n)\n)\n\n This module conforms to the APIs defined in $(D std.digest.digest). To understand the\n differences between the template and the OOP API, see $(D std.digest.digest).\n\n This module publicly imports $(D std.digest.digest) and can be used as a stand-alone\n module.\n\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n CTFE:\n Digests do not work in CTFE\n\n Authors:\n Kai Nacke $(BR)\n The algorithm was designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel. $(BR)\n The D implementation is a direct translation of the ANSI C implementation by Antoon Bosselaers.\n\n References:\n $(UL\n $(LI $(LINK2 http://homes.esat.kuleuven.be/~bosselae/ripemd160.html, The hash function RIPEMD-160))\n $(LI $(LINK2 http://en.wikipedia.org/wiki/RIPEMD-160, Wikipedia on RIPEMD-160))\n )\n\n Source: $(PHOBOSSRC std/digest/_ripemd.d)\n\n Macros:\n WIKI = Phobos/StdRipemd\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL54_2208)\n---\n//Template API\nimport std.digest.md;\n\nubyte[20] hash = ripemd160Of(\"abc\");\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n//Feeding data\nubyte[1024] data;\nRIPEMD160 md;\nmd.start();\nmd.put(data[]);\nmd.start(); //Start again\nmd.put(data[]);\nhash = md.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL54_2208)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL73_2209)\n---\n//OOP API\nimport std.digest.md;\n\nauto md = new RIPEMD160Digest();\nubyte[] hash = md.digest(\"abc\");\nassert(toHexString(hash) == \"8EB208F7E05D987A9B044A8E98C6B087F15A0BFC\");\n\n//Feeding data\nubyte[1024] data;\nmd.put(data[]);\nmd.reset(); //Start again\nmd.put(data[]);\nhash = md.finish();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL73_2209)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/random.d",
		"name": "std.random",
		"members": [
			{
				"members": [
					{
						"name": "isUniformRNG",
						"line": 135,
						"deco": "b",
						"init": "isInputRange!Rng && is(typeof(Rng.front) == ElementType) && is(typeof(()\n{\nstatic assert(Rng.isUniformRandom);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUniformRNG",
				"line": 133,
				"comment": " Test if Rng is a random-number generator. The overload\n taking a ElementType also makes sure that the Rng generates\n values of that type.\n\n A random-number generator has at least the following features:\n $(UL\n   $(LI it's an InputRange)\n   $(LI it has a 'bool isUniformRandom' field readable in CTFE)\n )\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					},
					{
						"name": "ElementType",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isUniformRNG",
						"line": 148,
						"deco": "b",
						"init": "isInputRange!Rng && is(typeof(()\n{\nstatic assert(Rng.isUniformRandom);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUniformRNG",
				"line": 146,
				"comment": " ditto\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSeedable",
						"line": 166,
						"deco": "b",
						"init": "isUniformRNG!Rng && is(typeof(()\n{\nRng r = void;\nr.seed(SeedType.init);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSeedable",
				"line": 164,
				"comment": " Test if Rng is seedable. The overload\n taking a SeedType also makes sure that the Rng can be seeded with SeedType.\n\n A seedable random-number generator has the following additional features:\n $(UL\n   $(LI it has a 'seed(ElementType)' function)\n )\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					},
					{
						"name": "SeedType",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSeedable",
						"line": 177,
						"deco": "b",
						"init": "isUniformRNG!Rng && is(typeof(()\n{\nRng r = void;\nr.seed((typeof(r.front)).init);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSeedable",
				"line": 175,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "LinearCongruentialEngine",
						"line": 253,
						"members": [
							{
								"name": "isUniformRandom",
								"line": 257,
								"comment": "Mark this as a Rng\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "hasFixedRange",
								"line": 259,
								"comment": "Does this generator have a fixed range? ($(D_PARAM true)).\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "min",
								"line": 261,
								"comment": "Lowest generated value ($(D 1) if $(D c == 0), $(D 0) otherwise).\n",
								"type": "UIntType",
								"init": "c == 0 ? 1 : 0",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "max",
								"line": 263,
								"comment": "Highest generated value ($(D modulus - 1)).\n",
								"type": "UIntType",
								"init": "m - 1",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "multiplier",
								"line": 268,
								"comment": "The parameters of this distribution. The random number is $(D_PARAM x\n= (x * multipler + increment) % modulus).\n",
								"type": "UIntType",
								"init": "a",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "increment",
								"line": 270,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "c",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "modulus",
								"line": 272,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "m",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 354,
								"comment": "Constructs a $(D_PARAM LinearCongruentialEngine) generator seeded with\n$(D x0).\n",
								"type": "pure @safe (UIntType x0)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType"
									}
								],
								"endline": 357,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "seed",
								"line": 362,
								"comment": "   (Re)seeds the generator.\n",
								"type": "pure @safe void(UIntType x0 = 1)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType",
										"default": "1"
									}
								],
								"endline": 372,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 377,
								"comment": "   Advances the random sequence.\n",
								"type": "pure nothrow @safe void()",
								"endline": 408,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 413,
								"comment": "   Returns the current number in the random sequence.\n",
								"type": "const pure nothrow @property @safe UIntType()",
								"endline": 416,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 419,
								"comment": "\n",
								"type": "pure nothrow @property @safe typeof(this)()",
								"endline": 422,
								"char": 28,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 427,
								"comment": "Always $(D false) (random generators are infinite ranges).\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 432,
								"comment": "   Compares against $(D_PARAM rhs) for equality.\n",
								"type": "const pure nothrow @safe bool(ref const LinearCongruentialEngine rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "LinearCongruentialEngine",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 435,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "LinearCongruentialEngine",
				"line": 253,
				"comment": "Linear Congruential generator.\n",
				"parameters": [
					{
						"name": "UIntType",
						"kind": "type"
					},
					{
						"name": "a",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "c",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "m",
						"type": "UIntType",
						"kind": "value"
					}
				],
				"constraint": "isUnsigned!UIntType",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "MinstdRand0",
				"line": 460,
				"comment": "Define $(D_PARAM LinearCongruentialEngine) generators with well-chosen\nparameters. $(D MinstdRand0) implements Park and Miller's \"minimal\nstandard\" $(WEB\nwikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator,\ngenerator) that uses 16807 for the multiplier. $(D MinstdRand)\nimplements a variant that has slightly better spectral behavior by\nusing the multiplier 48271. Both generators are rather simplistic.\n\nExample:\n\n----\n// seed with a constant\nauto rnd0 = MinstdRand0(1);\nauto n = rnd0.front; // same for each run\n// Seed with an unpredictable value\nrnd0.seed(unpredictableSeed);\nn = rnd0.front; // different across runs\n----\n",
				"deco": "S3std6random57__T24LinearCongruentialEngineTkVki16807Vki0Vki2147483647Z24LinearCongruentialEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "MinstdRand",
				"line": 462,
				"comment": "ditto\n",
				"deco": "S3std6random57__T24LinearCongruentialEngineTkVki48271Vki0Vki2147483647Z24LinearCongruentialEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "MersenneTwisterEngine",
						"line": 532,
						"members": [
							{
								"name": "isUniformRandom",
								"line": 545,
								"comment": "Mark this as a Rng\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "wordSize",
								"line": 550,
								"comment": "Parameters for the generator.\n",
								"type": "size_t",
								"init": "w",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "stateSize",
								"line": 551,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "n",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "shiftSize",
								"line": 552,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "m",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "maskBits",
								"line": 553,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "r",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "xorMask",
								"line": 554,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "a",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingU",
								"line": 555,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "u",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingS",
								"line": 556,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "s",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingB",
								"line": 557,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "b",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingT",
								"line": 558,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "t",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingC",
								"line": 559,
								"comment": "ditto\n",
								"type": "UIntType",
								"init": "c",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "temperingL",
								"line": 560,
								"comment": "ditto\n",
								"type": "size_t",
								"init": "l",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "min",
								"line": 563,
								"comment": "Smallest generated value (0).\n",
								"type": "UIntType",
								"init": "0",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "max",
								"line": 565,
								"comment": "Largest generated value.\n",
								"type": "UIntType",
								"init": "UIntType.max >> UIntType.sizeof * 8u - w",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "defaultSeed",
								"line": 568,
								"comment": "The default seed value.\n",
								"type": "UIntType",
								"init": "5489u",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 573,
								"comment": "   Constructs a MersenneTwisterEngine object.\n",
								"type": "pure nothrow @safe (UIntType value)",
								"parameters": [
									{
										"name": "value",
										"type": "UIntType"
									}
								],
								"endline": 576,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "seed",
										"line": 584,
										"type": "pure nothrow @safe void(UIntType value = defaultSeed)",
										"parameters": [
											{
												"name": "value",
												"type": "UIntType",
												"default": "defaultSeed"
											}
										],
										"endline": 608,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "seed",
								"line": 584,
								"comment": "   Seeds a MersenneTwisterEngine object.\n   Note:\n   This seed function gives 2^32 starting points. To allow the RNG to be started in any one of its\n   internal states use the seed overload taking an InputRange.\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "seed",
										"line": 623,
										"type": "void(T range)",
										"parameters": [
											{
												"name": "range",
												"type": "T"
											}
										],
										"endline": 640,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "seed",
								"line": 623,
								"comment": "   Seeds a MersenneTwisterEngine object using an InputRange.\n\n   Throws:\n   $(D Exception) if the InputRange didn't provide enough elements to seed the generator.\n   The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.\n\n   Examples:\n   ----------------\n   Mt19937 gen;\n   gen.seed(map!((a) => unpredictableSeed)(repeat(0)));\n   ----------------\n",
								"parameters": [
									{
										"name": "T",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!T && is(Unqual!(ElementType!T) == UIntType)",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 645,
								"comment": "   Advances the generator.\n",
								"type": "pure nothrow @safe void()",
								"endline": 691,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 696,
								"comment": "   Returns the current random value.\n",
								"type": "pure nothrow @property @safe UIntType()",
								"endline": 700,
								"char": 24,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 703,
								"comment": "\n",
								"type": "pure nothrow @property @safe typeof(this)()",
								"endline": 706,
								"char": 28,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 711,
								"comment": "Always $(D false).\n",
								"deco": "b",
								"init": "false",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "MersenneTwisterEngine",
				"line": 532,
				"comment": "The $(LUCKY Mersenne Twister) generator.\n",
				"parameters": [
					{
						"name": "UIntType",
						"kind": "type"
					},
					{
						"name": "w",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "n",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "m",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "r",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "a",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "u",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "s",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "b",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "t",
						"deco": "m",
						"kind": "value"
					},
					{
						"name": "c",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "l",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "isUnsigned!UIntType",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Mt19937",
				"line": 737,
				"comment": "A $(D MersenneTwisterEngine) instantiated with the parameters of the\noriginal engine $(WEB math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html,\nMT19937), generating uniformly-distributed 32-bit numbers with a\nperiod of 2 to the power of 19937. Recommended for random number\ngeneration unless memory is severely restricted, in which case a $(D\nLinearCongruentialEngine) would be the generator of choice.\n\nExample:\n\n----\n// seed with a constant\nMt19937 gen;\nauto n = gen.front; // same for each run\n// Seed with an unpredictable value\ngen.seed(unpredictableSeed);\nn = gen.front; // different across runs\n----\n",
				"deco": "S3std6random109__T21MersenneTwisterEngineTkVmi32Vmi624Vmi397Vmi31Vki2567483615Vmi11Vmi7Vki2636928640Vmi15Vki4022730752Vmi18Z21MersenneTwisterEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "XorshiftEngine",
						"line": 829,
						"members": [
							{
								"name": "isUniformRandom",
								"line": 838,
								"comment": "Mark this as a Rng\n",
								"deco": "b",
								"init": "true",
								"char": 15,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "empty",
								"line": 840,
								"comment": "Always $(D false) (random generators are infinite ranges).\n",
								"init": "false",
								"char": 10,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "min",
								"line": 842,
								"comment": "Smallest generated value.\n",
								"type": "UIntType",
								"init": "0",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"name": "max",
								"line": 844,
								"comment": "Largest generated value.\n",
								"type": "UIntType",
								"init": "UIntType.max",
								"char": 19,
								"kind": "variable",
								"storageClass": [
									"enum"
								]
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 877,
								"comment": " Constructs a $(D XorshiftEngine) generator seeded with $(D_PARAM x0).\n",
								"type": "pure nothrow @safe (UIntType x0)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType"
									}
								],
								"endline": 880,
								"char": 13,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "seed",
								"line": 887,
								"comment": " (Re)seeds the generator.\n",
								"type": "pure nothrow @safe void(UIntType x0)",
								"parameters": [
									{
										"name": "x0",
										"type": "UIntType"
									}
								],
								"endline": 897,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 904,
								"comment": " Returns the current number in the random sequence.\n",
								"type": "const pure nothrow @property @safe UIntType()",
								"endline": 910,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 917,
								"comment": " Advances the random sequence.\n",
								"type": "pure nothrow @safe void()",
								"endline": 972,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 979,
								"comment": " Captures a range state.\n",
								"type": "pure nothrow @property @safe typeof(this)()",
								"endline": 982,
								"char": 26,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 989,
								"comment": " Compares against $(D_PARAM rhs) for equality.\n",
								"type": "const pure nothrow @safe bool(ref const XorshiftEngine rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "XorshiftEngine",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 992,
								"char": 18,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "XorshiftEngine",
				"line": 829,
				"comment": " Xorshift generator using 32bit algorithm.\n\n Implemented according to $(WEB www.jstatsoft.org/v08/i14/paper, Xorshift RNGs).\n\n $(BOOKTABLE $(TEXTWITHCOMMAS Supporting bits are below, $(D bits) means second parameter of XorshiftEngine.),\n  $(TR $(TH bits) $(TH period))\n  $(TR $(TD 32)   $(TD 2^32 - 1))\n  $(TR $(TD 64)   $(TD 2^64 - 1))\n  $(TR $(TD 96)   $(TD 2^96 - 1))\n  $(TR $(TD 128)  $(TD 2^128 - 1))\n  $(TR $(TD 160)  $(TD 2^160 - 1))\n  $(TR $(TD 192)  $(TD 2^192 - 2^32))\n )\n",
				"parameters": [
					{
						"name": "UIntType",
						"kind": "type"
					},
					{
						"name": "bits",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "a",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "b",
						"type": "UIntType",
						"kind": "value"
					},
					{
						"name": "c",
						"type": "UIntType",
						"kind": "value"
					}
				],
				"constraint": "isUnsigned!UIntType",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "Xorshift32",
				"line": 1036,
				"comment": " Define $(D XorshiftEngine) generators with well-chosen parameters. See each bits examples of \"Xorshift RNGs\".\n $(D Xorshift) is a Xorshift128's alias because 128bits implementation is mostly used.\n\n Example:\n -----\n // Seed with a constant\n auto rnd = Xorshift(1);\n auto num = rnd.front;  // same for each run\n\n // Seed with an unpredictable value\n rnd.seed(unpredictableSeed());\n num = rnd.front; // different across runs\n -----\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki32Vki13Vki17Vki15Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift64",
				"line": 1037,
				"comment": "ditto\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki64Vki10Vki13Vki10Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift96",
				"line": 1038,
				"comment": "ditto\n",
				"deco": "S3std6random41__T14XorshiftEngineTkVki96Vki10Vki5Vki26Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift128",
				"line": 1039,
				"comment": "ditto\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki128Vki11Vki8Vki19Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift160",
				"line": 1040,
				"comment": "ditto\n",
				"deco": "S3std6random40__T14XorshiftEngineTkVki160Vki2Vki1Vki4Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift192",
				"line": 1041,
				"comment": "ditto\n",
				"deco": "S3std6random40__T14XorshiftEngineTkVki192Vki2Vki1Vki4Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Xorshift",
				"line": 1042,
				"comment": "ditto\n",
				"deco": "S3std6random42__T14XorshiftEngineTkVki128Vki11Vki8Vki19Z14XorshiftEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "unpredictableSeed",
				"line": 1133,
				"comment": "A \"good\" seed for initializing random number engines. Initializing\nwith $(D_PARAM unpredictableSeed) makes engines generate different\nrandom number sequences every run.\n\nReturns:\nA single unsigned integer seed value, different on each successive call\n\nExample:\n\n----\nauto rnd = Random(unpredictableSeed);\nauto n = rnd.front;\n...\n----\n",
				"deco": "FNdNeZk",
				"endline": 1146,
				"char": 16,
				"kind": "function"
			},
			{
				"name": "Random",
				"line": 1163,
				"comment": "The \"default\", \"favorite\", \"suggested\" random number generator type on\nthe current platform. It is an alias for one of the previously-defined\ngenerators. You may want to use it if (1) you need to generate some\nnice random numbers, and (2) you don't care for the minutiae of the\nmethod being used.\n",
				"deco": "S3std6random109__T21MersenneTwisterEngineTkVmi32Vmi624Vmi397Vmi31Vki2567483615Vmi11Vmi7Vki2636928640Vmi15Vki4022730752Vmi18Z21MersenneTwisterEngine",
				"char": 1,
				"kind": "alias"
			},
			{
				"endchar": 1,
				"name": "rndGen",
				"line": 1181,
				"comment": "Global random number generator used by various functions in this\nmodule whenever no generator is specified. It is allocated per-thread\nand initialized to an unpredictable value for each thread.\n\nReturns:\nA singleton instance of the default random number generator\n",
				"deco": "FNcNdNfZS3std6random109__T21MersenneTwisterEngineTkVmi32Vmi624Vmi397Vmi31Vki2567483615Vmi11Vmi7Vki2636928640Vmi15Vki4022730752Vmi18Z21MersenneTwisterEngine",
				"endline": 1197,
				"originalType": "@property ref @safe Random()",
				"char": 22,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1228,
						"type": "(T1 a, T2 b)",
						"parameters": [
							{
								"name": "a",
								"type": "T1"
							},
							{
								"name": "b",
								"type": "T2"
							}
						],
						"endline": 1232,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1228,
				"comment": "Generates a number between $(D a) and $(D b). The $(D boundaries)\nparameter controls the shape of the interval (open vs. closed on\neither side). Valid values for $(D boundaries) are $(D \"[]\"), $(D\n\"$(LPAREN)]\"), $(D \"[$(RPAREN)\"), and $(D \"()\"). The default interval\nis closed to the left and open to the right. The version that does not\ntake $(D urng) uses the default generator $(D rndGen).\n\nParams:\n    a = lower bound of the _uniform distribution\n    b = upper bound of the _uniform distribution\n    urng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\nReturns:\n    A single random variate drawn from the _uniform distribution\n    between $(D a) and $(D b), whose type is the common type of\n    these parameters\n\nExample:\n\n----\nauto gen = Random(unpredictableSeed);\n// Generate an integer in [0, 1023]\nauto a = uniform(0, 1024, gen);\n// Generate a float in [0, 1$(RPAREN)\nauto a = uniform(0.0f, 1.0f, gen);\n----\n",
				"parameters": [
					{
						"name": "boundaries",
						"defaultValue": "\"[)\"",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"constraint": "!is(CommonType!(T1, T2) == void)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1265,
						"type": "(T1 a, T2 b, ref UniformRandomNumberGenerator urng)",
						"parameters": [
							{
								"name": "a",
								"type": "T1"
							},
							{
								"name": "b",
								"type": "T2"
							},
							{
								"name": "urng",
								"type": "UniformRandomNumberGenerator",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1299,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1265,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "boundaries",
						"defaultValue": "\"[)\"",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					},
					{
						"name": "UniformRandomNumberGenerator",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!(CommonType!(T1, T2)) && isUniformRNG!UniformRandomNumberGenerator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1574,
						"type": "(ref UniformRandomNumberGenerator urng)",
						"parameters": [
							{
								"name": "urng",
								"type": "UniformRandomNumberGenerator",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1601,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1574,
				"comment": "Generates a uniformly-distributed number in the range $(D [T.min,\nT.max]) for any integral or character type $(D T). If no random\nnumber generator is passed, uses the default $(D rndGen).\n\nParams:\n    urng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\nReturns:\n    Random variate drawn from the _uniform distribution across all\n    possible values of the integral or character type $(D T).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "UniformRandomNumberGenerator",
						"kind": "type"
					}
				],
				"constraint": "!is(T == enum) && (isIntegral!T || isSomeChar!T) && isUniformRNG!UniformRandomNumberGenerator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1604,
						"type": "()",
						"endline": 1608,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1604,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!is(T == enum) && (isIntegral!T || isSomeChar!T)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1642,
						"type": "(ref UniformRandomNumberGenerator urng)",
						"parameters": [
							{
								"name": "urng",
								"type": "UniformRandomNumberGenerator",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1648,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1642,
				"comment": "Returns a uniformly selected member of enum $(D E). If no random number\ngenerator is passed, uses the default $(D rndGen).\n\nParams:\n    urng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\nReturns:\n    Random variate drawn with equal probability from any\n    of the possible values of the enum $(D E).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1658_2242)\n---\nenum Fruit { apple, mango, pear }\nauto randFruit = uniform!Fruit();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1658_2242)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "UniformRandomNumberGenerator",
						"kind": "type"
					}
				],
				"constraint": "is(E == enum) && isUniformRNG!UniformRandomNumberGenerator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform",
						"line": 1651,
						"type": "()",
						"endline": 1655,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniform",
				"line": 1651,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(E == enum)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform01",
						"line": 1695,
						"type": "T()",
						"endline": 1699,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "uniform01",
				"line": 1695,
				"comment": " Generates a uniformly-distributed floating point number of type\n $(D T) in the range [0, 1$(RPAREN).  If no random number generator is\n specified, the default RNG $(D rndGen) will be used as the source\n of randomness.\n\n $(D uniform01) offers a faster generation of random variates than\n the equivalent $(D uniform!\"[$(RPAREN)\"(0.0, 1.0)) and so may be preferred\n for some applications.\n\n Params:\n     rng = (optional) random number generator to use;\n           if not specified, defaults to $(D rndGen)\n\n Returns:\n     Floating-point random variate of type $(D T) drawn from the _uniform\n     distribution across the half-open interval [0, 1$(RPAREN).\n\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniform01",
						"line": 1702,
						"type": "T(ref UniformRNG rng)",
						"parameters": [
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1755,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "uniform01",
				"line": 1702,
				"comment": "ditto\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!T && isUniformRNG!UniformRNG",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniformDistribution",
						"line": 1797,
						"type": "F[](size_t n, F[] useThis = null)",
						"parameters": [
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "useThis",
								"type": "F[]",
								"default": "null"
							}
						],
						"endline": 1808,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "uniformDistribution",
				"line": 1797,
				"comment": "Generates a uniform probability distribution of size $(D n), i.e., an\narray of size $(D n) of positive numbers of type $(D F) that sum to\n$(D 1). If $(D useThis) is provided, it is used as storage.\n",
				"parameters": [
					{
						"defaultDeco": "d",
						"name": "F",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!F",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomShuffle",
						"line": 1834,
						"type": "void(Range r, ref RandomGen gen)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "gen",
								"type": "RandomGen",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1838,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "randomShuffle",
				"line": 1834,
				"comment": "Shuffles elements of $(D r) using $(D gen) as a shuffler. $(D r) must be\na random-access range with length.  If no RNG is specified, $(D rndGen)\nwill be used.\n\nParams:\n    r = random-access range whose elements are to be shuffled\n    gen = (optional) random number generator to use; if not\n          specified, defaults to $(D rndGen)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RandomGen",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isUniformRNG!RandomGen",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomShuffle",
						"line": 1841,
						"type": "void(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1845,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "randomShuffle",
				"line": 1841,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partialShuffle",
						"line": 1883,
						"type": "void(Range r, in size_t n, ref RandomGen gen)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "gen",
								"type": "RandomGen",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1893,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "partialShuffle",
				"line": 1883,
				"comment": "Partially shuffles the elements of $(D r) such that upon returning $(D r[0..n])\nis a random subset of $(D r) and is randomly ordered.  $(D r[n..r.length])\nwill contain the elements not in $(D r[0..n]).  These will be in an undefined\norder, but will not be random in the sense that their order after\n$(D partialShuffle) returns will not be independent of their order before\n$(D partialShuffle) was called.\n\n$(D r) must be a random-access range with length.  $(D n) must be less than\nor equal to $(D r.length).  If no RNG is specified, $(D rndGen) will be used.\n\nParams:\n    r = random-access range whose elements are to be shuffled\n    n = number of elements of $(D r) to shuffle (counting from the beginning);\n        must be less than $(D r.length)\n    gen = (optional) random number generator to use; if not\n          specified, defaults to $(D rndGen)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RandomGen",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isUniformRNG!RandomGen",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partialShuffle",
						"line": 1896,
						"type": "void(Range r, in size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1900,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "partialShuffle",
				"line": 1896,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1969,
						"type": "size_t(ref Rng rnd, Num[] proportions...)",
						"parameters": [
							{
								"name": "rnd",
								"type": "Rng",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "proportions",
								"type": "Num[]"
							}
						],
						"endline": 1973,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1969,
				"comment": "Rolls a dice with relative probabilities stored in $(D\nproportions). Returns the index in $(D proportions) that was chosen.\n\nParams:\n    rnd = (optional) random number generator to use; if not\n          specified, defaults to $(D rndGen)\n    proportions = forward range or list of individual values\n                  whose elements correspond to the probabilities\n                  with which to choose the corresponding index\n                  value\n\nReturns:\n    Random variate drawn from the index values\n    [0, ... $(D proportions.length) - 1], with the probability\n    of getting an individual index value $(D i) being proportional to\n    $(D proportions[i]).\n\nExample:\n\n----\nauto x = dice(0.5, 0.5);   // x is 0 or 1 in equal proportions\nauto y = dice(50, 50);     // y is 0 or 1 in equal proportions\nauto z = dice(70, 20, 10); // z is 0 70% of the time, 1 20% of the time,\n                           // and 2 10% of the time\n----\n",
				"parameters": [
					{
						"name": "Rng",
						"kind": "type"
					},
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "isNumeric!Num && isForwardRange!Rng",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1976,
						"type": "size_t(ref R rnd, Range proportions)",
						"parameters": [
							{
								"name": "rnd",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "proportions",
								"type": "Range"
							}
						],
						"endline": 1980,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1976,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isNumeric!(ElementType!Range) && !isArray!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1983,
						"type": "size_t(Range proportions)",
						"parameters": [
							{
								"name": "proportions",
								"type": "Range"
							}
						],
						"endline": 1987,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1983,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isNumeric!(ElementType!Range) && !isArray!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dice",
						"line": 1990,
						"type": "size_t(Num[] proportions...)",
						"parameters": [
							{
								"name": "proportions",
								"type": "Num[]"
							}
						],
						"endline": 1994,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "dice",
				"line": 1990,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Num",
						"kind": "type"
					}
				],
				"constraint": "isNumeric!Num",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomCover",
						"line": 2090,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RandomCover",
				"line": 2090,
				"comment": "Covers a given range $(D r) in a random manner, i.e. goes through each\nelement of $(D r) once and only once, just in a random order. $(D r)\nmust be a random-access range with length.\n\nIf no random number generator is passed to $(D randomCover), the\nthread-global RNG rndGen will be used internally.\n\nParams:\n    r = random-access range to cover\n    rng = (optional) random number generator to use;\n          if not specified, defaults to $(D rndGen)\n\nReturns:\n    Range whose elements consist of the elements of $(D r),\n    in random order.  Will be a forward range if both $(D r) and\n    $(D rng) are forward ranges, an input range otherwise.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\nforeach (e; randomCover(a))\n{\n    writeln(e);\n}\n----\n\n$(B WARNING:) If an alternative RNG is desired, it is essential for this\nto be a $(I new) RNG seeded in an unpredictable manner. Passing it a RNG\nused elsewhere in the program will result in unintended correlations,\ndue to the current implementation of RNGs as value types.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\nforeach (e; randomCover(a, Random(unpredictableSeed)))  // correct!\n{\n    writeln(e);\n}\n\nforeach (e; randomCover(a, rndGen))  // DANGEROUS!! rndGen gets copied by value\n{\n    writeln(e);\n}\n\nforeach (e; randomCover(a, rndGen))  // ... so this second random cover\n{                                    // will output the same sequence as\n    writeln(e);                      // the previous one.\n}\n----\n\nThese issues will be resolved in a second-generation std.random that\nre-implements random number generators as reference types.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "v",
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && (isUniformRNG!UniformRNG || is(UniformRNG == void))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomCover",
						"line": 2205,
						"type": "(Range r, auto ref UniformRNG rng)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 2209,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomCover",
				"line": 2205,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isUniformRNG!UniformRNG",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomCover",
						"line": 2212,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 2216,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomCover",
				"line": 2212,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomSample",
						"line": 2346,
						"members": [
							{
								"endchar": 5,
								"name": "empty",
								"line": 2448,
								"comment": "   Range primitives.\n",
								"type": "const @property bool()",
								"endline": 2451,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 2468,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 2482,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 2497,
								"comment": "Ditto\n",
								"type": "@property size_t()",
								"endline": 2500,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "index",
								"line": 2505,
								"comment": "Returns the index of the visited record.\n",
								"type": "@property size_t()",
								"endline": 2512,
								"char": 22,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RandomSample",
				"line": 2346,
				"comment": "Selects a random subsample out of $(D r), containing exactly $(D n)\nelements. The order of elements is the same as in the original\nrange. The total length of $(D r) must be known. If $(D total) is\npassed in, the total number of sample is considered to be $(D\ntotal). Otherwise, $(D RandomSample) uses $(D r.length).\n\nParams:\n    r = range to sample from\n    n = number of elements to include in the sample;\n        must be less than or equal to the total number\n        of elements in $(D r) and/or the parameter\n        $(D total) (if provided)\n    total = (semi-optional) number of elements of $(D r)\n            from which to select the sample (counting from\n            the beginning); must be less than or equal to\n            the total number of elements in $(D r) itself.\n            May be omitted if $(D r) has the $(D .length)\n            property and the sample is to be drawn from\n            all elements of $(D r).\n    rng = (optional) random number generator to use;\n          if not specified, defaults to $(D rndGen)\n\nReturns:\n    Range whose elements consist of a randomly selected subset of\n    the elements of $(D r), in the same order as these elements\n    appear in $(D r) itself.  Will be a forward range if both $(D r)\n    and $(D rng) are forward ranges, an input range otherwise.\n\n$(D RandomSample) implements Jeffrey Scott Vitter's Algorithm D\n(see Vitter $(WEB dx.doi.org/10.1145/358105.893, 1984), $(WEB\ndx.doi.org/10.1145/23002.23003, 1987)), which selects a sample\nof size $(D n) in O(n) steps and requiring O(n) random variates,\nregardless of the size of the data being sampled.  The exception\nto this is if traversing k elements on the input range is itself\nan O(k) operation (e.g. when sampling lines from an input file),\nin which case the sampling calculation will inevitably be of\nO(total).\n\nRandomSample will throw an exception if $(D total) is verifiably\nless than the total number of elements available in the input,\nor if $(D n > total).\n\nIf no random number generator is passed to $(D randomSample), the\nthread-global RNG rndGen will be used internally.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n// Print 5 random elements picked off from a\nforeach (e; randomSample(a, 5))\n{\n    writeln(e);\n}\n----\n\n$(B WARNING:) If an alternative RNG is desired, it is essential for this\nto be a $(I new) RNG seeded in an unpredictable manner. Passing it a RNG\nused elsewhere in the program will result in unintended correlations,\ndue to the current implementation of RNGs as value types.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\nforeach (e; randomSample(a, 5, Random(unpredictableSeed)))  // correct!\n{\n    writeln(e);\n}\n\nforeach (e; randomSample(a, 5, rndGen))  // DANGEROUS!! rndGen gets\n{                                        // copied by value\n    writeln(e);\n}\n\nforeach (e; randomSample(a, 5, rndGen))  // ... so this second random\n{                                        // sample will select the same\n    writeln(e);                          // values as the previous one.\n}\n----\n\nThese issues will be resolved in a second-generation std.random that\nre-implements random number generators as reference types.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"defaultDeco": "v",
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && (isUniformRNG!UniformRNG || is(UniformRNG == void))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2733,
						"type": "(Range r, size_t n, size_t total)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "total",
								"type": "size_t"
							}
						],
						"endline": 2737,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2733,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2740,
						"type": "(Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2744,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2740,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLength!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2747,
						"type": "(Range r, size_t n, size_t total, auto ref UniformRNG rng)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "total",
								"type": "size_t"
							},
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 2751,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2747,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && isUniformRNG!UniformRNG",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomSample",
						"line": 2754,
						"type": "(Range r, size_t n, auto ref UniformRNG rng)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							},
							{
								"name": "rng",
								"type": "UniformRNG",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 2758,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "randomSample",
				"line": 2754,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "UniformRNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLength!Range && isUniformRNG!UniformRNG",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "Facilities for random number generation.\n\nThe new-style generator objects hold their own state so they are\nimmune of threading issues. The generators feature a number of\nwell-known and well-documented methods of generating random\nnumbers. An overall fast and reliable means to generate random numbers\nis the $(D_PARAM Mt19937) generator, which derives its name from\n\"$(LUCKY Mersenne Twister) with a period of 2 to the power of\n19937\". In memory-constrained situations, $(LUCKY linear congruential)\ngenerators such as $(D MinstdRand0) and $(D MinstdRand) might be\nuseful. The standard library provides an alias $(D_PARAM Random) for\nwhichever generator it considers the most fit for the target\nenvironment.\n\nExample:\n\n----\n// Generate a uniformly-distributed integer in the range [0, 14]\nauto i = uniform(0, 15);\n// Generate a uniformly-distributed real in the range [0, 100$(RPAREN)\n// using a specific random generator\nRandom gen;\nauto r = uniform(0.0L, 100.0L, gen);\n----\n\nIn addition to random number generators, this module features\ndistributions, which skew a generator's output statistical\ndistribution in various ways. So far the uniform distribution for\nintegers and real numbers have been implemented.\n\nUpgrading:\n        $(WEB digitalmars.com/d/1.0/phobos/std_random.html#rand Phobos D1 $(D rand())) can\n        be replaced with $(D uniform!uint()).\n\nSource:    $(PHOBOSSRC std/_random.d)\n\nMacros:\n\nWIKI = Phobos/StdRandom\n\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009, Joseph Rushton Wakeling 2012.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\n           Masahiro Nakagawa (Xorshift random generator)\n           $(WEB braingam.es, Joseph Rushton Wakeling) (Algorithm D for random sampling)\nCredits:   The entire random number library architecture is derived from the\n           excellent $(WEB open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf, C++0X)\n           random number facility proposed by Jens Maurer and contributed to by\n           researchers at the Fermi laboratory (excluding Xorshift).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/outbuffer.d",
		"name": "std.outbuffer",
		"members": [
			{
				"name": "OutBuffer",
				"line": 36,
				"comment": " OutBuffer provides a way to build up an array of bytes out\n of raw data. It is useful for things like preparing an\n array of bytes to write out to a file.\n OutBuffer's byte order is the format native to the computer.\n To control the byte order (endianness), use a class derived\n from OutBuffer.\n OutBuffer's internal buffer is allocated with the GC.\n",
				"members": [
					{
						"endchar": 51,
						"name": "toBytes",
						"line": 58,
						"comment": " Convert to array of bytes.\n",
						"deco": "FNaNbNfZAh",
						"endline": 58,
						"char": 13,
						"kind": "function"
					},
					{
						"endchar": 9,
						"in": {
							"endchar": 9,
							"name": "__require",
							"line": 71,
							"deco": "FNaNbNeZv",
							"endline": 71,
							"char": 9,
							"kind": "function"
						},
						"name": "reserve",
						"line": 69,
						"comment": " Preallocate nbytes more to the size of the internal buffer.\n\n This is a\n speed optimization, a good guess at the maximum size of the resulting\n buffer will improve performance by eliminating reallocations and copying.\n",
						"deco": "FNaNbNemZv",
						"parameters": [
							{
								"name": "nbytes",
								"deco": "m"
							}
						],
						"endline": 86,
						"originalType": "pure nothrow @trusted void(size_t nbytes)",
						"char": 10,
						"kind": "function",
						"out": {
							"endchar": 9,
							"name": "__ensure",
							"line": 75,
							"deco": "FNaNbNeZv",
							"endline": 75,
							"char": 9,
							"kind": "function"
						}
					},
					{
						"name": "put",
						"line": 91,
						"comment": " put enables OutBuffer to be used as an OutputRange.\n",
						"char": 5,
						"kind": "alias"
					},
					{
						"endchar": 9,
						"name": "write",
						"line": 97,
						"comment": " Append data to the internal buffer.\n",
						"deco": "FNaNbNfAxhZv",
						"parameters": [
							{
								"name": "bytes",
								"deco": "Axh"
							}
						],
						"endline": 102,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 121,
						"comment": "ditto\n",
						"deco": "FNaNbNfgZv",
						"parameters": [
							{
								"name": "b",
								"deco": "g"
							}
						],
						"endline": 121,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 122,
						"comment": "ditto\n",
						"deco": "FNaNbNfaZv",
						"parameters": [
							{
								"name": "c",
								"deco": "a"
							}
						],
						"endline": 122,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 123,
						"comment": "ditto\n",
						"deco": "FNaNbNfwZv",
						"parameters": [
							{
								"name": "c",
								"deco": "w"
							}
						],
						"endline": 123,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 49,
						"name": "write",
						"line": 132,
						"comment": "ditto\n",
						"deco": "FNaNbNfsZv",
						"parameters": [
							{
								"name": "s",
								"deco": "s"
							}
						],
						"endline": 132,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 45,
						"name": "write",
						"line": 148,
						"comment": "ditto\n",
						"deco": "FNaNbNfiZv",
						"parameters": [
							{
								"name": "i",
								"deco": "i"
							}
						],
						"endline": 148,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 47,
						"name": "write",
						"line": 157,
						"comment": "ditto\n",
						"deco": "FNaNbNflZv",
						"parameters": [
							{
								"name": "l",
								"deco": "l"
							}
						],
						"endline": 157,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fill0",
						"line": 194,
						"comment": " Append nbytes of 0 to the internal buffer.\n",
						"deco": "FNaNbNfmZv",
						"parameters": [
							{
								"name": "nbytes",
								"deco": "m"
							}
						],
						"endline": 199,
						"originalType": "pure nothrow @safe void(size_t nbytes)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"in": {
							"endchar": 5,
							"name": "__require",
							"line": 207,
							"deco": "FNaNbNfZv",
							"endline": 207,
							"char": 5,
							"kind": "function"
						},
						"name": "alignSize",
						"line": 205,
						"comment": " 0-fill to align on power of 2 boundary.\n",
						"deco": "FNaNbNfmZv",
						"parameters": [
							{
								"name": "alignsize",
								"deco": "m"
							}
						],
						"endline": 219,
						"originalType": "pure nothrow @safe void(size_t alignsize)",
						"char": 10,
						"kind": "function",
						"out": {
							"endchar": 5,
							"name": "__ensure",
							"line": 211,
							"deco": "FNaNbNfZv",
							"endline": 211,
							"char": 5,
							"kind": "function"
						}
					},
					{
						"endchar": 5,
						"name": "align2",
						"line": 225,
						"comment": " Optimize common special case alignSize(2)\n",
						"deco": "FNaNbNfZv",
						"endline": 229,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "align4",
						"line": 235,
						"comment": " Optimize common special case alignSize(4)\n",
						"deco": "FNaNbNfZv",
						"endline": 241,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 247,
						"comment": " Convert internal buffer to array of chars.\n",
						"deco": "xFNaNbNfZAya",
						"endline": 251,
						"char": 21,
						"kind": "function",
						"overrides": [
							"object.Object.toString"
						],
						"storageClass": [
							"override"
						]
					},
					{
						"endchar": 5,
						"name": "vprintf",
						"line": 258,
						"comment": " Append output of C's vprintf() to internal buffer.\n",
						"deco": "FNbNeAyaPS4core4stdc6stdarg13__va_list_tagZv",
						"parameters": [
							{
								"name": "format",
								"deco": "Aya"
							},
							{
								"name": "args",
								"deco": "PS4core4stdc6stdarg13__va_list_tag"
							}
						],
						"endline": 307,
						"originalType": "nothrow @trusted void(string format, va_list args)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "printf",
						"line": 313,
						"comment": " Append output of C's printf() to internal buffer.\n",
						"deco": "FNeAyaYv",
						"parameters": [
							{
								"name": "format",
								"deco": "Aya"
							}
						],
						"endline": 319,
						"char": 10,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writef",
								"line": 332,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 336,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writef",
						"line": 332,
						"comment": " Formats and writes its arguments in text format to the OutBuffer.\n\n Params:\n  fmt = format string as described in $(XREF format, formattedWrite)\n  args = arguments to be formatted\n\n See_Also:\n  $(XREF stdio, writef);\n  $(XREF format, formattedWrite);\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL339_2253)\n---\nOutBuffer b = new OutBuffer();\nb.writef(\"a%sb\", 16);\nassert(b.toString() == \"a16b\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL339_2253)\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "writefln",
								"line": 358,
								"type": "void(in Char[] fmt, A args)",
								"parameters": [
									{
										"name": "fmt",
										"type": "Char[]",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "args",
										"type": "A"
									}
								],
								"endline": 363,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "writefln",
						"line": 358,
						"comment": " Formats and writes its arguments in text format to the OutBuffer,\n followed by a newline.\n\n Params:\n  fmt = format string as described in $(XREF format, formattedWrite)\n  args = arguments to be formatted\n\n See_Also:\n  $(XREF stdio, writefln);\n  $(XREF format, formattedWrite);\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL366_2254)\n---\nOutBuffer b = new OutBuffer();\nb.writefln(\"a%sb\", 16);\nassert(b.toString() == \"a16b\\n\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL366_2254)\n",
						"parameters": [
							{
								"name": "Char",
								"kind": "type"
							},
							{
								"name": "A",
								"kind": "tuple"
							}
						],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 9,
						"in": {
							"endchar": 9,
							"name": "__require",
							"line": 380,
							"deco": "FNaNbNfZv",
							"endline": 380,
							"char": 9,
							"kind": "function"
						},
						"name": "spread",
						"line": 378,
						"comment": " At offset index into buffer, create nbytes of space by shifting upwards\n all data past index.\n",
						"deco": "FNaNbNfmmZv",
						"parameters": [
							{
								"name": "index",
								"deco": "m"
							},
							{
								"name": "nbytes",
								"deco": "m"
							}
						],
						"endline": 394,
						"originalType": "pure nothrow @safe void(size_t index, size_t nbytes)",
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "class"
			}
		],
		"comment": "Serialize data to $(D ubyte) arrays.\n\n Macros:\n      WIKI = Phobos/StdOutbuffer\n\n Copyright: Copyright Digital Mars 2000 - 2015.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_outbuffer.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/experimental/logger/package.d",
		"name": "std.experimental.logger",
		"members": [],
		"comment": "Implements logging facilities.\n\nCopyright: Copyright Robert \"burner\" Schadek 2013 --\nLicense: <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors: $(WEB http://www.svs.informatik.uni-oldenburg.de/60865.html, Robert burner Schadek)\n\n$(H3 Basic Logging)\n\nMessage logging is a common approach to expose runtime information of a\nprogram. Logging should be easy, but also flexible and powerful, therefore\n$(D D) provides a standard interface for logging.\n\nThe easiest way to create a log message is to write:\n-------------\nimport std.experimental.logger;\n\nvoid main() {\n    log(\"Hello World\");\n}\n-------------\nThis will print a message to the $(D stderr) device. The message will contain\nthe filename, the linenumber, the name of the surrounding function, the time\nand the message.\n\nMore complex log call can go along the lines like:\n-------------\nlog(\"Logging to the sharedLog with its default LogLevel\");\nlogf(LogLevel.info, 5 < 6, \"%s to the sharedLog with its LogLevel.info\", \"Logging\");\ninfo(\"Logging to the sharedLog with its info LogLevel\");\nwarning(5 < 6, \"Logging to the sharedLog with its LogLevel.warning if 5 is less than 6\");\nerror(\"Logging to the sharedLog with its error LogLevel\");\nerrorf(\"Logging %s the sharedLog %s its error LogLevel\", \"to\", \"with\");\ncritical(\"Logging to the\",\" sharedLog with its error LogLevel\");\nfatal(\"Logging to the sharedLog with its fatal LogLevel\");\n\nauto fLogger = new FileLogger(\"NameOfTheLogFile\");\nfLogger.log(\"Logging to the fileLogger with its default LogLevel\");\nfLogger.info(\"Logging to the fileLogger with its default LogLevel\");\nfLogger.warning(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if 5 is less than 6\");\nfLogger.warningf(5 < 6, \"Logging to the fileLogger with its LogLevel.warning if %s is %s than 6\", 5, \"less\");\nfLogger.critical(\"Logging to the fileLogger with its info LogLevel\");\nfLogger.log(LogLevel.trace, 5 < 6, \"Logging to the fileLogger\",\" with its default LogLevel if 5 is less than 6\");\nfLogger.fatal(\"Logging to the fileLogger with its warning LogLevel\");\n-------------\nAdditionally, this example shows how a new $(D FileLogger) is created.\nIndividual $(D Logger) and the global log functions share commonly named\nfunctions to log data.\n\nThe names of the functions are as follows:\n$(LI $(D log))\n$(LI $(D trace))\n$(LI $(D info))\n$(LI $(D warning))\n$(LI $(D critical))\n$(LI $(D fatal))\nThe default $(D Logger) will by default log to $(D stderr) and has a default\n$(D LogLevel) of $(D LogLevel.all). The default Logger can be accessed by\nusing the property called $(D sharedLog). This property a reference to the\ncurrent default $(D Logger). This reference can be used to assign a new\ndefault $(D Logger).\n-------------\nsharedLog = new FileLogger(\"New_Default_Log_File.log\");\n-------------\n\nAdditional $(D Logger) can be created by creating a new instance of the\nrequired $(D Logger).\n\n$(H3 Logging Fundamentals)\n$(H4 LogLevel)\nThe $(D LogLevel) of an log call can be defined in two ways. The first is by\ncalling $(D log) and passing the $(D LogLevel) explicit as the first argument.\nThe second way of setting the $(D LogLevel) of a\nlog call, is by calling either $(D trace), $(D info), $(D warning),\n$(D critical), or $(D fatal). The log call will than have the respective\n$(D LogLevel). If no $(D LogLevel) is defined the log call will use the\ncurrent $(D LogLevel) of the used $(D Logger). If data is logged with\n$(D LogLevel) $(D fatal) by default an $(D Error) will be thrown.\nThis behaviour can be modified by using the member $(D fatalHandler) to\nassign a custom delegate to handle log call with $(D LogLevel) $(D fatal).\n\n$(H4 Conditional Logging)\nConditional logging can be achieved be passing a $(D bool) as first\nargument to a log function. If conditional logging is used the condition must\nbe $(D true) in order to have the log message logged.\n\nIn order to combine an explicit $(D LogLevel) passing with conditional\nlogging, the $(D LogLevel) has to be passed as first argument followed by the\n$(D bool).\n\n$(H4 Filtering Log Messages)\nMessages are logged if the $(D LogLevel) of the log message is greater than or\nequal to than the $(D LogLevel) of the used $(D Logger) and additionally if the\n$(D LogLevel) of the log message is greater equal to the global $(D LogLevel).\nIf a condition is passed into the log call, this condition must be true.\n\nThe global $(D LogLevel) is accessible by using $(D globalLogLevel).\nTo assign the $(D LogLevel) of a $(D Logger) use the $(D logLevel) property of\nthe logger.\n\n$(H4 Printf Sytle Logging)\nIf $(D printf)-style logging is needed add a $(B f) to the logging call, such as\n$(D myLogger.infof(\"Hello %s\", \"world\");) or $(fatalf(\"errno %d\", 1337))\nThe additional $(B f) enables $(D printf)-style logging for call combinations of\nexplicit $(D LogLevel) and conditional logging functions and methods.\n\n$(H4 Thread Local Redirection)\nCalls to the free standing log functions are not directly forwarded to the\nglobal $(D Logger) $(D sharedLog). Actually, a thread local $(D Logger) of\ntype $(D StdForwardLogger) process the log call and then, by default, forward\nthe created $(D Logger.LogEntry) to the $(D sharedLog) $(D Logger).\nThe thread local $(D Logger) is accessable by the $(D stdThreadLocalLog)\nproperty. This property allows to assign user defined $(D Logger). The default\n$(D LogLevel) of the $(D stdThreadLocalLog) $(D Logger) is $(D LogLevel.all)\nand it will therefore forward all messaged to the $(D sharedLog) $(D Logger).\nThe $(D LogLevel) of the $(D stdThreadLocalLog) can be used to filter log\ncalls before they reach the $(D sharedLog) $(D Logger).\n\n$(H3 User Defined Logger)\nTo customize the $(D Logger) behavior, create a new $(D class) that inherits from\nthe abstract $(D Logger) $(D class), and implements the $(D writeLogMsg)\nmethod.\n-------------\nclass MyCustomLogger : Logger\n{\n    this(string newName, LogLevel lv) @safe\n    {\n        super(newName, lv);\n    }\n\n    override void writeLogMsg(ref LogEntry payload)\n    {\n        // log message in my custom way\n    }\n}\n\nauto logger = new MyCustomLogger();\nlogger.log(\"Awesome log message\");\n-------------\n\nTo gain more precise control over the logging process, additionally to\noverwriting the $(D writeLogMsg) method the methods $(D beginLogMsg),\n$(D logMsgPart) and $(D finishLogMsg) can be overwritten.\n\n$(H3 Compile Time Disabling of $(D Logger))\nIn order to disable logging at compile time, pass $(D StdLoggerDisableLogging) as a\nversion argument to the $(D D) compiler when compiling your program code.\nThis will disable all logging functionality.\nSpecific $(D LogLevel) can be disabled at compile time as well.\nIn order to disable logging with the $(D trace) $(D LogLevel) pass\n$(D StdLoggerDisableTrace) as a version.\nThe following table shows which version statement disables which\n$(D LogLevel).\n$(TABLE\n    $(TR $(TD $(D LogLevel.trace) ) $(TD StdLoggerDisableTrace))\n    $(TR $(TD $(D LogLevel.info) ) $(TD StdLoggerDisableInfo))\n    $(TR $(TD $(D LogLevel.warning) ) $(TD StdLoggerDisableWarning))\n    $(TR $(TD $(D LogLevel.error) ) $(TD StdLoggerDisableError))\n    $(TR $(TD $(D LogLevel.critical) ) $(TD StdLoggerDisableCritical))\n    $(TR $(TD $(D LogLevel.fatal) ) $(TD StdLoggerDisableFatal))\n)\nSuch a version statement will only disable logging in the associated compile\nunit.\n\n$(H3 Provided Logger)\nBy default four $(D Logger) implementations are given. The $(D FileLogger)\nlogs data to files. It can also be used to log to $(D stdout) and $(D stderr)\nas these devices are files as well. A $(D Logger) that logs to $(D stdout) can\ntherefore be created by $(D new FileLogger(stdout)).\nThe $(D MultiLogger) is basically an associative array of $(D string)s to\n$(D Logger). It propagates log calls to its stored $(D Logger). The\n$(D ArrayLogger) contains an array of $(D Logger) and also propagates log\ncalls to its stored $(D Logger). The $(D NullLogger) does not do anything. It\nwill never log a message and will never throw on a log call with $(D LogLevel)\n$(D error).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/uuid.d",
		"name": "std.uuid",
		"members": [
			{
				"name": "UUID",
				"line": 127,
				"comment": "\n",
				"members": [
					{
						"members": [
							{
								"name": "ncs",
								"line": 187,
								"value": "0",
								"comment": "NCS backward compatibility\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "rfc4122",
								"line": 188,
								"value": "1",
								"comment": "Defined in RFC 4122 document\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "microsoft",
								"line": 189,
								"value": "2",
								"comment": "Microsoft Corporation backward compatibility\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "future",
								"line": 190,
								"value": "3",
								"comment": "Reserved for future use\n",
								"char": 13,
								"kind": "enum member"
							}
						],
						"name": "Variant",
						"line": 185,
						"comment": " RFC 4122 defines different internal data layouts for UUIDs. These are\n the UUID formats supported by this module. It's\n possible to read, compare and use all these Variants, but\n UUIDs generated by this module will always be in rfc4122 format.\n\n Note: Do not confuse this with $(XREF _variant, _Variant).\n",
						"baseDeco": "i",
						"char": 9,
						"kind": "enum"
					},
					{
						"members": [
							{
								"name": "unknown",
								"line": 205,
								"value": "-1",
								"comment": "Unknown version\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "timeBased",
								"line": 207,
								"value": "1",
								"comment": "Version 1\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "dceSecurity",
								"line": 209,
								"value": "2",
								"comment": "Version 2\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "nameBasedMD5",
								"line": 211,
								"value": "3",
								"comment": "Version 3 (Name based + MD5)\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "randomNumberBased",
								"line": 213,
								"value": "4",
								"comment": "Version 4 (Random)\n",
								"char": 13,
								"kind": "enum member"
							},
							{
								"name": "nameBasedSHA1",
								"line": 215,
								"value": "5",
								"comment": "Version 5 (Name based + SHA-1)\n",
								"char": 13,
								"kind": "enum member"
							}
						],
						"name": "Version",
						"line": 202,
						"comment": " RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n\n Note:\n All of these UUID versions can be read and processed by\n $(D std.uuid), but only version 3, 4 and 5 UUIDs can be generated.\n",
						"baseDeco": "i",
						"char": 9,
						"kind": "enum"
					},
					{
						"offset": 0,
						"name": "data",
						"line": 236,
						"comment": " It is sometimes useful to get or set the 16 bytes of a UUID\n directly.\n\n Note:\n UUID uses a 16-ubyte representation for the UUID data.\n RFC 4122 defines a UUID as a special structure in big-endian\n format. These 16-ubytes always equal the big-endian structure\n defined in RFC 4122.\n\n Examples:\n -----------------------------------------------\n auto rawData = uuid.data; //get data\n rawData[0] = 1; //modify\n uuid.data = rawData; //set data\n uuid.data[1] = 2; //modify directly\n -----------------------------------------------\n",
						"deco": "G16h",
						"char": 19,
						"kind": "variable"
					},
					{
						"endchar": 9,
						"name": "this",
						"line": 265,
						"comment": " Construct a UUID struct from the 16 byte representation\n of a UUID.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL276_2291)\n---\nenum ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\nauto uuid = UUID(data);\nenum ctfe = UUID(data);\nassert(uuid.data == data);\nassert(ctfe.data == data);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL276_2291)\n",
						"deco": "FNaNbNcNiNfKxG16hZS3std4uuid4UUID",
						"parameters": [
							{
								"name": "uuidData",
								"storageClass": [
									"ref"
								],
								"deco": "xG16h"
							}
						],
						"endline": 268,
						"originalType": "pure nothrow @nogc ref @safe (ref ubyte[16] uuidData)",
						"char": 34,
						"kind": "constructor"
					},
					{
						"endchar": 9,
						"name": "this",
						"line": 270,
						"comment": "ditto\n",
						"deco": "FNaNbNcNiNfxG16hZS3std4uuid4UUID",
						"parameters": [
							{
								"name": "uuidData",
								"deco": "xG16h"
							}
						],
						"endline": 273,
						"originalType": "pure nothrow @nogc ref @safe (in ubyte[16] uuidData)",
						"char": 34,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 290,
								"type": "pure @safe (T uuidData)",
								"parameters": [
									{
										"name": "uuidData",
										"type": "T"
									}
								],
								"endline": 299,
								"char": 20,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 290,
						"comment": " Construct a UUID struct from the 16 byte representation\n of a UUID. Variadic constructor to allow a simpler syntax, see examples.\n You need to pass exactly 16 ubytes.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL302_2292)\n---\nauto tmp = UUID(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);\nassert(tmp.data == cast(ubyte[16])[0,1,2,3,4,5,6,7,8,9,10,11,\n    12,13,14,15]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL302_2292)\n",
						"parameters": [
							{
								"name": "T",
								"kind": "tuple"
							}
						],
						"constraint": "uuidData.length == 16 && allSatisfy!(isIntegral, T)",
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 9,
								"name": "this",
								"line": 359,
								"type": "(in T[] uuid)",
								"parameters": [
									{
										"name": "uuid",
										"type": "T[]",
										"storageClass": [
											"in"
										]
									}
								],
								"endline": 416,
								"char": 9,
								"kind": "constructor"
							}
						],
						"name": "this",
						"line": 359,
						"comment": " <a name=\"UUID(string)\"></a>\n Parse a UUID from its canonical string form. An UUID in its\n canonical form looks like this: 8ab3060e-2cba-4f23-b74c-b52db3bdfb46\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at\n compile time.\n\n Note:\n This is a strict parser. It only accepts the pattern above.\n It doesn't support any leading or trailing characters. It only\n accepts characters used for hex numbers and the string must have\n hyphens exactly like above.\n\n For a less strict parser, see $(LREF parseUUID)\n\n Examples:\n -------------------------\n id = UUID(\"8AB3060E-2cba-4f23-b74c-b52db3bdfb46\");\n assert(id.data == [138, 179, 6, 14, 44, 186, 79, 35, 183, 76,\n    181, 45, 179, 189, 251, 70]);\n assert(id.toString() == \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n\n //Can also be used in CTFE, for example as UUID literals:\n enum ctfeID = UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n //here parsing is done at compile time, no runtime overhead!\n -------------------------\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"constraint": "isSomeChar!(Unqual!T)",
						"char": 9,
						"kind": "template"
					},
					{
						"endchar": 9,
						"name": "empty",
						"line": 480,
						"comment": " Returns true if and only if the UUID is equal\n to {00000000-0000-0000-0000-000000000000}\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL495_2295)\n---\nUUID id;\nassert(id.empty);\nid = UUID(\"00000000-0000-0000-0000-000000000001\");\nassert(!id.empty);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL495_2295)\n",
						"deco": "xFNaNbNdNiNeZb",
						"endline": 492,
						"char": 52,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "variant",
						"line": 542,
						"comment": " RFC 4122 defines different internal data layouts for UUIDs.\n Returns the format used by this UUID.\n\n Note: Do not confuse this with $(XREF _variant, _Variant).\n The type of this property is $(MYREF3 std.uuid.UUID.Variant, _Variant).\n\n See_Also:\n $(MYREF3 UUID.Variant, Variant)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL562_2297)\n---\nassert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").variant\n   == UUID.Variant.rfc4122);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL562_2297)\n",
						"deco": "xFNaNbNdNiNfZE3std4uuid4UUID7Variant",
						"endline": 559,
						"char": 52,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "uuidVersion",
						"line": 602,
						"comment": " RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n Returns the version used by this UUID.\n\n See_Also:\n $(MYREF3 UUID.Version, Version)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL622_2299)\n---\nassert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").uuidVersion\n    == UUID.Version.randomNumberBased);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL622_2299)\n",
						"deco": "xFNaNbNdNiNfZE3std4uuid4UUID7Version",
						"endline": 619,
						"char": 52,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "swap",
						"line": 657,
						"comment": " Swap the data of this UUID with the data of rhs.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL665_2301)\n---\nimmutable ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\nUUID u1;\nUUID u2 = UUID(data);\nu1.swap(u2);\n\nassert(u1 == UUID(data));\nassert(u2 == UUID.init);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL665_2301)\n",
						"deco": "FNaNbNiNfKS3std4uuid4UUIDZv",
						"parameters": [
							{
								"name": "rhs",
								"storageClass": [
									"ref"
								],
								"deco": "S3std4uuid4UUID"
							}
						],
						"endline": 662,
						"char": 39,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 680,
						"comment": " All of the standard numeric operators are defined for\n the UUID struct.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL686_2302)\n---\n//compare UUIDs\nassert(UUID(\"00000000-0000-0000-0000-000000000000\") == UUID.init);\n\n//UUIDs in associative arrays:\nint[UUID] test = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\") : 1,\n    UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\") : 2,\n    UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\") : 3];\n\nassert(test[UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")] == 3);\n\n//UUIDS can be sorted:\nimport std.algorithm;\nUUID[] ids = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\"),\n              UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\"),\n              UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")];\nsort(ids);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL686_2302)\n",
						"deco": "xFNaNbNiNfxS3std4uuid4UUIDZb",
						"parameters": [
							{
								"name": "s",
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 683,
						"originalType": "const pure nothrow @nogc @safe bool(in UUID s)",
						"char": 39,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opEquals",
						"line": 709,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfKxS3std4uuid4UUIDZb",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 712,
						"originalType": "const pure nothrow @nogc @safe bool(ref UUID s)",
						"char": 39,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 717,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfxS3std4uuid4UUIDZi",
						"parameters": [
							{
								"name": "s",
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 721,
						"originalType": "const pure nothrow @nogc @safe int(in UUID s)",
						"char": 38,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "opCmp",
						"line": 726,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfKxS3std4uuid4UUIDZi",
						"parameters": [
							{
								"name": "s",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std4uuid4UUID"
							}
						],
						"endline": 730,
						"originalType": "const pure nothrow @nogc @safe int(ref UUID s)",
						"char": 38,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "toHash",
						"line": 735,
						"comment": " ditto\n",
						"deco": "xFNaNbNiNfZm",
						"endline": 742,
						"originalType": "const pure nothrow @nogc @safe size_t()",
						"char": 41,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 799,
						"comment": " Return the UUID as a string in the canonical form.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL811_2304)\n---\nimmutable str = \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\";\nauto id = UUID(str);\nassert(id.toString() == str);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL811_2304)\n",
						"deco": "xFMDFAxaZvZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							}
						],
						"endline": 802,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 9,
						"name": "toString",
						"line": 805,
						"comment": "ditto\n",
						"deco": "xFNaNbNfZAya",
						"endline": 808,
						"char": 35,
						"kind": "function"
					}
				],
				"char": 8,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "md5UUID",
				"line": 868,
				"comment": " This function generates a name based (Version 3) UUID from a namespace UUID and a name.\n If no namespace UUID was passed, the empty UUID $(D UUID.init) is used.\n\n Note:\n The default namespaces ($(LREF dnsNamespace), ...) defined by\n this module should be used when appropriate.\n\n RFC 4122 recommends to use Version 5 UUIDs (SHA-1) instead of Version 3\n UUIDs (MD5) for new applications.\n\n CTFE:\n CTFE is not supported.\n\n Note:\n RFC 4122 isn't very clear on how UUIDs should be generated from names.\n It is possible that different implementations return different UUIDs\n for the same input, so be warned. The implementation for UTF-8 strings\n and byte arrays used by $(D std.uuid) is compatible with Boost's implementation.\n $(D std.uuid) guarantees that the same input to this function will generate\n the same output at any time, on any system (this especially means endianness\n doesn't matter).\n\n Note:\n This function does not provide overloads for wstring and dstring, as\n there's no clear answer on how that should be implemented. It could be\n argued, that string, wstring and dstring input should have the same output,\n but that wouldn't be compatible with Boost, which generates different output\n for strings and wstrings. It's always possible to pass wstrings and dstrings\n by using the ubyte[] function overload (but be aware of endianness issues!).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL908_2306)\n---\n//Use default UUID.init namespace\nauto simpleID = md5UUID(\"test.uuid.any.string\");\n\n//use a name-based id as namespace\nauto namespace = md5UUID(\"my.app\");\nauto id = md5UUID(\"some-description\", namespace);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL908_2306)\n",
				"deco": "FNaNbNiNfxAaxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
					}
				],
				"endline": 871,
				"originalType": "pure nothrow @nogc @safe UUID(const(char[]) name, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "md5UUID",
				"line": 876,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfxAhxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "data",
						"deco": "xAh"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
					}
				],
				"endline": 905,
				"originalType": "pure nothrow @nogc @safe UUID(const(ubyte[]) data, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sha1UUID",
				"line": 981,
				"comment": " This function generates a name based (Version 5) UUID from a namespace\n UUID and a name.\n If no namespace UUID was passed, the empty UUID $(D UUID.init) is used.\n\n Note:\n The default namespaces ($(LREF dnsNamespace), ...) defined by\n this module should be used when appropriate.\n\n CTFE:\n CTFE is not supported.\n\n Note:\n RFC 4122 isn't very clear on how UUIDs should be generated from names.\n It is possible that different implementations return different UUIDs\n for the same input, so be warned. The implementation for UTF-8 strings\n and byte arrays used by $(D std.uuid) is compatible with Boost's implementation.\n $(D std.uuid) guarantees that the same input to this function will generate\n the same output at any time, on any system (this especially means endianness\n doesn't matter).\n\n Note:\n This function does not provide overloads for wstring and dstring, as\n there's no clear answer on how that should be implemented. It could be\n argued, that string, wstring and dstring input should have the same output,\n but that wouldn't be compatible with Boost, which generates different output\n for strings and wstrings. It's always possible to pass wstrings and dstrings\n by using the ubyte[] function overload (but be aware of endianness issues!).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1022_2308)\n---\n//Use default UUID.init namespace\nauto simpleID = sha1UUID(\"test.uuid.any.string\");\n\n//use a name-based id as namespace\nauto namespace = sha1UUID(\"my.app\");\nauto id = sha1UUID(\"some-description\", namespace);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1022_2308)\n",
				"deco": "FNaNbNiNfxAaxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "name",
						"deco": "xAa"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
					}
				],
				"endline": 984,
				"originalType": "pure nothrow @nogc @safe UUID(in char[] name, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "sha1UUID",
				"line": 989,
				"comment": " ditto\n",
				"deco": "FNaNbNiNfxAhxS3std4uuid4UUIDZS3std4uuid4UUID",
				"parameters": [
					{
						"name": "data",
						"deco": "xAh"
					},
					{
						"name": "namespace",
						"deco": "xS3std4uuid4UUID",
						"default": "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
					}
				],
				"endline": 1019,
				"originalType": "pure nothrow @nogc @safe UUID(in ubyte[] data, const UUID namespace = UUID.init)",
				"char": 31,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "randomUUID",
				"line": 1069,
				"comment": " This function generates a random number based UUID from a random\n number generator.\n\n CTFE:\n This function is not supported at compile time.\n\n",
				"deco": "FNfZS3std4uuid4UUID",
				"endline": 1073,
				"char": 12,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "randomUUID",
						"line": 1083,
						"type": "UUID(ref RNG randomGen)",
						"parameters": [
							{
								"name": "randomGen",
								"type": "RNG",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1112,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "randomUUID",
				"line": 1083,
				"comment": " ditto\n\n Params:\n      randomGen = uniform RNG\n See_Also: $(XREF random, isUniformRNG)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1115_2310)\n---\nimport std.random : Xorshift192, unpredictableSeed;\n\n//simple call\nauto uuid = randomUUID();\n\n//provide a custom RNG. Must be seeded manually.\nXorshift192 gen;\n\ngen.seed(unpredictableSeed);\nauto uuid3 = randomUUID(gen);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1115_2310)\n",
				"parameters": [
					{
						"name": "RNG",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RNG && isIntegral!(ElementType!RNG)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseUUID",
						"line": 1187,
						"type": "UUID(T uuidString)",
						"parameters": [
							{
								"name": "uuidString",
								"type": "T"
							}
						],
						"endline": 1190,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "parseUUID",
				"line": 1187,
				"comment": " This is a less strict parser compared to the parser used in the\n UUID constructor. It enforces the following rules:\n\n $(UL\n   $(LI hex numbers are always two hexdigits([0-9a-fA-F]))\n   $(LI there must be exactly 16 such pairs in the input, not less, not more)\n   $(LI there can be exactly one dash between two hex-pairs, but not more)\n   $(LI there can be multiple characters enclosing the 16 hex pairs,\n     as long as these characters do not contain [0-9a-fA-F])\n )\n\n Note:\n Like most parsers, it consumes its argument. This means:\n -------------------------\n string s = \"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46\";\n parseUUID(s);\n assert(s == \"\");\n -------------------------\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at compile time.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1336_2313)\n---\nauto id = parseUUID(\"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46\");\n//no dashes\nid = parseUUID(\"8ab3060e2cba4f23b74cb52db3bdfb46\");\n//dashes at different positions\nid = parseUUID(\"8a-b3-06-0e2cba4f23b74c-b52db3bdfb-46\");\n//leading / trailing characters\nid = parseUUID(\"{8ab3060e-2cba-4f23-b74c-b52db3bdfb46}\");\n//unicode\nid = parseUUID(\"Ã¼8ab3060e2cba4f23b74cb52db3bdfb46Ã¼\");\n//multiple trailing/leading characters\nid = parseUUID(\"///8ab3060e2cba4f23b74cb52db3bdfb46||\");\n\n//Can also be used in CTFE, for example as UUID literals:\nenum ctfeID = parseUUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n//here parsing is done at compile time, no runtime overhead!\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1336_2313)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "parseUUID",
						"line": 1193,
						"type": "UUID(ref Range uuidRange)",
						"parameters": [
							{
								"name": "uuidRange",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1333,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "parseUUID",
				"line": 1193,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(Unqual!(ElementType!Range) == dchar)",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "dnsNamespace",
				"line": 1498,
				"comment": " Default namespace from RFC 4122\n\n Name string is a fully-qualified domain name\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)16u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "urlNamespace",
				"line": 1505,
				"comment": " Default namespace from RFC 4122\n\n Name string is a URL\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)17u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "oidNamespace",
				"line": 1512,
				"comment": " Default namespace from RFC 4122\n\n Name string is an ISO OID\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)18u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "x500Namespace",
				"line": 1519,
				"comment": " Default namespace from RFC 4122\n\n Name string is an X.500 DN (in DER or a text output format)\n",
				"deco": "S3std4uuid4UUID",
				"init": "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)20u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "uuidRegex",
				"line": 1524,
				"comment": " Regex string to extract UUIDs from text.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1528_2315)\n---\nimport std.algorithm;\nimport std.regex;\n\nstring test = \"Lorem ipsum dolor sit amet, consetetur \"~\n\"6ba7b814-9dad-11d1-80b4-00c04fd430c8 sadipscing \\n\"~\n\"elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore \\r\\n\"~\n\"magna aliquyam erat, sed diam voluptua. \"~\n\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46 At vero eos et accusam et \"~\n\"justo duo dolores et ea rebum.\";\n\nauto r = regex(uuidRegex, \"g\");\nUUID[] found;\nforeach(c; match(test, r))\n{\n    found ~= UUID(c.hit);\n}\nassert(found == [\n    UUID(\"6ba7b814-9dad-11d1-80b4-00c04fd430c8\"),\n    UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\"),\n]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1528_2315)\n",
				"deco": "Aya",
				"init": "\"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"members": [
							{
								"name": "unknown",
								"line": 1563,
								"value": "0",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "tooLittle",
								"line": 1564,
								"value": "1",
								"comment": "The passed in input was correct, but more input was expected.\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "tooMuch",
								"line": 1565,
								"value": "2",
								"comment": "The input data is too long (There's no guarantee the first part of the data is valid)\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "invalidChar",
								"line": 1566,
								"value": "3",
								"comment": "Encountered an invalid character\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Reason",
						"line": 1561,
						"comment": " The reason why parsing the UUID string failed (if known)\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"offset": 72,
						"name": "reason",
						"line": 1570,
						"comment": "ditto\n",
						"deco": "E3std4uuid20UUIDParsingException6Reason",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "input",
						"line": 1572,
						"comment": "The original input string which should have been parsed.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "position",
						"line": 1574,
						"comment": "The position in the input string where the error occurred.\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					}
				],
				"name": "UUIDParsingException",
				"line": 1556,
				"comment": " This exception is thrown if an error occurs when parsing a UUID\n from a string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1592_2316)\n---\nauto ex = new UUIDParsingException(\"foo\", 10, UUIDParsingException.Reason.tooMuch);\nassert(ex.input == \"foo\");\nassert(ex.position == 10);\nassert(ex.reason == UUIDParsingException.Reason.tooMuch);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1592_2316)\n",
				"base": "object.Exception",
				"char": 8,
				"kind": "class"
			}
		],
		"comment": " A $(LINK2 http://en.wikipedia.org/wiki/Universally_unique_identifier, UUID), or\n $(LINK2 http://en.wikipedia.org/wiki/Universally_unique_identifier, Universally unique identifier),\n is intended to uniquely identify information in a distributed environment\n without significant central coordination. It can be\n used to tag objects with very short lifetimes, or to reliably identify very\n persistent objects across a network.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Parsing UUIDs)\n     $(TD $(MYREF parseUUID)\n          $(MYREF UUID)\n          $(MYREF UUIDParsingException)\n          $(MYREF uuidRegex)\n          )\n     )\n$(TR $(TDNW Generating UUIDs)\n     $(TD $(MYREF sha1UUID)\n          $(MYREF randomUUID)\n          $(MYREF md5UUID)\n          )\n     )\n$(TR $(TDNW Using UUIDs)\n     $(TD $(MYREF2 UUID.uuidVersion, uuidVersion)\n          $(MYREF2 UUID.variant, variant)\n          $(MYREF2 UUID.toString, toString)\n          $(MYREF2 UUID.data, data)\n          $(MYREF2 UUID.swap, swap)\n          $(MYREF2 UUID.opEquals, opEquals)\n          $(MYREF2 UUID.opCmp, opCmp)\n          $(MYREF2 UUID.toHash, toHash)\n          )\n     )\n$(TR $(TDNW UUID namespaces)\n     $(TD $(MYREF dnsNamespace)\n          $(MYREF urlNamespace)\n          $(MYREF oidNamespace)\n          $(MYREF x500Namespace)\n          )\n     )\n)\n)\n\n UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify\n rows or records in order to ensure that they are unique across different\n databases, or for publication/subscription services. Network messages may be\n identified with a UUID to ensure that different parts of a message are put back together\n again. Distributed computing may use UUIDs to identify a remote procedure call.\n Transactions and classes involved in serialization may be identified by UUIDs.\n Microsoft's component object model (COM) uses UUIDs to distinguish different software\n component interfaces. UUIDs are inserted into documents from Microsoft Office programs.\n UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are\n also a basis for OIDs (object identifiers), and URNs (uniform resource name).\n\n An attractive feature of UUIDs when compared to alternatives is their relative small size,\n of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require\n a centralized authority.\n\n When UUIDs are generated by one of the defined mechanisms, they are either guaranteed\n to be unique, different from all other generated UUIDs (that is, it has never been\n generated before and it will never be generated again), or it is extremely likely\n to be unique (depending on the mechanism).\n\n For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly\n initialized. An UUID is empty if $(MYREF3 UUID.empty, empty) is true. Empty UUIDs are equal to\n $(D UUID.init), which is a UUID with all 16 bytes set to 0.\n Use UUID's constructors or the UUID generator functions to get an initialized UUID.\n\n This is a port of $(LINK2 http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html,\n boost._uuid) from the Boost project with some minor additions and API\n changes for a more D-like API.\n\n Examples:\n ------------------------\n UUID[] ids;\n ids ~= randomUUID();\n ids ~= md5UUID(\"test.name.123\");\n ids ~= sha1UUID(\"test.name.123\");\n\n foreach(entry; ids)\n {\n     assert(entry.variant == UUID.Variant.rfc4122);\n }\n\n assert(ids[0].uuidVersion == UUID.Version.randomNumberBased);\n assert(ids[1].toString() == \"22390768-cced-325f-8f0f-cfeaa19d0ccd\");\n assert(ids[1].data == [34, 57, 7, 104, 204, 237, 50, 95, 143, 15, 207,\n     234, 161, 157, 12, 205]);\n\n UUID id;\n assert(id.empty);\n\n ------------------------\n Standards:\n $(LINK2 http://www.ietf.org/rfc/rfc4122.txt, RFC 4122)\n\n See_Also:\n $(LINK http://en.wikipedia.org/wiki/Universally_unique_identifier)\n\n Copyright: Copyright Johannes Pfau 2011 - .\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Johannes Pfau\n Source:    $(PHOBOSSRC std/_uuid.d)\n\n Macros:\n MYREF2 = <a href=\"#$2\">$(TT $1)</a>&nbsp;\n MYREF3 = <a href=\"#$2\">$(D $1)</a>\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/base64.d",
		"name": "std.base64",
		"members": [
			{
				"name": "Base64",
				"line": 54,
				"comment": " The Base64\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Base64URL",
				"line": 60,
				"comment": " The \"URL and Filename safe\" Base64\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "NoPadding",
						"line": 77,
						"comment": "represents no-padding encoding\n",
						"init": "'\\x00'",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					},
					{
						"endchar": 5,
						"name": "encodeLength",
						"line": 113,
						"comment": " Calculates the minimum length for encoding.\n\n Params:\n  sourceLength = the length of source array.\n\n Returns:\n  the calculated length using $(D_PARAM sourceLength).\n",
						"type": "pure nothrow @safe size_t(in size_t sourceLength)",
						"parameters": [
							{
								"name": "sourceLength",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 119,
						"char": 25,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 136,
								"type": "pure @trusted char[](in R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 188,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 136,
						"comment": " Encodes $(D_PARAM source) into $(D_PARAM buffer).\n\n Params:\n  source = an $(D InputRange) to encode.\n  buffer = a buffer to store encoded result.\n\n Returns:\n  the encoded string that slices buffer.\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : ubyte) && is(R2 == char[])",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 197,
								"type": "char[](R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 260,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 197,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : ubyte) && hasLength!R1 && is(R2 == char[])",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 276,
								"type": "size_t(in R1 source, R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "range",
										"type": "R2"
									}
								],
								"endline": 330,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 276,
						"comment": " Encodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to encode.\n  range  = an $(D OutputRange) to put encoded result.\n\n Returns:\n  the number of calling put.\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : ubyte) && !is(R2 == char[])",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 339,
								"type": "size_t(R1 source, R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "range",
										"type": "R2"
									}
								],
								"endline": 404,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 339,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : ubyte) && hasLength!R1 && !is(R2 == char[]) && isOutputRange!(R2, char)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 413,
								"type": "pure @safe char[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 416,
								"char": 17,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 413,
						"comment": " Encodes $(D_PARAM source) to new buffer.\n\n Shortcut to encode(source, buffer) function.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isArray!Range && is(ElementType!Range : ubyte)",
						"char": 17,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encode",
								"line": 422,
								"type": "char[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 426,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "encode",
						"line": 422,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "!isArray!Range && isInputRange!Range && is(ElementType!Range : ubyte) && hasLength!Range",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Encoder",
								"line": 432,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 455,
										"comment": " Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n",
										"type": "@property @trusted bool()",
										"endline": 458,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 468,
										"comment": " Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the encoded string.\n",
										"type": "nothrow @property @safe char[]()",
										"endline": 471,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 480,
										"comment": " Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n",
										"type": "void()",
										"endline": 494,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Encoder",
						"line": 432,
						"comment": " Range that encodes chunk data at a time.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && (is(ElementType!Range : const(ubyte)[]) || is(ElementType!Range : const(char)[]))",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Encoder",
								"line": 534,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 563,
										"comment": " Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n",
										"type": "const nothrow @property @safe bool()",
										"endline": 569,
										"char": 22,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 579,
										"comment": " Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the encoded character.\n",
										"type": "nothrow @property @safe ubyte()",
										"endline": 582,
										"char": 23,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 591,
										"comment": " Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n",
										"type": "void()",
										"endline": 641,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Encoder",
						"line": 534,
						"comment": " Range that encodes single character at a time.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(ElementType!Range : ubyte)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "encoder",
								"line": 699,
								"type": "Encoder!Range(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 702,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "encoder",
						"line": 699,
						"comment": " Iterates through an $(D InputRange) at a time by using $(D Encoder).\n\n Default $(D Encoder) encodes chunk data.\n\n Example:\n -----\n File f = File(\"text.txt\", \"r\");\n scope(exit) f.close();\n\n uint line = 0;\n foreach (encoded; Base64.encoder(f.byLine()))\n {\n     writeln(++line, \". \", encoded);\n }\n -----\n\n In addition, You can use $(D Encoder) that returns encoded single character.\n This $(D Encoder) performs Range-based and lazy encoding.\n\n Example:\n -----\n ubyte[] data = cast(ubyte[]) \"0123456789\";\n\n // The ElementType of data is not aggregation type\n foreach (encoded; Base64.encoder(data))\n {\n     writeln(encoded);\n }\n -----\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Encoder) object instantiated and initialized according to the arguments.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range",
						"char": 21,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "decodeLength",
						"line": 735,
						"comment": " Calculates the minimum length for decoding.\n\n Params:\n  sourceLength = the length of source array.\n\n Returns:\n  calculated length using $(D_PARAM sourceLength).\n",
						"type": "pure nothrow @safe size_t(in size_t sourceLength)",
						"parameters": [
							{
								"name": "sourceLength",
								"type": "size_t",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 741,
						"char": 25,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 780,
								"type": "pure @trusted ubyte[](in R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 837,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 780,
						"comment": " Decodes $(D_PARAM source) into $(D_PARAM buffer).\n\n Params:\n  source = an $(D InputRange) to decode.\n  buffer = a buffer to store decoded result.\n\n Returns:\n  the decoded string that slices buffer.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : dchar) && is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 846,
								"type": "ubyte[](R1 source, R2 buffer)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "buffer",
										"type": "R2"
									}
								],
								"endline": 911,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 846,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : dchar) && hasLength!R1 && is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 930,
								"type": "size_t(in R1 source, R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1",
										"storageClass": [
											"in"
										]
									},
									{
										"name": "range",
										"type": "R2"
									}
								],
								"endline": 989,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 930,
						"comment": " Decodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to decode.\n  range  = an $(D OutputRange) to put decoded result\n\n Returns:\n  the number of calling put.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "isArray!R1 && is(ElementType!R1 : dchar) && !is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 998,
								"type": "size_t(R1 source, R2 range)",
								"parameters": [
									{
										"name": "source",
										"type": "R1"
									},
									{
										"name": "range",
										"type": "R2"
									}
								],
								"endline": 1064,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 998,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "R1",
								"kind": "type"
							},
							{
								"name": "R2",
								"kind": "type"
							}
						],
						"constraint": "!isArray!R1 && isInputRange!R1 && is(ElementType!R1 : dchar) && hasLength!R1 && !is(R2 == ubyte[]) && isOutputRange!(R2, ubyte)",
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 1073,
								"type": "pure @safe ubyte[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 1076,
								"char": 18,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 1073,
						"comment": " Decodes $(D_PARAM source) into new buffer.\n\n Shortcut to decode(source, buffer) function.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isArray!Range && is(ElementType!Range : dchar)",
						"char": 18,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decode",
								"line": 1082,
								"type": "ubyte[](Range source)",
								"parameters": [
									{
										"name": "source",
										"type": "Range"
									}
								],
								"endline": 1086,
								"char": 13,
								"kind": "function"
							}
						],
						"name": "decode",
						"line": 1082,
						"comment": " ditto\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "!isArray!Range && isInputRange!Range && is(ElementType!Range : dchar) && hasLength!Range",
						"char": 13,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Decoder",
								"line": 1092,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 1115,
										"comment": " Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n",
										"type": "@property @trusted bool()",
										"endline": 1118,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1128,
										"comment": " Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the decoded result.\n",
										"type": "nothrow @property @safe ubyte[]()",
										"endline": 1131,
										"char": 25,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 1140,
										"comment": " Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n",
										"type": "void()",
										"endline": 1151,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Decoder",
						"line": 1092,
						"comment": " Range that decodes chunk data at a time.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && (is(ElementType!Range : const(char)[]) || is(ElementType!Range : const(ubyte)[]))",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"name": "Decoder",
								"line": 1204,
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 1236,
										"comment": " Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n",
										"type": "const nothrow @property @safe bool()",
										"endline": 1239,
										"char": 22,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1249,
										"comment": " Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the decoded result.\n",
										"type": "nothrow @property @safe ubyte()",
										"endline": 1252,
										"char": 23,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 1261,
										"comment": " Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n",
										"type": "void()",
										"endline": 1320,
										"char": 14,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							}
						],
						"name": "Decoder",
						"line": 1204,
						"comment": " Range that decodes single character at a time.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(ElementType!Range : char)",
						"char": 5,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "decoder",
								"line": 1376,
								"type": "Decoder!Range(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 1379,
								"char": 21,
								"kind": "function"
							}
						],
						"name": "decoder",
						"line": 1376,
						"comment": " Iterates through an $(D InputRange) at a time by using $(D Decoder).\n\n Default $(D Decoder) decodes chunk data.\n\n Example:\n -----\n foreach (decoded; Base64.decoder(stdin.byLine()))\n {\n     writeln(decoded);\n }\n -----\n\n In addition, You can use $(D Decoder) that returns decoded single character.\n This $(D Decoder) performs Range-based and lazy decoding.\n\n Example:\n -----\n auto encoded = Base64.encoder(cast(ubyte[])\"0123456789\");\n foreach (n; map!q{a - '0'}(Base64.decoder(encoded)))\n {\n     writeln(n);\n }\n -----\n\n NOTE:\n  If you use $(D ByChunk), chunk-size should be the multiple of 4.\n  $(D Decoder) can't judge a encode-boundary.\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Decoder) object instantiated and initialized according to the arguments.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range",
						"char": 21,
						"kind": "template"
					}
				],
				"name": "Base64Impl",
				"line": 75,
				"comment": " Core implementation for Base64 format.\n\n Example:\n -----\n alias Base64   = Base64Impl!('+', '/');                    // The Base64 format(Already defined).\n alias Base64Re = Base64Impl!('!', '=', Base64.NoPadding);  // non-standard Base64 format for Regular expression\n -----\n\n NOTE:\n  encoded-string doesn't have padding character if set Padding parameter to NoPadding.\n",
				"parameters": [
					{
						"name": "Map62th",
						"deco": "a",
						"kind": "value"
					},
					{
						"name": "Map63th",
						"deco": "a",
						"kind": "value"
					},
					{
						"name": "Padding",
						"defaultValue": "'='",
						"deco": "a",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Base64Exception",
				"line": 1411,
				"comment": " Exception thrown on Base64 errors.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			}
		],
		"comment": " Encoding / Decoding Base64 format.\n\n Implemented according to $(WEB tools.ietf.org/html/rfc4648,\n RFC 4648 - The Base16, Base32, and Base64 Data Encodings).\n\n Example:\n -----\n ubyte[] data = [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e];\n\n const(char)[] encoded = Base64.encode(data);\n assert(encoded == \"FPucA9l+\");\n\n ubyte[] decoded = Base64.decode(\"FPucA9l+\");\n assert(decoded == [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e]);\n -----\n\n Support Range interface using Encoder / Decoder.\n\n Example:\n -----\n // Create MIME Base64 with CRLF, per line 76.\n File f = File(\"./text.txt\", \"r\");\n scope(exit) f.close();\n\n Appender!string mime64 = appender!string;\n\n foreach (encoded; Base64.encoder(f.byChunk(57)))\n {\n     mime64.put(encoded);\n     mime64.put(\"\\r\\n\");\n }\n\n writeln(mime64.data);\n -----\n\n Copyright: Masahiro Nakagawa 2010-.\n License:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Masahiro Nakagawa, Daniel Murphy (Single value Encoder and Decoder)\n Source:    $(PHOBOSSRC std/_base64.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/dlist.d",
		"name": "std.container.dlist",
		"members": [
			{
				"members": [
					{
						"name": "DList",
						"line": 140,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 193,
										"type": "(U[] values...)",
										"parameters": [
											{
												"name": "values",
												"type": "U[]"
											}
										],
										"endline": 196,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 193,
								"comment": "Constructor taking a number of nodes\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 201,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 205,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 201,
								"comment": "Constructor taking an input range\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opEquals",
										"line": 213,
										"type": "const bool(ref const DList rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "DList",
												"storageClass": [
													"const",
													"ref"
												]
											}
										],
										"endline": 237,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opEquals",
								"line": 213,
								"comment": "Comparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n",
								"parameters": [],
								"constraint": "is(typeof(front == front))",
								"char": 10,
								"kind": "template"
							},
							{
								"name": "Range",
								"line": 242,
								"comment": "    Defines the container's primary range, which embodies a bidirectional range.\n",
								"members": [],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 279,
								"comment": "Property returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n",
								"type": "const nothrow @property bool()",
								"endline": 282,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 291,
								"comment": "Removes all contents from the $(D DList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n",
								"type": "void()",
								"endline": 295,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 303,
								"comment": "Duplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n",
								"type": "@property DList()",
								"endline": 306,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 314,
								"comment": "Returns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 320,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 327,
								"comment": "Forward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 331,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 338,
								"comment": "Forward to $(D opSlice().back).\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 342,
								"char": 28,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 352,
										"type": "DList(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 358,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 352,
								"comment": "Returns a new $(D DList) that's the concatenation of $(D this) and its\nargument $(D rhs).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(insertBack(rhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 364,
										"type": "DList(Stuff lhs)",
										"parameters": [
											{
												"name": "lhs",
												"type": "Stuff"
											}
										],
										"endline": 370,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 364,
								"comment": "Returns a new $(D DList) that's the concatenation of the argument $(D lhs)\nand $(D this).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(insertFront(lhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 375,
										"type": "DList(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 380,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 375,
								"comment": "Appends the contents of the argument $(D rhs) into $(D this).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(insertBack(rhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 384,
										"type": "DList(DList rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "DList"
											}
										],
										"endline": 388,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 384,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"~\"",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertFront",
										"line": 404,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 408,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertFront",
								"line": 404,
								"comment": "Inserts $(D stuff) to the front/back of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 411,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 415,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 411,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 418,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsert",
								"line": 421,
								"comment": "ditto\n",
								"type": "insert",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsertFront",
								"line": 424,
								"comment": "ditto\n",
								"type": "insertFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsertBack",
								"line": 427,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 443,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 452,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 443,
								"comment": "Inserts $(D stuff) after range $(D r), which must be a non-empty range\npreviously extracted from this container.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertBefore",
								"line": 455,
								"comment": "ditto\n",
								"type": "insertBefore",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 458,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 467,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 458,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertAfter",
								"line": 470,
								"comment": "ditto\n",
								"type": "insertAfter",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 487,
								"comment": "Picks one value in an unspecified position in the container, removes\nit from the container, and returns it. The stable version behaves the same,\nbut guarantees that ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n",
								"type": "T()",
								"endline": 495,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 497,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 508,
								"comment": "Removes the value at the front/back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n",
								"type": "void()",
								"endline": 513,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 516,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 519,
								"comment": "ditto\n",
								"type": "void()",
								"endline": 524,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 527,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 542,
								"comment": "Removes $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany).\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 554,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 557,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 560,
								"comment": "ditto\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 572,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 575,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "remove",
								"line": 586,
								"comment": "Removes all elements belonging to $(D r), which must be a range\nobtained originally from this container.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 600,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 603,
								"comment": "ditto\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 606,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 615,
								"comment": "$(D linearRemove) functions as $(D remove), but also accepts ranges that are\nresult the of a $(D take) operation. This is a convenient way to remove a\nfixed amount of elements from the range.\n\nComplexity: $(BIGOH r.walkLength)\n",
								"type": "Range(Take!Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Take!Range"
									}
								],
								"endline": 629,
								"char": 11,
								"kind": "function"
							},
							{
								"name": "stableRemove",
								"line": 632,
								"comment": "ditto\n",
								"type": "remove",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableLinearRemove",
								"line": 634,
								"comment": "ditto\n",
								"type": "linearRemove",
								"char": 5,
								"kind": "alias"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "DList",
				"line": 140,
				"comment": "Implements a doubly-linked list.\n\n$(D DList) uses reference semantics.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a generic doubly-linked list container.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_dlist.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/slist.d",
		"name": "std.container.slist",
		"members": [
			{
				"members": [
					{
						"name": "SList",
						"line": 29,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 102,
										"type": "(U[] values...)",
										"parameters": [
											{
												"name": "values",
												"type": "U[]"
											}
										],
										"endline": 105,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 102,
								"comment": "Constructor taking a number of nodes\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 110,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 116,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 110,
								"comment": "Constructor taking an input range\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T) && !is(Stuff == T[])",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 124,
								"comment": "Comparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n",
								"type": "const bool(const SList rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "SList",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 127,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 130,
								"comment": "ditto\n",
								"type": "const bool(ref const SList rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "SList",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 143,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "Range",
								"line": 148,
								"comment": "Defines the container's primary range, which embodies a forward range.\n",
								"members": [
									{
										"endchar": 55,
										"name": "empty",
										"line": 154,
										"comment": "Input range primitives.\n",
										"type": "const @property bool()",
										"endline": 154,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 157,
										"comment": "ditto\n",
										"type": "@property ref T()",
										"endline": 161,
										"char": 25,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 164,
										"comment": "ditto\n",
										"type": "void()",
										"endline": 168,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 47,
										"name": "save",
										"line": 171,
										"comment": "Forward range primitive.\n",
										"type": "@property Range()",
										"endline": 171,
										"char": 25,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 198,
								"comment": "Property returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n",
								"type": "const @property bool()",
								"endline": 201,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 209,
								"comment": "Duplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n",
								"type": "@property SList()",
								"endline": 212,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 220,
								"comment": "Returns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 226,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 233,
								"comment": "Forward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n",
								"type": "@property ref T()",
								"endline": 237,
								"char": 21,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 251,
										"type": "SList(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 261,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 251,
								"comment": "Returns a new $(D SList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && is(typeof(SList(rhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 264,
										"type": "SList(Stuff lhs)",
										"parameters": [
											{
												"name": "lhs",
												"type": "Stuff"
											}
										],
										"endline": 272,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 264,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\" && !is(typeof(lhs.opBinary!\"~\"(this))) && is(typeof(SList(lhs)))",
								"char": 11,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 281,
								"comment": "Removes all contents from the $(D SList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n",
								"type": "void()",
								"endline": 284,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertFront",
										"line": 296,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 314,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertFront",
								"line": 296,
								"comment": "Inserts $(D stuff) to the front of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m), where $(D m) is the length of $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertFront",
										"line": 317,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 324,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertFront",
								"line": 317,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 327,
								"comment": "ditto\n",
								"type": "insertFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsert",
								"line": 330,
								"comment": "ditto\n",
								"type": "insert",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsertFront",
								"line": 333,
								"comment": "ditto\n",
								"type": "insertFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 346,
								"comment": "Picks one value in an unspecified position in the container, removes\nit from the container, and returns it. The stable version behaves the same,\nbut guarantees that ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n",
								"type": "T()",
								"endline": 354,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 356,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 367,
								"comment": "Removes the value at the front of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n",
								"type": "void()",
								"endline": 371,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 374,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 389,
								"comment": "Removes $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 398,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveFront",
								"line": 401,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 431,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 444,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 431,
								"comment": "Inserts $(D stuff) after range $(D r), which must be a range\npreviously extracted from this container. Given that all ranges for a\nlist end at the end of the list, this function essentially appends to\nthe list and uses $(D r) as a potentially fast way to reach the last\nnode in the list. Ideally $(D r) is positioned near or at the last\nelement of the list.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n\nExamples:\n--------------------\nauto sl = SList!string([\"a\", \"b\", \"d\"]);\nsl.insertAfter(sl[], \"e\"); // insert at the end (slowest)\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"d\", \"e\"]));\nsl.insertAfter(std.range.take(sl[], 2), \"c\"); // insert after \"b\"\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"c\", \"d\", \"e\"]));\n--------------------\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 460,
										"type": "size_t(Take!Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Take!Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 483,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 460,
								"comment": "Similar to $(D insertAfter) above, but accepts a range bounded in\ncount. This is important for ensuring fast insertions in the middle of\nthe list.  For fast insertions after a specified position $(D r), use\n$(D insertAfter(take(r, 1), stuff)). The complexity of that operation\nonly depends on the number of elements in $(D stuff).\n\nPrecondition: $(D r.original.empty || r.maxLength > 0)\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertAfter",
								"line": 486,
								"comment": "ditto\n",
								"type": "insertAfter",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 495,
								"comment": "Removes a range from the list in linear time.\n\nReturns: An empty range.\n\nComplexity: $(BIGOH n)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 505,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 514,
								"comment": "Removes a $(D Take!Range) from the list in linear time.\n\nReturns: A range comprehending the elements after the removed range.\n\nComplexity: $(BIGOH n)\n",
								"type": "Range(Take!Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Take!Range"
									}
								],
								"endline": 538,
								"char": 11,
								"kind": "function"
							},
							{
								"name": "stableLinearRemove",
								"line": 541,
								"comment": "ditto\n",
								"type": "linearRemove",
								"char": 5,
								"kind": "alias"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SList",
				"line": 29,
				"comment": "   Implements a simple and fast singly-linked list.\n\n   $(D SList) uses reference semantics.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module implements a singly-linked list container.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_slist.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/util.d",
		"name": "std.container.util",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 30,
								"type": "T(Args arguments)",
								"parameters": [
									{
										"name": "arguments",
										"type": "Args"
									}
								],
								"endline": 46,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "make",
						"line": 30,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "is(T == struct) && __traits(compiles, T(arguments))",
						"char": 7,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 48,
								"type": "T(Args arguments)",
								"parameters": [
									{
										"name": "arguments",
										"type": "Args"
									}
								],
								"endline": 52,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "make",
						"line": 48,
						"parameters": [
							{
								"name": "Args",
								"kind": "tuple"
							}
						],
						"constraint": "is(T == class) && __traits(compiles, new T(arguments))",
						"char": 7,
						"kind": "template"
					}
				],
				"name": "make",
				"line": 27,
				"comment": "Returns an initialized object. This function is mainly for eliminating\nconstruction differences between structs and classes. It allows code to not\nworry about whether the type it's constructing is a struct or a class.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL57_2403)\n---\nimport std.container;\nimport std.algorithm : equal;\nimport std.algorithm : equal;\n\nauto arr = make!(Array!int)([4, 2, 3, 1]);\nassert(equal(arr[], [4, 2, 3, 1]));\n\nauto rbt = make!(RedBlackTree!(int, \"a > b\"))([4, 2, 3, 1]);\nassert(equal(rbt[], [4, 3, 2, 1]));\n\nalias makeList = make!(SList!int);\nauto slist = makeList(1, 2, 3);\nassert(equal(slist[], [1, 2, 3]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL57_2403)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == struct) || is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 114,
								"type": "(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 119,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "make",
						"line": 114,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "!isDynamicArray!Range && isInputRange!Range",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "make",
								"line": 121,
								"type": "(T[] items...)",
								"parameters": [
									{
										"name": "items",
										"type": "T[]"
									}
								],
								"endline": 124,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "make",
						"line": 121,
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 10,
						"kind": "template"
					}
				],
				"name": "make",
				"line": 108,
				"comment": " Convenience function for constructing a generic container.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL128_2406)\n---\nimport std.container.array, std.container.rbtree, std.container.slist;\nimport std.range : iota;\nimport std.algorithm : equal;\n\nauto arr = make!Array(iota(5));\nassert(equal(arr[], [0, 1, 2, 3, 4]));\n\nauto rbtmax = make!(RedBlackTree, \"a > b\")(iota(5));\nassert(equal(rbtmax[], [4, 3, 2, 1, 0]));\n\nauto rbtmin = make!RedBlackTree(4, 1, 3, 2);\nassert(equal(rbtmin[], [1, 2, 3, 4]));\n\nalias makeList = make!SList;\nauto list = makeList(1, 7, 42);\nassert(equal(list[], [1, 7, 42]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL128_2406)\n",
				"parameters": [
					{
						"name": "Container",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"constraint": "!is(Container)",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module contains some common utilities used by containers.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_util.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/package.d",
		"name": "std.container",
		"members": [],
		"comment": "This module defines generic containers.\n\nConstruction:\n\nTo implement the different containers both struct and class based\napproaches have been used. $(XREF_PACK _container,util,make) allows for\nuniform construction with either approach.\n\n---\nimport std.container;\n// Construct a red-black tree and an array both containing the values 1, 2, 3.\n// RedBlackTree should typically be allocated using `new`\nRedBlackTree!int rbTree = new RedBlackTree!int(1, 2, 3);\n// But `new` should not be used with Array\nArray!int array = Array!int(1, 2, 3);\n// `make` hides the differences\nRedBlackTree!int rbTree2 = make!(RedBlackTree!int)(1, 2, 3);\nArray!int array2 = make!(Array!int)(1, 2, 3);\n---\n\nNote that $(D make) can infer the element type from the given arguments.\n\n---\nimport std.container;\nauto rbTree = make!RedBlackTree(1, 2, 3); // RedBlackTree!int\nauto array = make!Array(\"1\", \"2\", \"3\"); // Array!string\n---\n\nReference_semantics:\n\nAll containers have reference semantics, which means that after\nassignment both variables refer to the same underlying data.\n\nTo make a copy of a _container, use the $(D c._dup) _container primitive.\n---\nimport std.container, std.range;\nArray!int originalArray = make!(Array!int)(1, 2, 3);\nArray!int secondArray = originalArray;\nassert(equal(originalArray[], secondArray[]));\n\n// changing one instance changes the other one as well!\noriginalArray[0] = 12;\nassert(secondArray[0] == 12);\n\n// secondArray now refers to an independent copy of originalArray\nsecondArray = originalArray.dup;\nsecondArray[0] = 1;\n// assert that originalArray has not been effected\nassert(originalArray[0] == 12);\n---\n\n$(B Attention:) If the _container is implemented as a class, using an\nuninitialized instance can cause a null pointer dereference.\n\n---\nimport std.container;\n\nRedBlackTree!int rbTree;\nrbTree.insert(5); // null pointer dereference\n---\n\nUsing an uninitialized struct-based _container will work, because the struct\nintializes itself upon use; however, up to this point the _container will not\nhave an identity and assignment does not create two references to the same\ndata.\n\n---\nimport std.container;\n\n// create an uninitialized array\nArray!int array1;\n// array2 does _not_ refer to array1\nArray!int array2 = array1;\narray2.insertBack(42);\n// thus array1 will not be affected\nassert(array1.empty);\n\n// after initialization reference semantics work as expected\narray1 = array2;\n// now effects array2 as well\narray1.removeBack();\nassert(array2.empty);\n---\nIt is therefore recommended to always construct containers using\n$(XREF_PACK _container,util,make).\n\nThis is in fact necessary to put containers into another _container.\nFor example, to construct an $(D Array) of ten empty $(D Array)s, use\nthe following that calls $(D make) ten times.\n\n---\nimport std.range, std.container, std.algorithm;\n\nArray!(Array!int) arrayOfArrays = make!(Array!(Array!int))(\n    repeat(0, 10).map!(x => make!(Array!int))\n);\n---\n\nSubmodules:\n\nThis module consists of the following submodules:\n\n$(UL\n    $(LI\n        The $(LINK2 std_container_array.html, std._container.array) module provides\n        an array type with deterministic control of memory, not reliant on\n        the GC unlike built-in arrays.\n    )\n    $(LI\n        The $(LINK2 std_container_binaryheap.html, std._container.binaryheap) module\n        provides a binary heap implementation that can be applied to any\n        user-provided random-access range.\n    )\n    $(LI\n        The $(LINK2 std_container_dlist.html, std._container.dlist) module provides\n        a doubly-linked list implementation.\n    )\n    $(LI\n        The $(LINK2 std_container_rbtree.html, std._container.rbtree) module\n        implements red-black trees.\n    )\n    $(LI\n        The $(LINK2 std_container_slist.html, std._container.slist) module\n        implements singly-linked lists.\n    )\n    $(LI\n        The $(LINK2 std_container_util.html, std._container.util) module contains\n        some generic tools commonly used by _container implementations.\n    )\n)\n\nThe_primary_range_of_a_container:\n\nWhile some _containers offer direct access to their elements e.g. via\n$(D opIndex), $(D c.front) or $(D c.back), access\nand modification of a _container's contents is generally done through\nits primary $(LINK2 std_range.html, range) type,\nwhich is aliased as $(D C.Range). For example, the primary range type of\n$(D Array!int) is $(D Array!int.Range).\n\nIf the documentation of a member function of a _container takes a\na parameter of type $(D Range), then it refers to the primary range type of\nthis _container. Oftentimes $(D Take!Range) will be used, in which case\nthe range refers to a span of the elements in the _container. Arguments to\nthese parameters $(B must) be obtained from the same _container instance\nas the one being worked with. It is important to note that many generic range\nalgorithms return the same range type as their input range.\n\n---\nimport std.algorithm : equal, find;\nimport std.container;\nimport std.range : takeOne;\n\nauto array = make!Array(1, 2, 3);\n\n// `find` returns an Array!int.Range advanced to the element \"2\"\narray.linearRemove(array[].find(2));\n\nassert(array[].equal([1]));\n\narray = make!Array(1, 2, 3);\n\n// the range given to `linearRemove` is a Take!(Array!int.Range)\n// spanning just the element \"2\"\narray.linearRemove(array[].find(2).takeOne());\n\nassert(array[].equal([1, 3]));\n---\n\nWhen any $(LINK2 std_range.html, range) can be passed as an argument to\na member function, the documention usually refers to the parameter's templated\ntype as $(D Stuff).\n\n---\nimport std.algorithm : equal;\nimport std.container;\nimport std.range : iota;\n\nauto array = make!Array(1, 2);\n\n// the range type returned by `iota` is completely unrelated to Array,\n// which is fine for Array.insertBack:\narray.insertBack(iota(3, 10));\n\nassert(array[].equal([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n---\n\nContainer_primitives:\n\nContainers do not form a class hierarchy, instead they implement a\ncommon set of primitives (see table below). These primitives each guarantee\na specific worst case complexity and thus allow generic code to be written\nindependently of the _container implementation.\n\nFor example the primitives $(D c.remove(r)) and $(D c.linearRemove(r)) both\nremove the sequence of elements in range $(D r) from the _container $(D c).\nThe primitive $(D c.remove(r)) guarantees $(BIGOH 1) complexity and\n$(D c.linearRemove(r)) relaxes this guarantee to $(BIGOH n) (where $(D n)\nis the length of the _container $(D c)).\n\nSince a sequence of elements can be removed from a $(LINK2 std_container_dlist.html, doubly linked list)\nin constant time, $(D DList) provides the primitive $(D c.remove(r))\nas well as $(D c.linearRemove(r)). On the other hand a\n$(LINK2 std_container_array.html, Array) only offers $(D c.linearRemove(r)).\n\nThe following table describes the common set of primitives that containers\nimplement.  A _container need not implement all primitives, but if a\nprimitive is implemented, it must support the syntax described in the $(B\nsyntax) column with the semantics described in the $(B description) column, and\nit must not have a worst-case complexity worse than denoted in big-O notation in\nthe $(BIGOH &middot;) column.  Below, $(D C) means a _container type, $(D c) is\na value of _container type, $(D n$(SUBSCRIPT x)) represents the effective length of\nvalue $(D x), which could be a single element (in which case $(D n$(SUBSCRIPT x)) is\n$(D 1)), a _container, or a range.\n\n$(BOOKTABLE Container primitives,\n\n$(TR $(TH Syntax) $(TH $(BIGOH &middot;)) $(TH Description))\n\n$(TR $(TDNW $(D C(x))) $(TDNW $(D n$(SUBSCRIPT x))) $(TD Creates a\n_container of type $(D C) from either another _container or a range. The created _container must not be a null reference even if x is empty.))\n\n$(TR $(TDNW $(D c.dup)) $(TDNW $(D n$(SUBSCRIPT c))) $(TD Returns a\nduplicate of the _container.))\n\n$(TR $(TDNW $(D c ~ x)) $(TDNW $(D n$(SUBSCRIPT c) + n$(SUBSCRIPT x))) $(TD\nReturns the concatenation of $(D c) and $(D r). $(D x) may be a single\nelement or an input range.))\n\n$(TR $(TDNW $(D x ~ c)) $(TDNW $(D n$(SUBSCRIPT c) + n$(SUBSCRIPT x))) $(TD\nReturns the concatenation of $(D x) and $(D c).  $(D x) may be a\nsingle element or an input range type.))\n\n$(LEADINGROW Iteration)\n\n$(TR  $(TD $(D c.Range)) $(TD) $(TD The primary range\ntype associated with the _container.))\n\n$(TR $(TD $(D c[])) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns a range\niterating over the entire _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c[a .. b])) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Fetches a\nportion of the _container from key $(D a) to key $(D b).))\n\n$(LEADINGROW Capacity)\n\n$(TR $(TD $(D c.empty)) $(TD $(D 1)) $(TD Returns $(D true) if the\n_container has no elements, $(D false) otherwise.))\n\n$(TR  $(TD $(D c.length)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nnumber of elements in the _container.))\n\n$(TR $(TDNW $(D c.length = n)) $(TDNW $(D n$(SUBSCRIPT c) + n)) $(TD Forces\nthe number of elements in the _container to $(D n). If the _container\nends up growing, the added elements are initialized in a\n_container-dependent manner (usually with $(D T.init)).))\n\n$(TR $(TD $(D c.capacity)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nmaximum number of elements that can be stored in the _container\nwithout triggering a reallocation.))\n\n$(TR $(TD $(D c.reserve(x))) $(TD $(D n$(SUBSCRIPT c))) $(TD Forces $(D\ncapacity) to at least $(D x) without reducing it.))\n\n$(LEADINGROW Access)\n\n$(TR $(TDNW $(D c.front)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nfirst element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveFront)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nDestructively reads and returns the first element of the\n_container. The slot is not removed from the _container; it is left\ninitialized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.front = v)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Assigns\n$(D v) to the first element of the _container.))\n\n$(TR $(TDNW $(D c.back)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Returns the\nlast element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveBack)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nDestructively reads and returns the last element of the\n_container. The slot is not removed from the _container; it is left\ninitialized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.back = v)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Assigns\n$(D v) to the last element of the _container.))\n\n$(TR $(TDNW $(D c[x])) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Provides\nindexed access into the _container. The index type is\n_container-defined. A _container may define several index types (and\nconsequently overloaded indexing).))\n\n$(TR  $(TDNW $(D c.moveAt(x))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nDestructively reads and returns the value at position $(D x). The slot\nis not removed from the _container; it is left initialized with $(D\nT.init).))\n\n$(TR  $(TDNW $(D c[x] = v)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD Sets\nelement at specified index into the _container.))\n\n$(TR  $(TDNW $(D c[x] $(I op)= v)) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Performs read-modify-write operation at specified index into the\n_container.))\n\n$(LEADINGROW Operations)\n\n$(TR $(TDNW $(D e in c)) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns nonzero if e is found in $(D c).))\n\n$(TR  $(TDNW $(D c.lowerBound(v))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns a range of all elements strictly less than $(D v).))\n\n$(TR  $(TDNW $(D c.upperBound(v))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns a range of all elements strictly greater than $(D v).))\n\n$(TR  $(TDNW $(D c.equalRange(v))) $(TDNW $(D log n$(SUBSCRIPT c))) $(TD\nReturns a range of all elements in $(D c) that are equal to $(D v).))\n\n$(LEADINGROW Modifiers)\n\n$(TR $(TDNW $(D c ~= x)) $(TDNW $(D n$(SUBSCRIPT c) + n$(SUBSCRIPT x)))\n$(TD Appends $(D x) to $(D c). $(D x) may be a single element or an\ninput range type.))\n\n$(TR  $(TDNW $(D c.clear())) $(TDNW $(D n$(SUBSCRIPT c))) $(TD Removes all\nelements in $(D c).))\n\n$(TR  $(TDNW $(D c.insert(x))) $(TDNW $(D n$(SUBSCRIPT x) * log n$(SUBSCRIPT c)))\n$(TD Inserts $(D x) in $(D c) at a position (or positions) chosen by $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsert(x)))\n$(TDNW $(D n$(SUBSCRIPT x) * log n$(SUBSCRIPT c))) $(TD Same as $(D c.insert(x)),\nbut is guaranteed to not invalidate any ranges.))\n\n$(TR  $(TDNW $(D c.linearInsert(v))) $(TDNW $(D n$(SUBSCRIPT c))) $(TD Same\nas $(D c.insert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.stableLinearInsert(v))) $(TDNW $(D n$(SUBSCRIPT c)))\n$(TD Same as $(D c.stableInsert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.removeAny())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes some element from $(D c) and returns it.))\n\n$(TR  $(TDNW $(D c.stableRemoveAny())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.removeAny()), but is guaranteed to not invalidate any\niterators.))\n\n$(TR  $(TDNW $(D c.insertFront(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Inserts $(D v) at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertFront(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.insertFront(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.insertBack(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Inserts $(D v) at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertBack(v))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.insertBack(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeFront())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes the element at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveFront())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.removeFront()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeBack())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes the value at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveBack())) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.removeBack()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.remove(r))) $(TDNW $(D n$(SUBSCRIPT r) * log n$(SUBSCRIPT c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemove(r)))\n$(TDNW $(D n$(SUBSCRIPT r) * log n$(SUBSCRIPT c)))\n$(TD Same as $(D c.remove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.linearRemove(r))) $(TDNW $(D n$(SUBSCRIPT c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableLinearRemove(r))) $(TDNW $(D n$(SUBSCRIPT c)))\n$(TD Same as $(D c.linearRemove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeKey(k))) $(TDNW $(D log n$(SUBSCRIPT c)))\n$(TD Removes an element from $(D c) by using its key $(D k).\nThe key's type is defined by the _container.))\n\n$(TR  $(TDNW $(D )) $(TDNW $(D )) $(TD ))\n\n)\n\nSource: $(PHOBOSSRC std/_container/package.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/rbtree.d",
		"name": "std.container.rbtree",
		"members": [
			{
				"members": [
					{
						"name": "RedBlackTree",
						"line": 633,
						"members": [
							{
								"name": "Elem",
								"line": 675,
								"comment": " Element type for the tree\n",
								"type": "T",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "Range",
								"line": 706,
								"comment": " The range type for $(D RedBlackTree)\n",
								"members": [
									{
										"endchar": 9,
										"name": "empty",
										"line": 720,
										"comment": " Returns $(D true) if the range is _empty\n",
										"type": "const @property bool()",
										"endline": 723,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 728,
										"comment": " Returns the first element in the range\n",
										"type": "@property Elem()",
										"endline": 731,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "back",
										"line": 736,
										"comment": " Returns the last element in the range\n",
										"type": "@property Elem()",
										"endline": 739,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 746,
										"comment": " pop the front element from the range\n\n complexity: amortized $(BIGOH 1)\n",
										"type": "void()",
										"endline": 749,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popBack",
										"line": 756,
										"comment": " pop the back element from the range\n\n complexity: amortized $(BIGOH 1)\n",
										"type": "void()",
										"endline": 759,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "save",
										"line": 764,
										"comment": " Trivial _save implementation, needed for $(D isForwardRange).\n",
										"type": "@property Range()",
										"endline": 767,
										"char": 25,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 919,
								"comment": " Check if any elements exist in the container.  Returns $(D false) if at least\n one element exists.\n",
								"type": "@property bool()",
								"endline": 922,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 929,
								"comment": "        Returns the number of elements in the container.\n\n        Complexity: $(BIGOH 1).\n",
								"type": "const @property size_t()",
								"endline": 932,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 940,
								"comment": " Duplicate this container.  The resulting container contains a shallow\n copy of the elements.\n\n Complexity: $(BIGOH n)\n",
								"type": "@property RedBlackTree()",
								"endline": 943,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 963,
								"comment": " Fetch a range that spans all the elements in the container.\n\n Complexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 966,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 973,
								"comment": " The front element in the container\n\n Complexity: $(BIGOH 1)\n",
								"type": "Elem()",
								"endline": 976,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 983,
								"comment": " The last element in the container\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Elem()",
								"endline": 986,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinaryRight",
										"line": 994,
										"type": "const bool(Elem e)",
										"parameters": [
											{
												"name": "e",
												"type": "Elem"
											}
										],
										"endline": 997,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opBinaryRight",
								"line": 994,
								"comment": "        $(D in) operator. Check to see if the given element exists in the\n        container.\n\n       Complexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"in\"",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 1011,
								"comment": " Compares two trees for equality.\n\n Complexity: $(BIGOH n)\n",
								"type": "bool(Object rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Object"
									}
								],
								"endline": 1025,
								"char": 19,
								"kind": "function",
								"storageClass": [
									"override"
								]
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 1047,
								"comment": " Removes all elements from the container.\n\n Complexity: $(BIGOH 1)\n",
								"type": "void()",
								"endline": 1052,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "stableInsert",
										"line": 1070,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1081,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "stableInsert",
								"line": 1070,
								"comment": " Insert a single element in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Returns: The number of elements inserted.\n\n Complexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, Elem)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "stableInsert",
										"line": 1091,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1111,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "stableInsert",
								"line": 1091,
								"comment": " Insert a range of elements in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Returns: The number of elements inserted.\n\n Complexity: $(BIGOH m * log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, Elem)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 1114,
								"comment": "ditto\n",
								"type": "stableInsert",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 1152,
								"comment": " Remove an element from the container and return its value.\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Elem()",
								"endline": 1162,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 1181,
								"comment": " Remove the front element from the container.\n\n Complexity: $(BIGOH log(n))\n",
								"type": "void()",
								"endline": 1188,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 1195,
								"comment": " Remove the back element from the container.\n\n Complexity: $(BIGOH log(n))\n",
								"type": "void()",
								"endline": 1206,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "remove",
								"line": 1233,
								"comment": "        Removes the given range from the container.\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 1247,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "remove",
								"line": 1277,
								"comment": "        Removes the given $(D Take!Range) from the container\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n",
								"type": "Range(Take!Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Take!Range"
									}
								],
								"endline": 1293,
								"char": 11,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "removeKey",
										"line": 1340,
										"type": "size_t(U elems)",
										"parameters": [
											{
												"name": "elems",
												"type": "U"
											}
										],
										"endline": 1349,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "removeKey",
								"line": 1340,
								"comment": "       Removes elements from the container that are equal to the given values\n       according to the less comparator. One element is removed for each value\n       given which is in the container. If $(D allowDuplicates) is true,\n       duplicates are removed only if duplicate values are given.\n\n       Returns: The number of elements removed.\n\n       Complexity: $(BIGOH m log(n)) (where m is the number of elements to remove)\n\n       Examples:\n--------------------\nauto rbt = redBlackTree!true(0, 1, 1, 1, 4, 5, 7);\nrbt.removeKey(1, 4, 7);\nassert(equal(rbt[], [0, 1, 1, 5]));\nrbt.removeKey(1, 1, 0);\nassert(equal(rbt[], [5]));\n--------------------\n",
								"parameters": [
									{
										"name": "U",
										"kind": "tuple"
									}
								],
								"constraint": "allSatisfy!(isImplicitlyConvertibleToElem, U)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "removeKey",
										"line": 1352,
										"type": "size_t(U[] elems)",
										"parameters": [
											{
												"name": "elems",
												"type": "U[]"
											}
										],
										"endline": 1371,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "removeKey",
								"line": 1352,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, Elem)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "removeKey",
										"line": 1374,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1383,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "removeKey",
								"line": 1374,
								"comment": " Ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, Elem) && !isDynamicArray!Stuff",
								"char": 12,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "upperBound",
								"line": 1481,
								"comment": " Get a range from the container with all elements that are > e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Range(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1484,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "lowerBound",
								"line": 1492,
								"comment": " Get a range from the container with all elements that are < e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Range(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1495,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "equalRange",
								"line": 1503,
								"comment": " Get a range from the container with all elements that are == e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n",
								"type": "Range(Elem e)",
								"parameters": [
									{
										"name": "e",
										"type": "Elem"
									}
								],
								"endline": 1519,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1632,
								"comment": " Constructor. Pass in an array of elements, or individual elements to\n initialize the tree with.\n",
								"type": "(Elem[] elems...)",
								"parameters": [
									{
										"name": "elems",
										"type": "Elem[]"
									}
								],
								"endline": 1636,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 1641,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1645,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 1641,
								"comment": " Constructor. Pass in a range of elements to initialize the tree with.\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, Elem)",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1648,
								"comment": "\n",
								"type": "()",
								"endline": 1651,
								"char": 5,
								"kind": "constructor"
							}
						],
						"char": 7,
						"kind": "class"
					}
				],
				"name": "RedBlackTree",
				"line": 633,
				"comment": " Implementation of a $(LUCKY red-black tree) container.\n\n All inserts, removes, searches, and any function in general has complexity\n of $(BIGOH lg(n)).\n\n To use a different comparison than $(D \"a < b\"), pass a different operator string\n that can be used by $(XREF functional, binaryFun), or pass in a\n function, delegate, functor, or any type where $(D less(a, b)) results in a $(D bool)\n value.\n\n Note that less should produce a strict ordering.  That is, for two unequal\n elements $(D a) and $(D b), $(D less(a, b) == !less(b, a)). $(D less(a, a)) should\n always equal $(D false).\n\n If $(D allowDuplicates) is set to $(D true), then inserting the same element more than\n once continues to add more elements.  If it is $(D false), duplicate elements are\n ignored on insertion.  If duplicates are allowed, then new elements are\n inserted after all existing duplicate elements.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "allowDuplicates",
						"defaultValue": "false",
						"deco": "b",
						"kind": "value"
					}
				],
				"constraint": "is(typeof(binaryFun!less(T.init, T.init)))",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1727,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1730,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1727,
				"comment": "    Convenience function for creating a $(D RedBlackTree!E) from a list of\n    values.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1755_2426)\n---\nauto rbt1 = redBlackTree(0, 1, 5, 7);\nauto rbt2 = redBlackTree!string(\"hello\", \"world\");\nauto rbt3 = redBlackTree!true(0, 1, 5, 7, 5);\nauto rbt4 = redBlackTree!\"a > b\"(0, 1, 5, 7);\nauto rbt5 = redBlackTree!(\"a > b\", true)(0.1, 1.3, 5.9, 7.2, 5.9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1755_2426)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1733,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1736,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1733,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "allowDuplicates",
						"deco": "b",
						"kind": "value"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1739,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1742,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1739,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "less",
						"kind": "alias"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "redBlackTree",
						"line": 1745,
						"type": "(E[] elems...)",
						"parameters": [
							{
								"name": "elems",
								"type": "E[]"
							}
						],
						"endline": 1752,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "redBlackTree",
				"line": 1745,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "less",
						"kind": "alias"
					},
					{
						"name": "allowDuplicates",
						"deco": "b",
						"kind": "value"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!less(E.init, E.init)))",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This module implements a red-black tree container.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_rbtree.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/array.d",
		"name": "std.container.array",
		"members": [
			{
				"members": [
					{
						"name": "Array",
						"line": 198,
						"members": [
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 368,
										"type": "(U[] values...)",
										"parameters": [
											{
												"name": "values",
												"type": "U[]"
											}
										],
										"endline": 384,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 368,
								"comment": "Constructor taking a number of items\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(U, T)",
								"char": 5,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "this",
										"line": 389,
										"type": "(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 393,
										"char": 5,
										"kind": "constructor"
									}
								],
								"name": "this",
								"line": 389,
								"comment": "Constructor taking an input range\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T) && !is(Stuff == T[])",
								"char": 5,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 399,
								"comment": "Comparison for equality.\n",
								"type": "const bool(const Array rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Array",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 402,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opEquals",
								"line": 405,
								"comment": "ditto\n",
								"type": "const bool(ref const Array rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "Array",
										"storageClass": [
											"const",
											"ref"
										]
									}
								],
								"endline": 410,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "Range",
								"line": 418,
								"comment": "   Defines the container's primary range, which is a random-access range.\n\n   ConstRange is a variant with const elements.\n   ImmutableRange is a variant with immutable elements.\n",
								"type": "RangeT!Array",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "ConstRange",
								"line": 419,
								"comment": "ditto\n",
								"type": "RangeT!(const(Array))",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "ImmutableRange",
								"line": 420,
								"comment": "ditto\n",
								"type": "RangeT!(immutable(Array))",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 428,
								"comment": "Duplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n",
								"type": "@property Array()",
								"endline": 432,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 440,
								"comment": "Property returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n",
								"type": "const @property bool()",
								"endline": 443,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 450,
								"comment": "Returns the number of elements in the container.\n\nComplexity: $(BIGOH 1).\n",
								"type": "const @property size_t()",
								"endline": 453,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opDollar",
								"line": 456,
								"comment": "ditto\n",
								"type": "const size_t()",
								"endline": 459,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 467,
								"comment": "Returns the maximum number of elements the container can store without\n   (a) allocating memory, (b) invalidating iterators upon insertion.\n\nComplexity: $(BIGOH 1)\n",
								"type": "@property size_t()",
								"endline": 470,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "reserve",
								"line": 479,
								"comment": "Ensures sufficient capacity to accommodate $(D e) elements.\n\nPostcondition: $(D capacity >= e)\n\nComplexity: $(BIGOH 1)\n",
								"type": "void(size_t elements)",
								"parameters": [
									{
										"name": "elements",
										"type": "size_t"
									}
								],
								"endline": 497,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 505,
								"comment": "Returns a range that iterates over elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range()",
								"endline": 508,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 526,
								"comment": "Returns a range that iterates over elements of the container from\nindex $(D a) up to (excluding) index $(D b).\n\nPrecondition: $(D a <= b && b <= length)\n\nComplexity: $(BIGOH 1)\n",
								"type": "Range(size_t i, size_t j)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									},
									{
										"name": "j",
										"type": "size_t"
									}
								],
								"endline": 530,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 549,
								"comment": "Forward to $(D opSlice().front) and $(D opSlice().back), respectively.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout @property ref inout(T)()",
								"endline": 553,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 556,
								"comment": "ditto\n",
								"type": "inout @property ref inout(T)()",
								"endline": 560,
								"char": 28,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opIndex",
								"line": 569,
								"comment": "Indexing operators yield or modify the value at a specified index.\n\nPrecondition: $(D i < length)\n\nComplexity: $(BIGOH 1)\n",
								"type": "inout ref inout(T)(size_t i)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 573,
								"char": 18,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSliceAssign",
								"line": 582,
								"comment": "Slicing operations execute an operation on an entire slice.\n\nPrecondition: $(D i < j && j < length)\n\nComplexity: $(BIGOH slice.length)\n",
								"type": "void(T value)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									}
								],
								"endline": 586,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSliceAssign",
								"line": 589,
								"comment": "ditto\n",
								"type": "void(T value, size_t i, size_t j)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									},
									{
										"name": "i",
										"type": "size_t"
									},
									{
										"name": "j",
										"type": "size_t"
									}
								],
								"endline": 595,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceUnary",
										"line": 598,
										"type": "void()",
										"endline": 603,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceUnary",
								"line": 598,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"++\" || op == \"--\"",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceUnary",
										"line": 606,
										"type": "void(size_t i, size_t j)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											},
											{
												"name": "j",
												"type": "size_t"
											}
										],
										"endline": 611,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceUnary",
								"line": 606,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"constraint": "op == \"++\" || op == \"--\"",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceOpAssign",
										"line": 614,
										"type": "void(T value)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											}
										],
										"endline": 618,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceOpAssign",
								"line": 614,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opSliceOpAssign",
										"line": 621,
										"type": "void(T value, size_t i, size_t j)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											},
											{
												"name": "i",
												"type": "size_t"
											},
											{
												"name": "j",
												"type": "size_t"
											}
										],
										"endline": 625,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opSliceOpAssign",
								"line": 621,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 635,
										"type": "Array(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 646,
										"char": 11,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 635,
								"comment": "Returns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 11,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 651,
										"type": "void(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 662,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 651,
								"comment": "Forwards to $(D insertBack(stuff)).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 672,
								"comment": "Removes all contents from the container. The container decides how $(D\ncapacity) is affected.\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH n)\n",
								"type": "void()",
								"endline": 675,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 687,
								"comment": "Sets the number of elements in the container to $(D newSize). If $(D\nnewSize) is greater than $(D length), the added elements are added to\nunspecified positions in the container and initialized with $(D\nT.init).\n\nComplexity: $(BIGOH abs(n - newLength))\n\nPostcondition: $(D length == newLength)\n",
								"type": "@property void(size_t newLength)",
								"parameters": [
									{
										"name": "newLength",
										"type": "size_t"
									}
								],
								"endline": 691,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 704,
								"comment": "Picks one value in an unspecified position in the container, removes\nit from the container, and returns it. The stable version behaves the same,\nbut guarantees that ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH log(n)).\n",
								"type": "T()",
								"endline": 709,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 711,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 724,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 730,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 724,
								"comment": "Inserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T) || isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "insert",
								"line": 732,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 743,
								"comment": "Removes the value at the back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH log(n)).\n",
								"type": "void()",
								"endline": 750,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 752,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 767,
								"comment": "Removes $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany).\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 776,
								"char": 12,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 778,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 791,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 805,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 791,
								"comment": "Inserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 808,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 845,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 808,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 848,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 859,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 848,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "replace",
										"line": 862,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 881,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "replace",
								"line": 862,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "replace",
										"line": 884,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 899,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "replace",
								"line": 884,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isImplicitlyConvertible!(Stuff, T)",
								"char": 12,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 913,
								"comment": "Removes all elements belonging to $(D r), which must be a range\nobtained originally from this container. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH n - m), where $(D m) is the number of elements in\n$(D r)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 925,
								"char": 11,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Array",
				"line": 198,
				"comment": "Array type with deterministic control of memory. The memory allocated\nfor the array is reclaimed as soon as possible; there is no reliance\non the garbage collector. $(D Array) uses $(D malloc) and $(D free)\nfor managing its own memory.\n\nThis means that pointers to elements of an $(D Array) will become\ndangling as soon as the element is removed from the $(D Array). On the other hand\nthe memory allocated by an $(D Array) will be scanned by the GC and\nGC managed objects referenced from an $(D Array) will be kept alive.\n\nNote:\n\nWhen using $(D Array) with range-based functions like those in $(D std.algorithm),\n$(D Array) must be sliced to get a range (for example, use $(D array[].map!)\ninstead of $(D array.map!)). The container itself is not a range.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!is(Unqual!T == bool)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Array",
						"line": 1360,
						"members": [
							{
								"name": "Range",
								"line": 1383,
								"comment": "       Defines the container's primary range.\n",
								"members": [
									{
										"endchar": 9,
										"name": "save",
										"line": 1388,
										"comment": "Range primitives\n",
										"type": "@property Range()",
										"endline": 1399,
										"char": 25,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "empty",
										"line": 1401,
										"comment": "Ditto\n",
										"type": "@property bool()",
										"endline": 1404,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1406,
										"comment": "Ditto\n",
										"type": "@property T()",
										"endline": 1410,
										"char": 21,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "front",
										"line": 1412,
										"comment": "Ditto\n",
										"type": "@property void(bool value)",
										"parameters": [
											{
												"name": "value",
												"deco": "b"
											}
										],
										"endline": 1416,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "moveFront",
										"line": 1418,
										"comment": "Ditto\n",
										"type": "T()",
										"endline": 1422,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popFront",
										"line": 1424,
										"comment": "Ditto\n",
										"type": "void()",
										"endline": 1428,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "back",
										"line": 1430,
										"comment": "Ditto\n",
										"type": "@property T()",
										"endline": 1434,
										"char": 21,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "back",
										"line": 1436,
										"comment": "Ditto\n",
										"type": "@property void(bool value)",
										"parameters": [
											{
												"name": "value",
												"deco": "b"
											}
										],
										"endline": 1440,
										"char": 24,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "moveBack",
										"line": 1442,
										"comment": "Ditto\n",
										"type": "T()",
										"endline": 1446,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "popBack",
										"line": 1448,
										"comment": "Ditto\n",
										"type": "void()",
										"endline": 1452,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "opIndex",
										"line": 1454,
										"comment": "Ditto\n",
										"type": "T(size_t i)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1457,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "opIndexAssign",
										"line": 1459,
										"comment": "Ditto\n",
										"type": "void(T value, size_t i)",
										"parameters": [
											{
												"name": "value",
												"type": "T"
											},
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1462,
										"char": 14,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "moveAt",
										"line": 1464,
										"comment": "Ditto\n",
										"type": "T(size_t i)",
										"parameters": [
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1467,
										"char": 11,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "length",
										"line": 1469,
										"comment": "Ditto\n",
										"type": "const @property size_t()",
										"endline": 1473,
										"char": 26,
										"kind": "function"
									},
									{
										"endchar": 9,
										"name": "opSlice",
										"line": 1476,
										"comment": "ditto\n",
										"type": "Range(size_t low, size_t high)",
										"parameters": [
											{
												"name": "low",
												"type": "size_t"
											},
											{
												"name": "high",
												"type": "size_t"
											}
										],
										"endline": 1480,
										"char": 15,
										"kind": "function"
									}
								],
								"char": 5,
								"kind": "struct"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 1489,
								"comment": "       Property returning $(D true) if and only if the container has\n       no elements.\n\n       Complexity: $(BIGOH 1)\n",
								"type": "@property bool()",
								"endline": 1492,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 1509,
								"comment": "       Returns a duplicate of the container. The elements themselves\n       are not transitively duplicated.\n\n       Complexity: $(BIGOH n).\n",
								"type": "@property Array()",
								"endline": 1514,
								"char": 21,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 1531,
								"comment": "       Returns the number of elements in the container.\n\n       Complexity: $(BIGOH log(n)).\n",
								"type": "const @property size_t()",
								"endline": 1534,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 1556,
								"comment": "       Returns the maximum number of elements the container can store\n       without (a) allocating memory, (b) invalidating iterators upon\n       insertion.\n\n       Complexity: $(BIGOH log(n)).\n",
								"type": "@property size_t()",
								"endline": 1561,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "reserve",
								"line": 1583,
								"comment": "       Ensures sufficient capacity to accommodate $(D n) elements.\n\n       Postcondition: $(D capacity >= n)\n\n       Complexity: $(BIGOH log(e - capacity)) if $(D e > capacity),\n       otherwise $(BIGOH 1).\n",
								"type": "void(size_t e)",
								"parameters": [
									{
										"name": "e",
										"type": "size_t"
									}
								],
								"endline": 1588,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 1606,
								"comment": "       Returns a range that iterates over all elements of the\n       container, in a container-defined order. The container should\n       choose the most convenient and fast method of iteration for $(D\n       opSlice()).\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "Range()",
								"endline": 1609,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opSlice",
								"line": 1624,
								"comment": "       Returns a range that iterates the container between two\n       specified positions.\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "Range(size_t a, size_t b)",
								"parameters": [
									{
										"name": "a",
										"type": "size_t"
									},
									{
										"name": "b",
										"type": "size_t"
									}
								],
								"endline": 1628,
								"char": 11,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 1643,
								"comment": "       Equivalent to $(D opSlice().front) and $(D opSlice().back),\n       respectively.\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "@property bool()",
								"endline": 1647,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 1650,
								"comment": "Ditto\n",
								"type": "@property void(bool value)",
								"parameters": [
									{
										"name": "value",
										"deco": "b"
									}
								],
								"endline": 1655,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 1667,
								"comment": "Ditto\n",
								"type": "@property bool()",
								"endline": 1671,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "back",
								"line": 1674,
								"comment": "Ditto\n",
								"type": "@property void(bool value)",
								"parameters": [
									{
										"name": "value",
										"deco": "b"
									}
								],
								"endline": 1686,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opIndex",
								"line": 1700,
								"comment": "       Indexing operators yield or modify the value at a specified index.\n",
								"type": "bool(size_t i)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 1706,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "opIndexAssign",
								"line": 1708,
								"comment": "ditto\n",
								"type": "void(bool value, size_t i)",
								"parameters": [
									{
										"name": "value",
										"deco": "b"
									},
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 1715,
								"char": 10,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opIndexOpAssign",
										"line": 1717,
										"type": "void(bool value, size_t i)",
										"parameters": [
											{
												"name": "value",
												"deco": "b"
											},
											{
												"name": "i",
												"type": "size_t"
											}
										],
										"endline": 1731,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opIndexOpAssign",
								"line": 1717,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									}
								],
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "moveAt",
								"line": 1733,
								"comment": "Ditto\n",
								"type": "T(size_t i)",
								"parameters": [
									{
										"name": "i",
										"type": "size_t"
									}
								],
								"endline": 1736,
								"char": 7,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opBinary",
										"line": 1754,
										"type": "Array!bool(Stuff rhs)",
										"parameters": [
											{
												"name": "rhs",
												"type": "Stuff"
											}
										],
										"endline": 1758,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "opBinary",
								"line": 1754,
								"comment": "       Returns a new container that's the concatenation of $(D this)\n       and its argument.\n\n       Complexity: $(BIGOH n + m), where m is the number of elements\n       in $(D stuff)\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 16,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 1782,
										"type": "Array!bool(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1787,
										"char": 16,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 1782,
								"comment": "       Forwards to $(D insertAfter(this[], stuff)).\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"kind": "value"
									},
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "op == \"~\"",
								"char": 16,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 1810,
								"comment": "       Removes all contents from the container. The container decides\n       how $(D capacity) is affected.\n\n       Postcondition: $(D empty)\n\n       Complexity: $(BIGOH n)\n",
								"type": "void()",
								"endline": 1813,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 1833,
								"comment": "       Sets the number of elements in the container to $(D\n       newSize). If $(D newSize) is greater than $(D length), the\n       added elements are added to the container and initialized with\n       $(D ElementType.init).\n\n       Complexity: $(BIGOH abs(n - newLength))\n\n       Postcondition: $(D _length == newLength)\n",
								"type": "@property void(size_t newLength)",
								"parameters": [
									{
										"name": "newLength",
										"type": "size_t"
									}
								],
								"endline": 1841,
								"char": 20,
								"kind": "function"
							},
							{
								"name": "insert",
								"line": 1868,
								"comment": "       Inserts $(D stuff) in the container. $(D stuff) can be a value\n       convertible to $(D ElementType) or a range of objects\n       convertible to $(D ElementType).\n\n       The $(D stable) version guarantees that ranges iterating over\n       the container are never invalidated. Client code that counts on\n       non-invalidating insertion should use $(D stableInsert).\n\n       Returns: The number of elements added.\n\n       Complexity: $(BIGOH m * log(n)), where $(D m) is the number of\n       elements in $(D stuff)\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableInsert",
								"line": 1870,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "linearInsert",
								"line": 1876,
								"comment": "       Same as $(D insert(stuff)) and $(D stableInsert(stuff))\n       respectively, but relax the complexity constraint to linear.\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"name": "stableLinearInsert",
								"line": 1878,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 1892,
								"comment": "       Picks one value in the container, removes it from the\n       container, and returns it. The stable version behaves the same,\n       but guarantees that ranges iterating over the container are\n       never invalidated.\n\n       Precondition: $(D !empty)\n\n       Returns: The element removed.\n\n       Complexity: $(BIGOH log(n))\n",
								"type": "T()",
								"endline": 1897,
								"char": 7,
								"kind": "function"
							},
							{
								"name": "stableRemoveAny",
								"line": 1899,
								"comment": "ditto\n",
								"type": "removeAny",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 1924,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1947,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 1924,
								"comment": "       Inserts $(D value) to the back of the container. $(D stuff) can\n       be a value convertible to $(D ElementType) or a range of\n       objects convertible to $(D ElementType). The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: The number of elements inserted\n\n       Complexity: $(BIGOH log(n))\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "is(Stuff : bool)",
								"char": 12,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBack",
										"line": 1949,
										"type": "size_t(Stuff stuff)",
										"parameters": [
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 1960,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBack",
								"line": 1949,
								"comment": "Ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "isInputRange!Stuff && is(ElementType!Stuff : bool)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertBack",
								"line": 1962,
								"comment": "ditto\n",
								"type": "insertBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 1976,
								"comment": "       Removes the value at the front or back of the container. The\n       stable version behaves the same, but guarantees that ranges\n       iterating over the container are never invalidated. The\n       optional parameter $(D howMany) instructs removal of that many\n       elements. If $(D howMany > n), all elements are removed and no\n       exception is thrown.\n\n       Precondition: $(D !empty)\n\n       Complexity: $(BIGOH log(n)).\n",
								"type": "void()",
								"endline": 1990,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "stableRemoveBack",
								"line": 1992,
								"comment": "ditto\n",
								"type": "removeBack",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeBack",
								"line": 2008,
								"comment": "       Removes $(D howMany) values at the front or back of the\n       container. Unlike the unparameterized versions above, these\n       functions do not throw if they could not remove $(D howMany)\n       elements. Instead, if $(D howMany > n), all elements are\n       removed. The returned value is the effective number of elements\n       removed. The stable version behaves the same, but guarantees\n       that ranges iterating over the container are never invalidated.\n\n       Returns: The number of elements removed\n\n       Complexity: $(BIGOH howMany * log(n)).\n\nditto\n",
								"type": "size_t(size_t howMany)",
								"parameters": [
									{
										"name": "howMany",
										"type": "size_t"
									}
								],
								"endline": 2020,
								"char": 12,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertBefore",
										"line": 2047,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 2057,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertBefore",
								"line": 2047,
								"comment": "       Inserts $(D stuff) before, after, or instead range $(D r),\n       which must be a valid range previously extracted from this\n       container. $(D stuff) can be a value convertible to $(D\n       ElementType) or a range of objects convertible to $(D\n       ElementType). The stable version behaves the same, but\n       guarantees that ranges iterating over the container are never\n       invalidated.\n\n       Returns: The number of values inserted.\n\n       Complexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertBefore",
								"line": 2059,
								"comment": "ditto\n",
								"type": "insertBefore",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "insertAfter",
										"line": 2076,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 2086,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "insertAfter",
								"line": 2076,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableInsertAfter",
								"line": 2088,
								"comment": "ditto\n",
								"type": "insertAfter",
								"char": 5,
								"kind": "alias"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "replace",
										"line": 2100,
										"type": "size_t(Range r, Stuff stuff)",
										"parameters": [
											{
												"name": "r",
												"type": "Range"
											},
											{
												"name": "stuff",
												"type": "Stuff"
											}
										],
										"endline": 2115,
										"char": 12,
										"kind": "function"
									}
								],
								"name": "replace",
								"line": 2100,
								"comment": "ditto\n",
								"parameters": [
									{
										"name": "Stuff",
										"kind": "type"
									}
								],
								"constraint": "is(Stuff : bool)",
								"char": 12,
								"kind": "template"
							},
							{
								"name": "stableReplace",
								"line": 2117,
								"comment": "ditto\n",
								"type": "replace",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "linearRemove",
								"line": 2140,
								"comment": "       Removes all elements belonging to $(D r), which must be a range\n       obtained originally from this container. The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: A range spanning the remaining elements in the container that\n       initially were right after $(D r).\n\n       Complexity: $(BIGOH n)\n",
								"type": "Range(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 2146,
								"char": 11,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Array",
				"line": 1360,
				"comment": "\n\n\n\n_Array specialized for $(D bool). Packs together values efficiently by\nallocating one bit per element.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(Unqual!T == bool)",
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module provides an $(D Array) type with deterministic memory usage not\nreliant on the GC, as an alternative to the built-in arrays.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_array.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/container/binaryheap.d",
		"name": "std.container.binaryheap",
		"members": [
			{
				"members": [
					{
						"name": "BinaryHeap",
						"line": 57,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 174,
								"comment": "       Converts the store $(D s) into a heap. If $(D initialSize) is\n       specified, only the first $(D initialSize) elements in $(D s)\n       are transformed into a heap, after which the heap can grow up\n       to $(D r.length) (if $(D Store) is a range) or indefinitely (if\n       $(D Store) is a container with $(D insertBack)). Performs\n       $(BIGOH min(r.length, initialSize)) evaluations of $(D less).\n",
								"type": "(Store s, size_t initialSize = size_t.max)",
								"parameters": [
									{
										"name": "s",
										"type": "Store"
									},
									{
										"name": "initialSize",
										"type": "size_t",
										"default": "size_t.max"
									}
								],
								"endline": 177,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "acquire",
								"line": 183,
								"comment": "Takes ownership of a store. After this, manipulating $(D s) may make\nthe heap work incorrectly.\n",
								"type": "void(Store s, size_t initialSize = size_t.max)",
								"parameters": [
									{
										"name": "s",
										"type": "Store"
									},
									{
										"name": "initialSize",
										"type": "size_t",
										"default": "size_t.max"
									}
								],
								"endline": 195,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "assume",
								"line": 201,
								"comment": "Takes ownership of a store assuming it already was organized as a\nheap.\n",
								"type": "void(Store s, size_t initialSize = size_t.max)",
								"parameters": [
									{
										"name": "s",
										"type": "Store"
									},
									{
										"name": "initialSize",
										"type": "size_t",
										"default": "size_t.max"
									}
								],
								"endline": 207,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "release",
								"line": 213,
								"comment": "Clears the heap. Returns the portion of the store from $(D 0) up to\n$(D length), which satisfies the $(LUCKY heap property).\n",
								"type": "()",
								"endline": 223,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 228,
								"comment": "Returns $(D true) if the heap is _empty, $(D false) otherwise.\n",
								"type": "@property bool()",
								"endline": 231,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "dup",
								"line": 237,
								"comment": "Returns a duplicate of the heap. The underlying store must also\nsupport a $(D dup) method.\n",
								"type": "@property BinaryHeap()",
								"endline": 243,
								"char": 26,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "length",
								"line": 248,
								"comment": "Returns the _length of the heap.\n",
								"type": "@property size_t()",
								"endline": 251,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 258,
								"comment": "Returns the _capacity of the heap, which is the length of the\nunderlying store (if the store is a range) or the _capacity of the\nunderlying store (if the store is a container).\n",
								"type": "@property size_t()",
								"endline": 269,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 275,
								"comment": "Returns a copy of the _front of the heap, which is the largest element\naccording to $(D less).\n",
								"type": "@property ElementType!Store()",
								"endline": 279,
								"char": 33,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "clear",
								"line": 284,
								"comment": "Clears the heap by detaching it from the underlying store.\n",
								"type": "void()",
								"endline": 287,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "insert",
								"line": 293,
								"comment": "Inserts $(D value) into the store. If the underlying store is a range\nand $(D length == capacity), throws an exception.\n",
								"type": "size_t(ElementType!Store value)",
								"parameters": [
									{
										"name": "value",
										"type": "ElementType!Store"
									}
								],
								"endline": 329,
								"char": 12,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "removeFront",
								"line": 334,
								"comment": "Removes the largest element from the heap.\n",
								"type": "void()",
								"endline": 346,
								"char": 10,
								"kind": "function"
							},
							{
								"name": "popFront",
								"line": 349,
								"comment": "ditto\n",
								"type": "removeFront",
								"char": 5,
								"kind": "alias"
							},
							{
								"endchar": 5,
								"name": "removeAny",
								"line": 357,
								"comment": "Removes the largest element from the heap and returns a copy of\nit. The element still resides in the heap's store. For performance\nreasons you may want to use $(D removeFront) with heaps of objects\nthat are expensive to copy.\n",
								"type": "ElementType!Store()",
								"endline": 361,
								"char": 23,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "replaceFront",
								"line": 366,
								"comment": "Replaces the largest element in the store with $(D value).\n",
								"type": "void(ElementType!Store value)",
								"parameters": [
									{
										"name": "value",
										"type": "ElementType!Store"
									}
								],
								"endline": 373,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "conditionalInsert",
								"line": 383,
								"comment": "If the heap has room to grow, inserts $(D value) into the store and\nreturns $(D true). Otherwise, if $(D less(value, front)), calls $(D\nreplaceFront(value)) and returns again $(D true). Otherwise, leaves\nthe heap unaffected and returns $(D false). This method is useful in\nscenarios where the smallest $(D k) elements of a set of candidates\nmust be collected.\n",
								"type": "bool(ElementType!Store value)",
								"parameters": [
									{
										"name": "value",
										"type": "ElementType!Store"
									}
								],
								"endline": 398,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "BinaryHeap",
				"line": 57,
				"comment": "Implements a $(WEB en.wikipedia.org/wiki/Binary_heap, binary heap)\ncontainer on top of a given random-access range type (usually $(D\nT[])) or a random-access container type (usually $(D Array!T)). The\ndocumentation of $(D BinaryHeap) will refer to the underlying range or\ncontainer as the $(I store) of the heap.\n\nThe binary heap induces structure over the underlying store such that\naccessing the largest element (by using the $(D front) property) is a\n$(BIGOH 1) operation and extracting it (by using the $(D\nremoveFront()) method) is done fast in $(BIGOH log n) time.\n\nIf $(D less) is the less-than operator, which is the default option,\nthen $(D BinaryHeap) defines a so-called max-heap that optimizes\nextraction of the $(I largest) elements. To define a min-heap,\ninstantiate BinaryHeap with $(D \"a > b\") as its predicate.\n\nSimply extracting elements from a $(D BinaryHeap) container is\ntantamount to lazily fetching elements of $(D Store) in descending\norder. Extracting elements from the $(D BinaryHeap) to completion\nleaves the underlying store sorted in ascending order but, again,\nyields elements in descending order.\n\nIf $(D Store) is a range, the $(D BinaryHeap) cannot grow beyond the\nsize of that range. If $(D Store) is a container that supports $(D\ninsertBack), the $(D BinaryHeap) may grow by adding elements to the\ncontainer.\nExample:\nExample from \"Introduction to Algorithms\" Cormen et al, p 146$(DDOX_UNITTEST_HEADER __unittestL402_2485)\n---\nimport std.algorithm : equal;\nint[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];\nauto h = heapify(a);\n// largest element\nassert(h.front == 16);\n// a has the heap property\nassert(equal(a, [ 16, 14, 10, 8, 7, 9, 3, 2, 4, 1 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL402_2485)\nExample:\n$(D BinaryHeap) implements the standard input range interface, allowing\n\nlazy iteration of the underlying range in descending order.$(DDOX_UNITTEST_HEADER __unittestL415_2486)\n---\nimport std.algorithm : equal;\nimport std.range : take;\nint[] a = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7];\nauto top5 = heapify(a).take(5);\nassert(top5.equal([16, 14, 10, 9, 8]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL415_2486)\n",
				"parameters": [
					{
						"name": "Store",
						"kind": "type"
					},
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					}
				],
				"constraint": "isRandomAccessRange!Store || isRandomAccessRange!(typeof(Store.init[]))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "heapify",
						"line": 428,
						"type": "BinaryHeap!(Store, less)(Store s, size_t initialSize = size_t.max)",
						"parameters": [
							{
								"name": "s",
								"type": "Store"
							},
							{
								"name": "initialSize",
								"type": "size_t",
								"default": "size_t.max"
							}
						],
						"endline": 432,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "heapify",
				"line": 428,
				"comment": "Convenience function that returns a $(D BinaryHeap!Store) object\ninitialized with $(D s) and $(D initialSize).\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Store",
						"kind": "type"
					}
				],
				"char": 26,
				"kind": "template"
			}
		],
		"comment": "This module provides a $(D BinaryHeap) adaptor that makes a binary heap out of\nany user-provided random-access range.\n\nThis module is a submodule of $(LINK2 std_container.html, std.container).\n\nSource: $(PHOBOSSRC std/container/_binaryheap.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/mutation.d",
		"name": "std.algorithm.mutation",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "bringToFront",
						"line": 112,
						"type": "size_t(Range1 front, Range2 back)",
						"parameters": [
							{
								"name": "front",
								"type": "Range1"
							},
							{
								"name": "back",
								"type": "Range2"
							}
						],
						"endline": 171,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "bringToFront",
				"line": 112,
				"comment": "The $(D bringToFront) function has considerable flexibility and\nusefulness. It can rotate elements in one buffer left or right, swap\nbuffers of equal length, and even move elements across disjoint\nbuffers of different types and different lengths.\n\n$(D bringToFront) takes two ranges $(D front) and $(D back), which may\nbe of different types. Considering the concatenation of $(D front) and\n$(D back) one unified range, $(D bringToFront) rotates that unified\nrange such that all elements in $(D back) are brought to the beginning\nof the unified range. The relative ordering of elements in $(D front)\nand $(D back), respectively, remains unchanged.\n\nPerforms $(BIGOH max(front.length, back.length)) evaluations of $(D\nswap).\n\nPreconditions:\n\nEither $(D front) and $(D back) are disjoint, or $(D back) is\nreachable from $(D front) and $(D front) is not reachable from $(D\nback).\n\nReturns:\n\nThe number of elements brought to the front, i.e., the length of $(D\nback).\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_rotate.html, STL's rotate)\nExample:\nThe simplest use of $(D bringToFront) is for rotating elements in a\nbuffer. For example:$(DDOX_UNITTEST_HEADER __unittestL177_2489)\n---\nauto arr = [4, 5, 6, 7, 1, 2, 3];\nauto p = bringToFront(arr[0 .. 4], arr[4 .. $]);\nassert(p == arr.length - 4);\nassert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL177_2489)\nExample:\nThe $(D front) range may actually \"step over\" the $(D back)\nrange. This is very useful with forward ranges that cannot compute\ncomfortably right-bounded subranges like $(D arr[0 .. 4]) above. In\nthe example below, $(D r2) is a right subrange of $(D r1).$(DDOX_UNITTEST_HEADER __unittestL191_2490)\n---\nimport std.algorithm.comparison : equal;\nimport std.container : SList;\n\nauto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);\nauto r1 = list[];\nauto r2 = list[]; popFrontN(r2, 4);\nassert(equal(r2, [ 1, 2, 3 ]));\nbringToFront(r1, r2);\nassert(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL191_2490)\nExample:\nElements can be swapped across ranges of different types:$(DDOX_UNITTEST_HEADER __unittestL208_2491)\n---\nimport std.algorithm.comparison : equal;\nimport std.container : SList;\n\nauto list = SList!(int)(4, 5, 6, 7);\nauto vec = [ 1, 2, 3 ];\nbringToFront(list[], vec);\nassert(equal(list[], [ 1, 2, 3, 4 ]));\nassert(equal(vec, [ 5, 6, 7 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL208_2491)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isForwardRange!Range2",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "copy",
						"line": 297,
						"type": "TargetRange(SourceRange source, TargetRange target)",
						"parameters": [
							{
								"name": "source",
								"type": "SourceRange"
							},
							{
								"name": "target",
								"type": "TargetRange"
							}
						],
						"endline": 351,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "copy",
				"line": 297,
				"comment": "Copies the content of $(D source) into $(D target) and returns the\nremaining (unfilled) part of $(D target).\n\nPreconditions: $(D target) shall have enough room to accomodate\nthe entirety of $(D source).\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_copy.html, STL's _copy)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL354_2493)\n---\nint[] a = [ 1, 5 ];\nint[] b = [ 9, 8 ];\nint[] buf = new int[](a.length + b.length + 10);\nauto rem = a.copy(buf);    // copy a into buf\nrem = b.copy(rem);         // copy b into remainder of buf\nassert(buf[0 .. a.length + b.length] == [1, 5, 9, 8]);\nassert(rem.length == 10);   // unused slots in buf\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL354_2493)\nExample:\nAs long as the target range elements support assignment from source\nrange elements, different types of ranges are accepted:$(DDOX_UNITTEST_HEADER __unittestL369_2494)\n---\nfloat[] src = [ 1.0f, 5 ];\ndouble[] dest = new double[src.length];\nsrc.copy(dest);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL369_2494)\nExample:\nTo _copy at most $(D n) elements from a range, you may want to use\n$(XREF range, take):$(DDOX_UNITTEST_HEADER __unittestL380_2495)\n---\nimport std.range;\nint[] src = [ 1, 5, 8, 9, 10 ];\nauto dest = new int[](3);\nsrc.take(dest.length).copy(dest);\nassert(dest == [ 1, 5, 8 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL380_2495)\nExample:\nTo _copy just those elements from a range that satisfy a predicate,\nuse $(LREF filter):$(DDOX_UNITTEST_HEADER __unittestL393_2497)\n---\nimport std.algorithm.iteration : filter;\nint[] src = [ 1, 5, 8, 9, 10, 1, 2, 0 ];\nauto dest = new int[src.length];\nauto rem = src\n    .filter!(a => (a & 1) == 1)\n    .copy(dest);\nassert(dest[0 .. $ - rem.length] == [ 1, 5, 9, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL393_2497)\nExample:\n$(XREF range, retro) can be used to achieve behavior similar to\n$(WEB sgi.com/tech/stl/copy_backward.html, STL's copy_backward'):$(DDOX_UNITTEST_HEADER __unittestL408_2498)\n---\nimport std.algorithm, std.range;\nint[] src = [1, 2, 4];\nint[] dest = [0, 0, 0, 0, 0];\nsrc.retro.copy(dest.retro);\nassert(dest == [0, 0, 1, 2, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL408_2498)\n",
				"parameters": [
					{
						"name": "SourceRange",
						"kind": "type"
					},
					{
						"name": "TargetRange",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!SourceRange && isOutputRange!(TargetRange, ElementType!SourceRange)",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fill",
						"line": 462,
						"type": "void(Range range, Value value)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "value",
								"type": "Value"
							}
						],
						"endline": 482,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "fill",
				"line": 462,
				"comment": "Assigns $(D value) to each element of input _range $(D range).\n\nParams:\n        range = An\n                $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n                that exposes references to its elements and has assignable\n                elements\n        value = Assigned to each element of range\n\nSee_Also:\n        $(LREF uninitializedFill)\n        $(LREF initializeAll)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL485_2500)\n---\nint[] a = [ 1, 2, 3, 4 ];\nfill(a, 5);\nassert(a == [ 5, 5, 5, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL485_2500)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Value",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(range.front = value))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "fill",
						"line": 571,
						"type": "void(Range1 range, Range2 filler)",
						"parameters": [
							{
								"name": "range",
								"type": "Range1"
							},
							{
								"name": "filler",
								"type": "Range2"
							}
						],
						"endline": 638,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "fill",
				"line": 571,
				"comment": "Fills $(D range) with a pattern copied from $(D filler). The length of\n$(D range) does not have to be a multiple of the length of $(D\nfiller). If $(D filler) is empty, an exception is thrown.\n\nParams:\n    range = An $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n            that exposes references to its elements and has assignable elements.\n    filler = The\n             $(XREF_PACK_NAMED _range,primitives,isForwardRange,forward _range)\n             representing the _fill pattern.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL641_2504)\n---\nint[] a = [ 1, 2, 3, 4, 5 ];\nint[] b = [ 8, 9 ];\nfill(a, b);\nassert(a == [ 8, 9, 8, 9, 8 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL641_2504)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && (isForwardRange!Range2 || isInputRange!Range2 && isInfinite!Range2) && is(typeof(Range1.init.front = Range2.init.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "initializeAll",
						"line": 703,
						"type": "void(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 730,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "initializeAll",
				"line": 703,
				"comment": "Initializes all elements of $(D range) with their $(D .init) value.\nAssumes that the elements of the range are uninitialized.\n\nParams:\n        range = An\n                $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n                that exposes references to its elements and has assignable\n                elements\n\nSee_Also:\n        $(LREF fill)\n        $(LREF uninitializeFill)\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\ninitializeAll(s);\nassert(s == [ 0, 0, 0, 0, 0 ]);\n----\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLvalueElements!Range && hasAssignableElements!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "move",
						"line": 839,
						"type": "void(ref T source, ref T target)",
						"parameters": [
							{
								"name": "source",
								"type": "T",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 887,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "move",
				"line": 839,
				"comment": "Moves $(D source) into $(D target) via a destructive copy.\n\nParams:\n    source = Data to copy. If a destructor or postblit is defined, it is reset\n        to its $(D .init) value after it is moved into target.  Note that data\n        with internal pointers that point to itself cannot be moved, and will\n        trigger an assertion failure.\n    target = Where to copy into. The destructor, if any, is invoked before the\n        copy is performed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL890_2507)\n---\nObject obj1 = new Object;\nObject obj2 = obj1;\nObject obj3;\n\nmove(obj2, obj3);\nassert(obj3 is obj1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL890_2507)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL901_2508)\n---\n// Structs without destructors are simply copied\nstruct S1\n{\n    int a = 1;\n    int b = 2;\n}\nS1 s11 = { 10, 11 };\nS1 s12;\n\nmove(s11, s12);\n\nassert(s11.a == 10 && s11.b == 11 &&\n       s12.a == 10 && s12.b == 11);\n\n// But structs with destructors or postblits are reset to their .init value\n// after copying to the target.\nstruct S2\n{\n    int a = 1;\n    int b = 2;\n\n    ~this() { }\n}\nS2 s21 = { 3, 4 };\nS2 s22;\n\nmove(s21, s22);\n\nassert(s21.a == 1 && s21.b == 2 &&\n       s22.a == 3 && s22.b == 4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL901_2508)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "move",
						"line": 996,
						"type": "T(ref T source)",
						"parameters": [
							{
								"name": "source",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1042,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "move",
				"line": 996,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveAll",
						"line": 1184,
						"type": "Range2(Range1 src, Range2 tgt)",
						"parameters": [
							{
								"name": "src",
								"type": "Range1"
							},
							{
								"name": "tgt",
								"type": "Range2"
							}
						],
						"endline": 1208,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "moveAll",
				"line": 1184,
				"comment": "For each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)).\n\nPreconditions:\n$(D walkLength(src) <= walkLength(tgt)).\nAn exception will be thrown if this condition does not hold, i.e., there is not\nenough room in $(D tgt) to accommodate all of $(D src).\n\nParams:\n    src = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        movable elements.\n    tgt = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        elements that elements from $(D src) can be moved into.\n\nReturns: The leftover portion of $(D tgt) after all elements from $(D src) have\nbeen moved.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1211_2514)\n---\nint[] a = [ 1, 2, 3 ];\nint[] b = new int[5];\nassert(moveAll(a, b) is b[3 .. $]);\nassert(a == b[0 .. 3]);\nassert(a == [ 1, 2, 3 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1211_2514)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(move(src.front, tgt.front)))",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveSome",
						"line": 1235,
						"type": "Tuple!(Range1, Range2)(Range1 src, Range2 tgt)",
						"parameters": [
							{
								"name": "src",
								"type": "Range1"
							},
							{
								"name": "tgt",
								"type": "Range2"
							}
						],
						"endline": 1247,
						"char": 24,
						"kind": "function"
					}
				],
				"name": "moveSome",
				"line": 1235,
				"comment": "For each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Stops\nwhen either $(D src) or $(D tgt) have been exhausted.\n\nParams:\n    src = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        movable elements.\n    tgt = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) with\n        elements that elements from $(D src) can be moved into.\n\nReturns: The leftover portions of the two ranges after one or the other of the\nranges have been exhausted.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1250_2515)\n---\nint[] a = [ 1, 2, 3, 4, 5 ];\nint[] b = new int[3];\nassert(moveSome(a, b)[0] is a[3 .. $]);\nassert(a[0 .. 3] == b);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1250_2515)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(move(src.front, tgt.front)))",
				"char": 24,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "unstable",
						"line": 1297,
						"value": "0",
						"comment": "       Allows freely swapping of elements as long as the output\n       satisfies the algorithm's requirements.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "semistable",
						"line": 1302,
						"value": "1",
						"comment": "       In algorithms partitioning ranges in two, preserve relative\n       ordering of elements only to the left of the partition point.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "stable",
						"line": 1307,
						"value": "2",
						"comment": "       Preserve the relative ordering of elements to the largest\n       extent allowed by the algorithm's requirements.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SwapStrategy",
				"line": 1291,
				"comment": "Defines the swapping strategy for algorithms that need to swap\nelements in a range (such as partition and sort). The strategy\nconcerns the swapping of elements that are not the core concern of the\nalgorithm. For example, consider an algorithm that sorts $(D [ \"abc\",\n\"b\", \"aBc\" ]) according to $(D toUpper(a) < toUpper(b)). That\nalgorithm might choose to swap the two equivalent strings $(D \"abc\")\nand $(D \"aBc\"). That does not affect the sorting since both $(D [\n\"abc\", \"aBc\", \"b\" ]) and $(D [ \"aBc\", \"abc\", \"b\" ]) are valid\noutcomes.\n\nSome situations require that the algorithm must NOT ever change the\nrelative ordering of equivalent elements (in the example above, only\n$(D [ \"abc\", \"aBc\", \"b\" ]) would be the correct result). Such\nalgorithms are called $(B stable). If the ordering algorithm may swap\nequivalent elements discretionarily, the ordering is called $(B\nunstable).\n\nYet another class of algorithms may choose an intermediate tradeoff by\nbeing stable only on a well-defined subrange of the range. There is no\nestablished terminology for such behavior; this library calls it $(B\nsemistable).\n\nGenerally, the $(D stable) ordering strategy may be more costly in\ntime and/or space than the other two because it imposes additional\nconstraints. Similarly, $(D semistable) may be costlier than $(D\nunstable). As (semi-)stability is not needed very often, the ordering\nalgorithms in this module parameterized by $(D SwapStrategy) all\nchoose $(D SwapStrategy.unstable) as the default.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "remove",
						"line": 1384,
						"type": "Range(Range range, Offset offset)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "offset",
								"type": "Offset"
							}
						],
						"endline": 1464,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "remove",
				"line": 1384,
				"comment": "Eliminates elements at given offsets from $(D range) and returns the\nshortened range. In the simplest call, one element is removed.\n\n----\nint[] a = [ 3, 5, 7, 8 ];\nassert(remove(a, 1) == [ 3, 7, 8 ]);\nassert(a == [ 3, 7, 8, 8 ]);\n----\n\nIn the case above the element at offset $(D 1) is removed and $(D\nremove) returns the range smaller by one element. The original array\nhas remained of the same length because all functions in $(D\nstd.algorithm) only change $(I content), not $(I topology). The value\n$(D 8) is repeated because $(LREF move) was invoked to\nmove elements around and on integers $(D move) simply copies the source to\nthe destination. To replace $(D a) with the effect of the removal,\nsimply assign $(D a = remove(a, 1)). The slice will be rebound to the\nshorter array and the operation completes with maximal efficiency.\n\nMultiple indices can be passed into $(D remove). In that case,\nelements at the respective indices are all removed. The indices must\nbe passed in increasing order, otherwise an exception occurs.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, 3, 5) ==\n    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);\n----\n\n(Note how all indices refer to slots in the $(I original) array, not\nin the array as it is being progressively shortened.) Finally, any\ncombination of integral offsets and tuples composed of two integral\noffsets can be passed in.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);\n----\n\nIn this case, the slots at positions 1, 3, 4, and 9 are removed from\nthe array. The tuple passes in a range closed to the left and open to\nthe right (consistent with built-in slices), e.g. $(D tuple(3, 5))\nmeans indices $(D 3) and $(D 4) but not $(D 5).\n\nIf the need is to remove some elements in the range but the order of\nthe remaining elements does not have to be preserved, you may want to\npass $(D SwapStrategy.unstable) to $(D remove).\n\n----\nint[] a = [ 0, 1, 2, 3 ];\nassert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);\n----\n\nIn the case above, the element at slot $(D 1) is removed, but replaced\nwith the last element of the range. Taking advantage of the relaxation\nof the stability requirement, $(D remove) moved elements from the end\nof the array over the slots to be removed. This way there is less data\nmovement to be done which improves the execution time of the function.\n\nThe function $(D remove) works on any forward range. The moving\nstrategy is (listed from fastest to slowest): $(UL $(LI If $(D s ==\nSwapStrategy.unstable && isRandomAccessRange!Range && hasLength!Range\n&& hasLvalueElements!Range), then elements are moved from the end\nof the range into the slots to be filled. In this case, the absolute\nminimum of moves is performed.)  $(LI Otherwise, if $(D s ==\nSwapStrategy.unstable && isBidirectionalRange!Range && hasLength!Range\n&& hasLvalueElements!Range), then elements are still moved from the\nend of the range, but time is spent on advancing between slots by repeated\ncalls to $(D range.popFront).)  $(LI Otherwise, elements are moved\nincrementally towards the front of $(D range); a given element is never\nmoved several times, but more elements are moved than in the previous\ncases.))\n",
				"parameters": [
					{
						"name": "s",
						"defaultValue": "SwapStrategy.stable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Offset",
						"kind": "tuple"
					}
				],
				"constraint": "s != SwapStrategy.stable && isBidirectionalRange!Range && hasLvalueElements!Range && hasLength!Range && Offset.length >= 1",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "remove",
						"line": 1605,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1643,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "remove",
				"line": 1605,
				"comment": "Reduces the length of the bidirectional range $(D range) by removing\nelements that satisfy $(D pred). If $(D s = SwapStrategy.unstable),\nelements are moved from the right end of the range over the elements\nto eliminate. If $(D s = SwapStrategy.stable) (the default),\nelements are moved progressively to front such that their relative\norder is preserved. Returns the filtered range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1646_2521)\n---\nstatic immutable base = [1, 2, 3, 2, 4, 2, 5, 2];\n\nint[] arr = base[].dup;\n\n// using a string-based predicate\nassert(remove!(\"a == 2\")(arr) == [ 1, 3, 4, 5 ]);\n\n// The original array contents have been modified,\n// so we need to reset it to its original state.\n// The length is unmodified however.\narr[] = base[];\n\n// using a lambda predicate\nassert(remove!(a => a == 2)(arr) == [ 1, 3, 4, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1646_2521)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "s",
						"defaultValue": "SwapStrategy.stable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && hasLvalueElements!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 1685,
						"type": "void(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1696,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 1685,
				"comment": "Reverses $(D r) in-place.  Performs $(D r.length / 2) evaluations of $(D\nswap).\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_reverse.html, STL's _reverse)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1699_2523)\n---\nint[] arr = [ 1, 2, 3 ];\nreverse(arr);\nassert(arr == [ 3, 2, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1699_2523)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && !isRandomAccessRange!Range && hasSwappableElements!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 1707,
						"type": "void(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1717,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 1707,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "reverse",
						"line": 1741,
						"type": "void(Char[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "Char[]"
							}
						],
						"endline": 1762,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "reverse",
				"line": 1741,
				"comment": "Reverses $(D r) in-place, where $(D r) is a narrow string (having\nelements of type $(D char) or $(D wchar)). UTF sequences consisting of\nmultiple code units are preserved properly.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1765_2525)\n---\nchar[] arr = \"hello\\U00010143\\u0100\\U00010143\".dup;\nreverse(arr);\nassert(arr == \"\\U00010143\\u0100\\U00010143olleh\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1765_2525)\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!(Char[]) && !is(Char == const) && !is(Char == immutable)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strip",
						"line": 1825,
						"type": "Range(Range range, E element)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "element",
								"type": "E"
							}
						],
						"endline": 1829,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "strip",
				"line": 1825,
				"comment": "    The strip group of functions allow stripping of either leading, trailing,\n    or both leading and trailing elements.\n\n    The $(D stripLeft) function will strip the $(D front) of the range,\n    the $(D stripRight) function will strip the $(D back) of the range,\n    while the $(D strip) function will strip both the $(D front) and $(D back)\n    of the range.\n\n    Note that the $(D strip) and $(D stripRight) functions require the range to\n    be a $(LREF BidirectionalRange) range.\n\n    All of these functions come in two varieties: one takes a target element,\n    where the range will be stripped as long as this element can be found.\n    The other takes a lambda predicate, where the range will be stripped as\n    long as the predicate returns true.\nExample:\nStrip leading and trailing elements equal to the target element.$(DDOX_UNITTEST_HEADER __unittestL1881_2528)\n---\nassert(\"  foobar  \".strip(' ') == \"foobar\");\nassert(\"00223.444500\".strip('0') == \"223.4445\");\nassert(\"Ã«Ã«ÃªÃ©Ã¼ÅÅpÃ©ÃªÃ«Ã«\".strip('Ã«') == \"ÃªÃ©Ã¼ÅÅpÃ©Ãª\");\nassert([1, 1, 0, 1, 1].strip(1) == [0]);\nassert([0.0, 0.01, 0.01, 0.0].strip(0).length == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1881_2528)\nExample:\nStrip leading and trailing elements while the predicate returns true.$(DDOX_UNITTEST_HEADER __unittestL1891_2534)\n---\nassert(\"  foobar  \".strip!(a => a == ' ')() == \"foobar\");\nassert(\"00223.444500\".strip!(a => a == '0')() == \"223.4445\");\nassert(\"Ã«Ã«ÃªÃ©Ã¼ÅÅpÃ©ÃªÃ«Ã«\".strip!(a => a == 'Ã«')() == \"ÃªÃ©Ã¼ÅÅpÃ©Ãª\");\nassert([1, 1, 0, 1, 1].strip!(a => a == 1)() == [0]);\nassert([0.0, 0.01, 0.5, 0.6, 0.01, 0.0].strip!(a => a < 0.4)().length == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1891_2534)\nExample:\nStrip leading elements equal to the target element.$(DDOX_UNITTEST_HEADER __unittestL1901_2535)\n---\nassert(\"  foobar  \".stripLeft(' ') == \"foobar  \");\nassert(\"00223.444500\".stripLeft('0') == \"223.444500\");\nassert(\"Å¯Å¯Å±niÃ§odÃªÃ©Ã©\".stripLeft('Å¯') == \"Å±niÃ§odÃªÃ©Ã©\");\nassert([1, 1, 0, 1, 1].stripLeft(1) == [0, 1, 1]);\nassert([0.0, 0.01, 0.01, 0.0].stripLeft(0).length == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1901_2535)\nExample:\nStrip leading elements while the predicate returns true.$(DDOX_UNITTEST_HEADER __unittestL1911_2541)\n---\nassert(\"  foobar  \".stripLeft!(a => a == ' ')() == \"foobar  \");\nassert(\"00223.444500\".stripLeft!(a => a == '0')() == \"223.444500\");\nassert(\"Å¯Å¯Å±niÃ§odÃªÃ©Ã©\".stripLeft!(a => a == 'Å¯')() == \"Å±niÃ§odÃªÃ©Ã©\");\nassert([1, 1, 0, 1, 1].stripLeft!(a => a == 1)() == [0, 1, 1]);\nassert([0.0, 0.01, 0.10, 0.5, 0.6].stripLeft!(a => a < 0.4)().length == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1911_2541)\nExample:\nStrip trailing elements equal to the target element.$(DDOX_UNITTEST_HEADER __unittestL1921_2542)\n---\nassert(\"  foobar  \".stripRight(' ') == \"  foobar\");\nassert(\"00223.444500\".stripRight('0') == \"00223.4445\");\nassert(\"Ã¹niÃ§odÃªÃ©Ã©\".stripRight('Ã©') == \"Ã¹niÃ§odÃª\");\nassert([1, 1, 0, 1, 1].stripRight(1) == [1, 1, 0]);\nassert([0.0, 0.01, 0.01, 0.0].stripRight(0).length == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1921_2542)\nExample:\nStrip trailing elements while the predicate returns true.$(DDOX_UNITTEST_HEADER __unittestL1931_2548)\n---\nassert(\"  foobar  \".stripRight!(a => a == ' ')() == \"  foobar\");\nassert(\"00223.444500\".stripRight!(a => a == '0')() == \"00223.4445\");\nassert(\"Ã¹niÃ§odÃªÃ©Ã©\".stripRight!(a => a == 'Ã©')() == \"Ã¹niÃ§odÃª\");\nassert([1, 1, 0, 1, 1].stripRight!(a => a == 1)() == [1, 1, 0]);\nassert([0.0, 0.01, 0.10, 0.5, 0.6].stripRight!(a => a > 0.4)().length == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1931_2548)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(range.front == element) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strip",
						"line": 1832,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1836,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "strip",
				"line": 1832,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(pred(range.back)) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripLeft",
						"line": 1839,
						"type": "Range(Range range, E element)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "element",
								"type": "E"
							}
						],
						"endline": 1844,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripLeft",
				"line": 1839,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(range.front == element) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripLeft",
						"line": 1847,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1854,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripLeft",
				"line": 1847,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(pred(range.front)) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripRight",
						"line": 1857,
						"type": "Range(Range range, E element)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "element",
								"type": "E"
							}
						],
						"endline": 1866,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripRight",
				"line": 1857,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(range.back == element) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stripRight",
						"line": 1869,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1878,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "stripRight",
				"line": 1869,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range && is(typeof(pred(range.back)) : bool)",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swap",
						"line": 1955,
						"type": "pure nothrow @nogc @trusted void(ref T lhs, ref T rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "rhs",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 2001,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "swap",
				"line": 1955,
				"comment": "Swaps $(D lhs) and $(D rhs). The instances $(D lhs) and $(D rhs) are moved in\nmemory, without ever calling $(D opAssign), nor any other function. $(D T)\nneed not be assignable at all to be swapped.\n\nIf $(D lhs) and $(D rhs) reference the same instance, then nothing is done.\n\n$(D lhs) and $(D rhs) must be mutable. If $(D T) is a struct or union, then\nits fields must also all be (recursively) mutable.\n\nParams:\n    lhs = Data to be swapped with $(D rhs).\n    rhs = Data to be swapped with $(D lhs).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2004_2549)\n---\n// Swapping POD (plain old data) types:\nint a = 42, b = 34;\nswap(a, b);\nassert(a == 34 && b == 42);\n\n// Swapping structs with indirection:\nstatic struct S { int x; char c; int[] y; }\nS s1 = { 0, 'z', [ 1, 2 ] };\nS s2 = { 42, 'a', [ 4, 6 ] };\nswap(s1, s2);\nassert(s1.x == 42);\nassert(s1.c == 'a');\nassert(s1.y == [ 4, 6 ]);\n\nassert(s2.x == 0);\nassert(s2.c == 'z');\nassert(s2.y == [ 1, 2 ]);\n\n// Immutables cannot be swapped:\nimmutable int imm1, imm2;\nstatic assert(!__traits(compiles, swap(imm1, imm2)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2004_2549)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2030_2550)\n---\n// Non-copyable types can still be swapped.\nstatic struct NoCopy\n{\n    this(this) { assert(0); }\n    int n;\n    string s;\n}\nNoCopy nc1, nc2;\nnc1.n = 127; nc1.s = \"abc\";\nnc2.n = 513; nc2.s = \"uvwxyz\";\n\nswap(nc1, nc2);\nassert(nc1.n == 513 && nc1.s == \"uvwxyz\");\nassert(nc2.n == 127 && nc2.s == \"abc\");\n\nswap(nc1, nc1);\nswap(nc2, nc2);\nassert(nc1.n == 513 && nc1.s == \"uvwxyz\");\nassert(nc2.n == 127 && nc2.s == \"abc\");\n\n// Types containing non-copyable fields can also be swapped.\nstatic struct NoCopyHolder\n{\n    NoCopy noCopy;\n}\nNoCopyHolder h1, h2;\nh1.noCopy.n = 31; h1.noCopy.s = \"abc\";\nh2.noCopy.n = 65; h2.noCopy.s = null;\n\nswap(h1, h2);\nassert(h1.noCopy.n == 65 && h1.noCopy.s == null);\nassert(h2.noCopy.n == 31 && h2.noCopy.s == \"abc\");\n\nswap(h1, h1);\nswap(h2, h2);\nassert(h1.noCopy.n == 65 && h1.noCopy.s == null);\nassert(h2.noCopy.n == 31 && h2.noCopy.s == \"abc\");\n\n// Const types cannot be swapped.\nconst NoCopy const1, const2;\nstatic assert(!__traits(compiles, swap(const1, const2)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2030_2550)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isBlitAssignable!T && !is(typeof(lhs.proxySwap(rhs)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swapRanges",
						"line": 2196,
						"type": "Tuple!(Range1, Range2)(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 2206,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "swapRanges",
				"line": 2196,
				"comment": "Swaps all elements of $(D r1) with successive elements in $(D r2).\nReturns a tuple containing the remainder portions of $(D r1) and $(D\nr2) that were not swapped (one of them will be empty). The ranges may\nbe of different types but must have the same element type and support\nswapping.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2209_2558)\n---\nint[] a = [ 100, 101, 102, 103 ];\nint[] b = [ 0, 1, 2, 3 ];\nauto c = swapRanges(a[1 .. 3], b[2 .. 4]);\nassert(c[0].empty && c[1].empty);\nassert(a == [ 100, 2, 3, 103 ]);\nassert(b == [ 0, 1, 101, 102 ]);\n}\n\n/**\nInitializes each element of $(D range) with $(D value).\nAssumes that the elements of the range are uninitialized.\nThis is of interest for structs that\ndefine copy constructors (for all other types, $(LREF fill) and\nuninitializedFill are equivalent).\n\nParams:\n    range = An\n            $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n            that exposes references to its elements and has assignable\n            elements\n    value = Assigned to each element of range\n\nSee_Also:\n    $(LREF fill)\n    $(LREF initializeAll)\n\nExample:\n----\nstruct S { ... \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2209_2558)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2 && hasSwappableElements!Range1 && hasSwappableElements!Range2 && is(ElementType!Range1 == ElementType!Range2)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uninitializedFill",
						"line": 2245,
						"type": "void(Range range, Value value)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "value",
								"type": "Value"
							}
						],
						"endline": 2262,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "uninitializedFill",
				"line": 2245,
				"comment": "Initializes each element of $(D range) with $(D value).\nAssumes that the elements of the range are uninitialized.\nThis is of interest for structs that\ndefine copy constructors (for all other types, $(LREF fill) and\nuninitializedFill are equivalent).\n\nParams:\n        range = An\n                $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n                that exposes references to its elements and has assignable\n                elements\n        value = Assigned to each element of range\n\nSee_Also:\n        $(LREF fill)\n        $(LREF initializeAll)\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\nuninitializedFill(s, 42);\nassert(s == [ 42, 42, 42, 42, 42 ]);\n----\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Value",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && hasLvalueElements!Range && is(typeof(range.front = value))",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _mutation algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 bringToFront,\n        If $(D a = [1, 2, 3]) and $(D b = [4, 5, 6, 7]),\n        $(D bringToFront(a, b)) leaves $(D a = [4, 5, 6]) and\n        $(D b = [7, 1, 2, 3]).)\n$(T2 copy,\n        Copies a range to another. If\n        $(D a = [1, 2, 3]) and $(D b = new int[5]), then $(D copy(a, b))\n        leaves $(D b = [1, 2, 3, 0, 0]) and returns $(D b[3 .. $]).)\n$(T2 fill,\n        Fills a range with a pattern,\n        e.g., if $(D a = new int[3]), then $(D fill(a, 4))\n        leaves $(D a = [4, 4, 4]) and $(D fill(a, [3, 4])) leaves\n        $(D a = [3, 4, 3]).)\n$(T2 initializeAll,\n        If $(D a = [1.2, 3.4]), then $(D initializeAll(a)) leaves\n        $(D a = [double.init, double.init]).)\n$(T2 move,\n        $(D move(a, b)) moves $(D a) into $(D b). $(D move(a)) reads $(D a)\n        destructively.)\n$(T2 moveAll,\n        Moves all elements from one range to another.)\n$(T2 moveSome,\n        Moves as many elements as possible from one range to another.)\n$(T2 remove,\n        Removes elements from a range in-place, and returns the shortened\n        range.)\n$(T2 reverse,\n        If $(D a = [1, 2, 3]), $(D reverse(a)) changes it to $(D [3, 2, 1]).)\n$(T2 strip,\n        Strips all leading and trailing elements equal to a value, or that\n        satisfy a predicate.\n        If $(D a = [1, 1, 0, 1, 1]), then $(D strip(a, 1)) and\n        $(D strip!(e => e == 1)(a)) returns $(D [0]).)\n$(T2 stripLeft,\n        Strips all leading elements equal to a value, or that satisfy a\n        predicate.  If $(D a = [1, 1, 0, 1, 1]), then $(D stripLeft(a, 1)) and\n        $(D stripLeft!(e => e == 1)(a)) returns $(D [0, 1, 1]).)\n$(T2 stripRight,\n        Strips all trailing elements equal to a value, or that satisfy a\n        predicate.\n        If $(D a = [1, 1, 0, 1, 1]), then $(D stripRight(a, 1)) and\n        $(D stripRight!(e => e == 1)(a)) returns $(D [1, 1, 0]).)\n$(T2 swap,\n        Swaps two values.)\n$(T2 swapRanges,\n        Swaps all elements of two ranges.)\n$(T2 uninitializedFill,\n        Fills a range (assumed uninitialized) with a value.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_mutation.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/sorting.d",
		"name": "std.algorithm.sorting",
		"members": [
			{
				"members": [
					{
						"name": "no",
						"line": 79,
						"value": "0",
						"comment": "Don't sort output\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 80,
						"value": "1",
						"comment": "Sort output\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "SortOutput",
				"line": 77,
				"comment": "Specifies whether the output of certain algorithm is desired in sorted\nformat.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "completeSort",
						"line": 93,
						"type": "void(SortedRange!(Range1, less) lhs, Range2 rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "SortedRange!(Range1, less)"
							},
							{
								"name": "rhs",
								"type": "Range2"
							}
						],
						"endline": 109,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "completeSort",
				"line": 93,
				"comment": "Sorts the random-access range $(D chain(lhs, rhs)) according to\npredicate $(D less). The left-hand side of the range $(D lhs) is\nassumed to be already sorted; $(D rhs) is assumed to be unsorted. The\nexact strategy chosen depends on the relative sizes of $(D lhs) and\n$(D rhs).  Performs $(BIGOH lhs.length + rhs.length * log(rhs.length))\n(best case) to $(BIGOH (lhs.length + rhs.length) * log(lhs.length +\nrhs.length)) (worst-case) evaluations of $(D swap).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL112_2559)\n---\nimport std.range : assumeSorted;\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 4, 0, 6, 5 ];\ncompleteSort(assumeSorted(a), b);\nassert(a == [ 0, 1, 2 ]);\nassert(b == [ 3, 4, 5, 6 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL112_2559)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "hasLength!Range2 && hasSlicing!Range2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isSorted",
						"line": 128,
						"type": "bool(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 163,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isSorted",
				"line": 128,
				"comment": "Checks whether a forward range is sorted according to the comparison\noperation $(D less). Performs $(BIGOH r.length) evaluations of $(D\nless).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL166_2560)\n---\nint[] arr = [4, 3, 2, 1];\nassert(!isSorted(arr));\nsort(arr);\nassert(isSorted(arr));\nsort!(\"a > b\")(arr);\nassert(isSorted!(\"a > b\")(arr));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL166_2560)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ordered",
						"line": 220,
						"type": "bool(T values)",
						"parameters": [
							{
								"name": "values",
								"type": "T"
							}
						],
						"endline": 237,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "ordered",
				"line": 220,
				"comment": "Like $(D isSorted), returns $(D true) if the given $(D values) are ordered\naccording to the comparison operation $(D less). Unlike $(D isSorted), takes values\ndirectly instead of structured in a range.\n\n$(D ordered) allows repeated values, e.g. $(D ordered(1, 1, 2)) is $(D true). To verify\nthat the values are ordered strictly monotonically, use $(D strictlyOrdered);\n$(D strictlyOrdered(1, 1, 2)) is $(D false).\n\nWith either function, the predicate must be a strict ordering just like with $(D isSorted). For\nexample, using $(D \"a <= b\") instead of $(D \"a < b\") is incorrect and will cause failed\nassertions.\n\nParams:\n    values = The tested value\n    less = The comparison predicate\n\nReturns:\n    $(D true) if the values are ordered; $(D ordered) allows for duplicates,\n    $(D strictlyOrdered) does not.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL256_2566)\n---\nassert(ordered(42, 42, 43));\nassert(!strictlyOrdered(43, 42, 45));\nassert(ordered(42, 42, 43));\nassert(!strictlyOrdered(42, 42, 43));\nassert(!ordered(43, 42, 45));\n// Ordered lexicographically\nassert(ordered(\"Jane\", \"Jim\", \"Joe\"));\nassert(strictlyOrdered(\"Jane\", \"Jim\", \"Joe\"));\n// Incidentally also ordered by length decreasing\nassert(ordered!((a, b) => a.length > b.length)(\"Jane\", \"Jim\", \"Joe\"));\n// ... but not strictly so: \"Jim\" and \"Joe\" have the same length\nassert(!strictlyOrdered!((a, b) => a.length > b.length)(\"Jane\", \"Jim\", \"Joe\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL256_2566)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 2 && is(typeof(binaryFun!less(values[1], values[0])) : bool) || T.length > 2 && is(typeof(ordered!less(values[0..1 + __dollar / 2]))) && is(typeof(ordered!less(values[__dollar / 2..__dollar])))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "strictlyOrdered",
						"line": 240,
						"type": "bool(T values)",
						"parameters": [
							{
								"name": "values",
								"type": "T"
							}
						],
						"endline": 253,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "strictlyOrdered",
				"line": 240,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "is(typeof(ordered!less(values)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partition",
						"line": 300,
						"type": "Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 378,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "partition",
				"line": 300,
				"comment": "Partitions a range in two using $(D pred) as a\npredicate. Specifically, reorders the range $(D r = [left,\nright$(RPAREN)) using $(D swap) such that all elements $(D i) for\nwhich $(D pred(i)) is $(D true) come before all elements $(D j) for\nwhich $(D pred(j)) returns $(D false).\n\nPerforms $(BIGOH r.length) (if unstable or semistable) or $(BIGOH\nr.length * log(r.length)) (if stable) evaluations of $(D less) and $(D\nswap). The unstable version computes the minimum possible evaluations\nof $(D swap) (roughly half of those performed by the semistable\nversion).\n\nReturns:\n\nThe right part of $(D r) after partitioning.\n\nIf $(D ss == SwapStrategy.stable), $(D partition) preserves the\nrelative ordering of all elements $(D a), $(D b) in $(D r) for which\n$(D pred(a) == pred(b)). If $(D ss == SwapStrategy.semistable), $(D\npartition) preserves the relative ordering of all elements $(D a), $(D\nb) in the left part of $(D r) for which $(D pred(a) == pred(b)).\n\nSee_Also:\n    STL's $(WEB sgi.com/tech/stl/_partition.html, _partition)$(BR)\n    STL's $(WEB sgi.com/tech/stl/stable_partition.html, stable_partition)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL381_2567)\n---\nimport std.algorithm : count, find; // FIXME\nimport std.conv : text;\n\nauto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto arr = Arr.dup;\nstatic bool even(int a) { return (a & 1) == 0; }\n// Partition arr such that even numbers come first\nauto r = partition!(even)(arr);\n// Now arr is separated in evens and odds.\n// Numbers may have become shuffled due to instability\nassert(r == arr[5 .. $]);\nassert(count!(even)(arr[0 .. 5]) == 5);\nassert(find!(even)(r).empty);\n\n// Can also specify the predicate as a string.\n// Use 'a' as the predicate argument name\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0})(arr);\nassert(r == arr[5 .. $]);\n\n// Now for a stable partition:\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);\n// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1\nassert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] && r == arr[5 .. $]);\n\n// In case the predicate needs to hold its own state, use a delegate:\narr[] = Arr[];\nint x = 3;\n// Put stuff greater than 3 on the left\nbool fun(int a) { return a > x; }\nr = partition!(fun, SwapStrategy.semistable)(arr);\n// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2\nassert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && r == arr[7 .. $]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL381_2567)\n",
				"parameters": [
					{
						"name": "predicate",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "ss == SwapStrategy.stable && isRandomAccessRange!Range || ss != SwapStrategy.stable && isForwardRange!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "isPartitioned",
						"line": 437,
						"type": "bool(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 450,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "isPartitioned",
				"line": 437,
				"comment": "Returns $(D true) if $(D r) is partitioned according to predicate $(D\npred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL453_2569)\n---\nint[] r = [ 1, 3, 5, 7, 8, 2, 4, ];\nassert(isPartitioned!\"a & 1\"(r));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL453_2569)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partition3",
						"line": 471,
						"type": "(Range r, E pivot)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "pivot",
								"type": "E"
							}
						],
						"endline": 524,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "partition3",
				"line": 471,
				"comment": "Rearranges elements in $(D r) in three adjacent ranges and returns\nthem. The first and leftmost range only contains elements in $(D r)\nless than $(D pivot). The second and middle range only contains\nelements in $(D r) that are equal to $(D pivot). Finally, the third\nand rightmost range only contains elements in $(D r) that are greater\nthan $(D pivot). The less-than test is defined by the binary function\n$(D less).\n\nBUGS: stable $(D partition3) has not been implemented yet.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL527_2570)\n---\nauto a = [ 8, 3, 4, 1, 4, 7, 4 ];\nauto pieces = partition3(a, 4);\nassert(pieces[0] == [ 1, 3 ]);\nassert(pieces[1] == [ 4, 4, 4 ]);\nassert(pieces[2] == [ 8, 7 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL527_2570)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "ss == SwapStrategy.unstable && isRandomAccessRange!Range && hasSwappableElements!Range && hasLength!Range && is(typeof(binaryFun!less(r.front, pivot)) == bool) && is(typeof(binaryFun!less(pivot, r.front)) == bool) && is(typeof(binaryFun!less(r.front, r.front)) == bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeIndex",
						"line": 593,
						"type": "SortedRange!(RangeIndex, (a, b) => binaryFun!less(*a, *b))(Range r, RangeIndex index)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							}
						],
						"endline": 613,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "makeIndex",
				"line": 593,
				"comment": "Computes an index for $(D r) based on the comparison $(D less). The\nindex is a sorted array of pointers or indices into the original\nrange. This technique is similar to sorting, but it is more flexible\nbecause (1) it allows \"sorting\" of immutable collections, (2) allows\nbinary search even if the original collection does not offer random\naccess, (3) allows multiple indexes, each on a different predicate,\nand (4) may be faster when dealing with large objects. However, using\nan index may also be slower under certain circumstances due to the\nextra indirection, and is always larger than a sorting-based solution\nbecause it needs space for the index in addition to the original\ncollection. The complexity is the same as $(D sort)'s.\n\nThe first overload of $(D makeIndex) writes to a range containing\npointers, and the second writes to a range containing offsets. The\nfirst overload requires $(D Range) to be a forward range, and the\nlatter requires it to be a random-access range.\n\n$(D makeIndex) overwrites its second argument with the result, but\nnever reallocates it.\n\nReturns: The pointer-based version returns a $(D SortedRange) wrapper\nover index, of type $(D SortedRange!(RangeIndex, (a, b) =>\nbinaryFun!less(*a, *b))) thus reflecting the ordering of the\nindex. The index-based version returns $(D void) because the ordering\nrelation involves not only $(D index) but also $(D r).\n\nThrows: If the second argument's length is less than that of the range\nindexed, an exception is thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL650_2578)\n---\nimmutable(int[]) arr = [ 2, 3, 1, 5, 0 ];\n// index using pointers\nauto index1 = new immutable(int)*[arr.length];\nmakeIndex!(\"a < b\")(arr, index1);\nassert(isSorted!(\"*a < *b\")(index1));\n// index using offsets\nauto index2 = new size_t[arr.length];\nmakeIndex!(\"a < b\")(arr, index2);\nassert(isSorted!\n    ((size_t a, size_t b){ return arr[a] < arr[b];})\n    (index2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL650_2578)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isRandomAccessRange!RangeIndex && is(ElementType!RangeIndex : ElementType!Range*)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "makeIndex",
						"line": 616,
						"type": "void(Range r, RangeIndex index)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							}
						],
						"endline": 647,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "makeIndex",
				"line": 616,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && !isInfinite!Range && isRandomAccessRange!RangeIndex && !isInfinite!RangeIndex && isIntegral!(ElementType!RangeIndex)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "multiSort",
								"line": 723,
								"type": "void(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 762,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "multiSort",
						"line": 723,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "validPredicates!(ElementType!Range, less)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "multiSort",
				"line": 721,
				"comment": "$(D void multiSort(Range)(Range r)\n    if (validPredicates!(ElementType!Range, less));)\n\nSorts a range by multiple keys. The call $(D multiSort!(\"a.id < b.id\",\n\"a.date > b.date\")(r)) sorts the range $(D r) by $(D id) ascending,\nand sorts elements that have the same $(D id) by $(D date)\ndescending. Such a call is equivalent to $(D sort!\"a.id != b.id ? a.id\n< b.id : a.date > b.date\"(r)), but $(D multiSort) is faster because it\ndoes fewer comparisons (in addition to being more convenient).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL766_2580)\n---\nstatic struct Point { int x, y; }\nauto pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];\nauto pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];\nmultiSort!(\"a.x < b.x\", \"a.y < b.y\", SwapStrategy.unstable)(pts1);\nassert(pts1 == pts2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL766_2580)\n",
				"parameters": [
					{
						"name": "less",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sort",
						"line": 951,
						"type": "SortedRange!(Range, less)(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 983,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "sort",
				"line": 951,
				"comment": "Sorts a random-access range according to the predicate $(D less). Performs\n$(BIGOH r.length * log(r.length)) evaluations of $(D less). Stable sorting\nrequires $(D hasAssignableElements!Range) to be true.\n\n$(D sort) returns a $(XREF range, SortedRange) over the original range, which\nfunctions that can take advantage of sorted data can then use to know that the\nrange is sorted and adjust accordingly. The $(XREF range, SortedRange) is a\nwrapper around the original range, so both it and the original range are sorted,\nbut other functions won't know that the original range has been sorted, whereas\nthey $(I can) know that $(XREF range, SortedRange) has been sorted.\n\nThe predicate is expected to satisfy certain rules in order for $(D sort) to\nbehave as expected - otherwise, the program may fail on certain inputs (but not\nothers) when not compiled in release mode, due to the cursory $(D assumeSorted)\ncheck. Specifically, $(D sort) expects $(D less(a,b) && less(b,c)) to imply\n$(D less(a,c)) (transitivity), and, conversely, $(D !less(a,b) && !less(b,c)) to\nimply $(D !less(a,c)). Note that the default predicate ($(D \"a < b\")) does not\nalways satisfy these conditions for floating point types, because the expression\nwill always be $(D false) when either $(D a) or $(D b) is NaN.\n\nReturns: The initial range wrapped as a $(D SortedRange) with the predicate\n$(D binaryFun!less).\n\nAlgorithms: $(WEB en.wikipedia.org/wiki/Introsort) is used for unstable sorting and\n$(WEB en.wikipedia.org/wiki/Timsort, Timsort) is used for stable sorting.\nEach algorithm has benefits beyond stability. Introsort is generally faster but\nTimsort may achieve greater speeds on data with low entropy or if predicate calls\nare expensive. Introsort performs no allocations whereas Timsort will perform one\nor more allocations per call. Both algorithms have $(BIGOH n log n) worst-case\ntime complexity.\n\nSee_Also:\n    $(XREF range, assumeSorted)$(BR)\n    $(XREF range, SortedRange)$(BR)\n    $(XREF_PACK algorithm,mutation,SwapStrategy)$(BR)\n    $(XREF functional, binaryFun)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL986_2584)\n---\nint[] array = [ 1, 2, 3, 4 ];\n// sort in descending order\nsort!(\"a > b\")(array);\nassert(array == [ 4, 3, 2, 1 ]);\n// sort in ascending order\nsort(array);\nassert(array == [ 1, 2, 3, 4 ]);\n// sort with a delegate\nbool myComp(int x, int y) @safe pure nothrow { return x > y; }\nsort!(myComp)(array);\nassert(array == [ 4, 3, 2, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL986_2584)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1001_2585)\n---\n// Showcase stable sorting\nstring[] words = [ \"aBc\", \"a\", \"abc\", \"b\", \"ABC\", \"c\" ];\nsort!(\"toUpper(a) < toUpper(b)\", SwapStrategy.stable)(words);\nassert(words == [ \"a\", \"aBc\", \"abc\", \"ABC\", \"b\", \"c\" ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1001_2585)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "(ss == SwapStrategy.unstable && (hasSwappableElements!Range || hasAssignableElements!Range) || ss != SwapStrategy.unstable && hasAssignableElements!Range) && isRandomAccessRange!Range && hasSlicing!Range && hasLength!Range",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "schwartzSort",
						"line": 1903,
						"type": "SortedRange!(R, (a, b) => binaryFun!less(unaryFun!transform(a), unaryFun!transform(b)))(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 1939,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "schwartzSort",
				"line": 1903,
				"comment": "Sorts a range using an algorithm akin to the $(WEB\nwikipedia.org/wiki/Schwartzian_transform, Schwartzian transform), also\nknown as the decorate-sort-undecorate pattern in Python and Lisp.\nThis function is helpful when the sort comparison includes\nan expensive computation. The complexity is the same as that of the\ncorresponding $(D sort), but $(D schwartzSort) evaluates $(D\ntransform) only $(D r.length) times (less than half when compared to\nregular sorting). The usage can be best illustrated with an example.\n\nExamples:\n----\nuint hashFun(string) { ... expensive computation ... }\nstring[] array = ...;\n// Sort strings by hash, slow\nsort!((a, b) => hashFun(a) < hashFun(b))(array);\n// Sort strings by hash, fast (only computes arr.length hashes):\nschwartzSort!(hashFun, \"a < b\")(array);\n----\n\nThe $(D schwartzSort) function might require less temporary data and\nbe faster than the Perl idiom or the decorate-sort-undecorate idiom\npresent in Python and Lisp. This is because sorting is done in-place\nand only minimal extra data (one array of transformed elements) is\ncreated.\n\nTo check whether an array was sorted and benefit of the speedup of\nSchwartz sorting, a function $(D schwartzIsSorted) is not provided\nbecause the effect can be achieved by calling $(D\nisSorted!less(map!transform(r))).\n\nReturns: The initial range wrapped as a $(D SortedRange) with the\npredicate $(D (a, b) => binaryFun!less(transform(a),\ntransform(b))).\n",
				"parameters": [
					{
						"name": "transform",
						"kind": "alias"
					},
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && hasLength!R",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "partialSort",
						"line": 2032,
						"type": "void(Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2038,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "partialSort",
				"line": 2032,
				"comment": "Reorders the random-access range $(D r) such that the range $(D r[0\n.. mid]) is the same as if the entire $(D r) were sorted, and leaves\nthe range $(D r[mid .. r.length]) in no particular order. Performs\n$(BIGOH r.length * log(mid)) evaluations of $(D pred). The\nimplementation simply calls $(D topN!(less, ss)(r, n)) and then $(D\nsort!(less, ss)(r[0 .. n])).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2041_2599)\n---\nint[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];\npartialSort(a, 5);\nassert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2041_2599)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topN",
						"line": 2070,
						"type": "void(Range r, size_t nth)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "nth",
								"type": "size_t"
							}
						],
						"endline": 2105,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "topN",
				"line": 2070,
				"comment": "Reorders the range $(D r) using $(D swap) such that $(D r[nth]) refers\nto the element that would fall there if the range were fully\nsorted. In addition, it also partitions $(D r) such that all elements\n$(D e1) from $(D r[0]) to $(D r[nth]) satisfy $(D !less(r[nth], e1)),\nand all elements $(D e2) from $(D r[nth]) to $(D r[r.length]) satisfy\n$(D !less(e2, r[nth])). Effectively, it finds the nth smallest\n(according to $(D less)) elements in $(D r). Performs an expected\n$(BIGOH r.length) (if unstable) or $(BIGOH r.length * log(r.length))\n(if stable) evaluations of $(D less) and $(D swap).\n\nIf $(D n >= r.length), the algorithm has no effect.\n\nSee_Also:\n    $(LREF topNIndex),\n    $(WEB sgi.com/tech/stl/nth_element.html, STL's nth_element)\n\nBUGS:\n\nStable topN has not been implemented yet.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2108_2601)\n---\nint[] v = [ 25, 7, 9, 2, 0, 5, 21 ];\nauto n = 4;\ntopN!\"a < b\"(v, n);\nassert(v[n] == 9);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2108_2601)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && hasLength!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topN",
						"line": 2195,
						"type": "void(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 2210,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "topN",
				"line": 2195,
				"comment": "Stores the smallest elements of the two ranges in the left-hand range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2213_2606)\n---\nint[] a = [ 5, 7, 2, 6, 7 ];\nint[] b = [ 2, 1, 5, 6, 7, 3, 0 ];\ntopN(a, b);\nsort(a);\nassert(a == [0, 1, 2, 2, 3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2213_2606)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range1 && hasLength!Range1 && isInputRange!Range2 && is(ElementType!Range1 == ElementType!Range2)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topNCopy",
						"line": 2229,
						"type": "TRange(SRange source, TRange target, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "source",
								"type": "SRange"
							},
							{
								"name": "target",
								"type": "TRange"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 2245,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "topNCopy",
				"line": 2229,
				"comment": "Copies the top $(D n) elements of the input range $(D source) into the\nrandom-access range $(D target), where $(D n =\ntarget.length). Elements of $(D source) are not touched. If $(D\nsorted) is $(D true), the target is sorted. Otherwise, the target\nrespects the $(WEB en.wikipedia.org/wiki/Binary_heap, heap property).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2248_2607)\n---\nint[] a = [ 10, 16, 2, 3, 1, 5, 0 ];\nint[] b = new int[3];\ntopNCopy(a, b, SortOutput.yes);\nassert(b == [ 0, 1, 2 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2248_2607)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "SRange",
						"kind": "type"
					},
					{
						"name": "TRange",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!SRange && isRandomAccessRange!TRange && hasLength!TRange && hasSlicing!TRange",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topNIndex",
						"line": 2305,
						"type": "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 2335,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "topNIndex",
				"line": 2305,
				"comment": "Given a range of elements, constructs an index of its top $(I n) elements\n(i.e., the first $(I n) elements if the range were sorted).\n\nSimilar to $(LREF topN), except that the range is not modified.\n\nParams:\n    less = A binary predicate that defines the ordering of range elements.\n        Defaults to $(D a < b).\n    ss = $(RED (Not implemented yet.)) Specify the swapping strategy.\n    r = A\n        $(XREF_PACK_NAMED range,primitives,isRandomAccessRange,random-access range)\n        of elements to make an index for.\n    index = A\n        $(XREF_PACK_NAMED range,primitives,isRandomAccessRange,random-access range)\n        with assignable elements to build the index in. The length of this range\n        determines how many top elements to index in $(D r).\n\n        This index range can either have integral elements, in which case the\n        constructed index will consist of zero-based numerical indices into\n        $(D r); or it can have pointers to the element type of $(D r), in which\n        case the constructed index will be pointers to the top elements in\n        $(D r).\n    sorted = Determines whether to sort the index by the elements they refer\n        to.\n\nSee_also: $(LREF topN), $(LREF topNCopy).\n\nBUGS:\nThe swapping strategy parameter is not implemented yet; currently it is\nignored.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2369_2609)\n---\n// Construct index to top 3 elements using numerical indices:\nint[] a = [ 10, 2, 7, 5, 8, 1 ];\nint[] index = new int[3];\ntopNIndex(a, index, SortOutput.yes);\nassert(index == [5, 1, 3]); // because a[5]==1, a[1]==2, a[3]==5\n\n// Construct index to top 3 elements using pointer indices:\nint*[] ptrIndex = new int*[3];\ntopNIndex(a, ptrIndex, SortOutput.yes);\nassert(ptrIndex == [ &a[5], &a[1], &a[3] ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2369_2609)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isRandomAccessRange!RangeIndex && hasAssignableElements!RangeIndex && isIntegral!(ElementType!RangeIndex)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "topNIndex",
						"line": 2338,
						"type": "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "index",
								"type": "RangeIndex"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 2366,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "topNIndex",
				"line": 2338,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "ss",
						"defaultValue": "SwapStrategy.unstable",
						"deco": "E3std9algorithm8mutation12SwapStrategy",
						"kind": "value"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "RangeIndex",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range && isRandomAccessRange!RangeIndex && hasAssignableElements!RangeIndex && is(ElementType!RangeIndex == ElementType!Range*)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nextPermutation",
						"line": 2436,
						"type": "bool(BidirectionalRange range)",
						"parameters": [
							{
								"name": "range",
								"type": "BidirectionalRange"
							}
						],
						"endline": 2473,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "nextPermutation",
				"line": 2436,
				"comment": " Permutes $(D range) in-place to the next lexicographically greater\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n If the range is currently the lexicographically greatest permutation, it is\n permuted back to the least permutation and false is returned.  Otherwise,\n true is returned. One can thus generate all permutations of a range by\n sorting it according to $(D less), which produces the lexicographically\n least permutation, and then calling nextPermutation until it returns false.\n This is guaranteed to generate all distinct permutations of the range\n exactly once.  If there are $(I N) elements in the range and all of them are\n unique, then $(I N)! permutations will be generated. Otherwise, if there are\n some duplicated elements, fewer permutations will be produced.\n----\n// Enumerate all permutations\nint[] a = [1,2,3,4,5];\ndo\n{\n    // use the current permutation and\n    // proceed to the next permutation of the array.\n} while (nextPermutation(a));\n----\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2476_2612)\n---\n// Step through all permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextPermutation(a) == true);\nassert(a == [1,3,2]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,3]);\nassert(nextPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextPermutation(a) == true);\nassert(a == [3,2,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,2,3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2476_2612)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2495_2613)\n---\n// Step through permutations of an array containing duplicate elements:\nint[] a = [1,1,2];\nassert(nextPermutation(a) == true);\nassert(a == [1,2,1]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,1,2]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2495_2613)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "BidirectionalRange",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!BidirectionalRange && hasSwappableElements!BidirectionalRange",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nextEvenPermutation",
						"line": 2686,
						"type": "bool(BidirectionalRange range)",
						"parameters": [
							{
								"name": "range",
								"type": "BidirectionalRange"
							}
						],
						"endline": 2737,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "nextEvenPermutation",
				"line": 2686,
				"comment": " Permutes $(D range) in-place to the next lexicographically greater $(I even)\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n An even permutation is one which is produced by swapping an even number of\n pairs of elements in the original range. The set of $(I even) permutations\n is distinct from the set of $(I all) permutations only when there are no\n duplicate elements in the range. If the range has $(I N) unique elements,\n then there are exactly $(I N)!/2 even permutations.\n\n If the range is already the lexicographically greatest even permutation, it\n is permuted back to the least even permutation and false is returned.\n Otherwise, true is returned, and the range is modified in-place to be the\n lexicographically next even permutation.\n\n One can thus generate the even permutations of a range with unique elements\n by starting with the lexicographically smallest permutation, and repeatedly\n calling nextEvenPermutation until it returns false.\n----\n// Enumerate even permutations\nint[] a = [1,2,3,4,5];\ndo\n{\n    // use the current permutation and\n    // proceed to the next even permutation of the array.\n} while (nextEvenPermutation(a));\n----\n One can also generate the $(I odd) permutations of a range by noting that\n permutations obey the rule that even + even = even, and odd + even = odd.\n Thus, by swapping the last two elements of a lexicographically least range,\n it is turned into the first odd permutation. Then calling\n nextEvenPermutation on this first odd permutation will generate the next\n even permutation relative to this odd permutation, which is actually the\n next odd permutation of the original range. Thus, by repeatedly calling\n nextEvenPermutation until it returns false, one enumerates the odd\n permutations of the original range.\n----\n// Enumerate odd permutations\nint[] a = [1,2,3,4,5];\nswap(a[$-2], a[$-1]);    // a is now the first odd permutation of [1,2,3,4,5]\ndo\n{\n    // use the current permutation and\n    // proceed to the next odd permutation of the original array\n    // (which is an even permutation of the first odd permutation).\n} while (nextEvenPermutation(a));\n----\n\n Warning: Since even permutations are only distinct from all permutations\n when the range elements are unique, this function assumes that there are no\n duplicate elements under the specified ordering. If this is not _true, some\n permutations may fail to be generated. When the range has non-unique\n elements, you should use $(MYREF nextPermutation) instead.\n\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2740_2619)\n---\n// Step through even permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextEvenPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextEvenPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextEvenPermutation(a) == false);\nassert(a == [1,2,3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2740_2619)\nExample:\nEven permutations are useful for generating coordinates of certain geometric\nshapes. Here's a non-trivial example:$(DDOX_UNITTEST_HEADER __unittestL2797_2624)\n---\nimport std.math : sqrt;\n\n// Print the 60 vertices of a uniform truncated icosahedron (soccer ball)\nenum real Phi = (1.0 + sqrt(5.0)) / 2.0;    // Golden ratio\nreal[][] seeds = [\n    [0.0, 1.0, 3.0*Phi],\n    [1.0, 2.0+Phi, 2.0*Phi],\n    [Phi, 2.0, Phi^^3]\n];\nsize_t n;\nforeach (seed; seeds)\n{\n    // Loop over even permutations of each seed\n    do\n    {\n        // Loop over all sign changes of each permutation\n        size_t i;\n        do\n        {\n            // Generate all possible sign changes\n            for (i=0; i < seed.length; i++)\n            {\n                if (seed[i] != 0.0)\n                {\n                    seed[i] = -seed[i];\n                    if (seed[i] < 0.0)\n                        break;\n                }\n            }\n            n++;\n        } while (i < seed.length);\n    } while (nextEvenPermutation(seed));\n}\nassert(n == 60);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2797_2624)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "BidirectionalRange",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!BidirectionalRange && hasSwappableElements!BidirectionalRange",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _sorting algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 completeSort,\n        If $(D a = [10, 20, 30]) and $(D b = [40, 6, 15]), then\n        $(D completeSort(a, b)) leaves $(D a = [6, 10, 15]) and $(D b = [20,\n        30, 40]).\n        The range $(D a) must be sorted prior to the call, and as a result the\n        combination $(D $(XREF range,chain)(a, b)) is sorted.)\n$(T2 isPartitioned,\n        $(D isPartitioned!\"a < 0\"([-1, -2, 1, 0, 2])) returns $(D true) because\n        the predicate is $(D true) for a portion of the range and $(D false)\n        afterwards.)\n$(T2 isSorted,\n        $(D isSorted([1, 1, 2, 3])) returns $(D true).)\n$(T2 makeIndex,\n        Creates a separate index for a range.)\n$(T2 multiSort,\n        Sorts by multiple keys.)\n$(T2 nextEvenPermutation,\n        Computes the next lexicographically greater even permutation of a range\n        in-place.)\n$(T2 nextPermutation,\n        Computes the next lexicographically greater permutation of a range\n        in-place.)\n$(T2 partialSort,\n        If $(D a = [5, 4, 3, 2, 1]), then $(D partialSort(a, 3)) leaves\n        $(D a[0 .. 3] = [1, 2, 3]).\n        The other elements of $(D a) are left in an unspecified order.)\n$(T2 partition,\n        Partitions a range according to a predicate.)\n$(T2 partition3,\n        Partitions a range in three parts (less than, equal, greater than the\n        given pivot).)\n$(T2 schwartzSort,\n        Sorts with the help of the $(LUCKY Schwartzian transform).)\n$(T2 sort,\n        Sorts.)\n$(T2 topN,\n        Separates the top elements in a range.)\n$(T2 topNCopy,\n        Copies out the top elements of a range.)\n$(T2 topNIndex,\n        Builds an index of the top elements of a range.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_sorting.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/iteration.d",
		"name": "std.algorithm.iteration",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "cache",
						"line": 135,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 139,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cache",
				"line": 135,
				"comment": "$(D cache) eagerly evaluates $(D front) of $(D range)\non each construction or call to $(D popFront),\nto store the result in a cache.\nThe result is then directly returned when $(D front) is called,\nrather than re-evaluated.\n\nThis can be a useful function to place in a chain, after functions\nthat have expensive evaluation, as a lazy alternative to $(XREF array,array).\nIn particular, it can be placed after a call to $(D map), or before a call\nto $(D filter).\n\n$(D cache) may provide bidirectional iteration if needed, but since\nthis comes at an increased cost, it must be explicitly requested via the\ncall to $(D cacheBidirectional). Furthermore, a bidirectional cache will\nevaluate the \"center\" element twice, when there is only one element left in\nthe range.\n\n$(D cache) does not provide random access primitives,\nas $(D cache) would be unable to cache the random accesses.\nIf $(D Range) provides slicing primitives,\nthen $(D cache) will provide the same slicing primitives,\nbut $(D hasSlicing!Cache) will not yield true (as the $(XREF_PACK _range,primitives,hasSlicing)\ntrait also checks for random access).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL149_2628)\n---\nimport std.algorithm.comparison : equal;\nimport std.stdio, std.range;\nimport std.typecons : tuple;\n\nulong counter = 0;\ndouble fun(int x)\n{\n    ++counter;\n    // http://en.wikipedia.org/wiki/Quartic_function\n    return ( (x + 4.0) * (x + 1.0) * (x - 1.0) * (x - 3.0) ) / 14.0 + 0.5;\n}\n// Without cache, with array (greedy)\nauto result1 = iota(-4, 5).map!(a =>tuple(a, fun(a)))()\n                         .filter!\"a[1]<0\"()\n                         .map!\"a[0]\"()\n                         .array();\n\n// the values of x that have a negative y are:\nassert(equal(result1, [-3, -2, 2]));\n\n// Check how many times fun was evaluated.\n// As many times as the number of items in both source and result.\nassert(counter == iota(-4, 5).length + result1.length);\n\ncounter = 0;\n// Without array, with cache (lazy)\nauto result2 = iota(-4, 5).map!(a =>tuple(a, fun(a)))()\n                         .cache()\n                         .filter!\"a[1]<0\"()\n                         .map!\"a[0]\"();\n\n// the values of x that have a negative y are:\nassert(equal(result2, [-3, -2, 2]));\n\n// Check how many times fun was evaluated.\n// Only as many times as the number of items in source.\nassert(counter == iota(-4, 5).length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL149_2628)\nExample:\nTip: $(D cache) is eager when evaluating elements. If calling front on the\nunderlying range has a side effect, it will be observeable before calling\nfront on the actual cached range.\n\nFurtermore, care should be taken composing $(D cache) with $(XREF range,take).\nBy placing $(D take) before $(D cache), then $(D cache) will be \"aware\"\nof when the range ends, and correctly stop caching elements when needed.\nIf calling front has no side effect though, placing $(D take) after $(D cache)\nmay yield a faster range.\n\nEither way, the resulting ranges will be equivalent, but maybe not at the\nsame cost or side effects.$(DDOX_UNITTEST_HEADER __unittestL204_2630)\n---\nimport std.algorithm.comparison : equal;\nimport std.range;\nint i = 0;\n\nauto r = iota(0, 4).tee!((a){i = a;}, No.pipeOnPop);\nauto r1 = r.take(3).cache();\nauto r2 = r.cache().take(3);\n\nassert(equal(r1, [0, 1, 2]));\nassert(i == 2); //The last \"seen\" element was 2. The data in cache has been cleared.\n\nassert(equal(r2, [0, 1, 2]));\nassert(i == 3); //cache has accessed 3. It is still stored internally by cache.\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL204_2630)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cacheBidirectional",
						"line": 142,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 146,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cacheBidirectional",
				"line": 142,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "map",
								"line": 431,
								"type": "(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 458,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "map",
						"line": 431,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!(Unqual!Range)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "map",
				"line": 429,
				"comment": "$(D auto map(Range)(Range r) if (isInputRange!(Unqual!Range));)\n\nImplements the homonym function (also known as $(D transform)) present\nin many languages of functional flavor. The call $(D map!(fun)(range))\nreturns a range of which elements are obtained by applying $(D fun(a))\nleft to right for all elements $(D a) in $(D range). The original ranges are\nnot changed. Evaluation is done lazily.\n\nSee_Also:\n    $(WEB en.wikipedia.org/wiki/Map_(higher-order_function), Map (higher-order function))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL462_2639)\n---\nimport std.algorithm.comparison : equal;\nimport std.range : chain;\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nauto squares = map!(a => a * a)(chain(arr1, arr2));\nassert(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL462_2639)\nExample:\nMultiple functions can be passed to $(D map). In that case, the\nelement type of $(D map) is a tuple containing one element for each\nfunction.$(DDOX_UNITTEST_HEADER __unittestL477_2640)\n---\nauto sums = [2, 4, 6, 8];\nauto products = [1, 4, 9, 16];\n\nsize_t i = 0;\nforeach (result; [ 1, 2, 3, 4 ].map!(\"a + a\", \"a * a\"))\n{\n    assert(result[0] == sums[i]);\n    assert(result[1] == products[i]);\n    ++i;\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL477_2640)\nExample:\nYou may alias $(D map) with some function(s) to a symbol and use\nit separately:$(DDOX_UNITTEST_HEADER __unittestL495_2641)\n---\nimport std.algorithm.comparison : equal;\nimport std.conv : to;\n\nalias stringize = map!(to!string);\nassert(equal(stringize([ 1, 2, 3, 4 ]), [ \"1\", \"2\", \"3\", \"4\" ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL495_2641)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"constraint": "fun.length >= 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "each",
								"line": 849,
								"type": "void(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 871,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "each",
						"line": 849,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isRangeIterable!Range && !isForeachIterable!Range",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "each",
								"line": 873,
								"type": "void(Iterable r)",
								"parameters": [
									{
										"name": "r",
										"type": "Iterable"
									}
								],
								"endline": 887,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "each",
						"line": 873,
						"parameters": [
							{
								"name": "Iterable",
								"kind": "type"
							}
						],
						"constraint": "isForeachIterable!Iterable",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "each",
				"line": 818,
				"comment": "Eagerly iterates over $(D r) and calls $(D pred) over _each element.\n\nParams:\n    pred = predicate to apply to each element of the range\n    r = range or iterable over which each iterates\n\nExample:\n---\nvoid deleteOldBackups()\n{\n    import std.algorithm, std.datetime, std.file;\n    auto cutoff = Clock.currTime() - 7.days;\n    dirEntries(\"\", \"*~\", SpanMode.depth)\n        .filter!(de => de.timeLastModified < cutoff)\n        .each!remove();\n}\n---\n\nIf the range supports it, the value can be mutated in place. Examples:\n---\narr.each!((ref a) => a++);\narr.each!\"a++\";\n---\n\nIf no predicate is specified, $(D each) will default to doing nothing\nbut consuming the entire range. $(D .front) will be evaluated, but this\ncan be avoided by explicitly specifying a predicate lambda with a\n$(D lazy) parameter.\n\n$(D each) also supports $(D opApply)-based iterators, so it will work\nwith e.g. $(XREF parallelism, parallel).\n\nSee_Also: $(XREF range,tee)\n\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "filter",
								"line": 943,
								"type": "(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 946,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "filter",
						"line": 943,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!(Unqual!Range)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "filter",
				"line": 941,
				"comment": "$(D auto filter(Range)(Range rs) if (isInputRange!(Unqual!Range));)\n\nImplements the higher order _filter function.\n\nParams:\n    predicate = Function to apply to each element of range\n    range = Input range of elements\n\nReturns:\n    $(D filter!(predicate)(range)) returns a new range containing only elements $(D x) in $(D range) for\n    which $(D predicate(x)) returns $(D true).\n\nSee_Also:\n    $(WEB en.wikipedia.org/wiki/Filter_(higher-order_function), Filter (higher-order function))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL950_2665)\n---\nimport std.algorithm.comparison : equal;\nimport std.math : approxEqual;\nimport std.range;\n\nint[] arr = [ 1, 2, 3, 4, 5 ];\n\n// Sum all elements\nauto small = filter!(a => a < 3)(arr);\nassert(equal(small, [ 1, 2 ]));\n\n// Sum again, but with Uniform Function Call Syntax (UFCS)\nauto sum = arr.filter!(a => a < 3);\nassert(equal(sum, [ 1, 2 ]));\n\n// In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = chain(a, b).filter!(a => a > 0);\nassert(equal(r, [ 3, 400, 100, 102 ]));\n\n// Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = chain(c, a, b).filter!(a => cast(int) a != a);\nassert(approxEqual(r1, [ 2.5 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL950_2665)\n",
				"parameters": [
					{
						"name": "predicate",
						"kind": "alias"
					}
				],
				"constraint": "is(typeof(unaryFun!predicate))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "filterBidirectional",
								"line": 1138,
								"type": "(Range r)",
								"parameters": [
									{
										"name": "r",
										"type": "Range"
									}
								],
								"endline": 1141,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "filterBidirectional",
						"line": 1138,
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isBidirectionalRange!(Unqual!Range)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "filterBidirectional",
				"line": 1136,
				"comment": " $(D auto filterBidirectional(Range)(Range r) if (isBidirectionalRange!(Unqual!Range));)\n\n Similar to $(D filter), except it defines a bidirectional\n range. There is a speed disadvantage - the constructor spends time\n finding the last element in the range that satisfies the filtering\n condition (in addition to finding the first one). The advantage is\n that the filtered range can be spanned from both directions. Also,\n $(XREF range, retro) can be applied against the filtered range.\n\n Params:\n     pred = Function to apply to each element of range\n     r = Bidirectional range of elements\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1145_2670)\n---\nimport std.algorithm.comparison : equal;\nimport std.range;\n\nint[] arr = [ 1, 2, 3, 4, 5 ];\nauto small = filterBidirectional!(\"a < 3\")(arr);\nstatic assert(isBidirectionalRange!(typeof(small)));\nassert(small.back == 2);\nassert(equal(small, [ 1, 2 ]));\nassert(equal(retro(small), [ 2, 1 ]));\n// In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = filterBidirectional!(\"a > 0\")(chain(a, b));\nassert(r.back == 102);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1145_2670)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "group",
						"line": 1306,
						"type": "Group!(pred, Range)(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1309,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "group",
				"line": 1306,
				"comment": "Groups consecutively equivalent elements into a single tuple of the element and\nthe number of its repetitions.\n\nSimilarly to $(D uniq), $(D group) produces a range that iterates over unique\nconsecutive elements of the given range. Each element of this range is a tuple\nof the element and the number of times it is repeated in the original range.\nEquivalence of elements is assessed by using the predicate $(D pred), which\ndefaults to $(D \"a == b\").\n\nParams:\n    pred = Binary predicate for determining equivalence of two elements.\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\n        iterate over.\n\nReturns: A range of elements of type $(D Tuple!(ElementType!R, uint)),\nrepresenting each consecutively unique element and its respective number of\noccurrences in that run.  This will be an input range if $(D R) is an input\nrange, and a forward range in all other cases.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1312_2671)\n---\nimport std.algorithm.comparison : equal;\nimport std.typecons : tuple, Tuple;\n\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(group(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),\n    tuple(4, 3u), tuple(5, 1u) ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1312_2671)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chunkBy",
						"line": 1687,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 1691,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chunkBy",
				"line": 1687,
				"comment": " Chunks an input range into subranges of equivalent adjacent elements.\n\n Equivalence is defined by the predicate $(D pred), which can be either\n binary or unary. In the binary form, two _range elements $(D a) and $(D b)\n are considered equivalent if $(D pred(a,b)) is true. In unary form, two\n elements are considered equivalent if $(D pred(a) == pred(b)) is true.\n\n This predicate must be an equivalence relation, that is, it must be\n reflexive ($(D pred(x,x)) is always true), symmetric\n ($(D pred(x,y) == pred(y,x))), and transitive ($(D pred(x,y) && pred(y,z))\n implies $(D pred(x,z))). If this is not the case, the range returned by\n chunkBy may assert at runtime or behave erratically.\n\n Params:\n  pred = Predicate for determining equivalence.\n  r = The range to be chunked.\n\n Returns: With a binary predicate, a range of ranges is returned in which\n all elements in a given subrange are equivalent under the given predicate.\n With a unary predicate, a range of tuples is returned, with the tuple\n consisting of the result of the unary predicate for each subrange, and the\n subrange itself.\n\n Notes:\n\n Equivalent elements separated by an intervening non-equivalent element will\n appear in separate subranges; this function only considers adjacent\n equivalence. Elements in the subranges will always appear in the same order\n they appear in the original range.\n\n See_also:\n $(LREF group), which collapses adjacent equivalent elements into a single\n element.\nExample:\nShowing usage with binary predicate:$(DDOX_UNITTEST_HEADER __unittestL1694_2685)\n---\nimport std.algorithm.comparison : equal;\n\n// Grouping by particular attribute of each element:\nauto data = [\n    [1, 1],\n    [1, 2],\n    [2, 2],\n    [2, 3]\n];\n\nauto r1 = data.chunkBy!((a,b) => a[0] == b[0]);\nassert(r1.equal!equal([\n    [[1, 1], [1, 2]],\n    [[2, 2], [2, 3]]\n]));\n\nauto r2 = data.chunkBy!((a,b) => a[1] == b[1]);\nassert(r2.equal!equal([\n    [[1, 1]],\n    [[1, 2], [2, 2]],\n    [[2, 3]]\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1694_2685)\nExample:\nShowing usage with unary predicate:$(DDOX_UNITTEST_HEADER __unittestL1744_2691)\n---\nimport std.algorithm.comparison : equal;\nimport std.typecons : tuple;\n\n// Grouping by particular attribute of each element:\nauto range =\n[\n    [1, 1],\n    [1, 1],\n    [1, 2],\n    [2, 2],\n    [2, 3],\n    [2, 3],\n    [3, 3]\n];\n\nauto byX = chunkBy!(a => a[0])(range);\nauto expected1 =\n[\n    tuple(1, [[1, 1], [1, 1], [1, 2]]),\n    tuple(2, [[2, 2], [2, 3], [2, 3]]),\n    tuple(3, [[3, 3]])\n];\nforeach (e; byX)\n{\n    assert(!expected1.empty);\n    assert(e[0] == expected1.front[0]);\n    assert(e[1].equal(expected1.front[1]));\n    expected1.popFront();\n}\n\nauto byY = chunkBy!(a => a[1])(range);\nauto expected2 =\n[\n    tuple(1, [[1, 1], [1, 1]]),\n    tuple(2, [[1, 2], [2, 2]]),\n    tuple(3, [[2, 3], [2, 3], [3, 3]])\n];\nforeach (e; byY)\n{\n    assert(!expected2.empty);\n    assert(e[0] == expected2.front[0]);\n    assert(e[1].equal(expected2.front[1]));\n    expected2.popFront();\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1744_2691)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "joiner",
						"line": 1909,
						"type": "(RoR r, Separator sep)",
						"parameters": [
							{
								"name": "r",
								"type": "RoR"
							},
							{
								"name": "sep",
								"type": "Separator"
							}
						],
						"endline": 2062,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "joiner",
				"line": 1909,
				"comment": "Lazily joins a range of ranges with a separator. The separator itself\nis a range. If you do not provide a separator, then the ranges are\njoined directly without anything in between them.\n\nParams:\n    r = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of input\n        ranges to be joined.\n    sep = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) of\n        element(s) to serve as separators in the joined range.\n\nReturns:\nAn input range of elements in the joined range. This will be a forward range if\nboth outer and inner ranges of $(D RoR) are forward ranges; otherwise it will\nbe only an input range.\n\nSee_also:\n$(XREF range,chain), which chains a sequence of ranges with compatible elements\ninto a single range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2065_2704)\n---\nimport std.algorithm.comparison : equal;\nimport std.conv : text;\n\ndebug(std_algorithm) scope(success)\n    writeln(\"unittest @\", __FILE__, \":\", __LINE__, \" done.\");\n\nstatic assert(isInputRange!(typeof(joiner([\"\"], \"\"))));\nstatic assert(isForwardRange!(typeof(joiner([\"\"], \"\"))));\nassert(equal(joiner([\"\"], \"xyz\"), \"\"), text(joiner([\"\"], \"xyz\")));\nassert(equal(joiner([\"\", \"\"], \"xyz\"), \"xyz\"), text(joiner([\"\", \"\"], \"xyz\")));\nassert(equal(joiner([\"\", \"abc\"], \"xyz\"), \"xyzabc\"));\nassert(equal(joiner([\"abc\", \"\"], \"xyz\"), \"abcxyz\"));\nassert(equal(joiner([\"abc\", \"def\"], \"xyz\"), \"abcxyzdef\"));\nassert(equal(joiner([\"Mary\", \"has\", \"a\", \"little\", \"lamb\"], \"...\"),\n                \"Mary...has...a...little...lamb\"));\nassert(equal(joiner([\"abc\", \"def\"]), \"abcdef\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2065_2704)\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(ElementType!RoR) && isForwardRange!Separator && is(ElementType!Separator : ElementType!(ElementType!RoR))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "joiner",
						"line": 2192,
						"type": "(RoR r)",
						"parameters": [
							{
								"name": "r",
								"type": "RoR"
							}
						],
						"endline": 2279,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "joiner",
				"line": 2192,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(ElementType!RoR)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "reduce",
								"line": 2468,
								"type": "(R r)",
								"parameters": [
									{
										"name": "r",
										"type": "R"
									}
								],
								"endline": 2487,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "reduce",
						"line": 2468,
						"comment": "    No-seed version. The first element of $(D r) is used as the seed's value.\n\n    For each function $(D f) in $(D fun), the corresponding\n    seed type $(D S) is $(D Unqual!(typeof(f(e, e)))), where $(D e) is an\n    element of $(D r): $(D ElementType!R) for ranges,\n    and $(D ForeachType!R) otherwise.\n\n    Once S has been determined, then $(D S s = e;) and $(D s = f(s, e);)\n    must both be legal.\n\n    If $(D r) is empty, an $(D Exception) is thrown.\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isIterable!R",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "reduce",
								"line": 2498,
								"type": "(S seed, R r)",
								"parameters": [
									{
										"name": "seed",
										"type": "S"
									},
									{
										"name": "r",
										"type": "R"
									}
								],
								"endline": 2509,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							}
						],
						"name": "reduce",
						"line": 2498,
						"comment": "    Seed version. The seed should be a single value if $(D fun) is a\n    single function. If $(D fun) is multiple functions, then $(D seed)\n    should be a $(XREF typecons,Tuple), with one field per function in $(D f).\n\n    For convenience, if the seed is const, or has qualified fields, then\n    $(D reduce) will operate on an unqualified copy. If this happens\n    then the returned type will not perfectly match $(D S).\n",
						"parameters": [
							{
								"name": "S",
								"kind": "type"
							},
							{
								"name": "R",
								"kind": "type"
							}
						],
						"constraint": "isIterable!R",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "reduce",
				"line": 2447,
				"comment": "Implements the homonym function (also known as $(D accumulate), $(D\ncompress), $(D inject), or $(D foldl)) present in various programming\nlanguages of functional flavor. The call $(D reduce!(fun)(seed,\nrange)) first assigns $(D seed) to an internal variable $(D result),\nalso called the accumulator. Then, for each element $(D x) in $(D\nrange), $(D result = fun(result, x)) gets evaluated. Finally, $(D\nresult) is returned. The one-argument version $(D reduce!(fun)(range))\nworks similarly, but it uses the first element of the range as the\nseed (the range must be non-empty).\n\nReturns:\n    the accumulated $(D result)\n\nSee_Also:\n    $(WEB en.wikipedia.org/wiki/Fold_(higher-order_function), Fold (higher-order function))\n\n    $(LREF sum) is similar to $(D reduce!((a, b) => a + b)) that offers\n    precise summing of floating point numbers.\nExample:\nMany aggregate range operations turn out to be solved with $(D reduce)\nquickly and easily. The example below illustrates $(D reduce)'s\nremarkable power and flexibility.$(DDOX_UNITTEST_HEADER __unittestL2579_2718)\n---\nimport std.algorithm.comparison : max, min;\nimport std.math : approxEqual;\nimport std.range;\n\nint[] arr = [ 1, 2, 3, 4, 5 ];\n// Sum all elements\nauto sum = reduce!((a,b) => a + b)(0, arr);\nassert(sum == 15);\n\n// Sum again, using a string predicate with \"a\" and \"b\"\nsum = reduce!\"a + b\"(0, arr);\nassert(sum == 15);\n\n// Compute the maximum of all elements\nauto largest = reduce!(max)(arr);\nassert(largest == 5);\n\n// Max again, but with Uniform Function Call Syntax (UFCS)\nlargest = arr.reduce!(max);\nassert(largest == 5);\n\n// Compute the number of odd elements\nauto odds = reduce!((a,b) => a + (b & 1))(0, arr);\nassert(odds == 3);\n\n// Compute the sum of squares\nauto ssquares = reduce!((a,b) => a + b * b)(0, arr);\nassert(ssquares == 55);\n\n// Chain multiple ranges into seed\nint[] a = [ 3, 4 ];\nint[] b = [ 100 ];\nauto r = reduce!(\"a + b\")(chain(a, b));\nassert(r == 107);\n\n// Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = reduce!(\"a + b\")(chain(a, b, c));\nassert(approxEqual(r1, 112.5));\n\n// To minimize nesting of parentheses, Uniform Function Call Syntax can be used\nauto r2 = chain(a, b, c).reduce!(\"a + b\");\nassert(approxEqual(r2, 112.5));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2579_2718)\nExample:\nSometimes it is very useful to compute multiple aggregates in one pass.\nOne advantage is that the computation is faster because the looping overhead\nis shared. That's why $(D reduce) accepts multiple functions.\nIf two or more functions are passed, $(D reduce) returns a\n$(XREF typecons, Tuple) object with one member per passed-in function.\nThe number of seeds must be correspondingly increased.$(DDOX_UNITTEST_HEADER __unittestL2634_2719)\n---\nimport std.algorithm.comparison : max, min;\nimport std.math : approxEqual, sqrt;\nimport std.typecons : tuple, Tuple;\n\ndouble[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];\n// Compute minimum and maximum in one pass\nauto r = reduce!(min, max)(a);\n// The type of r is Tuple!(int, int)\nassert(approxEqual(r[0], 2));  // minimum\nassert(approxEqual(r[1], 11)); // maximum\n\n// Compute sum and sum of squares in one pass\nr = reduce!(\"a + b\", \"a + b * b\")(tuple(0.0, 0.0), a);\nassert(approxEqual(r[0], 35));  // sum\nassert(approxEqual(r[1], 233)); // sum of squares\n// Compute average and standard deviation from the above\nauto avg = r[0] / a.length;\nauto stdev = sqrt(r[1] / a.length - avg * avg);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2634_2719)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "tuple"
					}
				],
				"constraint": "fun.length >= 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 2875,
						"type": "(Range r, Separator s)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "s",
								"type": "Separator"
							}
						],
						"endline": 3029,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 2875,
				"comment": "Lazily splits a range using an element as a separator. This can be used with\nany narrow string type or sliceable range type, but is most popular with string\ntypes.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range. Use $(D filter!(a => !a.empty)) on the result to compress\nempty elements.\n\nIf the empty range is given, the result is a range with one empty\nelement. If a range with one separator is given, the result is a range\nwith two empty elements.\n\nIf splitting a string on whitespace and token compression is desired,\nconsider using $(D splitter) without specifying a separator (see fourth overload\nbelow).\n\nParams:\n    pred = The predicate for comparing each element with the separator,\n        defaulting to $(D \"a == b\").\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to be\n        split. Must support slicing and $(D .length).\n    s = The element to be treated as the separator between range segments to be\n        split.\n\nConstraints:\n    The predicate $(D pred) needs to accept an element of $(D r) and the\n    separator $(D s).\n\nReturns:\n    An input range of the subranges of elements between separators. If $(D r)\n    is a forward range or bidirectional range, the returned range will be\n    likewise.\n\nSee_Also:\n $(XREF regex, _splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3032_2730)\n---\nimport std.algorithm.comparison : equal;\n\nassert(equal(splitter(\"hello  world\", ' '), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5], [] ];\nassert(equal(splitter(a, 0), w));\na = [ 0 ];\nassert(equal(splitter(a, 0), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter(a, 0), [ [], [1] ]));\nw = [ [0], [1], [2] ];\nassert(equal(splitter!\"a.front == b\"(w, 1), [ [[0]], [[2]] ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3032_2730)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r.front, s)) : bool) && (hasSlicing!Range && hasLength!Range || isNarrowString!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 3155,
						"type": "(Range r, Separator s)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "s",
								"type": "Separator"
							}
						],
						"endline": 3309,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 3155,
				"comment": "Similar to the previous overload of $(D splitter), except this one uses another\nrange as a separator. This can be used with any narrow string type or sliceable\nrange type, but is most popular with string types.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range. Use $(D filter!(a => !a.empty)) on the result to compress\nempty elements.\n\nParams:\n    pred = The predicate for comparing each element with the separator,\n        defaulting to $(D \"a == b\").\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to be\n        split.\n    s = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to\n        be treated as the separator between segments of $(D r) to be split.\n\nConstraints:\n    The predicate $(D pred) needs to accept an element of $(D r) and an\n    element of $(D s).\n\nReturns:\n    An input range of the subranges of elements between separators. If $(D r)\n    is a forward range or bidirectional range, the returned range will be\n    likewise.\n\nSee_Also: $(XREF regex, _splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3312_2733)\n---\nimport std.algorithm.comparison : equal;\n\nassert(equal(splitter(\"hello  world\", \"  \"), [ \"hello\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [3, 0, 4, 5, 0] ];\nassert(equal(splitter(a, [0, 0]), w));\na = [ 0, 0 ];\nassert(equal(splitter(a, [0, 0]), [ (int[]).init, (int[]).init ]));\na = [ 0, 0, 1 ];\nassert(equal(splitter(a, [0, 0]), [ [], [1] ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3312_2733)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r.front, s.front)) : bool) && (hasSlicing!Range || isNarrowString!Range) && isForwardRange!Separator && (hasLength!Separator || isNarrowString!Separator)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 3461,
						"type": "(Range input)",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							}
						],
						"endline": 3465,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 3461,
				"comment": "\nSimilar to the previous overload of $(D splitter), except this one does not use a separator.\nInstead, the predicate is an unary function on the input range's element type.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range. Use $(D filter!(a => !a.empty)) on the result to compress\nempty elements.\n\nParams:\n    isTerminator = The predicate for deciding where to split the range.\n    input = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\n        be split.\n\nConstraints:\n    The predicate $(D isTerminator) needs to accept an element of $(D input).\n\nReturns:\n    An input range of the subranges of elements between separators. If $(D input)\n    is a forward range or bidirectional range, the returned range will be\n    likewise.\n\nSee_Also: $(XREF regex, _splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3468_2740)\n---\nimport std.algorithm.comparison : equal;\n\nassert(equal(splitter!\"a == ' '\"(\"hello  world\"), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5], [] ];\nassert(equal(splitter!\"a == 0\"(a), w));\na = [ 0 ];\nassert(equal(splitter!\"a == 0\"(a), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter!\"a == 0\"(a), [ [], [1] ]));\nw = [ [0], [1], [2] ];\nassert(equal(splitter!\"a.front == 1\"(w), [ [[0]], [[2]] ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3468_2740)\n",
				"parameters": [
					{
						"name": "isTerminator",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && is(typeof(unaryFun!isTerminator(input.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "splitter",
						"line": 3697,
						"type": "(C[] s)",
						"parameters": [
							{
								"name": "s",
								"type": "C[]"
							}
						],
						"endline": 3749,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "splitter",
				"line": 3697,
				"comment": "Lazily splits the string $(D s) into words, using whitespace as the delimiter.\n\nThis function is string specific and, contrary to\n$(D splitter!(std.uni.isWhite)), runs of whitespace will be merged together\n(no empty tokens will be produced).\n\nParams:\n    s = The string to be split.\n\nReturns:\n    An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of slices of\n    the original string split by whitespace.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3752_2745)\n---\nimport std.algorithm.comparison : equal;\nauto a = \" a     bcd   ef gh \";\nassert(equal(splitter(a), [\"a\", \"bcd\", \"ef\", \"gh\"][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3752_2745)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!C",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sum",
						"line": 3916,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 3925,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sum",
				"line": 3916,
				"comment": "Sums elements of $(D r), which must be a finite\n$(XREF_PACK_NAMED range,primitives,isInputRange,input range). Although\nconceptually $(D sum(r)) is equivalent to $(LREF reduce)!((a, b) => a +\nb)(0, r), $(D sum) uses specialized algorithms to maximize accuracy,\nas follows.\n\n$(UL\n$(LI If $(D $(XREF_PACK range,primitives,ElementType)!R) is a floating-point\ntype and $(D R) is a\n$(XREF_PACK_NAMED range,primitives,isRandomAccessRange,random-access range) with\nlength and slicing, then $(D sum) uses the\n$(WEB en.wikipedia.org/wiki/Pairwise_summation, pairwise summation)\nalgorithm.)\n$(LI If $(D ElementType!R) is a floating-point type and $(D R) is a\nfinite input range (but not a random-access range with slicing), then\n$(D sum) uses the $(WEB en.wikipedia.org/wiki/Kahan_summation,\nKahan summation) algorithm.)\n$(LI In all other cases, a simple element by element addition is done.)\n)\n\nFor floating point inputs, calculations are made in $(LINK2 ../type.html, $(D real))\nprecision for $(D real) inputs and in $(D double) precision otherwise\n(Note this is a special case that deviates from $(D reduce)'s behavior,\nwhich would have kept $(D float) precision for a $(D float) range).\nFor all other types, the calculations are done in the same type obtained\nfrom from adding two elements of the range, which may be a different\ntype from the elements themselves (for example, in case of $(LINK2 ../type.html#integer-promotions, integral promotion)).\n\nA seed may be passed to $(D sum). Not only will this seed be used as an initial\nvalue, but its type will override all the above, and determine the algorithm\nand precision used for sumation.\n\nNote that these specialized summing algorithms execute more primitive operations\nthan vanilla summation. Therefore, if in certain cases maximum speed is required\nat expense of precision, one can use $(D reduce!((a, b) => a + b)(0, r)), which\nis not specialized for summation.\n\nReturns:\n    The sum of all the elements in the range r.\nExample:\nDitto$(DDOX_UNITTEST_HEADER __unittestL3972_2758)\n---\nimport std.range;\n\n//simple integral sumation\nassert(sum([ 1, 2, 3, 4]) == 10);\n\n//with integral promotion\nassert(sum([false, true, true, false, true]) == 3);\nassert(sum(ubyte.max.repeat(100)) == 25500);\n\n//The result may overflow\nassert(uint.max.repeat(3).sum()           ==  4294967293U );\n//But a seed can be used to change the sumation primitive\nassert(uint.max.repeat(3).sum(ulong.init) == 12884901885UL);\n\n//Floating point sumation\nassert(sum([1.0, 2.0, 3.0, 4.0]) == 10);\n\n//Floating point operations have double precision minimum\nstatic assert(is(typeof(sum([1F, 2F, 3F, 4F])) == double));\nassert(sum([1F, 2, 3, 4]) == 10);\n\n//Force pair-wise floating point sumation on large integers\nimport std.math : approxEqual;\nassert(iota(ulong.max / 2, ulong.max / 2 + 4096).sum(0.0)\n           .approxEqual((ulong.max / 2) * 4096.0 + 4096^^2 / 2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3972_2758)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !isInfinite!R && is(typeof(r.front + r.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sum",
						"line": 3927,
						"type": "(R r, E seed)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							},
							{
								"name": "seed",
								"type": "E"
							}
						],
						"endline": 3941,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sum",
				"line": 3927,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !isInfinite!R && is(typeof(seed = seed + r.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uniq",
						"line": 4087,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 4091,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uniq",
				"line": 4087,
				"comment": "Lazily iterates unique consecutive elements of the given range (functionality\nakin to the $(WEB wikipedia.org/wiki/_Uniq, _uniq) system\nutility). Equivalence of elements is assessed by using the predicate\n$(D pred), by default $(D \"a == b\"). If the given range is\nbidirectional, $(D uniq) also yields a bidirectional range.\n\nParams:\n    pred = Predicate for determining equivalence between range elements.\n    r = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n        elements to filter.\n\nReturns:\n    An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n    consecutively unique elements in the original range. If $(D r) is also a\n    forward range or bidirectional range, the returned range will be likewise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4094_2765)\n---\nimport std.algorithm.mutation : copy;\nimport std.algorithm.comparison : equal;\n\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));\n\n// Filter duplicates in-place using copy\narr.length -= arr.uniq().copy(arr).length;\nassert(arr == [ 1, 2, 3, 4, 5 ]);\n\n// Note that uniqueness is only determined consecutively; duplicated\n// elements separated by an intervening different element will not be\n// eliminated:\nassert(equal(uniq([ 1, 1, 2, 1, 1, 3, 1]), [1, 2, 1, 3, 1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4094_2765)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(binaryFun!pred(r.front, r.front)) == bool)",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _iteration algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 cache,\n        Eagerly evaluates and caches another range's $(D front).)\n$(T2 cacheBidirectional,\n        As above, but also provides $(D back) and $(D popBack).)\n$(T2 chunkyBy,\n        $(D chunkyBy!((a,b) => a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]]))\n        returns a range containing 3 subranges: the first with just\n        $(D [1, 1]); the second with the elements $(D [1, 2]) and $(D [2, 2]);\n        and the third with just $(D [2, 1]).)\n$(T2 each,\n        $(D each!writeln([1, 2, 3])) eagerly prints the numbers $(D 1), $(D 2)\n        and $(D 3) on their own lines.)\n$(T2 filter,\n        $(D filter!\"a > 0\"([1, -1, 2, 0, -3])) iterates over elements $(D 1)\n        and $(D 2).)\n$(T2 filterBidirectional,\n        Similar to $(D filter), but also provides $(D back) and $(D popBack) at\n        a small increase in cost.)\n$(T2 group,\n        $(D group([5, 2, 2, 3, 3])) returns a range containing the tuples\n        $(D tuple(5, 1)), $(D tuple(2, 2)), and $(D tuple(3, 2)).)\n$(T2 joiner,\n        $(D joiner([\"hello\", \"world!\"], \"; \")) returns a range that iterates\n        over the characters $(D \"hello; world!\"). No new string is created -\n        the existing inputs are iterated.)\n$(T2 map,\n        $(D map!\"2 * a\"([1, 2, 3])) lazily returns a range with the numbers\n        $(D 2), $(D 4), $(D 6).)\n$(T2 reduce,\n        $(D reduce!\"a + b\"([1, 2, 3, 4])) returns $(D 10).)\n$(T2 splitter,\n        Lazily splits a range by a separator.)\n$(T2 sum,\n        Same as $(D reduce), but specialized for accurate summation.)\n$(T2 uniq,\n        Iterates over the unique elements in a range, which is assumed sorted.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_iteration.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/package.d",
		"name": "std.algorithm",
		"members": [],
		"comment": "This package implements generic algorithms oriented towards the processing of\nsequences. Sequences processed by these functions define range-based\ninterfaces.  See also $(LINK2 std_range.html, Reference on ranges) and\n$(WEB ddili.org/ders/d.en/ranges.html, tutorial on ranges).\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\nAlgorithms are categorized into the following submodules:\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Submodule) $(TH Functions)\n)\n$(TR $(TDNW Searching)\n     $(TDNW $(SUBMODULE searching))\n     $(TD\n        $(SUBREF searching, all)\n        $(SUBREF searching, any)\n        $(SUBREF searching, balancedParens)\n        $(SUBREF searching, boyerMooreFinder)\n        $(SUBREF searching, canFind)\n        $(SUBREF searching, commonPrefix)\n        $(SUBREF searching, count)\n        $(SUBREF searching, countUntil)\n        $(SUBREF searching, endsWith)\n        $(SUBREF searching, find)\n        $(SUBREF searching, findAdjacent)\n        $(SUBREF searching, findAmong)\n        $(SUBREF searching, findSkip)\n        $(SUBREF searching, findSplit)\n        $(SUBREF searching, findSplitAfter)\n        $(SUBREF searching, findSplitBefore)\n        $(SUBREF searching, minCount)\n        $(SUBREF searching, minPos)\n        $(SUBREF searching, skipOver)\n        $(SUBREF searching, startsWith)\n        $(SUBREF searching, until)\n    )\n)\n$(TR $(TDNW Comparison)\n    $(TDNW $(SUBMODULE comparison))\n    $(TD\n        $(SUBREF comparison, among)\n        $(SUBREF comparison, castSwitch)\n        $(SUBREF comparison, clamp)\n        $(SUBREF comparison, cmp)\n        $(SUBREF comparison, equal)\n        $(SUBREF comparison, levenshteinDistance)\n        $(SUBREF comparison, levenshteinDistanceAndPath)\n        $(SUBREF comparison, max)\n        $(SUBREF comparison, min)\n        $(SUBREF comparison, mismatch)\n        $(SUBREF comparison, predSwitch)\n    )\n)\n$(TR $(TDNW Iteration)\n    $(TDNW $(SUBMODULE iteration))\n    $(TD\n        $(SUBREF iteration, cache)\n        $(SUBREF iteration, cacheBidirectional)\n        $(SUBREF iteration, chunkBy)\n        $(SUBREF iteration, each)\n        $(SUBREF iteration, filter)\n        $(SUBREF iteration, filterBidirectional)\n        $(SUBREF iteration, group)\n        $(SUBREF iteration, joiner)\n        $(SUBREF iteration, map)\n        $(SUBREF iteration, reduce)\n        $(SUBREF iteration, splitter)\n        $(SUBREF iteration, sum)\n        $(SUBREF iteration, uniq)\n    )\n)\n$(TR $(TDNW Sorting)\n    $(TDNW $(SUBMODULE sorting))\n    $(TD\n        $(SUBREF sorting, completeSort)\n        $(SUBREF sorting, isPartitioned)\n        $(SUBREF sorting, isSorted)\n        $(SUBREF sorting, makeIndex)\n        $(SUBREF sorting, multiSort)\n        $(SUBREF sorting, nextEvenPermutation)\n        $(SUBREF sorting, nextPermutation)\n        $(SUBREF sorting, partialSort)\n        $(SUBREF sorting, partition)\n        $(SUBREF sorting, partition3)\n        $(SUBREF sorting, schwartzSort)\n        $(SUBREF sorting, sort)\n        $(SUBREF sorting, topN)\n        $(SUBREF sorting, topNCopy)\n        $(SUBREF sorting, topNIndex)\n    )\n)\n$(TR $(TDNW Set&nbsp;operations)\n    $(TDNW $(SUBMODULE setops))\n    $(TD\n        $(SUBREF setops, cartesianProduct)\n        $(SUBREF setops, largestPartialIntersection)\n        $(SUBREF setops, largestPartialIntersectionWeighted)\n        $(SUBREF setops, nWayUnion)\n        $(SUBREF setops, setDifference)\n        $(SUBREF setops, setIntersection)\n        $(SUBREF setops, setSymmetricDifference)\n        $(SUBREF setops, setUnion)\n    )\n)\n$(TR $(TDNW Mutation)\n    $(TDNW $(SUBMODULE mutation))\n    $(TD\n        $(SUBREF mutation, bringToFront)\n        $(SUBREF mutation, copy)\n        $(SUBREF mutation, fill)\n        $(SUBREF mutation, initializeAll)\n        $(SUBREF mutation, move)\n        $(SUBREF mutation, moveAll)\n        $(SUBREF mutation, moveSome)\n        $(SUBREF mutation, remove)\n        $(SUBREF mutation, reverse)\n        $(SUBREF mutation, strip)\n        $(SUBREF mutation, stripLeft)\n        $(SUBREF mutation, stripRight)\n        $(SUBREF mutation, swap)\n        $(SUBREF mutation, swapRanges)\n        $(SUBREF mutation, uninitializedFill)\n    )\n)\n))\n\nMany functions in this package are parameterized with a function or a\n$(GLOSSARY predicate). The predicate may be passed either as a\nfunction name, a delegate name, a $(GLOSSARY functor) name, or a\ncompile-time string. The string may consist of $(B any) legal D\nexpression that uses the symbol $(D a) (for unary functions) or the\nsymbols $(D a) and $(D b) (for binary functions). These names will NOT\ninterfere with other homonym symbols in user code because they are\nevaluated in a different context. The default for all binary\ncomparison predicates is $(D \"a == b\") for unordered operations and\n$(D \"a < b\") for ordered operations.\n\nExample:\n\n----\nint[] a = ...;\nstatic bool greater(int a, int b)\n{\n    return a > b;\n}\nsort!(greater)(a);  // predicate as alias\nsort!(\"a > b\")(a);  // predicate as string\n                    // (no ambiguity with array name)\nsort(a);            // no predicate, \"a < b\" is implicit\n----\n\nMacros:\nWIKI = Phobos/StdAlgorithm\nSUBMODULE = $(LINK2 std_algorithm_$1.html, std.algorithm.$1)\nSUBREF = $(LINK2 std_algorithm_$1.html#.$2, $(TT $2))$(NBSP)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/_algorithm/package.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/searching.d",
		"name": "std.algorithm.searching",
		"members": [
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "all",
								"line": 107,
								"type": "bool(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 113,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "all",
						"line": 107,
						"comment": "    Returns $(D true) if and only if $(I _all) values $(D v) found in the\n    input _range $(D range) satisfy the predicate $(D pred).\n    Performs (at most) $(BIGOH range.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(typeof(unaryFun!pred(range.front)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "all",
				"line": 100,
				"comment": "Checks if $(I _all) of the elements verify $(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL117_2767)\n---\nassert( all!\"a & 1\"([1, 3, 5, 7, 9]));\nassert(!all!\"a & 1\"([1, 2, 3, 5, 7, 9]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL117_2767)\nExample:\n$(D all) can also be used without a predicate, if its items can be\nevaluated to true or false in a conditional statement. This can be a\nconvenient way to quickly evaluate that $(I _all) of the elements of a range\nare true.$(DDOX_UNITTEST_HEADER __unittestL129_2768)\n---\nint[3] vals = [5, 3, 18];\nassert( all(vals[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL129_2768)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "any",
								"line": 153,
								"type": "bool(Range range)",
								"parameters": [
									{
										"name": "range",
										"type": "Range"
									}
								],
								"endline": 157,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "any",
						"line": 153,
						"comment": "    Returns $(D true) if and only if $(I _any) value $(D v) found in the\n    input _range $(D range) satisfies the predicate $(D pred).\n    Performs (at most) $(BIGOH range.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range && is(typeof(unaryFun!pred(range.front)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "any",
				"line": 146,
				"comment": "Checks if $(I _any) of the elements verifies $(D pred).\n$(D !any) can be used to verify that $(I none) of the elements verify\n$(D pred).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL161_2771)\n---\nimport std.ascii : isWhite;\nassert( all!(any!isWhite)([\"a a\", \"b b\"]));\nassert(!any!(all!isWhite)([\"a a\", \"b b\"]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL161_2771)\nExample:\n$(D any) can also be used without a predicate, if its items can be\nevaluated to true or false in a conditional statement. $(D !any) can be a\nconvenient way to quickly test that $(I none) of the elements of a range\nevaluate to true.$(DDOX_UNITTEST_HEADER __unittestL174_2772)\n---\nint[3] vals1 = [0, 0, 0];\nassert(!any(vals1[])); //none of vals1 evaluate to true\n\nint[3] vals2 = [2, 0, 2];\nassert( any(vals2[]));\nassert(!all(vals2[]));\n\nint[3] vals3 = [3, 3, 3];\nassert( any(vals3[]));\nassert( all(vals3[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL174_2772)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "balancedParens",
						"line": 204,
						"type": "bool(Range r, E lPar, E rPar, size_t maxNestingLevel = size_t.max)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "lPar",
								"type": "E"
							},
							{
								"name": "rPar",
								"type": "E"
							},
							{
								"name": "maxNestingLevel",
								"type": "size_t",
								"default": "size_t.max"
							}
						],
						"endline": 223,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "balancedParens",
				"line": 204,
				"comment": "Checks whether $(D r) has \"balanced parentheses\", i.e. all instances\nof $(D lPar) are closed by corresponding instances of $(D rPar). The\nparameter $(D maxNestingLevel) controls the nesting level allowed. The\nmost common uses are the default or $(D 0). In the latter case, no\nnesting is allowed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL226_2774)\n---\nauto s = \"1 + (2 * (3 + 1 / 2)\";\nassert(!balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(!balancedParens(s, '(', ')', 0));\ns = \"1 + (2 * 3 + 1) / (2 - 5)\";\nassert(balancedParens(s, '(', ')', 0));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL226_2774)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && is(typeof(r.front == lPar))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "boyerMooreFinder",
						"line": 253,
						"type": "BoyerMooreFinder!(binaryFun!pred, Range)(Range needle)",
						"parameters": [
							{
								"name": "needle",
								"type": "Range"
							}
						],
						"endline": 258,
						"char": 44,
						"kind": "function"
					}
				],
				"name": "boyerMooreFinder",
				"line": 253,
				"comment": " Sets up Boyer-Moore matching for use with $(D find) below.\n By default, elements are compared for equality.\n\n $(D BoyerMooreFinder) allocates GC memory.\n\n Params:\n pred = Predicate used to compare elements.\n needle = A random-access range with length and slicing.\n\n Returns:\n An instance of $(D BoyerMooreFinder) that can be used with $(D find()) to\n invoke the Boyer-Moore matching algorithm for finding of $(D needle) in a\n given haystack.\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Range || isSomeString!Range",
				"char": 44,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BoyerMooreFinder",
						"line": 261,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "BoyerMooreFinder",
				"line": 261,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 379,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 410,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 379,
				"comment": "Returns the common prefix of two ranges.\n\nParams:\n    pred = The predicate to use in comparing elements for commonality. Defaults\n        to equality $(D \"a == b\").\n\n    r1 = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) of\n        elements.\n\n    r2 = An $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n        elements.\n\nReturns:\nA slice of $(D r1) which contains the characters that both ranges start with,\nif the first argument is a string; otherwise, the same as the result of\n$(D takeExactly(r1, n)), where $(D n) is the number of elements in the common\nprefix of both ranges.\n\nSee_Also:\n    $(XREF range, takeExactly)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL413_2775)\n---\nassert(commonPrefix(\"hello, world\", \"hello, there\") == \"hello, \");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL413_2775)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isInputRange!R2 && !isNarrowString!R1 && is(typeof(binaryFun!pred(r1.front, r2.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 419,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 437,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 419,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!R1 && isInputRange!R2 && is(typeof(binaryFun!pred(r1.front, r2.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 440,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 445,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 440,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!R1 && isInputRange!R2 && !isNarrowString!R2 && is(typeof(r1.front == r2.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "commonPrefix",
						"line": 448,
						"type": "(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 476,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "commonPrefix",
				"line": 448,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!R1 && isNarrowString!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 562,
						"type": "size_t(Range haystack, E needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "Range"
							},
							{
								"name": "needle",
								"type": "E"
							}
						],
						"endline": 568,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 562,
				"comment": "The first version counts the number of elements $(D x) in $(D r) for\nwhich $(D pred(x, value)) is $(D true). $(D pred) defaults to\nequality. Performs $(BIGOH haystack.length) evaluations of $(D pred).\n\nThe second version returns the number of times $(D needle) occurs in\n$(D haystack). Throws an exception if $(D needle.empty), as the _count\nof the empty range in any range would be infinite. Overlapped counts\nare not considered, for example $(D count(\"aaa\", \"aa\")) is $(D 1), not\n$(D 2).\n\nThe third version counts the elements for which $(D pred(x)) is $(D\ntrue). Performs $(BIGOH haystack.length) evaluations of $(D pred).\n\nNote: Regardless of the overload, $(D count) will not accept\ninfinite ranges for $(D haystack).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL571_2779)\n---\nimport std.uni : toLower;\n\n// count elements in range\nint[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];\nassert(count(a, 2) == 3);\nassert(count!(\"a > b\")(a, 2) == 5);\n// count range in range\nassert(count(\"abcadfabf\", \"ab\") == 2);\nassert(count(\"ababab\", \"abab\") == 1);\nassert(count(\"ababab\", \"abx\") == 0);\n// fuzzy count range in range\nassert(count!((a, b) => std.uni.toLower(a) == std.uni.toLower(b))(\"AbcAdFaBf\", \"ab\") == 2);\n// count predicate in range\nassert(count!(\"a > 1\")(a) == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL571_2779)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !isInfinite!Range && is(typeof(binaryFun!pred(haystack.front, needle)) : bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 619,
						"type": "size_t(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 640,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 619,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && !isInfinite!R1 && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "count",
						"line": 643,
						"type": "size_t(R haystack)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							}
						],
						"endline": 652,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "count",
				"line": 643,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"true\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !isInfinite!R && is(typeof(unaryFun!pred(haystack.front)) : bool)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countUntil",
						"line": 690,
						"type": "ptrdiff_t(R haystack, Rs needles)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							},
							{
								"name": "needles",
								"type": "Rs"
							}
						],
						"endline": 775,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "countUntil",
				"line": 690,
				"comment": "    Counts elements in the given\n    $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\n    until the given predicate is true for one of the given $(D needles).\n\n    Params:\n        pred = The predicate for determining when to stop counting.\n        haystack = The\n            $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to be\n            counted.\n        needles = Either a single element, or a\n            $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\n            of elements, to be evaluated in turn against each\n            element in $(D haystack) under the given predicate.\n\n    Returns: The number of elements which must be popped from the front of\n    $(D haystack) before reaching an element for which\n    $(D startsWith!pred(haystack, needles)) is $(D true). If\n    $(D startsWith!pred(haystack, needles)) is not $(D true) for any element in\n    $(D haystack), then $(D -1) is returned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL787_2784)\n---\nassert(countUntil(\"hello world\", \"world\") == 6);\nassert(countUntil(\"hello world\", 'r') == 8);\nassert(countUntil(\"hello world\", \"programming\") == -1);\nassert(countUntil(\"æ¥æ¬èª\", \"æ¬èª\") == 1);\nassert(countUntil(\"æ¥æ¬èª\", 'èª')   == 2);\nassert(countUntil(\"æ¥æ¬èª\", \"äº\") == -1);\nassert(countUntil(\"æ¥æ¬èª\", 'äº') == -1);\nassert(countUntil([0, 7, 12, 22, 9], [12, 22]) == 2);\nassert(countUntil([0, 7, 12, 22, 9], 9) == 4);\nassert(countUntil!\"a > b\"([0, 7, 12, 22, 9], 20) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL787_2784)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "isForwardRange!R && Rs.length > 0 && isForwardRange!(Rs[0]) == isInputRange!(Rs[0]) && is(typeof(startsWith!pred(haystack, needles[0]))) && (Rs.length == 1 || is(typeof(countUntil!pred(haystack, needles[1..__dollar]))))",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countUntil",
						"line": 778,
						"type": "ptrdiff_t(R haystack, N needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							},
							{
								"name": "needle",
								"type": "N"
							}
						],
						"endline": 784,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "countUntil",
				"line": 778,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "N",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(binaryFun!pred(haystack.front, needle)) : bool)",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "countUntil",
						"line": 848,
						"type": "ptrdiff_t(R haystack)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R"
							}
						],
						"endline": 889,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "countUntil",
				"line": 848,
				"comment": "    Similar to the previous overload of $(D countUntil), except that this one\n    evaluates only the predicate $(D pred).\n\n    Params:\n        pred = Predicate to when to stop counting.\n        haystack = An\n          $(XREF_PACK_NAMED range,primitives,isInputRange,input range) of\n          elements to be counted.\n    Returns: The number of elements which must be popped from $(D haystack)\n    before $(D pred(haystack.front)) is $(D true).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL892_2787)\n---\nimport std.ascii : isDigit;\nimport std.uni : isWhite;\n\nassert(countUntil!(std.uni.isWhite)(\"hello world\") == 5);\nassert(countUntil!(std.ascii.isDigit)(\"hello world\") == -1);\nassert(countUntil!\"a > 20\"([0, 7, 12, 22, 9]) == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL892_2787)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(unaryFun!pred(haystack.front)) : bool)",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "endsWith",
						"line": 954,
						"type": "uint(Range doesThisEnd, Needles withOneOfThese)",
						"parameters": [
							{
								"name": "doesThisEnd",
								"type": "Range"
							},
							{
								"name": "withOneOfThese",
								"type": "Needles"
							}
						],
						"endline": 1018,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "endsWith",
				"line": 954,
				"comment": "Checks if the given range ends with (one of) the given needle(s).\nThe reciprocal of $(D startsWith).\n\nParams:\n    pred = The predicate to use for comparing elements between the range and\n        the needle(s).\n\n    doesThisEnd = The\n        $(XREF_PACK_NAMED range,primitives,isBidirectionalRange,bidirectional range)\n        to check.\n\n    withOneOfThese = The needles to check against, which may be single\n        elements, or bidirectional ranges of elements.\n\n    withThis = The single element to check.\n\nReturns:\n0 if the needle(s) do not occur at the end of the given range;\notherwise the position of the matching needle, that is, 1 if the range ends\nwith $(D withOneOfThese[0]), 2 if it ends with $(D withOneOfThese[1]), and so\non.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1059_2789)\n---\nassert(endsWith(\"abc\", \"\"));\nassert(!endsWith(\"abc\", \"b\"));\nassert(endsWith(\"abc\", \"a\", 'c') == 2);\nassert(endsWith(\"abc\", \"c\", \"a\") == 1);\nassert(endsWith(\"abc\", \"c\", \"c\") == 1);\nassert(endsWith(\"abc\", \"bc\", \"c\") == 2);\nassert(endsWith(\"abc\", \"x\", \"c\", \"b\") == 2);\nassert(endsWith(\"abc\", \"x\", \"aa\", \"bc\") == 3);\nassert(endsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(endsWith(\"abc\", \"x\", \"aaa\", 'c', \"sab\") == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1059_2789)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Needles",
						"kind": "tuple"
					}
				],
				"constraint": "isBidirectionalRange!Range && Needles.length > 1 && is(typeof(.endsWith!pred(doesThisEnd, withOneOfThese[0])) : bool) && is(typeof(.endsWith!pred(doesThisEnd, withOneOfThese[1..__dollar])) : uint)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "endsWith",
						"line": 1021,
						"type": "bool(R1 doesThisEnd, R2 withThis)",
						"parameters": [
							{
								"name": "doesThisEnd",
								"type": "R1"
							},
							{
								"name": "withThis",
								"type": "R2"
							}
						],
						"endline": 1046,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "endsWith",
				"line": 1021,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R1 && isBidirectionalRange!R2 && is(typeof(binaryFun!pred(doesThisEnd.back, withThis.back)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "endsWith",
						"line": 1049,
						"type": "bool(R doesThisEnd, E withThis)",
						"parameters": [
							{
								"name": "doesThisEnd",
								"type": "R"
							},
							{
								"name": "withThis",
								"type": "E"
							}
						],
						"endline": 1056,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "endsWith",
				"line": 1049,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R && is(typeof(binaryFun!pred(doesThisEnd.back, withThis)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1195,
						"type": "InputRange(InputRange haystack, Element needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "InputRange"
							},
							{
								"name": "needle",
								"type": "Element"
							}
						],
						"endline": 1329,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1195,
				"comment": "Finds an individual element in an input range. Elements of $(D\nhaystack) are compared with $(D needle) by using predicate $(D\npred). Performs $(BIGOH walkLength(haystack)) evaluations of $(D\npred).\n\nTo _find the last occurrence of $(D needle) in $(D haystack), call $(D\nfind(retro(haystack), needle)). See $(XREF range, retro).\n\nParams:\n\npred = The predicate for comparing each element with the needle, defaulting to\n$(D \"a == b\").\nThe negated predicate $(D \"a != b\") can be used to search instead for the first\nelement $(I not) matching the needle.\n\nhaystack = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range)\nsearched in.\n\nneedle = The element searched for.\n\nConstraints:\n\n$(D isInputRange!InputRange && is(typeof(binaryFun!pred(haystack.front, needle)\n: bool)))\n\nReturns:\n\n$(D haystack) advanced such that the front element is the one searched for;\nthat is, until $(D binaryFun!pred(haystack.front, needle)) is $(D true). If no\nsuch position exists, returns an empty $(D haystack).\n\nSee_Also:\n     $(WEB sgi.com/tech/stl/_find.html, STL's _find)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1332_2791)\n---\nimport std.algorithm.comparison : equal;\nimport std.container : SList;\n\nassert(find(\"hello, world\", ',') == \", world\");\nassert(find([1, 2, 3, 5], 4) == []);\nassert(equal(find(SList!int(1, 2, 3, 4, 5)[], 4), SList!int(4, 5)[]));\nassert(find!\"a > b\"([1, 2, 3, 5], 2) == [3, 5]);\n\nauto a = [ 1, 2, 3 ];\nassert(find(a, 5).empty);       // not found\nassert(!find(a, 2).empty);      // found\n\n// Case-insensitive find of a string\nstring[] s = [ \"Hello\", \"world\", \"!\" ];\nassert(!find!(\"toLower(a) == b\")(s, \"hello\").empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1332_2791)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "InputRange",
						"kind": "type"
					},
					{
						"name": "Element",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!InputRange && is(typeof(binaryFun!pred(haystack.front, needle)) : bool)",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1480,
						"type": "InputRange(InputRange haystack)",
						"parameters": [
							{
								"name": "haystack",
								"type": "InputRange"
							}
						],
						"endline": 1520,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1480,
				"comment": "Advances the input range $(D haystack) by calling $(D haystack.popFront)\nuntil either $(D pred(haystack.front)), or $(D\nhaystack.empty). Performs $(BIGOH haystack.length) evaluations of $(D\npred).\n\nTo _find the last element of a bidirectional $(D haystack) satisfying\n$(D pred), call $(D find!(pred)(retro(haystack))). See $(XREF\nrange, retro).\n\nParams:\n\npred = The predicate for determining if a given element is the one being\nsearched for.\n\nhaystack = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\nsearch in.\n\nReturns:\n\n$(D haystack) advanced such that the front element is the one searched for;\nthat is, until $(D binaryFun!pred(haystack.front, needle)) is $(D true). If no\nsuch position exists, returns an empty $(D haystack).\n\nSee_Also:\n     $(WEB sgi.com/tech/stl/find_if.html, STL's find_if)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1523_2812)\n---\nauto arr = [ 1, 2, 3, 4, 1 ];\nassert(find!(\"a > 2\")(arr) == [ 3, 4, 1 ]);\n\n// with predicate alias\nbool pred(int x) { return x + 1 > 1.5; }\nassert(find!(pred)(arr) == arr);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1523_2812)\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "InputRange",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!InputRange",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1569,
						"type": "R1(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 1591,
						"char": 4,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1569,
				"comment": "Finds the first occurrence of a forward range in another forward range.\n\nPerforms $(BIGOH walkLength(haystack) * walkLength(needle)) comparisons in the\nworst case.  There are specializations that improve performance by taking\nadvantage of bidirectional or random access in the given ranges (where\npossible), depending on the statistics of the two ranges' content.\n\nParams:\n\npred = The predicate to use for comparing respective elements from the haystack\nand the needle. Defaults to simple equality $(D \"a == b\").\n\nhaystack = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\nsearched in.\n\nneedle = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\nsearched for.\n\nReturns:\n\n$(D haystack) advanced such that $(D needle) is a prefix of it (if no\nsuch position exists, returns $(D haystack) advanced to termination).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1594_2817)\n---\nimport std.container : SList;\n\nassert(find(\"hello, world\", \"World\").empty);\nassert(find(\"hello, world\", \"wo\") == \"world\");\nassert([1, 2, 3, 4].find(SList!int(2, 3)[]) == [2, 3, 4]);\nalias C = Tuple!(int, \"x\", int, \"y\");\nauto a = [C(1,0), C(2,0), C(3,1), C(4,0)];\nassert(a.find!\"a.x == b\"([2, 3]) == [C(2,0), C(3,1), C(4,0)]);\nassert(a[1 .. $].find!\"a.x == b\"([2, 3]) == [C(2,0), C(3,1), C(4,0)]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1594_2817)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool) && !isRandomAccessRange!R1",
				"char": 4,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 1934,
						"type": "Tuple!(Range, size_t)(Range haystack, Ranges needles)",
						"parameters": [
							{
								"name": "haystack",
								"type": "Range"
							},
							{
								"name": "needles",
								"type": "Ranges"
							}
						],
						"endline": 1946,
						"char": 23,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 1934,
				"comment": "Finds two or more $(D needles) into a $(D haystack). The predicate $(D\npred) is used throughout to compare elements. By default, elements are\ncompared for equality.\n\nParams:\n\npred = The predicate to use for comparing elements.\n\nhaystack = The target of the search. Must be an input range.\nIf any of $(D needles) is a range with elements comparable to\nelements in $(D haystack), then $(D haystack) must be a forward range\nsuch that the search can backtrack.\n\nneedles = One or more items to search for. Each of $(D needles) must\nbe either comparable to one element in $(D haystack), or be itself a\nforward range with elements comparable with elements in\n$(D haystack).\n\nReturns:\n\nA tuple containing $(D haystack) positioned to match one of the\nneedles and also the 1-based index of the matching element in $(D\nneedles) (0 if none of $(D needles) matched, 1 if $(D needles[0])\nmatched, 2 if $(D needles[1]) matched...). The first needle to be found\nwill be the one that matches. If multiple needles are found at the\nsame spot in the range, then the shortest one is the one which matches\n(if multiple needles of the same length are found at the same spot (e.g\n$(D \"a\") and $(D 'a')), then the left-most of them in the argument list\nmatches).\n\nThe relationship between $(D haystack) and $(D needles) simply means\nthat one can e.g. search for individual $(D int)s or arrays of $(D\nint)s in an array of $(D int)s. In addition, if elements are\nindividually comparable, searches of heterogeneous types are allowed\nas well: a $(D double[]) can be searched for an $(D int) or a $(D\nshort[]), and conversely a $(D long) can be searched for a $(D float)\nor a $(D double[]). This makes for efficient searches without the need\nto coerce one side of the comparison into the other's side type.\n\nThe complexity of the search is $(BIGOH haystack.length *\nmax(needles.length)). (For needles that are individual items, length\nis considered to be 1.) The strategy used in searching several\nsubranges at once maximizes cache usage by moving in $(D haystack) as\nfew times as possible.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1949_2824)\n---\nint[] a = [ 1, 4, 2, 3 ];\nassert(find(a, 4) == [ 4, 2, 3 ]);\nassert(find(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);\nassert(find(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));\n// Mixed types allowed if comparable\nassert(find(a, 5, [ 1.2, 3.5 ], 2.0) == tuple([ 2, 3 ], 3));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1949_2824)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 1 && is(typeof(startsWith!pred(haystack, needles)))",
				"char": 23,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "find",
						"line": 2058,
						"type": "Range1(Range1 haystack, BoyerMooreFinder!(pred, Range2) needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "Range1"
							},
							{
								"name": "needle",
								"type": "BoyerMooreFinder!(pred, Range2)"
							}
						],
						"endline": 2062,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "find",
				"line": 2058,
				"comment": " Finds $(D needle) in $(D haystack) efficiently using the\n $(LUCKY Boyer-Moore) method.\n\n Params:\n haystack = A random-access range with length and slicing.\n needle = A $(LREF BoyerMooreFinder).\n\n Returns:\n $(D haystack) advanced such that $(D needle) is a prefix of it (if no\n such position exists, returns $(D haystack) advanced to termination).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2079_2830)\n---\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 1, 2, 3 ];\n\nassert(find(a, boyerMooreFinder(b)) == [ 1, 2, 3, 4, 5 ]);\nassert(find(b, boyerMooreFinder(a)).empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2079_2830)\n",
				"parameters": [
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "canFind",
								"line": 2112,
								"type": "bool(Range haystack)",
								"parameters": [
									{
										"name": "haystack",
										"type": "Range"
									}
								],
								"endline": 2116,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "canFind",
						"line": 2112,
						"comment": "    Returns $(D true) if and only if any value $(D v) found in the\n    input range $(D range) satisfies the predicate $(D pred).\n    Performs (at most) $(BIGOH haystack.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							}
						],
						"constraint": "is(typeof(find!pred(haystack)))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "canFind",
								"line": 2122,
								"type": "bool(Range haystack, Element needle)",
								"parameters": [
									{
										"name": "haystack",
										"type": "Range"
									},
									{
										"name": "needle",
										"type": "Element"
									}
								],
								"endline": 2126,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "canFind",
						"line": 2122,
						"comment": "    Returns $(D true) if and only if $(D needle) can be found in $(D\n    range). Performs $(BIGOH haystack.length) evaluations of $(D pred).\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							},
							{
								"name": "Element",
								"kind": "type"
							}
						],
						"constraint": "is(typeof(find!pred(haystack, needle)))",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "canFind",
								"line": 2139,
								"type": "size_t(Range haystack, Ranges needles)",
								"parameters": [
									{
										"name": "haystack",
										"type": "Range"
									},
									{
										"name": "needles",
										"type": "Ranges"
									}
								],
								"endline": 2145,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "canFind",
						"line": 2139,
						"comment": "    Returns the 1-based index of the first needle found in $(D haystack). If no\n    needle is found, then $(D 0) is returned.\n\n    So, if used directly in the condition of an if statement or loop, the result\n    will be $(D true) if one of the needles is found and $(D false) if none are\n    found, whereas if the result is used elsewhere, it can either be cast to\n    $(D bool) for the same effect or used to get which needle was found first\n    without having to deal with the tuple that $(D LREF find) returns for the\n    same operation.\n",
						"parameters": [
							{
								"name": "Range",
								"kind": "type"
							},
							{
								"name": "Ranges",
								"kind": "tuple"
							}
						],
						"constraint": "Ranges.length > 1 && allSatisfy!(isForwardRange, Ranges) && is(typeof(find!pred(haystack, needles)))",
						"char": 12,
						"kind": "template"
					}
				],
				"name": "canFind",
				"line": 2103,
				"comment": "Convenience function. Like find, but only returns whether or not the search\nwas successful.\n\nSee_Also:\n$(LREF among) for checking a value against multiple possibilities.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2149_2832)\n---\nassert(canFind([0, 1, 2, 3], 2) == true);\nassert(canFind([0, 1, 2, 3], [1, 2], [2, 3]));\nassert(canFind([0, 1, 2, 3], [1, 2], [2, 3]) == 1);\nassert(canFind([0, 1, 2, 3], [1, 7], [2, 3]));\nassert(canFind([0, 1, 2, 3], [1, 7], [2, 3]) == 2);\n\nassert(canFind([0, 1, 2, 3], 4) == false);\nassert(!canFind([0, 1, 2, 3], [1, 3], [2, 4]));\nassert(canFind([0, 1, 2, 3], [1, 3], [2, 4]) == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2149_2832)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findAdjacent",
						"line": 2200,
						"type": "Range(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 2213,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "findAdjacent",
				"line": 2200,
				"comment": "Advances $(D r) until it finds the first two adjacent elements $(D a),\n$(D b) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)\nevaluations of $(D pred).\n\nParams:\n    pred = The predicate to satisfy.\n    r = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to\n        search in.\n\nReturns:\n$(D r) advanced to the first occurrence of two adjacent elements that satisfy\nthe given predicate. If there are no such two elements, returns $(D r) advanced\nuntil empty.\n\nSee_Also:\n     $(WEB sgi.com/tech/stl/adjacent_find.html, STL's adjacent_find)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2216_2835)\n---\nint[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];\nauto r = findAdjacent(a);\nassert(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);\nauto p = findAdjacent!(\"a < b\")(a);\nassert(p == [ 7, 8, 9 ]);\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2216_2835)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findAmong",
						"line": 2277,
						"type": "Range1(Range1 seq, Range2 choices)",
						"parameters": [
							{
								"name": "seq",
								"type": "Range1"
							},
							{
								"name": "choices",
								"type": "Range2"
							}
						],
						"endline": 2285,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "findAmong",
				"line": 2277,
				"comment": "Searches the given range for an element that matches one of the given choices.\n\nAdvances $(D seq) by calling $(D seq.popFront) until either\n$(D find!(pred)(choices, seq.front)) is $(D true), or $(D seq) becomes empty.\nPerforms $(BIGOH seq.length * choices.length) evaluations of $(D pred).\n\nParams:\n    pred = The predicate to use for determining a match.\n    seq = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to\n        search.\n    choices = A $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range)\n        of possible choices.\n\nReturns:\n$(D seq) advanced to the first matching element, or until empty if there are no\nmatching elements.\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/find_first_of.html, STL's find_first_of)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2288_2837)\n---\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 3, 1, 2 ];\nassert(findAmong(a, b) == a[2 .. $]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2288_2837)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isForwardRange!Range2",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSkip",
						"line": 2323,
						"type": "bool(ref R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2332,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "findSkip",
				"line": 2323,
				"comment": " Finds $(D needle) in $(D haystack) and positions $(D haystack)\n right after the first occurrence of $(D needle).\n\n Params:\n  haystack = The\n   $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to search\n   in.\n  needle = The\n   $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to search\n   for.\n\n Returns: $(D true) if the needle was found, in which case $(D haystack) is\n positioned after the end of the first occurrence of $(D needle); otherwise\n $(D false), leaving $(D haystack) untouched.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2335_2839)\n---\n// Needle is found; s is replaced by the substring following the first\n// occurrence of the needle.\nstring s = \"abcdef\";\nassert(findSkip(s, \"cd\") && s == \"ef\");\n\n// Needle is not found; s is left untouched.\ns = \"abcdef\";\nassert(!findSkip(s, \"cxd\") && s == \"abcdef\");\n\n// If the needle occurs at the end of the range, the range is left empty.\ns = \"abcdef\";\nassert(findSkip(s, \"def\") && s.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2335_2839)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2 && is(typeof(binaryFun!pred(haystack.front, needle.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSplit",
						"line": 2383,
						"type": "(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2423,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "findSplit",
				"line": 2383,
				"comment": "These functions find the first occurrence of $(D needle) in $(D\nhaystack) and then split $(D haystack) as follows.\n\n$(D findSplit) returns a tuple $(D result) containing $(I three)\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), $(D result[1]) is the portion of $(D haystack) that matches\n$(D needle), and $(D result[2]) is the portion of $(D haystack) after\nthe match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) and $(D result[2])\nare empty.\n\n$(D findSplitBefore) returns a tuple $(D result) containing two\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), and $(D result[1]) is the balance of $(D haystack) starting\nwith the match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) is empty.\n\n$(D findSplitAfter) returns a tuple $(D result) containing two ranges.\n$(D result[0]) is the portion of $(D haystack) up to and including the\nmatch, and $(D result[1]) is the balance of $(D haystack) starting\nafter the match. If $(D needle) was not found, $(D result[0]) is empty\nand $(D result[1]) is $(D haystack).\n\nIn all cases, the concatenation of the returned ranges spans the\nentire $(D haystack).\n\nIf $(D haystack) is a random-access range, all three components of the\ntuple have the same type as $(D haystack). Otherwise, $(D haystack)\nmust be a forward range and the type of $(D result[0]) and $(D\nresult[1]) is the same as $(XREF range,takeExactly).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2506_2840)\n---\nauto a = \"Carl Sagan Memorial Station\";\nauto r = findSplit(a, \"Velikovsky\");\nassert(r[0] == a);\nassert(r[1].empty);\nassert(r[2].empty);\nr = findSplit(a, \" \");\nassert(r[0] == \"Carl\");\nassert(r[1] == \" \");\nassert(r[2] == \"Sagan Memorial Station\");\nauto r1 = findSplitBefore(a, \"Sagan\");\nassert(r1[0] == \"Carl \", r1[0]);\nassert(r1[1] == \"Sagan Memorial Station\");\nauto r2 = findSplitAfter(a, \"Sagan\");\nassert(r2[0] == \"Carl Sagan\");\nassert(r2[1] == \" Memorial Station\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2506_2840)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSplitBefore",
						"line": 2426,
						"type": "(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2460,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "findSplitBefore",
				"line": 2426,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "findSplitAfter",
						"line": 2463,
						"type": "(R1 haystack, R2 needle)",
						"parameters": [
							{
								"name": "haystack",
								"type": "R1"
							},
							{
								"name": "needle",
								"type": "R2"
							}
						],
						"endline": 2503,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "findSplitAfter",
				"line": 2463,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isForwardRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "minCount",
						"line": 2590,
						"type": "Tuple!(ElementType!Range, size_t)(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 2668,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "minCount",
				"line": 2590,
				"comment": "Returns the minimum element of a range together with the number of\noccurrences. The function can actually be used for counting the\nmaximum or any other ordering predicate (that's why $(D maxCount) is\nnot provided).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2671_2843)\n---\nimport std.conv : text;\n\ndebug(std_algorithm) scope(success)\n    writeln(\"unittest @\", __FILE__, \":\", __LINE__, \" done.\");\n\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and occurs 3 times\nassert(minCount(a) == tuple(1, 3));\n// Maximum is 4 and occurs 2 times\nassert(minCount!(\"a > b\")(a) == tuple(4, 2));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2671_2843)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !isInfinite!Range && is(typeof(binaryFun!pred(range.front, range.front)))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "minPos",
						"line": 2780,
						"type": "Range(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 2797,
						"char": 7,
						"kind": "function"
					}
				],
				"name": "minPos",
				"line": 2780,
				"comment": "Returns the position of the minimum element of forward range $(D\nrange), i.e. a subrange of $(D range) starting at the position of its\nsmallest element and with the same ending as $(D range). The function\ncan actually be used for finding the maximum or any other ordering\npredicate (that's why $(D maxPos) is not provided).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2800_2846)\n---\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and first occurs in position 3\nassert(minPos(a) == [ 1, 2, 4, 1, 1, 2 ]);\n// Maximum is 4 and first occurs in position 2\nassert(minPos!(\"a > b\")(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2800_2846)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && !isInfinite!Range && is(typeof(binaryFun!pred(range.front, range.front)))",
				"char": 7,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 2872,
						"type": "bool(ref R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 2891,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 2872,
				"comment": "Skip over the initial portion of the first given range that matches the second\nrange, or do nothing if there is no match.\n\nParams:\n    pred = The predicate that determines whether elements from each respective\n        range match. Defaults to equality $(D \"a == b\").\n    r1 = The $(XREF_PACK_NAMED range,primitives,isForwardRange,forward range) to\n        move forward.\n    r2 = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range)\n        representing the initial segment of $(D r1) to skip over.\n\nReturns:\ntrue if the initial segment of $(D r1) matches $(D r2), and $(D r1) has been\nadvanced to the point past this segment; otherwise false, and $(D r1) is left\nin its original position.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2917_2856)\n---\nimport std.algorithm.comparison : equal;\n\nauto s1 = \"Hello world\";\nassert(!skipOver(s1, \"Ha\"));\nassert(s1 == \"Hello world\");\nassert(skipOver(s1, \"Hell\") && s1 == \"o world\");\n\nstring[]  r1 = [\"abc\", \"def\", \"hij\"];\ndstring[] r2 = [\"abc\"d];\nassert(!skipOver!((a, b) => a.equal(b))(r1, [\"def\"d]));\nassert(r1 == [\"abc\", \"def\", \"hij\"]);\nassert(skipOver!((a, b) => a.equal(b))(r1, r2));\nassert(r1 == [\"def\", \"hij\"]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2917_2856)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R1 && isInputRange!R2 && is(typeof(r1.front == r2.front))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 2894,
						"type": "bool(ref R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 2914,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 2894,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r1.front, r2.front))) && isForwardRange!R1 && isInputRange!R2",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 2952,
						"type": "bool(ref R r, E e)",
						"parameters": [
							{
								"name": "r",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "e",
								"type": "E"
							}
						],
						"endline": 2956,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 2952,
				"comment": "Skip over the first element of the given range if it matches the given element,\notherwise do nothing.\n\nParams:\n    pred = The predicate that determines whether an element from the range\n        matches the given element.\n\n    r = The $(XREF_PACK_NAMED range,primitives,isInputRange,input range) to skip\n        over.\n\n    e = The element to match.\n\nReturns:\ntrue if the first element matches the given element according to the given\npredicate, and the range has been advanced by one element; otherwise false, and\nthe range is left untouched.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2969_2863)\n---\nimport std.algorithm.comparison : equal;\n\nauto s1 = \"Hello world\";\nassert(!skipOver(s1, 'a'));\nassert(s1 == \"Hello world\");\nassert(skipOver(s1, 'H') && s1 == \"ello world\");\n\nstring[] r = [\"abc\", \"def\", \"hij\"];\ndstring e = \"abc\"d;\nassert(!skipOver!((a, b) => a.equal(b))(r, \"def\"d));\nassert(r == [\"abc\", \"def\", \"hij\"]);\nassert(skipOver!((a, b) => a.equal(b))(r, e));\nassert(r == [\"def\", \"hij\"]);\n\nauto s2 = \"\";\nassert(!s2.skipOver('a'));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2969_2863)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(r.front == e) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "skipOver",
						"line": 2959,
						"type": "bool(ref R r, E e)",
						"parameters": [
							{
								"name": "r",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "e",
								"type": "E"
							}
						],
						"endline": 2966,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "skipOver",
				"line": 2959,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(binaryFun!pred(r.front, e))) && isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "startsWith",
						"line": 3020,
						"type": "uint(Range doesThisStart, Needles withOneOfThese)",
						"parameters": [
							{
								"name": "doesThisStart",
								"type": "Range"
							},
							{
								"name": "withOneOfThese",
								"type": "Needles"
							}
						],
						"endline": 3090,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "startsWith",
				"line": 3020,
				"comment": "Checks whether the given\n$(XREF_PACK_NAMED range,primitives,isInputRange,input range) starts with (one\nof) the given needle(s).\n\nParams:\n\n    pred = Predicate to use in comparing the elements of the haystack and the\n        needle(s).\n\n    doesThisStart = The input range to check.\n\n    withOneOfThese = The needles against which the range is to be checked,\n        which may be individual elements or input ranges of elements.\n\n    withThis = The single needle to check, which may be either a single element\n        or an input range of elements.\n\nReturns:\n\n0 if the needle(s) do not occur at the beginning of the given range;\notherwise the position of the matching needle, that is, 1 if the range starts\nwith $(D withOneOfThese[0]), 2 if it starts with $(D withOneOfThese[1]), and so\non.\n\nIn the case where $(D doesThisStart) starts with multiple of the ranges or\nelements in $(D withOneOfThese), then the shortest one matches (if there are\ntwo which match which are of the same length (e.g. $(D \"a\") and $(D 'a')), then\nthe left-most of them in the argument\nlist matches).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3172_2864)\n---\nassert(startsWith(\"abc\", \"\"));\nassert(startsWith(\"abc\", \"a\"));\nassert(!startsWith(\"abc\", \"b\"));\nassert(startsWith(\"abc\", 'a', \"b\") == 1);\nassert(startsWith(\"abc\", \"b\", \"a\") == 2);\nassert(startsWith(\"abc\", \"a\", \"a\") == 1);\nassert(startsWith(\"abc\", \"ab\", \"a\") == 2);\nassert(startsWith(\"abc\", \"x\", \"a\", \"b\") == 2);\nassert(startsWith(\"abc\", \"x\", \"aa\", \"ab\") == 3);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"a\", \"sab\") == 3);\nalias C = Tuple!(int, \"x\", int, \"y\");\nassert(startsWith!\"a.x == b\"([ C(1,1), C(1,2), C(2,2) ], [1, 1]));\nassert(startsWith!\"a.x == b\"([ C(1,1), C(2,1), C(2,2) ], [1, 1], [1, 2], [1, 3]) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3172_2864)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Needles",
						"kind": "tuple"
					}
				],
				"constraint": "isInputRange!Range && Needles.length > 1 && is(typeof(.startsWith!pred(doesThisStart, withOneOfThese[0])) : bool) && is(typeof(.startsWith!pred(doesThisStart, withOneOfThese[1..__dollar])) : uint)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "startsWith",
						"line": 3093,
						"type": "bool(R1 doesThisStart, R2 withThis)",
						"parameters": [
							{
								"name": "doesThisStart",
								"type": "R1"
							},
							{
								"name": "withThis",
								"type": "R2"
							}
						],
						"endline": 3159,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "startsWith",
				"line": 3093,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2 && is(typeof(binaryFun!pred(doesThisStart.front, withThis.front)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "startsWith",
						"line": 3162,
						"type": "bool(R doesThisStart, E withThis)",
						"parameters": [
							{
								"name": "doesThisStart",
								"type": "R"
							},
							{
								"name": "withThis",
								"type": "E"
							}
						],
						"endline": 3169,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "startsWith",
				"line": 3162,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(typeof(binaryFun!pred(doesThisStart.front, withThis)) : bool)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 3319,
						"value": "0",
						"comment": "Interval is closed to the right (last element included)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 3320,
						"value": "1",
						"comment": "Interval is open to the right (last element is not included)\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "OpenRight",
				"line": 3317,
				"comment": "Interval option specifier for $(D until) (below) and others.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "until",
						"line": 3434,
						"type": "Until!(pred, Range, Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = OpenRight.yes)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "sentinel",
								"type": "Sentinel"
							},
							{
								"name": "openRight",
								"type": "OpenRight",
								"default": "OpenRight.yes"
							}
						],
						"endline": 3439,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "until",
				"line": 3434,
				"comment": "Lazily iterates $(D range) _until the element $(D e) for which\n$(D pred(e, sentinel)) is true.\n\nParams:\n    pred = Predicate to determine when to stop.\n    range = The $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range)\n    to iterate over.\n    sentinel = The element to stop at.\n    openRight = Determines whether the element for which the given predicate is\n        true should be included in the resulting range ($(D OpenRight.no)), or\n        not ($(D OpenRight.yes)).\n\nReturns:\n    An $(XREF_PACK_NAMED _range,primitives,isInputRange,input _range) that\n    iterates over the original range's elements, but ends when the specified\n    predicate becomes true. If the original range is a\n    $(XREF_PACK_NAMED _range,primitives,isForwardRange,forward _range) or\n    higher, this range will be a forward range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3450_2867)\n---\nimport std.algorithm.comparison : equal;\nint[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];\nassert(equal(a.until(7), [1, 2, 4][]));\nassert(equal(a.until(7, OpenRight.no), [1, 2, 4, 7][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3450_2867)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Sentinel",
						"kind": "type"
					}
				],
				"constraint": "!is(Sentinel == OpenRight)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "until",
						"line": 3443,
						"type": "Until!(pred, Range, void)(Range range, OpenRight openRight = OpenRight.yes)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "openRight",
								"type": "OpenRight",
								"default": "OpenRight.yes"
							}
						],
						"endline": 3447,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "until",
				"line": 3443,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "pred",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _searching algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 all,\n        $(D all!\"a > 0\"([1, 2, 3, 4])) returns $(D true) because all elements\n        are positive)\n$(T2 any,\n        $(D any!\"a > 0\"([1, 2, -3, -4])) returns $(D true) because at least one\n        element is positive)\n$(T2 balancedParens,\n        $(D balancedParens(\"((1 + 1) / 2)\")) returns $(D true) because the\n        string has balanced parentheses.)\n$(T2 boyerMooreFinder,\n        $(D find(\"hello world\", boyerMooreFinder(\"or\"))) returns $(D \"orld\")\n        using the $(LUCKY Boyer-Moore _algorithm).)\n$(T2 canFind,\n        $(D canFind(\"hello world\", \"or\")) returns $(D true).)\n$(T2 count,\n        Counts elements that are equal to a specified value or satisfy a\n        predicate.  $(D count([1, 2, 1], 1)) returns $(D 2) and\n        $(D count!\"a < 0\"([1, -3, 0])) returns $(D 1).)\n$(T2 countUntil,\n        $(D countUntil(a, b)) returns the number of steps taken in $(D a) to\n        reach $(D b); for example, $(D countUntil(\"hello!\", \"o\")) returns\n        $(D 4).)\n$(T2 commonPrefix,\n        $(D commonPrefix(\"parakeet\", \"parachute\")) returns $(D \"para\").)\n$(T2 endsWith,\n        $(D endsWith(\"rocks\", \"ks\")) returns $(D true).)\n$(T2 find,\n        $(D find(\"hello world\", \"or\")) returns $(D \"orld\") using linear search.\n        (For binary search refer to $(XREF range,sortedRange).))\n$(T2 findAdjacent,\n        $(D findAdjacent([1, 2, 3, 3, 4])) returns the subrange starting with\n        two equal adjacent elements, i.e. $(D [3, 3, 4]).)\n$(T2 findAmong,\n        $(D findAmong(\"abcd\", \"qcx\")) returns $(D \"cd\") because $(D 'c') is\n        among $(D \"qcx\").)\n$(T2 findSkip,\n        If $(D a = \"abcde\"), then $(D findSkip(a, \"x\")) returns $(D false) and\n        leaves $(D a) unchanged, whereas $(D findSkip(a, 'c')) advances $(D a)\n        to $(D \"cde\") and returns $(D true).)\n$(T2 findSplit,\n        $(D findSplit(\"abcdefg\", \"de\")) returns the three ranges $(D \"abc\"),\n        $(D \"de\"), and $(D \"fg\").)\n$(T2 findSplitAfter,\n        $(D findSplitAfter(\"abcdefg\", \"de\")) returns the two ranges\n        $(D \"abcde\") and $(D \"fg\").)\n$(T2 findSplitBefore,\n        $(D findSplitBefore(\"abcdefg\", \"de\")) returns the two ranges $(D \"abc\")\n        and $(D \"defg\").)\n$(T2 minCount,\n        $(D minCount([2, 1, 1, 4, 1])) returns $(D tuple(1, 3)).)\n$(T2 minPos,\n        $(D minPos([2, 3, 1, 3, 4, 1])) returns the subrange $(D [1, 3, 4, 1]),\n        i.e., positions the range at the first occurrence of its minimal\n        element.)\n$(T2 mismatch,\n        $(D mismatch(\"parakeet\", \"parachute\")) returns the two ranges\n        $(D \"keet\") and $(D \"chute\").)\n$(T2 skipOver,\n        Assume $(D a = \"blah\"). Then $(D skipOver(a, \"bi\")) leaves $(D a)\n        unchanged and returns $(D false), whereas $(D skipOver(a, \"bl\"))\n        advances $(D a) to refer to $(D \"ah\") and returns $(D true).)\n$(T2 startsWith,\n        $(D startsWith(\"hello, world\", \"hello\")) returns $(D true).)\n$(T2 until,\n        Lazily iterates a range until a specific value is found.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_searching.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/setops.d",
		"name": "std.algorithm.setops",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "cartesianProduct",
						"line": 70,
						"type": "(R1 range1, R2 range2)",
						"parameters": [
							{
								"name": "range1",
								"type": "R1"
							},
							{
								"name": "range2",
								"type": "R2"
							}
						],
						"endline": 111,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cartesianProduct",
				"line": 70,
				"comment": "Lazily computes the Cartesian product of two or more ranges. The product is a\n_range of tuples of elements from each respective range.\n\nThe conditions for the two-range case are as follows:\n\nIf both ranges are finite, then one must be (at least) a forward range and the\nother an input range.\n\nIf one _range is infinite and the other finite, then the finite _range must\nbe a forward _range, and the infinite range can be an input _range.\n\nIf both ranges are infinite, then both must be forward ranges.\n\nWhen there are more than two ranges, the above conditions apply to each\nadjacent pair of ranges.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL114_2874)\n---\nimport std.algorithm.searching : canFind;\nimport std.range;\nimport std.typecons : tuple;\n\nauto N = sequence!\"n\"(0);         // the range of natural numbers\nauto N2 = cartesianProduct(N, N); // the range of all pairs of natural numbers\n\n// Various arbitrary number pairs can be found in the range in finite time.\nassert(canFind(N2, tuple(0, 0)));\nassert(canFind(N2, tuple(123, 321)));\nassert(canFind(N2, tuple(11, 35)));\nassert(canFind(N2, tuple(279, 172)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL114_2874)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL131_2875)\n---\nimport std.algorithm.searching : canFind;\nimport std.typecons : tuple;\n\nauto B = [ 1, 2, 3 ];\nauto C = [ 4, 5, 6 ];\nauto BC = cartesianProduct(B, C);\n\nforeach (n; [[1, 4], [2, 4], [3, 4], [1, 5], [2, 5], [3, 5], [1, 6],\n             [2, 6], [3, 6]])\n{\n    assert(canFind(BC, tuple(n[0], n[1])));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL131_2875)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL493_2886)\n---\nimport std.algorithm.comparison : equal;\nimport std.typecons : tuple;\n\nauto A = [ 1, 2, 3 ];\nauto B = [ 'a', 'b', 'c' ];\nauto C = [ \"x\", \"y\", \"z\" ];\nauto ABC = cartesianProduct(A, B, C);\n\nassert(ABC.equal([\n    tuple(1, 'a', \"x\"), tuple(1, 'a', \"y\"), tuple(1, 'a', \"z\"),\n    tuple(1, 'b', \"x\"), tuple(1, 'b', \"y\"), tuple(1, 'b', \"z\"),\n    tuple(1, 'c', \"x\"), tuple(1, 'c', \"y\"), tuple(1, 'c', \"z\"),\n    tuple(2, 'a', \"x\"), tuple(2, 'a', \"y\"), tuple(2, 'a', \"z\"),\n    tuple(2, 'b', \"x\"), tuple(2, 'b', \"y\"), tuple(2, 'b', \"z\"),\n    tuple(2, 'c', \"x\"), tuple(2, 'c', \"y\"), tuple(2, 'c', \"z\"),\n    tuple(3, 'a', \"x\"), tuple(3, 'a', \"y\"), tuple(3, 'a', \"z\"),\n    tuple(3, 'b', \"x\"), tuple(3, 'b', \"y\"), tuple(3, 'b', \"z\"),\n    tuple(3, 'c', \"x\"), tuple(3, 'c', \"y\"), tuple(3, 'c', \"z\")\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL493_2886)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "!allSatisfy!(isForwardRange, R1, R2) || anySatisfy!(isInfinite, R1, R2)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cartesianProduct",
						"line": 340,
						"type": "(RR ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "RR"
							}
						],
						"endline": 404,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cartesianProduct",
				"line": 340,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "RR",
						"kind": "tuple"
					}
				],
				"constraint": "ranges.length >= 2 && allSatisfy!(isForwardRange, RR) && !anySatisfy!(isInfinite, RR)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cartesianProduct",
						"line": 437,
						"type": "(R1 range1, R2 range2, RR otherRanges)",
						"parameters": [
							{
								"name": "range1",
								"type": "R1"
							},
							{
								"name": "range2",
								"type": "R2"
							},
							{
								"name": "otherRanges",
								"type": "RR"
							}
						],
						"endline": 455,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "cartesianProduct",
				"line": 437,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					},
					{
						"name": "RR",
						"kind": "tuple"
					}
				],
				"constraint": "!allSatisfy!(isForwardRange, R1, R2, RR) || anySatisfy!(isInfinite, R1, R2, RR)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "largestPartialIntersection",
						"line": 586,
						"type": "void(RangeOfRanges ror, Range tgt, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "ror",
								"type": "RangeOfRanges"
							},
							{
								"name": "tgt",
								"type": "Range"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 596,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "largestPartialIntersection",
				"line": 586,
				"comment": "Given a range of sorted forward ranges $(D ror), copies to $(D tgt)\nthe elements that are common to most ranges, along with their number\nof occurrences. All ranges in $(D ror) are assumed to be sorted by $(D\nless). Only the most frequent $(D tgt.length) elements are returned.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below.\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\nlargestPartialIntersection(a, b);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(7.0, 4u));\n----\n\n$(D 7.0) is the correct answer because it occurs in $(D 4) out of the\n$(D 5) inputs, more than any other number. The second member of the\nresulting tuple is indeed $(D 4) (recording the number of occurrences\nof $(D 7.0)). If more of the top-frequent numbers are needed, just\ncreate a larger $(D tgt) range. In the example above, creating $(D b)\nwith length $(D 2) yields $(D tuple(1.0, 3u)) in the second position.\n\nThe function $(D largestPartialIntersection) is useful for\ne.g. searching an $(LUCKY inverted index) for the documents most\nlikely to contain some terms of interest. The complexity of the search\nis $(BIGOH n * log(tgt.length)), where $(D n) is the sum of lengths of\nall input ranges. This approach is faster than keeping an associative\narray of the occurrences and then selecting its top items, and also\nrequires less memory ($(D largestPartialIntersection) builds its\nresult directly in $(D tgt) and requires no extra memory).\n\nWarning: Because $(D largestPartialIntersection) does not allocate\nextra memory, it will leave $(D ror) modified. Namely, $(D\nlargestPartialIntersection) assumes ownership of $(D ror) and\ndiscretionarily swaps and advances elements of it. If you want $(D\nror) to preserve its contents after the call, you may want to pass a\nduplicate to $(D largestPartialIntersection) (and perhaps cache the\nduplicate in between calls).\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "largestPartialIntersectionWeighted",
						"line": 629,
						"type": "void(RangeOfRanges ror, Range tgt, WeightsAA weights, SortOutput sorted = SortOutput.no)",
						"parameters": [
							{
								"name": "ror",
								"type": "RangeOfRanges"
							},
							{
								"name": "tgt",
								"type": "Range"
							},
							{
								"name": "weights",
								"type": "WeightsAA"
							},
							{
								"name": "sorted",
								"type": "SortOutput",
								"default": "SortOutput.no"
							}
						],
						"endline": 643,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "largestPartialIntersectionWeighted",
				"line": 629,
				"comment": "Similar to $(D largestPartialIntersection), but associates a weight\nwith each distinct element in the intersection.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below, with specific per-element weights\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\ndouble[double] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];\nlargestPartialIntersectionWeighted(a, b, weights);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(4.0, 2u));\n----\n\nThe correct answer in this case is $(D 4.0), which, although only\nappears two times, has a total weight $(D 4.6) (three times its weight\n$(D 2.3)). The value $(D 7) is weighted with $(D 1.1) and occurs four\ntimes for a total weight $(D 4.4).\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "WeightsAA",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "NWayUnion",
						"line": 748,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "NWayUnion",
				"line": 748,
				"comment": "Computes the union of multiple sets. The input sets are passed as a\nrange of ranges and each is assumed to be sorted by $(D\nless). Computation is done lazily, one union element at a time. The\ncomplexity of one $(D popFront) operation is $(BIGOH\nlog(ror.length)). However, the length of $(D ror) decreases as ranges\nin it are exhausted, so the complexity of a full pass through $(D\nNWayUnion) is dependent on the distribution of the lengths of ranges\ncontained within $(D ror). If all ranges have the same length $(D n)\n(worst case scenario), the complexity of a full pass through $(D\nNWayUnion) is $(BIGOH n * ror.length * log(ror.length)), i.e., $(D\nlog(ror.length)) times worse than just spanning all ranges in\nturn. The output comes sorted (unstably) by $(D less).\n\nWarning: Because $(D NWayUnion) does not allocate extra memory, it\nwill leave $(D ror) modified. Namely, $(D NWayUnion) assumes ownership\nof $(D ror) and discretionarily swaps and advances elements of it. If\nyou want $(D ror) to preserve its contents after the call, you may\nwant to pass a duplicate to $(D NWayUnion) (and perhaps cache the\nduplicate in between calls).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL807_2894)\n---\nimport std.algorithm.comparison : equal;\n\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto witness = [\n    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8\n];\nassert(equal(nWayUnion(a), witness));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL807_2894)\n",
				"parameters": [
					{
						"name": "less",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nWayUnion",
						"line": 799,
						"type": "NWayUnion!(less, RangeOfRanges)(RangeOfRanges ror)",
						"parameters": [
							{
								"name": "ror",
								"type": "RangeOfRanges"
							}
						],
						"endline": 804,
						"char": 33,
						"kind": "function"
					}
				],
				"name": "nWayUnion",
				"line": 799,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 33,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetDifference",
						"line": 830,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetDifference",
				"line": 830,
				"comment": "Lazily computes the difference of $(D r1) and $(D r2). The two ranges\nare assumed to be sorted by $(D less). The element types of the two\nranges must have a common type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL899_2895)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setDifference(a, b), [5, 9][]));\nstatic assert(isForwardRange!(typeof(setDifference(a, b))));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL899_2895)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setDifference",
						"line": 892,
						"type": "SetDifference!(less, R1, R2)(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 896,
						"char": 30,
						"kind": "function"
					}
				],
				"name": "setDifference",
				"line": 892,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"char": 30,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetIntersection",
						"line": 925,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetIntersection",
				"line": 925,
				"comment": "Lazily computes the intersection of two or more input ranges $(D\nranges). The ranges are assumed to be sorted by $(D less). The element\ntypes of the ranges must have a common type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1021_2897)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nint[] c = [ 0, 1, 4, 5, 7, 8 ];\nassert(equal(setIntersection(a, a), a));\nassert(equal(setIntersection(a, b), [1, 2, 4, 7]));\nassert(equal(setIntersection(a, b, c), [1, 4, 7]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1021_2897)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "Rs.length >= 2 && allSatisfy!(isInputRange, Rs) && !is(CommonType!(staticMap!(ElementType, Rs)) == void)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setIntersection",
						"line": 1013,
						"type": "SetIntersection!(less, Rs)(Rs ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Rs"
							}
						],
						"endline": 1018,
						"char": 28,
						"kind": "function"
					}
				],
				"name": "setIntersection",
				"line": 1013,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "Rs.length >= 2 && allSatisfy!(isInputRange, Rs) && !is(CommonType!(staticMap!(ElementType, Rs)) == void)",
				"char": 28,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetSymmetricDifference",
						"line": 1074,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetSymmetricDifference",
				"line": 1074,
				"comment": "Lazily computes the symmetric difference of $(D r1) and $(D r2),\ni.e. the elements that are present in exactly one of $(D r1) and $(D\nr2). The two ranges are assumed to be sorted by $(D less), and the\noutput is also sorted by $(D less). The element types of the two\nranges must have a common type.\n\nIf both arguments are ranges of L-values of the same type then\n$(D SetSymmetricDifference) will also be a range of L-values of\nthat type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1160_2903)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setSymmetricDifference(a, b), [0, 5, 8, 9][]));\nstatic assert(isForwardRange!(typeof(setSymmetricDifference(a, b))));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1160_2903)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setSymmetricDifference",
						"line": 1153,
						"type": "SetSymmetricDifference!(less, R1, R2)(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 1157,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "setSymmetricDifference",
				"line": 1153,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetUnion",
						"line": 1192,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SetUnion",
				"line": 1192,
				"comment": "Lazily computes the union of two or more ranges $(D rs). The ranges\nare assumed to be sorted by $(D less). Elements in the output are not\nunique; the length of the output is the sum of the lengths of the\ninputs. (The $(D length) member is offered if all ranges also have\nlength.) The element types of all ranges must have a common type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1310_2905)\n---\nimport std.algorithm.comparison : equal;\n\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\ndouble[] c = [ 10.5 ];\n\nstatic assert(isForwardRange!(typeof(setUnion(a, b))));\nassert(setUnion(a, b).length == a.length + b.length);\nassert(equal(setUnion(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));\nassert(equal(setUnion(a, c, b),\n                [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9, 10.5][]));\nauto u = setUnion(a, b);\nu.front--;\nassert(equal(u, [-1, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1310_2905)\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isInputRange, Rs)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "setUnion",
						"line": 1303,
						"type": "SetUnion!(less, Rs)(Rs rs)",
						"parameters": [
							{
								"name": "rs",
								"type": "Rs"
							}
						],
						"endline": 1307,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "setUnion",
				"line": 1303,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "less",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"char": 21,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic algorithms that implement set operations.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 cartesianProduct,\n        Computes Cartesian product of two ranges.)\n$(T2 largestPartialIntersection,\n        Copies out the values that occur most frequently in a range of ranges.)\n$(T2 largestPartialIntersectionWeighted,\n        Copies out the values that occur most frequently (multiplied by\n        per-value weights) in a range of ranges.)\n$(T2 nWayUnion,\n        Computes the union of a set of sets implemented as a range of sorted\n        ranges.)\n$(T2 setDifference,\n        Lazily computes the set difference of two or more sorted ranges.)\n$(T2 setIntersection,\n        Lazily computes the intersection of two or more sorted ranges.)\n$(T2 setSymmetricDifference,\n        Lazily computes the symmetric set difference of two or more sorted\n        ranges.)\n$(T2 setUnion,\n        Lazily computes the set union of two or more sorted ranges.)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_setops.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/algorithm/comparison.d",
		"name": "std.algorithm.comparison",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "among",
						"line": 79,
						"type": "uint(Value value, Values values)",
						"parameters": [
							{
								"name": "value",
								"type": "Value"
							},
							{
								"name": "values",
								"type": "Values"
							}
						],
						"endline": 89,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "among",
				"line": 79,
				"comment": "Find $(D value) _among $(D values), returning the 1-based index\nof the first matching value in $(D values), or $(D 0) if $(D value)\nis not _among $(D values). The predicate $(D pred) is used to\ncompare values, and uses equality by default.\n\nParams:\n    pred = The predicate used to compare the values.\n    value = The value to search for.\n    values = The values to compare the value to.\n\nReturns:\n    0 if value was not found among the values, otherwise the index of the\n    found value plus one is returned.\n\nSee_Also:\n$(LREF find) and $(LREF canFind) for finding a value in a\nrange.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL110_2910)\n---\nassert(3.among(1, 42, 24, 3, 2));\n\nif (auto pos = \"bar\".among(\"foo\", \"bar\", \"baz\"))\n    assert(pos == 2);\nelse\n    assert(false);\n\n// 42 is larger than 24\nassert(42.among!((lhs, rhs) => lhs > rhs)(43, 24, 100) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL110_2910)\nExample:\nAlternatively, $(D values) can be passed at compile-time, allowing for a more\nefficient search, but one that only supports matching on equality:$(DDOX_UNITTEST_HEADER __unittestL127_2911)\n---\nassert(3.among!(2, 3, 4));\nassert(\"bar\".among!(\"foo\", \"bar\", \"baz\") == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL127_2911)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "",
						"kind": "alias"
					},
					{
						"name": "Value",
						"kind": "type"
					},
					{
						"name": "Values",
						"kind": "tuple"
					}
				],
				"constraint": "Values.length != 0",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "among",
								"line": 95,
								"type": "uint(Value value)",
								"parameters": [
									{
										"name": "value",
										"type": "Value"
									}
								],
								"endline": 106,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "among",
						"line": 95,
						"parameters": [
							{
								"name": "Value",
								"kind": "type"
							}
						],
						"constraint": "!is(CommonType!(Value, values) == void)",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "among",
				"line": 92,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "values",
						"kind": "tuple"
					}
				],
				"constraint": "isExpressionTuple!values",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "castSwitch",
						"line": 231,
						"type": "(Object switchObject)",
						"parameters": [
							{
								"name": "switchObject",
								"type": "Object"
							}
						],
						"endline": 365,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "castSwitch",
				"line": 231,
				"comment": "Executes and returns one of a collection of handlers based on the type of the\nswitch object.\n\nThe first choice that $(D switchObject) can be casted to the type\nof argument it accepts will be called with $(D switchObject) casted to that\ntype, and the value it'll return will be returned by $(D castSwitch).\n\nIf a choice's return type is void, the choice must throw an exception, unless\nall the choices are void. In that case, castSwitch itself will return void.\n\nThrows: If none of the choice matches, a $(D SwitchError) will be thrown.  $(D\nSwitchError) will also be thrown if not all the choices are void and a void\nchoice was executed without throwing anything.\n\nParams:\n    choices = The $(D choices) needs to be composed of function or delegate\n        handlers that accept one argument. There can also be a choice that\n        accepts zero arguments. That choice will be invoked if the $(D\n        switchObject) is null.\n    switchObject = the object against which the tests are being made.\n\nReturns:\n    The value of the selected choice.\n\nNote: $(D castSwitch) can only be used with object types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL368_2913)\n---\nimport std.algorithm.iteration : map;\nimport std.format : format;\n\nclass A\n{\n    int a;\n    this(int a) {this.a = a;}\n    @property int i() { return a; }\n}\ninterface I { }\nclass B : I { }\n\nObject[] arr = [new A(1), new B(), null];\n\nauto results = arr.map!(castSwitch!(\n                            (A a) => \"A with a value of %d\".format(a.a),\n                            (I i) => \"derived from I\",\n                            ()    => \"null reference\",\n                        ))();\n\n// A is handled directly:\nassert(results[0] == \"A with a value of 1\");\n// B has no handler - it is handled by the handler of I:\nassert(results[1] == \"derived from I\");\n// null is handled by the null handler:\nassert(results[2] == \"null reference\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL368_2913)\nExample:\nUsing with void handlers:$(DDOX_UNITTEST_HEADER __unittestL399_2914)\n---\nimport std.exception : assertThrown;\n\nclass A { }\nclass B { }\n// Void handlers are allowed if they throw:\nassertThrown!Exception(\n    new B().castSwitch!(\n        (A a) => 1,\n        (B d)    { throw new Exception(\"B is not allowed!\"); }\n    )()\n);\n\n// Void handlers are also allowed if all the handlers are void:\nnew A().castSwitch!(\n    (A a) { assert(true); },\n    (B b) { assert(false); },\n)();\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL399_2914)\n",
				"parameters": [
					{
						"name": "choices",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "clamp",
						"line": 507,
						"type": "(T1 val, T2 lower, T3 upper)",
						"parameters": [
							{
								"name": "val",
								"type": "T1"
							},
							{
								"name": "lower",
								"type": "T2"
							},
							{
								"name": "upper",
								"type": "T3"
							}
						],
						"endline": 516,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "clamp",
				"line": 507,
				"comment": " Clamps a value into the given bounds.\n\nThis functions is equivalent to $(D max(lower, min(upper,val))).\n\nParams:\n    val = The value to _clamp.\n    lower = The _lower bound of the _clamp.\n    upper = The _upper bound of the _clamp.\n\nReturns:\n    Returns $(D val), if it is between $(D lower) and $(D upper).\n    Otherwise returns the nearest of the two.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL519_2916)\n---\nassert(clamp(2, 1, 3) == 2);\nassert(clamp(0, 1, 3) == 1);\nassert(clamp(4, 1, 3) == 3);\n\nassert(clamp(1, 1, 1) == 1);\n\nassert(clamp(5, -1, 2u) == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL519_2916)\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					},
					{
						"name": "T3",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cmp",
						"line": 584,
						"type": "int(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 595,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "cmp",
				"line": 584,
				"comment": "Performs three-way lexicographical comparison on two input ranges\naccording to predicate $(D pred). Iterating $(D r1) and $(D r2) in\nlockstep, $(D cmp) compares each element $(D e1) of $(D r1) with the\ncorresponding element $(D e2) in $(D r2). If one of the ranges has been\nfinished, $(D cmp) returns a negative value if $(D r1) has fewer\nelements than $(D r2), a positive value if $(D r1) has more elements\nthan $(D r2), and $(D 0) if the ranges have the same number of\nelements.\n\nIf the ranges are strings, $(D cmp) performs UTF decoding\nappropriately and compares the ranges one code point at a time.\n\nParams:\n    pred = The predicate used for comparison.\n    r1 = The first range.\n    r2 = The second range.\n\nReturns:\n    0 if both ranges compare equal. -1 if the first differing element of $(D\n    r1) is less than the corresponding element of $(D r2) according to $(D\n    pred). 1 if the first differing element of $(D r2) is less than the\n    corresponding element of $(D r1) according to $(D pred).\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL668_2918)\n---\nint result;\n\nresult = cmp(\"abc\", \"abc\");\nassert(result == 0);\nresult = cmp(\"\", \"\");\nassert(result == 0);\nresult = cmp(\"abc\", \"abcd\");\nassert(result < 0);\nresult = cmp(\"abcd\", \"abc\");\nassert(result > 0);\nresult = cmp(\"abc\"d, \"abd\");\nassert(result < 0);\nresult = cmp(\"bbc\", \"abc\"w);\nassert(result > 0);\nresult = cmp(\"aaa\", \"aaaa\"d);\nassert(result < 0);\nresult = cmp(\"aaaa\", \"aaa\"d);\nassert(result > 0);\nresult = cmp(\"aaa\", \"aaa\"d);\nassert(result == 0);\nresult = cmp(cast(int[])[], cast(int[])[]);\nassert(result == 0);\nresult = cmp([1, 2, 3], [1, 2, 3]);\nassert(result == 0);\nresult = cmp([1, 3, 2], [1, 2, 3]);\nassert(result > 0);\nresult = cmp([1, 2, 3], [1L, 2, 3, 4]);\nassert(result < 0);\nresult = cmp([1L, 2, 3], [1, 2]);\nassert(result > 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL668_2918)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isInputRange!R2 && !(isSomeString!R1 && isSomeString!R2)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cmp",
						"line": 598,
						"type": "int(R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 665,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "cmp",
				"line": 598,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!R1 && isSomeString!R2",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "equal",
								"line": 726,
								"type": "bool(Range1 r1, Range2 r2)",
								"parameters": [
									{
										"name": "r1",
										"type": "Range1"
									},
									{
										"name": "r2",
										"type": "Range2"
									}
								],
								"endline": 760,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "equal",
						"line": 726,
						"comment": "    This function compares to ranges for equality. The ranges may have\n    different element types, as long as $(D pred(a, b)) evaluates to $(D bool)\n    for $(D a) in $(D r1) and $(D b) in $(D r2).\n    Performs $(BIGOH min(r1.length, r2.length)) evaluations of $(D pred).\n\n    Params:\n        r1 = The first range to be compared.\n        r2 = The second range to be compared.\n\n    Returns:\n        $(D true) if and only if the two ranges compare equal element\n        for element, according to binary predicate $(D pred).\n\n    See_Also:\n        $(WEB sgi.com/tech/stl/_equal.html, STL's _equal)\n",
						"parameters": [
							{
								"name": "Range1",
								"kind": "type"
							},
							{
								"name": "Range2",
								"kind": "type"
							}
						],
						"constraint": "isInputRange!Range1 && isInputRange!Range2 && is(typeof(binaryFun!pred(r1.front, r2.front)))",
						"char": 10,
						"kind": "template"
					}
				],
				"name": "equal",
				"line": 707,
				"comment": "Compares two ranges for equality, as defined by predicate $(D pred)\n(which is $(D ==) by default).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL764_2919)\n---\nimport std.math : approxEqual;\nimport std.algorithm : equal;\n\nint[] a = [ 1, 2, 4, 3 ];\nassert(!equal(a, a[1..$]));\nassert(equal(a, a));\n\n// different types\ndouble[] b = [ 1.0, 2, 4, 3];\nassert(!equal(a, b[1..$]));\nassert(equal(a, b));\n\n// predicated: ensure that two vectors are approximately equal\ndouble[] c = [ 1.005, 2, 4, 3];\nassert(equal!approxEqual(b, c));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL764_2919)\nExample:\nTip: $(D equal) can itself be used as a predicate to other functions.\nThis can be very useful when the element type of a range is itself a\nrange. In particular, $(D equal) can be its own predicate, allowing\nrange of range (of range...) comparisons.$(DDOX_UNITTEST_HEADER __unittestL789_2920)\n---\nimport std.range : iota, chunks;\nimport std.algorithm : equal;\nassert(equal!(equal!equal)(\n    [[[0, 1], [2, 3]], [[4, 5], [6, 7]]],\n    iota(0, 8).chunks(2).chunks(2)\n));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL789_2920)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 904,
						"value": "'n'",
						"comment": " Current items are equal; no editing is necessary.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "substitute",
						"line": 906,
						"value": "'s'",
						"comment": " Substitute current item in target with current item in source.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "insert",
						"line": 908,
						"value": "'i'",
						"comment": " Insert current item from the source into the target.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remove",
						"line": 910,
						"value": "'r'",
						"comment": " Remove current item from the target.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "EditOp",
				"line": 901,
				"comment": "Encodes $(WEB realityinteractive.com/rgrzywinski/archives/000249.html,\nedit operations) necessary to transform one sequence into\nanother. Given sequences $(D s) (source) and $(D t) (target), a\nsequence of $(D EditOp) encodes the steps that need to be taken to\nconvert $(D s) into $(D t). For example, if $(D s = \"cat\") and $(D\n\"cars\"), the minimal sequence that transforms $(D s) into $(D t) is:\nskip two characters, replace 't' with 'r', and insert an 's'. Working\nwith edit operations is useful in applications such as spell-checkers\n(to find the closest word to a given misspelled word), approximate\nsearches, diff-style programs that compute the difference between\nfiles, efficient encoding of patches, DNA sequence analysis, and\nplagiarism detection.\n",
				"baseDeco": "a",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "levenshteinDistance",
						"line": 1095,
						"type": "size_t(Range1 s, Range2 t)",
						"parameters": [
							{
								"name": "s",
								"type": "Range1"
							},
							{
								"name": "t",
								"type": "Range2"
							}
						],
						"endline": 1141,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "levenshteinDistance",
				"line": 1095,
				"comment": "Returns the $(WEB wikipedia.org/wiki/Levenshtein_distance, Levenshtein\ndistance) between $(D s) and $(D t). The Levenshtein distance computes\nthe minimal amount of edit operations necessary to transform $(D s)\ninto $(D t).  Performs $(BIGOH s.length * t.length) evaluations of $(D\nequals) and occupies $(BIGOH s.length * t.length) storage.\n\nParams:\n    equals = The binary predicate to compare the elements of the two ranges.\n    s = The original range.\n    t = The transformation target\n\nReturns:\n    The minimal number of edits to transform s into t.\n\nDoes not allocate GC memory.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1144_2926)\n---\nimport std.algorithm.iteration : filter;\nimport std.uni : toUpper;\n\nassert(levenshteinDistance(\"cat\", \"rat\") == 1);\nassert(levenshteinDistance(\"parks\", \"spark\") == 2);\nassert(levenshteinDistance(\"abcde\", \"abcde\") == 0);\nassert(levenshteinDistance(\"abcde\", \"abCde\") == 1);\nassert(levenshteinDistance(\"kitten\", \"sitting\") == 3);\nassert(levenshteinDistance!((a, b) => std.uni.toUpper(a) == std.uni.toUpper(b))\n    (\"parks\", \"SPARK\") == 2);\nassert(levenshteinDistance(\"parks\".filter!\"true\", \"spark\".filter!\"true\") == 2);\nassert(levenshteinDistance(\"ID\", \"Iâ¥D\") == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1144_2926)\n",
				"parameters": [
					{
						"name": "equals",
						"defaultAlias": "",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range1 && isForwardRange!Range2",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "levenshteinDistanceAndPath",
						"line": 1181,
						"type": "Tuple!(size_t, EditOp[])(Range1 s, Range2 t)",
						"parameters": [
							{
								"name": "s",
								"type": "Range1"
							},
							{
								"name": "t",
								"type": "Range2"
							}
						],
						"endline": 1188,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "levenshteinDistanceAndPath",
				"line": 1181,
				"comment": "Returns the Levenshtein distance and the edit path between $(D s) and\n$(D t).\n\nParams:\n    equals = The binary predicate to compare the elements of the two ranges.\n    s = The original range.\n    t = The transformation target\n\nReturns:\n    Tuple with the first element being the minimal amount of edits to transform s into t and\n    the second element being the sequence of edits to effect this transformation.\n\nAllocates GC memory for the returned EditOp[] array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1191_2928)\n---\nstring a = \"Saturday\", b = \"Sundays\";\nauto p = levenshteinDistanceAndPath(a, b);\nassert(p[0] == 4);\nassert(equal(p[1], \"nrrnsnnni\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1191_2928)\n",
				"parameters": [
					{
						"name": "equals",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range1 && isForwardRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "max",
						"line": 1223,
						"type": "MaxType!T(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 1248,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "max",
				"line": 1223,
				"comment": "Iterates the passed arguments and return the maximum value.\n\nParams:\n    args = The values to select the maximum from. At least two arguments must\n    be passed.\n\nReturns:\n    The maximum of the passed-in args. The type of the returned value is\n    the type among the passed arguments that is able to store the largest value.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1251_2930)\n---\nint a = 5;\nshort b = 6;\ndouble c = 2;\nauto d = max(a, b);\nassert(is(typeof(d) == int));\nassert(d == 6);\nauto e = min(a, b, c);\nassert(is(typeof(e) == double));\nassert(e == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1251_2930)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length >= 2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "min",
						"line": 1331,
						"type": "MinType!T(T args)",
						"parameters": [
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 1356,
						"char": 11,
						"kind": "function"
					}
				],
				"name": "min",
				"line": 1331,
				"comment": "Returns the minimum of the passed-in values.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length >= 2",
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "mismatch",
						"line": 1401,
						"type": "Tuple!(Range1, Range2)(Range1 r1, Range2 r2)",
						"parameters": [
							{
								"name": "r1",
								"type": "Range1"
							},
							{
								"name": "r2",
								"type": "Range2"
							}
						],
						"endline": 1409,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "mismatch",
				"line": 1401,
				"comment": "Sequentially compares elements in $(D r1) and $(D r2) in lockstep, and\nstops at the first mismatch (according to $(D pred), by default\nequality). Returns a tuple with the reduced ranges that start with the\ntwo mismatched values. Performs $(BIGOH min(r1.length, r2.length))\nevaluations of $(D pred).\n\nSee_Also:\n    $(WEB sgi.com/tech/stl/_mismatch.html, STL's _mismatch)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1412_2933)\n---\nint[]    x = [ 1,  5, 2, 7,   4, 3 ];\ndouble[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];\nauto m = mismatch(x, y);\nassert(m[0] == x[3 .. $]);\nassert(m[1] == y[3 .. $]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1412_2933)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "Range1",
						"kind": "type"
					},
					{
						"name": "Range2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range1 && isInputRange!Range2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "predSwitch",
						"line": 1465,
						"type": "(T switchExpression, lazy R choices)",
						"parameters": [
							{
								"name": "switchExpression",
								"type": "T"
							},
							{
								"name": "choices",
								"type": "R",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 1507,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "predSwitch",
				"line": 1465,
				"comment": "Returns one of a collection of expressions based on the value of the switch\nexpression.\n\n$(D choices) needs to be composed of pairs of test expressions and return\nexpressions. Each test-expression is compared with $(D switchExpression) using\n$(D pred)($(D switchExpression) is the first argument) and if that yields true\n- the return expression is returned.\n\nBoth the test and the return expressions are lazily evaluated.\n\nParams:\n\nswitchExpression = The first argument for the predicate.\n\nchoices = Pairs of test expressions and return expressions. The test\nexpressions will be the second argument for the predicate, and the return\nexpression will be returned if the predicate yields true with $(D\nswitchExpression) and the test expression as arguments.  May also have a\ndefault return expression, that needs to be the last expression without a test\nexpression before it. A return expression may be of void type only if it\nalways throws.\n\nReturns: The return expression associated with the first test expression that\nmade the predicate yield true, or the default return expression if no test\nexpression matched.\n\nThrows: If there is no default return expression and the predicate does not\nyield true with any test expression - $(D SwitchError) is thrown. $(D\nSwitchError) is also thrown if a void return expression was executed without\nthrowing anything.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1510_2935)\n---\nstring res = 2.predSwitch!\"a < b\"(\n    1, \"less than 1\",\n    5, \"less than 5\",\n    10, \"less than 10\",\n    \"greater or equal to 10\");\n\nassert(res == \"less than 5\");\n\n//The arguments are lazy, which allows us to use predSwitch to create\n//recursive functions:\nint factorial(int n)\n{\n    return n.predSwitch!\"a <= b\"(\n        -1, {throw new Exception(\"Can not calculate n! for n < 0\");}(),\n        0, 1, // 0! = 1\n        n * factorial(n - 1) // n! = n * (n - 1)! for n >= 0\n        );\n}\nassert(factorial(3) == 6);\n\n//Void return expressions are allowed if they always throw:\nimport std.exception : assertThrown;\nassertThrown!Exception(factorial(-9));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1510_2935)\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a == b\"",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This is a submodule of $(LINK2 std_algorithm.html, std.algorithm).\nIt contains generic _comparison algorithms.\n\n$(BOOKTABLE Cheat Sheet,\n\n$(TR $(TH Function Name) $(TH Description))\n\n$(T2 among,\n        Checks if a value is among a set of values, e.g.\n        $(D if (v.among(1, 2, 3)) // `v` is 1, 2 or 3))\n$(T2 castSwitch,\n        $(D (new A()).castSwitch((A a)=>1,(B b)=>2)) returns $(D 1).)\n$(T2 clamp,\n        $(D clamp(1, 3, 6)) returns $(D 3). $(D clamp(4, 3, 6)) returns $(D 4).)\n$(T2 cmp,\n        $(D cmp(\"abc\", \"abcd\")) is $(D -1), $(D cmp(\"abc\", \"aba\")) is $(D 1),\n        and $(D cmp(\"abc\", \"abc\")) is $(D 0).)\n$(T2 equal,\n        Compares ranges for element-by-element equality, e.g.\n        $(D equal([1, 2, 3], [1.0, 2.0, 3.0])) returns $(D true).)\n$(T2 levenshteinDistance,\n        $(D levenshteinDistance(\"kitten\", \"sitting\")) returns $(D 3) by using\n        the $(LUCKY Levenshtein distance _algorithm).)\n$(T2 levenshteinDistanceAndPath,\n        $(D levenshteinDistanceAndPath(\"kitten\", \"sitting\")) returns\n        $(D tuple(3, \"snnnsni\")) by using the $(LUCKY Levenshtein distance\n        _algorithm).)\n$(T2 max,\n        $(D max(3, 4, 2)) returns $(D 4).)\n$(T2 min,\n        $(D min(3, 4, 2)) returns $(D 2).)\n$(T2 mismatch,\n        $(D mismatch(\"oh hi\", \"ohayo\")) returns $(D tuple(\" hi\", \"ayo\")).)\n$(T2 predSwitch,\n        $(D 2.predSwitch(1, \"one\", 2, \"two\", 3, \"three\")) returns $(D \"two\").)\n)\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/algorithm/_comparison.d)\n\nMacros:\nT2=$(TR $(TDNW $(LREF $1)) $(TD $+))\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/concurrency.d",
		"name": "std.concurrency",
		"members": [
			{
				"members": [],
				"name": "MessageMismatch",
				"line": 220,
				"comment": "\n\n\n\n Thrown on calls to $(D receiveOnly) if a message other than the type\n the receiving thread expected is sent.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "OwnerTerminated",
				"line": 233,
				"comment": " Thrown on calls to $(D receive) if the thread that spawned the receiving\n thread has terminated and no more messages exist.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "LinkTerminated",
				"line": 248,
				"comment": " Thrown if a linked thread has terminated.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"offset": 72,
						"name": "message",
						"line": 276,
						"comment": " The message that was sent.\n",
						"deco": "S3std7variant18__T8VariantNVmi32Z8VariantN",
						"originalType": "Variant",
						"char": 13,
						"kind": "variable"
					}
				],
				"name": "PriorityMessageException",
				"line": 265,
				"comment": " Thrown if a message was sent to a thread via\n $(XREF concurrency, prioritySend) and the receiver does not have a handler\n for a message of this type.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "MailboxFull",
				"line": 284,
				"comment": " Thrown on mailbox crowding if the mailbox is configured with\n $(D OnCrowding.throwException).\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [],
				"name": "TidMissingException",
				"line": 300,
				"comment": " Thrown when a Tid is missing, e.g. when $(D ownerTid) doesn't\n find an owner thread.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "Tid",
				"line": 317,
				"comment": "\n\n\n\n An opaque type used to represent a logical thread.\n",
				"members": [
					{
						"endchar": 5,
						"name": "toString",
						"line": 337,
						"comment": " Generate a convenient string for identifying this Tid.  This is only\n useful to see if Tid's that are currently executing are the same or\n different, e.g. for logging and debugging.  It is potentially possible\n that a Tid executed in the future will have the same toString() output\n as another Tid that has already terminated.\n",
						"deco": "FMDFAxaZvZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							}
						],
						"endline": 341,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "thisTid",
				"line": 349,
				"comment": " Returns the caller's Tid.\n",
				"deco": "FNdNfZS3std11concurrency3Tid",
				"endline": 361,
				"char": 15,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "ownerTid",
				"line": 369,
				"comment": " Return the Tid of the thread which spawned the caller's thread.\n\n Throws: A $(D TidMissingException) exception if\n there is no owner thread.\n",
				"deco": "FNdZS3std11concurrency3Tid",
				"endline": 374,
				"char": 15,
				"kind": "function"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "spawn",
						"line": 466,
						"type": "Tid(F fn, T args)",
						"parameters": [
							{
								"name": "fn",
								"type": "F"
							},
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 472,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "spawn",
				"line": 466,
				"comment": " Starts fn(args) in a new logical thread.\n\n Executes the supplied function in a new logical thread represented by\n $(D Tid).  The calling thread is designated as the owner of the new thread.\n When the owner thread terminates an $(D OwnerTerminated) message will be\n sent to the new thread, causing an $(D OwnerTerminated) exception to be\n thrown on $(D receive()).\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new logical thread.\n\n Notes:\n  $(D args) must not have unshared aliasing.  In other words, all arguments\n  to $(D fn) must either be $(D shared) or $(D immutable) or have no\n  pointer indirection.  This is necessary for enforcing isolation among\n  threads.\n\n Example:\n ---\n import std.stdio, std.concurrency;\n\n void f1(string str)\n {\n     writeln(str);\n }\n\n void f2(char[] str)\n {\n     writeln(str);\n }\n\n void main()\n {\n     auto str = \"Hello, world\";\n\n     // Works:  string is immutable.\n     auto tid1 = spawn(&f1, str);\n\n     // Fails:  char[] has mutable aliasing.\n     auto tid2 = spawn(&f2, str.dup);\n }\n ---\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "isSpawnable!(F, T)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "spawnLinked",
						"line": 494,
						"type": "Tid(F fn, T args)",
						"parameters": [
							{
								"name": "fn",
								"type": "F"
							},
							{
								"name": "args",
								"type": "T"
							}
						],
						"endline": 500,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "spawnLinked",
				"line": 494,
				"comment": " Starts fn(args) in a logical thread and will receive a LinkTerminated\n message when the operation terminates.\n\n Executes the supplied function in a new logical thread represented by\n Tid.  This new thread is linked to the calling thread so that if either\n it or the calling thread terminates a LinkTerminated message will be sent\n to the other, causing a LinkTerminated exception to be thrown on receive().\n The owner relationship from spawn() is preserved as well, so if the link\n between threads is broken, owner termination will still result in an\n OwnerTerminated exception to be thrown on receive().\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new thread.\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "isSpawnable!(F, T)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "send",
						"line": 590,
						"type": "void(Tid tid, T vals)",
						"parameters": [
							{
								"name": "tid",
								"type": "Tid"
							},
							{
								"name": "vals",
								"type": "T"
							}
						],
						"endline": 595,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "send",
				"line": 590,
				"comment": "\n\n\n\n Places the values as a message at the back of tid's message queue.\n\n Sends the supplied value to the thread represented by tid.  As with\n $(XREF concurrency, spawn), $(D T) must not have unshared aliasing.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "prioritySend",
						"line": 605,
						"type": "void(Tid tid, T vals)",
						"parameters": [
							{
								"name": "tid",
								"type": "Tid"
							},
							{
								"name": "vals",
								"type": "T"
							}
						],
						"endline": 610,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "prioritySend",
				"line": 605,
				"comment": " Places the values as a message on the front of tid's message queue.\n\n Send a message to $(D tid) but place it at the front of $(D tid)'s message\n queue instead of at the back.  This function is typically used for\n out-of-band communication, to signal exceptional conditions, etc.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "receive",
						"line": 668,
						"type": "void(T ops)",
						"parameters": [
							{
								"name": "ops",
								"type": "T"
							}
						],
						"endline": 680,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "receive",
				"line": 668,
				"comment": " Receives a message from another thread.\n\n Receive a message from another thread, or block if no messages of the\n specified types are available.  This function works by pattern matching\n a message against a set of delegates and executing the first match found.\n\n If a delegate that accepts a $(XREF variant, Variant) is included as\n the last argument to $(D receive), it will match any message that was not\n matched by an earlier delegate.  If more than one argument is sent,\n the $(D Variant) will contain a $(XREF typecons, Tuple) of all values\n sent.\n\n Example:\n ---\n import std.stdio;\n import std.variant;\n import std.concurrency;\n\n void spawnedFunction()\n {\n     receive(\n         (int i) { writeln(\"Received an int.\"); },\n         (float f) { writeln(\"Received a float.\"); },\n         (Variant v) { writeln(\"Received some other type.\"); }\n     );\n }\n\n void main()\n {\n      auto tid = spawn(&spawnedFunction);\n      send(tid, 42);\n }\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "receiveOnly",
						"line": 752,
						"type": "receiveOnlyRet!T()",
						"endline": 792,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "receiveOnly",
				"line": 752,
				"comment": " Receives only messages with arguments of types $(D T).\n\n Throws:  $(D MessageMismatch) if a message of types other than $(D T)\n          is received.\n\n Returns: The received message.  If $(D T.length) is greater than one,\n          the message will be packed into a $(XREF typecons, Tuple).\n\n Example:\n ---\n import std.concurrency;\n\n void spawnedFunc()\n {\n     auto msg = receiveOnly!(int, string)();\n     assert(msg[0] == 42);\n     assert(msg[1] == \"42\");\n }\n\n void main()\n {\n     auto tid = spawn(&spawnedFunc);\n     send(tid, 42, \"42\");\n }\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "receiveTimeout",
						"line": 823,
						"type": "bool(Duration duration, T ops)",
						"parameters": [
							{
								"name": "duration",
								"type": "Duration"
							},
							{
								"name": "ops",
								"type": "T"
							}
						],
						"endline": 835,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "receiveTimeout",
				"line": 823,
				"comment": " Tries to receive but will give up if no matches arrive within duration.\n\n Same as $(D receive) except that rather than wait forever for a message,\n it waits until either it receives a message or the given\n $(CXREF time, Duration) has passed. It returns $(D true) if it received a\n message and $(D false) if it timed out waiting for one.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "block",
						"line": 872,
						"value": "0",
						"comment": "Wait until room is available.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "throwException",
						"line": 873,
						"value": "1",
						"comment": "Throw a MailboxFull exception.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ignore",
						"line": 874,
						"value": "2",
						"comment": "Abort the send and return.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "OnCrowding",
				"line": 870,
				"comment": "\n\n\n\n These behaviors may be specified when a mailbox is full.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"endchar": 1,
				"name": "setMaxMailboxSize",
				"line": 913,
				"comment": " Sets a maximum mailbox size.\n\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute the behavior specified by doThis.  If messages is zero, the mailbox\n is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  doThis   = The behavior executed when a message is sent to a full\n             mailbox.\n",
				"deco": "FS3std11concurrency3TidmE3std11concurrency10OnCrowdingZv",
				"parameters": [
					{
						"name": "tid",
						"deco": "S3std11concurrency3Tid"
					},
					{
						"name": "messages",
						"deco": "m"
					},
					{
						"name": "doThis",
						"deco": "E3std11concurrency10OnCrowding"
					}
				],
				"endline": 924,
				"originalType": "void(Tid tid, size_t messages, OnCrowding doThis)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "setMaxMailboxSize",
				"line": 940,
				"comment": " Sets a maximum mailbox size.\n\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute onCrowdingDoThis.  If messages is zero, the mailbox is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  onCrowdingDoThis = The routine called when a message is sent to a full\n                     mailbox.\n",
				"deco": "FS3std11concurrency3TidmPFS3std11concurrency3TidZbZv",
				"parameters": [
					{
						"name": "tid",
						"deco": "S3std11concurrency3Tid"
					},
					{
						"name": "messages",
						"deco": "m"
					},
					{
						"name": "onCrowdingDoThis",
						"deco": "PFS3std11concurrency3TidZb"
					}
				],
				"endline": 943,
				"originalType": "void(Tid tid, size_t messages, bool function(Tid) onCrowdingDoThis)",
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "register",
				"line": 996,
				"comment": " Associates name with tid.\n\n Associates name with tid in a process-local map.  When the thread\n represented by tid terminates, any names associated with it will be\n automatically unregistered.\n\n Params:\n  name = The name to associate with tid.\n  tid  = The tid register by name.\n\n Returns:\n  true if the name is available and tid is not known to represent a\n  defunct thread.\n",
				"deco": "FAyaS3std11concurrency3TidZb",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					},
					{
						"name": "tid",
						"deco": "S3std11concurrency3Tid"
					}
				],
				"endline": 1008,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "unregister",
				"line": 1020,
				"comment": " Removes the registered name associated with a tid.\n\n Params:\n  name = The name to unregister.\n\n Returns:\n  true if the name is registered, false if not.\n",
				"deco": "FAyaZb",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"endline": 1034,
				"char": 6,
				"kind": "function"
			},
			{
				"endchar": 1,
				"name": "locate",
				"line": 1046,
				"comment": " Gets the Tid associated with name.\n\n Params:\n  name = The name to locate within the registry.\n\n Returns:\n  The associated Tid or Tid.init if name is not registered.\n",
				"deco": "FAyaZS3std11concurrency3Tid",
				"parameters": [
					{
						"name": "name",
						"deco": "Aya"
					}
				],
				"endline": 1054,
				"char": 5,
				"kind": "function"
			},
			{
				"name": "ThreadInfo",
				"line": 1069,
				"comment": "\n\n\n\n Encapsulates all implementation-level data needed for scheduling.\n\n When definining a Scheduler, an instance of this struct must be associated\n with each logical thread.  It contains all implementation-level information\n needed by the internal API.\n",
				"members": [
					{
						"endchar": 5,
						"name": "thisInfo",
						"line": 1082,
						"comment": " Gets a thread-local instance of ThreadInfo.\n\n Gets a thread-local instance of ThreadInfo, which should be used as the\n default instance when info is requested for a thread not created by the\n Scheduler.\n",
						"deco": "FNbNcNdNiNfZS3std11concurrency10ThreadInfo",
						"endline": 1086,
						"originalType": "nothrow @property ref ()",
						"char": 26,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "cleanup",
						"line": 1096,
						"comment": " Cleans up this ThreadInfo.\n\n This must be called when a scheduled thread terminates.  It tears down\n the messaging system for the thread and notifies interested parties of\n the thread's termination.\n",
						"deco": "FZv",
						"endline": 1105,
						"char": 10,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "Scheduler",
				"line": 1141,
				"comment": " A Scheduler controls how threading is performed by spawn.\n\n Implementing a Scheduler allows the concurrency mechanism used by this\n module to be customized according to different needs.  By default, a call\n to spawn will create a new kernel thread that executes the supplied routine\n and terminates when finished.  But it is possible to create Schedulers that\n reuse threads, that multiplex Fibers (coroutines) across a single thread,\n or any number of other approaches.  By making the choice of Scheduler a\n user-level option, std.concurrency may be used for far more types of\n application than if this behavior were predefined.\n\n Example:\n ---\n import std.concurrency;\n import std.stdio;\n\n void main()\n {\n     scheduler = new FiberScheduler;\n     scheduler.start(\n     {\n         writeln(\"the rest of main goes here\");\n     });\n }\n ---\n\n Some schedulers have a dispatching loop that must run if they are to work\n properly, so for the sake of consistency, when using a scheduler, start()\n must be called within main().  This yields control to the scheduler and\n will ensure that any spawned threads are executed in an expected manner.\n",
				"members": [
					{
						"name": "start",
						"line": 1157,
						"comment": " Spawns the supplied op and starts the Scheduler.\n\n This is intended to be called at the start of the program to yield all\n scheduling to the active Scheduler instance.  This is necessary for\n schedulers that explicitly dispatch threads rather than simply relying\n on the operating system to do so, and so start should always be called\n within main() to begin normal program execution.\n\n Params:\n  op = A wrapper for whatever the main thread would have done in the\n       absence of a custom scheduler.  It will be automatically executed\n       via a call to spawn by the Scheduler.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "spawn",
						"line": 1172,
						"comment": " Assigns a logical thread to execute the supplied op.\n\n This routine is called by spawn.  It is expected to instantiate a new\n logical thread and run the supplied operation.  This thread must call\n thisInfo.cleanup() when the thread terminates if the scheduled thread\n is not a kernel thread--all kernel threads will have their ThreadInfo\n cleaned up automatically by a thread-local destructor.\n\n Params:\n  op = The function to execute.  This may be the actual function passed\n       by the user to spawn itself, or may be a wrapper function.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "yield",
						"line": 1183,
						"comment": " Yields execution to another logical thread.\n\n This routine is called at various points within concurrency-aware APIs\n to provide a scheduler a chance to yield execution when using some sort\n of cooperative multithreading model.  If this is not appropriate, such\n as when each logical thread is backed by a dedicated kernel thread,\n this routine may be a no-op.\n",
						"deco": "FNbZv",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "thisInfo",
						"line": 1192,
						"comment": " Returns an appropriate ThreadInfo instance.\n\n Returns an instance of ThreadInfo specific to the logical thread that\n is calling this routine or, if the calling thread was not create by\n this scheduler, returns ThreadInfo.thisInfo instead.\n",
						"deco": "FNbNcNdZS3std11concurrency10ThreadInfo",
						"char": 30,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					},
					{
						"name": "newCondition",
						"line": 1209,
						"comment": " Creates a Condition varialbe analog for signaling.\n\n Creates a new Condition variable analog which is used to check for and\n to signal the addition of messages to a thread's message queue.  Like\n yield, some schedulers may need to define custom behavior so that calls\n to Condition.wait() yield to another thread when no new messages are\n available instead of blocking.\n\n Params:\n  m = The Mutex that will be associated with this condition.  It will be\n      locked prior to any operation on the condition, and so in some\n      cases a Scheduler may need to hold this reference and unlock the\n      mutex before yielding execution to another logical thread.\n",
						"deco": "FNbC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"char": 15,
						"kind": "function",
						"storageClass": [
							"abstract"
						]
					}
				],
				"char": 1,
				"kind": "interface"
			},
			{
				"interfaces": [
					"std.concurrency.Scheduler"
				],
				"members": [
					{
						"endchar": 5,
						"name": "start",
						"line": 1228,
						"comment": " This simply runs op directly, since no real scheduling is needed by\n this approach.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1231,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.start"
						]
					},
					{
						"endchar": 5,
						"name": "spawn",
						"line": 1237,
						"comment": " Creates a new kernel thread and assigns it to run the supplied op.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1241,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.spawn"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 1247,
						"comment": " This scheduler does no explicit multiplexing, so this is a no-op.\n",
						"deco": "FNbZv",
						"endline": 1250,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.yield"
						]
					},
					{
						"endchar": 5,
						"name": "thisInfo",
						"line": 1257,
						"comment": " Returns ThreadInfo.thisInfo, since it is a thread-local instance of\n ThreadInfo, which is the correct behavior for this scheduler.\n",
						"deco": "FNbNcNdZS3std11concurrency10ThreadInfo",
						"endline": 1260,
						"char": 30,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.thisInfo"
						]
					},
					{
						"endchar": 5,
						"name": "newCondition",
						"line": 1266,
						"comment": " Creates a new Condition variable.  No custom behavior is needed here.\n",
						"deco": "FNbC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"endline": 1269,
						"char": 15,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.newCondition"
						]
					}
				],
				"name": "ThreadScheduler",
				"line": 1221,
				"comment": " An example Scheduler using kernel threads.\n\n This is an example Scheduler that mirrors the default scheduling behavior\n of creating one kernel thread per call to spawn.  It is fully functional\n and may be instantiated and used, but is not a necessary part of the\n default functioning of this module.\n",
				"char": 1,
				"kind": "class"
			},
			{
				"interfaces": [
					"std.concurrency.Scheduler"
				],
				"members": [
					{
						"endchar": 5,
						"name": "start",
						"line": 1286,
						"comment": " This creates a new Fiber for the supplied op and then starts the\n dispatcher.\n",
						"deco": "FDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1290,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.start"
						]
					},
					{
						"endchar": 5,
						"name": "spawn",
						"line": 1297,
						"comment": " This created a new Fiber for the supplied op and adds it to the\n dispatch list.\n",
						"deco": "FNbDFZvZv",
						"parameters": [
							{
								"name": "op",
								"deco": "DFZv"
							}
						],
						"endline": 1301,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.spawn"
						]
					},
					{
						"endchar": 5,
						"name": "yield",
						"line": 1308,
						"comment": " If the caller is a scheduled Fiber, this yields execution to another\n scheduled Fiber.\n",
						"deco": "FNbZv",
						"endline": 1315,
						"char": 10,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.yield"
						]
					},
					{
						"endchar": 5,
						"name": "thisInfo",
						"line": 1325,
						"comment": " Returns an appropriate ThreadInfo instance.\n\n Returns a ThreadInfo instance specific to the calling Fiber if the\n Fiber was created by this dispatcher, otherwise it returns\n ThreadInfo.thisInfo.\n",
						"deco": "FNbNcNdZS3std11concurrency10ThreadInfo",
						"endline": 1332,
						"char": 30,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.thisInfo"
						]
					},
					{
						"endchar": 5,
						"name": "newCondition",
						"line": 1338,
						"comment": " Returns a Condition analog that yields when wait or notify is called.\n",
						"deco": "FNbC4core4sync5mutex5MutexZC4core4sync9condition9Condition",
						"parameters": [
							{
								"name": "m",
								"deco": "C4core4sync5mutex5Mutex"
							}
						],
						"endline": 1341,
						"char": 15,
						"kind": "function",
						"overrides": [
							"std.concurrency.Scheduler.newCondition"
						]
					}
				],
				"name": "FiberScheduler",
				"line": 1279,
				"comment": " An example Scheduler using Fibers.\n\n This is an example scheduler that creates a new Fiber per call to spawn\n and multiplexes the execution of all fibers within the main thread.\n",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "scheduler",
				"line": 1505,
				"comment": " Sets the Scheduler behavior within the program.\n\n This variable sets the Scheduler behavior within this program.  Typically,\n when setting a Scheduler, scheduler.start() should be called in main.  This\n routine will not return until program execution is complete.\n",
				"deco": "C3std11concurrency9Scheduler",
				"originalType": "Scheduler",
				"char": 21,
				"kind": "variable",
				"storageClass": [
					"__gshared"
				]
			},
			{
				"endchar": 1,
				"name": "yield",
				"line": 1517,
				"comment": "\n\n\n\n If the caller is a Fiber and is not a Generator, this function will call\n scheduler.yield() or Fiber.yield(), as appropriate.\n",
				"deco": "FNbZv",
				"endline": 1529,
				"char": 6,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "Generator",
						"line": 1569,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 1583,
								"comment": " Initializes a generator object which is associated with a static\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  fn = The fiber function.\n\n In:\n  fn must not be null.\n",
								"type": "(void function() fn)",
								"parameters": [
									{
										"name": "fn",
										"type": "void function()"
									}
								],
								"endline": 1587,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1602,
								"comment": " Initializes a generator object which is associated with a static\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  fn = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  fn must not be null.\n",
								"type": "(void function() fn, size_t sz)",
								"parameters": [
									{
										"name": "fn",
										"type": "void function()"
									},
									{
										"name": "sz",
										"type": "size_t"
									}
								],
								"endline": 1606,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1620,
								"comment": " Initializes a generator object which is associated with a dynamic\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  dg = The fiber function.\n\n In:\n  dg must not be null.\n",
								"type": "(void delegate() dg)",
								"parameters": [
									{
										"name": "dg",
										"type": "void delegate()"
									}
								],
								"endline": 1624,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "this",
								"line": 1639,
								"comment": " Initializes a generator object which is associated with a dynamic\n D function.  The function will be called once to prepare the range\n for iteration.\n\n Params:\n  dg = The fiber function.\n  sz = The stack size for this fiber.\n\n In:\n  dg must not be null.\n",
								"type": "(void delegate() dg, size_t sz)",
								"parameters": [
									{
										"name": "dg",
										"type": "void delegate()"
									},
									{
										"name": "sz",
										"type": "size_t"
									}
								],
								"endline": 1643,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "empty",
								"line": 1649,
								"comment": " Returns true if the generator is empty.\n",
								"type": "@property bool()",
								"endline": 1652,
								"char": 16,
								"kind": "function",
								"storageClass": [
									"final"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 1658,
								"comment": " Obtains the next value from the underlying function.\n",
								"type": "void()",
								"endline": 1661,
								"char": 16,
								"kind": "function",
								"storageClass": [
									"final"
								]
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 1667,
								"comment": " Returns the most recently generated value.\n",
								"type": "@property T()",
								"endline": 1670,
								"char": 13,
								"kind": "function",
								"storageClass": [
									"final"
								]
							}
						],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "Generator",
				"line": 1569,
				"comment": " A Generator is a Fiber that periodically returns values of type T to the\n caller via yield.  This is represented as an InputRange.\n\n Example:\n ---\n import std.concurrency;\n import std.stdio;\n\n\n void main()\n {\n     auto tid = spawn(\n     {\n         while (true)\n         {\n             writeln(receiveOnly!int());\n         }\n     });\n\n     auto r = new Generator!int(\n     {\n         foreach (i; 1 .. 10)\n             yield(i);\n     });\n\n     foreach (e; r)\n     {\n         tid.send(e);\n     }\n }\n ---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "yield",
						"line": 1685,
						"type": "void(ref T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 1695,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "yield",
				"line": 1685,
				"comment": " Yields a value of type T to the caller of the currently executing\n generator.\n\n Params:\n  value = The value to yield.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "yield",
						"line": 1699,
						"type": "void(T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 1702,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "yield",
				"line": 1699,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "initOnce",
						"line": 2539,
						"type": "ref (lazy typeof(var) init)",
						"parameters": [
							{
								"name": "init",
								"type": "typeof(var)",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 2542,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "initOnce",
				"line": 2539,
				"comment": " Initializes $(D_PARAM var) with the lazy $(D_PARAM init) value in a\n thread-safe manner.\n\n The implementation guarantees that all threads simultaneously calling\n initOnce with the same $(D_PARAM var) argument block until $(D_PARAM var) is\n fully initialized. All side-effects of $(D_PARAM init) are globally visible\n afterwards.\n\n Params:\n   var = The variable to initialize\n   init = The lazy initializer value\n\n Returns:\n   A reference to the initialized variable\nExample:\nA typical use-case is to perform lazy but thread-safe initialization.$(DDOX_UNITTEST_HEADER __unittestL2545_2949)\n---\nstatic class MySingleton\n{\n    static MySingleton instance()\n    {\n        static __gshared MySingleton inst;\n        return initOnce!inst(new MySingleton);\n    }\n}\nassert(MySingleton.instance !is null);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2545_2949)\n",
				"parameters": [
					{
						"name": "var",
						"kind": "alias"
					}
				],
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "initOnce",
						"line": 2596,
						"type": "ref (lazy typeof(var) init, Mutex mutex)",
						"parameters": [
							{
								"name": "init",
								"type": "typeof(var)",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "mutex",
								"type": "Mutex"
							}
						],
						"endline": 2615,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "initOnce",
				"line": 2596,
				"comment": " Same as above, but takes a separate mutex instead of sharing one among\n all initOnce instances.\n\n This should be used to avoid dead-locks when the $(D_PARAM init)\n expression waits for the result of another thread that might also\n call initOnce. Use with care.\n\n Params:\n   var = The variable to initialize\n   init = The lazy initializer value\n   mutex = A mutex to prevent race conditions\n\n Returns:\n   A reference to the initialized variable\nExample:\nUse a separate mutex when init blocks on another thread that might also call initOnce.$(DDOX_UNITTEST_HEADER __unittestL2618_2951)\n---\nstatic shared bool varA, varB;\n__gshared Mutex m;\nm = new Mutex;\n\nspawn({\n    // use a different mutex for varB to avoid a dead-lock\n    initOnce!varB(true, m);\n    ownerTid.send(true);\n});\n// init depends on the result of the spawned thread\ninitOnce!varA(receiveOnly!bool);\nassert(varA == true);\nassert(varB == true);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2618_2951)\n",
				"parameters": [
					{
						"name": "var",
						"kind": "alias"
					}
				],
				"char": 10,
				"kind": "template"
			}
		],
		"comment": " This is a low-level messaging API upon which more structured or restrictive\n APIs may be built.  The general idea is that every messageable entity is\n represented by a common handle type called a Tid, which allows messages to\n be sent to logical threads that are executing in both the current process\n and in external processes using the same interface.  This is an important\n aspect of scalability because it allows the components of a program to be\n spread across available resources with few to no changes to the actual\n implementation.\n\n A logical thread is an execution context that has its own stack and which\n runs asynchronously to other logical threads.  These may be preemptively\n scheduled kernel threads, fibers (cooperative user-space threads), or some\n other concept with similar behavior.\n\n The type of concurrency used when logical threads are created is determined\n by the Scheduler selected at initialization time.  The default behavior is\n currently to create a new kernel thread per call to spawn, but other\n schedulers are available that multiplex fibers across the main thread or\n use some combination of the two approaches.\n\n Synposis:\n ---\n import std.stdio;\n import std.concurrency;\n\n void spawnedFunc(Tid ownerTid)\n {\n     // Receive a message from the owner thread.\n     receive(\n         (int i) { writeln(\"Received the number \", i);}\n     );\n\n     // Send a message back to the owner thread\n     // indicating success.\n     send(ownerTid, true);\n }\n\n void main()\n {\n     // Start spawnedFunc in a new thread.\n     auto childTid = spawn(&spawnedFunc, thisTid);\n\n     // Send the number 42 to this new thread.\n     send(childTid, 42);\n\n     // Receive the result code.\n     auto wasSuccessful = receiveOnly!(bool);\n     assert(wasSuccessful);\n     writeln(\"Successfully printed number.\");\n }\n ---\n\n Copyright: Copyright Sean Kelly 2009 - 2014.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   Sean Kelly, Alex RÃ¸nne Petersen, Martin Nowak\n Source:    $(PHOBOSSRC std/_concurrency.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/exception.d",
		"name": "std.exception",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "assertNotThrown",
						"line": 74,
						"type": "void(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "msg",
								"type": "string",
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 91,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "assertNotThrown",
				"line": 74,
				"comment": "    Asserts that the given expression does $(I not) throw the given type\n    of $(D Throwable). If a $(D Throwable) of the given type is thrown,\n    it is caught and does not escape assertNotThrown. Rather, an\n    $(D AssertError) is thrown. However, any other $(D Throwable)s will escape.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n                     If msg is empty, and the thrown exception has a\n                     non-empty msg field, the exception's msg field\n                     will be output on test failure.\n        file       = The file where the error occurred.\n                     Defaults to $(D __FILE__).\n        line       = The line where the error occurred.\n                     Defaults to $(D __LINE__).\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL93_2953)\n---\nimport core.exception : AssertError;\n\nimport std.string;\nassertNotThrown!StringException(enforce!StringException(true, \"Error!\"));\n\n//Exception is the default.\nassertNotThrown(enforce!StringException(true, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertNotThrown!StringException(\n           enforce!StringException(false, \"Error!\"))) ==\n       `assertNotThrown failed: StringException was thrown: Error!`);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL93_2953)\n",
				"parameters": [
					{
						"name": "T",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assertThrown",
						"line": 219,
						"type": "void(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "msg",
								"type": "string",
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 234,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "assertThrown",
				"line": 219,
				"comment": "    Asserts that the given expression throws the given type of $(D Throwable).\n    The $(D Throwable) is caught and does not escape assertThrown. However,\n    any other $(D Throwable)s $(I will) escape, and if no $(D Throwable)\n    of the given type is thrown, then an $(D AssertError) is thrown.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n        file       = The file where the error occurred.\n                     Defaults to $(D __FILE__).\n        line       = The line where the error occurred.\n                     Defaults to $(D __LINE__).\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is not thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL236_2956)\n---\nimport core.exception : AssertError;\nimport std.string;\n\nassertThrown!StringException(enforce!StringException(false, \"Error!\"));\n\n//Exception is the default.\nassertThrown(enforce!StringException(false, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertThrown!StringException(\n           enforce!StringException(true, \"Error!\"))) ==\n       `assertThrown failed: No StringException was thrown.`);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL236_2956)\n",
				"parameters": [
					{
						"name": "T",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforce",
						"line": 348,
						"type": "T(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "msg",
								"type": "const(char)[]",
								"storageClass": [
									"lazy"
								],
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 353,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "enforce",
				"line": 348,
				"comment": "    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new Exception(msg)) is thrown.\n\n    Note:\n        $(D enforce) is used to throw exceptions and is therefore intended to\n        aid in error handling. It is $(I not) intended for verifying the logic\n        of your program. That is what $(D assert) is for. Also, do not use\n        $(D enforce) inside of contracts (i.e. inside of $(D in) and $(D out)\n        blocks and $(D invariant)s), because they will be compiled out when\n        compiling with $(I -release). Use $(D assert) in contracts.\n\n    Example:\n    --------------------\n    auto f = enforce(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforce(line.length, \"Expected a non-empty line.\");\n    --------------------\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(()\n{\nif (!value)\n{\n}\n}\n))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforce",
						"line": 362,
						"type": "T(T value, lazy const(char)[] msg = null)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "msg",
								"type": "const(char)[]",
								"storageClass": [
									"lazy"
								],
								"default": "null"
							}
						],
						"endline": 368,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "enforce",
				"line": 362,
				"comment": "   $(RED Deprecated. If passing the file or line number explicitly, please use\n         the overload of enforce which takes them as function arguments. Taking\n         them as template arguments causes unnecessary template bloat. This\n         overload will be removed in June 2015.)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "file",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "line",
						"defaultValue": "__LINE__",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "is(typeof(()\n{\nif (!value)\n{\n}\n}\n))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforce",
						"line": 376,
						"type": "T(T value, scope Dg dg)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "dg",
								"type": "Dg",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 383,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "enforce",
				"line": 376,
				"comment": "    If $(D !!value) is true, $(D value) is returned. Otherwise, the given\n    delegate is called.\n\n    The whole safety and purity are inferred from $(D Dg)'s safety and purity.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Dg",
						"kind": "type"
					},
					{
						"name": "file",
						"defaultValue": "__FILE__",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "line",
						"defaultValue": "__LINE__",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "isSomeFunction!Dg && is(typeof(dg())) && is(typeof(()\n{\nif (!value)\n{\n}\n}\n))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enforce",
						"line": 533,
						"type": "T(T value, lazy Throwable ex)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "ex",
								"type": "Throwable",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 537,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "enforce",
				"line": 533,
				"comment": "    If $(D !!value) is true, $(D value) is returned. Otherwise, $(D ex) is thrown.\n\n    Example:\n    --------------------\n    auto f = enforce(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforce(line.length, new IOException); // expect a non-empty line\n    --------------------\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "errnoEnforce",
						"line": 557,
						"type": "T(T value, lazy string msg = null)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "msg",
								"type": "string",
								"storageClass": [
									"lazy"
								],
								"default": "null"
							}
						],
						"endline": 562,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "errnoEnforce",
				"line": 557,
				"comment": "    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new ErrnoException(msg)) is thrown. $(D ErrnoException) assumes that the\n    last operation set $(D errno) to an error code.\n\n    Example:\n    --------------------\n    auto f = errnoEnforce(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforce(line.length); // expect a non-empty line\n    --------------------\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "file",
						"defaultValue": "__FILE__",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "line",
						"defaultValue": "__LINE__",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "enforceEx",
								"line": 584,
								"type": "T(T value, lazy string msg = \"\", string file = __FILE__, size_t line = __LINE__)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									},
									{
										"name": "msg",
										"type": "string",
										"storageClass": [
											"lazy"
										],
										"default": "\"\""
									},
									{
										"name": "file",
										"type": "string",
										"default": "__FILE__"
									},
									{
										"name": "line",
										"type": "size_t",
										"default": "__LINE__"
									}
								],
								"endline": 588,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "enforceEx",
						"line": 584,
						"comment": " Ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					}
				],
				"name": "enforceEx",
				"line": 580,
				"comment": "    If $(D !!value) is $(D true), $(D value) is returned. Otherwise,\n    $(D new E(msg, file, line)) is thrown. Or if $(D E) doesn't take a message\n    and can be constructed with $(D new E(file, line)), then\n    $(D new E(file, line)) will be thrown.\n\n    This is legacy name, it is recommended to use $(D enforce!E) instead.\n\n    Example:\n    --------------------\n    auto f = enforceEx!FileMissingException(fopen(\"data.txt\"));\n    auto line = readln(f);\n    enforceEx!DataCorruptionException(line.length);\n    --------------------\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(new E(\"\", \"/home/seb/dlang/docs/work/repo/phobos/std/exception.d\", 581)))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "enforceEx",
								"line": 596,
								"type": "T(T value, string file = __FILE__, size_t line = __LINE__)",
								"parameters": [
									{
										"name": "value",
										"type": "T"
									},
									{
										"name": "file",
										"type": "string",
										"default": "__FILE__"
									},
									{
										"name": "line",
										"type": "size_t",
										"default": "__LINE__"
									}
								],
								"endline": 600,
								"char": 7,
								"kind": "function"
							}
						],
						"name": "enforceEx",
						"line": 596,
						"comment": " Ditto\n",
						"parameters": [
							{
								"name": "T",
								"kind": "type"
							}
						],
						"char": 7,
						"kind": "template"
					}
				],
				"name": "enforceEx",
				"line": 592,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(new E(\"/home/seb/dlang/docs/work/repo/phobos/std/exception.d\", 593))) && !is(typeof(new E(\"\", \"/home/seb/dlang/docs/work/repo/phobos/std/exception.d\", 593)))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "collectException",
						"line": 671,
						"type": "T(lazy E expression, ref E result)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "result",
								"type": "E",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 682,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "collectException",
				"line": 671,
				"comment": "    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned and $(D result) is\n    set to the result of the expression.\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n        result     = The result of the expression if no exception is thrown.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL684_2967)\n---\nint b;\nint foo() { throw new Exception(\"blah\"); }\nassert(collectException(foo(), b));\n\nint[] a = new int[3];\nimport core.exception : RangeError;\nassert(collectException!RangeError(a[4], b));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL684_2967)\n",
				"parameters": [
					{
						"name": "T",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "collectException",
						"line": 711,
						"type": "T(lazy E expression)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 722,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "collectException",
				"line": 711,
				"comment": "    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned. $(D E) can be\n    $(D void).\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n",
				"parameters": [
					{
						"name": "T",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "collectExceptionMsg",
						"line": 749,
						"type": "string(lazy E expression)",
						"parameters": [
							{
								"name": "expression",
								"type": "E",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 760,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "collectExceptionMsg",
				"line": 749,
				"comment": "    Catches the exception thrown from the given expression and returns the\n    msg property of that exception. If no exception is thrown, then null is\n    returned. $(D E) can be $(D void).\n\n    If an exception is thrown but it has an empty message, then\n    $(D emptyExceptionMsg) is returned.\n\n    Note that while $(D collectExceptionMsg) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectExceptionMsg) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL762_2969)\n---\nvoid throwFunc() { throw new Exception(\"My Message.\"); }\nassert(collectExceptionMsg(throwFunc()) == \"My Message.\");\n\nvoid nothrowFunc() {}\nassert(collectExceptionMsg(nothrowFunc()) is null);\n\nvoid throwEmptyFunc() { throw new Exception(\"\"); }\nassert(collectExceptionMsg(throwEmptyFunc()) == emptyExceptionMsg);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL762_2969)\n",
				"parameters": [
					{
						"name": "T",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 8,
				"kind": "template"
			},
			{
				"name": "emptyExceptionMsg",
				"line": 778,
				"comment": "    Value that collectExceptionMsg returns when it catches an exception\n    with an empty exception message.\n",
				"deco": "Aya",
				"init": "\"<Empty Exception Message>\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeUnique",
						"line": 871,
						"type": "pure nothrow immutable(T)[](T[] array)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]"
							}
						],
						"endline": 874,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "assumeUnique",
				"line": 871,
				"comment": " Casts a mutable array to an immutable array in an idiomatic\n manner. Technically, $(D assumeUnique) just inserts a cast,\n but its name documents assumptions on the part of the\n caller. $(D assumeUnique(arr)) should only be called when\n there are no more active mutable aliases to elements of $(D\n arr). To strengthen this assumption, $(D assumeUnique(arr))\n also clears $(D arr) before returning. Essentially $(D\n assumeUnique(arr)) indicates commitment from the caller that there\n is no more mutable access to any of $(D arr)'s elements\n (transitively), and that all future accesses will be done through\n the immutable array returned by $(D assumeUnique).\n\n Typically, $(D assumeUnique) is used to return arrays from\n functions that have allocated and built them.\n\n Example:\n\n ----\n string letters()\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = cast(char)('a' + i);\n   }\n   return assumeUnique(result);\n }\n ----\n\n The use in the example above is correct because $(D result)\n was private to $(D letters) and is inaccessible in writing\n after the function returns. The following example shows an\n incorrect use of $(D assumeUnique).\n\n Bad:\n\n ----\n private char[] buffer;\n string letters(char first, char last)\n {\n   if (first >= last) return null; // fine\n   auto sneaky = buffer;\n   sneaky.length = last - first + 1;\n   foreach (i, ref e; sneaky)\n   {\n     e = cast(char)('a' + i);\n   }\n   return assumeUnique(sneaky); // BAD\n }\n ----\n\n The example above wreaks havoc on client code because it is\n modifying arrays that callers considered immutable. To obtain an\n immutable array from the writable array $(D buffer), replace\n the last line with:\n ----\n return to!(string)(sneaky); // not that sneaky anymore\n ----\n\n The call will duplicate the array appropriately.\n\n Note that checking for uniqueness during compilation is\n possible in certain cases, especially when a function is\n marked as a pure function. The following example does not\n need to call assumeUnique because the compiler can infer the\n uniqueness of the array in the pure function:\n ----\n string letters() pure\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = cast(char)('a' + i);\n   }\n   return result;\n }\n ----\n\n For more on infering uniqueness see the $(B unique) and\n $(B lent) keywords in the\n $(WEB archjava.fluid.cs.cmu.edu/papers/oopsla02.pdf, ArchJava)\n language.\n\n The downside of using $(D assumeUnique)'s\n convention-based usage is that at this time there is no\n formal checking of the correctness of the assumption;\n on the upside, the idiomatic use of $(D assumeUnique) is\n simple and rare enough to be tolerable.\n\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeUnique",
						"line": 876,
						"type": "pure nothrow immutable(T)[](ref T[] array)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 881,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "assumeUnique",
				"line": 876,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeWontThrow",
						"line": 920,
						"type": "nothrow T(lazy T expr, string msg = null, string file = __FILE__, size_t line = __LINE__)",
						"parameters": [
							{
								"name": "expr",
								"type": "T",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "msg",
								"type": "string",
								"default": "null"
							},
							{
								"name": "file",
								"type": "string",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"type": "size_t",
								"default": "__LINE__"
							}
						],
						"endline": 937,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "assumeWontThrow",
				"line": 920,
				"comment": " Wraps a possibly-throwing expression in a $(D nothrow) wrapper so that it\n can be called by a $(D nothrow) function.\n\n This wrapper function documents commitment on the part of the caller that\n the appropriate steps have been taken to avoid whatever conditions may\n trigger an exception during the evaluation of $(D expr).  If it turns out\n that the expression $(I does) throw at runtime, the wrapper will throw an\n $(D AssertError).\n\n (Note that $(D Throwable) objects such as $(D AssertError) that do not\n subclass $(D Exception) may be thrown even from $(D nothrow) functions,\n since they are considered to be serious runtime problems that cannot be\n recovered from.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL940_2972)\n---\nimport std.math : sqrt;\n\n// This function may throw.\nint squareRoot(int x)\n{\n    if (x < 0)\n        throw new Exception(\"Tried to take root of negative number\");\n    return cast(int)sqrt(cast(double)x);\n}\n\n// This function never throws.\nint computeLength(int x, int y) nothrow\n{\n    // Since x*x + y*y is always positive, we can safely assume squareRoot\n    // won't throw, and use it to implement this nothrow function. If it\n    // does throw (e.g., if x*x + y*y overflows a 32-bit value), then the\n    // program will terminate.\n    return assumeWontThrow(squareRoot(x*x + y*y));\n}\n\nassert(computeLength(3, 4) == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL940_2972)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "doesPointTo",
						"line": 1013,
						"type": "pure nothrow @trusted bool(auto ref const S source, ref const T target)",
						"parameters": [
							{
								"name": "source",
								"type": "S",
								"storageClass": [
									"auto",
									"const",
									"ref"
								]
							},
							{
								"name": "target",
								"type": "T",
								"storageClass": [
									"const",
									"ref"
								]
							}
						],
						"endline": 1046,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "doesPointTo",
				"line": 1013,
				"comment": "The \"pointsTo\" functions, $(D doesPointTo) and $(D mayPointTo).\n\nReturns $(D true) if $(D source)'s representation embeds a pointer\nthat points to $(D target)'s representation or somewhere inside\nit.\n\nIf $(D source) is or contains a dynamic array, then, then these functions will check\nif there is overlap between the dynamic array and $(D target)'s representation.\n\nIf $(D source) is a class, then pointsTo will handle it as a pointer.\n\nIf $(D target) is a pointer, a dynamic array or a class, then these functions will only\ncheck if $(D source) points to $(D target), $(I not) what $(D target) references.\n\nIf $(D source) is or contains a union, then there may be either false positives or\nfalse negatives:\n\n$(D doesPointTo) will return $(D true) if it is absolutely certain\n$(D source) points to $(D target). It may produce false negatives, but never\nfalse positives. This function should be prefered when trying to validate\ninput data.\n\n$(D mayPointTo) will return $(D false) if it is absolutely certain\n$(D source) does not point to $(D target). It may produce false positives, but never\nfalse negatives. This function should be prefered for defensively choosing a\ncode path.\n\nNote: Evaluating $(D pointsTo(x, x)) checks whether $(D x) has\ninternal pointers. This should only be done as an assertive test,\nas the language is free to assume objects don't have internal pointers\n(TDPL 7.1.3.5).\nExample:\nPointers$(DDOX_UNITTEST_HEADER __unittestL1150_2975)\n---\nint  i = 0;\nint* p = null;\nassert(!p.doesPointTo(i));\np = &i;\nassert( p.doesPointTo(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1150_2975)\nExample:\nStructs and Unions$(DDOX_UNITTEST_HEADER __unittestL1160_2976)\n---\nstruct S\n{\n    int v;\n    int* p;\n}\nint i;\nauto s = S(0, &i);\n\n//structs and unions \"own\" their members\n//pointsTo will answer true if one of the members pointsTo.\nassert(!s.doesPointTo(s.v)); //s.v is just v member of s, so not pointed.\nassert( s.p.doesPointTo(i)); //i is pointed by s.p.\nassert( s  .doesPointTo(i)); //which means i is pointed by s itself.\n\n//Unions will behave exactly the same. Points to will check each \"member\"\n//individually, even if they share the same memory\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1160_2976)\nExample:\nArrays (dynamic and static)$(DDOX_UNITTEST_HEADER __unittestL1181_2977)\n---\nint i;\nint[]  slice = [0, 1, 2, 3, 4];\nint[5] arr   = [0, 1, 2, 3, 4];\nint*[]  slicep = [&i];\nint*[1] arrp   = [&i];\n\n//A slice points to all of its members:\nassert( slice.doesPointTo(slice[3]));\nassert(!slice[0 .. 2].doesPointTo(slice[3])); //Object 3 is outside of the slice [0 .. 2]\n\n//Note that a slice will not take into account what its members point to.\nassert( slicep[0].doesPointTo(i));\nassert(!slicep   .doesPointTo(i));\n\n//static arrays are objects that own their members, just like structs:\nassert(!arr.doesPointTo(arr[0])); //arr[0] is just a member of arr, so not pointed.\nassert( arrp[0].doesPointTo(i));  //i is pointed by arrp[0].\nassert( arrp   .doesPointTo(i));  //which means i is pointed by arrp itslef.\n\n//Notice the difference between static and dynamic arrays:\nassert(!arr  .doesPointTo(arr[0]));\nassert( arr[].doesPointTo(arr[0]));\nassert( arrp  .doesPointTo(i));\nassert(!arrp[].doesPointTo(i));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1181_2977)\nExample:\nClasses$(DDOX_UNITTEST_HEADER __unittestL1210_2978)\n---\nclass C\n{\n    this(int* p){this.p = p;}\n    int* p;\n}\nint i;\nC a = new C(&i);\nC b = a;\n//Classes are a bit particular, as they are treated like simple pointers\n//to a class payload.\nassert( a.p.doesPointTo(i)); //a.p points to i.\nassert(!a  .doesPointTo(i)); //Yet a itself does not point i.\n\n//To check the class payload itself, iterate on its members:\n()\n{\n    foreach (index, _; FieldTypeTuple!C)\n        if (doesPointTo(a.tupleof[index], i))\n            return;\n    assert(0);\n}();\n\n//To check if a class points a specific payload, a direct memmory check can be done:\nauto aLoc = cast(ubyte[__traits(classInstanceSize, C)]*) a;\nassert(b.doesPointTo(*aLoc)); //b points to where a is pointing\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1210_2978)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					},
					{
						"name": "T",
						"kind": "type"
					},
					{
						"defaultDeco": "v",
						"name": "Tdummy",
						"kind": "type"
					}
				],
				"constraint": "__traits(isRef, source) || isDynamicArray!S || isPointer!S || is(S == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 51,
						"name": "errno",
						"line": 1427,
						"comment": "Operating system error code.\n",
						"deco": "FNdZk",
						"endline": 1427,
						"char": 26,
						"kind": "function",
						"storageClass": [
							"final"
						]
					}
				],
				"name": "ErrnoException",
				"line": 1425,
				"comment": " Thrown if errors that set $(D errno) occur.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ifThrown",
						"line": 1506,
						"type": "CommonType!(T1, T2)(lazy scope T1 expression, lazy scope T2 errorHandler)",
						"parameters": [
							{
								"name": "expression",
								"type": "T1",
								"storageClass": [
									"scope",
									"lazy"
								]
							},
							{
								"name": "errorHandler",
								"type": "T2",
								"storageClass": [
									"scope",
									"lazy"
								]
							}
						],
						"endline": 1518,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "ifThrown",
				"line": 1506,
				"comment": "    ML-style functional exception handling. Runs the supplied expression and\n    returns its result. If the expression throws a $(D Throwable), runs the\n    supplied error handler instead and return its result. The error handler's\n    type must be the same as the expression's type.\n\n    Params:\n        E            = The type of $(D Throwable)s to catch. Defaults to $(D Exception)\n        T1           = The type of the expression.\n        T2           = The return type of the error handler.\n        expression   = The expression to run and return its result.\n        errorHandler = The handler to run if the expression throwed.\n\n    Examples:\n    --------------------\n    //Revert to a default value upon an error:\n    assert(\"x\".to!int().ifThrown(0) == 0);\n    --------------------\n\n    You can also chain multiple calls to ifThrown, each capturing errors from the\n    entire preceding expression.\n\n    Example:\n    --------------------\n    //Chaining multiple calls to ifThrown to attempt multiple things in a row:\n    string s=\"true\";\n    assert(s.to!int().\n            ifThrown(cast(int)s.to!double()).\n            ifThrown(cast(int)s.to!bool())\n            == 1);\n\n    //Respond differently to different types of errors\n    assert(enforce(\"x\".to!int() < 1).to!string()\n            .ifThrown!ConvException(\"not a number\")\n            .ifThrown!Exception(\"number too small\")\n            == \"not a number\");\n    --------------------\n\n    The expression and the errorHandler must have a common type they can both\n    be implicitly casted to, and that type will be the type of the compound\n    expression.\n\n    Examples:\n    --------------------\n    //null and new Object have a common type(Object).\n    static assert(is(typeof(null.ifThrown(new Object())) == Object));\n    static assert(is(typeof((new Object()).ifThrown(null)) == Object));\n\n    //1 and new Object do not have a common type.\n    static assert(!__traits(compiles, 1.ifThrown(new Object())));\n    static assert(!__traits(compiles, (new Object()).ifThrown(1)));\n    --------------------\n\n    If you need to use the actual thrown exception, you can use a delegate.\n    Example:\n    --------------------\n    //Use a lambda to get the thrown object.\n    assert(\"%s\".format().ifThrown!Exception(e => e.classinfo.name) == \"std.format.FormatException\");\n    --------------------\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"default": "Exception",
						"kind": "type"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ifThrown",
						"line": 1522,
						"type": "CommonType!(T1, T2)(lazy scope T1 expression, scope T2 delegate(E) errorHandler)",
						"parameters": [
							{
								"name": "expression",
								"type": "T1",
								"storageClass": [
									"scope",
									"lazy"
								]
							},
							{
								"name": "errorHandler",
								"type": "T2 delegate(E)",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 1534,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "ifThrown",
				"line": 1522,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "ifThrown",
						"line": 1538,
						"type": "CommonType!(T1, T2)(lazy scope T1 expression, scope T2 delegate(Exception) errorHandler)",
						"parameters": [
							{
								"name": "expression",
								"type": "T1",
								"storageClass": [
									"scope",
									"lazy"
								]
							},
							{
								"name": "errorHandler",
								"type": "T2 delegate(Exception)",
								"storageClass": [
									"scope"
								]
							}
						],
						"endline": 1550,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "ifThrown",
				"line": 1538,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "front",
						"line": 1641,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "back",
						"line": 1642,
						"value": "2",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "popFront",
						"line": 1643,
						"value": "4",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "popBack",
						"line": 1644,
						"value": "8",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "empty",
						"line": 1645,
						"value": "16",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "save",
						"line": 1646,
						"value": "32",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "length",
						"line": 1647,
						"value": "64",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "opDollar",
						"line": 1648,
						"value": "128",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "opIndex",
						"line": 1649,
						"value": "256",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "opSlice",
						"line": 1650,
						"value": "512",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "access",
						"line": 1651,
						"value": "259",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pop",
						"line": 1652,
						"value": "12",
						"comment": "Ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "RangePrimitive",
				"line": 1639,
				"comment": " This $(D enum) is used to select the primitives of the range to handle by the\n  $(LREF handle) range wrapper. The values of the $(D enum) can be $(D OR)'d to\n  select multiple primitives to be handled.\n\n  $(D RangePrimitive.access) is a shortcut for the access primitives; $(D front),\n  $(D back) and $(D opIndex).\n\n  $(D RangePrimitive.pop) is a shortcut for the mutating primitives;\n  $(D popFront) and $(D popBack).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "handle",
						"line": 1682,
						"type": "(Range input)",
						"parameters": [
							{
								"name": "input",
								"type": "Range"
							}
						],
						"endline": 1911,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "handle",
				"line": 1682,
				"comment": " Handle exceptions thrown from range primitives.\n\nUse the $(LREF RangePrimitive) enum to specify which primitives to _handle.\nMultiple range primitives can be handled at once by using the $(D OR) operator\nor the pseudo-primitives $(D RangePrimitive.access) and $(D RangePrimitive.pop).\nAll handled primitives must have return types or values compatible with the\nuser-supplied handler.\n\nParams:\n    E = The type of $(D Throwable) to _handle.\n    primitivesToHandle = Set of range primitives to _handle.\n    handler = The callable that is called when a handled primitive throws a\n    $(D Throwable) of type $(D E). The handler must accept arguments of\n    the form $(D E, ref IRange) and its return value is used as the primitive's\n    return value whenever $(D E) is thrown. For $(D opIndex), the handler can\n    optionally recieve a third argument; the index that caused the exception.\n    input = The range to _handle.\n\nReturns: A wrapper $(D struct) that preserves the range interface of $(D input).\n\nopSlice:\nInfinite ranges with slicing support must return an instance of\n$(XREF range, Take) when sliced with a specific lower and upper\nbound (see $(XREF_PACK range,primitives,hasSlicing)); $(D handle) deals with\nthis by $(D take)ing 0 from the return value of the handler function and\nreturning that when an exception is caught.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1914_3001)\n---\nimport std.algorithm : equal, map, splitter;\nimport std.conv : to, ConvException;\n\nauto s = \"12,1337z32,54,2,7,9,1z,6,8\";\n\n// The next line composition will throw when iterated\n// as some elements of the input do not convert to integer\nauto r = s.splitter(',').map!(a => to!int(a));\n\n// Substitute 0 for cases of ConvException\nauto h = r.handle!(ConvException, RangePrimitive.front, (e, r) => 0);\nassert(h.equal([12, 0, 54, 2, 7, 9, 0, 6, 8]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1914_3001)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1931_3004)\n---\nimport std.algorithm : equal;\nimport std.range : retro;\nimport std.utf : UTFException;\n\nauto str = \"hello\\xFFworld\"; // 0xFF is an invalid UTF-8 code unit\n\nauto handled = str.handle!(UTFException, RangePrimitive.access,\n        (e, r) => ' '); // Replace invalid code points with spaces\n\nassert(handled.equal(\"hello world\")); // `front` is handled,\nassert(handled.retro.equal(\"dlrow olleh\")); // as well as `back`\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1931_3004)\n",
				"parameters": [
					{
						"name": "E",
						"deco": "C6object9Throwable",
						"kind": "type"
					},
					{
						"name": "primitivesToHandle",
						"deco": "E3std9exception14RangePrimitive",
						"kind": "value"
					},
					{
						"name": "handler",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "    This module defines functions related to exceptions and general error\n    handling. It also defines functions intended to aid in unit testing.\n\n    Synopsis of some of std.exception's functions:\n    --------------------\n    string synopsis()\n    {\n        FILE* f = enforce(fopen(\"some/file\"));\n        // f is not null from here on\n        FILE* g = enforce!WriteException(fopen(\"some/other/file\", \"w\"));\n        // g is not null from here on\n\n        Exception e = collectException(write(g, readln(f)));\n        if (e)\n        {\n            ... an exception occurred...\n            ... We have the exception to play around with...\n        }\n\n        string msg = collectExceptionMsg(write(g, readln(f)));\n        if (msg)\n        {\n            ... an exception occurred...\n            ... We have the message from the exception but not the exception...\n        }\n\n        char[] line;\n        enforce(readln(f, line));\n        return assumeUnique(line);\n    }\n    --------------------\n\n    Macros:\n        WIKI = Phobos/StdException\n\n    Copyright: Copyright Andrei Alexandrescu 2008-, Jonathan M Davis 2011-.\n    License:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Authors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_exception.d)\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/range/interfaces.d",
		"name": "std.range.interfaces",
		"members": [
			{
				"members": [
					{
						"name": "InputRange",
						"line": 93,
						"members": [
							{
								"name": "front",
								"line": 95,
								"comment": "\n",
								"type": "@property E()",
								"char": 17,
								"kind": "function"
							},
							{
								"name": "moveFront",
								"line": 98,
								"comment": "\n",
								"type": "E()",
								"char": 7,
								"kind": "function"
							},
							{
								"name": "popFront",
								"line": 101,
								"comment": "\n",
								"type": "void()",
								"char": 10,
								"kind": "function"
							},
							{
								"name": "empty",
								"line": 104,
								"comment": "\n",
								"type": "@property bool()",
								"char": 20,
								"kind": "function"
							},
							{
								"name": "opApply",
								"line": 118,
								"comment": "$(D foreach) iteration uses opApply, since one delegate call per loop\n iteration is faster than three virtual function calls.\n",
								"type": "int(int delegate(E))",
								"parameters": [
									{
										"type": "int delegate(E)"
									}
								],
								"char": 9,
								"kind": "function"
							},
							{
								"name": "opApply",
								"line": 121,
								"comment": "Ditto\n",
								"type": "int(int delegate(size_t, E))",
								"parameters": [
									{
										"type": "int delegate(size_t, E)"
									}
								],
								"char": 9,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "InputRange",
				"line": 93,
				"comment": "These interfaces are intended to provide virtual function-based wrappers\n around input ranges with element type E.  This is useful where a well-defined\n binary interface is required, such as when a DLL function or virtual function\n needs to accept a generic range as a parameter.  Note that\n $(LREF isInputRange) and friends check for conformance to structural\n interfaces, not for implementation of these $(D interface) types.\n\n Limitations:\n\n These interfaces are not capable of forwarding $(D ref) access to elements.\n\n Infiniteness of the wrapped range is not propagated.\n\n Length is not propagated in the case of non-random access ranges.\n\n See_Also:\n $(LREF inputRangeObject)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL126_3023)\n---\nimport std.algorithm : map;\nimport std.range : iota;\n\nvoid useRange(InputRange!int range) {\n    // Function body.\n}\n\n// Create a range type.\nauto squares = map!\"a * a\"(iota(10));\n\n// Wrap it in an interface.\nauto squaresWrapped = inputRangeObject(squares);\n\n// Use it.\nuseRange(squaresWrapped);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL126_3023)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ForwardRange",
						"line": 146,
						"members": [
							{
								"name": "save",
								"line": 148,
								"comment": "\n",
								"type": "@property ForwardRange!E()",
								"char": 30,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "ForwardRange",
				"line": 146,
				"comment": "Interface for a forward range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BidirectionalRange",
						"line": 152,
						"members": [
							{
								"name": "save",
								"line": 154,
								"comment": "\n",
								"type": "@property BidirectionalRange!E()",
								"char": 36,
								"kind": "function"
							},
							{
								"name": "back",
								"line": 157,
								"comment": "\n",
								"type": "@property E()",
								"char": 17,
								"kind": "function"
							},
							{
								"name": "moveBack",
								"line": 160,
								"comment": "\n",
								"type": "E()",
								"char": 7,
								"kind": "function"
							},
							{
								"name": "popBack",
								"line": 163,
								"comment": "\n",
								"type": "void()",
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "BidirectionalRange",
				"line": 152,
				"comment": "Interface for a bidirectional range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomAccessFinite",
						"line": 167,
						"members": [
							{
								"name": "save",
								"line": 169,
								"comment": "\n",
								"type": "@property RandomAccessFinite!E()",
								"char": 36,
								"kind": "function"
							},
							{
								"name": "opIndex",
								"line": 172,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							},
							{
								"name": "moveAt",
								"line": 175,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							},
							{
								"name": "length",
								"line": 178,
								"comment": "\n",
								"type": "@property size_t()",
								"char": 22,
								"kind": "function"
							},
							{
								"name": "opDollar",
								"line": 181,
								"comment": "\n",
								"type": "length",
								"char": 5,
								"kind": "alias"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "RandomAccessFinite",
				"line": 167,
				"comment": "Interface for a finite random access range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomAccessInfinite",
						"line": 192,
						"members": [
							{
								"name": "moveAt",
								"line": 194,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							},
							{
								"name": "save",
								"line": 197,
								"comment": "\n",
								"type": "@property RandomAccessInfinite!E()",
								"char": 38,
								"kind": "function"
							},
							{
								"name": "opIndex",
								"line": 200,
								"comment": "\n",
								"type": "E(size_t)",
								"parameters": [
									{
										"type": "size_t"
									}
								],
								"char": 7,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "RandomAccessInfinite",
				"line": 192,
				"comment": "Interface for an infinite random access range of type $(D E).\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "InputAssignable",
						"line": 204,
						"members": [
							{
								"name": "front",
								"line": 206,
								"comment": "\n",
								"type": "@property void(E newVal)",
								"parameters": [
									{
										"name": "newVal",
										"type": "E"
									}
								],
								"char": 20,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "InputAssignable",
				"line": 204,
				"comment": "Adds assignable elements to InputRange.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ForwardAssignable",
						"line": 210,
						"members": [
							{
								"name": "save",
								"line": 212,
								"comment": "\n",
								"type": "@property ForwardAssignable!E()",
								"char": 35,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "ForwardAssignable",
				"line": 210,
				"comment": "Adds assignable elements to ForwardRange.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "BidirectionalAssignable",
						"line": 216,
						"members": [
							{
								"name": "save",
								"line": 218,
								"comment": "\n",
								"type": "@property BidirectionalAssignable!E()",
								"char": 41,
								"kind": "function"
							},
							{
								"name": "back",
								"line": 221,
								"comment": "\n",
								"type": "@property void(E newVal)",
								"parameters": [
									{
										"name": "newVal",
										"type": "E"
									}
								],
								"char": 20,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "BidirectionalAssignable",
				"line": 216,
				"comment": "Adds assignable elements to BidirectionalRange.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RandomFiniteAssignable",
						"line": 225,
						"members": [
							{
								"name": "save",
								"line": 227,
								"comment": "\n",
								"type": "@property RandomFiniteAssignable!E()",
								"char": 40,
								"kind": "function"
							},
							{
								"name": "opIndexAssign",
								"line": 230,
								"comment": "\n",
								"type": "void(E val, size_t index)",
								"parameters": [
									{
										"name": "val",
										"type": "E"
									},
									{
										"name": "index",
										"type": "size_t"
									}
								],
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "RandomFiniteAssignable",
				"line": 225,
				"comment": "Adds assignable elements to RandomAccessFinite.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "OutputRange",
						"line": 235,
						"members": [
							{
								"name": "put",
								"line": 237,
								"comment": "\n",
								"type": "void(E)",
								"parameters": [
									{
										"type": "E"
									}
								],
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "interface"
					}
				],
				"name": "OutputRange",
				"line": 235,
				"comment": "Interface for an output range of type $(D E).  Usage is similar to the\n $(D InputRange) interface and descendants.\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "OutputRangeObject",
						"line": 266,
						"members": [],
						"char": 1,
						"kind": "class"
					}
				],
				"name": "OutputRangeObject",
				"line": 266,
				"comment": "Implements the $(D OutputRange) interface for all types E and wraps the\n $(D put) method for each type $(D E) in a virtual function.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "MostDerivedInputRange",
				"line": 280,
				"comment": "Returns the interface type that best matches $(D R).\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "InputRangeObject",
				"line": 316,
				"comment": "Implements the most derived interface that $(D R) works with and wraps\n all relevant range primitives in virtual functions.  If $(D R) is already\n derived from the $(D InputRange) interface, aliases itself away.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "inputRangeObject",
						"line": 434,
						"type": "InputRangeObject!R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 440,
						"char": 20,
						"kind": "function"
					}
				],
				"name": "inputRangeObject",
				"line": 434,
				"comment": "Convenience function for creating an $(D InputRangeObject) of the proper type.\n See $(LREF InputRange) for an example.\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 20,
				"kind": "template"
			},
			{
				"members": [
					{
						"members": [
							{
								"endchar": 5,
								"name": "outputRangeObject",
								"line": 448,
								"type": "OutputRangeObject!(R, E)(R range)",
								"parameters": [
									{
										"name": "range",
										"type": "R"
									}
								],
								"endline": 450,
								"char": 30,
								"kind": "function"
							}
						],
						"name": "outputRangeObject",
						"line": 448,
						"comment": "\n",
						"parameters": [
							{
								"name": "R",
								"kind": "type"
							}
						],
						"char": 30,
						"kind": "template"
					}
				],
				"name": "outputRangeObject",
				"line": 445,
				"comment": "Convenience function for creating an $(D OutputRangeObject) with a base range\n of type $(D R) that accepts types $(D E).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL454_3025)\n---\nimport std.array;\nauto app = appender!(uint[])();\nauto appWrapped = outputRangeObject!(uint, uint[])(app);\nstatic assert(is(typeof(appWrapped) : OutputRange!(uint[])));\nstatic assert(is(typeof(appWrapped) : OutputRange!(uint)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL454_3025)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": "This module is a submodule of $(LINK2 std_range.html, std.range).\n\nThe main $(D std.range) module provides template-based tools for working with\nranges, but sometimes an object-based interface for ranges is needed, such as\nwhen runtime polymorphism is required. For this purpose, this submodule\nprovides a number of object and $(D interface) definitions that can be used to\nwrap around _range objects created by the $(D std.range) templates.\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF InputRange)))\n        $(TD Wrapper for input ranges.\n    ))\n    $(TR $(TD $(D $(LREF InputAssignable)))\n        $(TD Wrapper for input ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF ForwardRange)))\n        $(TD Wrapper for forward ranges.\n    ))\n    $(TR $(TD $(D $(LREF ForwardAssignable)))\n        $(TD Wrapper for forward ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF BidirectionalRange)))\n        $(TD Wrapper for bidirectional ranges.\n    ))\n    $(TR $(TD $(D $(LREF BidirectionalAssignable)))\n        $(TD Wrapper for bidirectional ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessFinite)))\n        $(TD Wrapper for finite random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessAssignable)))\n        $(TD Wrapper for finite random-access ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessInfinite)))\n        $(TD Wrapper for infinite random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF OutputRange)))\n        $(TD Wrapper for output ranges.\n    ))\n    $(TR $(TD $(D $(LREF OutputRangeObject)))\n        $(TD Class that implements the $(D OutputRange) interface and wraps the\n        $(D put) methods in virtual functions.\n    ))\n    $(TR $(TD $(D $(LREF InputRangeObject)))\n        $(TD Class that implements the $(D InputRange) interface and wraps the\n        input _range methods in virtual functions.\n    ))\n    $(TR $(TD $(D $(LREF RefRange)))\n        $(TD Wrapper around a forward _range that gives it reference semantics.\n    ))\n)\n\n\nSource: $(PHOBOSSRC std/range/_interfaces.d)\n\nMacros:\n\nWIKI = Phobos/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net/leonardo/so/, Leonardo Maffi).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/range/package.d",
		"name": "std.range",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "retro",
						"line": 185,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 294,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "retro",
				"line": 185,
				"comment": "Iterates a bidirectional range backwards. The original range can be\naccessed by using the $(D source) property. Applying retro twice to\nthe same range yields the original range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL298_3027)\n---\nimport std.algorithm : equal;\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(retro(a), [ 5, 4, 3, 2, 1 ][]));\nassert(retro(a).source is a);\nassert(retro(retro(a)) is a);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL298_3027)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!(Unqual!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "stride",
						"line": 412,
						"type": "(Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 620,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "stride",
				"line": 412,
				"comment": "Iterates range $(D r) with stride $(D n). If the range is a\nrandom-access range, moves by indexing into the range; otherwise,\nmoves by successive calls to $(D popFront). Applying stride twice to\nthe same range results in a stride with a step that is the\nproduct of the two applications. It is an error for $(D n) to be 0.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL623_3032)\n---\nimport std.algorithm : equal;\n\nint[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\nassert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));\nassert(stride(stride(a, 2), 3) == stride(a, 6));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL623_3032)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!Range)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chain",
						"line": 795,
						"type": "(Ranges rs)",
						"parameters": [
							{
								"name": "rs",
								"type": "Ranges"
							}
						],
						"endline": 1108,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chain",
				"line": 795,
				"comment": "Spans multiple ranges in sequence. The function $(D chain) takes any\nnumber of ranges and returns a $(D Chain!(R1, R2,...)) object. The\nranges may be different, but they must have the same element type. The\nresult is a range that offers the $(D front), $(D popFront), and $(D\nempty) primitives. If all input ranges offer random access and $(D\nlength), $(D Chain) offers them as well.\n\nIf only one range is offered to $(D Chain) or $(D chain), the $(D\nChain) type exits the picture by aliasing itself directly to that\nrange's type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1111_3037)\n---\nimport std.algorithm : equal;\n\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\nauto s = chain(arr1, arr2, arr3);\nassert(s.length == 7);\nassert(s[5] == 6);\nassert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1111_3037)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 0 && allSatisfy!(isInputRange, staticMap!(Unqual, Ranges)) && !is(CommonType!(staticMap!(ElementType, staticMap!(Unqual, Ranges))) == void)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "choose",
						"line": 1246,
						"type": "(bool condition, R1 r1, R2 r2)",
						"parameters": [
							{
								"name": "condition",
								"deco": "b"
							},
							{
								"name": "r1",
								"type": "R1"
							},
							{
								"name": "r2",
								"type": "R2"
							}
						],
						"endline": 1408,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "choose",
				"line": 1246,
				"comment": "Choose one of two ranges at runtime depending on a Boolean condition.\n\nThe ranges may be different, but they must have compatible element types (i.e.\n$(D CommonType) must exist for the two element types). The result is a range\nthat offers the weakest capabilities of the two (e.g. $(D ForwardRange) if $(D\nR1) is a random-access range and $(D R2) is a forward range).\n\nParams:\n    condition = which range to choose: $(D r1) if $(D true), $(D r2) otherwise\n    r1 = the \"true\" range\n    r2 = the \"false\" range\n\nReturns:\n    A range type dependent on $(D R1) and $(D R2).\n\nBugs:\n    $(BUGZILLA 14660)\n",
				"parameters": [
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R1) && isInputRange!(Unqual!R2) && !is(CommonType!(ElementType!(Unqual!R1), ElementType!(Unqual!R2)) == void)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chooseAmong",
						"line": 1424,
						"type": "(size_t index, Ranges rs)",
						"parameters": [
							{
								"name": "index",
								"type": "size_t"
							},
							{
								"name": "rs",
								"type": "Ranges"
							}
						],
						"endline": 1430,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "chooseAmong",
				"line": 1424,
				"comment": "Choose one of multiple ranges at runtime.\n\nThe ranges may be different, but they must have compatible element types. The\nresult is a range that offers the weakest capabilities of all $(D Ranges).\n\nParams:\n    index = which range to choose, must be less than the number of ranges\n    rs = two or more ranges\n\nReturns:\n    The indexed range. If rs consists of only one range, the return type is an\n    alias of that range's type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1439_3040)\n---\nimport std.algorithm : equal;\n\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\n\n{\n    auto s = chooseAmong(0, arr1, arr2, arr3);\n    auto t = s.save;\n    assert(s.length == 4);\n    assert(s[2] == 3);\n    s.popFront();\n    assert(equal(t, [1, 2, 3, 4][]));\n}\n{\n    auto s = chooseAmong(1, arr1, arr2, arr3);\n    assert(s.length == 2);\n    s.front = 8;\n    assert(equal(s, [8, 6][]));\n}\n{\n    auto s = chooseAmong(1, arr1, arr2, arr3);\n    assert(s.length == 2);\n    s[1] = 9;\n    assert(equal(s, [8, 9][]));\n}\n{\n    auto s = chooseAmong(1, arr2, arr1, arr3)[1..3];\n    assert(s.length == 2);\n    assert(equal(s, [2, 3][]));\n}\n{\n    auto s = chooseAmong(0, arr1, arr2, arr3);\n    assert(s.length == 4);\n    assert(s.back == 4);\n    s.popBack();\n    s.back = 5;\n    assert(equal(s, [1, 2, 5][]));\n    s.back = 3;\n    assert(equal(s, [1, 2, 3][]));\n}\n{\n    uint[] foo = [1,2,3,4,5];\n    uint[] bar = [6,7,8,9,10];\n    auto c = chooseAmong(1,foo, bar);\n    assert(c[3] == 9);\n    c[3] = 42;\n    assert(c[3] == 42);\n    assert(c.moveFront() == 6);\n    assert(c.moveBack() == 10);\n    assert(c.moveAt(4) == 10);\n}\n{\n    import std.range : cycle;\n    auto s = chooseAmong(1, cycle(arr2), cycle(arr3));\n    assert(isInfinite!(typeof(s)));\n    assert(!s.empty);\n    assert(s[100] == 7);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1439_3040)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 2 && is(typeof(choose(true, rs[0], rs[1]))) && is(typeof(chooseAmong(0, rs[1..__dollar])))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "roundRobin",
						"line": 1520,
						"type": "(Rs rs)",
						"parameters": [
							{
								"name": "rs",
								"type": "Rs"
							}
						],
						"endline": 1614,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "roundRobin",
				"line": 1520,
				"comment": "$(D roundRobin(r1, r2, r3)) yields $(D r1.front), then $(D r2.front),\nthen $(D r3.front), after which it pops off one element from each and\ncontinues again from $(D r1). For example, if two ranges are involved,\nit alternately yields elements off the two ranges. $(D roundRobin)\nstops after it has consumed all ranges (skipping over the ones that\nfinish early).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1617_3042)\n---\nimport std.algorithm : equal;\n\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 10, 20, 30, 40 ];\nauto r = roundRobin(a, b);\nassert(equal(r, [ 1, 10, 2, 20, 3, 30, 40 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1617_3042)\n",
				"parameters": [
					{
						"name": "Rs",
						"kind": "tuple"
					}
				],
				"constraint": "Rs.length > 1 && allSatisfy!(isInputRange, staticMap!(Unqual, Rs))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "radial",
						"line": 1633,
						"type": "(Range r, I startingIndex)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							},
							{
								"name": "startingIndex",
								"type": "I"
							}
						],
						"endline": 1638,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "radial",
				"line": 1633,
				"comment": "Iterates a random-access range starting from a given point and\nprogressively extending left and right from that point. If no initial\npoint is given, iteration starts from the middle of the\nrange. Iteration spans the entire range.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1648_3043)\n---\nimport std.algorithm : equal;\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));\na = [ 1, 2, 3, 4 ];\nassert(equal(radial(a), [ 2, 3, 1, 4 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1648_3043)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!(Unqual!Range) && hasLength!(Unqual!Range) && isIntegral!I",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "radial",
						"line": 1641,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 1645,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "radial",
				"line": 1641,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!(Unqual!R) && hasLength!(Unqual!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Take",
						"line": 1711,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Take",
				"line": 1711,
				"comment": "Lazily takes only up to $(D n) elements of a range. This is\nparticularly useful when using with infinite ranges. If the range\noffers random access and $(D length), $(D Take) offers them as well.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1901_3046)\n---\nimport std.algorithm : equal;\n\nint[] arr1 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nauto s = take(arr1, 5);\nassert(s.length == 5);\nassert(s[4] == 5);\nassert(equal(s, [ 1, 2, 3, 4, 5 ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1901_3046)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!Range) && !(!isInfinite!(Unqual!Range) && hasSlicing!(Unqual!Range) || is(Range T == Take!T))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "take",
						"line": 1890,
						"type": "Take!R(R input, size_t n)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1898,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "take",
				"line": 1890,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R) && !isInfinite!(Unqual!R) && hasSlicing!(Unqual!R) && !is(R T == Take!T)",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeExactly",
						"line": 2040,
						"type": "(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2116,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeExactly",
				"line": 2040,
				"comment": "Similar to $(LREF take), but assumes that $(D range) has at least $(D\nn) elements. Consequently, the result of $(D takeExactly(range, n))\nalways defines the $(D length) property (and initializes it to $(D n))\neven when $(D range) itself does not define $(D length).\n\nThe result of $(D takeExactly) is identical to that of $(LREF take) in\ncases where the original range defines $(D length) or is infinite.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2119_3052)\n---\nimport std.algorithm : equal;\n\nauto a = [ 1, 2, 3, 4, 5 ];\n\nauto b = takeExactly(a, 3);\nassert(equal(b, [1, 2, 3]));\nstatic assert(is(typeof(b.length) == size_t));\nassert(b.length == 3);\nassert(b.front == 1);\nassert(b.back == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2119_3052)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeOne",
						"line": 2238,
						"type": "(R source)",
						"parameters": [
							{
								"name": "source",
								"type": "R"
							}
						],
						"endline": 2273,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeOne",
				"line": 2238,
				"comment": "Returns a range with at most one element; for example, $(D\ntakeOne([42, 43, 44])) returns a range consisting of the integer $(D\n42). Calling $(D popFront()) off that range renders it empty.\n\nIn effect $(D takeOne(r)) is somewhat equivalent to $(D take(r, 1)) but in\ncertain interfaces it is important to know statically that the range may only\nhave at most one element.\n\nThe type returned by $(D takeOne) is a random-access range with length\nregardless of $(D R)'s capabilities (another feature that distinguishes\n$(D takeOne) from $(D take)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2276_3056)\n---\nauto s = takeOne([42, 43, 44]);\nstatic assert(isRandomAccessRange!(typeof(s)));\nassert(s.length == 1);\nassert(!s.empty);\nassert(s.front == 42);\ns.front = 43;\nassert(s.front == 43);\nassert(s.back == 43);\nassert(s[0] == 43);\ns.popFront();\nassert(s.length == 0);\nassert(s.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2276_3056)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeNone",
						"line": 2312,
						"type": "()",
						"endline": 2316,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeNone",
				"line": 2312,
				"comment": "    Returns an empty range which is statically known to be empty and is\n    guaranteed to have $(D length) and be random access regardless of $(D R)'s\n    capabilities.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2319_3058)\n---\nauto range = takeNone!(int[])();\nassert(range.length == 0);\nassert(range.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2319_3058)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "takeNone",
						"line": 2339,
						"type": "(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2361,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "takeNone",
				"line": 2339,
				"comment": "    Creates an empty range from the given range in $(BIGOH 1). If it can, it\n    will return the same range type. If not, it will return\n    $(D takeExactly(range, 0)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2364_3060)\n---\nimport std.algorithm : filter;\nassert(takeNone([42, 27, 19]).empty);\nassert(takeNone(\"dlang.org\").empty);\nassert(takeNone(filter!\"true\"([42, 27, 19])).empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2364_3060)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "drop",
						"line": 2505,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2510,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "drop",
				"line": 2505,
				"comment": "    Convenience function which calls\n    $(D range.$(LREF popFrontN)(n)) and returns $(D range). $(D drop)\n    makes it easier to pop elements from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFrontN) would require multiple statements.\n\n    $(D dropBack) provides the same functionality but instead calls\n    $(D range.popBackN(n)).\n\n    Note: $(D drop) and $(D dropBack) will only pop $(I up to)\n    $(D n) elements but will stop if the range is empty first.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2520_3062)\n---\nimport std.algorithm : equal;\n\nassert([0, 2, 1, 5, 0, 3].drop(3) == [5, 0, 3]);\nassert(\"hello world\".drop(6) == \"world\");\nassert(\"hello world\".drop(50).empty);\nassert(\"hello world\".take(6).drop(3).equal(\"lo \"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2520_3062)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBack",
						"line": 2512,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2517,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropBack",
				"line": 2512,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropExactly",
						"line": 2583,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2588,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropExactly",
				"line": 2583,
				"comment": "    Similar to $(LREF drop) and $(D dropBack) but they call\n    $(D range.$(LREF popFrontExactly)(n)) and $(D range.popBackExactly(n))\n    instead.\n\n    Note: Unlike $(D drop), $(D dropExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D dropExactly)\n    faster than $(D drop), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2598_3067)\n---\nimport std.algorithm : equal, filterBidirectional;\n\nauto a = [1, 2, 3];\nassert(a.dropExactly(2) == [3]);\nassert(a.dropBackExactly(2) == [1]);\n\nstring s = \"æ¥æ¬èª\";\nassert(s.dropExactly(2) == \"èª\");\nassert(s.dropBackExactly(2) == \"æ¥\");\n\nauto bd = filterBidirectional!\"true\"([1, 2, 3]);\nassert(bd.dropExactly(2).equal([3]));\nassert(bd.dropBackExactly(2).equal([1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2598_3067)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBackExactly",
						"line": 2590,
						"type": "R(R range, size_t n)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2595,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropBackExactly",
				"line": 2590,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropOne",
						"line": 2625,
						"type": "R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2630,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropOne",
				"line": 2625,
				"comment": "    Convenience function which calls\n    $(D range.popFront()) and returns $(D range). $(D dropOne)\n    makes it easier to pop an element from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFront) would require multiple statements.\n\n    $(D dropBackOne) provides the same functionality but instead calls\n    $(D range.popBack()).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2640_3068)\n---\nimport std.algorithm : equal, filterBidirectional;\n\nimport std.container.dlist;\n\nauto dl = DList!int(9, 1, 2, 3, 9);\nassert(dl[].dropOne().dropBackOne().equal([1, 2, 3]));\n\nauto a = [1, 2, 3];\nassert(a.dropOne() == [2, 3]);\nassert(a.dropBackOne() == [1, 2]);\n\nstring s = \"æ¥æ¬èª\";\nassert(s.dropOne() == \"æ¬èª\");\nassert(s.dropBackOne() == \"æ¥æ¬\");\n\nauto bd = filterBidirectional!\"true\"([1, 2, 3]);\nassert(bd.dropOne().equal([2, 3]));\nassert(bd.dropBackOne().equal([1, 2]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2640_3068)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "dropBackOne",
						"line": 2632,
						"type": "R(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2637,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "dropBackOne",
				"line": 2632,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!R",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Repeat",
						"line": 2667,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Repeat",
				"line": 2667,
				"comment": "Repeats one value forever.\n\nModels an infinite bidirectional and random access range, with slicing.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2709_3069)\n---\nimport std.algorithm : equal;\n\nassert(equal(5.repeat().take(4), [ 5, 5, 5, 5 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2709_3069)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 55,
						"name": "repeat",
						"line": 2706,
						"type": "Repeat!T(T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 2706,
						"char": 10,
						"kind": "function"
					}
				],
				"name": "repeat",
				"line": 2706,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 10,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "repeat",
						"line": 2739,
						"type": "Take!(Repeat!T)(T value, size_t n)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 2742,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "repeat",
				"line": 2739,
				"comment": "   Repeats $(D value) exactly $(D n) times. Equivalent to $(D\n   take(repeat(value), n)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2745_3071)\n---\nimport std.algorithm : equal;\n\nassert(equal(5.repeat(4), 5.repeat().take(4)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2745_3071)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "generate",
						"line": 2792,
						"type": "(Fun fun)",
						"parameters": [
							{
								"name": "fun",
								"type": "Fun"
							}
						],
						"endline": 2796,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "generate",
				"line": 2792,
				"comment": "Given callable ($(XREF traits, isCallable)) $(D fun), create as a range\nwhose front is defined by successive calls to $(D fun()).\nThis is especially useful to call function with global side effects (random\nfunctions), or to create ranges expressed as a single delegate, rather than\nan entire $(D front)/$(D popFront)/$(D empty) structure.\n$(D fun) maybe be passed either a template alias parameter (existing\nfunction, delegate, struct type defining static $(D opCall)... ) or\na run-time value argument (delegate, function object... ).\nThe result range models an InputRange\n($(XREF_PACK range,primitives,isInputRange)).\nThe resulting range will call $(D fun()) on every call to $(D front),\nand only when $(D front) is called, regardless of how the range is\niterated.\nIt is advised to compose generate with either\n$(XREF_PACK algorithm,iteration,cache) or $(XREF array,array), or to use it in a\nforeach loop.\nA by-value foreach loop means that the loop value is not $(D ref).\n\nParams:\n    fun = is the $(D isCallable) that gets called on every call to front.\n\nReturns: an $(D inputRange) that returns a new value generated by $(D Fun) on\n    any call to $(D front).\n",
				"parameters": [
					{
						"name": "Fun",
						"kind": "type"
					}
				],
				"constraint": "isCallable!fun",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "generate",
						"line": 2799,
						"type": "()",
						"endline": 2803,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "generate",
				"line": 2799,
				"comment": "\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2829_3073)\n---\nimport std.algorithm : equal, map;\n\nint i = 1;\nauto powersOfTwo = generate!(() => i *= 2)().take(10);\nassert(equal(powersOfTwo, iota(1, 11).map!\"2^^a\"()));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2829_3073)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2839_3074)\n---\nimport std.algorithm : equal;\n\n//Returns a run-time delegate\nauto infiniteIota(T)(T low, T high)\n{\n    T i = high;\n    return (){if (i == high) i = low; return i++;};\n}\n//adapted as a range.\nassert(equal(generate(infiniteIota(1, 4)).take(10), [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2839_3074)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					}
				],
				"constraint": "isCallable!fun",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Cycle",
						"line": 2891,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Cycle",
				"line": 2891,
				"comment": "Repeats the given forward range ad infinitum. If the original range is\ninfinite (fact that would make $(D Cycle) the identity application),\n$(D Cycle) detects that and aliases itself to the range type\nitself. If the original range has random access, $(D Cycle) offers\nrandom access and also offers a constructor taking an initial position\n$(D index). $(D Cycle) works with static arrays in addition to ranges,\nmostly for performance reasons.\n\nNote: The input range must not be empty.\n\nTip: This is a great way to implement simple circular buffers.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3119_3077)\n---\nimport std.algorithm : equal;\nimport std.range : cycle, take;\n\n// Here we create an infinitive cyclic sequence from [1, 2]\n// (i.e. get here [1, 2, 1, 2, 1, 2 and so on]) then\n// take 5 elements of this sequence (so we have [1, 2, 1, 2, 1])\n// and compare them with the expected values for equality.\nassert(cycle([1, 2]).take(5).equal([ 1, 2, 1, 2, 1 ]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3119_3077)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R && !isInfinite!R",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cycle",
						"line": 3111,
						"type": "Cycle!R(R input)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							}
						],
						"endline": 3116,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "cycle",
				"line": 3111,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!R && !isInfinite!R",
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "cycle",
						"line": 3132,
						"type": "Cycle!R(R input, size_t index = 0)",
						"parameters": [
							{
								"name": "input",
								"type": "R"
							},
							{
								"name": "index",
								"type": "size_t",
								"default": "0"
							}
						],
						"endline": 3137,
						"char": 9,
						"kind": "function"
					}
				],
				"name": "cycle",
				"line": 3132,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!R && !isInfinite!R",
				"char": 9,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Zip",
						"line": 3334,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 3349,
								"comment": "   Builds an object. Usually this is invoked indirectly by using the\n   $(LREF zip) function.\n",
								"type": "(R rs, StoppingPolicy s = StoppingPolicy.shortest)",
								"parameters": [
									{
										"name": "rs",
										"type": "R"
									},
									{
										"name": "s",
										"type": "StoppingPolicy",
										"default": "StoppingPolicy.shortest"
									}
								],
								"endline": 3353,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 3420,
								"comment": "   Returns the current iterated element.\n",
								"type": "@property ElementType()",
								"endline": 3425,
								"char": 27,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 3510,
								"comment": "   Advances to the next element in all controlled ranges.\n",
								"type": "void()",
								"endline": 3537,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Zip",
				"line": 3334,
				"comment": "   Iterate several ranges in lockstep. The element type is a proxy tuple\n   that allows accessing the current element in the $(D n)th range by\n   using $(D e[n]).\n   $(D Zip) offers the lowest range facilities of all components, e.g. it\n   offers random access iff all ranges offer random access, and also\n   offers mutation and swapping if all ranges offer it. Due to this, $(D\n   Zip) is extremely powerful because it allows manipulating several\n   ranges in lockstep. For example, the following code sorts two arrays\n   in parallel:\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3676_3089)\n---\nimport std.algorithm : sort;\nint[] a = [ 1, 2, 3 ];\nstring[] b = [ \"a\", \"b\", \"c\" ];\nsort!((c, d) => c[0] > d[0])(zip(a, b));\nassert(a == [ 3, 2, 1 ]);\nassert(b == [ \"c\", \"b\", \"a\" ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3676_3089)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3687_3090)\n---\nint[] a = [ 1, 2, 3 ];\nstring[] b = [ \"a\", \"b\", \"c\" ];\n\nsize_t idx = 0;\nforeach (e; zip(a, b))\n{\n    assert(e[0] == a[idx]);\n    assert(e[1] == b[idx]);\n    ++idx;\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3687_3090)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length && allSatisfy!(isInputRange, Ranges)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "zip",
						"line": 3669,
						"type": "(Ranges ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 3673,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "zip",
				"line": 3669,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length && allSatisfy!(isInputRange, Ranges)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "zip",
						"line": 3702,
						"type": "(StoppingPolicy sp, Ranges ranges)",
						"parameters": [
							{
								"name": "sp",
								"type": "StoppingPolicy"
							},
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 3706,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "zip",
				"line": 3702,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length && allSatisfy!(isInputRange, Ranges)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "shortest",
						"line": 3715,
						"value": "0",
						"comment": "Stop when the shortest range is exhausted\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "longest",
						"line": 3717,
						"value": "1",
						"comment": "Stop when the longest range is exhausted\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "requireSameLength",
						"line": 3719,
						"value": "2",
						"comment": "Require that all ranges are equal\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "StoppingPolicy",
				"line": 3712,
				"comment": "   Dictates how iteration in a $(D Zip) should stop. By default stop at\n   the end of the shortest of all ranges.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "Lockstep",
						"line": 3974,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Lockstep",
				"line": 3974,
				"comment": "   Iterate multiple ranges in lockstep using a $(D foreach) loop.  If only a single\n   range is passed in, the $(D Lockstep) aliases itself away.  If the\n   ranges are of different lengths and $(D s) == $(D StoppingPolicy.shortest)\n   stop after the shortest range is empty.  If the ranges are of different\n   lengths and $(D s) == $(D StoppingPolicy.requireSameLength), throw an\n   exception.  $(D s) may not be $(D StoppingPolicy.longest), and passing this\n   will throw an exception.\n\n   By default $(D StoppingPolicy) is set to $(D StoppingPolicy.shortest).\n\n   BUGS:  If a range does not offer lvalue access, but $(D ref) is used in the\n   $(D foreach) loop, it will be silently accepted but any modifications\n   to the variable will not be propagated to the underlying range.\n\n   // Lockstep also supports iterating with an index variable:\n   Example:\n   -------\n   foreach(index, a, b; lockstep(arr1, arr2)) {\n       writefln(\"Index %s:  a = %s, b = %s\", index, a, b);\n   }\n   -------\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4020_3096)\n---\nauto arr1 = [1,2,3,4,5];\nauto arr2 = [6,7,8,9,10];\n\nforeach(ref a, ref b; lockstep(arr1, arr2))\n{\n    a += b;\n}\n\nassert(arr1 == [7,9,11,13,15]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4020_3096)\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "Ranges.length > 1 && allSatisfy!(isInputRange, Ranges)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lockstep",
						"line": 4004,
						"type": "Lockstep!Ranges(Ranges ranges)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Ranges"
							}
						],
						"endline": 4008,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "lockstep",
				"line": 4004,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isInputRange, Ranges)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "lockstep",
						"line": 4010,
						"type": "Lockstep!Ranges(Ranges ranges, StoppingPolicy s)",
						"parameters": [
							{
								"name": "ranges",
								"type": "Ranges"
							},
							{
								"name": "s",
								"type": "StoppingPolicy"
							}
						],
						"endline": 4017,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "lockstep",
				"line": 4010,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Ranges",
						"kind": "tuple"
					}
				],
				"constraint": "allSatisfy!(isInputRange, Ranges)",
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Recurrence",
						"line": 4151,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Recurrence",
				"line": 4151,
				"comment": "Creates a mathematical sequence given the initial values and a\nrecurrence function that computes the next value from the existing\nvalues. The sequence comes in the form of an infinite forward\nrange. The type $(D Recurrence) itself is seldom used directly; most\noften, recurrences are obtained by calling the function $(D\nrecurrence).\n\nWhen calling $(D recurrence), the function that computes the next\nvalue is specified as a template argument, and the initial values in\nthe recurrence are passed as regular arguments. For example, in a\nFibonacci sequence, there are two initial values (and therefore a\nstate size of 2) because computing the next Fibonacci value needs the\npast two values.\n\nThe signature of this function should be:\n----\nauto fun(R)(R state, size_t n)\n----\nwhere $(D n) will be the index of the current value, and $(D state) will be an\nopaque state vector that can be indexed with array-indexing notation\n$(D state[i]), where valid values of $(D i) range from $(D (n - 1)) to\n$(D (n - State.length)).\n\nIf the function is passed in string form, the state has name $(D \"a\")\nand the zero-based index in the recurrence has name $(D \"n\"). The\ngiven string must return the desired value for $(D a[n]) given $(D a[n\n- 1]), $(D a[n - 2]), $(D a[n - 3]),..., $(D a[n - stateSize]). The\nstate size is dictated by the number of arguments passed to the call\nto $(D recurrence). The $(D Recurrence) struct itself takes care of\nmanaging the recurrence's state and shifting it appropriately.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4188_3100)\n---\nimport std.algorithm : equal;\n\n// The Fibonacci numbers, using function in string form:\n// a[0] = 1, a[1] = 1, and compute a[n+1] = a[n-1] + a[n]\nauto fib = recurrence!(\"a[n-1] + a[n-2]\")(1, 1);\nassert(fib.take(10).equal([1, 1, 2, 3, 5, 8, 13, 21, 34, 55]));\n\n// The factorials, using function in lambda form:\nauto fac = recurrence!((a,n) => a[n-1] * n)(1);\nassert(take(fac, 10).equal([\n    1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880\n]));\n\n// The triangular numbers, using function in explicit form:\nstatic size_t genTriangular(R)(R state, size_t n)\n{\n    return state[n-1] + n;\n}\nauto tri = recurrence!genTriangular(0);\nassert(take(tri, 10).equal([0, 1, 3, 6, 10, 15, 21, 28, 36, 45]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4188_3100)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "StateType",
						"kind": "type"
					},
					{
						"name": "stateSize",
						"deco": "m",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "recurrence",
						"line": 4214,
						"type": "Recurrence!(fun, CommonType!State, State.length)(State initial)",
						"parameters": [
							{
								"name": "initial",
								"type": "State"
							}
						],
						"endline": 4222,
						"char": 1,
						"kind": "function"
					}
				],
				"name": "recurrence",
				"line": 4214,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "State",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Sequence",
						"line": 4257,
						"members": [],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Sequence",
				"line": 4257,
				"comment": "   $(D Sequence) is similar to $(D Recurrence) except that iteration is\n   presented in the so-called $(WEB en.wikipedia.org/wiki/Closed_form,\n   closed form). This means that the $(D n)th element in the series is\n   computable directly from the initial values and $(D n) itself. This\n   implies that the interface offered by $(D Sequence) is a random-access\n   range, as opposed to the regular $(D Recurrence), which only offers\n   forward iteration.\n\n   The state of the sequence is stored as a $(D Tuple) so it can be\n   heterogeneous.\nExample:\nOdd numbers, using function in string form:$(DDOX_UNITTEST_HEADER __unittestL4322_3102)\n---\nauto odds = sequence!(\"a[0] + n * a[1]\")(1, 2);\nassert(odds.front == 1);\nodds.popFront();\nassert(odds.front == 3);\nodds.popFront();\nassert(odds.front == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4322_3102)\nExample:\nTriangular numbers, using function in lambda form:$(DDOX_UNITTEST_HEADER __unittestL4333_3105)\n---\nauto tri = sequence!((a,n) => n*(n+1)/2)();\n\n// Note random access\nassert(tri[0] == 0);\nassert(tri[3] == 6);\nassert(tri[1] == 1);\nassert(tri[4] == 10);\nassert(tri[2] == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4333_3105)\nExample:\nFibonacci numbers, using function in explicit form:$(DDOX_UNITTEST_HEADER __unittestL4346_3106)\n---\nimport std.math : pow, round, sqrt;\nstatic ulong computeFib(S)(S state, size_t n)\n{\n    // Binet's formula\n    return cast(ulong)(round((pow(state[0], n+1) - pow(state[1], n+1)) /\n                             state[2]));\n}\nauto fib = sequence!computeFib(\n    (1.0 + sqrt(5.0)) / 2.0,    // Golden Ratio\n    (1.0 - sqrt(5.0)) / 2.0,    // Conjugate of Golden Ratio\n    sqrt(5.0));\n\n// Note random access with [] operator\nassert(fib[1] == 1);\nassert(fib[4] == 5);\nassert(fib[3] == 3);\nassert(fib[2] == 2);\nassert(fib[9] == 55);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4346_3106)\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "State",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sequence",
						"line": 4314,
						"type": "(State args)",
						"parameters": [
							{
								"name": "args",
								"type": "State"
							}
						],
						"endline": 4319,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "sequence",
				"line": 4314,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "State",
						"kind": "tuple"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4468,
						"type": "(B begin, E end, S step)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							},
							{
								"name": "step",
								"type": "S"
							}
						],
						"endline": 4557,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4468,
				"comment": "   Construct a range of values that span the given starting and stopping\n   values.\n\n   Params:\n   begin = The starting value.\n   end = The value that serves as the stopping criterion. This value is not\n        included in the range.\n   step = The value to add to the current value at each iteration.\n\n   Returns:\n   A range that goes through the numbers $(D begin), $(D begin + step),\n   $(D begin + 2 * step), $(D ...), up to and excluding $(D end).\n\n   The two-argument overloads have $(D step = 1). If $(D begin < end && step <\n   0) or $(D begin > end && step > 0) or $(D begin == end), then an empty range\n   is returned. If $(D step == 0) then $(D begin == end) is an error.\n\n   For built-in types, the range returned is a random access range. For\n   user-defined types that support $(D ++), the range is an input\n   range.\n\n    Example:\n    ---\n    void main()\n    {\n        import std.stdio;\n\n        // The following groups all produce the same output of:\n        // 0 1 2 3 4\n\n        foreach (i; 0..5)\n            writef(\"%s \", i);\n        writeln();\n\n        import std.range : iota;\n        foreach (i; iota(0, 5))\n            writef(\"%s \", i);\n        writeln();\n\n        writefln(\"%(%s %|%)\", iota(0, 5));\n\n        import std.algorithm : map, copy;\n        import std.format;\n        iota(0, 5).map!(i => format(\"%s \", i)).copy(stdout.lockingTextWriter());\n        writeln();\n    }\n    ---\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4724_3112)\n---\nimport std.algorithm : equal;\nimport std.math : approxEqual;\n\nauto r = iota(0, 10, 1);\nassert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][]));\nr = iota(0, 11, 3);\nassert(equal(r, [0, 3, 6, 9][]));\nassert(r[2] == 6);\nauto rf = iota(0.0, 0.5, 0.1);\nassert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4724_3112)\nExample:\nUser-defined types such as $(XREF bigint, BigInt) are also supported, as long\nas they can be incremented with $(D ++) and compared with $(D <) or $(D ==).$(DDOX_UNITTEST_HEADER __unittestL4978_3120)\n---\nimport std.algorithm.comparison : equal;\nimport std.bigint;\n\nauto s = BigInt(1_000_000_000_000);\nauto e = BigInt(1_000_000_000_003);\nauto r = iota(s, e);\nassert(r.equal([\n    BigInt(1_000_000_000_000),\n    BigInt(1_000_000_000_001),\n    BigInt(1_000_000_000_002)\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4978_3120)\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "(isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))) && isIntegral!S",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4560,
						"type": "(B begin, E end)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 4564,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4560,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!(CommonType!(B, E))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4567,
						"type": "(B begin, E end)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 4627,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4567,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4630,
						"type": "(E end)",
						"parameters": [
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 4634,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4630,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4638,
						"type": "(B begin, E end, S step)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							},
							{
								"name": "step",
								"type": "S"
							}
						],
						"endline": 4721,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4638,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isFloatingPoint!(CommonType!(B, E, S))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "iota",
						"line": 4942,
						"type": "(B begin, E end)",
						"parameters": [
							{
								"name": "begin",
								"type": "B"
							},
							{
								"name": "end",
								"type": "E"
							}
						],
						"endline": 4971,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "iota",
				"line": 4942,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "B",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "!isIntegral!(CommonType!(B, E)) && !isFloatingPoint!(CommonType!(B, E)) && !isPointer!(CommonType!(B, E)) && is(typeof((ref B b)\n{\n++b;\n}\n)) && (is(typeof(B.init < E.init)) || is(typeof(B.init == E.init)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "assumeJagged",
						"line": 5033,
						"value": "0",
						"comment": "   When transversed, the elements of a range of ranges are assumed to\n   have different lengths (e.g. a jagged array).\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "enforceNotJagged",
						"line": 5040,
						"value": "1",
						"comment": "       The transversal enforces that the elements of a range of ranges have\n       all the same length (e.g. an array of arrays, all having the same\n       length). Checking is done once upon construction of the transversal\n       range.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "assumeNotJagged",
						"line": 5046,
						"value": "2",
						"comment": "       The transversal assumes, without verifying, that the elements of a\n       range of ranges have all the same length. This option is useful if\n       checking was already done from the outside of the range.\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "TransverseOptions",
				"line": 5027,
				"comment": "   Options for the $(LREF FrontTransversal) and $(LREF Transversal) ranges\n   (below).\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "FrontTransversal",
						"line": 5053,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 5081,
								"comment": "   Construction from an input.\n",
								"type": "(RangeOfRanges input)",
								"parameters": [
									{
										"name": "input",
										"type": "RangeOfRanges"
									}
								],
								"endline": 5098,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 5116,
								"comment": "Ditto\n",
								"type": "@property ref ()",
								"endline": 5120,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 5140,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 5145,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "FrontTransversal",
				"line": 5053,
				"comment": "   Given a range of ranges, iterate transversally through the first\n   elements of each of the enclosed ranges.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5258_3122)\n---\nimport std.algorithm : equal;\nint[][] x = new int[][2];\nx[0] = [1, 2];\nx[1] = [3, 4];\nauto ror = frontTransversal(x);\nassert(equal(ror, [ 1, 3 ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5258_3122)\n",
				"parameters": [
					{
						"name": "Ror",
						"kind": "type"
					},
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "frontTransversal",
						"line": 5249,
						"type": "FrontTransversal!(RangeOfRanges, opt)(RangeOfRanges rr)",
						"parameters": [
							{
								"name": "rr",
								"type": "RangeOfRanges"
							}
						],
						"endline": 5255,
						"char": 39,
						"kind": "function"
					}
				],
				"name": "frontTransversal",
				"line": 5249,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 39,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Transversal",
						"line": 5336,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 5364,
								"comment": "   Construction from an input and an index.\n",
								"type": "(RangeOfRanges input, size_t n)",
								"parameters": [
									{
										"name": "input",
										"type": "RangeOfRanges"
									},
									{
										"name": "n",
										"type": "size_t"
									}
								],
								"endline": 5380,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 5398,
								"comment": "Ditto\n",
								"type": "@property ref ()",
								"endline": 5402,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 5424,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 5429,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Transversal",
				"line": 5336,
				"comment": "   Given a range of ranges, iterate transversally through the the $(D\n   n)th element of each of the enclosed ranges. All elements of the\n   enclosing range must offer random access.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5554_3124)\n---\nimport std.algorithm : equal;\nint[][] x = new int[][2];\nx[0] = [1, 2];\nx[1] = [3, 4];\nauto ror = transversal(x, 1);\nassert(equal(ror, [ 2, 4 ][]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5554_3124)\n",
				"parameters": [
					{
						"name": "Ror",
						"kind": "type"
					},
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transversal",
						"line": 5546,
						"type": "Transversal!(RangeOfRanges, opt)(RangeOfRanges rr, size_t n)",
						"parameters": [
							{
								"name": "rr",
								"type": "RangeOfRanges"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 5551,
						"char": 34,
						"kind": "function"
					}
				],
				"name": "transversal",
				"line": 5546,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "opt",
						"defaultValue": "TransverseOptions.assumeJagged",
						"deco": "E3std5range17TransverseOptions",
						"kind": "value"
					},
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"char": 34,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "transposed",
						"line": 5709,
						"type": "Transposed!RangeOfRanges(RangeOfRanges rr)",
						"parameters": [
							{
								"name": "rr",
								"type": "RangeOfRanges"
							}
						],
						"endline": 5715,
						"char": 26,
						"kind": "function"
					}
				],
				"name": "transposed",
				"line": 5709,
				"comment": "Given a range of ranges, returns a range of ranges where the $(I i)'th subrange\ncontains the $(I i)'th elements of the original subranges.\nExample:\nExample$(DDOX_UNITTEST_HEADER __unittestL5718_3130)\n---\nimport std.algorithm : equal;\nint[][] ror = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\nauto xp = transposed(ror);\nassert(equal!\"a.equal(b)\"(xp, [\n    [1, 4],\n    [2, 5],\n    [3, 6]\n]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5718_3130)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5734_3131)\n---\nint[][] x = new int[][2];\nx[0] = [1, 2];\nx[1] = [3, 4];\nauto tr = transposed(x);\nint[][] witness = [ [ 1, 3 ], [ 2, 4 ] ];\nuint i;\n\nforeach (e; tr)\n{\n    assert(array(e) == witness[i++]);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5734_3131)\n",
				"parameters": [
					{
						"name": "RangeOfRanges",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!RangeOfRanges && isInputRange!(ElementType!RangeOfRanges) && hasAssignableElements!RangeOfRanges",
				"char": 26,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Indexed",
						"line": 5773,
						"members": [
							{
								"endchar": 5,
								"name": "front",
								"line": 5784,
								"comment": "Range primitives\n",
								"type": "@property ref ()",
								"endline": 5788,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 5791,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 5795,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "source",
								"line": 5931,
								"comment": "    Returns the source range.\n",
								"type": "@property Source()",
								"endline": 5934,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "indices",
								"line": 5939,
								"comment": "    Returns the indices range.\n",
								"type": "@property Indices()",
								"endline": 5942,
								"char": 24,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Indexed",
				"line": 5773,
				"comment": "This struct takes two ranges, $(D source) and $(D indices), and creates a view\nof $(D source) as if its elements were reordered according to $(D indices).\n$(D indices) may include only a subset of the elements of $(D source) and\nmay also repeat elements.\n\n$(D Source) must be a random access range.  The returned range will be\nbidirectional or random-access if $(D Indices) is bidirectional or\nrandom-access, respectively.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5976_3133)\n---\nimport std.algorithm : equal;\nauto source = [1, 2, 3, 4, 5];\nauto indices = [4, 3, 1, 2, 0, 4];\nauto ind = indexed(source, indices);\nassert(equal(ind, [5, 4, 2, 3, 1, 5]));\nassert(equal(retro(ind), [5, 1, 3, 2, 4, 5]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5976_3133)\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					},
					{
						"name": "Indices",
						"kind": "type"
					}
				],
				"constraint": "isRandomAccessRange!Source && isInputRange!Indices && is(typeof(Source.init[ElementType!Indices.init]))",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "indexed",
						"line": 5970,
						"type": "Indexed!(Source, Indices)(Source source, Indices indices)",
						"parameters": [
							{
								"name": "source",
								"type": "Source"
							},
							{
								"name": "indices",
								"type": "Indices"
							}
						],
						"endline": 5973,
						"char": 27,
						"kind": "function"
					}
				],
				"name": "indexed",
				"line": 5970,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					},
					{
						"name": "Indices",
						"kind": "type"
					}
				],
				"char": 27,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Chunks",
						"line": 6025,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 6029,
								"comment": "Standard constructor\n",
								"type": "(Source source, size_t chunkSize)",
								"parameters": [
									{
										"name": "source",
										"type": "Source"
									},
									{
										"name": "chunkSize",
										"type": "size_t"
									}
								],
								"endline": 6034,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 6037,
								"comment": "Forward range primitives. Always present.\n",
								"type": "@property ()",
								"endline": 6041,
								"char": 20,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 6044,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 6048,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "save",
								"line": 6061,
								"comment": "Ditto\n",
								"type": "@property typeof(this)()",
								"endline": 6064,
								"char": 28,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Chunks",
				"line": 6025,
				"comment": "This range iterates over fixed-sized chunks of size $(D chunkSize) of a\n$(D source) range. $(D Source) must be a forward range.\n\nIf $(D !isInfinite!Source) and $(D source.walkLength) is not evenly\ndivisible by $(D chunkSize), the back element of this range will contain\nfewer than $(D chunkSize) elements.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6231_3136)\n---\nimport std.algorithm : equal;\nauto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto chunks = chunks(source, 4);\nassert(chunks[0] == [1, 2, 3, 4]);\nassert(chunks[1] == [5, 6, 7, 8]);\nassert(chunks[2] == [9, 10]);\nassert(chunks.back == chunks[2]);\nassert(chunks.front == chunks[0]);\nassert(chunks.length == 3);\nassert(equal(retro(array(chunks)), array(retro(chunks))));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6231_3136)\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Source",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "chunks",
						"line": 6224,
						"type": "Chunks!Source(Source source, size_t chunkSize)",
						"parameters": [
							{
								"name": "source",
								"type": "Source"
							},
							{
								"name": "chunkSize",
								"type": "size_t"
							}
						],
						"endline": 6228,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "chunks",
				"line": 6224,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "Source",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Source",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "only",
						"line": 6517,
						"type": "(auto ref Values values)",
						"parameters": [
							{
								"name": "values",
								"type": "Values",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 6521,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "only",
				"line": 6517,
				"comment": "Assemble $(D values) into a range that carries all its\nelements in-situ.\n\nUseful when a single value or multiple disconnected values\nmust be passed to an algorithm expecting a range, without\nhaving to perform dynamic memory allocation.\n\nAs copying the range means copying all elements, it can be\nsafely returned from functions. For the same reason, copying\nthe returned range may be expensive for a large number of arguments.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6524_3140)\n---\nimport std.algorithm;\nimport std.uni;\n\nassert(equal(only('â¡'), \"â¡\"));\nassert([1, 2, 3, 4].findSplitBefore(only(3))[0] == [1, 2]);\n\nassert(only(\"one\", \"two\", \"three\").joiner(\" \").equal(\"one two three\"));\n\nstring title = \"The D Programming Language\";\nassert(filter!isUpper(title).map!only().join(\".\") == \"T.D.P.L\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6524_3140)\n",
				"parameters": [
					{
						"name": "Values",
						"kind": "tuple"
					}
				],
				"constraint": "!is(CommonType!Values == void) || Values.length == 0",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "enumerate",
						"line": 6740,
						"type": "(Range range, Enumerator start = 0)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "start",
								"type": "Enumerator",
								"default": "0"
							}
						],
						"endline": 6882,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "enumerate",
				"line": 6740,
				"comment": "Iterate over $(D range) with an attached index variable.\n\nEach element is a $(XREF typecons, Tuple) containing the index\nand the element, in that order, where the index member is named $(D index)\nand the element member is named $(D value).\n\nThe index starts at $(D start) and is incremented by one on every iteration.\n\nBidirectionality is propagated only if $(D range) has length.\n\nOverflow:\nIf $(D range) has length, then it is an error to pass a value for $(D start)\nso that $(D start + range.length) is bigger than $(D Enumerator.max), thus it is\nensured that overflow cannot happen.\n\nIf $(D range) does not have length, and $(D popFront) is called when\n$(D front.index == Enumerator.max), the index will overflow and\ncontinue from $(D Enumerator.min).\n\nExamples:\nUseful for using $(D foreach) with an index loop variable:\n----\n    import std.stdio : stdin, stdout;\n    import std.range : enumerate;\n\n    foreach (lineNum, line; stdin.byLine().enumerate(1))\n        stdout.writefln(\"line #%s: %s\", lineNum, line);\n----\nExample:\nCan start enumeration from a negative position:$(DDOX_UNITTEST_HEADER __unittestL6885_3145)\n---\nimport std.array : assocArray;\nimport std.range : enumerate;\n\nbool[int] aa = true.repeat(3).enumerate(-1).assocArray();\nassert(aa[-1]);\nassert(aa[0]);\nassert(aa[1]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6885_3145)\n",
				"parameters": [
					{
						"name": "Enumerator",
						"default": "size_t",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!Enumerator && isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isTwoWayCompatible",
						"line": 7081,
						"init": "is(typeof(()\n{\nT1 foo();\nT2 bar();\nfn(foo(), bar());\nfn(bar(), foo());\n}\n))",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isTwoWayCompatible",
				"line": 7079,
				"comment": "  Returns true if $(D fn) accepts variables of type T1 and T2 in any order.\n  The following code should compile:\n  ---\n  T1 foo();\n  T2 bar();\n\n  fn(foo(), bar());\n  fn(bar(), foo());\n  ---\n",
				"parameters": [
					{
						"name": "fn",
						"kind": "alias"
					},
					{
						"name": "T1",
						"kind": "type"
					},
					{
						"name": "T2",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "linear",
						"line": 7101,
						"value": "0",
						"comment": "       Searches in a linear fashion.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "trot",
						"line": 7112,
						"value": "1",
						"comment": "       Searches with a step that is grows linearly (1, 2, 3,...)\n       leading to a quadratic search schedule (indexes tried are 0, 1,\n       3, 6, 10, 15, 21, 28,...) Once the search overshoots its target,\n       the remaining interval is searched using binary search. The\n       search is completed in $(BIGOH sqrt(n)) time. Use it when you\n       are reasonably confident that the value is around the beginning\n       of the range.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "gallop",
						"line": 7122,
						"value": "2",
						"comment": "       Performs a $(LUCKY galloping search algorithm), i.e. searches\n       with a step that doubles every time, (1, 2, 4, 8, ...)  leading\n       to an exponential search schedule (indexes tried are 0, 1, 3,\n       7, 15, 31, 63,...) Once the search overshoots its target, the\n       remaining interval is searched using binary search. A value is\n       found in $(BIGOH log(n)) time.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "binarySearch",
						"line": 7133,
						"value": "3",
						"comment": "       Searches using a classic interval halving policy. The search\n       starts in the middle of the range, and each search step cuts\n       the range in half. This policy finds a value in $(BIGOH log(n))\n       time but is less cache friendly than $(D gallop) for large\n       ranges. The $(D binarySearch) policy is used as the last step\n       of $(D trot), $(D gallop), $(D trotBackwards), and $(D\n       gallopBackwards) strategies.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "trotBackwards",
						"line": 7139,
						"value": "4",
						"comment": "       Similar to $(D trot) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n",
						"char": 9,
						"kind": "enum member"
					},
					{
						"name": "gallopBackwards",
						"line": 7145,
						"value": "5",
						"comment": "       Similar to $(D gallop) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n",
						"char": 9,
						"kind": "enum member"
					}
				],
				"name": "SearchPolicy",
				"line": 7096,
				"comment": "   Policy used with the searching primitives $(D lowerBound), $(D\n   upperBound), and $(D equalRange) of $(LREF SortedRange) below.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "SortedRange",
						"line": 7158,
						"members": [
							{
								"endchar": 5,
								"name": "empty",
								"line": 7221,
								"comment": "Range primitives.\n",
								"type": "@property bool()",
								"endline": 7224,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "front",
								"line": 7237,
								"comment": "Ditto\n",
								"type": "@property ref ()",
								"endline": 7240,
								"char": 24,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 7243,
								"comment": "Ditto\n",
								"type": "void()",
								"endline": 7246,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "release",
								"line": 7293,
								"comment": "   Releases the controlled range and returns it.\n",
								"type": "()",
								"endline": 7297,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "lowerBound",
										"line": 7404,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7409,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "lowerBound",
								"line": 7404,
								"comment": "   This function uses a search with policy $(D sp) to find the\n   largest left subrange on which $(D pred(x, value)) is $(D true) for\n   all $(D x) (e.g., if $(D pred) is \"less than\", returns the portion of\n   the range with elements strictly smaller than $(D value)). The search\n   schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com/tech/stl/lower_bound.html, lower_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n   auto p = a.lowerBound(4);\n   assert(equal(p, [ 0, 1, 2, 3 ]));\n   ----\n",
								"parameters": [
									{
										"name": "sp",
										"type": "SearchPolicy",
										"defaultValue": "SearchPolicy.binarySearch",
										"kind": "value"
									},
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V) && hasSlicing!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "upperBound",
										"line": 7433,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7451,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "upperBound",
								"line": 7433,
								"comment": "This function searches with policy $(D sp) to find the largest right\nsubrange on which $(D pred(value, x)) is $(D true) for all $(D x)\n(e.g., if $(D pred) is \"less than\", returns the portion of the range\nwith elements strictly greater than $(D value)). The search schedule\nand its complexity are documented in $(LREF SearchPolicy).\n\nFor ranges that do not offer random access, $(D SearchPolicy.linear)\nis the only policy allowed (and it must be specified explicitly lest it exposes\nuser code to unexpected inefficiencies). For random-access searches, all\npolicies are allowed, and $(D SearchPolicy.binarySearch) is the default.\n\nSee_Also: STL's $(WEB sgi.com/tech/stl/lower_bound.html,upper_bound).\n\nExample:\n----\nauto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);\nauto p = a.upperBound(3);\nassert(equal(p, [4, 4, 5, 6]));\n----\n",
								"parameters": [
									{
										"name": "sp",
										"type": "SearchPolicy",
										"defaultValue": "SearchPolicy.binarySearch",
										"kind": "value"
									},
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V)",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "equalRange",
										"line": 7474,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7511,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "equalRange",
								"line": 7474,
								"comment": "   Returns the subrange containing all elements $(D e) for which both $(D\n   pred(e, value)) and $(D pred(value, e)) evaluate to $(D false) (e.g.,\n   if $(D pred) is \"less than\", returns the portion of the range with\n   elements equal to $(D value)). Uses a classic binary search with\n   interval halving until it finds a value that satisfies the condition,\n   then uses $(D SearchPolicy.gallopBackwards) to find the left boundary\n   and $(D SearchPolicy.gallop) to find the right boundary. These\n   policies are justified by the fact that the two boundaries are likely\n   to be near the first found value (i.e., equal ranges are relatively\n   small). Completes the entire search in $(BIGOH log(n)) time. See also\n   STL's $(WEB sgi.com/tech/stl/equal_range.html, equal_range).\n\n   Example:\n   ----\n   auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\n   auto r = equalRange(a, 3);\n   assert(equal(r, [ 3, 3, 3 ]));\n   ----\n",
								"parameters": [
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V) && isRandomAccessRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "trisect",
										"line": 7531,
										"type": "(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7571,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "trisect",
								"line": 7531,
								"comment": "Returns a tuple $(D r) such that $(D r[0]) is the same as the result\nof $(D lowerBound(value)), $(D r[1]) is the same as the result of $(D\nequalRange(value)), and $(D r[2]) is the same as the result of $(D\nupperBound(value)). The call is faster than computing all three\nseparately. Uses a search schedule similar to $(D\nequalRange). Completes the entire search in $(BIGOH log(n)) time.\n\nExample:\n----\nauto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\nauto r = assumeSorted(a).trisect(3);\nassert(equal(r[0], [ 1, 2 ]));\nassert(equal(r[1], [ 3, 3, 3 ]));\nassert(equal(r[2], [ 4, 4, 5, 6 ]));\n----\n",
								"parameters": [
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isTwoWayCompatible!(predFun, ElementType!Range, V) && isRandomAccessRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "contains",
										"line": 7581,
										"type": "bool(V value)",
										"parameters": [
											{
												"name": "value",
												"type": "V"
											}
										],
										"endline": 7606,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "contains",
								"line": 7581,
								"comment": "Returns $(D true) if and only if $(D value) can be found in $(D\nrange), which is assumed to be sorted. Performs $(BIGOH log(r.length))\nevaluations of $(D pred). See also STL's $(WEB\nsgi.com/tech/stl/binary_search.html, binary_search).\n",
								"parameters": [
									{
										"name": "V",
										"kind": "type"
									}
								],
								"constraint": "isRandomAccessRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "groupBy",
										"line": 7613,
										"type": "()",
										"endline": 7617,
										"char": 10,
										"kind": "function",
										"storageClass": [
											"auto"
										]
									}
								],
								"name": "groupBy",
								"line": 7613,
								"comment": "Returns a range of subranges of elements that are equivalent according to the\nsorting relation.\n",
								"parameters": [],
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "SortedRange",
				"line": 7158,
				"comment": "Represents a sorted range. In addition to the regular range\nprimitives, supports additional operations that take advantage of the\nordering, such as merge and binary search. To obtain a $(D\nSortedRange) from an unsorted range $(D r), use\n$(XREF_PACK algorithm,sorting,sort) which sorts $(D r) in place and returns the\ncorresponding $(D SortedRange). To construct a $(D SortedRange) from a range\n$(D r) that is known to be already sorted, use $(LREF assumeSorted) described\nbelow.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL7621_3151)\n---\nimport std.algorithm : sort;\nauto a = [ 1, 2, 3, 42, 52, 64 ];\nauto r = assumeSorted(a);\nassert(r.contains(3));\nassert(!r.contains(32));\nauto r1 = sort!\"a > b\"(a);\nassert(r1.contains(3));\nassert(!r1.contains(32));\nassert(r1.release() == [ 64, 52, 42, 3, 2, 1 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7621_3151)\nExample:\n$(D SortedRange) could accept ranges weaker than random-access, but it\nis unable to provide interesting functionality for them. Therefore,\n$(D SortedRange) is currently restricted to random-access ranges.\n\nNo copy of the original range is ever made. If the underlying range is\nchanged concurrently with its corresponding $(D SortedRange) in ways\nthat break its sortedness, $(D SortedRange) will work erratically.$(DDOX_UNITTEST_HEADER __unittestL7643_3152)\n---\nimport std.algorithm : swap;\nauto a = [ 1, 2, 3, 42, 52, 64 ];\nauto r = assumeSorted(a);\nassert(r.contains(42));\nswap(a[3], a[5]);         // illegal to break sortedness of original range\nassert(!r.contains(42));  // passes although it shouldn't\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL7643_3152)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assumeSorted",
						"line": 7786,
						"type": "(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 7790,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assumeSorted",
				"line": 7786,
				"comment": "Assumes $(D r) is sorted by predicate $(D pred) and returns the\ncorresponding $(D SortedRange!(pred, R)) having $(D r) as support. To\nkeep the checking costs low, the cost is $(BIGOH 1) in release mode\n(no checks for sortedness are performed). In debug mode, a few random\nelements of $(D r) are checked for sortedness. The size of the sample\nis proportional $(BIGOH log(r.length)). That way, checking has no\neffect on the complexity of subsequent operations specific to sorted\nranges (such as binary search). The probability of an arbitrary\nunsorted range failing the test is very high (however, an\nalmost-sorted range is likely to pass it). To check for sortedness at\ncost $(BIGOH n), use $(XREF_PACK algorithm,sorting,isSorted).\n",
				"parameters": [
					{
						"name": "pred",
						"defaultAlias": "\"a < b\"",
						"kind": "alias"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!(Unqual!R)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RefRange",
						"line": 7886,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 7892,
								"comment": "\n",
								"type": "pure nothrow @safe (R* range)",
								"parameters": [
									{
										"name": "range",
										"type": "R*"
									}
								],
								"endline": 7895,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 7907,
								"comment": "        This does not assign the pointer of $(D rhs) to this $(D RefRange).\n        Rather it assigns the range pointed to by $(D rhs) to the range pointed\n        to by this $(D RefRange). This is because $(I any) operation on a\n        $(D RefRange) is the same is if it occurred to the original range. The\n        one exception is when a $(D RefRange) is assigned $(D null) either\n        directly or because $(D rhs) is $(D null). In that case, $(D RefRange)\n        no longer refers to the original range but is $(D null).\n",
								"type": "(RefRange rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "RefRange"
									}
								],
								"endline": 7915,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "opAssign",
								"line": 7918,
								"comment": "\n",
								"type": "(typeof(null) rhs)",
								"parameters": [
									{
										"name": "rhs",
										"type": "typeof(null)"
									}
								],
								"endline": 7921,
								"char": 10,
								"kind": "function",
								"storageClass": [
									"auto"
								]
							},
							{
								"endchar": 5,
								"name": "ptr",
								"line": 7927,
								"comment": "        A pointer to the wrapped range.\n",
								"type": "inout pure nothrow @property @safe inout(R*)()",
								"endline": 7930,
								"char": 25,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "popFront",
								"line": 7983,
								"comment": "\n",
								"type": "void()",
								"endline": 7986,
								"char": 10,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RefRange",
				"line": 7886,
				"comment": "    Wrapper which effectively makes it possible to pass a range by reference.\n    Both the original range and the RefRange will always have the exact same\n    elements. Any operation done on one will affect the other. So, for instance,\n    if it's passed to a function which would implicitly copy the original range\n    if it were passed to it, the original range is $(I not) copied but is\n    consumed as if it were a reference type.\n\n    Note that $(D save) works as normal and operates on a new range, so if\n    $(D save) is ever called on the RefRange, then no operations on the saved\n    range will affect the original.\n\nExample:\nBasic Example$(DDOX_UNITTEST_HEADER __unittestL8217_3169)\n---\nimport std.algorithm;\nubyte[] buffer = [1, 9, 45, 12, 22];\nauto found1 = find(buffer, 45);\nassert(found1 == [45, 12, 22]);\nassert(buffer == [1, 9, 45, 12, 22]);\n\nauto wrapped1 = refRange(&buffer);\nauto found2 = find(wrapped1, 45);\nassert(*found2.ptr == [45, 12, 22]);\nassert(buffer == [45, 12, 22]);\n\nauto found3 = find(wrapped1.save, 22);\nassert(*found3.ptr == [22]);\nassert(buffer == [45, 12, 22]);\n\nstring str = \"hello world\";\nauto wrappedStr = refRange(&str);\nassert(str.front == 'h');\nstr.popFrontN(5);\nassert(str == \" world\");\nassert(wrappedStr.front == ' ');\nassert(*wrappedStr.ptr == \" world\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8217_3169)\nExample:\nopAssign Example.$(DDOX_UNITTEST_HEADER __unittestL8244_3170)\n---\nubyte[] buffer1 = [1, 2, 3, 4, 5];\nubyte[] buffer2 = [6, 7, 8, 9, 10];\nauto wrapped1 = refRange(&buffer1);\nauto wrapped2 = refRange(&buffer2);\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\nassert(buffer1 != buffer2);\n\nwrapped1 = wrapped2;\n\n//Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//But buffer1 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [6, 7, 8, 9, 10]);\n\nbuffer2 = [11, 12, 13, 14, 15];\n\n//Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//But buffer2 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n\nwrapped2 = null;\n\n//The pointer changed for wrapped2 but not wrapped1.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is null);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//buffer2 is not affected by the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8244_3170)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "refRange",
						"line": 8591,
						"type": "(R* range)",
						"parameters": [
							{
								"name": "range",
								"type": "R*"
							}
						],
						"endline": 8595,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "refRange",
				"line": 8591,
				"comment": "    Helper function for constructing a $(LREF RefRange).\n\n    If the given range is a class type (and thus is already a reference type),\n    then the original range is returned rather than a $(LREF RefRange).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8606_3180)\n---\nimport std.algorithm : map, joiner, group, until;\n// fix for std.algorithm\nauto r = map!(x => 0)([1]);\nchain(r, r);\nzip(r, r);\nroundRobin(r, r);\n\nstruct NRAR {\n    typeof(r) input;\n    @property empty() { return input.empty; }\n    @property front() { return input.front; }\n    void popFront()   { input.popFront(); }\n    @property save()  { return NRAR(input.save); }\n}\nauto n1 = NRAR(r);\ncycle(n1);  // non random access range version\n\nassumeSorted(r);\n\n// fix for std.range\njoiner([r], [9]);\n\nstruct NRAR2 {\n    NRAR input;\n    @property empty() { return true; }\n    @property front() { return input; }\n    void popFront() { }\n    @property save()  { return NRAR2(input.save); }\n}\nauto n2 = NRAR2(n1);\njoiner(n2);\n\ngroup(r);\n\nuntil(r, 7);\nstatic void foo(R)(R r) { until!(x => x > 7)(r); }\nfoo(r);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8606_3180)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && !is(R == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "refRange",
						"line": 8598,
						"type": "(R* range)",
						"parameters": [
							{
								"name": "range",
								"type": "R*"
							}
						],
						"endline": 8602,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "refRange",
				"line": 8598,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R && is(R == class)",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "NullSink",
				"line": 8651,
				"comment": " An OutputRange that discards the data it receives.\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "tee",
						"line": 8698,
						"type": "(R1 inputRange, R2 outputRange)",
						"parameters": [
							{
								"name": "inputRange",
								"type": "R1"
							},
							{
								"name": "outputRange",
								"type": "R2"
							}
						],
						"endline": 8756,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "tee",
				"line": 8698,
				"comment": "\n  Implements a \"tee\" style pipe, wrapping an input range so that elements of the\n  range can be passed to a provided function or $(LREF OutputRange) as they are\n  iterated over. This is useful for printing out intermediate values in a long\n  chain of range code, performing some operation with side-effects on each call\n  to $(D front) or $(D popFront), or diverting the elements of a range into an\n  auxiliary $(LREF OutputRange).\n\n  It is important to note that as the resultant range is evaluated lazily,\n  in the case of the version of $(D tee) that takes a function, the function\n  will not actually be executed until the range is \"walked\" using functions\n  that evaluate ranges, such as $(XREF array,array) or\n  $(XREF_PACK algorithm,iteration,reduce).\n\n  Params:\n  pipeOnPop = If `Yes.pipeOnPop`, simply iterating the range without ever\n  calling `front` is enough to have `tee` mirror elements to `outputRange` (or,\n  respectively, `fun`). If `No.pipeOnPop`, only elements for which `front` does\n  get called will be also sent to `outputRange`/`fun`.\n  inputRange = The input range beeing passed through.\n  outputRange = This range will receive elements of `inputRange` progressively\n  as iteration proceeds.\n  fun = This function will be called with elements of `inputRange`\n  progressively as iteration proceeds.\n\n  Returns:\n  An input range that offers the elements of `inputRange`. Regardless of\n  whether `inputRange` is a more powerful range (forward, bidirectional etc),\n  the result is always an input range. Reading this causes `inputRange` to be\n  iterated and returns its elements in turn. In addition, the same elements\n  will be passed to `outputRange` or `fun` as well.\n\n  See_Also: $(XREF_PACK algorithm,iteration,each)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL8785_3188)\n---\nimport std.algorithm : equal, filter, map;\n\n// Sum values while copying\nint[] values = [1, 4, 9, 16, 25];\nint sum = 0;\nauto newValues = values.tee!(a => sum += a).array;\nassert(equal(newValues, values));\nassert(sum == 1 + 4 + 9 + 16 + 25);\n\n// Count values that pass the first filter\nint count = 0;\nauto newValues4 = values.filter!(a => a < 10)\n                        .tee!(a => count++)\n                        .map!(a => a + 1)\n                        .filter!(a => a < 10);\n\n//Fine, equal also evaluates any lazy ranges passed to it.\n//count is not 3 until equal evaluates newValues3\nassert(equal(newValues4, [2, 5]));\nassert(count == 3);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL8785_3188)\n",
				"parameters": [
					{
						"name": "pipeOnPop",
						"defaultValue": "Yes.pipeOnPop",
						"deco": "E3std8typecons34__T4FlagVAyaa9_706970654f6e506f70Z4Flag",
						"kind": "value"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!R1 && isOutputRange!(R2, ElementType!R1)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "tee",
						"line": 8759,
						"type": "(R1 inputRange)",
						"parameters": [
							{
								"name": "inputRange",
								"type": "R1"
							}
						],
						"endline": 8782,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "tee",
				"line": 8759,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "fun",
						"kind": "alias"
					},
					{
						"name": "pipeOnPop",
						"defaultValue": "Yes.pipeOnPop",
						"deco": "E3std8typecons34__T4FlagVAyaa9_706970654f6e506f70Z4Flag",
						"kind": "value"
					},
					{
						"name": "R1",
						"kind": "type"
					}
				],
				"constraint": "is(typeof(fun) == void) || isSomeFunction!fun",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "This module defines the notion of a range. Ranges generalize the concept of\narrays, lists, or anything that involves sequential access. This abstraction\nenables the same set of algorithms (see $(LINK2 std_algorithm.html,\nstd.algorithm)) to be used with a vast variety of different concrete types. For\nexample, a linear search algorithm such as $(LINK2 std_algorithm.html#find,\nstd.algorithm.find) works not just for arrays, but for linked-lists, input\nfiles, incoming network data, etc.\n\nFor more detailed information about the conceptual aspect of ranges and the\nmotivation behind them, see Andrei Alexandrescu's article\n$(LINK2 http://www.informit.com/articles/printerfriendly.aspx?p=1407357&rll=1,\n$(I On Iteration)).\n\nSubmodules:\n\nThis module has two submodules:\n\nThe $(LINK2 std_range_primitives.html, $(D std._range.primitives)) submodule\nprovides basic _range functionality. It defines several templates for testing\nwhether a given object is a _range, what kind of _range it is, and provides\nsome common _range operations.\n\nThe $(LINK2 std_range_interfaces.html, $(D std._range.interfaces)) submodule\nprovides object-based interfaces for working with ranges via runtime\npolymorphism.\n\nThe remainder of this module provides a rich set of _range creation and\ncomposition templates that let you construct new ranges out of existing ranges:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF chain)))\n        $(TD Concatenates several ranges into a single _range.\n    ))\n    $(TR $(TD $(D $(LREF choose)))\n        $(TD choose one of several ranges.\n    ))\n    $(TR $(TD $(D $(LREF chunks)))\n        $(TD Creates a _range that returns fixed-size chunks of the original\n        _range.\n    ))\n    $(TR $(TD $(D $(LREF cycle)))\n        $(TD Creates an infinite _range that repeats the given forward _range\n        indefinitely. Good for implementing circular buffers.\n    ))\n    $(TR $(TD $(D $(LREF drop)))\n        $(TD Creates the _range that results from discarding the first $(I n)\n        elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF dropExactly)))\n        $(TD Creates the _range that results from discarding exactly $(I n)\n        of the first elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF dropOne)))\n        $(TD Creates the _range that results from discarding\n        the first elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF enumerate)))\n        $(TD Iterates a _range with an attached index variable.\n    ))\n    $(TR $(TD $(D $(LREF frontTransversal)))\n        $(TD Creates a _range that iterates over the first elements of the\n        given ranges.\n    ))\n    $(TR $(TD $(D $(LREF indexed)))\n        $(TD Creates a _range that offers a view of a given _range as though\n        its elements were reordered according to a given _range of indices.\n    ))\n    $(TR $(TD $(D $(LREF iota)))\n        $(TD Creates a _range consisting of numbers between a starting point\n        and ending point, spaced apart by a given interval.\n    ))\n    $(TR $(TD $(D $(LREF lockstep)))\n        $(TD Iterates $(I n) _ranges in lockstep, for use in a $(D foreach)\n        loop. Similar to $(D zip), except that $(D lockstep) is designed\n        especially for $(D foreach) loops.\n    ))\n    $(TR $(TD $(D $(LREF NullSink)))\n        $(TD An output _range that discards the data it receives.\n    ))\n    $(TR $(TD $(D $(LREF only)))\n        $(TD Creates a _range that iterates over the given arguments.\n    ))\n    $(TR $(TD $(D $(LREF radial)))\n        $(TD Given a random-access _range and a starting point, creates a\n        _range that alternately returns the next left and next right element to\n        the starting point.\n    ))\n    $(TR $(TD $(D $(LREF recurrence)))\n        $(TD Creates a forward _range whose values are defined by a\n        mathematical recurrence relation.\n    ))\n    $(TR $(TD $(D $(LREF repeat)))\n        $(TD Creates a _range that consists of a single element repeated $(I n)\n        times, or an infinite _range repeating that element indefinitely.\n    ))\n    $(TR $(TD $(D $(LREF retro)))\n        $(TD Iterates a bidirectional _range backwards.\n    ))\n    $(TR $(TD $(D $(LREF roundRobin)))\n        $(TD Given $(I n) ranges, creates a new _range that return the $(I n)\n        first elements of each _range, in turn, then the second element of each\n        _range, and so on, in a round-robin fashion.\n    ))\n    $(TR $(TD $(D $(LREF sequence)))\n        $(TD Similar to $(D recurrence), except that a random-access _range is\n        created.\n    ))\n    $(TR $(TD $(D $(LREF stride)))\n        $(TD Iterates a _range with stride $(I n).\n    ))\n    $(TR $(TD $(D $(LREF take)))\n        $(TD Creates a sub-_range consisting of only up to the first $(I n)\n        elements of the given _range.\n    ))\n    $(TR $(TD $(D $(LREF takeExactly)))\n        $(TD Like $(D take), but assumes the given _range actually has $(I n)\n        elements, and therefore also defines the $(D length) property.\n    ))\n    $(TR $(TD $(D $(LREF takeNone)))\n        $(TD Creates a random-access _range consisting of zero elements of the\n        given _range.\n    ))\n    $(TR $(TD $(D $(LREF takeOne)))\n        $(TD Creates a random-access _range consisting of exactly the first\n        element of the given _range.\n    ))\n    $(TR $(TD $(D $(LREF tee)))\n        $(TD Creates a _range that wraps a given _range, forwarding along\n        its elements while also calling a provided function with each element.\n    ))\n    $(TR $(TD $(D $(LREF transposed)))\n        $(TD Transposes a _range of ranges.\n    ))\n    $(TR $(TD $(D $(LREF transversal)))\n        $(TD Creates a _range that iterates over the $(I n)'th elements of the\n        given random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF zip)))\n        $(TD Given $(I n) _ranges, creates a _range that successively returns a\n        tuple of all the first elements, a tuple of all the second elements,\n        etc.\n    ))\n)\n\nRanges whose elements are sorted afford better efficiency with certain\noperations. For this, the $(D $(LREF assumeSorted)) function can be used to\nconstruct a $(D $(LREF SortedRange)) from a pre-sorted _range. The $(LINK2\nstd_algorithm.html#sort, $(D std.algorithm.sort)) function also conveniently\nreturns a $(D SortedRange). $(D SortedRange) objects provide some additional\n_range operations that take advantage of the fact that the _range is sorted.\n\nSource: $(PHOBOSSRC std/_range/_package.d)\n\nMacros:\n\nWIKI = Phobos/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net/leonardo/so/, Leonardo Maffi).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/range/primitives.d",
		"name": "std.range.primitives",
		"members": [
			{
				"members": [
					{
						"name": "isInputRange",
						"line": 151,
						"deco": "b",
						"init": "is(typeof((inout int = 0)\n{\nR r = R.init;\nif (r.empty)\n{\n}\nr.popFront();\nauto h = r.front;\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isInputRange",
				"line": 149,
				"comment": "Returns $(D true) if $(D R) is an input range. An input range must\ndefine the primitives $(D empty), $(D popFront), and $(D front). The\nfollowing code should compile for any input range.\n\n----\nR r;              // can define a range object\nif (r.empty) {}   // can test for empty\nr.popFront();     // can invoke popFront()\nauto h = r.front; // can get the front of the range of non-void type\n----\n\nThe semantics of an input range (not checkable during compilation) are\nassumed to be the following ($(D r) is an object of type $(D R)):\n\n$(UL $(LI $(D r.empty) returns $(D false) iff there is more data\navailable in the range.)  $(LI $(D r.front) returns the current\nelement in the range. It may return by value or by reference. Calling\n$(D r.front) is allowed only if calling $(D r.empty) has, or would\nhave, returned $(D false).) $(LI $(D r.popFront) advances to the next\nelement in the range. Calling $(D r.popFront) is allowed only if\ncalling $(D r.empty) has, or would have, returned $(D false).))\n\nParams:\n    R = type to be tested\n\nReturns:\n    true if R is an InputRange, false if not\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL162_3208)\n---\nstruct A {}\nstruct B\n{\n    void popFront();\n    @property bool empty();\n    @property int front();\n}\nstatic assert(!isInputRange!A);\nstatic assert( isInputRange!B);\nstatic assert( isInputRange!(int[]));\nstatic assert( isInputRange!(char[]));\nstatic assert(!isInputRange!(char[4]));\nstatic assert( isInputRange!(inout(int)[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL162_3208)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "put",
						"line": 284,
						"type": "void(ref R r, E e)",
						"parameters": [
							{
								"name": "r",
								"type": "R",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "e",
								"type": "E"
							}
						],
						"endline": 337,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "put",
				"line": 284,
				"comment": "Outputs $(D e) to $(D r). The exact effect is dependent upon the two\ntypes. Several cases are accepted, as described below. The code snippets\nare attempted in order, and the first to compile \"wins\" and gets\nevaluated.\n\nIn this table \"doPut\" is a method that places $(D e) into $(D r), using the\ncorrect primitive: $(D r.put(e)) if $(D R) defines $(D put), $(D r.front = e)\nif $(D r) is an input range (followed by $(D r.popFront())), or $(D r(e))\notherwise.\n\n$(BOOKTABLE ,\n    $(TR\n        $(TH Code Snippet)\n        $(TH Scenario)\n    )\n    $(TR\n        $(TD $(D r.doPut(e);))\n        $(TD $(D R) specifically accepts an $(D E).)\n    )\n    $(TR\n        $(TD $(D r.doPut([ e ]);))\n        $(TD $(D R) specifically accepts an $(D E[]).)\n    )\n    $(TR\n        $(TD $(D r.putChar(e);))\n        $(TD $(D R) accepts some form of string or character. put will\n            transcode the character $(D e) accordingly.)\n    )\n    $(TR\n        $(TD $(D for (; !e.empty; e.popFront()) put(r, e.front);))\n        $(TD Copying range $(D E) into $(D R).)\n    )\n)\n\nTip: $(D put) should $(I not) be used \"UFCS-style\", e.g. $(D r.put(e)).\nDoing this may call $(D R.put) directly, by-passing any transformation\nfeature provided by $(D Range.put). $(D put(r, e)) is prefered.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL686_3229)\n---\nint[] r = new int[](4);\nstatic assert(isInputRange!(int[]));\nstatic assert( isNativeOutputRange!(int[], int));\nstatic assert(!isNativeOutputRange!(int[], int[]));\nstatic assert( isOutputRange!(int[], int[]));\n\nif (!r.empty)\n    put(r, 1); //guaranteed to succeed\nif (!r.empty)\n    put(r, [1, 2]); //May actually error out.\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL686_3229)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isOutputRange",
						"line": 706,
						"deco": "b",
						"init": "is(typeof((inout int = 0)\n{\nR r = R.init;\nE e = E.init;\nput(r, e);\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isOutputRange",
				"line": 704,
				"comment": "Returns $(D true) if $(D R) is an output range for elements of type\n$(D E). An output range is defined functionally as a range that\nsupports the operation $(D put(r, e)) as defined above.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL716_3230)\n---\nvoid myprint(in char[] s) { }\nstatic assert(isOutputRange!(typeof(&myprint), char));\n\nstatic assert(!isOutputRange!(char[], char));\nstatic assert( isOutputRange!(dchar[], wchar));\nstatic assert( isOutputRange!(dchar[], dchar));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL716_3230)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isForwardRange",
						"line": 777,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nR r1 = R.init;\nauto s1 = r1.save;\nstatic assert(is(typeof(s1) == R));\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isForwardRange",
				"line": 775,
				"comment": "Returns $(D true) if $(D R) is a forward range. A forward range is an\ninput range $(D r) that can save \"checkpoints\" by saving $(D r.save)\nto another value of type $(D R). Notable examples of input ranges that\nare $(I not) forward ranges are file/socket ranges; copying such a\nrange will not save the position in the stream, and they most likely\nreuse an internal buffer as the entire stream does not sit in\nmemory. Subsequently, advancing either the original or the copy will\nadvance the stream, so the copies are not independent.\n\nThe following code should compile for any forward range.\n\n----\nstatic assert(isInputRange!R);\nR r1;\nauto s1 = r1.save;\nstatic assert (is(typeof(s1) == R));\n----\n\nSaving a range is not duplicating it; in the example above, $(D r1)\nand $(D r2) still refer to the same underlying data. They just\nnavigate that data independently.\n\nThe semantics of a forward range (not checkable during compilation)\nare the same as for an input range, with the additional requirement\nthat backtracking must be possible by saving a copy of the range\nobject with $(D save) and using it later.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL790_3232)\n---\nstatic assert(!isForwardRange!(int));\nstatic assert( isForwardRange!(int[]));\nstatic assert( isForwardRange!(inout(int)[]));\n\n// BUG 14544\nstruct R14544\n{\n    int front() { return 0;}\n    void popFront() {}\n    bool empty() { return false; }\n    R14544 save() {return this;}\n}\n\nstatic assert( isForwardRange!R14544 );\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL790_3232)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBidirectionalRange",
						"line": 824,
						"deco": "b",
						"init": "isForwardRange!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nr.popBack();\nauto t = r.back;\nauto w = r.front;\nstatic assert(is(typeof(t) == typeof(w)));\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBidirectionalRange",
				"line": 822,
				"comment": "Returns $(D true) if $(D R) is a bidirectional range. A bidirectional\nrange is a forward range that also offers the primitives $(D back) and\n$(D popBack). The following code should compile for any bidirectional\nrange.\n\nThe semantics of a bidirectional range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)):\n\n$(UL $(LI $(D r.back) returns (possibly a reference to) the last\nelement in the range. Calling $(D r.back) is allowed only if calling\n$(D r.empty) has, or would have, returned $(D false).))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL836_3233)\n---\nalias R = int[];\nR r = [0,1];\nstatic assert(isForwardRange!R);           // is forward range\nr.popBack();                               // can invoke popBack\nauto t = r.back;                           // can get the back of the range\nauto w = r.front;\nstatic assert(is(typeof(t) == typeof(w))); // same type for front and back\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL836_3233)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isRandomAccessRange",
						"line": 894,
						"deco": "b",
						"init": "is(typeof((inout int = 0)\n{\nstatic assert(isBidirectionalRange!R || isForwardRange!R && isInfinite!R);\nR r = R.init;\nauto e = r[1];\nauto f = r.front;\nstatic assert(is(typeof(e) == typeof(f)));\nstatic assert(!isNarrowString!R);\nstatic assert(hasLength!R || isInfinite!R);\nstatic if (is(typeof(r[__dollar])))\n{\nstatic assert(is(typeof(f) == typeof(r[__dollar])));\nstatic if (!isInfinite!R)\n{\nstatic assert(is(typeof(f) == typeof(r[__dollar - 1])));\n}\n\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isRandomAccessRange",
				"line": 892,
				"comment": "Returns $(D true) if $(D R) is a random-access range. A random-access\nrange is a bidirectional range that also offers the primitive $(D\nopIndex), OR an infinite forward range that offers $(D opIndex). In\neither case, the range must either offer $(D length) or be\ninfinite. The following code should compile for any random-access\nrange.\n\nThe semantics of a random-access range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)): $(UL $(LI $(D r.opIndex(n)) returns a reference to the\n$(D n)th element in the range.))\n\nAlthough $(D char[]) and $(D wchar[]) (as well as their qualified\nversions including $(D string) and $(D wstring)) are arrays, $(D\nisRandomAccessRange) yields $(D false) for them because they use\nvariable-length encodings (UTF-8 and UTF-16 respectively). These types\nare bidirectional ranges only.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL917_3235)\n---\nalias R = int[];\n\n// range is finite and bidirectional or infinite and forward.\nstatic assert(isBidirectionalRange!R ||\n              isForwardRange!R && isInfinite!R);\n\nR r = [0,1];\nauto e = r[1]; // can index\nauto f = r.front;\nstatic assert(is(typeof(e) == typeof(f))); // same type for indexed and front\nstatic assert(!isNarrowString!R); // narrow strings cannot be indexed as ranges\nstatic assert(hasLength!R || isInfinite!R); // must have length or be infinite\n\n// $ must work as it does with arrays if opIndex works with $\nstatic if(is(typeof(r[$])))\n{\n    static assert(is(typeof(f) == typeof(r[$])));\n\n    // $ - 1 doesn't make sense with infinite ranges but needs to work\n    // with finite ones.\n    static if(!isInfinite!R)\n        static assert(is(typeof(f) == typeof(r[$ - 1])));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL917_3235)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasMobileElements",
						"line": 1046,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nalias E = ElementType!R;\nR r = R.init;\nstatic assert(is(typeof(moveFront(r)) == E));\nstatic if (isBidirectionalRange!R)\n{\nstatic assert(is(typeof(moveBack(r)) == E));\n}\n\nstatic if (isRandomAccessRange!R)\n{\nstatic assert(is(typeof(moveAt(r, 0)) == E));\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasMobileElements",
				"line": 1044,
				"comment": "Returns $(D true) iff $(D R) is an input range that supports the\n$(D moveFront) primitive, as well as $(D moveBack) and $(D moveAt) if it's a\nbidirectional or random access range. These may be explicitly implemented, or\nmay work via the default behavior of the module level functions $(D moveFront)\nand friends. The following code should compile for any range\nwith mobile elements.\n\n----\nalias E = ElementType!R;\nR r;\nstatic assert(isInputRange!R);\nstatic assert(is(typeof(moveFront(r)) == E));\nstatic if (isBidirectionalRange!R)\n    static assert(is(typeof(moveBack(r)) == E));\nstatic if (isRandomAccessRange!R)\n    static assert(is(typeof(moveAt(r, 0)) == E));\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1060_3238)\n---\nimport std.algorithm : map;\nimport std.range : iota, repeat;\n\nstatic struct HasPostblit\n{\n    this(this) {}\n}\n\nauto nonMobile = map!\"a\"(repeat(HasPostblit.init));\nstatic assert(!hasMobileElements!(typeof(nonMobile)));\nstatic assert( hasMobileElements!(int[]));\nstatic assert( hasMobileElements!(inout(int)[]));\nstatic assert( hasMobileElements!(typeof(iota(1000))));\n\nstatic assert( hasMobileElements!( string));\nstatic assert( hasMobileElements!(dstring));\nstatic assert( hasMobileElements!( char[]));\nstatic assert( hasMobileElements!(dchar[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1060_3238)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ElementType",
				"line": 1090,
				"comment": "The element type of $(D R). $(D R) does not have to be a range. The\nelement type is determined as the type yielded by $(D r.front) for an\nobject $(D r) of type $(D R). For example, $(D ElementType!(T[])) is\n$(D T) if $(D T[]) isn't a narrow string; if it is, the element type is\n$(D dchar). If $(D R) doesn't have $(D front), $(D ElementType!R) is\n$(D void).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1099_3239)\n---\nimport std.range : iota;\n\n// Standard arrays: returns the type of the elements of the array\nstatic assert(is(ElementType!(int[]) == int));\n\n// Accessing .front retrieves the decoded dchar\nstatic assert(is(ElementType!(char[])  == dchar)); // rvalue\nstatic assert(is(ElementType!(dchar[]) == dchar)); // lvalue\n\n// Ditto\nstatic assert(is(ElementType!(string) == dchar));\nstatic assert(is(ElementType!(dstring) == immutable(dchar)));\n\n// For ranges it gets the type of .front.\nauto range = iota(0, 10);\nstatic assert(is(ElementType!(typeof(range)) == int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1099_3239)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ElementEncodingType",
				"line": 1176,
				"comment": "The encoding element type of $(D R). For narrow strings ($(D char[]),\n$(D wchar[]) and their qualified variants including $(D string) and\n$(D wstring)), $(D ElementEncodingType) is the character type of the\nstring. For all other types, $(D ElementEncodingType) is the same as\n$(D ElementType).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1185_3245)\n---\nimport std.range : iota;\n// internally the range stores the encoded type\nstatic assert(is(ElementEncodingType!(char[])  == char));\n\nstatic assert(is(ElementEncodingType!(wstring) == immutable(wchar)));\n\nstatic assert(is(ElementEncodingType!(byte[]) == byte));\n\nauto range = iota(0, 10);\nstatic assert(is(ElementEncodingType!(typeof(range)) == int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1185_3245)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasSwappableElements",
						"line": 1250,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nswap(r.front, r.front);\nstatic if (isBidirectionalRange!R)\n{\nswap(r.back, r.front);\n}\n\nstatic if (isRandomAccessRange!R)\n{\nswap(r[0], r.front);\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasSwappableElements",
				"line": 1247,
				"comment": "Returns $(D true) if $(D R) is an input range and has swappable\nelements. The following code should compile for any range\nwith swappable elements.\n\n----\nR r;\nstatic assert(isInputRange!R);\nswap(r.front, r.front);\nstatic if (isBidirectionalRange!R) swap(r.back, r.front);\nstatic if (isRandomAccessRange!R) swap(r[], r.front);\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1261_3249)\n---\nstatic assert(!hasSwappableElements!(const int[]));\nstatic assert(!hasSwappableElements!(const(int)[]));\nstatic assert(!hasSwappableElements!(inout(int)[]));\nstatic assert( hasSwappableElements!(int[]));\n\nstatic assert(!hasSwappableElements!( string));\nstatic assert(!hasSwappableElements!(dstring));\nstatic assert(!hasSwappableElements!( char[]));\nstatic assert( hasSwappableElements!(dchar[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1261_3249)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasAssignableElements",
						"line": 1289,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nr.front = r.front;\nstatic if (isBidirectionalRange!R)\n{\nr.back = r.front;\n}\n\nstatic if (isRandomAccessRange!R)\n{\nr[0] = r.front;\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasAssignableElements",
				"line": 1287,
				"comment": "Returns $(D true) if $(D R) is an input range and has mutable\nelements. The following code should compile for any range\nwith assignable elements.\n\n----\nR r;\nstatic assert(isInputRange!R);\nr.front = r.front;\nstatic if (isBidirectionalRange!R) r.back = r.front;\nstatic if (isRandomAccessRange!R) r[0] = r.front;\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1300_3250)\n---\nstatic assert(!hasAssignableElements!(const int[]));\nstatic assert(!hasAssignableElements!(const(int)[]));\nstatic assert( hasAssignableElements!(int[]));\nstatic assert(!hasAssignableElements!(inout(int)[]));\n\nstatic assert(!hasAssignableElements!( string));\nstatic assert(!hasAssignableElements!(dstring));\nstatic assert(!hasAssignableElements!( char[]));\nstatic assert( hasAssignableElements!(dchar[]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1300_3250)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasLvalueElements",
						"line": 1328,
						"deco": "b",
						"init": "isInputRange!R && is(typeof((inout int = 0)\n{\nvoid checkRef(ref ElementType!R stuff);\nR r = R.init;\ncheckRef(r.front);\nstatic if (isBidirectionalRange!R)\n{\ncheckRef(r.back);\n}\n\nstatic if (isRandomAccessRange!R)\n{\ncheckRef(r[0]);\n}\n\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasLvalueElements",
				"line": 1326,
				"comment": "Tests whether the range $(D R) has lvalue elements. These are defined as\nelements that can be passed by reference and have their address taken.\nThe following code should compile for any range with lvalue elements.\n----\nvoid passByRef(ref ElementType!R stuff);\n...\nstatic assert(isInputRange!R);\npassByRef(r.front);\nstatic if (isBidirectionalRange!R) passByRef(r.back);\nstatic if (isRandomAccessRange!R) passByRef(r[0]);\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1341_3251)\n---\nimport std.range : iota, chain;\n\nstatic assert( hasLvalueElements!(int[]));\nstatic assert( hasLvalueElements!(const(int)[]));\nstatic assert( hasLvalueElements!(inout(int)[]));\nstatic assert( hasLvalueElements!(immutable(int)[]));\nstatic assert(!hasLvalueElements!(typeof(iota(3))));\n\nstatic assert(!hasLvalueElements!( string));\nstatic assert( hasLvalueElements!(dstring));\nstatic assert(!hasLvalueElements!( char[]));\nstatic assert( hasLvalueElements!(dchar[]));\n\nauto c = chain([1, 2, 3], [4, 5, 6]);\nstatic assert( hasLvalueElements!(typeof(c)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1341_3251)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasLength",
						"line": 1385,
						"deco": "b",
						"init": "!isNarrowString!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nulong l = r.length;\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasLength",
				"line": 1383,
				"comment": "Returns $(D true) if $(D R) has a $(D length) member that returns an\nintegral type. $(D R) does not have to be a range. Note that $(D\nlength) is an optional primitive as no range must implement it. Some\nranges do not store their length explicitly, some cannot compute it\nwithout actually exhausting the range (e.g. socket streams), and some\nother ranges may be infinite.\n\nAlthough narrow string types ($(D char[]), $(D wchar[]), and their\nqualified derivatives) do define a $(D length) property, $(D\nhasLength) yields $(D false) for them. This is because a narrow\nstring's length does not reflect the number of characters, but instead\nthe number of encoding units, and as such is not useful with\nrange-oriented algorithms.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1394_3253)\n---\nstatic assert(!hasLength!(char[]));\nstatic assert( hasLength!(int[]));\nstatic assert( hasLength!(inout(int)[]));\n\nstruct A { ulong length; }\nstruct B { size_t length() { return 0; } }\nstruct C { @property size_t length() { return 0; } }\nstatic assert( hasLength!(A));\nstatic assert( hasLength!(B));\nstatic assert( hasLength!(C));\n}\n\n/**\nReturns $(D true) if $(D R) is an infinite input range. An\ninfinite input range is an input range that has a statically-defined\nenumerated member called $(D empty) that is always $(D false),\nfor example:\n\n----\nstruct MyInfiniteRange\n{\nenum bool empty = false;\n...\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1394_3253)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isInfinite",
				"line": 1423,
				"comment": "Returns $(D true) if $(D R) is an infinite input range. An\ninfinite input range is an input range that has a statically-defined\nenumerated member called $(D empty) that is always $(D false),\nfor example:\n\n----\nstruct MyInfiniteRange\n{\n    enum bool empty = false;\n    ...\n}\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1432_3254)\n---\nimport std.range : Repeat;\nstatic assert(!isInfinite!(int[]));\nstatic assert( isInfinite!(Repeat!(int)));\n}\n\n/**\nReturns $(D true) if $(D R) offers a slicing operator with integral boundaries\nthat returns a forward range type.\n\nFor finite ranges, the result of $(D opSlice) must be of the same type as the\noriginal range type. If the range defines $(D opDollar), then it must support\nsubtraction.\n\nFor infinite ranges, when $(I not) using $(D opDollar), the result of\n$(D opSlice) must be the result of $(LREF take) or $(LREF takeExactly) on the\noriginal range (they both return the same type for infinite ranges). However,\nwhen using $(D opDollar), the result of $(D opSlice) must be that of the\noriginal range type.\n\nThe following code must compile for $(D hasSlicing) to be $(D true):\n\n----\nR r = void;\n\nstatic if(isInfinite!R)\ntypeof(take(r, 1)) s = r[1 .. 2];\nelse\n{\nstatic assert(is(typeof(r[1 .. 2]) == R));\nR s = r[1 .. 2];\n}\n\ns = r[1 .. 2];\n\nstatic if(is(typeof(r[0 .. $])))\n{\nstatic assert(is(typeof(r[0 .. $]) == R));\nR t = r[0 .. $];\nt = r[0 .. $];\n\nstatic if(!isInfinite!R)\n{\n    static assert(is(typeof(r[0 .. $ - 1]) == R));\n    R u = r[0 .. $ - 1];\n    u = r[0 .. $ - 1];\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1432_3254)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "hasSlicing",
						"line": 1488,
						"deco": "b",
						"init": "isForwardRange!R && !isNarrowString!R && is(typeof((inout int = 0)\n{\nR r = R.init;\nstatic if (isInfinite!R)\n{\ntypeof(r[1..1]) s = r[1..2];\n}\nelse\n{\nstatic assert(is(typeof(r[1..2]) == R));\nR s = r[1..2];\n}\ns = r[1..2];\nstatic if (is(typeof(r[0..__dollar])))\n{\nstatic assert(is(typeof(r[0..__dollar]) == R));\nR t = r[0..__dollar];\nt = r[0..__dollar];\nstatic if (!isInfinite!R)\n{\nstatic assert(is(typeof(r[0..__dollar - 1]) == R));\nR u = r[0..__dollar - 1];\nu = r[0..__dollar - 1];\n}\n\n}\n\nstatic assert(isForwardRange!(typeof(r[1..2])));\nstatic assert(hasLength!(typeof(r[1..2])));\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "hasSlicing",
				"line": 1486,
				"comment": "Returns $(D true) if $(D R) offers a slicing operator with integral boundaries\nthat returns a forward range type.\n\nFor finite ranges, the result of $(D opSlice) must be of the same type as the\noriginal range type. If the range defines $(D opDollar), then it must support\nsubtraction.\n\nFor infinite ranges, when $(I not) using $(D opDollar), the result of\n$(D opSlice) must be the result of $(LREF take) or $(LREF takeExactly) on the\noriginal range (they both return the same type for infinite ranges). However,\nwhen using $(D opDollar), the result of $(D opSlice) must be that of the\noriginal range type.\n\nThe following code must compile for $(D hasSlicing) to be $(D true):\n\n----\nR r = void;\n\nstatic if(isInfinite!R)\n    typeof(take(r, 1)) s = r[1 .. 2];\nelse\n{\n    static assert(is(typeof(r[1 .. 2]) == R));\n    R s = r[1 .. 2];\n}\n\ns = r[1 .. 2];\n\nstatic if(is(typeof(r[0 .. $])))\n{\n    static assert(is(typeof(r[0 .. $]) == R));\n    R t = r[0 .. $];\n    t = r[0 .. $];\n\n    static if(!isInfinite!R)\n    {\n        static assert(is(typeof(r[0 .. $ - 1]) == R));\n        R u = r[0 .. $ - 1];\n        u = r[0 .. $ - 1];\n    }\n}\n\nstatic assert(isForwardRange!(typeof(r[1 .. 2])));\nstatic assert(hasLength!(typeof(r[1 .. 2])));\n----\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1525_3255)\n---\nimport std.range : takeExactly;\nstatic assert( hasSlicing!(int[]));\nstatic assert( hasSlicing!(const(int)[]));\nstatic assert(!hasSlicing!(const int[]));\nstatic assert( hasSlicing!(inout(int)[]));\nstatic assert(!hasSlicing!(inout int []));\nstatic assert( hasSlicing!(immutable(int)[]));\nstatic assert(!hasSlicing!(immutable int[]));\nstatic assert(!hasSlicing!string);\nstatic assert( hasSlicing!dstring);\n\nenum rangeFuncs = \"@property int front();\" ~\n                  \"void popFront();\" ~\n                  \"@property bool empty();\" ~\n                  \"@property auto save() { return this; }\" ~\n                  \"@property size_t length();\";\n\nstruct A { mixin(rangeFuncs); int opSlice(size_t, size_t); }\nstruct B { mixin(rangeFuncs); B opSlice(size_t, size_t); }\nstruct C { mixin(rangeFuncs); @disable this(); C opSlice(size_t, size_t); }\nstruct D { mixin(rangeFuncs); int[] opSlice(size_t, size_t); }\nstatic assert(!hasSlicing!(A));\nstatic assert( hasSlicing!(B));\nstatic assert( hasSlicing!(C));\nstatic assert(!hasSlicing!(D));\n\nstruct InfOnes\n{\n    enum empty = false;\n    void popFront() {}\n    @property int front() { return 1; }\n    @property InfOnes save() { return this; }\n    auto opSlice(size_t i, size_t j) { return takeExactly(this, j - i); }\n    auto opSlice(size_t i, Dollar d) { return this; }\n\n    struct Dollar {}\n    Dollar opDollar() const { return Dollar.init; }\n}\n\nstatic assert(hasSlicing!InfOnes);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1525_3255)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "walkLength",
						"line": 1589,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1601,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "walkLength",
				"line": 1589,
				"comment": "This is a best-effort implementation of $(D length) for any kind of\nrange.\n\nIf $(D hasLength!Range), simply returns $(D range.length) without\nchecking $(D upTo) (when specified).\n\nOtherwise, walks the range through its length and returns the number\nof elements seen. Performes $(BIGOH n) evaluations of $(D range.empty)\nand $(D range.popFront()), where $(D n) is the effective length of $(D\nrange).\n\nThe $(D upTo) parameter is useful to \"cut the losses\" in case\nthe interest is in seeing whether the range has at least some number\nof elements. If the parameter $(D upTo) is specified, stops if $(D\nupTo) steps have been taken and returns $(D upTo).\n\nInfinite ranges are compatible, provided the parameter $(D upTo) is\nspecified, in which case the implementation simply returns upTo.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && !isInfinite!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "walkLength",
						"line": 1603,
						"type": "(Range range, const size_t upTo)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "upTo",
								"type": "size_t",
								"storageClass": [
									"const"
								]
							}
						],
						"endline": 1617,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "walkLength",
				"line": 1603,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popFrontN",
						"line": 1660,
						"type": "size_t(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1693,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "popFrontN",
				"line": 1660,
				"comment": "    Eagerly advances $(D r) itself (not a copy) up to $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontN) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing and have length.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Returns:\n    How much $(D r) was actually advanced, which may be less than $(D n) if\n    $(D r) did not have at least $(D n) elements.\n\n    $(D popBackN) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1732_3257)\n---\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popFrontN(2);\nassert(a == [ 3, 4, 5 ]);\na.popFrontN(7);\nassert(a == [ ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1732_3257)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1742_3258)\n---\nimport std.algorithm : equal;\nimport std.range : iota;\nauto LL = iota(1L, 7L);\nauto r = popFrontN(LL, 2);\nassert(equal(LL, [3L, 4L, 5L, 6L]));\nassert(r == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1742_3258)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1753_3259)\n---\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popBackN(2);\nassert(a == [ 1, 2, 3 ]);\na.popBackN(7);\nassert(a == [ ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1753_3259)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1763_3260)\n---\nimport std.algorithm : equal;\nimport std.range : iota;\nauto LL = iota(1L, 7L);\nauto r = popBackN(LL, 2);\nassert(equal(LL, [1L, 2L, 3L, 4L]));\nassert(r == 2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1763_3260)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popBackN",
						"line": 1696,
						"type": "size_t(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1729,
						"char": 8,
						"kind": "function"
					}
				],
				"name": "popBackN",
				"line": 1696,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range",
				"char": 8,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popFrontExactly",
						"line": 1791,
						"type": "void(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1804,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popFrontExactly",
				"line": 1791,
				"comment": "    Eagerly advances $(D r) itself (not a copy) exactly $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontExactly) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing, and have either length or are infinite.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Note: Unlike $(LREF popFrontN), $(D popFrontExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D popFrontExactly)\n    faster than $(D popFrontN), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\n\n    $(D popBackExactly) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1823_3261)\n---\nimport std.algorithm : filterBidirectional, equal;\n\nauto a = [1, 2, 3];\na.popFrontExactly(1);\nassert(a == [2, 3]);\na.popBackExactly(1);\nassert(a == [2]);\n\nstring s = \"æ¥æ¬èª\";\ns.popFrontExactly(1);\nassert(s == \"æ¬èª\");\ns.popBackExactly(1);\nassert(s == \"æ¬\");\n\nauto bd = filterBidirectional!\"true\"([1, 2, 3]);\nbd.popFrontExactly(1);\nassert(bd.equal([2, 3]));\nbd.popBackExactly(1);\nassert(bd.equal([2]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1823_3261)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popBackExactly",
						"line": 1807,
						"type": "void(ref Range r, size_t n)",
						"parameters": [
							{
								"name": "r",
								"type": "Range",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1820,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popBackExactly",
				"line": 1807,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isBidirectionalRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveFront",
						"line": 1851,
						"type": "ElementType!R(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 1864,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "moveFront",
				"line": 1851,
				"comment": "   Moves the front of $(D r) out and returns it. Leaves $(D r.front) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1867_3262)\n---\nauto a = [ 1, 2, 3 ];\nassert(moveFront(a) == 1);\n\n// define a perfunctory input range\nstruct InputRange\n{\n    @property bool empty() { return false; }\n    @property int front() { return 42; }\n    void popFront() {}\n    int moveFront() { return 43; }\n}\nInputRange r;\nassert(moveFront(r) == 43);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1867_3262)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveBack",
						"line": 1900,
						"type": "ElementType!R(R r)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							}
						],
						"endline": 1913,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "moveBack",
				"line": 1900,
				"comment": "   Moves the back of $(D r) out and returns it. Leaves $(D r.back) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1916_3264)\n---\nstruct TestRange\n{\n    int payload = 5;\n    @property bool empty() { return false; }\n    @property TestRange save() { return this; }\n    @property ref int front() return { return payload; }\n    @property ref int back() return { return payload; }\n    void popFront() { }\n    void popBack() { }\n}\nstatic assert(isBidirectionalRange!TestRange);\nTestRange r;\nauto x = moveBack(r);\nassert(x == 5);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1916_3264)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "moveAt",
						"line": 1939,
						"type": "ElementType!R(R r, I i)",
						"parameters": [
							{
								"name": "r",
								"type": "R"
							},
							{
								"name": "i",
								"type": "I"
							}
						],
						"endline": 1952,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "moveAt",
				"line": 1939,
				"comment": "   Moves element at index $(D i) of $(D r) out and returns it. Leaves $(D\n   r.front) in a destroyable state that does not allocate any resources\n   (usually equal to its $(D .init) value).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1955_3265)\n---\nauto a = [1,2,3,4];\nforeach(idx, it; a)\n{\n    assert(it == moveAt(a, idx));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1955_3265)\n",
				"parameters": [
					{
						"name": "R",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!I",
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "empty",
						"line": 1989,
						"type": "pure nothrow @nogc @property @safe bool(in T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1992,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "empty",
				"line": 1989,
				"comment": "Implements the range interface primitive $(D empty) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.empty) is\nequivalent to $(D empty(array)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1995_3267)\n---\nauto a = [ 1, 2, 3 ];\nassert(!a.empty);\nassert(a[3 .. $].empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1995_3267)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "save",
						"line": 2010,
						"type": "pure nothrow @nogc @property @safe T[](T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 2013,
						"char": 15,
						"kind": "function"
					}
				],
				"name": "save",
				"line": 2010,
				"comment": "Implements the range interface primitive $(D save) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.save) is\nequivalent to $(D save(array)). The function does not duplicate the\ncontent of the array, it simply returns its argument.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2016_3268)\n---\nauto a = [ 1, 2, 3 ];\nauto b = a.save;\nassert(b is a);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2016_3268)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 15,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popFront",
						"line": 2032,
						"type": "pure nothrow @nogc @safe void(ref T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 2037,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popFront",
				"line": 2032,
				"comment": "Implements the range interface primitive $(D popFront) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popFront) is\nequivalent to $(D popFront(array)). For $(GLOSSARY narrow strings),\n$(D popFront) automatically advances to the next $(GLOSSARY code\npoint).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2040_3269)\n---\nauto a = [ 1, 2, 3 ];\na.popFront();\nassert(a == [ 2, 3 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2040_3269)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[]) && !is(T[] == void[])",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "popBack",
						"line": 2131,
						"type": "pure nothrow @nogc @safe void(ref T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 2136,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "popBack",
				"line": 2131,
				"comment": "Implements the range interface primitive $(D popBack) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popBack) is\nequivalent to $(D popBack(array)). For $(GLOSSARY narrow strings), $(D\npopFront) automatically eliminates the last $(GLOSSARY code point).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2139_3271)\n---\nauto a = [ 1, 2, 3 ];\na.popBack();\nassert(a == [ 1, 2 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2139_3271)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[]) && !is(T[] == void[])",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "front",
						"line": 2197,
						"type": "pure nothrow @nogc @property ref @safe T(T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 2202,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "front",
				"line": 2197,
				"comment": "Implements the range interface primitive $(D front) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.front) is\nequivalent to $(D front(array)). For $(GLOSSARY narrow strings), $(D\nfront) automatically returns the first $(GLOSSARY code point) as a $(D\ndchar).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2205_3273)\n---\nint[] a = [ 1, 2, 3 ];\nassert(a.front == 1);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2205_3273)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[]) && !is(T[] == void[])",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "back",
						"line": 2241,
						"type": "pure nothrow @nogc @property ref @safe T(T[] a)",
						"parameters": [
							{
								"name": "a",
								"type": "T[]"
							}
						],
						"endline": 2246,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "back",
				"line": 2241,
				"comment": "Implements the range interface primitive $(D back) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.back) is\nequivalent to $(D back(array)). For $(GLOSSARY narrow strings), $(D\nback) automatically returns the last $(GLOSSARY code point) as a $(D\ndchar).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2249_3275)\n---\nint[] a = [ 1, 2, 3 ];\nassert(a.back == 3);\na.back += 4;\nassert(a.back == 7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2249_3275)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "!isNarrowString!(T[])",
				"char": 17,
				"kind": "template"
			}
		],
		"comment": "This module is a submodule of $(LINK2 std_range.html, std.range).\n\nIt provides basic range functionality by defining several templates for testing\nwhether a given object is a _range, and what kind of _range it is:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF isInputRange)))\n        $(TD Tests if something is an $(I input _range), defined to be\n        something from which one can sequentially read data using the\n        primitives $(D front), $(D popFront), and $(D empty).\n    ))\n    $(TR $(TD $(D $(LREF isOutputRange)))\n        $(TD Tests if something is an $(I output _range), defined to be\n        something to which one can sequentially write data using the\n        $(D $(LREF put)) primitive.\n    ))\n    $(TR $(TD $(D $(LREF isForwardRange)))\n        $(TD Tests if something is a $(I forward _range), defined to be an\n        input _range with the additional capability that one can save one's\n        current position with the $(D save) primitive, thus allowing one to\n        iterate over the same _range multiple times.\n    ))\n    $(TR $(TD $(D $(LREF isBidirectionalRange)))\n        $(TD Tests if something is a $(I bidirectional _range), that is, a\n        forward _range that allows reverse traversal using the primitives $(D\n        back) and $(D popBack).\n    ))\n    $(TR $(TD $(D $(LREF isRandomAccessRange)))\n        $(TD Tests if something is a $(I random access _range), which is a\n        bidirectional _range that also supports the array subscripting\n        operation via the primitive $(D opIndex).\n    ))\n)\n\nIt also provides number of templates that test for various _range capabilities:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF hasMobileElements)))\n        $(TD Tests if a given _range's elements can be moved around using the\n        primitives $(D moveFront), $(D moveBack), or $(D moveAt).\n    ))\n    $(TR $(TD $(D $(LREF ElementType)))\n        $(TD Returns the element type of a given _range.\n    ))\n    $(TR $(TD $(D $(LREF ElementEncodingType)))\n        $(TD Returns the encoding element type of a given _range.\n    ))\n    $(TR $(TD $(D $(LREF hasSwappableElements)))\n        $(TD Tests if a _range is a forward _range with swappable elements.\n    ))\n    $(TR $(TD $(D $(LREF hasAssignableElements)))\n        $(TD Tests if a _range is a forward _range with mutable elements.\n    ))\n    $(TR $(TD $(D $(LREF hasLvalueElements)))\n        $(TD Tests if a _range is a forward _range with elements that can be\n        passed by reference and have their address taken.\n    ))\n    $(TR $(TD $(D $(LREF hasLength)))\n        $(TD Tests if a given _range has the $(D length) attribute.\n    ))\n    $(TR $(TD $(D $(LREF isInfinite)))\n        $(TD Tests if a given _range is an $(I infinite _range).\n    ))\n    $(TR $(TD $(D $(LREF hasSlicing)))\n        $(TD Tests if a given _range supports the array slicing operation $(D\n        R[x..y]).\n    ))\n)\n\nFinally, it includes some convenience functions for manipulating ranges:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF popFrontN)))\n        $(TD Advances a given _range by up to $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popBackN)))\n        $(TD Advances a given bidirectional _range from the right by up to\n        $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popFrontExactly)))\n        $(TD Advances a given _range by up exactly $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popBackExactly)))\n        $(TD Advances a given bidirectional _range from the right by exactly\n        $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF moveFront)))\n        $(TD Removes the front element of a _range.\n    ))\n    $(TR $(TD $(D $(LREF moveBack)))\n        $(TD Removes the back element of a bidirectional _range.\n    ))\n    $(TR $(TD $(D $(LREF moveAt)))\n        $(TD Removes the $(I i)'th element of a random-access _range.\n    ))\n    $(TR $(TD $(D $(LREF walkLength)))\n        $(TD Computes the length of any _range in O(n) time.\n    ))\n)\n\nSource: $(PHOBOSSRC std/range/_primitives.d)\n\nMacros:\n\nWIKI = Phobos/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net/leonardo/so/, Leonardo Maffi).\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/net/curl.d",
		"name": "std.net.curl",
		"members": [
			{
				"name": "AutoProtocol",
				"line": 258,
				"comment": "Macros:\n\nCALLBACK_PARAMS = $(TABLE ,\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlTotal))\n        $(DDOC_PARAM_DESC total bytes to download)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM dlNow))\n        $(DDOC_PARAM_DESC currently downloaded bytes)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulTotal))\n        $(DDOC_PARAM_DESC total bytes to upload)\n        )\n    $(DDOC_PARAM_ROW\n        $(DDOC_PARAM_ID $(DDOC_PARAM ulNow))\n        $(DDOC_PARAM_DESC currently uploaded bytes)\n        )\n)\n\n Connection type used when the URL should be used to auto detect the protocol.\n\n This struct is used as placeholder for the connection parameter when calling\n the high level API and the connection type (HTTP/FTP) should be guessed by\n inspecting the URL parameter.\n\n The rules for guessing the protocol are:\n 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed.\n 2, HTTP connection otherwise.\n\n Example:\n ---\n import std.net.curl;\n // Two requests below will do the same.\n string content;\n\n // Explicit connection provided\n content = get!HTTP(\"dlang.org\");\n\n // Guess connection type by looking at the URL\n content = get!AutoProtocol(\"ftp://foo.com/file\");\n // and since AutoProtocol is default this is the same as\n connect = get(\"ftp://foo.com/file\");\n // and will end up detecting FTP from the url and be the same as\n connect = get!FTP(\"ftp://foo.com/file\");\n ---\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "download",
						"line": 287,
						"type": "void(const(char)[] url, string saveToPath, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "saveToPath",
								"type": "string"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 305,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "download",
				"line": 287,
				"comment": " HTTP/FTP download to local file system.\n\n Params:\n url = resource to download\n saveToPath = path to store the downloaded content on local disk\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n Example:\n ----\n import std.net.curl;\n download(\"d-lang.appspot.com/testUrl2\", \"/tmp/downloaded-http-file\");\n ----\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "upload",
						"line": 334,
						"type": "void(string loadFromPath, const(char)[] url, Conn conn = Conn())",
						"parameters": [
							{
								"name": "loadFromPath",
								"type": "string"
							},
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 368,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "upload",
				"line": 334,
				"comment": " Upload file from local files system using the HTTP or FTP protocol.\n\n Params:\n loadFromPath = path load data from local disk.\n url = resource to upload to\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n Example:\n ----\n import std.net.curl;\n upload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");\n upload(\"/tmp/downloaded-http-file\", \"d-lang.appspot.com/testUrl2\");\n ----\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "get",
						"line": 405,
						"type": "T[](const(char)[] url, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 425,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "get",
				"line": 405,
				"comment": " HTTP/FTP get content.\n\n Params:\n url = resource to get\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n for $(D char), content will be converted from the connection character set\n (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n by default) to UTF-8.\n\n Example:\n ----\n import std.net.curl;\n string content = get(\"d-lang.appspot.com/testUrl2\");\n ----\n\n Returns:\n A T[] range containing the content of the resource pointed to by the URL.\n\n Throws:\n\n $(D CurlException) on error.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && (is(T == char) || is(T == ubyte))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "post",
						"line": 470,
						"type": "T[](const(char)[] url, const(PostUnit)[] postData, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "postData",
								"type": "const(PostUnit)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 475,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "post",
				"line": 470,
				"comment": " HTTP post content.\n\n Params:\n url = resource to post to\n postData = data to send as the body of the request. An array\n            of an arbitrary type is accepted and will be cast to ubyte[]\n            before sending it.\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n for $(D char), content will be converted from the connection character set\n (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n by default) to UTF-8.\n\n Example:\n ----\n import std.net.curl;\n string content = post(\"d-lang.appspot.com/testUrl2\", [1,2,3,4]);\n ----\n\n Returns:\n A T[] range containing the content of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "PostUnit",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "put",
						"line": 534,
						"type": "T[](const(char)[] url, const(PutUnit)[] putData, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "putData",
								"type": "const(PutUnit)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 554,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "put",
				"line": 534,
				"comment": " HTTP/FTP put content.\n\n Params:\n url = resource to put\n putData = data to send as the body of the request. An array\n           of an arbitrary type is accepted and will be cast to ubyte[]\n           before sending it.\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]). If asking\n for $(D char), content will be converted from the connection character set\n (specified in HTTP response headers or FTP connection properties, both ISO-8859-1\n by default) to UTF-8.\n\n Example:\n ----\n import std.net.curl;\n string content = put(\"d-lang.appspot.com/testUrl2\",\n                      \"Putting this data\");\n ----\n\n Returns:\n A T[] range containing the content of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "PutUnit",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && (is(T == char) || is(T == ubyte))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "del",
						"line": 585,
						"type": "void(const(char)[] url, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 614,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "del",
				"line": 585,
				"comment": " HTTP/FTP delete content.\n\n Params:\n url = resource to delete\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n Example:\n ----\n import std.net.curl;\n del(\"d-lang.appspot.com/testUrl2\");\n ----\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "options",
						"line": 651,
						"type": "T[](const(char)[] url, const(OptionsUnit)[] optionsData = null, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "optionsData",
								"type": "const(OptionsUnit)[]",
								"default": "null"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 658,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "options",
				"line": 651,
				"comment": " HTTP options request.\n\n Params:\n url = resource make a option call to\n optionsData = options data to send as the body of the request. An array\n               of an arbitrary type is accepted and will be cast to ubyte[]\n               before sending it.\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n Currently the HTTP RFC does not specify any usage of the optionsData and\n for this reason the example below does not send optionsData to the server.\n\n Example:\n ----\n import std.net.curl;\n auto http = HTTP();\n options(\"d-lang.appspot.com/testUrl2\", null, http);\n writeln(\"Allow set to \" ~ http.responseHeaders[\"Allow\"]);\n ----\n\n Returns:\n A T[] range containing the options of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					},
					{
						"name": "OptionsUnit",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "trace",
						"line": 698,
						"type": "T[](const(char)[] url, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 703,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "trace",
				"line": 698,
				"comment": " HTTP trace request.\n\n Params:\n url = resource make a trace call to\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n\n Example:\n ----\n import std.net.curl;\n trace(\"d-lang.appspot.com/testUrl1\");\n ----\n\n Returns:\n A T[] range containing the trace info of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "connect",
						"line": 735,
						"type": "T[](const(char)[] url, HTTP conn = HTTP())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "conn",
								"type": "HTTP",
								"default": "HTTP()"
							}
						],
						"endline": 740,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "connect",
				"line": 735,
				"comment": " HTTP connect request.\n\n Params:\n url = resource make a connect to\n conn = connection to use e.g. FTP or HTTP. The default AutoProtocol will\n        guess connection type and create a new instance for this call only.\n\n The template parameter $(D T) specifies the type to return. Possible values\n are $(D char) and $(D ubyte) to return $(D char[]) or $(D ubyte[]).\n\n Example:\n ----\n import std.net.curl;\n connect(\"d-lang.appspot.com/testUrl1\");\n ----\n\n Returns:\n A T[] range containing the connect info of the resource pointed to by the URL.\n\n See_Also: $(LREF HTTP.Method)\n",
				"parameters": [
					{
						"defaultDeco": "a",
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == char) || is(T == ubyte)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byLine",
						"line": 978,
						"type": "(const(char)[] url, KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a', Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "keepTerminator",
								"type": "KeepTerminator",
								"default": "KeepTerminator.no"
							},
							{
								"name": "terminator",
								"type": "Terminator",
								"default": "'\\x0a'"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1046,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byLine",
				"line": 978,
				"comment": " HTTP/FTP fetch content as a range of lines.\n\n A range of lines is returned when the request is complete. If the method or\n other request properties is to be customized then set the $(D conn) parameter\n with a HTTP/FTP instance that has these properties set.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n foreach (line; byLine(\"dlang.org\"))\n     writeln(line);\n ----\n\n Params:\n url = The url to receive content from\n keepTerminator = KeepTerminator.yes signals that the line terminator should be\n                  returned as part of the lines in the range.\n terminator = The character that terminates a line\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of Char[] with the content of the resource pointer to by the URL\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Terminator",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChunk",
						"line": 1083,
						"type": "(const(char)[] url, size_t chunkSize = 1024, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "chunkSize",
								"type": "size_t",
								"default": "1024"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1120,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChunk",
				"line": 1083,
				"comment": " HTTP/FTP fetch content as a range of chunks.\n\n A range of chunks is returned when the request is complete. If the method or\n other request properties is to be customized then set the $(D conn) parameter\n with a HTTP/FTP instance that has these properties set.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n foreach (chunk; byChunk(\"dlang.org\", 100))\n     writeln(chunk); // chunk is ubyte[100]\n ----\n\n Params:\n url = The url to receive content from\n chunkSize = The size of each chunk\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of ubyte[chunkSize] with the content of the resource pointer to by the URL\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byLineAsync",
						"line": 1363,
						"type": "(const(char)[] url, const(PostUnit)[] postData, KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a', size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "postData",
								"type": "const(PostUnit)[]"
							},
							{
								"name": "keepTerminator",
								"type": "KeepTerminator",
								"default": "KeepTerminator.no"
							},
							{
								"name": "terminator",
								"type": "Terminator",
								"default": "'\\x0a'"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1393,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byLineAsync",
				"line": 1363,
				"comment": " HTTP/FTP fetch content as a range of lines asynchronously.\n\n A range of lines is returned immediately and the request that fetches the\n lines is performed in another thread. If the method or other request\n properties is to be customized then set the $(D conn) parameter with a\n HTTP/FTP instance that has these properties set.\n\n If $(D postData) is non-_null the method will be set to $(D post) for HTTP\n requests.\n\n The background thread will buffer up to transmitBuffers number of lines\n before it stops receiving data from network. When the main thread reads the\n lines from the range it frees up buffers and allows for the background thread\n to receive more data from the network.\n\n If no data is available and the main thread accesses the range it will block\n until data becomes available. An exception to this is the $(D wait(Duration)) method on\n the $(LREF AsyncLineInputRange). This method will wait at maximum for the\n specified duration and return true if data is available.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n // Get some pages in the background\n auto range1 = byLineAsync(\"www.google.com\");\n auto range2 = byLineAsync(\"www.wikipedia.org\");\n foreach (line; byLineAsync(\"dlang.org\"))\n     writeln(line);\n\n // Lines already fetched in the background and ready\n foreach (line; range1) writeln(line);\n foreach (line; range2) writeln(line);\n ----\n\n ----\n import std.net.curl, std.stdio;\n // Get a line in a background thread and wait in\n // main thread for 2 seconds for it to arrive.\n auto range3 = byLineAsync(\"dlang.com\");\n if (range.wait(dur!\"seconds\"(2)))\n     writeln(range.front);\n else\n     writeln(\"No line received after 2 seconds!\");\n ----\n\n Params:\n url = The url to receive content from\n postData = Data to HTTP Post\n keepTerminator = KeepTerminator.yes signals that the line terminator should be\n                  returned as part of the lines in the range.\n terminator = The character that terminates a line\n transmitBuffers = The number of lines buffered asynchronously\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of Char[] with the content of the resource pointer to by the\n URL.\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Terminator",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Char",
						"kind": "type"
					},
					{
						"name": "PostUnit",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn && isSomeChar!Char && isSomeChar!Terminator",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byLineAsync",
						"line": 1396,
						"type": "(const(char)[] url, KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a', size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "keepTerminator",
								"type": "KeepTerminator",
								"default": "KeepTerminator.no"
							},
							{
								"name": "terminator",
								"type": "Terminator",
								"default": "'\\x0a'"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1415,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byLineAsync",
				"line": 1396,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Terminator",
						"kind": "type"
					},
					{
						"defaultDeco": "a",
						"name": "Char",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChunkAsync",
						"line": 1516,
						"type": "(const(char)[] url, const(PostUnit)[] postData, size_t chunkSize = 1024, size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "postData",
								"type": "const(PostUnit)[]"
							},
							{
								"name": "chunkSize",
								"type": "size_t",
								"default": "1024"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1542,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChunkAsync",
				"line": 1516,
				"comment": " HTTP/FTP fetch content as a range of chunks asynchronously.\n\n A range of chunks is returned immediately and the request that fetches the\n chunks is performed in another thread. If the method or other request\n properties is to be customized then set the $(D conn) parameter with a\n HTTP/FTP instance that has these properties set.\n\n If $(D postData) is non-_null the method will be set to $(D post) for HTTP\n requests.\n\n The background thread will buffer up to transmitBuffers number of chunks\n before is stops receiving data from network. When the main thread reads the\n chunks from the range it frees up buffers and allows for the background\n thread to receive more data from the network.\n\n If no data is available and the main thread access the range it will block\n until data becomes available. An exception to this is the $(D wait(Duration))\n method on the $(LREF AsyncChunkInputRange). This method will wait at maximum for the specified\n duration and return true if data is available.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n // Get some pages in the background\n auto range1 = byChunkAsync(\"www.google.com\", 100);\n auto range2 = byChunkAsync(\"www.wikipedia.org\");\n foreach (chunk; byChunkAsync(\"dlang.org\"))\n     writeln(chunk); // chunk is ubyte[100]\n\n // Chunks already fetched in the background and ready\n foreach (chunk; range1) writeln(chunk);\n foreach (chunk; range2) writeln(chunk);\n ----\n\n ----\n import std.net.curl, std.stdio;\n // Get a line in a background thread and wait in\n // main thread for 2 seconds for it to arrive.\n auto range3 = byChunkAsync(\"dlang.com\", 10);\n if (range.wait(dur!\"seconds\"(2)))\n     writeln(range.front);\n else\n     writeln(\"No chunk received after 2 seconds!\");\n ----\n\n Params:\n url = The url to receive content from\n postData = Data to HTTP Post\n chunkSize = The size of the chunks\n transmitBuffers = The number of chunks buffered asynchronously\n conn = The connection to use e.g. HTTP or FTP.\n\n Returns:\n A range of ubyte[chunkSize] with the content of the resource pointer to by\n the URL.\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					},
					{
						"name": "PostUnit",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byChunkAsync",
						"line": 1545,
						"type": "(const(char)[] url, size_t chunkSize = 1024, size_t transmitBuffers = 10, Conn conn = Conn())",
						"parameters": [
							{
								"name": "url",
								"type": "const(char)[]"
							},
							{
								"name": "chunkSize",
								"type": "size_t",
								"default": "1024"
							},
							{
								"name": "transmitBuffers",
								"type": "size_t",
								"default": "10"
							},
							{
								"name": "conn",
								"type": "Conn",
								"default": "Conn()"
							}
						],
						"endline": 1565,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byChunkAsync",
				"line": 1545,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Conn",
						"default": "AutoProtocol",
						"kind": "type"
					}
				],
				"constraint": "isCurlConn!Conn",
				"char": 6,
				"kind": "template"
			},
			{
				"name": "HTTP",
				"line": 2096,
				"comment": " HTTP client functionality.\n\n Example:\n ---\n import std.net.curl, std.stdio;\n\n // Get with custom data receivers\n auto http = HTTP(\"dlang.org\");\n http.onReceiveHeader =\n     (in char[] key, in char[] value) { writeln(key ~ \": \" ~ value); };\n http.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\n http.perform();\n\n // Put with data senders\n auto msg = \"Hello world\";\n http.contentLength = msg.length;\n http.onSend = (void[] data)\n {\n     auto m = cast(void[])msg;\n     size_t len = m.length > data.length ? data.length : m.length;\n     if (len == 0) return len;\n     data[0..len] = m[0..len];\n     msg = msg[len..$];\n     return len;\n };\n http.perform();\n\n // Track progress\n http.method = HTTP.Method.get;\n http.url = \"http://upload.wikimedia.org/wikipedia/commons/\"\n            \"5/53/Wikipedia-logo-en-big.png\";\n http.onReceive = (ubyte[] data) { return data.length; };\n http.onProgress = (size_t dltotal, size_t dlnow,\n                    size_t ultotal, size_t ulnow)\n {\n     writeln(\"Progress \", dltotal, \", \", dlnow, \", \", ultotal, \", \", ulnow);\n     return 0;\n };\n http.perform();\n ---\n\n See_Also: $(WEB www.ietf.org/rfc/rfc2616.txt, RFC2616)\n\n",
				"members": [
					{
						"name": "AuthMethod",
						"line": 2101,
						"comment": "Authentication method equal to $(ECXREF curl, CurlAuth)\n",
						"deco": "E3etc1c4curl8CurlAuth",
						"char": 5,
						"kind": "alias"
					},
					{
						"name": "TimeCond",
						"line": 2196,
						"comment": " Time condition enumeration as an alias of $(ECXREF curl, CurlTimeCond)\n\n        $(WEB www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n",
						"deco": "E3etc1c4curl12CurlTimeCond",
						"char": 5,
						"kind": "alias"
					},
					{
						"endchar": 5,
						"name": "opCall",
						"line": 2201,
						"comment": "       Constructor taking the url as parameter.\n",
						"deco": "FAxaZS3std3net4curl4HTTP",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 2207,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 2260,
						"comment": "       Perform a http request.\n\n       After the HTTP client has been setup and possibly assigned callbacks the\n       $(D perform()) method will start performing the request towards the\n       specified server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 2294,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "url",
						"line": 2297,
						"comment": "The URL to specify the location of the resource.\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 2302,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "caInfo",
						"line": 2305,
						"comment": "Set the CA certificate bundle file to use for SSL peer verification\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "caFile",
								"deco": "Axa"
							}
						],
						"endline": 2308,
						"char": 20,
						"kind": "function"
					},
					{
						"name": "requestPause",
						"line": 2316,
						"comment": "Value to return from $(D onSend)/$(D onReceive) delegates in order to\n\npause a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "requestAbort",
						"line": 2319,
						"comment": "Value to return from onSend delegate in order to abort a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "isStopped",
						"line": 2324,
						"comment": "           True if the instance is stopped. A stopped instance is not usable.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "shutdown",
						"line": 2327,
						"comment": "Stop and invalidate this instance.\n",
						"deco": "FZv",
						"char": 14,
						"kind": "function"
					},
					{
						"name": "verbose",
						"line": 2332,
						"comment": " Set verbose.\n            This will print request information to stderr.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dataTimeout",
						"line": 2337,
						"comment": "Set timeout for activity on connection.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "operationTimeout",
						"line": 2342,
						"comment": " Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "connectTimeout",
						"line": 2345,
						"comment": "Set timeout for connecting.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxy",
						"line": 2352,
						"comment": " Proxy\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "host",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxyPort",
						"line": 2357,
						"comment": " Proxy port\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "CurlProxy",
						"line": 2360,
						"comment": "Type of proxy\n",
						"deco": "E3etc1c4curl9CurlProxy",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "proxyType",
						"line": 2365,
						"comment": " Proxy type\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n",
						"deco": "FNdE3etc1c4curl9CurlProxyZv",
						"parameters": [
							{
								"name": "type",
								"deco": "E3etc1c4curl9CurlProxy"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dnsTimeout",
						"line": 2368,
						"comment": "DNS lookup timeout.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 2381,
						"comment": " The network interface to use in form of the the IP of the interface.\n\n Example:\n ----\n theprotocol.netInterface = \"192.168.1.32\";\n theprotocol.netInterface = [ 192, 168, 1, 32 ];\n ----\n\n See: $(XREF socket, InternetAddress)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "i",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 2384,
						"comment": "ditto\n",
						"deco": "FNdxG4hZv",
						"parameters": [
							{
								"name": "i",
								"deco": "xG4h"
							}
						],
						"originalType": "@property void(const(ubyte)[4] i)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 2387,
						"comment": "ditto\n",
						"deco": "FNdC3std6socket15InternetAddressZv",
						"parameters": [
							{
								"name": "i",
								"deco": "C3std6socket15InternetAddress"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPort",
						"line": 2394,
						"comment": "           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPortRange",
						"line": 2403,
						"comment": "           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "range",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "tcpNoDelay",
						"line": 2408,
						"comment": " Set the tcp no-delay socket option on or off.\n            See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "setAuthentication",
						"line": 2425,
						"comment": "           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n",
						"deco": "FAxaAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							},
							{
								"name": "domain",
								"deco": "Axa",
								"default": "\"\""
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "setProxyAuthentication",
						"line": 2435,
						"comment": "           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "onSend",
						"line": 2467,
						"comment": " The event handler that gets called when data is needed for sending. The\n length of the $(D void[]) specifies the maximum number of bytes that can\n be sent.\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D .abortRequest) can be returned in order to abort the\n current request.\n The special value $(D .pauseRequest) can be returned in order to pause the\n current request.\n\n Example:\n ----\n import std.net.curl;\n string msg = \"Hello world\";\n auto client = HTTP(\"dlang.org\");\n client.onSend = delegate size_t(void[] data)\n {\n     auto m = cast(void[])msg;\n     size_t length = m.length > data.length ? data.length : m.length;\n     if (length == 0) return 0;\n     data[0..length] = m[0..length];\n     msg = msg[length..$];\n     return length;\n };\n client.perform();\n ----\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"originalType": "@property void(size_t delegate(void[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onReceive",
						"line": 2492,
						"comment": " The event handler that receives incoming data. Be sure to copy the\n incoming ubyte[] since it is not guaranteed to be valid after the\n callback returns.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value .pauseRequest can be returned in order to pause the\n current request.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto client = HTTP(\"dlang.org\");\n client.onReceive = (ubyte[] data)\n {\n     writeln(\"Got data\", to!(const(char)[])(data));\n     return data.length;\n };\n client.perform();\n ----\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"originalType": "@property void(size_t delegate(ubyte[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onProgress",
						"line": 2516,
						"comment": " Register an event handler that gets called to inform of\n upload/download progress.\n\n Callback_parameters:\n $(CALLBACK_PARAMS)\n\n Callback_returns: Return 0 to signal success, return non-zero to\n abort transfer.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto client = HTTP(\"dlang.org\");\n client.onProgress = delegate int(size_t dl, size_t dln, size_t ul, size_t ult)\n {\n     writeln(\"Progress: downloaded \", dln, \" of \", dl);\n     writeln(\"Progress: uploaded \", uln, \" of \", ul);\n };\n client.perform();\n ----\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearRequestHeaders",
						"line": 2522,
						"comment": " Clear all outgoing headers.\n",
						"deco": "FZv",
						"endline": 2528,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addRequestHeader",
						"line": 2543,
						"comment": " Add a header e.g. \"X-CustomField: Something is fishy\".\n\n There is no remove header functionality. Do a $(LREF clearRequestHeaders)\n and set the needed headers instead.\n\n Example:\n ---\n import std.net.curl;\n auto client = HTTP();\n client.addRequestHeader(\"X-Custom-ABC\", \"This is the custom value\");\n string content = get(\"dlang.org\", client);\n ---\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "Axa"
							},
							{
								"name": "value",
								"deco": "Axa"
							}
						],
						"endline": 2551,
						"char": 10,
						"kind": "function"
					},
					{
						"name": "defaultUserAgent",
						"line": 2557,
						"comment": " The default \"User-Agent\" value send with a request.\n It has the form \"Phobos-std.net.curl/$(I PHOBOS_VERSION) (libcurl/$(I CURL_VERSION))\"\n",
						"deco": "yAa",
						"originalType": "string",
						"char": 29,
						"kind": "variable",
						"storageClass": [
							"static",
							"immutable"
						]
					},
					{
						"endchar": 5,
						"name": "setUserAgent",
						"line": 2581,
						"comment": " Set the value of the user agent request header field.\n\n By default a request has it's \"User-Agent\" field set to $(LREF\n defaultUserAgent) even if $(D setUserAgent) was never called.  Pass\n an empty string to suppress the \"User-Agent\" field altogether.\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "userAgent",
								"deco": "Axa"
							}
						],
						"endline": 2584,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "responseHeaders",
						"line": 2589,
						"comment": " The headers read from a successful response.\n\n",
						"deco": "FNdZHAyaAya",
						"endline": 2592,
						"char": 30,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "method",
						"line": 2595,
						"comment": "HTTP method used.\n",
						"deco": "FNdE3std3net4curl4HTTP6MethodZv",
						"parameters": [
							{
								"name": "m",
								"deco": "E3std3net4curl4HTTP6Method"
							}
						],
						"endline": 2598,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "method",
						"line": 2601,
						"comment": "ditto\n",
						"deco": "FNdZE3std3net4curl4HTTP6Method",
						"endline": 2604,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "statusLine",
						"line": 2610,
						"comment": "       HTTP status line of last response. One call to perform may\n       result in several requests because of redirection.\n",
						"deco": "FNdZS3std3net4curl4HTTP10StatusLine",
						"endline": 2613,
						"char": 26,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setCookie",
						"line": 2616,
						"comment": "Set the active cookie string e.g. \"name1=value1;name2=value2\"\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "cookie",
								"deco": "Axa"
							}
						],
						"endline": 2619,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setCookieJar",
						"line": 2622,
						"comment": "Set a file path to where a cookie jar should be read/stored.\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "path",
								"deco": "Axa"
							}
						],
						"endline": 2627,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "flushCookieJar",
						"line": 2630,
						"comment": "Flush cookie jar to disk.\n",
						"deco": "FZv",
						"endline": 2633,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearSessionCookies",
						"line": 2636,
						"comment": "Clear session cookies.\n",
						"deco": "FZv",
						"endline": 2639,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearAllCookies",
						"line": 2642,
						"comment": "Clear all cookies.\n",
						"deco": "FZv",
						"endline": 2645,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setTimeCondition",
						"line": 2656,
						"comment": "       Set time condition on the request.\n\n       Params:\n       cond =  $(D CurlTimeCond.{none,ifmodsince,ifunmodsince,lastmod})\n       timestamp = Timestamp for the condition\n\n       $(WEB www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25, _RFC2616 Section 14.25)\n",
						"deco": "FE3etc1c4curl12CurlTimeCondS3std8datetime7SysTimeZv",
						"parameters": [
							{
								"name": "cond",
								"deco": "E3etc1c4curl12CurlTimeCond"
							},
							{
								"name": "timestamp",
								"deco": "S3std8datetime7SysTime"
							}
						],
						"endline": 2660,
						"originalType": "void(HTTP.TimeCond cond, SysTime timestamp)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "postData",
						"line": 2677,
						"comment": " Specifying data to post when not using the onSend callback.\n\n The data is NOT copied by the library.  Content-Type will default to\n application/octet-stream.  Data is not converted or encoded by this\n method.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto http = HTTP(\"http://www.mydomain.com\");\n http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n http.postData = [1,2,3,4,5];\n http.perform();\n ----\n",
						"deco": "FNdAxvZv",
						"parameters": [
							{
								"name": "data",
								"deco": "Axv"
							}
						],
						"endline": 2680,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "postData",
						"line": 2696,
						"comment": " Specifying data to post when not using the onSend callback.\n\n The data is NOT copied by the library.  Content-Type will default to\n text/plain.  Data is not converted or encoded by this method.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto http = HTTP(\"http://www.mydomain.com\");\n http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n http.postData = \"The quick....\";\n http.perform();\n ----\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "data",
								"deco": "Axa"
							}
						],
						"endline": 2699,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "setPostData",
						"line": 2719,
						"comment": " Specify data to post when not using the onSend callback, with\n user-specified Content-Type.\n Params:\n  data = Data to post.\n  contentType = MIME type of the data, for example, \"text/plain\" or\n      \"application/octet-stream\". See also:\n      $(LINK2 http://en.wikipedia.org/wiki/Internet_media_type,\n      Internet media type) on Wikipedia.\n -----\n import std.net.curl;\n auto http = HTTP(\"http://onlineform.example.com\");\n auto data = \"app=login&username=bob&password=s00perS3kret\";\n http.setPostData(data, \"application/x-www-form-urlencoded\");\n http.onReceive = (ubyte[] data) { return data.length; };\n http.perform();\n -----\n",
						"deco": "FAxvAyaZv",
						"parameters": [
							{
								"name": "data",
								"deco": "Axv"
							},
							{
								"name": "contentType",
								"deco": "Aya"
							}
						],
						"endline": 2728,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceiveHeader",
						"line": 2760,
						"comment": " Set the event handler that receives incoming headers.\n\n The callback will receive a header field key, value as parameter. The\n $(D const(char)[]) arrays are not valid after the delegate has returned.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n auto http = HTTP(\"dlang.org\");\n http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };\n http.onReceiveHeader = (in char[] key, in char[] value) { writeln(key, \" = \", value); };\n http.perform();\n ----\n",
						"deco": "FNdDFxAaxAaZvZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFxAaxAaZv"
							}
						],
						"endline": 2764,
						"originalType": "@property void(void delegate(in char[] key, in char[] value) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceiveStatusLine",
						"line": 2774,
						"comment": "       Callback for each received StatusLine.\n\n       Notice that several callbacks can be done for each call to\n       $(D perform()) due to redirections.\n\n       See_Also: $(LREF StatusLine)\n",
						"deco": "FNdDFS3std3net4curl4HTTP10StatusLineZvZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFS3std3net4curl4HTTP10StatusLineZv"
							}
						],
						"endline": 2777,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "contentLength",
						"line": 2784,
						"comment": "       The content length in bytes when using request that has content\n       e.g. POST/PUT and not using chunked transfer. Is set as the\n       \"Content-Length\" header.  Set to size_t.max to reset to chunked transfer.\n",
						"deco": "FNdmZv",
						"parameters": [
							{
								"name": "len",
								"deco": "m"
							}
						],
						"endline": 2808,
						"originalType": "@property void(size_t len)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "authenticationMethod",
						"line": 2813,
						"comment": "       Authentication method as specified in $(LREF AuthMethod).\n",
						"deco": "FNdE3etc1c4curl8CurlAuthZv",
						"parameters": [
							{
								"name": "authMethod",
								"deco": "E3etc1c4curl8CurlAuth"
							}
						],
						"endline": 2816,
						"originalType": "@property void(AuthMethod authMethod)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "maxRedirects",
						"line": 2822,
						"comment": "       Set max allowed redirections using the location header.\n       uint.max for infinite.\n",
						"deco": "FNdkZv",
						"parameters": [
							{
								"name": "maxRedirs",
								"deco": "k"
							}
						],
						"endline": 2834,
						"char": 20,
						"kind": "function"
					},
					{
						"members": [
							{
								"name": "head",
								"line": 2842,
								"value": "1",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "get",
								"line": 2843,
								"value": "2",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "post",
								"line": 2844,
								"value": "3",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "put",
								"line": 2845,
								"value": "4",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "del",
								"line": 2846,
								"value": "5",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "options",
								"line": 2847,
								"value": "6",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "trace",
								"line": 2848,
								"value": "7",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							},
							{
								"name": "connect",
								"line": 2849,
								"value": "8",
								"comment": "\n",
								"char": 9,
								"kind": "enum member"
							}
						],
						"name": "Method",
						"line": 2839,
						"comment": " <a name=\"HTTP.Method\"/ >The standard HTTP methods :\n  $(WEB www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1, _RFC2616 Section 5.1.1)\n",
						"baseDeco": "i",
						"char": 5,
						"kind": "enum"
					},
					{
						"name": "StatusLine",
						"line": 2858,
						"comment": "       HTTP status line ie. the first line returned in an HTTP response.\n\n       If authentication or redirections are done then the status will be for\n       the last response received.\n",
						"members": [
							{
								"offset": 0,
								"name": "majorVersion",
								"line": 2860,
								"comment": "Major HTTP version ie. 1 in HTTP/1.0.\n",
								"deco": "t",
								"char": 16,
								"kind": "variable"
							},
							{
								"offset": 2,
								"name": "minorVersion",
								"line": 2861,
								"comment": "Minor HTTP version ie. 0 in HTTP/1.0.\n",
								"deco": "t",
								"char": 16,
								"kind": "variable"
							},
							{
								"offset": 4,
								"name": "code",
								"line": 2862,
								"comment": "HTTP status line code e.g. 200.\n",
								"deco": "t",
								"char": 16,
								"kind": "variable"
							},
							{
								"offset": 8,
								"name": "reason",
								"line": 2863,
								"comment": "HTTP status line reason string.\n",
								"deco": "Aya",
								"char": 16,
								"kind": "variable"
							},
							{
								"endchar": 9,
								"name": "reset",
								"line": 2866,
								"comment": "Reset this status line\n",
								"deco": "FNfZv",
								"endline": 2872,
								"char": 20,
								"kind": "function"
							},
							{
								"endchar": 9,
								"name": "toString",
								"line": 2875,
								"comment": "\n",
								"deco": "FZAya",
								"endline": 2879,
								"char": 16,
								"kind": "function"
							}
						],
						"char": 5,
						"kind": "struct"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "FTP",
				"line": 2889,
				"comment": "   FTP client functionality.\n\n   See_Also: $(WEB tools.ietf.org/html/rfc959, RFC959)\n",
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 2913,
						"comment": "       FTP access to the specified url.\n",
						"deco": "FAxaZS3std3net4curl3FTP",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 2919,
						"char": 16,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 2965,
						"comment": "       Performs the ftp request as it has been configured.\n\n       After a FTP client has been setup and possibly assigned callbacks the $(D\n       perform()) method will start performing the actual communication with the\n       server.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 2968,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "url",
						"line": 2971,
						"comment": "The URL to specify the location of the resource.\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 2976,
						"char": 20,
						"kind": "function"
					},
					{
						"name": "requestPause",
						"line": 2984,
						"comment": "Value to return from $(D onSend)/$(D onReceive) delegates in order to\n\npause a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "requestAbort",
						"line": 2987,
						"comment": "Value to return from onSend delegate in order to abort a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "isStopped",
						"line": 2992,
						"comment": "           True if the instance is stopped. A stopped instance is not usable.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "shutdown",
						"line": 2995,
						"comment": "Stop and invalidate this instance.\n",
						"deco": "FZv",
						"char": 14,
						"kind": "function"
					},
					{
						"name": "verbose",
						"line": 3000,
						"comment": " Set verbose.\n            This will print request information to stderr.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dataTimeout",
						"line": 3005,
						"comment": "Set timeout for activity on connection.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "operationTimeout",
						"line": 3010,
						"comment": " Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "connectTimeout",
						"line": 3013,
						"comment": "Set timeout for connecting.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxy",
						"line": 3020,
						"comment": " Proxy\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "host",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxyPort",
						"line": 3025,
						"comment": " Proxy port\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "CurlProxy",
						"line": 3028,
						"comment": "Type of proxy\n",
						"deco": "E3etc1c4curl9CurlProxy",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "proxyType",
						"line": 3033,
						"comment": " Proxy type\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n",
						"deco": "FNdE3etc1c4curl9CurlProxyZv",
						"parameters": [
							{
								"name": "type",
								"deco": "E3etc1c4curl9CurlProxy"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dnsTimeout",
						"line": 3036,
						"comment": "DNS lookup timeout.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3049,
						"comment": " The network interface to use in form of the the IP of the interface.\n\n Example:\n ----\n theprotocol.netInterface = \"192.168.1.32\";\n theprotocol.netInterface = [ 192, 168, 1, 32 ];\n ----\n\n See: $(XREF socket, InternetAddress)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "i",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3052,
						"comment": "ditto\n",
						"deco": "FNdxG4hZv",
						"parameters": [
							{
								"name": "i",
								"deco": "xG4h"
							}
						],
						"originalType": "@property void(const(ubyte)[4] i)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3055,
						"comment": "ditto\n",
						"deco": "FNdC3std6socket15InternetAddressZv",
						"parameters": [
							{
								"name": "i",
								"deco": "C3std6socket15InternetAddress"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPort",
						"line": 3062,
						"comment": "           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPortRange",
						"line": 3071,
						"comment": "           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "range",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "tcpNoDelay",
						"line": 3076,
						"comment": " Set the tcp no-delay socket option on or off.\n            See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "setAuthentication",
						"line": 3093,
						"comment": "           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n",
						"deco": "FAxaAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							},
							{
								"name": "domain",
								"deco": "Axa",
								"default": "\"\""
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "setProxyAuthentication",
						"line": 3103,
						"comment": "           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "onSend",
						"line": 3119,
						"comment": " The event handler that gets called when data is needed for sending. The\n length of the $(D void[]) specifies the maximum number of bytes that can\n be sent.\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D .abortRequest) can be returned in order to abort the\n current request.\n The special value $(D .pauseRequest) can be returned in order to pause the\n current request.\n\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"originalType": "@property void(size_t delegate(void[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onReceive",
						"line": 3133,
						"comment": " The event handler that receives incoming data. Be sure to copy the\n incoming ubyte[] since it is not guaranteed to be valid after the\n callback returns.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value .pauseRequest can be returned in order to pause the\n current request.\n\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"originalType": "@property void(size_t delegate(ubyte[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onProgress",
						"line": 3145,
						"comment": " The event handler that gets called to inform of upload/download progress.\n\n Callback_parameters:\n $(CALLBACK_PARAMS)\n\n Callback_returns:\n Return 0 from the callback to signal success, return non-zero to\n abort transfer.\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearCommands",
						"line": 3151,
						"comment": " Clear all commands send to ftp server.\n",
						"deco": "FZv",
						"endline": 3157,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "addCommand",
						"line": 3173,
						"comment": " Add a command to send to ftp server.\n\n There is no remove command functionality. Do a $(LREF clearCommands) and\n set the needed commands instead.\n\n Example:\n ---\n import std.net.curl;\n auto client = FTP();\n client.addCommand(\"RNFR my_file.txt\");\n client.addCommand(\"RNTO my_renamed_file.txt\");\n upload(\"my_file.txt\", \"ftp.digitalmars.com\", client);\n ---\n",
						"deco": "FAxaZv",
						"parameters": [
							{
								"name": "command",
								"deco": "Axa"
							}
						],
						"endline": 3178,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "encoding",
						"line": 3181,
						"comment": "Connection encoding. Defaults to ISO-8859-1.\n",
						"deco": "FNdAyaZv",
						"parameters": [
							{
								"name": "name",
								"deco": "Aya"
							}
						],
						"endline": 3184,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "encoding",
						"line": 3187,
						"comment": "ditto\n",
						"deco": "FNdZAya",
						"endline": 3190,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "contentLength",
						"line": 3195,
						"comment": "       The content length in bytes of the ftp data.\n",
						"deco": "FNdmZv",
						"parameters": [
							{
								"name": "len",
								"deco": "m"
							}
						],
						"endline": 3198,
						"originalType": "@property void(size_t len)",
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "SMTP",
				"line": 3219,
				"comment": " Basic SMTP protocol support.\n\n Example:\n ---\n import std.net.curl;\n\n // Send an email with SMTPS\n auto smtp = SMTP(\"smtps://smtp.gmail.com\");\n smtp.setAuthentication(\"from.addr@gmail.com\", \"password\");\n smtp.mailTo = [\"<to.addr@gmail.com>\"];\n smtp.mailFrom = \"<from.addr@gmail.com>\";\n smtp.message = \"Example Message\";\n smtp.perform();\n ---\n\n See_Also: $(WEB www.ietf.org/rfc/rfc2821.txt, RFC2821)\n",
				"members": [
					{
						"endchar": 5,
						"name": "opCall",
						"line": 3255,
						"comment": "        Sets to the URL of the SMTP server.\n",
						"deco": "FAxaZS3std3net4curl4SMTP",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 3261,
						"char": 17,
						"kind": "function",
						"storageClass": [
							"static"
						]
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 3296,
						"comment": "        Performs the request as configured.\n        Params:\n        throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 3299,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "url",
						"line": 3302,
						"comment": "The URL to specify the location of the resource.\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "url",
								"deco": "Axa"
							}
						],
						"endline": 3316,
						"char": 20,
						"kind": "function"
					},
					{
						"name": "requestPause",
						"line": 3333,
						"comment": "Value to return from $(D onSend)/$(D onReceive) delegates in order to\n\npause a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "requestAbort",
						"line": 3336,
						"comment": "Value to return from onSend delegate in order to abort a request\n",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "isStopped",
						"line": 3341,
						"comment": "           True if the instance is stopped. A stopped instance is not usable.\n",
						"deco": "FNdZb",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "shutdown",
						"line": 3344,
						"comment": "Stop and invalidate this instance.\n",
						"deco": "FZv",
						"char": 14,
						"kind": "function"
					},
					{
						"name": "verbose",
						"line": 3349,
						"comment": " Set verbose.\n            This will print request information to stderr.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dataTimeout",
						"line": 3354,
						"comment": "Set timeout for activity on connection.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "operationTimeout",
						"line": 3359,
						"comment": " Set maximum time an operation is allowed to take.\n            This includes dns resolution, connecting, data transfer, etc.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "connectTimeout",
						"line": 3362,
						"comment": "Set timeout for connecting.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxy",
						"line": 3369,
						"comment": " Proxy\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "host",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "proxyPort",
						"line": 3374,
						"comment": " Proxy port\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT, _proxy_port)\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "CurlProxy",
						"line": 3377,
						"comment": "Type of proxy\n",
						"deco": "E3etc1c4curl9CurlProxy",
						"char": 9,
						"kind": "alias"
					},
					{
						"name": "proxyType",
						"line": 3382,
						"comment": " Proxy type\n  See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY, _proxy_type)\n",
						"deco": "FNdE3etc1c4curl9CurlProxyZv",
						"parameters": [
							{
								"name": "type",
								"deco": "E3etc1c4curl9CurlProxy"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "dnsTimeout",
						"line": 3385,
						"comment": "DNS lookup timeout.\n",
						"deco": "FNdS4core4time8DurationZv",
						"parameters": [
							{
								"name": "d",
								"deco": "S4core4time8Duration"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3398,
						"comment": " The network interface to use in form of the the IP of the interface.\n\n Example:\n ----\n theprotocol.netInterface = \"192.168.1.32\";\n theprotocol.netInterface = [ 192, 168, 1, 32 ];\n ----\n\n See: $(XREF socket, InternetAddress)\n",
						"deco": "FNdAxaZv",
						"parameters": [
							{
								"name": "i",
								"deco": "Axa"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3401,
						"comment": "ditto\n",
						"deco": "FNdxG4hZv",
						"parameters": [
							{
								"name": "i",
								"deco": "xG4h"
							}
						],
						"originalType": "@property void(const(ubyte)[4] i)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "netInterface",
						"line": 3404,
						"comment": "ditto\n",
						"deco": "FNdC3std6socket15InternetAddressZv",
						"parameters": [
							{
								"name": "i",
								"deco": "C3std6socket15InternetAddress"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPort",
						"line": 3411,
						"comment": "           Set the local outgoing port to use.\n           Params:\n           port = the first outgoing port number to try and use\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "port",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "localPortRange",
						"line": 3420,
						"comment": "           Set the local outgoing port range to use.\n           This can be used together with the localPort property.\n           Params:\n           range = if the first port is occupied then try this many\n           port number forwards\n",
						"deco": "FNdtZv",
						"parameters": [
							{
								"name": "range",
								"deco": "t"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "tcpNoDelay",
						"line": 3425,
						"comment": " Set the tcp no-delay socket option on or off.\n            See: $(WEB curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY, nodelay)\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "on",
								"deco": "b"
							}
						],
						"char": 24,
						"kind": "function"
					},
					{
						"name": "setAuthentication",
						"line": 3442,
						"comment": "           Set the user name, password and optionally domain for authentication\n           purposes.\n\n           Some protocols may need authentication in some cases. Use this\n           function to provide credentials.\n\n           Params:\n           username = the username\n           password = the password\n           domain = used for NTLM authentication only and is set to the NTLM domain\n           name\n",
						"deco": "FAxaAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							},
							{
								"name": "domain",
								"deco": "Axa",
								"default": "\"\""
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "setProxyAuthentication",
						"line": 3452,
						"comment": "           Set the user name and password for proxy authentication.\n\n           Params:\n           username = the username\n           password = the password\n",
						"deco": "FAxaAxaZv",
						"parameters": [
							{
								"name": "username",
								"deco": "Axa"
							},
							{
								"name": "password",
								"deco": "Axa"
							}
						],
						"char": 14,
						"kind": "function"
					},
					{
						"name": "onSend",
						"line": 3467,
						"comment": " The event handler that gets called when data is needed for sending. The\n length of the $(D void[]) specifies the maximum number of bytes that can\n be sent.\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D .abortRequest) can be returned in order to abort the\n current request.\n The special value $(D .pauseRequest) can be returned in order to pause the\n current request.\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"originalType": "@property void(size_t delegate(void[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onReceive",
						"line": 3480,
						"comment": " The event handler that receives incoming data. Be sure to copy the\n incoming ubyte[] since it is not guaranteed to be valid after the\n callback returns.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value .pauseRequest can be returned in order to pause the\n current request.\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"originalType": "@property void(size_t delegate(ubyte[]) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"name": "onProgress",
						"line": 3492,
						"comment": " The event handler that gets called to inform of upload/download progress.\n\n Callback_parameters:\n $(CALLBACK_PARAMS)\n\n Callback_returns:\n Return 0 from the callback to signal success, return non-zero to\n abort transfer.\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 24,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "mailFrom",
								"line": 3499,
								"type": "@property void(const(char)[] sender)",
								"parameters": [
									{
										"name": "sender",
										"type": "const(char)[]"
									}
								],
								"endline": 3503,
								"char": 20,
								"kind": "function"
							}
						],
						"name": "mailFrom",
						"line": 3499,
						"comment": "        Setter for the sender's email address.\n",
						"parameters": [],
						"char": 20,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "mailTo",
								"line": 3508,
								"type": "void(const(char)[][] recipients...)",
								"parameters": [
									{
										"name": "recipients",
										"type": "const(char)[][]"
									}
								],
								"endline": 3519,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "mailTo",
						"line": 3508,
						"comment": "        Setter for the recipient email addresses.\n",
						"parameters": [],
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "message",
						"line": 3525,
						"comment": "        Sets the message body text.\n",
						"deco": "FNdAyaZv",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							}
						],
						"endline": 3528,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3544,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std3net4curl13CurlException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 3550,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "CurlException",
				"line": 3534,
				"comment": "    Exception thrown on errors in std.net.curl functions.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"endchar": 5,
						"name": "this",
						"line": 3566,
						"comment": "        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n",
						"deco": "FNaNbNfAyaAyamC6object9ThrowableZC3std3net4curl20CurlTimeoutException",
						"parameters": [
							{
								"name": "msg",
								"deco": "Aya"
							},
							{
								"name": "file",
								"deco": "Aya",
								"default": "__FILE__"
							},
							{
								"name": "line",
								"deco": "m",
								"default": "cast(ulong)__LINE__"
							},
							{
								"name": "next",
								"deco": "C6object9Throwable",
								"default": "null"
							}
						],
						"endline": 3572,
						"originalType": "pure nothrow @safe (string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
						"char": 5,
						"kind": "constructor"
					}
				],
				"name": "CurlTimeoutException",
				"line": 3556,
				"comment": "    Exception thrown on timeout errors in std.net.curl functions.\n",
				"base": "std.net.curl.CurlException",
				"char": 1,
				"kind": "class"
			},
			{
				"name": "CurlCode",
				"line": 3576,
				"comment": "Equal to $(ECXREF curl, CURLcode)\n",
				"deco": "i",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "ThrowOnError",
				"line": 3580,
				"comment": "Flag to specify whether or not an exception is thrown on error.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"name": "Curl",
				"line": 3592,
				"comment": "  Wrapper to provide a better interface to libcurl than using the plain C API.\n  It is recommended to use the $(D HTTP)/$(D FTP) etc. structs instead unless\n  raw access to libcurl is needed.\n\n  Warning: This struct uses interior pointers for callbacks. Only allocate it\n  on the stack if you never move or copy it. This also means passing by reference\n  when passing Curl to other functions. Otherwise always allocate on\n  the heap.\n",
				"members": [
					{
						"endchar": 5,
						"name": "initialize",
						"line": 3628,
						"comment": "       Initialize the instance by creating a working curl handle.\n",
						"deco": "FZv",
						"endline": 3635,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dup",
						"line": 3645,
						"comment": "       Duplicate this handle.\n\n       The new handle will have all options set as the one it was duplicated\n       from. An exception to this is that all options that cannot be shared\n       across threads are reset thereby making it safe to use the duplicate\n       in a new thread.\n",
						"deco": "FZS3std3net4curl4Curl",
						"endline": 3698,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "shutdown",
						"line": 3729,
						"comment": "        Stop and invalidate this curl instance.\n        Warning: Do not call this from inside a callback handler e.g. $(D onReceive).\n",
						"deco": "FZv",
						"endline": 3735,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "pause",
						"line": 3740,
						"comment": "       Pausing and continuing transfers.\n",
						"deco": "FbbZv",
						"parameters": [
							{
								"name": "sendingPaused",
								"deco": "b"
							},
							{
								"name": "receivingPaused",
								"deco": "b"
							}
						],
						"endline": 3746,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "set",
						"line": 3754,
						"comment": "       Set a string curl option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n       value = The string\n",
						"deco": "FE3etc1c4curl10CurlOptionAxaZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							},
							{
								"name": "value",
								"deco": "Axa"
							}
						],
						"endline": 3758,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "set",
						"line": 3766,
						"comment": "       Set a long curl option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n       value = The long\n",
						"deco": "FE3etc1c4curl10CurlOptionlZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							},
							{
								"name": "value",
								"deco": "l"
							}
						],
						"endline": 3770,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "set",
						"line": 3778,
						"comment": "       Set a void* curl option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n       value = The pointer\n",
						"deco": "FE3etc1c4curl10CurlOptionPvZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							},
							{
								"name": "value",
								"deco": "Pv"
							}
						],
						"endline": 3782,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clear",
						"line": 3789,
						"comment": "       Clear a pointer option.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n",
						"deco": "FE3etc1c4curl10CurlOptionZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							}
						],
						"endline": 3793,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "clearIfSupported",
						"line": 3801,
						"comment": "       Clear a pointer option. Does not raise an exception if the underlying\n       libcurl does not support the option. Use sparingly.\n       Params:\n       option = A $(ECXREF curl, CurlOption) as found in the curl documentation\n",
						"deco": "FE3etc1c4curl10CurlOptionZv",
						"parameters": [
							{
								"name": "option",
								"deco": "E3etc1c4curl10CurlOption"
							}
						],
						"endline": 3809,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "perform",
						"line": 3818,
						"comment": "       perform the curl request by doing the HTTP,FTP etc. as it has\n       been setup beforehand.\n\n       Params:\n       throwOnError = whether to throw an exception or return a CurlCode on error\n",
						"deco": "FE3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4FlagZi",
						"parameters": [
							{
								"name": "throwOnError",
								"deco": "E3std8typecons41__T4FlagVAyaa12_7468726f774f6e4572726f72Z4Flag",
								"default": "cast(Flag)true"
							}
						],
						"endline": 3825,
						"originalType": "CurlCode(ThrowOnError throwOnError = ThrowOnError.yes)",
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceive",
						"line": 3858,
						"comment": " The event handler that receives incoming data.\n\n Params:\n callback = the callback that receives the $(D ubyte[]) data.\n Be sure to copy the incoming data and not store\n a slice.\n\n Returns:\n The callback returns the incoming bytes read. If not the entire array is\n the request will abort.\n The special value HTTP.pauseRequest can be returned in order to pause the\n current request.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onReceive = (ubyte[] data) { writeln(\"Got data\", to!(const(char)[])(data)); return data.length;};\n curl.perform();\n ----\n",
						"deco": "FNdDFAhZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAhZm"
							}
						],
						"endline": 3867,
						"originalType": "@property void(size_t delegate(InData) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onReceiveHeader",
						"line": 3889,
						"comment": " The event handler that receives incoming headers for protocols\n that uses headers.\n\n Params:\n callback = the callback that receives the header string.\n Make sure the callback copies the incoming params if\n it needs to store it because they are references into\n the backend and may very likely change.\n\n Example:\n ----\n import std.net.curl, std.stdio;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onReceiveHeader = (in char[] header) { writeln(header); };\n curl.perform();\n ----\n",
						"deco": "FNdDFxAaZvZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFxAaZv"
							}
						],
						"endline": 3900,
						"originalType": "@property void(void delegate(in char[]) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onSend",
						"line": 3936,
						"comment": " The event handler that gets called when data is needed for sending.\n\n Params:\n callback = the callback that has a $(D void[]) buffer to be filled\n\n Returns:\n The callback returns the number of elements in the buffer that have been\n filled and are ready to send.\n The special value $(D Curl.abortRequest) can be returned in\n order to abort the current request.\n The special value $(D Curl.pauseRequest) can be returned in order to\n pause the current request.\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n\n string msg = \"Hello world\";\n curl.onSend = (void[] data)\n {\n     auto m = cast(void[])msg;\n     size_t length = m.length > data.length ? data.length : m.length;\n     if (length == 0) return 0;\n     data[0..length] = m[0..length];\n     msg = msg[length..$];\n     return length;\n };\n curl.perform();\n ----\n",
						"deco": "FNdDFAvZmZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFAvZm"
							}
						],
						"endline": 3945,
						"originalType": "@property void(size_t delegate(OutData) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onSeek",
						"line": 3972,
						"comment": " The event handler that gets called when the curl backend needs to seek\n the data to be sent.\n\n Params:\n callback = the callback that receives a seek offset and a seek position\n            $(ECXREF curl, CurlSeekPos)\n\n Returns:\n The callback returns the success state of the seeking\n $(ECXREF curl, CurlSeek)\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onSeek = (long p, CurlSeekPos sp)\n {\n     return CurlSeek.cantseek;\n };\n curl.perform();\n ----\n",
						"deco": "FNdDFlE3etc1c4curl11CurlSeekPosZE3etc1c4curl8CurlSeekZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFlE3etc1c4curl11CurlSeekPosZE3etc1c4curl8CurlSeek"
							}
						],
						"endline": 3981,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onSocketOption",
						"line": 4006,
						"comment": " The event handler that gets called when the net socket has been created\n but a $(D connect()) call has not yet been done. This makes it possible to set\n misc. socket options.\n\n Params:\n callback = the callback that receives the socket and socket type\n $(ECXREF curl, CurlSockType)\n\n Returns:\n Return 0 from the callback to signal success, return 1 to signal error\n and make curl close the socket\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onSocketOption = delegate int(curl_socket_t s, CurlSockType t) { /+ do stuff +/ };\n curl.perform();\n ----\n",
						"deco": "FNdDFE3std6socket8socket_tE3etc1c4curl12CurlSockTypeZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFE3std6socket8socket_tE3etc1c4curl12CurlSockTypeZi"
							}
						],
						"endline": 4018,
						"originalType": "@property void(int delegate(curl_socket_t, CurlSockType) callback)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "onProgress",
						"line": 4046,
						"comment": " The event handler that gets called to inform of upload/download progress.\n\n Params:\n callback = the callback that receives the (total bytes to download,\n currently downloaded bytes, total bytes to upload, currently uploaded\n bytes).\n\n Returns:\n Return 0 from the callback to signal success, return non-zero to abort\n transfer\n\n Example:\n ----\n import std.net.curl;\n Curl curl;\n curl.initialize();\n curl.set(CurlOption.url, \"http://dlang.org\");\n curl.onProgress = delegate int(size_t dltotal, size_t dlnow, size_t ultotal, size_t uln)\n {\n     writeln(\"Progress: downloaded bytes \", dlnow, \" of \", dltotal);\n     writeln(\"Progress: uploaded bytes \", ulnow, \" of \", ultotal);\n     curl.perform();\n };\n ----\n",
						"deco": "FNdDFmmmmZiZv",
						"parameters": [
							{
								"name": "callback",
								"deco": "DFmmmmZi"
							}
						],
						"endline": 4060,
						"originalType": "@property void(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback)",
						"char": 20,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			}
		],
		"comment": "Networking client functionality as provided by $(WEB _curl.haxx.se/libcurl,\nlibcurl). The libcurl library must be installed on the system in order to use\nthis module.\n\n$(SCRIPT inhibitQuickIndex = 1;)\n\n$(DIVC quickindex,\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW High level) $(TD $(MYREF download) $(MYREF upload) $(MYREF get)\n$(MYREF post) $(MYREF put) $(MYREF del) $(MYREF options) $(MYREF trace)\n$(MYREF connect) $(MYREF byLine) $(MYREF byChunk)\n$(MYREF byLineAsync) $(MYREF byChunkAsync) )\n)\n$(TR $(TDNW Low level) $(TD $(MYREF HTTP) $(MYREF FTP) $(MYREF\nSMTP) )\n)\n)\n)\n\nNote:\nYou may need to link to the $(B curl) library, e.g. by adding $(D \"libs\": [\"curl\"])\nto your $(B dub.json) file if you are using $(LINK2 http://code.dlang.org, DUB).\n\nWindows x86 note:\nA DMD compatible libcurl static library can be downloaded from the dlang.org\n$(LINK2 http://dlang.org/download.html, download page).\n\nCompared to using libcurl directly this module allows simpler client code for\ncommon uses, requires no unsafe operations, and integrates better with the rest\nof the language. Futhermore it provides <a href=\"std_range.html\">$(D range)</a>\naccess to protocols supported by libcurl both synchronously and asynchronously.\n\nA high level and a low level API are available. The high level API is built\nentirely on top of the low level one.\n\nThe high level API is for commonly used functionality such as HTTP/FTP get. The\n$(LREF byLineAsync) and $(LREF byChunkAsync) provides asynchronous <a\nhref=\"std_range.html\">$(D ranges)</a> that performs the request in another\nthread while handling a line/chunk in the current thread.\n\nThe low level API allows for streaming and other advanced features.\n\n$(BOOKTABLE Cheat Sheet,\n$(TR $(TH Function Name) $(TH Description)\n)\n$(LEADINGROW High level)\n$(TR $(TDNW $(LREF download)) $(TD $(D\ndownload(\"ftp.digitalmars.com/sieve.ds\", \"/tmp/downloaded-ftp-file\"))\ndownloads file from URL to file system.)\n)\n$(TR $(TDNW $(LREF upload)) $(TD $(D\nupload(\"/tmp/downloaded-ftp-file\", \"ftp.digitalmars.com/sieve.ds\");)\nuploads file from file system to URL.)\n)\n$(TR $(TDNW $(LREF get)) $(TD $(D\nget(\"dlang.org\")) returns a string containing the dlang.org web page.)\n)\n$(TR $(TDNW $(LREF put)) $(TD $(D\nput(\"dlang.org\", \"Hi\")) returns a string containing\nthe dlang.org web page. after a HTTP PUT of \"hi\")\n)\n$(TR $(TDNW $(LREF post)) $(TD $(D\npost(\"dlang.org\", \"Hi\")) returns a string containing\nthe dlang.org web page. after a HTTP POST of \"hi\")\n)\n$(TR $(TDNW $(LREF byLine)) $(TD $(D\nbyLine(\"dlang.org\")) returns a range of strings containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byChunk)) $(TD $(D\nbyChunk(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page.)\n)\n$(TR $(TDNW $(LREF byLineAsync)) $(TD $(D\nbyLineAsync(\"dlang.org\")) returns a range of strings containing the dlang.org web\n page asynchronously.)\n)\n$(TR $(TDNW $(LREF byChunkAsync)) $(TD $(D\nbyChunkAsync(\"dlang.org\", 10)) returns a range of ubyte[10] containing the\ndlang.org web page asynchronously.)\n)\n$(LEADINGROW Low level\n)\n$(TR $(TDNW $(LREF HTTP)) $(TD $(D HTTP) struct for advanced usage))\n$(TR $(TDNW $(LREF FTP)) $(TD $(D FTP) struct for advanced usage))\n$(TR $(TDNW $(LREF SMTP)) $(TD $(D SMTP) struct for advanced usage))\n)\n\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// Return a string containing the content specified by an URL\nstring content = get(\"dlang.org\");\n\n// Post data and return a string containing the content specified by an URL\nstring content = post(\"mydomain.com/here.cgi\", \"post data\");\n\n// Get content of file from ftp server\nstring content = get(\"ftp.digitalmars.com/sieve.ds\");\n\n// Post and print out content line by line. The request is done in another thread.\nforeach (line; byLineAsync(\"dlang.org\", \"Post data\"))\n    writeln(line);\n\n// Get using a line range and proxy settings\nauto client = HTTP();\nclient.proxy = \"1.2.3.4\";\nforeach (line; byLine(\"dlang.org\", client))\n    writeln(line);\n---\n\nFor more control than the high level functions provide, use the low level API:\n\nExample:\n---\nimport std.net.curl, std.stdio;\n\n// GET with custom data receivers\nauto http = HTTP(\"dlang.org\");\nhttp.onReceiveHeader =\n    (in char[] key, in char[] value) { writeln(key, \": \", value); };\nhttp.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };\nhttp.perform();\n---\n\nFirst, an instance of the reference-counted HTTP struct is created. Then the\ncustom delegates are set. These will be called whenever the HTTP instance\nreceives a header and a data buffer, respectively. In this simple example, the\nheaders are written to stdout and the data is ignored. If the request should be\nstopped before it has finished then return something less than data.length from\nthe onReceive callback. See $(LREF onReceiveHeader)/$(LREF onReceive) for more\ninformation. Finally the HTTP request is effected by calling perform(), which is\nsynchronous.\n\nSource: $(PHOBOSSRC std/net/_curl.d)\n\nCopyright: Copyright Jonas Drewsen 2011-2012\nLicense: $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors: Jonas Drewsen. Some of the SMTP code contributed by Jimmy Cao.\n\nCredits: The functionally is based on $(WEB _curl.haxx.se/libcurl, libcurl).\n         LibCurl is licensed under an MIT/X derivative license.\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/net/isemail.d",
		"name": "std.net.isemail",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "isEmail",
						"line": 59,
						"type": "EmailStatus(const(Char)[] email, CheckDns checkDNS = CheckDns.no, EmailStatusCode errorLevel = EmailStatusCode.none)",
						"parameters": [
							{
								"name": "email",
								"type": "const(Char)[]"
							},
							{
								"name": "checkDNS",
								"type": "CheckDns",
								"default": "CheckDns.no"
							},
							{
								"name": "errorLevel",
								"type": "EmailStatusCode",
								"default": "EmailStatusCode.none"
							}
						],
						"endline": 763,
						"char": 13,
						"kind": "function"
					}
				],
				"name": "isEmail",
				"line": 59,
				"comment": " Check that an email address conforms to RFCs 5321, 5322 and others.\n\n As of Version 3.0, we are now distinguishing clearly between a Mailbox as defined\n by RFC 5321 and an addr-spec as defined by RFC 5322. Depending on the context,\n either can be regarded as a valid email address. The RFC 5321 Mailbox specification\n is more restrictive (comments, white space and obsolete forms are not allowed).\n\n Note: The DNS check is currently not implemented.\n\n Params:\n     email = The email address to check\n     checkDNS = If CheckDns.yes then a DNS check for MX records will be made\n     errorLevel = Determines the boundary between valid and invalid addresses.\n                  Status codes above this number will be returned as-is,\n                  status codes below will be returned as EmailStatusCode.valid.\n                  Thus the calling program can simply look for EmailStatusCode.valid\n                  if it is only interested in whether an address is valid or not. The\n                  $(D_PARAM errorLevel) will determine how \"picky\" isEmail() is about\n                  the address.\n\n                  If omitted or passed as EmailStatusCode.none then isEmail() will\n                  not perform any finer grained error checking and an address is\n                  either considered valid or not. Email status code will either be\n                  EmailStatusCode.valid or EmailStatusCode.error.\n\n Returns: an EmailStatus, indicating the status of the email address.\n",
				"parameters": [
					{
						"name": "Char",
						"kind": "type"
					}
				],
				"constraint": "isSomeChar!Char",
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 1236,
						"value": "0",
						"comment": "Does not perform DNS checking\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "yes",
						"line": 1239,
						"value": "1",
						"comment": "Performs DNS checking\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CheckDns",
				"line": 1233,
				"comment": "Enum for indicating if the isEmail function should perform a DNS check or not.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "EmailStatus",
				"line": 1243,
				"comment": "This struct represents the status of an email address\n",
				"members": [
					{
						"endchar": 5,
						"name": "valid",
						"line": 1272,
						"comment": "Indicates if the email address is valid or not.\n",
						"deco": "xFNdZb",
						"endline": 1275,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "localPart",
						"line": 1278,
						"comment": "The local part of the email address, that is, the part before the @ sign.\n",
						"deco": "xFNdZAya",
						"endline": 1281,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "domainPart",
						"line": 1284,
						"comment": "The domain part of the email address, that is, the part after the @ sign.\n",
						"deco": "xFNdZAya",
						"endline": 1287,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "statusCode",
						"line": 1290,
						"comment": "The email status code\n",
						"deco": "xFNdZE3std3net7isemail15EmailStatusCode",
						"endline": 1293,
						"char": 31,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "status",
						"line": 1296,
						"comment": "Returns a describing string of the status code\n",
						"deco": "xFNdZAya",
						"endline": 1299,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1302,
						"comment": "Returns a textual representation of the email status\n",
						"deco": "xFZAya",
						"endline": 1307,
						"char": 12,
						"kind": "function"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"endchar": 1,
				"name": "statusCodeDescription",
				"line": 1311,
				"comment": "Returns a describing string of the given status code\n",
				"deco": "FE3std3net7isemail15EmailStatusCodeZAya",
				"parameters": [
					{
						"name": "statusCode",
						"deco": "E3std3net7isemail15EmailStatusCode"
					}
				],
				"endline": 1440,
				"char": 8,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "validCategory",
						"line": 1451,
						"value": "1",
						"comment": "Address is valid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dnsWarning",
						"line": 1454,
						"value": "7",
						"comment": "Address is valid but a DNS check was not successful\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321",
						"line": 1457,
						"value": "15",
						"comment": "Address is valid for SMTP but has unusual elements\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "cFoldingWhitespace",
						"line": 1460,
						"value": "31",
						"comment": "Address is valid within the message but cannot be used unmodified for the envelope\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecated_",
						"line": 1463,
						"value": "63",
						"comment": "Address contains deprecated elements but may still be valid in restricted contexts\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322",
						"line": 1466,
						"value": "127",
						"comment": "The address is only valid according to the broad definition of RFC 5322. It is otherwise invalid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "any",
						"line": 1473,
						"value": "252",
						"comment": " All finer grained error checking is turned on. Address containing errors or\n warnings is considered invalid. A specific email status code will be\n returned indicating the error/warning of the address.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "none",
						"line": 1479,
						"value": "253",
						"comment": " Address is either considered valid or not, no finer grained error checking\n is performed. Returned email status code will be either Error or Valid.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "warning",
						"line": 1485,
						"value": "254",
						"comment": " Address containing warnings is considered valid, that is,\n any status code below 16 is considered valid.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "error",
						"line": 1488,
						"value": "255",
						"comment": "Address is invalid for any purpose\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "valid",
						"line": 1495,
						"value": "0",
						"comment": "Address is valid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dnsWarningNoMXRecord",
						"line": 1500,
						"value": "5",
						"comment": "Could not find an MX record for this domain but an A-record does exist\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dnsWarningNoRecord",
						"line": 1503,
						"value": "6",
						"comment": "Could not find an MX record or an A-record for this domain\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321TopLevelDomain",
						"line": 1510,
						"value": "9",
						"comment": "Address is valid but at a Top Level Domain\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321TopLevelDomainNumeric",
						"line": 1513,
						"value": "10",
						"comment": "Address is valid but the Top Level Domain begins with a number\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321QuotedString",
						"line": 1516,
						"value": "11",
						"comment": "Address is valid but contains a quoted string\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321AddressLiteral",
						"line": 1519,
						"value": "12",
						"comment": "Address is valid but at a literal address not a domain\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5321IpV6Deprecated",
						"line": 1522,
						"value": "13",
						"comment": "Address is valid but contains a :: that only elides one zero group\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "comment",
						"line": 1529,
						"value": "17",
						"comment": "Address contains comments\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "foldingWhitespace",
						"line": 1532,
						"value": "18",
						"comment": "Address contains Folding White Space\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedLocalPart",
						"line": 1539,
						"value": "33",
						"comment": "The local part is in a deprecated form\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedFoldingWhitespace",
						"line": 1542,
						"value": "34",
						"comment": "Address contains an obsolete form of Folding White Space\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedQuotedText",
						"line": 1545,
						"value": "35",
						"comment": "A quoted string contains a deprecated character\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedQuotedPair",
						"line": 1548,
						"value": "36",
						"comment": "A quoted pair contains a deprecated character\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedComment",
						"line": 1551,
						"value": "37",
						"comment": "Address contains a comment in a position that is deprecated\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedCommentText",
						"line": 1554,
						"value": "38",
						"comment": "A comment contains a deprecated character\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deprecatedCommentFoldingWhitespaceNearAt",
						"line": 1557,
						"value": "49",
						"comment": "Address contains a comment or Folding White Space around the @ sign\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322Domain",
						"line": 1564,
						"value": "65",
						"comment": "Address is RFC 5322 compliant but contains domain characters that are not allowed by DNS\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322TooLong",
						"line": 1567,
						"value": "66",
						"comment": "Address is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322LocalTooLong",
						"line": 1570,
						"value": "67",
						"comment": "The local part of the address is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322DomainTooLong",
						"line": 1573,
						"value": "68",
						"comment": "The domain part is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322LabelTooLong",
						"line": 1576,
						"value": "69",
						"comment": "The domain part contains an element that is too long\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322DomainLiteral",
						"line": 1579,
						"value": "70",
						"comment": "The domain literal is not a valid RFC 5321 address literal\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322DomainLiteralObsoleteText",
						"line": 1582,
						"value": "71",
						"comment": "The domain literal is not a valid RFC 5321 address literal and it contains obsolete characters\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6GroupCount",
						"line": 1585,
						"value": "72",
						"comment": "The IPv6 literal address contains the wrong number of groups\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6TooManyDoubleColons",
						"line": 1588,
						"value": "73",
						"comment": "The IPv6 literal address contains too many :: sequences\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6BadChar",
						"line": 1591,
						"value": "74",
						"comment": "The IPv6 address contains an illegal group of characters\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6MaxGroups",
						"line": 1594,
						"value": "75",
						"comment": "The IPv6 address has too many groups\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6ColonStart",
						"line": 1597,
						"value": "76",
						"comment": "IPv6 address starts with a single colon\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rfc5322IpV6ColonEnd",
						"line": 1600,
						"value": "77",
						"comment": "IPv6 address ends with a single colon\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingDomainText",
						"line": 1607,
						"value": "129",
						"comment": "A domain literal contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorNoLocalPart",
						"line": 1610,
						"value": "130",
						"comment": "Address has no local part\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorNoDomain",
						"line": 1613,
						"value": "131",
						"comment": "Address has no domain part\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorConsecutiveDots",
						"line": 1616,
						"value": "132",
						"comment": "The address may not contain consecutive dots\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorTextAfterCommentFoldingWhitespace",
						"line": 1619,
						"value": "133",
						"comment": "Address contains text after a comment or Folding White Space\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorTextAfterQuotedString",
						"line": 1622,
						"value": "134",
						"comment": "Address contains text after a quoted string\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorTextAfterDomainLiteral",
						"line": 1625,
						"value": "135",
						"comment": "Extra characters were found after the end of the domain literal\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingQuotedPair",
						"line": 1628,
						"value": "136",
						"comment": "The address contains a character that is not allowed in a quoted pair\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingText",
						"line": 1631,
						"value": "137",
						"comment": "Address contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingQuotedText",
						"line": 1634,
						"value": "138",
						"comment": "A quoted string contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorExpectingCommentText",
						"line": 1637,
						"value": "139",
						"comment": "A comment contains a character that is not allowed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorBackslashEnd",
						"line": 1640,
						"value": "140",
						"comment": "The address cannot end with a backslash\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDotStart",
						"line": 1643,
						"value": "141",
						"comment": "Neither part of the address may begin with a dot\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDotEnd",
						"line": 1646,
						"value": "142",
						"comment": "Neither part of the address may end with a dot\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDomainHyphenStart",
						"line": 1649,
						"value": "143",
						"comment": "A domain or subdomain cannot begin with a hyphen\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorDomainHyphenEnd",
						"line": 1652,
						"value": "144",
						"comment": "A domain or subdomain cannot end with a hyphen\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorUnclosedQuotedString",
						"line": 1655,
						"value": "145",
						"comment": "Unclosed quoted string\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorUnclosedComment",
						"line": 1658,
						"value": "146",
						"comment": "Unclosed comment\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorUnclosedDomainLiteral",
						"line": 1661,
						"value": "147",
						"comment": "Domain literal is missing its closing bracket\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorFoldingWhitespaceCrflX2",
						"line": 1664,
						"value": "148",
						"comment": "Folding White Space contains consecutive CRLF sequences\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorFoldingWhitespaceCrLfEnd",
						"line": 1667,
						"value": "149",
						"comment": "Folding White Space ends with a CRLF sequence\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "errorCrNoLf",
						"line": 1670,
						"value": "150",
						"comment": "Address contains a carriage return that is not followed by a line feed\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "EmailStatusCode",
				"line": 1446,
				"comment": " An email status code, indicating if an email address is valid or not.\n If it is invalid it also indicates why.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			}
		],
		"comment": " Validates an email address according to RFCs 5321, 5322 and others.\n\n Authors: Dominic Sayers <dominic@sayers.cc>, Jacob Carlborg\n Copyright: Dominic Sayers, Jacob Carlborg 2008-.\n Test schema documentation: Copyright Â© 2011, Daniel Marschall\n License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0)\n Version: 3.0.13 - Version 3.0 of the original PHP implementation: $(LINK http://www.dominicsayers.com/isemail)\n\n Standards:\n         $(UL\n             $(LI RFC 5321)\n             $(LI RFC 5322)\n          )\n\n References:\n         $(UL\n             $(LI $(LINK http://www.dominicsayers.com/isemail))\n             $(LI $(LINK http://tools.ietf.org/html/rfc5321))\n             $(LI $(LINK http://tools.ietf.org/html/rfc5322))\n          )\n\n Source: $(PHOBOSSRC std/net/_isemail.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/array.d",
		"name": "std.array",
		"members": [
			{
				"members": [
					{
						"endchar": 1,
						"name": "array",
						"line": 89,
						"type": "ForeachType!Range[](Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 131,
						"char": 21,
						"kind": "function"
					}
				],
				"name": "array",
				"line": 89,
				"comment": " Allocates an array and initializes it with copies of the elements\n of range $(D r).\n\n Narrow strings are handled as a special case in an overload.\n\n Params:\n      r = range (or aggregate with $(D opApply) function) whose elements are copied into the allocated array\n Returns:\n      allocated and initialized array\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL134_3304)\n---\nauto a = array([1, 2, 3, 4, 5][]);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL134_3304)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isIterable!Range && !isNarrowString!Range && !isInfinite!Range",
				"char": 21,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "array",
						"line": 191,
						"type": "ElementType!String[](String str)",
						"parameters": [
							{
								"name": "str",
								"type": "String"
							}
						],
						"endline": 195,
						"char": 22,
						"kind": "function"
					}
				],
				"name": "array",
				"line": 191,
				"comment": "Convert a narrow string to an array type that fully supports random access.\nThis is handled as a special case and always returns a $(D dchar[]),\n$(D const(dchar)[]), or $(D immutable(dchar)[]) depending on the constness of\nthe input.\n",
				"parameters": [
					{
						"name": "String",
						"kind": "type"
					}
				],
				"constraint": "isNarrowString!String",
				"char": 22,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "assocArray",
						"line": 334,
						"type": "(Range r)",
						"parameters": [
							{
								"name": "r",
								"type": "Range"
							}
						],
						"endline": 350,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "assocArray",
				"line": 334,
				"comment": "Returns a newly allocated associative _array from a range of key/value tuples.\nParams: r = An input range of tuples of keys and values.\nReturns: A newly allocated associative array out of elements of the input\nrange, which must be a range of tuples (Key, Value).\nSee_Also: $(XREF typecons, Tuple)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL353_3314)\n---\nimport std.range;\nimport std.typecons;\nauto a = assocArray(zip([0, 1, 2], [\"a\", \"b\", \"c\"]));\nassert(is(typeof(a) == string[int]));\nassert(a == [0:\"a\", 1:\"b\", 2:\"c\"]);\n\nauto b = assocArray([ tuple(\"foo\", \"bar\"), tuple(\"baz\", \"quux\") ]);\nassert(is(typeof(b) == string[string]));\nassert(b == [\"foo\":\"bar\", \"baz\":\"quux\"]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL353_3314)\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "byPair",
						"line": 393,
						"type": "(Value[Key] aa)",
						"parameters": [
							{
								"name": "aa",
								"type": "Value[Key]"
							}
						],
						"endline": 399,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "byPair",
				"line": 393,
				"comment": "Construct a range iterating over an associative array by key/value tuples.\n\nParams: aa = The associative array to iterate over.\n\nReturns: A forward range of Tuple's of key and value pairs from the given\nassociative array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL402_3318)\n---\nimport std.typecons : tuple, Tuple;\nimport std.algorithm : sort;\n\nauto aa = [\"a\": 1, \"b\": 2, \"c\": 3];\nTuple!(string, int)[] pairs;\n\n// Iteration over key/value pairs.\nforeach (pair; aa.byPair)\n{\n    pairs ~= pair;\n}\n\n// Iteration order is implementation-dependent, so we should sort it to get\n// a fixed order.\nsort(pairs);\nassert(pairs == [\n    tuple(\"a\", 1),\n    tuple(\"b\", 2),\n    tuple(\"c\", 3)\n]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL402_3318)\n",
				"parameters": [
					{
						"name": "Key",
						"kind": "type"
					},
					{
						"name": "Value",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uninitializedArray",
						"line": 495,
						"type": "nothrow @system (I sizes)",
						"parameters": [
							{
								"name": "sizes",
								"type": "I"
							}
						],
						"endline": 509,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uninitializedArray",
				"line": 495,
				"comment": "Returns a new array of type $(D T) allocated on the garbage collected heap\nwithout initializing its elements.  This can be a useful optimization if every\nelement will be immediately initialized.  $(D T) may be a multidimensional\narray.  In this case sizes may be specified for any number of dimensions from 0\nto the number in $(D T).\n\nuninitializedArray is nothrow and weakly pure.\n\nuninitializedArray is @system if the uninitialized element type has pointers.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "tuple"
					}
				],
				"constraint": "isDynamicArray!T && allSatisfy!(isIntegral, I) && hasIndirections!(ElementEncodingType!T)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "uninitializedArray",
						"line": 512,
						"type": "nothrow @trusted (I sizes)",
						"parameters": [
							{
								"name": "sizes",
								"type": "I"
							}
						],
						"endline": 526,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "uninitializedArray",
				"line": 512,
				"comment": "\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL528_3320)\n---\ndouble[] arr = uninitializedArray!(double[])(100);\nassert(arr.length == 100);\n\ndouble[][] matrix = uninitializedArray!(double[][])(42, 31);\nassert(matrix.length == 42);\nassert(matrix[0].length == 31);\n\nchar*[] ptrs = uninitializedArray!(char*[])(100);\nassert(ptrs.length == 100);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL528_3320)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "tuple"
					}
				],
				"constraint": "isDynamicArray!T && allSatisfy!(isIntegral, I) && !hasIndirections!(ElementEncodingType!T)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "minimallyInitializedArray",
						"line": 550,
						"type": "nothrow @trusted (I sizes)",
						"parameters": [
							{
								"name": "sizes",
								"type": "I"
							}
						],
						"endline": 563,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "minimallyInitializedArray",
				"line": 550,
				"comment": "Returns a new array of type $(D T) allocated on the garbage collected heap.\n\nPartial initialization is done for types with indirections, for preservation\nof memory safety. Note that elements will only be initialized to 0, but not\nnecessarily the element type's $(D .init).\n\nminimallyInitializedArray is nothrow and weakly pure.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL724_3326)\n---\nint[] a = [ 10, 11, 12, 13, 14 ];\nint[] b = a[1 .. 3];\nassert(overlap(a, b) == [ 11, 12 ]);\nb = b.dup;\n// overlap disappears even though the content is the same\nassert(overlap(a, b).empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL724_3326)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "I",
						"kind": "tuple"
					}
				],
				"constraint": "isDynamicArray!T && allSatisfy!(isIntegral, I)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "insertInPlace",
						"line": 925,
						"type": "void(ref T[] array, size_t pos, U stuff)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "pos",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "U"
							}
						],
						"endline": 981,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "insertInPlace",
				"line": 925,
				"comment": "    Inserts $(D stuff) (which must be an input range or any number of\n    implicitly convertible items) in $(D array) at position $(D pos).\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1074_3329)\n---\nint[] a = [ 1, 2, 3, 4 ];\na.insertInPlace(2, [ 1, 2 ]);\nassert(a == [ 1, 2, 1, 2, 3, 4 ]);\na.insertInPlace(3, 10u, 11);\nassert(a == [ 1, 2, 1, 10, 11, 2, 3, 4]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1074_3329)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "tuple"
					}
				],
				"constraint": "!isSomeString!(T[]) && allSatisfy!(isInputRangeOrConvertible!T, U) && U.length > 0",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "insertInPlace",
						"line": 984,
						"type": "void(ref T[] array, size_t pos, U stuff)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "pos",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "U"
							}
						],
						"endline": 1071,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "insertInPlace",
				"line": 984,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "U",
						"kind": "tuple"
					}
				],
				"constraint": "isSomeString!(T[]) && allSatisfy!(isCharOrStringOrDcharRange, U)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sameHead",
						"line": 1288,
						"type": "pure nothrow @safe bool(in T[] lhs, in T[] rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "rhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1291,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "sameHead",
				"line": 1288,
				"comment": "    Returns whether the $(D front)s of $(D lhs) and $(D rhs) both refer to the\n    same place in memory, making one of the arrays a slice of the other which\n    starts at index $(D 0).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1294_3334)\n---\nauto a = [1, 2, 3, 4, 5];\nauto b = a[0..2];\n\nassert(a.sameHead(b));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1294_3334)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "sameTail",
						"line": 1309,
						"type": "pure nothrow @trusted bool(in T[] lhs, in T[] rhs)",
						"parameters": [
							{
								"name": "lhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "rhs",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 1312,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "sameTail",
				"line": 1309,
				"comment": "    Returns whether the $(D back)s of $(D lhs) and $(D rhs) both refer to the\n    same place in memory, making one of the arrays a slice of the other which\n    end at index $(D $).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1315_3335)\n---\nauto a = [1, 2, 3, 4, 5];\nauto b = a[3..$];\n\nassert(a.sameTail(b));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1315_3335)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replicate",
						"line": 1356,
						"type": "ElementEncodingType!S[](S s, size_t n)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1377,
						"char": 25,
						"kind": "function"
					}
				],
				"name": "replicate",
				"line": 1356,
				"comment": "Returns an array that consists of $(D s) (which must be an input\nrange) repeated $(D n) times. This function allocates, fills, and\nreturns a new array. For a lazy version, refer to $(XREF range, repeat).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1389_3337)\n---\nauto a = \"abc\";\nauto s = replicate(a, 3);\n\nassert(s == \"abcabcabc\");\n\nauto b = [1, 2, 3];\nauto c = replicate(b, 3);\n\nassert(c == [1, 2, 3, 1, 2, 3, 1, 2, 3]);\n\nauto d = replicate(b, 0);\n\nassert(d == []);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1389_3337)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!S",
				"char": 25,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replicate",
						"line": 1380,
						"type": "ElementType!S[](S s, size_t n)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							},
							{
								"name": "n",
								"type": "size_t"
							}
						],
						"endline": 1385,
						"char": 17,
						"kind": "function"
					}
				],
				"name": "replicate",
				"line": 1380,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!S && !isDynamicArray!S",
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1440,
						"type": "pure @safe S[](S s)",
						"parameters": [
							{
								"name": "s",
								"type": "S"
							}
						],
						"endline": 1470,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "split",
				"line": 1440,
				"comment": "Eagerly split the string $(D s) into an array of words, using whitespace as\ndelimiter. Runs of whitespace are merged together (no empty words are produced).\n\n$(D @safe), $(D pure) and $(D CTFE)-able.\n\nSee_Also:\n$(XREF_PACK algorithm,iteration,splitter) for a version that splits using any\nseparator.\n\n$(XREF regex, splitter) for a version that splits using a regular\nexpression defined separator.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1517_3341)\n---\nassert(split(\"hello world\") == [\"hello\",\"world\"]);\nassert(split(\"192.168.0.1\", \".\") == [\"192\", \"168\", \"0\", \"1\"]);\n\nauto a = split([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [2, 3]);\nassert(a == [[1], [4, 5, 1], [4, 5]]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1517_3341)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"constraint": "isSomeString!S",
				"char": 5,
				"kind": "template"
			},
			{
				"name": "splitter",
				"line": 1530,
				"comment": "Alias for $(XREF_PACK algorithm,iteration,_splitter).\n",
				"storageClass": [
					"deprecated"
				],
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1558,
						"type": "(Range range, Separator sep)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "sep",
								"type": "Separator"
							}
						],
						"endline": 1563,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "split",
				"line": 1558,
				"comment": "    Eagerly splits $(D range) into an array, using $(D sep) as the delimiter.\n\n    The _range must be a\n    $(XREF_PACK_NAMED _range,primitives,isForwardRange,forward _range).\n    The separator can be a value of the same type as the elements in $(D range)\n    or it can be another forward _range.\n\n    Examples:\n        If $(D range) is a $(D string), $(D sep) can be a $(D char) or another\n        $(D string). The return type will be an array of strings. If $(D range) is\n        an $(D int) array, $(D sep) can be an $(D int) or another $(D int) array.\n        The return type will be an array of $(D int) arrays.\n\n    Params:\n        range = a forward _range.\n        sep = a value of the same type as the elements of $(D range) or another\n        forward range.\n\n    Returns:\n        An array containing the divided parts of $(D range).\n\n    See_Also:\n        $(XREF_PACK algorithm,iteration,splitter) for the lazy version of this\n        function.\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && is(typeof(ElementType!Range.init == Separator.init))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1565,
						"type": "(Range range, Separator sep)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							},
							{
								"name": "sep",
								"type": "Separator"
							}
						],
						"endline": 1570,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "split",
				"line": 1565,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "Range",
						"kind": "type"
					},
					{
						"name": "Separator",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && isForwardRange!Separator && is(typeof(ElementType!Range.init == ElementType!Separator.init))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "split",
						"line": 1572,
						"type": "(Range range)",
						"parameters": [
							{
								"name": "range",
								"type": "Range"
							}
						],
						"endline": 1577,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "split",
				"line": 1572,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "isTerminator",
						"kind": "alias"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isForwardRange!Range && is(typeof(unaryFun!isTerminator(range.front)))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "join",
						"line": 1657,
						"type": "ElementEncodingType!(ElementType!RoR)[](RoR ror, R sep)",
						"parameters": [
							{
								"name": "ror",
								"type": "RoR"
							},
							{
								"name": "sep",
								"type": "R"
							}
						],
						"endline": 1725,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "join",
				"line": 1657,
				"comment": "   Concatenates all of the ranges in $(D ror) together into one array using\n   $(D sep) as the separator if present.\n\n   Params:\n        ror = Range of Ranges of Elements\n        sep = Range of Elements\n\n   Returns:\n        an allocated array of Elements\n\n   See_Also:\n        $(XREF_PACK algorithm,iteration,joiner)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1842_3345)\n---\nassert(join([\"hello\", \"silly\", \"world\"], \" \") == \"hello silly world\");\nassert(join([\"hello\", \"silly\", \"world\"]) == \"hellosillyworld\");\n\nassert(join([[1, 2, 3], [4, 5]], [72, 73]) == [1, 2, 3, 72, 73, 4, 5]);\nassert(join([[1, 2, 3], [4, 5]]) == [1, 2, 3, 4, 5]);\n\nconst string[] arr = [\"apple\", \"banana\"];\nassert(arr.join(\",\") == \"apple,banana\");\nassert(arr.join() == \"applebanana\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1842_3345)\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(Unqual!(ElementType!RoR)) && isInputRange!R && is(Unqual!(ElementType!(ElementType!RoR)) == Unqual!(ElementType!R))",
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "join",
						"line": 1734,
						"type": "ElementEncodingType!(ElementType!RoR)[](RoR ror, E sep)",
						"parameters": [
							{
								"name": "ror",
								"type": "RoR"
							},
							{
								"name": "sep",
								"type": "E"
							}
						],
						"endline": 1797,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "join",
				"line": 1734,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(Unqual!(ElementType!RoR)) && is(E : ElementType!(ElementType!RoR))",
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "join",
						"line": 1806,
						"type": "ElementEncodingType!(ElementType!RoR)[](RoR ror)",
						"parameters": [
							{
								"name": "ror",
								"type": "RoR"
							}
						],
						"endline": 1839,
						"char": 41,
						"kind": "function"
					}
				],
				"name": "join",
				"line": 1806,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "RoR",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!RoR && isInputRange!(Unqual!(ElementType!RoR))",
				"char": 41,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 2037,
						"type": "E[](E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 2053,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 2037,
				"comment": "    Replace occurrences of $(D from) with $(D to) in $(D subject). Returns a new\n    array without changing the contents of $(D subject), or the original array\n    if no match is found.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2056_3353)\n---\nassert(\"Hello WÃ¶rld\".replace(\"o WÃ¶\", \"o Wo\") == \"Hello World\");\nassert(\"Hello WÃ¶rld\".replace(\"l\", \"h\") == \"Hehho WÃ¶rhd\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2056_3353)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!(E[]) && isForwardRange!R1 && isForwardRange!R2 && (hasLength!R2 || isSomeString!R2)",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceInto",
						"line": 2066,
						"type": "void(Sink sink, E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "sink",
								"type": "Sink"
							},
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 2088,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "replaceInto",
				"line": 2066,
				"comment": "    Same as above, but outputs the result via OutputRange $(D sink).\n    If no match is found the original array is transferred to $(D sink) as is.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2091_3354)\n---\nauto arr = [1, 2, 3, 4, 5];\nauto from = [2, 3];\nauto into = [4, 6];\nauto sink = appender!(int[])();\n\nreplaceInto(sink, arr, from, into);\n\nassert(sink.data == [1, 4, 6, 4, 5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2091_3354)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "Sink",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isOutputRange!(Sink, E) && isDynamicArray!(E[]) && isForwardRange!R1 && isForwardRange!R2 && (hasLength!R2 || isSomeString!R2)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replace",
						"line": 2163,
						"type": "T[](T[] subject, size_t from, size_t to, Range stuff)",
						"parameters": [
							{
								"name": "subject",
								"type": "T[]"
							},
							{
								"name": "from",
								"type": "size_t"
							},
							{
								"name": "to",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "Range"
							}
						],
						"endline": 2190,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replace",
				"line": 2163,
				"comment": "    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Returns a new\n    array without changing the contents of $(D subject).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2193_3357)\n---\nauto a = [ 1, 2, 3, 4 ];\nauto b = a.replace(1, 3, [ 9, 9, 9 ]);\nassert(a == [ 1, 2, 3, 4 ]);\nassert(b == [ 1, 9, 9, 9, 4 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2193_3357)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && (is(ElementType!Range : T) || isSomeString!(T[]) && is(ElementType!Range : dchar))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceInPlace",
						"line": 2279,
						"type": "void(ref T[] array, size_t from, size_t to, Range stuff)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "from",
								"type": "size_t"
							},
							{
								"name": "to",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "Range"
							}
						],
						"endline": 2309,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "replaceInPlace",
				"line": 2279,
				"comment": "    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Expands or\n    shrinks the array as needed.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2323_3359)\n---\nint[] a = [1, 4, 5];\nreplaceInPlace(a, 1u, 2u, [2, 3, 4]);\nassert(a == [1, 2, 3, 4, 5]);\nreplaceInPlace(a, 1u, 2u, cast(int[])[]);\nassert(a == [1, 3, 4, 5]);\nreplaceInPlace(a, 1u, 3u, a[2 .. 4]);\nassert(a == [1, 4, 5, 5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2323_3359)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!Range && is(ElementEncodingType!Range : T) && !is(T == const(T)) && !is(T == immutable(T))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceInPlace",
						"line": 2312,
						"type": "void(ref T[] array, size_t from, size_t to, Range stuff)",
						"parameters": [
							{
								"name": "array",
								"type": "T[]",
								"storageClass": [
									"ref"
								]
							},
							{
								"name": "from",
								"type": "size_t"
							},
							{
								"name": "to",
								"type": "size_t"
							},
							{
								"name": "stuff",
								"type": "Range"
							}
						],
						"endline": 2320,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "replaceInPlace",
				"line": 2312,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "Range",
						"kind": "type"
					}
				],
				"constraint": "isInputRange!Range && (!isDynamicArray!Range && is(ElementType!Range : T) || isDynamicArray!Range && is(ElementType!Range : T) && (is(T == const(T)) || is(T == immutable(T))) || isSomeString!(T[]) && is(ElementType!Range : dchar))",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceFirst",
						"line": 2420,
						"type": "E[](E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 2455,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replaceFirst",
				"line": 2420,
				"comment": "    Replaces the first occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2458_3362)\n---\nauto a = [1, 2, 2, 3, 4, 5];\nauto b = a.replaceFirst([2], [1337]);\nassert(b == [1, 1337, 2, 3, 4, 5]);\n\nauto s = \"This is a foo foo list\";\nauto r = s.replaceFirst(\"foo\", \"silly\");\nassert(r == \"This is a silly foo list\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2458_3362)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!(E[]) && isForwardRange!R1 && is(typeof(appender!(E[])().put(from[0..1]))) && isForwardRange!R2 && is(typeof(appender!(E[])().put(to[0..1])))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceLast",
						"line": 2520,
						"type": "E[](E[] subject, R1 from, R2 to)",
						"parameters": [
							{
								"name": "subject",
								"type": "E[]"
							},
							{
								"name": "from",
								"type": "R1"
							},
							{
								"name": "to",
								"type": "R2"
							}
						],
						"endline": 2563,
						"char": 5,
						"kind": "function"
					}
				],
				"name": "replaceLast",
				"line": 2520,
				"comment": "    Replaces the last occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2566_3365)\n---\nauto a = [1, 2, 2, 3, 4, 5];\nauto b = a.replaceLast([2], [1337]);\nassert(b == [1, 2, 1337, 3, 4, 5]);\n\nauto s = \"This is a foo foo list\";\nauto r = s.replaceLast(\"foo\", \"silly\");\nassert(r == \"This is a foo silly list\", r);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2566_3365)\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					},
					{
						"name": "R1",
						"kind": "type"
					},
					{
						"name": "R2",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!(E[]) && isForwardRange!R1 && is(typeof(appender!(E[])().put(from[0..1]))) && isForwardRange!R2 && is(typeof(appender!(E[])().put(to[0..1])))",
				"char": 5,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "replaceSlice",
						"line": 2619,
						"type": "inout(T)[](inout(T)[] s, in T[] slice, in T[] replacement)",
						"parameters": [
							{
								"name": "s",
								"type": "inout(T)[]"
							},
							{
								"name": "slice",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							},
							{
								"name": "replacement",
								"type": "T[]",
								"storageClass": [
									"in"
								]
							}
						],
						"endline": 2635,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "replaceSlice",
				"line": 2619,
				"comment": "    Returns a new array that is $(D s) with $(D slice) replaced by\n    $(D replacement[]).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2638_3367)\n---\nauto a = [1, 2, 3, 4, 5];\nauto b = replaceSlice(a, a[1..4], [0, 0, 0]);\n\nassert(b == [1, 0, 0, 0, 5]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2638_3367)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Appender",
						"line": 2665,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 2686,
								"comment": " Construct an appender with a given array.  Note that this does not copy the\n data.  If the array has a larger capacity as determined by arr.capacity,\n it will be used by the appender.  After initializing an appender on an array,\n appending to the original array will reallocate.\n",
								"type": "pure nothrow @trusted (T[] arr)",
								"parameters": [
									{
										"name": "arr",
										"type": "T[]"
									}
								],
								"endline": 2707,
								"char": 5,
								"kind": "constructor"
							},
							{
								"endchar": 5,
								"name": "reserve",
								"line": 2730,
								"comment": " Reserve at least newCapacity elements for appending.  Note that more elements\n may be reserved than requested.  If newCapacity <= capacity, then nothing is\n done.\n",
								"type": "pure nothrow @safe void(size_t newCapacity)",
								"parameters": [
									{
										"name": "newCapacity",
										"type": "size_t"
									}
								],
								"endline": 2741,
								"char": 10,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 2748,
								"comment": " Returns the capacity of the array (the maximum number of elements the\n managed array can accommodate before triggering a reallocation).  If any\n appending will reallocate, $(D capacity) returns $(D 0).\n",
								"type": "const pure nothrow @property @safe size_t()",
								"endline": 2751,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "data",
								"line": 2756,
								"comment": " Returns the managed array.\n",
								"type": "inout pure nothrow @property @trusted inout(T)[]()",
								"endline": 2762,
								"char": 26,
								"kind": "function"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "put",
										"line": 2844,
										"type": "void(U item)",
										"parameters": [
											{
												"name": "item",
												"type": "U"
											}
										],
										"endline": 2869,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "put",
								"line": 2844,
								"comment": " Appends one item to the managed array.\n",
								"parameters": [
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "canPutItem!U",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "put",
										"line": 2881,
										"type": "void(Range items)",
										"parameters": [
											{
												"name": "items",
												"type": "Range"
											}
										],
										"endline": 2941,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "put",
								"line": 2881,
								"comment": " Appends an entire range to the managed array.\n",
								"parameters": [
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "canPutRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2946,
										"type": "void(U item)",
										"parameters": [
											{
												"name": "item",
												"type": "U"
											}
										],
										"endline": 2949,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2946,
								"comment": " Appends one item to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "canPutItem!U",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 2960,
										"type": "void(Range items)",
										"parameters": [
											{
												"name": "items",
												"type": "Range"
											}
										],
										"endline": 2963,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 2960,
								"comment": " Appends an entire range to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "canPutRange!Range",
								"char": 10,
								"kind": "template"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "Appender",
				"line": 2665,
				"comment": "Implements an output range that appends data to an array. This is\nrecommended over $(D a ~= data) when appending many elements because it is more\nefficient.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3009_3369)\n---\nauto app = appender!string();\nstring b = \"abcdefg\";\nforeach (char c; b)\n    app.put(c);\nassert(app.data == \"abcdefg\");\n\nint[] a = [ 1, 2 ];\nauto app2 = appender(a);\napp2.put(3);\napp2.put([ 4, 5, 6 ]);\nassert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3009_3369)\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!A",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "RefAppender",
						"line": 3057,
						"members": [
							{
								"endchar": 5,
								"name": "this",
								"line": 3077,
								"comment": " Construct a ref appender with a given array reference.  This does not copy the\n data.  If the array has a larger capacity as determined by arr.capacity, it\n will be used by the appender.  $(D RefAppender) assumes that arr is a non-null\n value.\n\n Note, do not use builtin appending (i.e. ~=) on the original array passed in\n until you are done with the appender, because calls to the appender override\n those appends.\n",
								"type": "(T[]* arr)",
								"parameters": [
									{
										"name": "arr",
										"type": "T[]*"
									}
								],
								"endline": 3081,
								"char": 5,
								"kind": "constructor"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 3095,
										"type": "void(U item)",
										"parameters": [
											{
												"name": "item",
												"type": "U"
											}
										],
										"endline": 3099,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 3095,
								"comment": " Appends one item to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "U",
										"kind": "type"
									}
								],
								"constraint": "AppenderType.canPutItem!U",
								"char": 10,
								"kind": "template"
							},
							{
								"members": [
									{
										"endchar": 5,
										"name": "opOpAssign",
										"line": 3111,
										"type": "void(Range items)",
										"parameters": [
											{
												"name": "items",
												"type": "Range"
											}
										],
										"endline": 3115,
										"char": 10,
										"kind": "function"
									}
								],
								"name": "opOpAssign",
								"line": 3111,
								"comment": " Appends an entire range to the managed array.\n",
								"parameters": [
									{
										"name": "op",
										"type": "string",
										"specValue": "\"~\"",
										"kind": "value"
									},
									{
										"name": "Range",
										"kind": "type"
									}
								],
								"constraint": "AppenderType.canPutRange!Range",
								"char": 10,
								"kind": "template"
							},
							{
								"endchar": 5,
								"name": "capacity",
								"line": 3122,
								"comment": " Returns the capacity of the array (the maximum number of elements the\n managed array can accommodate before triggering a reallocation).  If any\n appending will reallocate, $(D capacity) returns $(D 0).\n",
								"type": "const @property size_t()",
								"endline": 3125,
								"char": 22,
								"kind": "function"
							},
							{
								"endchar": 5,
								"name": "data",
								"line": 3130,
								"comment": " Returns the managed array.\n",
								"type": "inout @property inout(T)[]()",
								"endline": 3133,
								"char": 26,
								"kind": "function"
							}
						],
						"char": 1,
						"kind": "struct"
					}
				],
				"name": "RefAppender",
				"line": 3057,
				"comment": " An appender that can update an array in-place.  It forwards all calls to an\n underlying appender implementation.  Any calls made to the appender also update\n the pointer to the original array passed in.\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!A",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "appender",
						"line": 3140,
						"type": "Appender!A()",
						"endline": 3144,
						"char": 12,
						"kind": "function"
					}
				],
				"name": "appender",
				"line": 3140,
				"comment": "    Convenience function that returns an $(D Appender!A) object initialized\n    with $(D array).\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"constraint": "isDynamicArray!A",
				"char": 12,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "appender",
						"line": 3146,
						"type": "Appender!(E[])(auto ref A array)",
						"parameters": [
							{
								"name": "array",
								"type": "A",
								"storageClass": [
									"auto",
									"ref"
								]
							}
						],
						"endline": 3152,
						"char": 16,
						"kind": "function"
					}
				],
				"name": "appender",
				"line": 3146,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "A",
						"type": "E[]",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 16,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "appender",
						"line": 3516,
						"type": "RefAppender!(E[])(A array)",
						"parameters": [
							{
								"name": "array",
								"type": "A"
							}
						],
						"endline": 3519,
						"char": 19,
						"kind": "function"
					}
				],
				"name": "appender",
				"line": 3516,
				"comment": "    Convenience function that returns a $(D RefAppender!A) object initialized\n    with $(D array).  Don't use null for the $(D array) pointer, use the other\n    version of $(D appender) instead.\n",
				"parameters": [
					{
						"name": "A",
						"type": "E[]*",
						"kind": "type"
					},
					{
						"name": "E",
						"kind": "type"
					}
				],
				"char": 19,
				"kind": "template"
			}
		],
		"comment": "Functions and types that manipulate built-in arrays and associative arrays.\n\nThis module provides all kinds of functions to create, manipulate or convert arrays:\n\n$(BOOKTABLE ,\n$(TR $(TH Function Name) $(TH Description)\n)\n    $(TR $(TD $(D $(LREF _array)))\n        $(TD Returns a copy of the input in a newly allocated dynamic _array.\n    ))\n    $(TR $(TD $(D $(LREF appender)))\n        $(TD Returns a new Appender initialized with a given _array.\n    ))\n    $(TR $(TD $(D $(LREF assocArray)))\n        $(TD Returns a newly allocated associative _array from a range of key/value tuples.\n    ))\n    $(TR $(TD $(D $(LREF byPair)))\n        $(TD Construct a range iterating over an associative _array by key/value tuples.\n    ))\n    $(TR $(TD $(D $(LREF insertInPlace)))\n        $(TD Inserts into an existing _array at a given position.\n    ))\n    $(TR $(TD $(D $(LREF join)))\n        $(TD Concatenates a range of ranges into one _array.\n    ))\n    $(TR $(TD $(D $(LREF minimallyInitializedArray)))\n        $(TD Returns a new _array of type $(D T).\n    ))\n    $(TR $(TD $(D $(LREF replace)))\n        $(TD Returns a new _array with all occurrences of a certain subrange replaced.\n    ))\n    $(TR $(TD $(D $(LREF replaceFirst)))\n        $(TD Returns a new _array with the first occurrence of a certain subrange replaced.\n    ))\n    $(TR $(TD $(D $(LREF replaceInPlace)))\n        $(TD Replaces all occurrences of a certain subrange and puts the result into a given _array.\n    ))\n    $(TR $(TD $(D $(LREF replaceInto)))\n        $(TD Replaces all occurrences of a certain subrange and puts the result into an output range.\n    ))\n    $(TR $(TD $(D $(LREF replaceLast)))\n        $(TD Returns a new _array with the last occurrence of a certain subrange replaced.\n    ))\n    $(TR $(TD $(D $(LREF replaceSlice)))\n        $(TD Returns a new _array with a given slice replaced.\n    ))\n    $(TR $(TD $(D $(LREF replicate)))\n        $(TD Creates a new _array out of several copies of an input _array or range.\n    ))\n    $(TR $(TD $(D $(LREF split)))\n        $(TD Eagerly split a range or string into an _array.\n    ))\n    $(TR $(TD $(D $(LREF uninitializedArray)))\n        $(TD Returns a new _array of type $(D T) without initializing its elements.\n    ))\n)\n\nCopyright: Copyright Andrei Alexandrescu 2008- and Jonathan M Davis 2011-.\n\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n\nSource: $(PHOBOSSRC std/_array.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/traits.d",
		"name": "std.traits",
		"members": [
			{
				"members": [
					{
						"name": "InoutOf",
						"line": 270,
						"type": "inout(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "InoutOf",
				"line": 270,
				"comment": "Add specific qualifier to the given type T.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ConstOf",
						"line": 272,
						"type": "const(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "ConstOf",
				"line": 272,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SharedOf",
						"line": 274,
						"type": "shared(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "SharedOf",
				"line": 274,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SharedInoutOf",
						"line": 276,
						"type": "shared(inout(T))",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "SharedInoutOf",
				"line": 276,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SharedConstOf",
						"line": 278,
						"type": "shared(const(T))",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "SharedConstOf",
				"line": 278,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ImmutableOf",
						"line": 280,
						"type": "immutable(T)",
						"char": 29,
						"kind": "alias"
					}
				],
				"name": "ImmutableOf",
				"line": 280,
				"comment": "ditto.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "packageName",
				"line": 333,
				"comment": " Get the full package name for the given symbol.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL351_3391)\n---\nimport std.traits;\nstatic assert(packageName!packageName == \"std\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL351_3391)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "moduleName",
				"line": 387,
				"comment": " Get the module name (including package) for the given symbol.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL407_3393)\n---\nimport std.traits;\nstatic assert(moduleName!moduleName == \"std.traits\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL407_3393)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "fullyQualifiedName",
				"line": 450,
				"comment": " Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string  converter.\n\nExample:\n-----------------\nmodule myModule;\nstruct MyStruct {}\nstatic assert(fullyQualifiedName!(const MyStruct[]) == \"const(myModule.MyStruct[])\");\n-----------------\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL461_3395)\n---\nstatic assert(fullyQualifiedName!fullyQualifiedName == \"std.traits.fullyQualifiedName\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL461_3395)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ReturnType",
				"line": 855,
				"comment": " Get the type of the return value from a function,\n a pointer to function, a delegate, a struct\n with an opCall, a pointer to a struct with an opCall,\n or a class with an $(D opCall). Please note that $(D_KEYWORD ref)\n is not part of a type, but the attribute of the function\n (see template $(LREF functionAttributes)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL865_3399)\n---\nint foo();\nReturnType!foo x;   // x is declared as int\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL865_3399)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Parameters",
				"line": 914,
				"comment": "Get, as a tuple, the types of the parameters to a function, a pointer\nto function, a delegate, a struct with an $(D opCall), a pointer to a\nstruct with an $(D opCall), or a class with an $(D opCall).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL924_3401)\n---\nint foo(int, long);\nvoid bar(Parameters!foo);      // declares void bar(int, long);\nvoid abc(Parameters!foo[1]);   // declares void abc(long);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL924_3401)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "ParameterTypeTuple",
				"line": 934,
				"comment": " Alternate name for $(LREF Parameters), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "arity",
						"line": 967,
						"type": "size_t",
						"init": "Parameters!func.length",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "arity",
				"line": 964,
				"comment": "Returns the number of arguments of function $(D func).\narity is undefined for variadic functions.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL971_3403)\n---\nvoid foo(){}\nstatic assert(arity!foo==0);\nvoid bar(uint){}\nstatic assert(arity!bar==1);\nvoid variadicFoo(uint...){}\nstatic assert(__traits(compiles,arity!variadicFoo)==false);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL971_3403)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"constraint": "isCallable!func && variadicFunctionStyle!func == Variadic.no",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 990,
						"value": "0u",
						"comment": " These flags can be bitwise OR-ed together to represent complex storage\n class.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "scope_",
						"line": 991,
						"value": "1u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "out_",
						"line": 992,
						"value": "2u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ref_",
						"line": 993,
						"value": "4u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lazy_",
						"line": 994,
						"value": "8u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "return_",
						"line": 995,
						"value": "16u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "ParameterStorageClass",
				"line": 984,
				"comment": "Returns a tuple consisting of the storage classes of the parameters of a\nfunction $(D func).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1038_3404)\n---\nalias STC = ParameterStorageClass; // shorten the enum name\n\nvoid func(ref int ctx, out real result, real param)\n{\n}\nalias pstc = ParameterStorageClassTuple!func;\nstatic assert(pstc.length == 3); // three parameters\nstatic assert(pstc[0] == STC.ref_);\nstatic assert(pstc[1] == STC.out_);\nstatic assert(pstc[2] == STC.none);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1038_3404)\n",
				"baseDeco": "k",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ParameterStorageClassTuple",
						"line": 1034,
						"type": "demangleNextParameter!margs",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ParameterStorageClassTuple",
				"line": 999,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ParameterIdentifierTuple",
						"line": 1143,
						"type": "Impl!()",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ParameterIdentifierTuple",
				"line": 1107,
				"comment": "Get, as a tuple, the identifiers of the parameters to a function symbol.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1147_3407)\n---\nint foo(int num, string name, int);\nstatic assert([ParameterIdentifierTuple!foo] == [\"num\", \"name\", \"\"]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1147_3407)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ParameterDefaults",
						"line": 1237,
						"type": "Impl!()",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ParameterDefaults",
				"line": 1194,
				"comment": "Get, as a tuple, the default value of the parameters to a function symbol.\nIf a parameter doesn't have the default value, $(D void) is returned instead.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1241_3409)\n---\nint foo(int num, string name = \"hello\", int[] = [1,2,3]);\nstatic assert(is(ParameterDefaults!foo[0] == void));\nstatic assert(   ParameterDefaults!foo[1] == \"hello\");\nstatic assert(   ParameterDefaults!foo[2] == [1,2,3]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1241_3409)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "ParameterDefaultValueTuple",
				"line": 1252,
				"comment": " Alternate name for $(LREF ParameterDefaults), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1297,
						"value": "0u",
						"comment": " These flags can be bitwise OR-ed together to represent a complex attribute.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pure_",
						"line": 1298,
						"value": "1u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nothrow_",
						"line": 1299,
						"value": "2u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ref_",
						"line": 1300,
						"value": "4u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "property",
						"line": 1301,
						"value": "8u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "trusted",
						"line": 1302,
						"value": "16u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "safe",
						"line": 1303,
						"value": "32u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nogc",
						"line": 1304,
						"value": "64u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "system",
						"line": 1305,
						"value": "128u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "const_",
						"line": 1306,
						"value": "256u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "immutable_",
						"line": 1307,
						"value": "512u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "inout_",
						"line": 1308,
						"value": "1024u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "shared_",
						"line": 1309,
						"value": "2048u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "return_",
						"line": 1310,
						"value": "4096u",
						"comment": "ditto\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "FunctionAttribute",
				"line": 1292,
				"comment": "Returns the attributes attached to a function $(D func).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1326_3411)\n---\nimport std.traits : functionAttributes, FunctionAttribute;\n\nalias FA = FunctionAttribute; // shorten the enum name\n\nreal func(real x) pure nothrow @safe\n{\n    return x;\n}\nstatic assert(functionAttributes!func & FA.pure_);\nstatic assert(functionAttributes!func & FA.safe);\nstatic assert(!(functionAttributes!func & FA.trusted)); // not @trusted\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1326_3411)\n",
				"baseDeco": "k",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "functionAttributes",
						"line": 1321,
						"type": "FunctionAttribute",
						"init": "extractAttribFlags!(__traits(getFunctionAttributes, FuncSym))()",
						"char": 28,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "functionAttributes",
				"line": 1314,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSafe",
						"line": 1485,
						"init": "(functionAttributes!func & FunctionAttribute.safe) != 0 || (functionAttributes!func & FunctionAttribute.trusted) != 0",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSafe",
				"line": 1482,
				"comment": "$(D true) if $(D func) is $(D @safe) or $(D @trusted).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1490_3413)\n---\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert( isSafe!add);\nstatic assert( isSafe!sub);\nstatic assert(!isSafe!mul);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1490_3413)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"constraint": "isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isUnsafe",
						"line": 1563,
						"init": "!isSafe!func",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUnsafe",
				"line": 1561,
				"comment": "$(D true) if $(D func) is $(D @system).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1567_3415)\n---\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert(!isUnsafe!add);\nstatic assert(!isUnsafe!sub);\nstatic assert( isUnsafe!mul);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1567_3415)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "areAllSafe",
				"line": 1654,
				"comment": "$(RED Deprecated. It's badly named and provides redundant functionality. It was\nalso badly broken prior to 2.060 (bug# 8362), so any code which uses it\nprobably needs to be changed anyway. Please use $(D allSatisfy(isSafe, ...))\ninstead. This will be removed in June 2015.)\n\n$(D true) all functions are $(D isSafe).\n\nExample\n-------------\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert( areAllSafe!(add, add));\nstatic assert( areAllSafe!(add, sub));\nstatic assert(!areAllSafe!(sub, mul));\n-------------\n",
				"parameters": [
					{
						"name": "funcs",
						"kind": "tuple"
					}
				],
				"constraint": "funcs.length > 0",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "functionLinkage",
						"line": 1705,
						"type": "string",
						"init": "['F':\"D\", 'U':\"C\", 'W':\"Windows\", 'V':\"Pascal\", 'R':\"C++\"][mangledName!Func[0]]",
						"char": 17,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "functionLinkage",
				"line": 1700,
				"comment": "Returns the calling convention of function as a string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1716_3419)\n---\nextern(D) void Dfunc() {}\nextern(C) void Cfunc() {}\nstatic assert(functionLinkage!Dfunc == \"D\");\nstatic assert(functionLinkage!Cfunc == \"C\");\n\nstring a = functionLinkage!Dfunc;\nassert(a == \"D\");\n\nauto fp = &Cfunc;\nstring b = functionLinkage!fp;\nassert(b == \"C\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1716_3419)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "no",
						"line": 1750,
						"value": "0",
						"comment": "Function is not variadic.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "c",
						"line": 1751,
						"value": "1",
						"comment": "Function is a _C-style variadic function.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "d",
						"line": 1753,
						"value": "2",
						"comment": "Function is a _D-style variadic function, which uses\n\n__argptr and __arguments.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "typesafe",
						"line": 1754,
						"value": "3",
						"comment": "Function is a typesafe variadic function.\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "Variadic",
				"line": 1748,
				"comment": "Determines what kind of variadic parameters function has.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1779_3421)\n---\nvoid func() {}\nstatic assert(variadicFunctionStyle!func == Variadic.no);\n\nextern(C) int printf(in char*, ...);\nstatic assert(variadicFunctionStyle!printf == Variadic.c);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1779_3421)\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "variadicFunctionStyle",
						"line": 1772,
						"type": "Variadic",
						"init": "argclose == 'X' ? Variadic.typesafe : argclose == 'Y' ? callconv == \"C\" ? Variadic.c : Variadic.d : Variadic.no",
						"char": 19,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "variadicFunctionStyle",
				"line": 1758,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "FunctionTypeOf",
				"line": 1817,
				"comment": "Get the function type from a callable object $(D func).\n\nUsing builtin $(D typeof) on a property function yields the types of the\nproperty value, not of the property function itself.  Still,\n$(D FunctionTypeOf) is able to obtain function types of properties.\n\nNote:\nDo not confuse function types with function pointer types; function types are\nusually used for compile-time reflection purposes.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1848_3423)\n---\nclass C\n{\n    int value() @property { return 0; }\n}\nstatic assert(is( typeof(C.value) == int ));\nstatic assert(is( FunctionTypeOf!(C.value) == function ));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1848_3423)\n",
				"parameters": [
					{
						"name": "func",
						"kind": "tuple"
					}
				],
				"constraint": "func.length == 1 && isCallable!func",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "SetFunctionAttributes",
				"line": 1922,
				"comment": " Constructs a new function or delegate type with the same basic signature\n as the given one, but different attributes (including linkage).\n\n This is especially useful for adding/removing attributes to/from types in\n generic code, where the actual type name cannot be spelt out.\n\n Params:\n    T = The base type.\n    linkage = The desired linkage of the result type.\n    attrs = The desired $(LREF FunctionAttribute)s of the result type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2007_3425)\n---\nalias ExternC(T) = SetFunctionAttributes!(T, \"C\", functionAttributes!T);\n\nauto assumePure(T)(T t)\n    if (isFunctionPointer!T || isDelegate!T)\n{\n    enum attrs = functionAttributes!T | FunctionAttribute.pure_;\n    return cast(SetFunctionAttributes!(T, functionLinkage!T, attrs)) t;\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2007_3425)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "linkage",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "attrs",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "isFunctionPointer!T || isDelegate!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "SetFunctionAttributes",
						"line": 2003,
						"type": "FunctionTypeOf!(SetFunctionAttributes!(T*, linkage, attrs))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "SetFunctionAttributes",
				"line": 1997,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "linkage",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "attrs",
						"deco": "k",
						"kind": "value"
					}
				],
				"constraint": "is(T == function)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNested",
						"line": 2086,
						"init": "__traits(isNested, T)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNested",
				"line": 2083,
				"comment": "Determines whether $(D T) has its own context pointer.\n$(D T) must be either $(D class), $(D struct), or $(D union).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2090_3427)\n---\nstatic struct S { }\nstatic assert(!isNested!S);\n\nint i;\nstruct NestedStruct { void f() { ++i; } }\nstatic assert(isNested!NestedStruct);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2090_3427)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class) || is(T == struct) || is(T == union)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasNested",
				"line": 2104,
				"comment": "Determines whether $(D T) or any of its representation types\nhave a context pointer.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2116_3428)\n---\nstatic struct S { }\n\nint i;\nstruct NS { void f() { ++i; } }\n\nstatic assert(!hasNested!(S[2]));\nstatic assert(hasNested!(NS[2]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2116_3428)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Fields",
				"line": 2187,
				"comment": " Get as a tuple the types of the fields of a struct, class, or union.\n This consists of the fields that take up memory space,\n excluding the hidden fields like the virtual function\n table pointer or a context pointer for nested types.\n If $(D T) isn't a struct, class, or union returns a tuple\n with one element $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2198_3430)\n---\nstruct S { int x; float y; }\nstatic assert(is(Fields!S == TypeTuple!(int, float)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2198_3430)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "FieldTypeTuple",
				"line": 2207,
				"comment": " Alternate name for $(LREF FieldTypeTuple), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "FieldNameTuple",
				"line": 2242,
				"comment": " Get as an expression tuple the names of the fields of a struct, class, or\n union. This consists of the fields that take up memory space, excluding the\n hidden fields like the virtual function table pointer or a context pointer\n for nested types. If $(D T) isn't a struct, class, or union returns an\n expression tuple with an empty string.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2253_3432)\n---\nstruct S { int x; float y; }\nstatic assert(FieldNameTuple!S == TypeTuple!(\"x\", \"y\"));\nstatic assert(FieldNameTuple!int == TypeTuple!\"\");\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2253_3432)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "RepresentationTypeTuple",
				"line": 2287,
				"comment": "Get the primitive types of the fields of a struct or class, in\ntopological order.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2328_3434)\n---\nstruct S1 { int a; float b; }\nstruct S2 { char[] a; union { S1 b; S1 * c; } }\nalias R = RepresentationTypeTuple!S2;\nassert(R.length == 4\n    && is(R[0] == char[]) && is(R[1] == int)\n    && is(R[2] == float) && is(R[3] == S1*));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2328_3434)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2402_3436)\n---\n// simple types\nstatic assert(!hasRawAliasing!int);\nstatic assert( hasRawAliasing!(char*));\n// references aren't raw pointers\nstatic assert(!hasRawAliasing!Object);\n// built-in arrays do contain raw pointers\nstatic assert( hasRawAliasing!(int[]));\n// aggregate of simple types\nstruct S1 { int a; double b; }\nstatic assert(!hasRawAliasing!S1);\n// indirect aggregation\nstruct S2 { S1 a; double b; }\nstatic assert(!hasRawAliasing!S2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2402_3436)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2498_3438)\n---\n// simple types\nstatic assert(!hasRawUnsharedAliasing!int);\nstatic assert( hasRawUnsharedAliasing!(char*));\nstatic assert(!hasRawUnsharedAliasing!(shared char*));\n// references aren't raw pointers\nstatic assert(!hasRawUnsharedAliasing!Object);\n// built-in arrays do contain raw pointers\nstatic assert( hasRawUnsharedAliasing!(int[]));\nstatic assert(!hasRawUnsharedAliasing!(shared int[]));\n// aggregate of simple types\nstruct S1 { int a; double b; }\nstatic assert(!hasRawUnsharedAliasing!S1);\n// indirect aggregation\nstruct S2 { S1 a; double b; }\nstatic assert(!hasRawUnsharedAliasing!S2);\n// struct with a pointer member\nstruct S3 { int a; double * b; }\nstatic assert( hasRawUnsharedAliasing!S3);\nstruct S4 { int a; shared double * b; }\nstatic assert(!hasRawUnsharedAliasing!S4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2498_3438)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasAliasing",
				"line": 2702,
				"comment": "Returns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable;) $(LI an array $(D U[]) and $(D U) is not\nimmutable;) $(LI a reference to a class or interface type $(D C) and $(D C) is\nnot immutable.) $(LI an associative array that is not immutable.)\n$(LI a delegate.))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2724_3440)\n---\nstruct S1 { int a; Object b; }\nstruct S2 { string a; }\nstruct S3 { int a; immutable Object b; }\nstruct S4 { float[3] vals; }\nstatic assert( hasAliasing!S1);\nstatic assert(!hasAliasing!S2);\nstatic assert(!hasAliasing!S3);\nstatic assert(!hasAliasing!S4);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2724_3440)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasIndirections",
				"line": 2805,
				"comment": "Returns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*);) $(LI an\narray $(D U[]);) $(LI a reference to a class type $(D C).)\n$(LI an associative array.) $(LI a delegate.))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2819_3442)\n---\nstatic assert( hasIndirections!(int[string]));\nstatic assert( hasIndirections!(void delegate()));\nstatic assert( hasIndirections!(void delegate() immutable));\nstatic assert( hasIndirections!(immutable(void delegate())));\nstatic assert( hasIndirections!(immutable(void delegate() immutable)));\n\nstatic assert(!hasIndirections!(void function()));\nstatic assert( hasIndirections!(void*[1]));\nstatic assert(!hasIndirections!(byte[1]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2819_3442)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasUnsharedAliasing",
				"line": 2915,
				"comment": "Returns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable or shared;) $(LI an array $(D U[]) and $(D U) is not\nimmutable or shared;) $(LI a reference to a class type $(D C) and\n$(D C) is not immutable or shared.) $(LI an associative array that is not\nimmutable or shared.) $(LI a delegate that is not shared.))\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2948_3445)\n---\nstruct S1 { int a; Object b; }\nstruct S2 { string a; }\nstruct S3 { int a; immutable Object b; }\nstatic assert( hasUnsharedAliasing!S1);\nstatic assert(!hasUnsharedAliasing!S2);\nstatic assert(!hasUnsharedAliasing!S3);\n\nstruct S4 { int a; shared Object b; }\nstruct S5 { char[] a; }\nstruct S6 { shared char[] b; }\nstruct S7 { float[3] vals; }\nstatic assert(!hasUnsharedAliasing!S4);\nstatic assert( hasUnsharedAliasing!S5);\nstatic assert(!hasUnsharedAliasing!S6);\nstatic assert(!hasUnsharedAliasing!S7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2948_3445)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasElaborateCopyConstructor",
				"line": 3090,
				"comment": " True if $(D S) or any type embedded directly in the representation of $(D S)\n defines an elaborate copy constructor. Elaborate copy constructors are\n introduced by defining $(D this(this)) for a $(D struct).\n\n Classes and unions never have elaborate copy constructors.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3108_3448)\n---\nstatic assert(!hasElaborateCopyConstructor!int);\n\nstatic struct S1 { }\nstatic struct S2 { this(this) {} }\nstatic struct S3 { S2 field; }\nstatic struct S4 { S3[1] field; }\nstatic struct S5 { S3[] field; }\nstatic struct S6 { S3[0] field; }\nstatic struct S7 { @disable this(); S3 field; }\nstatic assert(!hasElaborateCopyConstructor!S1);\nstatic assert( hasElaborateCopyConstructor!S2);\nstatic assert( hasElaborateCopyConstructor!(immutable S2));\nstatic assert( hasElaborateCopyConstructor!S3);\nstatic assert( hasElaborateCopyConstructor!(S3[1]));\nstatic assert(!hasElaborateCopyConstructor!(S3[0]));\nstatic assert( hasElaborateCopyConstructor!S4);\nstatic assert(!hasElaborateCopyConstructor!S5);\nstatic assert(!hasElaborateCopyConstructor!S6);\nstatic assert( hasElaborateCopyConstructor!S7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3108_3448)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasElaborateAssign",
				"line": 3146,
				"comment": "   True if $(D S) or any type directly embedded in the representation of $(D S)\n   defines an elaborate assignment. Elaborate assignments are introduced by\n   defining $(D opAssign(typeof(this))) or $(D opAssign(ref typeof(this)))\n   for a $(D struct) or when there is a compiler-generated $(D opAssign).\n\n   A type $(D S) gets compiler-generated $(D opAssign) in case it has\n   an elaborate copy constructor or elaborate destructor.\n\n   Classes and unions never have elaborate assignments.\n\n   Note: Structs with (possibly nested) postblit operator(s) will have a\n   hidden yet elaborate compiler generated assignment operator (unless\n   explicitly disabled).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3165_3449)\n---\nstatic assert(!hasElaborateAssign!int);\n\nstatic struct S  { void opAssign(S) {} }\nstatic assert( hasElaborateAssign!S);\nstatic assert(!hasElaborateAssign!(const(S)));\n\nstatic struct S1 { void opAssign(ref S1) {} }\nstatic struct S2 { void opAssign(int) {} }\nstatic struct S3 { S s; }\nstatic assert( hasElaborateAssign!S1);\nstatic assert(!hasElaborateAssign!S2);\nstatic assert( hasElaborateAssign!S3);\nstatic assert( hasElaborateAssign!(S3[1]));\nstatic assert(!hasElaborateAssign!(S3[0]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3165_3449)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasElaborateDestructor",
				"line": 3232,
				"comment": "   True if $(D S) or any type directly embedded in the representation\n   of $(D S) defines an elaborate destructor. Elaborate destructors\n   are introduced by defining $(D ~this()) for a $(D\n   struct).\n\n   Classes and unions never have elaborate destructors, even\n   though classes may define $(D ~this()).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3250_3451)\n---\nstatic assert(!hasElaborateDestructor!int);\n\nstatic struct S1 { }\nstatic struct S2 { ~this() {} }\nstatic struct S3 { S2 field; }\nstatic struct S4 { S3[1] field; }\nstatic struct S5 { S3[] field; }\nstatic struct S6 { S3[0] field; }\nstatic struct S7 { @disable this(); S3 field; }\nstatic assert(!hasElaborateDestructor!S1);\nstatic assert( hasElaborateDestructor!S2);\nstatic assert( hasElaborateDestructor!(immutable S2));\nstatic assert( hasElaborateDestructor!S3);\nstatic assert( hasElaborateDestructor!(S3[1]));\nstatic assert(!hasElaborateDestructor!(S3[0]));\nstatic assert( hasElaborateDestructor!S4);\nstatic assert(!hasElaborateDestructor!S5);\nstatic assert(!hasElaborateDestructor!S6);\nstatic assert( hasElaborateDestructor!S7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3250_3451)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasMember",
				"line": 3279,
				"comment": "   Yields $(D true) if and only if $(D T) is an aggregate that defines\n   a symbol called $(D name).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3294_3452)\n---\nstatic assert(!hasMember!(int, \"blah\"));\nstruct S1 { int blah; }\nstruct S2 { int blah(){ return 0; } }\nclass C1 { int blah; }\nclass C2 { int blah(){ return 0; } }\nstatic assert(hasMember!(S1, \"blah\"));\nstatic assert(hasMember!(S2, \"blah\"));\nstatic assert(hasMember!(C1, \"blah\"));\nstatic assert(hasMember!(C2, \"blah\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3294_3452)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "EnumMembers",
						"line": 3443,
						"type": "EnumSpecificMembers!(__traits(allMembers, E))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "EnumMembers",
				"line": 3404,
				"comment": "Retrieves the members of an enumerated type $(D enum E).\n\nParams:\n E = An enumerated type. $(D E) may have duplicated values.\n\nReturns:\n Static tuple composed of the members of the enumerated type $(D E).\n The members are arranged in the same order as declared in $(D E).\n\nNote:\n An enum can have multiple members which have the same value. If you want\n to use EnumMembers to e.g. generate switch cases at compile-time,\n you should use the $(XREF typetuple, NoDuplicates) template to avoid\n generating duplicate switch cases.\n\nNote:\n Returned values are strictly typed with $(D E). Thus, the following code\n does not work without the explicit cast:\n--------------------\nenum E : int { a, b, c }\nint[] abc = cast(int[]) [ EnumMembers!E ];\n--------------------\n Cast is not necessary if the type of the variable is inferred. See the\n example below.\n\nExamples:\n Creating an array of enumerated values:\n--------------------\nenum Sqrts : real\n{\n    one   = 1,\n    two   = 1.41421,\n    three = 1.73205,\n}\nauto sqrts = [ EnumMembers!Sqrts ];\nassert(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);\n--------------------\n\n A generic function $(D rank(v)) in the following example uses this\n template for finding a member $(D e) in an enumerated type $(D E).\n--------------------\n// Returns i if e is the i-th enumerator of E.\nsize_t rank(E)(E e)\n    if (is(E == enum))\n{\n    foreach (i, member; EnumMembers!E)\n    {\n        if (e == member)\n            return i;\n    }\n    assert(0, \"Not an enum member\");\n}\n\nenum Mode\n{\n    read  = 1,\n    write = 2,\n    map   = 4,\n}\nassert(rank(Mode.read ) == 0);\nassert(rank(Mode.write) == 1);\nassert(rank(Mode.map  ) == 2);\n--------------------\n",
				"parameters": [
					{
						"name": "E",
						"kind": "type"
					}
				],
				"constraint": "is(E == enum)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "BaseTypeTuple",
				"line": 3496,
				"comment": " Get a $(D_PARAM TypeTuple) of the base class and base interfaces of\n this class or interface. $(D_PARAM BaseTypeTuple!Object) returns\n the empty type tuple.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3505_3458)\n---\ninterface I1 { }\ninterface I2 { }\ninterface I12 : I1, I2 { }\nstatic assert(is(BaseTypeTuple!I12 == TypeTuple!(I1, I2)));\n\ninterface I3 : I1 { }\ninterface I123 : I1, I2, I3 { }\nstatic assert(is(BaseTypeTuple!I123 == TypeTuple!(I1, I2, I3)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3505_3458)\n",
				"parameters": [
					{
						"name": "A",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "BaseClassesTuple",
				"line": 3538,
				"comment": " Get a $(D_PARAM TypeTuple) of $(I all) base classes of this class,\n in decreasing order. Interfaces are not included. $(D_PARAM\n BaseClassesTuple!Object) yields the empty type tuple.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3558_3460)\n---\nclass C1 { }\nclass C2 : C1 { }\nclass C3 : C2 { }\nstatic assert(!BaseClassesTuple!Object.length);\nstatic assert(is(BaseClassesTuple!C1 == TypeTuple!(Object)));\nstatic assert(is(BaseClassesTuple!C2 == TypeTuple!(C1, Object)));\nstatic assert(is(BaseClassesTuple!C3 == TypeTuple!(C2, C1, Object)));\nstatic assert(!BaseClassesTuple!Object.length);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3558_3460)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "InterfacesTuple",
				"line": 3587,
				"comment": " Get a $(D_PARAM TypeTuple) of $(I all) interfaces directly or\n indirectly inherited by this class or interface. Interfaces do not\n repeat if multiply implemented. $(D_PARAM InterfacesTuple!Object)\n yields the empty type tuple.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "TransitiveBaseTypeTuple",
				"line": 3647,
				"comment": " Get a $(D_PARAM TypeTuple) of $(I all) base classes of $(D_PARAM\n T), in decreasing order, followed by $(D_PARAM T)'s\n interfaces. $(D_PARAM TransitiveBaseTypeTuple!Object) yields the\n empty type tuple.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3657_3464)\n---\ninterface J1 {}\ninterface J2 {}\nclass B1 {}\nclass B2 : B1, J1, J2 {}\nclass B3 : B2, J1 {}\nalias TL = TransitiveBaseTypeTuple!B3;\nassert(TL.length == 5);\nassert(is (TL[0] == B2));\nassert(is (TL[1] == B1));\nassert(is (TL[2] == Object));\nassert(is (TL[3] == J1));\nassert(is (TL[4] == J2));\n\nassert(TransitiveBaseTypeTuple!Object.length == 0);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3657_3464)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "MemberFunctionsTuple",
				"line": 3681,
				"comment": "Returns a tuple of non-static functions with the name $(D name) declared in the\nclass or interface $(D C).  Covariant duplicates are shrunk into the most\nderived one.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3772_3465)\n---\ninterface I { I foo(); }\nclass B\n{\n    real foo(real v) { return v; }\n}\nclass C : B, I\n{\n    override C foo() { return this; } // covariant overriding of I.foo()\n}\nalias foos = MemberFunctionsTuple!(C, \"foo\");\nstatic assert(foos.length == 2);\nstatic assert(__traits(isSame, foos[0], C.foo));\nstatic assert(__traits(isSame, foos[1], B.foo));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3772_3465)\n",
				"parameters": [
					{
						"name": "C",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					}
				],
				"constraint": "is(C == class) || is(C == interface)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateOf",
						"line": 3835,
						"type": "Base",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateOf",
				"line": 3833,
				"comment": "Returns an alias to the template that $(D T) is an instance of.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3845_3467)\n---\nstruct Foo(T, U) {}\nstatic assert(__traits(isSame, TemplateOf!(Foo!(int, real)), Foo));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3845_3467)\n",
				"parameters": [
					{
						"name": "T",
						"specAlias": "Base!Args",
						"kind": "alias"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateOf",
						"line": 3841,
						"type": "Base",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateOf",
				"line": 3839,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"type": "Base!Args",
						"kind": "type"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateArgsOf",
						"line": 3880,
						"type": "Args",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateArgsOf",
				"line": 3878,
				"comment": "Returns a $(D TypeTuple) of the template arguments used to instantiate $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3890_3469)\n---\nstruct Foo(T, U) {}\nstatic assert(is(TemplateArgsOf!(Foo!(int, real)) == TypeTuple!(int, real)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3890_3469)\n",
				"parameters": [
					{
						"name": "T",
						"specAlias": "Base!Args",
						"kind": "alias"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "TemplateArgsOf",
						"line": 3886,
						"type": "Args",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "TemplateArgsOf",
				"line": 3884,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"type": "Base!Args",
						"kind": "type"
					},
					{
						"name": "Base",
						"kind": "alias"
					},
					{
						"name": "Args",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "classInstanceAlignment",
						"line": 3941,
						"type": "maxAlignment!(void*, typeof(T.tupleof))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "classInstanceAlignment",
				"line": 3939,
				"comment": "Returns class instance alignment.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3945_3471)\n---\nclass A { byte b; }\nclass B { long l; }\n\n// As class instance always has a hidden pointer\nstatic assert(classInstanceAlignment!A == (void*).alignof);\nstatic assert(classInstanceAlignment!B == long.alignof);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3945_3471)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "CommonType",
				"line": 3966,
				"comment": "Get the type that all types can be implicitly converted to. Useful\ne.g. in figuring out an array type from a bunch of initializing\nvalues. Returns $(D_PARAM void) if passed an empty list, or if the\ntypes have no common type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3992_3472)\n---\nalias X = CommonType!(int, long, short);\nassert(is(X == long));\nalias Y = CommonType!(int, char[], short);\nassert(is(Y == void));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3992_3472)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "ImplicitConversionTargets",
				"line": 4019,
				"comment": " Returns a tuple with all possible target types of an implicit\n conversion of a value of type $(D_PARAM T).\n\n Important note:\n\n The possible targets are computed more conservatively than the D\n 2.005 compiler does, eliminating all dangerous conversions. For\n example, $(D_PARAM ImplicitConversionTargets!double) does not\n include $(D_PARAM float).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isImplicitlyConvertible",
						"line": 4092,
						"deco": "b",
						"init": "is(typeof(()\n{\nvoid fun(ref From v)\n{\nvoid gun(To)\n{\n}\ngun(v);\n}\n}\n))",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isImplicitlyConvertible",
				"line": 4090,
				"comment": "Is $(D From) implicitly convertible to $(D To)?\n",
				"parameters": [
					{
						"name": "From",
						"kind": "type"
					},
					{
						"name": "To",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAssignable",
						"line": 4127,
						"init": "isRvalueAssignable!(Lhs, Rhs) && isLvalueAssignable!(Lhs, Rhs)",
						"char": 6,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAssignable",
				"line": 4127,
				"comment": "Returns $(D true) iff a value of type $(D Rhs) can be assigned to a variable of\ntype $(D Lhs).\n\n$(D isAssignable) returns whether both an lvalue and rvalue can be assigned.\n\nIf you omit $(D Rhs), $(D isAssignable) will check identity assignable of $(D Lhs).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4130_3476)\n---\nstatic assert( isAssignable!(long, int));\nstatic assert(!isAssignable!(int, long));\nstatic assert( isAssignable!(const(char)[], string));\nstatic assert(!isAssignable!(string, char[]));\n\n// int is assignable to int\nstatic assert( isAssignable!int);\n\n// immutable int is not assignable to immutable int\nstatic assert(!isAssignable!(immutable int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4130_3476)\n",
				"parameters": [
					{
						"name": "Lhs",
						"kind": "type"
					},
					{
						"name": "Rhs",
						"default": "Lhs",
						"kind": "type"
					}
				],
				"char": 6,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isCovariantWith",
				"line": 4338,
				"comment": "Determines whether the function type $(D F) is covariant with $(D G), i.e.,\nfunctions of the type $(D F) can override ones of the type $(D G).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL4447_3480)\n---\ninterface I { I clone(); }\ninterface J { J clone(); }\nclass C : I\n{\n    override C clone()   // covariant overriding of I.clone()\n    {\n        return new C;\n    }\n}\n\n// C.clone() can override I.clone(), indeed.\nstatic assert(isCovariantWith!(typeof(C.clone), typeof(I.clone)));\n\n// C.clone() can't override J.clone(); the return type C is not implicitly\n// convertible to J.\nstatic assert(!isCovariantWith!(typeof(C.clone), typeof(J.clone)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL4447_3480)\n",
				"parameters": [
					{
						"name": "F",
						"kind": "type"
					},
					{
						"name": "G",
						"kind": "type"
					}
				],
				"constraint": "is(F == function) && is(G == function)",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "rvalueOf",
						"line": 4551,
						"type": "@property T(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init)",
						"parameters": [
							{
								"type": "__InoutWorkaroundStruct",
								"storageClass": [
									"inout"
								],
								"default": "__InoutWorkaroundStruct.init"
							}
						],
						"char": 13,
						"kind": "function"
					}
				],
				"name": "rvalueOf",
				"line": 4551,
				"comment": "Creates an lvalue or rvalue of type $(D T) for $(D typeof(...)) and\n$(D __traits(compiles, ...)) purposes. No actual value is returned.\n\nNote: Trying to use returned value will result in a\n\"Symbol Undefined\" error at link time.\n\nExamples:\n---\n// Note that `f` doesn't have to be implemented\n// as is isn't called.\nint f(int);\nbool f(ref int);\nstatic assert(is(typeof(f(rvalueOf!int)) == int));\nstatic assert(is(typeof(f(lvalueOf!int)) == bool));\n\nint i = rvalueOf!int; // error, no actual value is returned\n---\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 13,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "lvalueOf",
						"line": 4554,
						"type": "@property ref T(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init)",
						"parameters": [
							{
								"type": "__InoutWorkaroundStruct",
								"storageClass": [
									"inout"
								],
								"default": "__InoutWorkaroundStruct.init"
							}
						],
						"char": 17,
						"kind": "function"
					}
				],
				"name": "lvalueOf",
				"line": 4554,
				"comment": "ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 17,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBoolean",
						"line": 5004,
						"deco": "b",
						"init": "is(BooleanTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBoolean",
				"line": 5004,
				"comment": " Detect whether $(D T) is a built-in boolean type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5007_3494)\n---\nstatic assert( isBoolean!bool);\nenum EB : bool { a = true }\nstatic assert( isBoolean!EB);\nstatic assert(!isBoolean!(SubTypeOf!bool));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5007_3494)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isIntegral",
						"line": 5019,
						"deco": "b",
						"init": "is(IntegralTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isIntegral",
				"line": 5019,
				"comment": " Detect whether $(D T) is a built-in integral type. Types $(D bool),\n $(D char), $(D wchar), and $(D dchar) are not considered integral.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isFloatingPoint",
						"line": 5043,
						"deco": "b",
						"init": "is(FloatingPointTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFloatingPoint",
				"line": 5043,
				"comment": " Detect whether $(D T) is a built-in floating point type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNumeric",
						"line": 5070,
						"deco": "b",
						"init": "is(NumericTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNumeric",
				"line": 5070,
				"comment": "Detect whether $(D T) is a built-in numeric type (integral or floating\npoint).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isScalarType",
						"line": 5087,
						"deco": "b",
						"init": "isNumeric!T || isSomeChar!T || isBoolean!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isScalarType",
				"line": 5087,
				"comment": "Detect whether $(D T) is a scalar type (a built-in numeric, character or boolean type).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5090_3498)\n---\nstatic assert(!isScalarType!void);\nstatic assert( isScalarType!(immutable(int)));\nstatic assert( isScalarType!(shared(float)));\nstatic assert( isScalarType!(shared(const bool)));\nstatic assert( isScalarType!(const(dchar)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5090_3498)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBasicType",
						"line": 5102,
						"deco": "b",
						"init": "isScalarType!T || is(T == void)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBasicType",
				"line": 5102,
				"comment": "Detect whether $(D T) is a basic type (scalar type or void).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5105_3499)\n---\nstatic assert(isBasicType!void);\nstatic assert(isBasicType!(immutable(int)));\nstatic assert(isBasicType!(shared(float)));\nstatic assert(isBasicType!(shared(const bool)));\nstatic assert(isBasicType!(const(dchar)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5105_3499)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isUnsigned",
						"line": 5117,
						"deco": "b",
						"init": "is(UnsignedTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isUnsigned",
				"line": 5117,
				"comment": "Detect whether $(D T) is a built-in unsigned numeric type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSigned",
						"line": 5134,
						"deco": "b",
						"init": "is(SignedTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSigned",
				"line": 5134,
				"comment": "Detect whether $(D T) is a built-in signed numeric type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSomeChar",
						"line": 5151,
						"deco": "b",
						"init": "is(CharTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSomeChar",
				"line": 5151,
				"comment": "Detect whether $(D T) is one of the built-in character types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5154_3502)\n---\nstatic assert(!isSomeChar!int);\nstatic assert(!isSomeChar!byte);\nstatic assert(!isSomeChar!string);\nstatic assert(!isSomeChar!wstring);\nstatic assert(!isSomeChar!dstring);\nstatic assert(!isSomeChar!(char[4]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5154_3502)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSomeString",
						"line": 5187,
						"deco": "b",
						"init": "is(StringTypeOf!T) && !isAggregateType!T && !isStaticArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSomeString",
				"line": 5187,
				"comment": "Detect whether $(D T) is one of the built-in string types.\n\nThe built-in string types are $(D Char[]), where $(D Char) is any of $(D char),\n$(D wchar) or $(D dchar), with or without qualifiers.\n\nStatic arrays of characters (like $(D char[80])) are not considered\nbuilt-in string types.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5190_3504)\n---\nstatic assert(!isSomeString!int);\nstatic assert(!isSomeString!(int[]));\nstatic assert(!isSomeString!(byte[]));\nstatic assert(!isSomeString!(typeof(null)));\nstatic assert(!isSomeString!(char[4]));\n\nenum ES : string { a = \"aaa\", b = \"bbb\" }\nstatic assert( isSomeString!ES);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5190_3504)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNarrowString",
						"line": 5217,
						"deco": "b",
						"init": "(is(T : const(char[])) || is(T : const(wchar[]))) && !isAggregateType!T && !isStaticArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNarrowString",
				"line": 5217,
				"comment": " Detect whether type $(D T) is a narrow string.\n\n All arrays that use char, wchar, and their qualified versions are narrow\n strings. (Those include string and wstring).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAutodecodableString",
						"line": 5257,
						"deco": "b",
						"init": "(is(T : const(char[])) || is(T : const(wchar[]))) && !isStaticArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAutodecodableString",
				"line": 5257,
				"comment": " Detect whether type $(D T) is a string that will be autodecoded.\n\n All arrays that use char, wchar, and their qualified versions are narrow\n strings. (Those include string and wstring).\n Aggregates that implicitly cast to narrow strings are included.\n\n Params:\n      T = type to be tested\n\n Returns:\n      true if T represents a string that is subject to autodecoding\n\n See Also:\n      $(LREF isNarrowString)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5260_3507)\n---\nstatic struct Stringish\n{\n    string s;\n    alias s this;\n}\nassert(isAutodecodableString!wstring);\nassert(isAutodecodableString!Stringish);\nassert(!isAutodecodableString!dstring);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5260_3507)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isStaticArray",
						"line": 5275,
						"deco": "b",
						"init": "is(StaticArrayTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isStaticArray",
				"line": 5275,
				"comment": " Detect whether type $(D T) is a static array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5278_3508)\n---\nstatic assert(!isStaticArray!(const(int)[]));\nstatic assert(!isStaticArray!(immutable(int)[]));\nstatic assert(!isStaticArray!(const(int)[4][]));\nstatic assert(!isStaticArray!(int[]));\nstatic assert(!isStaticArray!(int[char]));\nstatic assert(!isStaticArray!(int[1][]));\nstatic assert(!isStaticArray!(int[int]));\nstatic assert(!isStaticArray!int);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5278_3508)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isDynamicArray",
						"line": 5310,
						"deco": "b",
						"init": "is(DynamicArrayTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isDynamicArray",
				"line": 5310,
				"comment": " Detect whether type $(D T) is a dynamic array.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isArray",
						"line": 5334,
						"deco": "b",
						"init": "isStaticArray!T || isDynamicArray!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isArray",
				"line": 5334,
				"comment": " Detect whether type $(D T) is an array (static or dynamic; for associative\n  arrays see $(LREF isAssociativeArray)).\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAssociativeArray",
						"line": 5355,
						"deco": "b",
						"init": "is(AssocArrayTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAssociativeArray",
				"line": 5355,
				"comment": " Detect whether $(D T) is an associative array type\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isBuiltinType",
						"line": 5386,
						"deco": "b",
						"init": "is(BuiltinTypeOf!T) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isBuiltinType",
				"line": 5386,
				"comment": " Detect whether type $(D T) is a builtin type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5389_3513)\n---\nclass C;\nunion U;\nstruct S;\ninterface I;\n\nstatic assert( isBuiltinType!void);\nstatic assert( isBuiltinType!string);\nstatic assert( isBuiltinType!(int[]));\nstatic assert( isBuiltinType!(C[string]));\nstatic assert(!isBuiltinType!C);\nstatic assert(!isBuiltinType!U);\nstatic assert(!isBuiltinType!S);\nstatic assert(!isBuiltinType!I);\nstatic assert(!isBuiltinType!(void delegate(int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5389_3513)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isSIMDVector",
						"line": 5410,
						"deco": "b",
						"init": "is(T : __vector(V[N]), V, size_t N)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isSIMDVector",
				"line": 5410,
				"comment": " Detect whether type $(D T) is a SIMD vector type.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isPointer",
						"line": 5427,
						"deco": "b",
						"init": "is(T == U*, U) && !isAggregateType!T",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isPointer",
				"line": 5427,
				"comment": " Detect whether type $(D T) is a pointer.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "PointerTarget",
						"line": 5449,
						"type": "T",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "PointerTarget",
				"line": 5449,
				"comment": "Returns the target type of a pointer.\n",
				"parameters": [
					{
						"name": "T",
						"type": "T*",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "pointerTarget",
				"line": 5456,
				"comment": "  $(RED Deprecated. Please use $(LREF PointerTarget) instead. This will be\n        removed in June 2015.)\n",
				"storageClass": [
					"deprecated"
				],
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "isAggregateType",
						"line": 5469,
						"deco": "b",
						"init": "is(T == struct) || is(T == union) || is(T == class) || is(T == interface)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAggregateType",
				"line": 5469,
				"comment": " Detect whether type $(D T) is an aggregate type.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5473_3517)\n---\nclass C;\nunion U;\nstruct S;\ninterface I;\n\nstatic assert( isAggregateType!C);\nstatic assert( isAggregateType!U);\nstatic assert( isAggregateType!S);\nstatic assert( isAggregateType!I);\nstatic assert(!isAggregateType!void);\nstatic assert(!isAggregateType!string);\nstatic assert(!isAggregateType!(int[]));\nstatic assert(!isAggregateType!(C[string]));\nstatic assert(!isAggregateType!(void delegate(int)));\n}\n\n/**\n* Returns $(D true) if T can be iterated over using a $(D foreach) loop with\n* a single loop variable of automatically inferred type, regardless of how\n* the $(D foreach) loop is implemented.  This includes ranges, structs/classes\n* that define $(D opApply) with a single loop variable, and builtin dynamic,\n* static and associative arrays.\n*/\nenum bool isIterable(T) = is(typeof({ foreach(elem; T.init) {} \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5473_3517)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isIterable",
						"line": 5498,
						"deco": "b",
						"init": "is(typeof(()\n{\nforeach (elem; T.init)\n{\n}\n}\n))",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isIterable",
				"line": 5498,
				"comment": " Returns $(D true) if T can be iterated over using a $(D foreach) loop with\n a single loop variable of automatically inferred type, regardless of how\n the $(D foreach) loop is implemented.  This includes ranges, structs/classes\n that define $(D opApply) with a single loop variable, and builtin dynamic,\n static and associative arrays.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5501_3518)\n---\nstruct OpApply\n{\n    int opApply(int delegate(ref uint) dg) { assert(0); }\n}\n\nstruct Range\n{\n    @property uint front() { assert(0); }\n    void popFront() { assert(0); }\n    enum bool empty = false;\n}\n\nstatic assert( isIterable!(uint[]));\nstatic assert( isIterable!OpApply);\nstatic assert( isIterable!(uint[string]));\nstatic assert( isIterable!Range);\n\nstatic assert(!isIterable!uint);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5501_3518)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isMutable",
						"line": 5527,
						"deco": "b",
						"init": "!is(T == const) && !is(T == immutable) && !is(T == inout)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isMutable",
				"line": 5527,
				"comment": " Returns true if T is not const or immutable.  Note that isMutable is true for\n string, or immutable(char)[], because the 'head' is mutable.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5530_3519)\n---\nstatic assert( isMutable!int);\nstatic assert( isMutable!string);\nstatic assert( isMutable!(shared int));\nstatic assert( isMutable!(shared const(int)[]));\n\nstatic assert(!isMutable!(const int));\nstatic assert(!isMutable!(inout int));\nstatic assert(!isMutable!(shared(const int)));\nstatic assert(!isMutable!(shared(inout int)));\nstatic assert(!isMutable!(immutable string));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5530_3519)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isInstanceOf",
						"line": 5547,
						"deco": "b",
						"init": "is(T == S!Args, Args...)",
						"char": 11,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isInstanceOf",
				"line": 5547,
				"comment": " Returns true if T is an instance of the template S.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5550_3520)\n---\nstatic struct Foo(T...) { }\nstatic struct Bar(T...) { }\nstatic struct Doo(T) { }\nstatic struct ABC(int x) { }\nstatic assert(isInstanceOf!(Foo, Foo!int));\nstatic assert(!isInstanceOf!(Foo, Bar!int));\nstatic assert(!isInstanceOf!(Foo, int));\nstatic assert(isInstanceOf!(Doo, Doo!int));\nstatic assert(isInstanceOf!(ABC, ABC!1));\nstatic assert(!__traits(compiles, isInstanceOf!(Foo, Foo)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5550_3520)\n",
				"parameters": [
					{
						"name": "S",
						"kind": "alias"
					},
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 11,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isExpressions",
				"line": 5570,
				"comment": " Check whether the tuple T is an expression tuple.\n An expression tuple only contains expressions.\n\n See_Also: $(LREF isTypeTuple).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5584_3521)\n---\nstatic assert(isExpressions!(1, 2.0, \"a\"));\nstatic assert(!isExpressions!(int, double, string));\nstatic assert(!isExpressions!(int, 2.0, \"a\"));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5584_3521)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"name": "isExpressionTuple",
				"line": 5595,
				"comment": " Alternate name for $(LREF isExpressions), kept for legacy compatibility.\n",
				"char": 1,
				"kind": "alias"
			},
			{
				"members": [],
				"name": "isTypeTuple",
				"line": 5623,
				"comment": " Check whether the tuple $(D T) is a type tuple.\n A type tuple only contains types.\n\n See_Also: $(LREF isExpressions).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5634_3524)\n---\nstatic assert(isTypeTuple!(int, float, string));\nstatic assert(!isTypeTuple!(1, 2.0, \"a\"));\nstatic assert(!isTypeTuple!(1, double, string));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5634_3524)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isFunctionPointer",
				"line": 5663,
				"comment": "Detect whether symbol or type $(D T) is a function pointer.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5678_3526)\n---\nstatic void foo() {}\nvoid bar() {}\n\nauto fpfoo = &foo;\nstatic assert( isFunctionPointer!fpfoo);\nstatic assert( isFunctionPointer!(void function()));\n\nauto dgbar = &bar;\nstatic assert(!isFunctionPointer!dgbar);\nstatic assert(!isFunctionPointer!(void delegate()));\nstatic assert(!isFunctionPointer!foo);\nstatic assert(!isFunctionPointer!bar);\n\nstatic assert( isFunctionPointer!((int a) {}));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5678_3526)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isDelegate",
				"line": 5699,
				"comment": "Detect whether symbol or type $(D T) is a delegate.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5717_3527)\n---\nstatic void sfunc() { }\nint x;\nvoid func() { x++; }\n\nint delegate() dg;\nassert(isDelegate!dg);\nassert(isDelegate!(int delegate()));\nassert(isDelegate!(typeof(&func)));\n\nint function() fp;\nassert(!isDelegate!fp);\nassert(!isDelegate!(int function()));\nassert(!isDelegate!(typeof(&sfunc)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5717_3527)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isSomeFunction",
				"line": 5737,
				"comment": "Detect whether symbol or type $(D T) is a function, a function pointer or a delegate.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "isCallable",
				"line": 5798,
				"comment": "Detect whether $(D T) is a callable object, which can be called with the\nfunction call operator $(D $(LPAREN)...$(RPAREN)).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5812_3529)\n---\ninterface I { real value() @property; }\nstruct S { static int opCall(int) { return 0; } }\nclass C { int opCall(int) { return 0; } }\nauto c = new C;\n\nstatic assert( isCallable!c);\nstatic assert( isCallable!S);\nstatic assert( isCallable!(c.opCall));\nstatic assert( isCallable!(I.value));\nstatic assert( isCallable!((int a) { return a; }));\n\nstatic assert(!isCallable!I);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5812_3529)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAbstractFunction",
						"line": 5835,
						"deco": "b",
						"init": "__traits(isAbstractFunction, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAbstractFunction",
				"line": 5832,
				"comment": " Detect whether $(D T) is a an abstract function.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isFinalFunction",
						"line": 5854,
						"deco": "b",
						"init": "__traits(isFinalFunction, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFinalFunction",
				"line": 5851,
				"comment": " Detect whether $(D T) is a a final function.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5858_3531)\n---\nstruct S { void bar() { } }\nfinal class FC { void foo(); }\nclass C\n{\n    void bar() { }\n    final void foo();\n}\nstatic assert(!isFinalFunction!(S.bar));\nstatic assert( isFinalFunction!(FC.foo));\nstatic assert(!isFinalFunction!(C.bar));\nstatic assert( isFinalFunction!(C.foo));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5858_3531)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isNestedFunction",
						"line": 5878,
						"init": "__traits(isNested, f)",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isNestedFunction",
				"line": 5876,
				"comment": "Determines whether function $(D f) requires a context pointer.\n",
				"parameters": [
					{
						"name": "f",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isAbstractClass",
						"line": 5895,
						"deco": "b",
						"init": "__traits(isAbstractClass, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isAbstractClass",
				"line": 5892,
				"comment": " Detect whether $(D T) is a an abstract class.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5899_3533)\n---\nstruct S { }\nclass C { }\nabstract class AC { }\nstatic assert(!isAbstractClass!S);\nstatic assert(!isAbstractClass!C);\nstatic assert( isAbstractClass!AC);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5899_3533)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "isFinalClass",
						"line": 5915,
						"deco": "b",
						"init": "__traits(isFinalClass, T[0])",
						"char": 15,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "isFinalClass",
				"line": 5912,
				"comment": " Detect whether $(D T) is a a final class.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5919_3534)\n---\nclass C { }\nabstract class AC { }\nfinal class FC1 : C { }\nfinal class FC2 { }\nstatic assert(!isFinalClass!C);\nstatic assert(!isFinalClass!AC);\nstatic assert( isFinalClass!FC1);\nstatic assert( isFinalClass!FC2);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5919_3534)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Unqual",
				"line": 5938,
				"comment": "Removes all qualifiers, if any, from type $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL5963_3535)\n---\nstatic assert(is(Unqual!int == int));\nstatic assert(is(Unqual!(const int) == int));\nstatic assert(is(Unqual!(immutable int) == int));\nstatic assert(is(Unqual!(shared int) == int));\nstatic assert(is(Unqual!(shared(const int)) == int));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL5963_3535)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "CopyTypeQualifiers",
						"line": 6034,
						"type": "ModifyTypePreservingTQ!(T, FromType)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "CopyTypeQualifiers",
				"line": 6031,
				"comment": " Copies type qualifiers from $(D FromType) to $(D ToType).\n\n Supported type qualifiers:\n $(UL\n     $(LI $(D const))\n     $(LI $(D inout))\n     $(LI $(D immutable))\n     $(LI $(D shared))\n )\n Examples:\n ---\n static assert(is(CopyTypeQualifiers!(inout const real, int) == inout const int));\n ---\n",
				"parameters": [
					{
						"name": "FromType",
						"kind": "type"
					},
					{
						"name": "ToType",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ForeachType",
						"line": 6059,
						"type": "ReturnType!(typeof((inout int x = 0)\n{\nforeach (elem; T.init)\n{\nreturn elem;\n}\nassert(0);\n}\n))",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "ForeachType",
				"line": 6057,
				"comment": "Returns the inferred type of the loop variable when a variable of type T\nis iterated over using a $(D foreach) loop with a single loop variable and\nautomatically inferred return type.  Note that this may not be the same as\n$(D std.range.ElementType!Range) in the case of narrow strings, or if T\nhas both opApply and a range interface.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6071_3539)\n---\nstatic assert(is(ForeachType!(uint[]) == uint));\nstatic assert(is(ForeachType!string == immutable(char)));\nstatic assert(is(ForeachType!(string[string]) == string));\nstatic assert(is(ForeachType!(inout(int)[]) == inout(int)));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6071_3539)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "OriginalType",
						"line": 6091,
						"type": "ModifyTypePreservingTQ!(Impl, T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "OriginalType",
				"line": 6083,
				"comment": " Strips off all $(D enum)s from type $(D T).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6095_3540)\n---\nenum E : real { a }\nenum F : E    { a = E.a }\nalias G = const(F);\nstatic assert(is(OriginalType!E == real));\nstatic assert(is(OriginalType!F == real));\nstatic assert(is(OriginalType!G == const real));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6095_3540)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "KeyType",
						"line": 6108,
						"type": "K",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "KeyType",
				"line": 6108,
				"comment": " Get the Key type of an Associative Array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6111_3541)\n---\nimport std.traits;\nalias Hash = int[string];\nstatic assert(is(KeyType!Hash == string));\nstatic assert(is(ValueType!Hash == int));\nKeyType!Hash str = \"a\"; // str is declared as string\nValueType!Hash num = 1; // num is declared as int\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6111_3541)\n",
				"parameters": [
					{
						"name": "V",
						"type": "V[K]",
						"kind": "type"
					},
					{
						"name": "K",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "ValueType",
						"line": 6124,
						"type": "V",
						"char": 1,
						"kind": "alias"
					}
				],
				"name": "ValueType",
				"line": 6124,
				"comment": " Get the Value type of an Associative Array.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6127_3542)\n---\nimport std.traits;\nalias Hash = int[string];\nstatic assert(is(KeyType!Hash == string));\nstatic assert(is(ValueType!Hash == int));\nKeyType!Hash str = \"a\"; // str is declared as string\nValueType!Hash num = 1; // num is declared as int\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6127_3542)\n",
				"parameters": [
					{
						"name": "V",
						"type": "V[K]",
						"kind": "type"
					},
					{
						"name": "K",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Unsigned",
						"line": 6162,
						"type": "ModifyTypePreservingTQ!(Impl, OriginalType!T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Unsigned",
				"line": 6141,
				"comment": " Returns the corresponding unsigned type for T. T must be a numeric\n integral type, otherwise a compile-time error occurs.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "Largest",
				"line": 6199,
				"comment": "Returns the largest type, i.e. T such that T.sizeof is the largest.  If more\nthan one type is of the same size, the leftmost argument of these in will be\nreturned.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6223_3544)\n---\nstatic assert(is(Largest!(uint, ubyte, ushort, real) == real));\nstatic assert(is(Largest!(ulong, double) == ulong));\nstatic assert(is(Largest!(double, ulong) == double));\nstatic assert(is(Largest!(uint, byte, double, short) == double));\nstatic if (is(ucent))\n    static assert(is(Largest!(uint, ubyte, ucent, ushort) == ucent));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6223_3544)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length >= 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Signed",
						"line": 6258,
						"type": "ModifyTypePreservingTQ!(Impl, OriginalType!T)",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Signed",
				"line": 6237,
				"comment": "Returns the corresponding signed type for T. T must be a numeric integral type,\notherwise a compile-time error occurs.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6262_3545)\n---\nalias S1 = Signed!uint;\nstatic assert(is(S1 == int));\nalias S2 = Signed!(const(uint));\nstatic assert(is(S2 == const(int)));\nalias S3 = Signed!(immutable(uint));\nstatic assert(is(S3 == immutable(int)));\nstatic if (is(ucent))\n{\n    alias S4 = Signed!ucent;\n    static assert(is(S4 == cent));\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6262_3545)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "mostNegative",
				"line": 6293,
				"comment": "Returns the most negative value of the numeric type T.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6305_3547)\n---\nstatic assert(mostNegative!float == -float.max);\nstatic assert(mostNegative!double == -double.max);\nstatic assert(mostNegative!real == -real.max);\nstatic assert(mostNegative!bool == false);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6305_3547)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6314_3548)\n---\nforeach(T; TypeTuple!(bool, byte, short, int, long))\n    static assert(mostNegative!T == T.min);\n\nforeach(T; TypeTuple!(ubyte, ushort, uint, ulong, char, wchar, dchar))\n    static assert(mostNegative!T == 0);\n}\n\n\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://\n// Misc.\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://\n\n/**\nReturns the mangled name of symbol or type $(D sth).\n\n$(D mangledName) is the same as builtin $(D .mangleof) property, except that\nthe correct names of property functions are obtained.\n--------------------\nmodule test;\nimport std.traits : mangledName;\n\nclass C\n{\nint value() @property;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6314_3548)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isNumeric!T || isSomeChar!T || isBoolean!T",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [],
				"name": "mangledName",
				"line": 6345,
				"comment": "Returns the mangled name of symbol or type $(D sth).\n\n$(D mangledName) is the same as builtin $(D .mangleof) property, except that\nthe correct names of property functions are obtained.\n--------------------\nmodule test;\nimport std.traits : mangledName;\n\nclass C\n{\n    int value() @property;\n}\npragma(msg, C.value.mangleof);      // prints \"i\"\npragma(msg, mangledName!(C.value)); // prints \"_D4test1C5valueMFNdZi\"\n--------------------\n",
				"parameters": [
					{
						"name": "sth",
						"kind": "tuple"
					}
				],
				"constraint": "sth.length == 1",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "Select",
						"line": 6447,
						"type": "T[!condition]",
						"char": 5,
						"kind": "alias"
					}
				],
				"name": "Select",
				"line": 6445,
				"comment": "Aliases itself to $(D T[0]) if the boolean $(D condition) is $(D true)\nand to $(D T[1]) otherwise.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6451_3551)\n---\n// can select types\nstatic assert(is(Select!(true, int, long) == int));\nstatic assert(is(Select!(false, int, long) == long));\n\n// can select symbols\nint a = 1;\nint b = 2;\nalias selA = Select!(true, a, b);\nalias selB = Select!(false, a, b);\nassert(selA == 1);\nassert(selB == 2);\n}\n\n/**\nIf $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n*/\nA select(bool cond : true, A, B)(A a, lazy B b) { return a; \n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6451_3551)\n",
				"parameters": [
					{
						"name": "condition",
						"deco": "b",
						"kind": "value"
					},
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"constraint": "T.length == 2",
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 61,
						"name": "select",
						"line": 6470,
						"type": "A(A a, lazy B b)",
						"parameters": [
							{
								"name": "a",
								"type": "A"
							},
							{
								"name": "b",
								"type": "B",
								"storageClass": [
									"lazy"
								]
							}
						],
						"endline": 6470,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "select",
				"line": 6470,
				"comment": "If $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n",
				"parameters": [
					{
						"name": "cond",
						"deco": "b",
						"specValue": "true",
						"kind": "value"
					},
					{
						"name": "A",
						"kind": "type"
					},
					{
						"name": "B",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 62,
						"name": "select",
						"line": 6472,
						"type": "B(lazy A a, B b)",
						"parameters": [
							{
								"name": "a",
								"type": "A",
								"storageClass": [
									"lazy"
								]
							},
							{
								"name": "b",
								"type": "B"
							}
						],
						"endline": 6472,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "select",
				"line": 6472,
				"comment": "Ditto\n",
				"parameters": [
					{
						"name": "cond",
						"deco": "b",
						"specValue": "false",
						"kind": "value"
					},
					{
						"name": "A",
						"kind": "type"
					},
					{
						"name": "B",
						"kind": "type"
					}
				],
				"char": 3,
				"kind": "template"
			},
			{
				"members": [],
				"name": "hasUDA",
				"line": 6487,
				"comment": " Determine if a symbol has a given $(LINK2 ../attribute.html#uda, user-defined attribute).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL6509_3553)\n---\nenum E;\nstruct S;\nstruct Named { string name; }\n\n@(\"alpha\") int a;\nstatic assert(hasUDA!(a, \"alpha\"));\nstatic assert(!hasUDA!(a, S));\nstatic assert(!hasUDA!(a, E));\n\n@(E) int b;\nstatic assert(!hasUDA!(b, \"alpha\"));\nstatic assert(!hasUDA!(b, S));\nstatic assert(hasUDA!(b, E));\n\n@E int c;\nstatic assert(!hasUDA!(c, \"alpha\"));\nstatic assert(!hasUDA!(c, S));\nstatic assert(hasUDA!(c, E));\n\n@(S, E) int d;\nstatic assert(!hasUDA!(d, \"alpha\"));\nstatic assert(hasUDA!(d, S));\nstatic assert(hasUDA!(d, E));\n\n@S int e;\nstatic assert(!hasUDA!(e, \"alpha\"));\nstatic assert(hasUDA!(e, S));\nstatic assert(!hasUDA!(e, E));\n\n@(S, E, \"alpha\") int f;\nstatic assert(hasUDA!(f, \"alpha\"));\nstatic assert(hasUDA!(f, S));\nstatic assert(hasUDA!(f, E));\n\n@(100) int g;\nstatic assert(hasUDA!(g, 100));\n\n@Named(\"abc\") int h;\nstatic assert(hasUDA!(h, Named));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL6509_3553)\n",
				"parameters": [
					{
						"name": "symbol",
						"kind": "alias"
					},
					{
						"name": "attribute",
						"kind": "alias"
					}
				],
				"char": 1,
				"kind": "template"
			}
		],
		"comment": " Templates which extract information about types and symbols at compile time.\n\n $(SCRIPT inhibitQuickIndex = 1;)\n\n $(DIVC quickindex,\n $(BOOKTABLE ,\n $(TR $(TH Category) $(TH Templates))\n $(TR $(TD Symbol Name _traits) $(TD\n           $(LREF fullyQualifiedName)\n           $(LREF moduleName)\n           $(LREF packageName)\n ))\n $(TR $(TD Function _traits) $(TD\n           $(LREF arity)\n           $(LREF functionAttributes)\n           $(LREF functionLinkage)\n           $(LREF FunctionTypeOf)\n           $(LREF isSafe)\n           $(LREF isUnsafe)\n           $(LREF ParameterDefaults)\n           $(LREF ParameterIdentifierTuple)\n           $(LREF ParameterStorageClassTuple)\n           $(LREF Parameters)\n           $(LREF ReturnType)\n           $(LREF SetFunctionAttributes)\n           $(LREF variadicFunctionStyle)\n ))\n $(TR $(TD Aggregate Type _traits) $(TD\n           $(LREF BaseClassesTuple)\n           $(LREF BaseTypeTuple)\n           $(LREF classInstanceAlignment)\n           $(LREF EnumMembers)\n           $(LREF FieldNameTuple)\n           $(LREF Fields)\n           $(LREF hasAliasing)\n           $(LREF hasElaborateAssign)\n           $(LREF hasElaborateCopyConstructor)\n           $(LREF hasElaborateDestructor)\n           $(LREF hasIndirections)\n           $(LREF hasMember)\n           $(LREF hasNested)\n           $(LREF hasUnsharedAliasing)\n           $(LREF InterfacesTuple)\n           $(LREF isNested)\n           $(LREF MemberFunctionsTuple)\n           $(LREF RepresentationTypeTuple)\n           $(LREF TemplateArgsOf)\n           $(LREF TemplateOf)\n           $(LREF TransitiveBaseTypeTuple)\n ))\n $(TR $(TD Type Conversion) $(TD\n           $(LREF CommonType)\n           $(LREF ImplicitConversionTargets)\n           $(LREF CopyTypeQualifiers)\n           $(LREF isAssignable)\n           $(LREF isCovariantWith)\n           $(LREF isImplicitlyConvertible)\n ))\n <!--$(TR $(TD SomethingTypeOf) $(TD\n           $(LREF BooleanTypeOf)\n           $(LREF IntegralTypeOf)\n           $(LREF FloatingPointTypeOf)\n           $(LREF NumericTypeOf)\n           $(LREF UnsignedTypeOf)\n           $(LREF SignedTypeOf)\n           $(LREF CharTypeOf)\n           $(LREF StaticArrayTypeOf)\n           $(LREF DynamicArrayTypeOf)\n           $(LREF ArrayTypeOf)\n           $(LREF StringTypeOf)\n           $(LREF AssocArrayTypeOf)\n           $(LREF BuiltinTypeOf)\n ))-->\n $(TR $(TD Categories of types) $(TD\n           $(LREF isAggregateType)\n           $(LREF isArray)\n           $(LREF isAssociativeArray)\n           $(LREF isBasicType)\n           $(LREF isBoolean)\n           $(LREF isBuiltinType)\n           $(LREF isDynamicArray)\n           $(LREF isFloatingPoint)\n           $(LREF isIntegral)\n           $(LREF isNarrowString)\n           $(LREF isAutodecodableString)\n           $(LREF isNumeric)\n           $(LREF isPointer)\n           $(LREF isScalarType)\n           $(LREF isSigned)\n           $(LREF isSomeChar)\n           $(LREF isSomeString)\n           $(LREF isStaticArray)\n           $(LREF isUnsigned)\n ))\n $(TR $(TD Type behaviours) $(TD\n           $(LREF isAbstractClass)\n           $(LREF isAbstractFunction)\n           $(LREF isCallable)\n           $(LREF isDelegate)\n           $(LREF isExpressions)\n           $(LREF isFinalClass)\n           $(LREF isFinalFunction)\n           $(LREF isFunctionPointer)\n           $(LREF isInstanceOf)\n           $(LREF isIterable)\n           $(LREF isMutable)\n           $(LREF isSomeFunction)\n           $(LREF isTypeTuple)\n ))\n $(TR $(TD General Types) $(TD\n           $(LREF ForeachType)\n           $(LREF KeyType)\n           $(LREF Largest)\n           $(LREF mostNegative)\n           $(LREF OriginalType)\n           $(LREF PointerTarget)\n           $(LREF Signed)\n           $(LREF Unqual)\n           $(LREF Unsigned)\n           $(LREF ValueType)\n ))\n $(TR $(TD Misc) $(TD\n           $(LREF mangledName)\n           $(LREF Select)\n           $(LREF select)\n           $(LREF hasUDA)\n ))\n )\n )\n\n Macros:\n  WIKI = Phobos/StdTraits\n\n Copyright: Copyright Digital Mars 2005 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Tomasz Stachowiak ($(D isExpressions)),\n            $(WEB erdani.org, Andrei Alexandrescu),\n            Shin Fujishiro,\n            $(WEB octarineparrot.com, Robert Clipsham),\n            $(WEB klickverbot.at, David Nadlinger),\n            Kenji Hara,\n            Shoichi Kato\n Source:    $(PHOBOSSRC std/_traits.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/syserror.d",
		"name": "std.syserror",
		"members": [],
		"comment": " Convert Win32 error code to string\n\n Source:    $(PHOBOSSRC std/_syserror.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/bitmanip.d",
		"name": "std.bitmanip",
		"members": [
			{
				"members": [
					{
						"name": "bitfields",
						"line": 256,
						"value": "createFields!(createStoreName!T, 0, T).result",
						"char": 12,
						"kind": "enum member"
					}
				],
				"name": "bitfields",
				"line": 254,
				"comment": "Allows creating bit fields inside $(D_PARAM struct)s and $(D_PARAM\nclass)es.\n\nExample:\n\n----\nstruct A\n{\n    int a;\n    mixin(bitfields!(\n        uint, \"x\",    2,\n        int,  \"y\",    3,\n        uint, \"z\",    2,\n        bool, \"flag\", 1));\n}\nA obj;\nobj.x = 2;\nobj.z = obj.x;\n----\n\nThe example above creates a bitfield pack of eight bits, which fit in\none $(D_PARAM ubyte). The bitfields are allocated starting from the\nleast significant bit, i.e. x occupies the two least significant bits\nof the bitfields storage.\n\nThe sum of all bit lengths in one $(D_PARAM bitfield) instantiation\nmust be exactly 8, 16, 32, or 64. If padding is needed, just allocate\none bitfield with an empty name.\n\nExample:\n\n----\nstruct A\n{\n    mixin(bitfields!(\n        bool, \"flag1\",    1,\n        bool, \"flag2\",    1,\n        uint, \"\",         6));\n}\n----\n\nThe type of a bit field can be any integral type or enumerated\ntype. The most efficient type to store in bitfields is $(D_PARAM\nbool), followed by unsigned types, followed by signed types.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "taggedPointer",
						"line": 278,
						"init": "createTaggedReference!(createStoreName!(T, name, 0, Ts), T*, T.alignof, name, Ts).result",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "taggedPointer",
				"line": 277,
				"comment": "This string mixin generator allows one to create tagged pointers inside $(D_PARAM struct)s and $(D_PARAM class)es.\n\nA tagged pointer uses the bits known to be zero in a normal pointer or class reference to store extra information.\nFor example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero.\nOne can store a 2-bit integer there.\n\nThe example above creates a tagged pointer in the struct A. The pointer is of type\n$(D uint*) as specified by the first argument, and is named x, as specified by the second\nargument.\n\nFollowing arguments works the same way as $(D bitfield)'s. The bitfield must fit into the\nbits known to be zero because of the pointer alignment.\n\n$(RED Warning: Don't use $(D taggedPointer) with pointers to garbage collected objects, as it will result in\nundefined behaviour. See $(LINK http://dlang.org/garbage.html) for details.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL282_3554)\n---\nstruct A\n{\n    int a;\n    mixin(taggedPointer!(\n        uint*, \"x\",\n        bool, \"b1\", 1,\n        bool, \"b2\", 1));\n}\nA obj;\nobj.x = new uint;\nobj.b1 = true;\nobj.b2 = false;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL282_3554)\n",
				"parameters": [
					{
						"name": "T",
						"type": "T*",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "Ts",
						"kind": "tuple"
					}
				],
				"char": 1,
				"kind": "template"
			},
			{
				"members": [
					{
						"name": "taggedClassRef",
						"line": 313,
						"init": "createTaggedReference!(createStoreName!(T, name, 0, Ts), T, 8, name, Ts).result",
						"char": 10,
						"kind": "variable",
						"storageClass": [
							"enum"
						]
					}
				],
				"name": "taggedClassRef",
				"line": 312,
				"comment": "This string mixin generator allows one to create tagged class reference inside $(D_PARAM struct)s and $(D_PARAM class)es.\n\nA tagged class reference uses the bits known to be zero in a normal class reference to store extra information.\nFor example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero.\nOne can store a 2-bit integer there.\n\nThe example above creates a tagged reference to an Object in the struct A. This expects the same parameters\nas $(D taggedPointer), except the first argument which must be a class type instead of a pointer type.\n\n$(RED Warning: Don't use $(D taggedClassRef) with references to garbage collected objects, as it will result in\nundefined behaviour. See $(LINK http://dlang.org/garbage.html) for details.)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL317_3555)\n---\nstruct A\n{\n    int a;\n    mixin(taggedClassRef!(\n        Object, \"o\",\n        uint, \"i\", 2));\n}\nA obj;\nobj.o = new Object();\nobj.i = 3;\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL317_3555)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "name",
						"deco": "Aya",
						"kind": "value"
					},
					{
						"name": "Ts",
						"kind": "tuple"
					}
				],
				"constraint": "is(T == class)",
				"char": 1,
				"kind": "template"
			},
			{
				"name": "FloatRep",
				"line": 630,
				"comment": "   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM float) separately. The definition is:\n\n----\nstruct FloatRep\n{\n    union\n    {\n        float value;\n        mixin(bitfields!(\n                  uint,  \"fraction\", 23,\n                  ubyte, \"exponent\",  8,\n                  bool,  \"sign\",      1));\n    }\n    enum uint bias = 127, fractionBits = 23, exponentBits = 8, signBits = 1;\n}\n----\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "DoubleRep",
				"line": 663,
				"comment": "   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM double) separately. The definition is:\n\n----\nstruct DoubleRep\n{\n    union\n    {\n        double value;\n        mixin(bitfields!(\n                  ulong,   \"fraction\", 52,\n                  ushort,  \"exponent\", 11,\n                  bool,    \"sign\",      1));\n    }\n    enum uint bias = 1023, signBits = 1, fractionBits = 52, exponentBits = 11;\n}\n----\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "BitArray",
				"line": 708,
				"comment": " An array of bits.\n",
				"members": [
					{
						"endchar": 5,
						"name": "dim",
						"line": 741,
						"comment": " Gets the amount of native words backing this $(D BitArray).\n",
						"deco": "xFNaNbNdNiZm",
						"endline": 744,
						"originalType": "const pure nothrow @nogc @property size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 749,
						"comment": " Gets the amount of bits in the $(D BitArray).\n",
						"deco": "xFNaNbNdNiZm",
						"endline": 752,
						"originalType": "const pure nothrow @nogc @property size_t()",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "length",
						"line": 760,
						"comment": " Sets the amount of bits in the $(D BitArray).\n $(RED Warning: increasing length may overwrite bits in\n final word up to the next word boundary. i.e. D dynamic\n array extension semantics are not followed.)\n",
						"deco": "FNaNbNdmZm",
						"parameters": [
							{
								"name": "newlen",
								"deco": "m"
							}
						],
						"endline": 778,
						"originalType": "pure nothrow @property size_t(size_t newlen)",
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndex",
						"line": 783,
						"comment": " Gets the $(D i)'th bit in the $(D BitArray).\n",
						"deco": "xFNaNbNimZb",
						"parameters": [
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 791,
						"originalType": "const pure nothrow @nogc bool(size_t i)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opIndexAssign",
						"line": 811,
						"comment": " Sets the $(D i)'th bit in the $(D BitArray).\n",
						"deco": "FNaNbNibmZb",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							},
							{
								"name": "i",
								"deco": "m"
							}
						],
						"endline": 823,
						"originalType": "pure nothrow @nogc bool(bool b, size_t i)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "dup",
						"line": 828,
						"comment": " Duplicates the $(D BitArray) and its contents.\n",
						"deco": "xFNaNbNdZS3std8bitmanip8BitArray",
						"endline": 836,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 859,
						"comment": " Support for $(D foreach) loops for $(D BitArray).\n",
						"deco": "FMDFKbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFKbZi"
							}
						],
						"endline": 872,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 875,
						"comment": " ditto\n",
						"deco": "xFMDFbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFbZi"
							}
						],
						"endline": 887,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 890,
						"comment": " ditto\n",
						"deco": "FMDFmKbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFmKbZi"
							}
						],
						"endline": 903,
						"originalType": "int(scope int delegate(size_t, ref bool) dg)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opApply",
						"line": 906,
						"comment": " ditto\n",
						"deco": "xFMDFmbZiZi",
						"parameters": [
							{
								"name": "dg",
								"storageClass": [
									"scope"
								],
								"deco": "DFmbZi"
							}
						],
						"endline": 918,
						"originalType": "const int(scope int delegate(size_t, bool) dg)",
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "reverse",
						"line": 957,
						"comment": " Reverses the bits of the $(D BitArray).\n",
						"deco": "FNaNbNdNiZS3std8bitmanip8BitArray",
						"endline": 979,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "sort",
						"line": 1001,
						"comment": " Sorts the $(D BitArray)'s elements.\n",
						"deco": "FNaNbNdNiZS3std8bitmanip8BitArray",
						"endline": 1043,
						"char": 24,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opEquals",
						"line": 1062,
						"comment": " Support for operators == and != for $(D BitArray).\n",
						"deco": "xFNaNbNiKxS3std8bitmanip8BitArrayZb",
						"parameters": [
							{
								"name": "a2",
								"storageClass": [
									"ref"
								],
								"deco": "xS3std8bitmanip8BitArray"
							}
						],
						"endline": 1077,
						"originalType": "const pure nothrow @nogc bool(ref const BitArray a2)",
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCmp",
						"line": 1109,
						"comment": " Supports comparison operators for $(D BitArray).\n",
						"deco": "xFNaNbNiS3std8bitmanip8BitArrayZi",
						"parameters": [
							{
								"name": "a2",
								"deco": "S3std8bitmanip8BitArray"
							}
						],
						"endline": 1143,
						"char": 9,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "toHash",
						"line": 1210,
						"comment": " Support for hashing for $(D BitArray).\n",
						"deco": "xFNaNbNiZm",
						"endline": 1225,
						"originalType": "const pure nothrow @nogc size_t()",
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "init",
						"line": 1231,
						"comment": " $(RED Will be deprecated in 2.068. Please use the constructor instead.)\n",
						"deco": "FNaNbAbZv",
						"parameters": [
							{
								"name": "ba",
								"deco": "Ab"
							}
						],
						"endline": 1234,
						"char": 10,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "init",
						"line": 1238,
						"comment": "ditto\n",
						"deco": "FNaNbAvmZv",
						"parameters": [
							{
								"name": "v",
								"deco": "Av"
							},
							{
								"name": "numbits",
								"deco": "m"
							}
						],
						"endline": 1241,
						"originalType": "pure nothrow void(void[] v, size_t numbits)",
						"char": 10,
						"kind": "function",
						"storageClass": [
							"deprecated"
						]
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1246,
						"comment": " Set this $(D BitArray) to the contents of $(D ba).\n",
						"deco": "FNaNbNcAbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "ba",
								"deco": "Ab"
							}
						],
						"endline": 1253,
						"originalType": "pure nothrow ref (bool[] ba)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 1270,
						"comment": " Map the $(D BitArray) onto $(D v), with $(D numbits) being the number of bits\n in the array. Does not copy the data. $(D v.length) must be a multiple of\n $(D size_t.sizeof). If there are unmapped bits in the final mapped word then\n these will be set to 0.\n\n This is the inverse of $(D opCast).\n",
						"deco": "FNaNbNcAvmZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "v",
								"deco": "Av"
							},
							{
								"name": "numbits",
								"deco": "m"
							}
						],
						"endline": 1285,
						"originalType": "pure nothrow ref (void[] v, size_t numbits)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 1314,
								"type": "pure nothrow @nogc void[]()",
								"endline": 1317,
								"char": 12,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 1314,
						"comment": " Convert to $(D void[]).\n",
						"parameters": [
							{
								"name": "T",
								"deco": "Av",
								"kind": "type"
							}
						],
						"char": 12,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opCast",
								"line": 1322,
								"type": "pure nothrow @nogc size_t[]()",
								"endline": 1325,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opCast",
						"line": 1322,
						"comment": " Convert to $(D size_t[]).\n",
						"parameters": [
							{
								"name": "T",
								"deco": "Am",
								"kind": "type"
							}
						],
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCom",
						"line": 1342,
						"comment": " Support for unary operator ~ for $(D BitArray).\n",
						"deco": "xFNaNbZS3std8bitmanip8BitArray",
						"endline": 1357,
						"char": 14,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opBinary",
								"line": 1379,
								"type": "const pure nothrow BitArray(const BitArray e2)",
								"parameters": [
									{
										"name": "e2",
										"type": "BitArray",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 1403,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opBinary",
						"line": 1379,
						"comment": " Support for binary bitwise operators for $(D BitArray).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\" || op == \"&\" || op == \"|\" || op == \"^\"",
						"char": 14,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 1485,
								"type": "pure nothrow @nogc BitArray(const BitArray e2)",
								"parameters": [
									{
										"name": "e2",
										"type": "BitArray",
										"storageClass": [
											"const"
										]
									}
								],
								"endline": 1512,
								"char": 14,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 1485,
						"comment": " Support for operator op= for $(D BitArray).\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"-\" || op == \"&\" || op == \"|\" || op == \"^\"",
						"char": 14,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 1610,
						"comment": " Support for operator ~= for $(D BitArray).\n $(RED Warning: This will overwrite a bit in the final word\n of the current underlying data regardless of whether it is\n shared between BitArray objects. i.e. D dynamic array\n concatenation semantics are not followed)\n",
						"deco": "FNaNbbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 1615,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCatAssign",
						"line": 1641,
						"comment": " ditto\n",
						"deco": "FNaNbS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "S3std8bitmanip8BitArray"
							}
						],
						"endline": 1648,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCat",
						"line": 1675,
						"comment": " Support for binary operator ~ for $(D BitArray).\n",
						"deco": "xFNaNbbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 1683,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCat_r",
						"line": 1686,
						"comment": " ditto\n",
						"deco": "xFNaNbbZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "b"
							}
						],
						"endline": 1695,
						"char": 14,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "opCat",
						"line": 1698,
						"comment": " ditto\n",
						"deco": "xFNaNbS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
						"parameters": [
							{
								"name": "b",
								"deco": "S3std8bitmanip8BitArray"
							}
						],
						"endline": 1705,
						"char": 14,
						"kind": "function"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 1818,
								"type": "pure nothrow @nogc void(size_t nbits)",
								"parameters": [
									{
										"name": "nbits",
										"type": "size_t"
									}
								],
								"endline": 1839,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 1818,
						"comment": " Operator $(D <<=) support.\n\n Shifts all the bits in the array to the left by the given number of\n bits.  The leftmost bits are dropped, and 0's are appended to the end\n to fill up the vacant bits.\n\n $(RED Warning: unused bits in the final word up to the next word\n boundary may be overwritten by this operation. It does not attempt to\n preserve bits past the end of the array.)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \"<<\"",
						"char": 10,
						"kind": "template"
					},
					{
						"members": [
							{
								"endchar": 5,
								"name": "opOpAssign",
								"line": 1852,
								"type": "pure nothrow @nogc void(size_t nbits)",
								"parameters": [
									{
										"name": "nbits",
										"type": "size_t"
									}
								],
								"endline": 1880,
								"char": 10,
								"kind": "function"
							}
						],
						"name": "opOpAssign",
						"line": 1852,
						"comment": " Operator $(D >>=) support.\n\n Shifts all the bits in the array to the right by the given number of\n bits.  The rightmost bits are dropped, and 0's are inserted at the back\n to fill up the vacant bits.\n\n $(RED Warning: unused bits in the final word up to the next word\n boundary may be overwritten by this operation. It does not attempt to\n preserve bits past the end of the array.)\n",
						"parameters": [
							{
								"name": "op",
								"deco": "Aya",
								"kind": "value"
							}
						],
						"constraint": "op == \">>\"",
						"char": 10,
						"kind": "template"
					},
					{
						"endchar": 5,
						"name": "toString",
						"line": 1973,
						"comment": " Return a string representation of this BitArray.\n\n Two format specifiers are supported:\n $(LI $(B %s) which prints the bits as an array, and)\n $(LI $(B %b) which prints the bits as 8-bit byte packets)\n separated with an underscore.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL1988_3591)\n---\nimport std.format : format;\n\ndebug(bitarray) printf(\"BitArray.toString unittest\\n\");\nauto b = BitArray([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);\n\nauto s1 = format(\"%s\", b);\nassert(s1 == \"[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]\");\n\nauto s2 = format(\"%b\", b);\nassert(s2 == \"00001111_00001111\");\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL1988_3591)\n",
						"deco": "xFMDFAxaZvS3std6format18__T10FormatSpecTaZ10FormatSpecZv",
						"parameters": [
							{
								"name": "sink",
								"storageClass": [
									"scope"
								],
								"deco": "DFAxaZv"
							},
							{
								"name": "fmt",
								"deco": "S3std6format18__T10FormatSpecTaZ10FormatSpec"
							}
						],
						"endline": 1985,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "bitsSet",
						"line": 2005,
						"comment": " Return a lazy range of the indices of set bits.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2017_3594)\n---\nimport std.algorithm : equal;\n\nauto b1 = BitArray([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);\nassert(b1.bitsSet.equal([4, 5, 6, 7, 12, 13, 14, 15]));\n\nBitArray b2;\nb2.length = 1000;\nb2[333] = true;\nb2[666] = true;\nb2[999] = true;\nassert(b2.bitsSet.equal([333, 666, 999]));\n\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2017_3594)\n",
						"deco": "xFNaNbNdZS3std9algorithm9iteration270__T6joinerTS3std9algorithm9iteration220__T9MapResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda2TS3std9algorithm9iteration112__T12FilterResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda1TS3std5range13__T4iotaTmTmZ4iotaFmmZ6ResultZ12FilterResultZ9MapResultZ6joinerFS3std9algorithm9iteration220__T9MapResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda2TS3std9algorithm9iteration112__T12FilterResultS483std8bitmanip8BitArray7bitsSetMxFNbNdZ9__lambda1TS3std5range13__T4iotaTmTmZ4iotaFmmZ6ResultZ12FilterResultZ9MapResultZ6Result",
						"endline": 2014,
						"originalType": "const nothrow @property ()",
						"char": 20,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "swapEndian",
						"line": 2131,
						"type": "pure nothrow @nogc @safe T(T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 2146,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "swapEndian",
				"line": 2131,
				"comment": "    Swaps the endianness of the given integral value or character.\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T || isSomeChar!T || isBoolean!T",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nativeToBigEndian",
						"line": 2243,
						"type": "pure nothrow @nogc @safe (T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 2247,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "nativeToBigEndian",
				"line": 2243,
				"comment": "    Converts the given value from the native endianness to big endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2250_3598)\n---\nint i = 12345;\nubyte[4] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToBigEndian(d);\nassert(d == bigEndianToNative!double(swappedD));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2250_3598)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bigEndianToNative",
						"line": 2365,
						"type": "pure nothrow @nogc @safe T(ubyte[n] val)",
						"parameters": [
							{
								"name": "val",
								"type": "ubyte[n]"
							}
						],
						"endline": 2369,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "bigEndianToNative",
				"line": 2365,
				"comment": "    Converts the given value from big endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2372_3600)\n---\nushort i = 12345;\nubyte[2] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToBigEndian(c);\nassert(c == bigEndianToNative!dchar(swappedC));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2372_3600)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "n",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "canSwapEndianness!T && n == T.sizeof",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "nativeToLittleEndian",
						"line": 2417,
						"type": "pure nothrow @nogc @safe (T val)",
						"parameters": [
							{
								"name": "val",
								"type": "T"
							}
						],
						"endline": 2421,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "nativeToLittleEndian",
				"line": 2417,
				"comment": "    Converts the given value from the native endianness to little endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2424_3601)\n---\nint i = 12345;\nubyte[4] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToLittleEndian(d);\nassert(d == littleEndianToNative!double(swappedD));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2424_3601)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "littleEndianToNative",
						"line": 2512,
						"type": "pure nothrow @nogc @safe T(ubyte[n] val)",
						"parameters": [
							{
								"name": "val",
								"type": "ubyte[n]"
							}
						],
						"endline": 2516,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "littleEndianToNative",
				"line": 2512,
				"comment": "    Converts the given value from little endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2519_3603)\n---\nushort i = 12345;\nubyte[2] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToLittleEndian(c);\nassert(c == littleEndianToNative!dchar(swappedC));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2519_3603)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "n",
						"deco": "m",
						"kind": "value"
					}
				],
				"constraint": "canSwapEndianness!T && n == T.sizeof",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "peek",
						"line": 2657,
						"type": "T(R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							}
						],
						"endline": 2681,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "peek",
				"line": 2657,
				"comment": "    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The range is not consumed.\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n        index = The index to start reading from (instead of starting at the\n                front). If index is a pointer, then it is updated to the index\n                after the bytes read. The overloads with index are only\n                available if $(D hasSlicing!R) is $(D true).\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2714_3606)\n---\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.peek!uint() == 17110537);\nassert(buffer.peek!ushort() == 261);\nassert(buffer.peek!ubyte() == 1);\n\nassert(buffer.peek!uint(2) == 369700095);\nassert(buffer.peek!ushort(2) == 5641);\nassert(buffer.peek!ubyte(2) == 22);\n\nsize_t index = 0;\nassert(buffer.peek!ushort(&index) == 261);\nassert(index == 2);\n\nassert(buffer.peek!uint(&index) == 369700095);\nassert(index == 6);\n\nassert(buffer.peek!ubyte(&index) == 8);\nassert(index == 7);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2714_3606)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "peek",
						"line": 2684,
						"type": "T(R range, size_t index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 2691,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "peek",
				"line": 2684,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "peek",
						"line": 2694,
						"type": "T(R range, size_t* index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "index",
								"type": "size_t*"
							}
						],
						"endline": 2711,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "peek",
				"line": 2694,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "read",
						"line": 2959,
						"type": "T(ref R range)",
						"parameters": [
							{
								"name": "range",
								"type": "R",
								"storageClass": [
									"ref"
								]
							}
						],
						"endline": 2982,
						"char": 3,
						"kind": "function"
					}
				],
				"name": "read",
				"line": 2959,
				"comment": "    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The $(D T.sizeof) bytes which are read are consumed from\n    the range.\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL2985_3609)\n---\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.length == 7);\n\nassert(buffer.read!ushort() == 261);\nassert(buffer.length == 5);\n\nassert(buffer.read!uint() == 369700095);\nassert(buffer.length == 1);\n\nassert(buffer.read!ubyte() == 8);\nassert(buffer.empty);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL2985_3609)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isInputRange!R && is(ElementType!R : const(ubyte))",
				"char": 3,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "write",
						"line": 3204,
						"type": "void(R range, T value, size_t index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "index",
								"type": "size_t"
							}
						],
						"endline": 3211,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "write",
				"line": 3204,
				"comment": "    Takes an integral value, converts it to the given endianness, and writes it\n    to the given range of $(D ubyte)s as a sequence of $(D T.sizeof) $(D ubyte)s\n    starting at index. $(D hasSlicing!R) must be $(D true).\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to _write the bytes in.\n        range = The range to _write to.\n        value = The value to _write.\n        index = The index to start writing to. If index is a pointer, then it\n                is updated to the index after the bytes read.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3234_3612)\n---\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(29110231u, 0);\n    assert(buffer == [1, 188, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ushort(927, 0);\n    assert(buffer == [3, 159, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ubyte(42, 0);\n    assert(buffer == [42, 159, 47, 215, 0, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(142700095u, 2);\n    assert(buffer == [0, 0, 8, 129, 110, 63, 0, 0, 0]);\n\n    buffer.write!ushort(19839, 2);\n    assert(buffer == [0, 0, 77, 127, 110, 63, 0, 0, 0]);\n\n    buffer.write!ubyte(132, 2);\n    assert(buffer == [0, 0, 132, 127, 110, 63, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    size_t index = 0;\n    buffer.write!ushort(261, &index);\n    assert(buffer == [1, 5, 0, 0, 0, 0, 0, 0]);\n    assert(index == 2);\n\n    buffer.write!uint(369700095u, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 0, 0]);\n    assert(index == 6);\n\n    buffer.write!ubyte(8, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 8, 0]);\n    assert(index == 7);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3234_3612)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : ubyte)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "write",
						"line": 3214,
						"type": "void(R range, T value, size_t* index)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "value",
								"type": "T"
							},
							{
								"name": "index",
								"type": "size_t*"
							}
						],
						"endline": 3231,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "write",
				"line": 3214,
				"comment": " Ditto\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isForwardRange!R && hasSlicing!R && is(ElementType!R : ubyte)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "append",
						"line": 3548,
						"type": "void(R range, T value)",
						"parameters": [
							{
								"name": "range",
								"type": "R"
							},
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 3557,
						"char": 6,
						"kind": "function"
					}
				],
				"name": "append",
				"line": 3548,
				"comment": "    Takes an integral value, converts it to the given endianness, and appends\n    it to the given range of $(D ubyte)s (using $(D put)) as a sequence of\n    $(D T.sizeof) $(D ubyte)s starting at index. $(D hasSlicing!R) must be\n    $(D true).\n\n    Params:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to _append to.\n        value = The value to _append.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3560_3614)\n---\nimport std.array;\nauto buffer = appender!(const ubyte[])();\nbuffer.append!ushort(261);\nassert(buffer.data == [1, 5]);\n\nbuffer.append!uint(369700095u);\nassert(buffer.data == [1, 5, 22, 9, 44, 255]);\n\nbuffer.append!ubyte(8);\nassert(buffer.data == [1, 5, 22, 9, 44, 255, 8]);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3560_3614)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3774_3617)\n---\nassert(countTrailingZeros(1) == 0);\nassert(countTrailingZeros(0) == 32);\nassert(countTrailingZeros(int.min) == 31);\nassert(countTrailingZeros(256) == 8);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3774_3617)\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3855_3619)\n---\nassert(countBitsSet(1) == 1);\nassert(countBitsSet(0) == 0);\nassert(countBitsSet(int.min) == 1);\nassert(countBitsSet(uint.max) == 32);\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3855_3619)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					},
					{
						"name": "endianness",
						"defaultValue": "Endian.bigEndian",
						"deco": "E3std6system6Endian",
						"kind": "value"
					},
					{
						"name": "R",
						"kind": "type"
					}
				],
				"constraint": "canSwapEndianness!T && isOutputRange!(R, ubyte)",
				"char": 6,
				"kind": "template"
			},
			{
				"members": [
					{
						"endchar": 1,
						"name": "bitsSet",
						"line": 3943,
						"type": "pure nothrow @nogc (T value)",
						"parameters": [
							{
								"name": "value",
								"type": "T"
							}
						],
						"endline": 3947,
						"char": 6,
						"kind": "function",
						"storageClass": [
							"auto"
						]
					}
				],
				"name": "bitsSet",
				"line": 3943,
				"comment": "Range that iterates the indices of the set bits in $(D value).\nIndex 0 corresponds to the least significant bit.\nFor signed integers, the highest index corresponds to the sign bit.\nExample:\n$(DDOX_UNITTEST_HEADER __unittestL3950_3621)\n---\nimport std.algorithm : equal;\nimport std.range : iota;\n\nassert(bitsSet(1).equal([0]));\nassert(bitsSet(5).equal([0, 2]));\nassert(bitsSet(-1).equal(iota(32)));\nassert(bitsSet(int.min).equal([31]));\n\n---\n$(DDOX_UNITTEST_FOOTER __unittestL3950_3621)\n",
				"parameters": [
					{
						"name": "T",
						"kind": "type"
					}
				],
				"constraint": "isIntegral!T",
				"char": 6,
				"kind": "template"
			}
		],
		"comment": "Bit-level manipulation facilities.\n\nMacros:\n\nWIKI = StdBitarray\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nLicense:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis,\n           Alex RÃ¸nne Petersen,\n           Damian Ziemba\n           Amaury SECHET\nSource: $(PHOBOSSRC std/_bitmanip.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/std/zip.d",
		"name": "std.zip",
		"members": [
			{
				"members": [],
				"name": "ZipException",
				"line": 81,
				"comment": " Thrown on error.\n",
				"base": "object.Exception",
				"char": 1,
				"kind": "class"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 94,
						"value": "cast(ushort)0u",
						"comment": "No compression, just archiving\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "deflate",
						"line": 95,
						"value": "cast(ushort)8u",
						"comment": "Deflate algorithm. Use zlib library to compress\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CompressionMethod",
				"line": 92,
				"comment": " Compression method used by ArchiveMember\n",
				"baseDeco": "t",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "ArchiveMember",
				"line": 101,
				"comment": " A member of the ZipArchive.\n",
				"members": [
					{
						"offset": 16,
						"name": "name",
						"line": 111,
						"comment": " Read/Write: Usually the file name of the archive member; it is used to\n index the archive directory for the member. Each member must have a unique\n name[]. Do not change without removing member from the directory first.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "extra",
						"line": 113,
						"comment": "Read/Write: extra data for this member.\n",
						"deco": "Ah",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "comment",
						"line": 114,
						"comment": "Read/Write: comment associated with this member.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 128,
						"name": "flags",
						"line": 129,
						"comment": "Read/Write: normally set to 0\n",
						"deco": "t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 130,
						"name": "internalAttributes",
						"line": 130,
						"comment": "Read/Write\n",
						"deco": "t",
						"char": 12,
						"kind": "variable"
					},
					{
						"endchar": 69,
						"name": "extractVersion",
						"line": 132,
						"comment": "Read Only\n",
						"deco": "FNdZt",
						"endline": 132,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 53,
						"name": "crc32",
						"line": 133,
						"comment": "Read Only: cyclic redundancy check (CRC) value\n",
						"deco": "FNdZk",
						"endline": 133,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 67,
						"name": "compressedSize",
						"line": 146,
						"comment": "Read Only: size of data of member in compressed form.\n",
						"deco": "FNdZk",
						"endline": 146,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 63,
						"name": "expandedSize",
						"line": 149,
						"comment": "Read Only: size of data of member in expanded form.\n",
						"deco": "FNdZk",
						"endline": 149,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 61,
						"name": "diskNumber",
						"line": 150,
						"comment": "Read Only: should be 0.\n",
						"deco": "FNdZt",
						"endline": 150,
						"char": 22,
						"kind": "function"
					},
					{
						"endchar": 70,
						"name": "compressedData",
						"line": 153,
						"comment": "Read Only: data of member in compressed form.\n",
						"deco": "FNdZAh",
						"endline": 153,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 66,
						"name": "expandedData",
						"line": 156,
						"comment": "Read data of member in uncompressed form.\n",
						"deco": "FNdZAh",
						"endline": 156,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "expandedData",
						"line": 159,
						"comment": "Write data of member in uncompressed form.\n",
						"deco": "FNdAhZv",
						"parameters": [
							{
								"name": "ed",
								"deco": "Ah"
							}
						],
						"endline": 167,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fileAttributes",
						"line": 173,
						"comment": " Set the OS specific file attributes, as obtained by\n $(XREF file,getAttributes) or $(XREF file,DirEntry.attributes), for this archive member.\n",
						"deco": "FNdkZv",
						"parameters": [
							{
								"name": "attr",
								"deco": "k"
							}
						],
						"endline": 190,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "fileAttributes",
						"line": 207,
						"comment": " Get the OS specific file attributes for the archive member.\n\n Returns: The file attributes or 0 if the file attributes were\n encoded for an incompatible OS (Windows vs. Posix).\n\n",
						"deco": "xFNdZk",
						"endline": 225,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "time",
						"line": 228,
						"comment": "Set the last modification time for this member.\n",
						"deco": "FNdS3std8datetime7SysTimeZv",
						"parameters": [
							{
								"name": "time",
								"deco": "S3std8datetime7SysTime"
							}
						],
						"endline": 231,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "time",
						"line": 234,
						"comment": "ditto\n",
						"deco": "FNdkZv",
						"parameters": [
							{
								"name": "time",
								"deco": "k"
							}
						],
						"endline": 237,
						"originalType": "@property void(DosFileTime time)",
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "time",
						"line": 240,
						"comment": "Get the last modification time for this member.\n",
						"deco": "xFNdZk",
						"endline": 243,
						"originalType": "const @property DosFileTime()",
						"char": 27,
						"kind": "function"
					},
					{
						"endchar": 82,
						"name": "compressionMethod",
						"line": 250,
						"comment": " Read compression method used for this member\n See_Also:\n     CompressionMethod\n",
						"deco": "FNdZE3std3zip17CompressionMethod",
						"endline": 250,
						"char": 33,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "compressionMethod",
						"line": 264,
						"comment": " Write compression method used for this member\n See_Also:\n     CompressionMethod\n",
						"deco": "FNdE3std3zip17CompressionMethodZv",
						"parameters": [
							{
								"name": "cm",
								"deco": "E3std3zip17CompressionMethod"
							}
						],
						"endline": 272,
						"char": 20,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			},
			{
				"name": "ZipArchive",
				"line": 298,
				"comment": " Object representing the entire archive.\n ZipArchives are collections of ArchiveMembers.\n",
				"members": [
					{
						"offset": 16,
						"name": "comment",
						"line": 306,
						"comment": "Read/Write: the archive comment. Must be less than 65536 bytes in length.\n",
						"deco": "Aya",
						"char": 12,
						"kind": "variable"
					},
					{
						"endchar": 52,
						"name": "data",
						"line": 322,
						"comment": "Read Only: array representing the entire contents of the archive.\n",
						"deco": "FNdZAh",
						"endline": 322,
						"char": 23,
						"kind": "function"
					},
					{
						"endchar": 58,
						"name": "diskNumber",
						"line": 325,
						"comment": "Read Only: 0 since multi-disk zip archives are not supported.\n",
						"deco": "FNdZk",
						"endline": 325,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 60,
						"name": "diskStartDir",
						"line": 328,
						"comment": "Read Only: 0 since multi-disk zip archives are not supported\n",
						"deco": "FNdZk",
						"endline": 328,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 58,
						"name": "numEntries",
						"line": 331,
						"comment": "Read Only: number of ArchiveMembers in the directory.\n",
						"deco": "FNdZk",
						"endline": 331,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 60,
						"name": "totalEntries",
						"line": 332,
						"comment": "ditto\n",
						"deco": "FNdZk",
						"endline": 332,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 50,
						"name": "isZip64",
						"line": 335,
						"comment": "True when the archive is in Zip64 format.\n",
						"deco": "FNdZb",
						"endline": 335,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 60,
						"name": "isZip64",
						"line": 338,
						"comment": "Set this to true to force building a Zip64 archive.\n",
						"deco": "FNdbZv",
						"parameters": [
							{
								"name": "value",
								"deco": "b"
							}
						],
						"endline": 338,
						"char": 20,
						"kind": "function"
					},
					{
						"endchar": 70,
						"name": "directory",
						"line": 351,
						"comment": " Read Only: array indexed by the name of each member of the archive.\n  All the members of the archive can be accessed with a foreach loop:\n Example:\n --------------------\n ZipArchive archive = new ZipArchive(data);\n foreach (ArchiveMember am; archive.directory)\n {\n     writefln(\"member name is '%s'\", am.name);\n }\n --------------------\n",
						"deco": "FNdZHAyaC3std3zip13ArchiveMember",
						"endline": 351,
						"char": 37,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 371,
						"comment": " Constructor to use when creating a new archive.\n",
						"deco": "FZC3std3zip10ZipArchive",
						"endline": 373,
						"originalType": "()",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "addMember",
						"line": 377,
						"comment": " Add de to the archive.\n",
						"deco": "FC3std3zip13ArchiveMemberZv",
						"parameters": [
							{
								"name": "de",
								"deco": "C3std3zip13ArchiveMember"
							}
						],
						"endline": 380,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "deleteMember",
						"line": 384,
						"comment": " Delete de from the archive.\n",
						"deco": "FC3std3zip13ArchiveMemberZv",
						"parameters": [
							{
								"name": "de",
								"deco": "C3std3zip13ArchiveMember"
							}
						],
						"endline": 387,
						"char": 10,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "build",
						"line": 399,
						"comment": " Construct an archive out of the current members of the archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, and directory[].\n For each ArchiveMember, fills in properties crc32, compressedSize,\n compressedData[].\n\n Returns: array representing the entire archive.\n",
						"deco": "FZAv",
						"endline": 555,
						"char": 12,
						"kind": "function"
					},
					{
						"endchar": 5,
						"name": "this",
						"line": 574,
						"comment": " Constructor to use when reading an existing archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, comment[], and directory[].\n For each ArchiveMember, fills in\n properties madeVersion, extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, compressedData[], diskNumber,\n internalAttributes, externalAttributes, name[], extra[], comment[].\n Use expand() to get the expanded data for each ArchiveMember.\n\n Params:\n  buffer = the entire contents of the archive.\n",
						"deco": "FAvZC3std3zip10ZipArchive",
						"parameters": [
							{
								"name": "buffer",
								"deco": "Av"
							}
						],
						"endline": 727,
						"originalType": "(void[] buffer)",
						"char": 5,
						"kind": "constructor"
					},
					{
						"endchar": 5,
						"name": "expand",
						"line": 736,
						"comment": " Decompress the contents of archive member de and return the expanded\n data.\n\n Fills in properties extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, expandedData[], name[], extra[].\n",
						"deco": "FC3std3zip13ArchiveMemberZAh",
						"parameters": [
							{
								"name": "de",
								"deco": "C3std3zip13ArchiveMember"
							}
						],
						"endline": 789,
						"char": 13,
						"kind": "function"
					}
				],
				"char": 7,
				"kind": "class"
			}
		],
		"comment": " Read/write data in the $(LINK2 http://www.info-_zip.org, zip archive) format.\n Makes use of the etc.c.zlib compression library.\n\n Bugs:\n      $(UL\n      $(LI Multi-disk zips not supported.)\n      $(LI Only Zip version 20 formats are supported.)\n      $(LI Only supports compression modes 0 (no compression) and 8 (deflate).)\n      $(LI Does not support encryption.)\n      $(LI $(BUGZILLA 592))\n      $(LI $(BUGZILLA 2137))\n      )\n\n Macros:\n      WIKI = Phobos/StdZip\n\n Examples:\n ---\n// Read existing zip file.\nimport std.digest.crc, std.file, std.stdio, std.zip;\n\nvoid main(string[] args)\n{\n    // read a zip file into memory\n    auto zip = new ZipArchive(read(args[1]));\n    writeln(\"Archive: \", args[1]);\n    writefln(\"%-10s  %-8s  Name\", \"Length\", \"CRC-32\");\n    // iterate over all zip members\n    foreach (name, am; zip.directory)\n    {\n        // print some data about each member\n        writefln(\"%10s  %08x  %s\", am.expandedSize, am.crc32, name);\n        assert(am.expandedData.length == 0);\n        // decompress the archive member\n        zip.expand(am);\n        assert(am.expandedData.length == am.expandedSize);\n    }\n}\n\n// Create and write new zip file.\nimport std.file: write;\nimport std.string: representation;\n\nvoid main()\n{\n    char[] data = \"Test data.\\n\".dup;\n    // Create an ArchiveMember for the test file.\n    ArchiveMember am = new ArchiveMember();\n    am.name = \"test.txt\";\n    am.expandedData(data.representation);\n    // Create an archive and add the member.\n    ZipArchive zip = new ZipArchive();\n    zip.addMember(am);\n    // Build the archive\n    void[] compressed_data = zip.build();\n    // Write to a file\n    write(\"test.zip\", compressed_data);\n}\n ---\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_zip.d)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/curl.d",
		"name": "etc.c.curl",
		"members": [
			{
				"name": "LIBCURL_COPYRIGHT",
				"line": 52,
				"comment": " This is the global package copyright\n",
				"deco": "Aya",
				"init": "\"1996 - 2010 Daniel Stenberg, <daniel@haxx.se>.\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION",
				"line": 56,
				"comment": " This is the version number of the libcurl package from which this header\n   file origins:\n",
				"deco": "Aya",
				"init": "\"7.21.4\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_MAJOR",
				"line": 60,
				"comment": " The numeric version number is also available \"in parts\" by using these\n   constants\n",
				"deco": "i",
				"init": "7",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_MINOR",
				"line": 62,
				"comment": "ditto\n",
				"deco": "i",
				"init": "21",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_PATCH",
				"line": 64,
				"comment": "ditto\n",
				"deco": "i",
				"init": "4",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_VERSION_NUM",
				"line": 82,
				"comment": " This is the numeric version of the libcurl version number, meant for easier\n   parsing and comparions by programs. The LIBCURL_VERSION_NUM define will\n   always follow this syntax:\n\n         0xXXYYZZ\n\n   Where XX, YY and ZZ are the main version, release and patch numbers in\n   hexadecimal (using 8 bits each). All three numbers are always represented\n   using two digits.  1.2 would appear as \"0x010200\" while version 9.11.7\n   appears as \"0x090b07\".\n\n   This 6-digit (24 bits) hexadecimal number does not show pre-release number,\n   and it is always a greater number in a more recent release. It makes\n   comparisons with greater than and less than work.\n",
				"deco": "i",
				"init": "464132",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LIBCURL_TIMESTAMP",
				"line": 93,
				"comment": " This is the date and time when the full source package was created. The\n timestamp is not stored in git, as the timestamp is properly set in the\n tarballs by the maketgz script.\n\n The format of the date should follow this template:\n\n \"Mon Feb 12 11:35:33 UTC 2007\"\n",
				"deco": "Aya",
				"init": "\"Thu Feb 17 12:19:40 UTC 2011\"",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "curl_off_t",
				"line": 109,
				"comment": " Data type definition of curl_off_t.\n\njdrewsen - Always 64bit signed and that is what long is in D.\n\nComment below is from curlbuild.h:\n\n NOTE 2:\n\n For any given platform/compiler curl_off_t must be typedef'ed to a\n 64-bit wide signed integral data type. The width of this data type\n must remain constant and independent of any possible large file\n support settings.\n\n As an exception to the above, curl_off_t shall be typedef'ed to a\n 32-bit wide signed integral data type if there is no 64-bit type.\n",
				"deco": "l",
				"char": 12,
				"kind": "alias"
			},
			{
				"name": "CURL",
				"line": 112,
				"comment": "\n",
				"deco": "v",
				"char": 12,
				"kind": "alias"
			},
			{
				"name": "curl_socket_t",
				"line": 115,
				"comment": "jdrewsen - Get socket alias from std.socket\n",
				"deco": "E3std6socket8socket_t",
				"char": 16,
				"kind": "alias"
			},
			{
				"name": "curl_httppost",
				"line": 125,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "next",
						"line": 127,
						"comment": " next entry in the list\n",
						"deco": "PS3etc1c4curl13curl_httppost",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "name",
						"line": 128,
						"comment": " pointer to allocated name\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "namelength",
						"line": 129,
						"comment": " length of name length\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "contents",
						"line": 130,
						"comment": " pointer to allocated data contents\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "contentslength",
						"line": 131,
						"comment": " length of contents field\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "buffer",
						"line": 132,
						"comment": " pointer to allocated buffer contents\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "bufferlength",
						"line": 133,
						"comment": " length of buffer field\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "contenttype",
						"line": 134,
						"comment": " Content-Type\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "contentheader",
						"line": 135,
						"comment": " list of extra headers for this form\n",
						"deco": "PS3etc1c4curl10curl_slist",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 72,
						"name": "more",
						"line": 136,
						"comment": " if one field name has more than one\n                                    file, this link should link to following\n                                    files\n",
						"deco": "PS3etc1c4curl13curl_httppost",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 80,
						"name": "flags",
						"line": 139,
						"comment": " as defined below\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 88,
						"name": "showfilename",
						"line": 140,
						"comment": " The file name to show. If not set, the\n                                    actual file name will be used (if this\n                                    is a file part)\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "userp",
						"line": 143,
						"comment": " custom pointer used for\n                                    HTTPPOST_CALLBACK posts\n",
						"deco": "Pv",
						"char": 11,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "HTTPPOST_FILENAME",
				"line": 147,
				"comment": " specified content is a file name\n",
				"deco": "i",
				"init": "1",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_READFILE",
				"line": 148,
				"comment": " specified content is a file name\n",
				"deco": "i",
				"init": "2",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_PTRNAME",
				"line": 149,
				"comment": " name is only stored pointer\n                                    do not free in formfree\n",
				"deco": "i",
				"init": "4",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_PTRCONTENTS",
				"line": 151,
				"comment": " contents is only stored pointer\n                                    do not free in formfree\n",
				"deco": "i",
				"init": "8",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_BUFFER",
				"line": 153,
				"comment": " upload file from buffer\n",
				"deco": "i",
				"init": "16",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_PTRBUFFER",
				"line": 154,
				"comment": " upload file from pointer contents\n",
				"deco": "i",
				"init": "32",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "HTTPPOST_CALLBACK",
				"line": 155,
				"comment": " upload file contents by using the\n                                    regular read callback to get the data\n                                    and pass the given pointer as custom\n                                    pointer\n",
				"deco": "i",
				"init": "64",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "curl_progress_callback",
				"line": 161,
				"comment": "\n",
				"deco": "PFPvddddZi",
				"char": 95,
				"kind": "alias"
			},
			{
				"name": "CURL_MAX_WRITE_SIZE",
				"line": 169,
				"comment": " Tests have proven that 20K is a very bad buffer size for uploads on\n   Windows, while 16K for some odd reason performed a lot better.\n   We do the ifndef check to allow this value to easier be changed at build\n   time for those who feel adventurous. The practical minimum is about\n   400 bytes since libcurl uses a buffer of this size as a scratch area\n   (unrelated to network send operations).\n",
				"deco": "i",
				"init": "16384",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURL_MAX_HTTP_HEADER",
				"line": 174,
				"comment": " The only reason to have a max limit for this is to avoid the risk of a bad\n   server feeding libcurl with a never-ending header that will cause reallocs\n   infinitely\n",
				"deco": "i",
				"init": "102400",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURL_WRITEFUNC_PAUSE",
				"line": 179,
				"comment": " This is a magic return code for the write callback that, when returned,\n   will signal libcurl to pause receiving on the current transfer.\n",
				"deco": "i",
				"init": "268435457",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "curl_write_callback",
				"line": 182,
				"comment": "\n",
				"deco": "PFPammPvZm",
				"char": 82,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "file",
						"line": 186,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "directory",
						"line": 187,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "symlink",
						"line": 188,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "device_block",
						"line": 189,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "device_char",
						"line": 190,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "namedpipe",
						"line": 191,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socket",
						"line": 192,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "door",
						"line": 193,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown",
						"line": 194,
						"value": "8",
						"comment": " is possible only on Sun Solaris now\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFileType",
				"line": 185,
				"comment": " enumeration of file types\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curlfiletype",
				"line": 198,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "filename",
						"line": 202,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "filetype",
						"line": 203,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "time",
						"line": 204,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "perm",
						"line": 205,
						"value": "8",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "uid",
						"line": 206,
						"value": "16",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gid",
						"line": 207,
						"value": "32",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "size",
						"line": 208,
						"value": "64",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "hlinkcount",
						"line": 209,
						"value": "128",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlFInfoFlagKnown",
				"line": 201,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "_N2",
				"line": 219,
				"comment": " Content of this structure depends on information which is known and is\n   achievable (e.g. by FTP LIST parsing). Please see the url_easy_setopt(3) man\n   page for callbacks returning this structure -- some fields are mandatory,\n   some others are optional. The FLAG field has special meaning.\n\n If some of these fields is not NULL, it is a pointer to b_data.\n",
				"members": [
					{
						"offset": 0,
						"name": "time",
						"line": 221,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "perm",
						"line": 222,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "user",
						"line": 223,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "group",
						"line": 224,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "target",
						"line": 225,
						"comment": " pointer to the target filename of a symlink\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_fileinfo",
				"line": 232,
				"comment": " Content of this structure depends on information which is known and is\n   achievable (e.g. by FTP LIST parsing). Please see the url_easy_setopt(3) man\n   page for callbacks returning this structure -- some fields are mandatory,\n   some others are optional. The FLAG field has special meaning.\n",
				"members": [
					{
						"offset": 0,
						"name": "filename",
						"line": 234,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "filetype",
						"line": 235,
						"comment": "\n",
						"deco": "i",
						"originalType": "curlfiletype",
						"char": 18,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "time",
						"line": 236,
						"comment": "\n",
						"deco": "l",
						"originalType": "time_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "perm",
						"line": 237,
						"comment": "\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 28,
						"name": "uid",
						"line": 238,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "gid",
						"line": 239,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "size",
						"line": 240,
						"comment": "\n",
						"deco": "l",
						"originalType": "curl_off_t",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "hardlinks",
						"line": 241,
						"comment": "\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "strings",
						"line": 242,
						"comment": "\n",
						"deco": "S3etc1c4curl3_N2",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "flags",
						"line": 243,
						"comment": "\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 104,
						"name": "b_data",
						"line": 244,
						"comment": "\n",
						"deco": "Pa",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 112,
						"name": "b_size",
						"line": 245,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 120,
						"name": "b_used",
						"line": 246,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 251,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 252,
						"value": "1",
						"comment": " tell the lib to end the task\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "skip",
						"line": 253,
						"value": "2",
						"comment": " skip this chunk over\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlChunkBgnFunc",
				"line": 250,
				"comment": " return codes for CURLOPT_CHUNK_BGN_FUNCTION\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_chunk_bgn_callback",
				"line": 259,
				"comment": " if splitting of data transfer is enabled, this callback is called before\n   download of an individual chunk started. Note that parameter \"remains\" works\n   only for FTP wildcard downloading (for now), otherwise is not used\n",
				"deco": "PFPvPviZl",
				"char": 67,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 263,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 264,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlChunkEndFunc",
				"line": 262,
				"comment": " return codes for CURLOPT_CHUNK_END_FUNCTION\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_chunk_end_callback",
				"line": 272,
				"comment": " If splitting of data transfer is enabled this callback is called after\n   download of an individual chunk finished.\n   Note! After this callback was set then it have to be called FOR ALL chunks.\n   Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC.\n   This is the reason why we don't need \"transfer_info\" parameter in this\n   callback and we are not interested in \"remains\" parameter too.\n",
				"deco": "PFPvZl",
				"char": 33,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "match",
						"line": 276,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nomatch",
						"line": 277,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 278,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlFnMAtchFunc",
				"line": 275,
				"comment": " return codes for FNMATCHFUNCTION\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_fnmatch_callback",
				"line": 283,
				"comment": " callback type for wildcard downloading pattern matching. If the\n   string matches the pattern, return CURL_FNMATCHFUNC_MATCH value, etc.\n",
				"deco": "PFPvxPaxPaZi",
				"char": 66,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "set",
						"line": 287,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "current",
						"line": 288,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "end",
						"line": 289,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlSeekPos",
				"line": 286,
				"comment": "seek whence...\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 294,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fail",
						"line": 295,
						"value": "1",
						"comment": " fail the entire transfer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cantseek",
						"line": 296,
						"value": "2",
						"comment": " tell libcurl seeking can't be done, so\n               libcurl might try other means instead\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlSeek",
				"line": 293,
				"comment": " These are the return codes for the seek callbacks\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_seek_callback",
				"line": 301,
				"comment": "\n",
				"deco": "PFPvliZi",
				"char": 67,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "abort",
						"line": 307,
						"value": "268435456",
						"comment": " This is a return code for the read callback that, when returned, will\n     signal libcurl to immediately abort the current transfer.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "pause",
						"line": 312,
						"value": "268435457",
						"comment": " This is a return code for the read callback that, when returned,\n     will const signal libcurl to pause sending data on the current\n     transfer.\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlReadFunc",
				"line": 304,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_read_callback",
				"line": 316,
				"comment": "\n",
				"deco": "PFPammPvZm",
				"char": 81,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ipcxn",
						"line": 320,
						"value": "0",
						"comment": " socket created for a specific IP connection\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 321,
						"value": "1",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlSockType",
				"line": 319,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curlsocktype",
				"line": 324,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_sockopt_callback",
				"line": 327,
				"comment": "\n",
				"deco": "PFPvE3std6socket8socket_tiZi",
				"char": 79,
				"kind": "alias"
			},
			{
				"name": "curl_sockaddr",
				"line": 331,
				"comment": " addrlen was a socklen_t type before 7.18.0 but it turned really\n   ugly and painful on the systems that lack this type\n",
				"members": [
					{
						"offset": 0,
						"name": "family",
						"line": 333,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 4,
						"name": "socktype",
						"line": 334,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "protocol",
						"line": 335,
						"comment": "\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 12,
						"name": "addrlen",
						"line": 336,
						"comment": " addrlen was a socklen_t type before 7.18.0 but it\n                     turned really ugly and painful on the systems that\n                     lack this type\n",
						"deco": "k",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "addr",
						"line": 339,
						"comment": "\n",
						"deco": "S4core3sys5posix3sys6socket8sockaddr",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_opensocket_callback",
				"line": 343,
				"comment": "\n",
				"deco": "PFPviPS3etc1c4curl13curl_sockaddrZE3std6socket8socket_t",
				"char": 91,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 348,
						"value": "0",
						"comment": " I/O operation successful\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknowncmd",
						"line": 349,
						"value": "1",
						"comment": " command was unknown to callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "failrestart",
						"line": 350,
						"value": "2",
						"comment": " failed to restart the read\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 351,
						"value": "3",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlIoError",
				"line": 346,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curlioerr",
				"line": 354,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "nop",
						"line": 358,
						"value": "0",
						"comment": " command was unknown to callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "restartread",
						"line": 359,
						"value": "1",
						"comment": " failed to restart the read\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 360,
						"value": "2",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlIoCmd",
				"line": 357,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curliocmd",
				"line": 363,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_ioctl_callback",
				"line": 366,
				"comment": "\n",
				"deco": "PFPviPvZi",
				"char": 64,
				"kind": "alias"
			},
			{
				"name": "curl_malloc_callback",
				"line": 374,
				"comment": " The following typedef's are signatures of malloc, free, realloc, strdup and\n calloc respectively.  Function pointers of these types can be passed to the\n curl_global_init_mem() function to set user defined memory management\n callback routines.\n",
				"deco": "PFmZPv",
				"char": 35,
				"kind": "alias"
			},
			{
				"name": "curl_free_callback",
				"line": 376,
				"comment": "ditto\n",
				"deco": "PFPvZv",
				"char": 32,
				"kind": "alias"
			},
			{
				"name": "curl_realloc_callback",
				"line": 378,
				"comment": "ditto\n",
				"deco": "PFPvmZPv",
				"char": 46,
				"kind": "alias"
			},
			{
				"name": "curl_strdup_callback",
				"line": 380,
				"comment": "ditto\n",
				"deco": "PFxPaZPa",
				"char": 36,
				"kind": "alias"
			},
			{
				"name": "curl_calloc_callback",
				"line": 382,
				"comment": "ditto\n",
				"deco": "PFmmZPv",
				"char": 49,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "text",
						"line": 386,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "header_in",
						"line": 387,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "header_out",
						"line": 388,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "data_in",
						"line": 389,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "data_out",
						"line": 390,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_data_in",
						"line": 391,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_data_out",
						"line": 392,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "end",
						"line": 393,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlCallbackInfo",
				"line": 385,
				"comment": " the kind of data that is passed to information_callback\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_infotype",
				"line": 396,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_debug_callback",
				"line": 404,
				"comment": "\n",
				"deco": "PFPviPamPvZi",
				"char": 22,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 414,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unsupported_protocol",
						"line": 415,
						"value": "1",
						"comment": " 1\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "failed_init",
						"line": 416,
						"value": "2",
						"comment": " 2\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "url_malformat",
						"line": 417,
						"value": "3",
						"comment": " 3\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete4",
						"line": 418,
						"value": "4",
						"comment": " 4 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "couldnt_resolve_proxy",
						"line": 419,
						"value": "5",
						"comment": " 5\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "couldnt_resolve_host",
						"line": 420,
						"value": "6",
						"comment": " 6\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "couldnt_connect",
						"line": 421,
						"value": "7",
						"comment": " 7\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_server_reply",
						"line": 422,
						"value": "8",
						"comment": " 8\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_access_denied",
						"line": 423,
						"value": "9",
						"comment": " 9 a service was denied by the server\n                                    due to lack of access - when login fails\n                                    this is not returned.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete10",
						"line": 426,
						"value": "10",
						"comment": " 10 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_pass_reply",
						"line": 427,
						"value": "11",
						"comment": " 11\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete12",
						"line": 428,
						"value": "12",
						"comment": " 12 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_pasv_reply",
						"line": 429,
						"value": "13",
						"comment": " 13\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_weird_227_format",
						"line": 430,
						"value": "14",
						"comment": " 14\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_cant_get_host",
						"line": 431,
						"value": "15",
						"comment": " 15\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete16",
						"line": 432,
						"value": "16",
						"comment": " 16 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_couldnt_set_type",
						"line": 433,
						"value": "17",
						"comment": " 17\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "partial_file",
						"line": 434,
						"value": "18",
						"comment": " 18\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_couldnt_retr_file",
						"line": 435,
						"value": "19",
						"comment": " 19\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete20",
						"line": 436,
						"value": "20",
						"comment": " 20 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "quote_error",
						"line": 437,
						"value": "21",
						"comment": " 21 - quote command failure\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_returned_error",
						"line": 438,
						"value": "22",
						"comment": " 22\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "write_error",
						"line": 439,
						"value": "23",
						"comment": " 23\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete24",
						"line": 440,
						"value": "24",
						"comment": " 24 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "upload_failed",
						"line": 441,
						"value": "25",
						"comment": " 25 - failed upload \"command\"\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "read_error",
						"line": 442,
						"value": "26",
						"comment": " 26 - couldn't open/read from file\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "out_of_memory",
						"line": 443,
						"value": "27",
						"comment": " 27\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "operation_timedout",
						"line": 448,
						"value": "28",
						"comment": " Note: CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error\n             instead of a memory allocation error if CURL_DOES_CONVERSIONS\n             is defined\n\n 28 - the timeout time was reached\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete29",
						"line": 449,
						"value": "29",
						"comment": " 29 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_port_failed",
						"line": 450,
						"value": "30",
						"comment": " 30 - FTP PORT operation failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_couldnt_use_rest",
						"line": 451,
						"value": "31",
						"comment": " 31 - the REST command failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete32",
						"line": 452,
						"value": "32",
						"comment": " 32 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "range_error",
						"line": 453,
						"value": "33",
						"comment": " 33 - RANGE \"command\" didn't work\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_post_error",
						"line": 454,
						"value": "34",
						"comment": " 34\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_connect_error",
						"line": 455,
						"value": "35",
						"comment": " 35 - wrong when connecting with SSL\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_download_resume",
						"line": 456,
						"value": "36",
						"comment": " 36 - couldn't resume download\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "file_couldnt_read_file",
						"line": 457,
						"value": "37",
						"comment": " 37\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ldap_cannot_bind",
						"line": 458,
						"value": "38",
						"comment": " 38\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ldap_search_failed",
						"line": 459,
						"value": "39",
						"comment": " 39\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete40",
						"line": 460,
						"value": "40",
						"comment": " 40 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "function_not_found",
						"line": 461,
						"value": "41",
						"comment": " 41\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "aborted_by_callback",
						"line": 462,
						"value": "42",
						"comment": " 42\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_function_argument",
						"line": 463,
						"value": "43",
						"comment": " 43\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete44",
						"line": 464,
						"value": "44",
						"comment": " 44 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "interface_failed",
						"line": 465,
						"value": "45",
						"comment": " 45 - CURLOPT_INTERFACE failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete46",
						"line": 466,
						"value": "46",
						"comment": " 46 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "too_many_redirects",
						"line": 467,
						"value": "47",
						"comment": " 47 - catch endless re-direct loops\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown_telnet_option",
						"line": 468,
						"value": "48",
						"comment": " 48 - User specified an unknown option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "telnet_option_syntax",
						"line": 469,
						"value": "49",
						"comment": " 49 - Malformed telnet option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete50",
						"line": 470,
						"value": "50",
						"comment": " 50 - NOT USED\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "peer_failed_verification",
						"line": 471,
						"value": "51",
						"comment": " 51 - peer's certificate or fingerprint\n                                         wasn't verified fine\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "got_nothing",
						"line": 473,
						"value": "52",
						"comment": " 52 - when this is a specific error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engine_notfound",
						"line": 474,
						"value": "53",
						"comment": " 53 - SSL crypto engine not found\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engine_setfailed",
						"line": 475,
						"value": "54",
						"comment": " 54 - can not set SSL crypto engine as default\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "send_error",
						"line": 476,
						"value": "55",
						"comment": " 55 - failed sending network data\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "recv_error",
						"line": 477,
						"value": "56",
						"comment": " 56 - failure in receiving network data\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "obsolete57",
						"line": 478,
						"value": "57",
						"comment": " 57 - NOT IN USE\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_certproblem",
						"line": 479,
						"value": "58",
						"comment": " 58 - problem with the local certificate\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_cipher",
						"line": 480,
						"value": "59",
						"comment": " 59 - couldn't use specified cipher\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_cacert",
						"line": 481,
						"value": "60",
						"comment": " 60 - problem with the CA cert (path?)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_content_encoding",
						"line": 482,
						"value": "61",
						"comment": " 61 - Unrecognized transfer encoding\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ldap_invalid_url",
						"line": 483,
						"value": "62",
						"comment": " 62 - Invalid LDAP URL\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "filesize_exceeded",
						"line": 484,
						"value": "63",
						"comment": " 63 - Maximum file size exceeded\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "use_ssl_failed",
						"line": 485,
						"value": "64",
						"comment": " 64 - Requested FTP SSL level failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "send_fail_rewind",
						"line": 486,
						"value": "65",
						"comment": " 65 - Sending the data requires a rewind that failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engine_initfailed",
						"line": 487,
						"value": "66",
						"comment": " 66 - failed to initialise ENGINE\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "login_denied",
						"line": 488,
						"value": "67",
						"comment": " 67 - user, password or similar was not accepted and we failed to login\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_notfound",
						"line": 489,
						"value": "68",
						"comment": " 68 - file not found on server\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_perm",
						"line": 490,
						"value": "69",
						"comment": " 69 - permission problem on server\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_disk_full",
						"line": 491,
						"value": "70",
						"comment": " 70 - out of disk space on server\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_illegal",
						"line": 492,
						"value": "71",
						"comment": " 71 - Illegal TFTP operation\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_unknownid",
						"line": 493,
						"value": "72",
						"comment": " 72 - Unknown transfer ID\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_file_exists",
						"line": 494,
						"value": "73",
						"comment": " 73 - File already exists\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tftp_nosuchuser",
						"line": 495,
						"value": "74",
						"comment": " 74 - No such user\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "conv_failed",
						"line": 496,
						"value": "75",
						"comment": " 75 - conversion failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "conv_reqd",
						"line": 497,
						"value": "76",
						"comment": " 76 - caller must register conversion\n                                    callbacks using curl_easy_setopt options\n                                    CURLOPT_CONV_FROM_NETWORK_FUNCTION,\n                                    CURLOPT_CONV_TO_NETWORK_FUNCTION, and\n                                    CURLOPT_CONV_FROM_UTF8_FUNCTION\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_cacert_badfile",
						"line": 502,
						"value": "77",
						"comment": " 77 - could not load CACERT file, missing  or wrong format\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "remote_file_not_found",
						"line": 503,
						"value": "78",
						"comment": " 78 - remote file not found\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssh",
						"line": 504,
						"value": "79",
						"comment": " 79 - error from the SSH layer, somewhat\n                                    generic so the error message will be of\n                                    interest when this has happened\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_shutdown_failed",
						"line": 507,
						"value": "80",
						"comment": " 80 - Failed to shut down the SSL connection\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "again",
						"line": 508,
						"value": "81",
						"comment": " 81 - socket is not ready for send/recv,\n                                    wait till it's ready and try again (Added\n                                    in 7.18.2)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_crl_badfile",
						"line": 511,
						"value": "82",
						"comment": " 82 - could not load CRL file, missing or wrong format (Added in 7.19.0)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_issuer_error",
						"line": 512,
						"value": "83",
						"comment": " 83 - Issuer check failed.  (Added in 7.19.0)\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_pret_failed",
						"line": 513,
						"value": "84",
						"comment": " 84 - a PRET command failed\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_cseq_error",
						"line": 514,
						"value": "85",
						"comment": " 85 - mismatch of RTSP CSeq numbers\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_session_error",
						"line": 515,
						"value": "86",
						"comment": " 86 - mismatch of RTSP Session Identifiers\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_bad_file_list",
						"line": 516,
						"value": "87",
						"comment": " 87 - unable to parse FTP file list\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "chunk_failed",
						"line": 517,
						"value": "88",
						"comment": " 88 - chunk callback reported error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "curl_last",
						"line": 518,
						"value": "89",
						"comment": " never use!\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlError",
				"line": 412,
				"comment": " All possible error codes from all sorts of curl functions. Future versions\n   may return other values, stay prepared.\n\n   Always add new return codes last. Never *EVER* remove any. The return\n   codes must remain the same!\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLcode",
				"line": 521,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_conv_callback",
				"line": 524,
				"comment": " This prototype applies to all conversion callbacks\n",
				"deco": "PFPamZi",
				"char": 54,
				"kind": "alias"
			},
			{
				"name": "curl_ssl_ctx_callback",
				"line": 531,
				"comment": " actually an OpenSSL SSL_CTX\n",
				"deco": "PFPvPvPvZi",
				"char": 27,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "http",
						"line": 535,
						"value": "0",
						"comment": " added in 7.10, new in 7.19.4 default is to use CONNECT HTTP/1.1\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_1_0",
						"line": 536,
						"value": "1",
						"comment": " added in 7.19.4, force to use CONNECT HTTP/1.0\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks4",
						"line": 537,
						"value": "4",
						"comment": " support added in 7.15.2, enum existed already in 7.10\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks5",
						"line": 538,
						"value": "5",
						"comment": " added in 7.10\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks4a",
						"line": 539,
						"value": "6",
						"comment": " added in 7.18.0\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socks5_hostname",
						"line": 540,
						"value": "7",
						"comment": " Use the SOCKS5 protocol but pass along the\n                         host name rather than the IP address. added\n                         in 7.18.0\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlProxy",
				"line": 534,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_proxytype",
				"line": 545,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "basic",
						"line": 550,
						"value": "1L",
						"comment": " Basic (default)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "digest",
						"line": 551,
						"value": "2L",
						"comment": " Digest\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gssnegotiate",
						"line": 552,
						"value": "4L",
						"comment": " GSS-Negotiate\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ntlm",
						"line": 553,
						"value": "8L",
						"comment": " NTLM\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "digest_ie",
						"line": 554,
						"value": "16L",
						"comment": " Digest with IE flavour\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "only",
						"line": 555,
						"value": "2147483648L",
						"comment": " used together with a single other\n                                type to force no auth or just that\n                                single type\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "any",
						"line": 558,
						"value": "-17L",
						"comment": " all fine types set\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "anysafe",
						"line": 559,
						"value": "-18L",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlAuth",
				"line": 548,
				"comment": "\n",
				"baseDeco": "l",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "any",
						"line": 564,
						"value": "-1",
						"comment": " all types supported by the server\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "none",
						"line": 565,
						"value": "0",
						"comment": " none allowed, silly but complete\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "publickey",
						"line": 566,
						"value": "1",
						"comment": " public/private key files\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "password",
						"line": 567,
						"value": "2",
						"comment": " password\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "host",
						"line": 568,
						"value": "4",
						"comment": " host key files\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "keyboard",
						"line": 569,
						"value": "8",
						"comment": " keyboard interactive\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlSshAuth",
				"line": 563,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURL_ERROR_SIZE",
				"line": 573,
				"comment": "\n",
				"deco": "i",
				"init": "256",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "unknown",
						"line": 578,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rsa1",
						"line": 579,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rsa",
						"line": 580,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dss",
						"line": 581,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlKHType",
				"line": 576,
				"comment": " points to a zero-terminated string encoded with base64\n   if len is zero, otherwise to the \"raw\" data\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_khkey",
				"line": 584,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "key",
						"line": 586,
						"comment": " points to a zero-terminated string encoded with base64\n                         if len is zero, otherwise to the \"raw\" data\n",
						"deco": "Pxa",
						"char": 18,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "len",
						"line": 588,
						"comment": "\n",
						"deco": "m",
						"originalType": "size_t",
						"char": 12,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "keytype",
						"line": 589,
						"comment": "\n",
						"deco": "E3etc1c4curl10CurlKHType",
						"char": 16,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "fine_add_to_file",
						"line": 595,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "fine",
						"line": 596,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "reject",
						"line": 597,
						"value": "2",
						"comment": " reject the connection, return an error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "defer",
						"line": 598,
						"value": "3",
						"comment": " do not accept it, but we can't answer right now so\n                this causes a CURLE_DEFER error but otherwise the\n                connection will be left intact etc\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 601,
						"value": "4",
						"comment": " not for use, only a marker for last-in-list\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlKHStat",
				"line": 594,
				"comment": " this is the set of return values expected from the curl_sshkeycallback\n   callback\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 606,
						"value": "0",
						"comment": " match\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "mismatch",
						"line": 607,
						"value": "1",
						"comment": " host found, key mismatch!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "missing",
						"line": 608,
						"value": "2",
						"comment": " no matching host/key found\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 609,
						"value": "3",
						"comment": " not for use, only a marker for last-in-list\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlKHMatch",
				"line": 605,
				"comment": " this is the set of status codes pass in to the callback\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_sshkeycallback",
				"line": 618,
				"comment": "\n",
				"deco": "PFPvPS3etc1c4curl10curl_khkeyPS3etc1c4curl10curl_khkeyE3etc1c4curl11CurlKHMatchPvZi",
				"char": 22,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 622,
						"value": "0",
						"comment": " do not attempt to use SSL\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tryssl",
						"line": 623,
						"value": "1",
						"comment": " try using SSL, proceed anyway otherwise\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "control",
						"line": 624,
						"value": "2",
						"comment": " SSL for the control connection or fail\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 625,
						"value": "3",
						"comment": " SSL for all communication or fail\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 626,
						"value": "4",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlUseSSL",
				"line": 621,
				"comment": " parameter for the CURLOPT_USE_SSL option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_usessl",
				"line": 629,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ccc_none",
						"line": 633,
						"value": "0",
						"comment": " do not send CCC\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ccc_passive",
						"line": 634,
						"value": "1",
						"comment": " Let the server initiate the shutdown\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ccc_active",
						"line": 635,
						"value": "2",
						"comment": " Initiate the shutdown\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ccc_last",
						"line": 636,
						"value": "3",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtpSSL",
				"line": 632,
				"comment": " parameter for the CURLOPT_FTP_SSL_CCC option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpccc",
				"line": 639,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "defaultauth",
						"line": 643,
						"value": "0",
						"comment": " let libcurl decide\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl",
						"line": 644,
						"value": "1",
						"comment": " use \"AUTH SSL\"\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tls",
						"line": 645,
						"value": "2",
						"comment": " use \"AUTH TLS\"\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 646,
						"value": "3",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtpAuth",
				"line": 642,
				"comment": " parameter for the CURLOPT_FTPSSLAUTH option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpauth",
				"line": 649,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "create_dir_none",
						"line": 653,
						"value": "0",
						"comment": " do NOT create missing dirs!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "create_dir",
						"line": 654,
						"value": "1",
						"comment": " (FTP/SFTP) if CWD fails, try MKD and then CWD again if MKD\n                          succeeded, for SFTP this does similar magic\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "create_dir_retry",
						"line": 656,
						"value": "2",
						"comment": " (FTP only) if CWD fails, try MKD and then CWD again even if MKD\n                          failed!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "create_dir_last",
						"line": 658,
						"value": "3",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtp",
				"line": 652,
				"comment": " parameter for the CURLOPT_FTP_CREATE_MISSING_DIRS option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpcreatedir",
				"line": 661,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "defaultmethod",
						"line": 665,
						"value": "0",
						"comment": " let libcurl pick\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "multicwd",
						"line": 666,
						"value": "1",
						"comment": " single CWD operation for each path part\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nocwd",
						"line": 667,
						"value": "2",
						"comment": " no CWD at all\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "singlecwd",
						"line": 668,
						"value": "3",
						"comment": " one CWD to full dir, then work on file\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 669,
						"value": "4",
						"comment": " not an option, never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFtpMethod",
				"line": 664,
				"comment": " parameter for the CURLOPT_FTP_FILEMETHOD option\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_ftpmethod",
				"line": 672,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "http",
						"line": 676,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "https",
						"line": 677,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp",
						"line": 678,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftps",
						"line": 679,
						"value": "8",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "scp",
						"line": 680,
						"value": "16",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sftp",
						"line": 681,
						"value": "32",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "telnet",
						"line": 682,
						"value": "64",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ldap",
						"line": 683,
						"value": "128",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ldaps",
						"line": 684,
						"value": "256",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dict",
						"line": 685,
						"value": "512",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "file",
						"line": 686,
						"value": "1024",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tftp",
						"line": 687,
						"value": "2048",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "imap",
						"line": 688,
						"value": "4096",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "imaps",
						"line": 689,
						"value": "8192",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "pop3",
						"line": 690,
						"value": "16384",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "pop3s",
						"line": 691,
						"value": "32768",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "smtp",
						"line": 692,
						"value": "65536",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "smtps",
						"line": 693,
						"value": "131072",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp",
						"line": 694,
						"value": "262144",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmp",
						"line": 695,
						"value": "524288",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpt",
						"line": 696,
						"value": "1048576",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpe",
						"line": 697,
						"value": "2097152",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpte",
						"line": 698,
						"value": "4194304",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmps",
						"line": 699,
						"value": "8388608",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtmpts",
						"line": 700,
						"value": "16777216",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gopher",
						"line": 701,
						"value": "33554432",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 702,
						"value": "-1",
						"comment": " enable everything\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlProto",
				"line": 675,
				"comment": " CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLOPTTYPE_LONG",
				"line": 707,
				"comment": " long may be 32 or 64 bits, but we should never depend on anything else\n   but 32\n",
				"deco": "i",
				"init": "0",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPTTYPE_OBJECTPOINT",
				"line": 709,
				"comment": "ditto\n",
				"deco": "i",
				"init": "10000",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPTTYPE_FUNCTIONPOINT",
				"line": 711,
				"comment": "ditto\n",
				"deco": "i",
				"init": "20000",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPTTYPE_OFF_T",
				"line": 714,
				"comment": "ditto\n",
				"deco": "i",
				"init": "30000",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "LONG",
				"line": 720,
				"comment": " name is uppercase CURLOPT_<name>,\n   type is one of the defined CURLOPTTYPE_<type>\n   number is unique identifier\n\n The macro \"##\" is ISO C, we assume pre-ISO C doesn't support it.\n",
				"char": 24,
				"kind": "alias"
			},
			{
				"name": "OBJECTPOINT",
				"line": 722,
				"comment": "ditto\n",
				"char": 31,
				"kind": "alias"
			},
			{
				"name": "FUNCTIONPOINT",
				"line": 724,
				"comment": "ditto\n",
				"char": 33,
				"kind": "alias"
			},
			{
				"name": "OFF_T",
				"line": 727,
				"comment": "ditto\n",
				"char": 25,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "file",
						"line": 732,
						"value": "10001",
						"comment": " This is the FILE * or void * the regular output should be written to.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "url",
						"line": 734,
						"value": "10002",
						"comment": " The full URL to get/put\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "port",
						"line": 736,
						"value": "3",
						"comment": " Port number to connect to, if other than default.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxy",
						"line": 738,
						"value": "10004",
						"comment": " Name of proxy to use.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "userpwd",
						"line": 740,
						"value": "10005",
						"comment": " \"name:password\" to use when fetching.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyuserpwd",
						"line": 742,
						"value": "10006",
						"comment": " \"name:password\" to use with proxy.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "range",
						"line": 744,
						"value": "10007",
						"comment": " Range to get, specified as an ASCII string.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "infile",
						"line": 748,
						"value": "10009",
						"comment": " not used\n\n Specified file stream to upload from (use as input):\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "errorbuffer",
						"line": 751,
						"value": "10010",
						"comment": " Buffer to receive error messages in, must be at least CURL_ERROR_SIZE\n bytes big. If this is not used, error messages go to stderr instead:\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writefunction",
						"line": 754,
						"value": "20011",
						"comment": " Function that will be called to store the output (instead of fwrite). The\n parameters will use fwrite() syntax, make sure to follow them.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "readfunction",
						"line": 757,
						"value": "20012",
						"comment": " Function that will be called to read the input (instead of fread). The\n parameters will use fread() syntax, make sure to follow them.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timeout",
						"line": 759,
						"value": "13",
						"comment": " Time-out the read operation after this amount of seconds\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "infilesize",
						"line": 769,
						"value": "14",
						"comment": " If the CURLOPT_INFILE is used, this can be used to inform libcurl about\n how large the file being sent really is. That allows better error\n checking and better verifies that the upload was successful. -1 means\n unknown size.\n\n For large file support, there is also a _LARGE version of the key\n which takes an off_t type, allowing platforms with larger off_t\n sizes to handle larger files.  See below for INFILESIZE_LARGE.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postfields",
						"line": 771,
						"value": "10015",
						"comment": " POST static input fields.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "referer",
						"line": 773,
						"value": "10016",
						"comment": " Set the referrer page (needed by some CGIs)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftpport",
						"line": 776,
						"value": "10017",
						"comment": " Set the FTP PORT string (interface name, named or numerical IP address)\n     Use i.e '-' to use default address.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "useragent",
						"line": 778,
						"value": "10018",
						"comment": " Set the User-Agent string (examined by some CGIs)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "low_speed_limit",
						"line": 786,
						"value": "19",
						"comment": " If the download receives less than \"low speed limit\" bytes/second\n during \"low speed time\" seconds, the operations is aborted.\n You could i.e if you have a pretty high speed connection, abort if\n it is less than 2000 bytes/sec during 20 seconds.\n\n Set the \"low speed limit\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "low_speed_time",
						"line": 788,
						"value": "20",
						"comment": " Set the \"low speed time\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "resume_from",
						"line": 795,
						"value": "21",
						"comment": " Set the continuation offset.\n\n Note there is also a _LARGE version of this key which uses\n off_t types, allowing for large file offsets on platforms which\n use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookie",
						"line": 797,
						"value": "10022",
						"comment": " Set cookie in request:\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpheader",
						"line": 799,
						"value": "10023",
						"comment": " This points to a linked list of headers, struct curl_slist kind\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httppost",
						"line": 801,
						"value": "10024",
						"comment": " This points to a linked list of post entries, struct curl_httppost\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslcert",
						"line": 803,
						"value": "10025",
						"comment": " name of the file keeping your private SSL-certificate\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "keypasswd",
						"line": 805,
						"value": "10026",
						"comment": " password for the SSL or SSH private key\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "crlf",
						"line": 807,
						"value": "27",
						"comment": " send TYPE parameter?\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "quote",
						"line": 809,
						"value": "10028",
						"comment": " send linked-list of QUOTE commands\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writeheader",
						"line": 812,
						"value": "10029",
						"comment": " send FILE * or void * to store headers to, if you use a callback it\n     is simply passed to the callback unmodified\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookiefile",
						"line": 815,
						"value": "10031",
						"comment": " point to a file to read the initial cookies from, also enables\n     \"cookie awareness\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslversion",
						"line": 818,
						"value": "32",
						"comment": " What version to specifically try to use.\n     See CURL_SSLVERSION defines below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timecondition",
						"line": 820,
						"value": "33",
						"comment": " What kind of HTTP time condition to use, see defines\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timevalue",
						"line": 823,
						"value": "34",
						"comment": " Time to use with the above condition. Specified in number of seconds\n     since 1 Jan 1970\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "customrequest",
						"line": 830,
						"value": "10036",
						"comment": " 35 = OBSOLETE\n\n Custom request, for customizing the get command like\n     HTTP: DELETE, TRACE and others\n     FTP: to use a different list command\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "stderr",
						"line": 832,
						"value": "10037",
						"comment": " HTTP request, for odd commands like DELETE, TRACE and others\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postquote",
						"line": 836,
						"value": "10039",
						"comment": " 38 is not used\n\n send linked-list of post-transfer QUOTE commands\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writeinfo",
						"line": 839,
						"value": "10040",
						"comment": " Pass a pointer to string of the output using full variable-replacement\n     as described elsewhere.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "verbose",
						"line": 840,
						"value": "41",
						"comment": " talk a lot\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "header",
						"line": 841,
						"value": "42",
						"comment": " throw the header out too\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "noprogress",
						"line": 842,
						"value": "43",
						"comment": " shut off the progress meter\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nobody",
						"line": 843,
						"value": "44",
						"comment": " use HEAD to get http document\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "failonerror",
						"line": 844,
						"value": "45",
						"comment": " no output on http error codes >= 300\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "upload",
						"line": 845,
						"value": "46",
						"comment": " this is an upload\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post",
						"line": 846,
						"value": "47",
						"comment": " HTTP POST method\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dirlistonly",
						"line": 847,
						"value": "48",
						"comment": " return bare names when listing directories\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "append",
						"line": 848,
						"value": "50",
						"comment": " Append instead of overwrite on upload!\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "netrc",
						"line": 851,
						"value": "51",
						"comment": " Specify whether to read the user+password from the .netrc or the URL.\n This must be one of the CURL_NETRC_* enums below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "followlocation",
						"line": 852,
						"value": "52",
						"comment": " use Location: Luke!\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "transfertext",
						"line": 853,
						"value": "53",
						"comment": " transfer data in text/ASCII format\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "put",
						"line": 854,
						"value": "54",
						"comment": " HTTP PUT\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "progressfunction",
						"line": 860,
						"value": "20056",
						"comment": " 55 = OBSOLETE\n\n Function that will be called instead of the internal progress display\n function. This function should be defined as the curl_progress_callback\n prototype defines.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "progressdata",
						"line": 862,
						"value": "10057",
						"comment": " Data passed to the progress callback\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "autoreferer",
						"line": 864,
						"value": "58",
						"comment": " We want the referrer field set automatically when following locations\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyport",
						"line": 867,
						"value": "59",
						"comment": " Port of the proxy, can be set in the proxy string as well with:\n     \"[host]:[port]\"\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postfieldsize",
						"line": 869,
						"value": "60",
						"comment": " size of the POST input data, if strlen() is not good to use\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpproxytunnel",
						"line": 871,
						"value": "61",
						"comment": " tunnel non-http operations through a HTTP proxy\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "intrface",
						"line": 873,
						"value": "10062",
						"comment": " Set the interface string to use as outgoing network interface\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "krblevel",
						"line": 877,
						"value": "10063",
						"comment": " Set the krb4/5 security level, this also enables krb4/5 awareness.  This\n is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string\n is set but doesn't match one of these, 'private' will be used.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_verifypeer",
						"line": 879,
						"value": "64",
						"comment": " Set if we should verify the peer in ssl handshake, set 1 to verify.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cainfo",
						"line": 882,
						"value": "10065",
						"comment": " The CApath or CAfile used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxredirs",
						"line": 887,
						"value": "68",
						"comment": " 66 = OBSOLETE\n\n 67 = OBSOLETE\n\n Maximum number of http redirects to follow\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "filetime",
						"line": 890,
						"value": "69",
						"comment": " Pass a long set to 1 to get the date of the requested document (if\n     possible)! Pass a zero to shut it off.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "telnetoptions",
						"line": 892,
						"value": "10070",
						"comment": " This points to a linked list of telnet options\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxconnects",
						"line": 894,
						"value": "71",
						"comment": " Max amount of cached alive connections\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "closepolicy",
						"line": 897,
						"value": "72",
						"comment": " What policy to use when closing connections when the cache is filled\n     up\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fresh_connect",
						"line": 903,
						"value": "74",
						"comment": " 73 = OBSOLETE\n\n Set to explicitly use a new connection for the upcoming transfer.\n     Do not use this unless you're absolutely sure of this, as it makes the\n     operation slower and is less friendly for the network.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "forbid_reuse",
						"line": 907,
						"value": "75",
						"comment": " Set to explicitly forbid the upcoming transfer's connection to be re-used\n     when done. Do not use this unless you're absolutely sure of this, as it\n     makes the operation slower and is less friendly for the network.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "random_file",
						"line": 910,
						"value": "10076",
						"comment": " Set to a file name that contains random data for libcurl to use to\n     seed the random engine when doing SSL connects.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "egdsocket",
						"line": 912,
						"value": "10077",
						"comment": " Set to the Entropy Gathering Daemon socket pathname\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "connecttimeout",
						"line": 916,
						"value": "78",
						"comment": " Time-out connect operations after this amount of seconds, if connects\n     are OK within this time, then fine... This only aborts the connect\n     phase. [Only works on unix-style/SIGALRM operating systems]\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "headerfunction",
						"line": 919,
						"value": "20079",
						"comment": " Function that will be called to store headers (instead of fwrite). The\n parameters will use fwrite() syntax, make sure to follow them.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpget",
						"line": 923,
						"value": "80",
						"comment": " Set this to force the HTTP request to get back to GET. Only really usable\n     if POST, PUT or a custom request have been used first.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_verifyhost",
						"line": 927,
						"value": "81",
						"comment": " Set if we should verify the Common name from the peer certificate in ssl\n handshake, set 1 to check existence, 2 to ensure that it matches the\n provided hostname.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookiejar",
						"line": 930,
						"value": "10082",
						"comment": " Specify which file name to write all known cookies in after completed\n     operation. Set file name to \"-\" (dash) to make it go to stdout.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_cipher_list",
						"line": 932,
						"value": "10083",
						"comment": " Specify which SSL ciphers to use\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http_version",
						"line": 935,
						"value": "84",
						"comment": " Specify which HTTP version to use! This must be set to one of the\n     CURL_HTTP_VERSION* enums set below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_use_epsv",
						"line": 939,
						"value": "85",
						"comment": " Specifically switch on or off the FTP engine's use of the EPSV command. By\n     default, that one will always be attempted before the more traditional\n     PASV command.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslcerttype",
						"line": 941,
						"value": "10086",
						"comment": " type of the file keeping your SSL-certificate (\"DER\", \"PEM\", \"ENG\")\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslkey",
						"line": 943,
						"value": "10087",
						"comment": " name of the file keeping your private SSL-key\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslkeytype",
						"line": 945,
						"value": "10088",
						"comment": " type of the file keeping your private SSL-key (\"DER\", \"PEM\", \"ENG\")\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslengine",
						"line": 947,
						"value": "10089",
						"comment": " crypto engine for the SSL-sub system\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sslengine_default",
						"line": 951,
						"value": "90",
						"comment": " set the crypto engine for the SSL-sub system as default\n     the param has no meaning...\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dns_use_global_cache",
						"line": 953,
						"value": "91",
						"comment": " Non-zero value means to use the global dns cache\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dns_cache_timeout",
						"line": 955,
						"value": "92",
						"comment": " DNS cache timeout\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "prequote",
						"line": 957,
						"value": "10093",
						"comment": " send linked-list of pre-transfer QUOTE commands\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "debugfunction",
						"line": 959,
						"value": "20094",
						"comment": " set the debug function\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "debugdata",
						"line": 961,
						"value": "10095",
						"comment": " set the data for the debug function\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookiesession",
						"line": 963,
						"value": "96",
						"comment": " mark this as start of a cookie session\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "capath",
						"line": 966,
						"value": "10097",
						"comment": " The CApath directory used to validate the peer certificate\n     this option is used only if SSL_VERIFYPEER is true\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "buffersize",
						"line": 968,
						"value": "98",
						"comment": " Instruct libcurl to use a smaller receive buffer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nosignal",
						"line": 972,
						"value": "99",
						"comment": " Instruct libcurl to not use any signal/alarm handlers, even when using\n     timeouts. This option is useful for multi-threaded applications.\n     See libcurl-the-guide for more background information.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "share",
						"line": 974,
						"value": "10100",
						"comment": " Provide a CURLShare for mutexing non-ts data\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxytype",
						"line": 977,
						"value": "101",
						"comment": " indicates type of proxy. accepted values are CURLPROXY_HTTP (default),\n     CURLPROXY_SOCKS4, CURLPROXY_SOCKS4A and CURLPROXY_SOCKS5.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "encoding",
						"line": 980,
						"value": "10102",
						"comment": " Set the Accept-Encoding string. Use this to tell a server you would like\n     the response to be compressed.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "private_opt",
						"line": 982,
						"value": "10103",
						"comment": " Set pointer to private data\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http200aliases",
						"line": 984,
						"value": "10104",
						"comment": " Set aliases for HTTP 200 in the HTTP Response header\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "unrestricted_auth",
						"line": 988,
						"value": "105",
						"comment": " Continue to send authentication (user+password) when following locations,\n     even when hostname changed. This can potentially send off the name\n     and password to whatever host the server decides.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_use_eprt",
						"line": 992,
						"value": "106",
						"comment": " Specifically switch on or off the FTP engine's use of the EPRT command ( it\n     also disables the LPRT attempt). By default, those ones will always be\n     attempted before the good old traditional PORT command.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "httpauth",
						"line": 996,
						"value": "107",
						"comment": " Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_USERPWD.\n     Note that setting multiple bits may cause extra network round-trips.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_ctx_function",
						"line": 1000,
						"value": "20108",
						"comment": " Set the ssl context callback function, currently only for OpenSSL ssl_ctx\n     in second argument. The function must be matching the\n     curl_ssl_ctx_callback proto.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_ctx_data",
						"line": 1003,
						"value": "10109",
						"comment": " Set the userdata for the ssl context callback function's third\n     argument\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_create_missing_dirs",
						"line": 1008,
						"value": "110",
						"comment": " FTP Option that causes missing dirs to be created on the remote server.\n     In 7.19.4 we introduced the convenience enums for this option using the\n     CURLFTP_CREATE_DIR prefix.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyauth",
						"line": 1012,
						"value": "111",
						"comment": " Set this to a bitmask value to enable the particular authentications\n     methods you like. Use this in combination with CURLOPT_PROXYUSERPWD.\n     Note that setting multiple bits may cause extra network round-trips.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_response_timeout",
						"line": 1017,
						"value": "112",
						"comment": " FTP option that changes the timeout, in seconds, associated with\n     getting a response.  This is different from transfer timeout time and\n     essentially places a demand on the FTP server to acknowledge commands\n     in a timely manner.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ipresolve",
						"line": 1021,
						"value": "113",
						"comment": " Set this option to one of the CURL_IPRESOLVE_* defines (see below) to\n     tell libcurl to resolve names to those IP versions only. This only has\n     affect on systems with support for more than one, i.e IPv4 _and_ IPv6.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxfilesize",
						"line": 1027,
						"value": "114",
						"comment": " Set this option to limit the size of a file that will be downloaded from\n     an HTTP or FTP server.\n\n     Note there is also _LARGE version which adds large file support for\n     platforms which have larger off_t sizes.  See MAXFILESIZE_LARGE below.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "infilesize_large",
						"line": 1031,
						"value": "30115",
						"comment": " See the comment for INFILESIZE above, but in short, specifies\n the size of the file being uploaded.  -1 means unknown.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "resume_from_large",
						"line": 1035,
						"value": "30116",
						"comment": " Sets the continuation offset.  There is also a LONG version of this;\n look above for RESUME_FROM.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "maxfilesize_large",
						"line": 1039,
						"value": "30117",
						"comment": " Sets the maximum size of data that will be downloaded from\n an HTTP or FTP server.  See MAXFILESIZE above for the LONG version.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "netrc_file",
						"line": 1044,
						"value": "10118",
						"comment": " Set this option to the file name of your .netrc file you want libcurl\n     to parse (using the CURLOPT_NETRC option). If not set, libcurl will do\n     a poor attempt to find the user's home directory and check for a .netrc\n     file in there.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "use_ssl",
						"line": 1050,
						"value": "119",
						"comment": " Enable SSL/TLS for FTP, pick one of:\n     CURLFTPSSL_TRY     - try using SSL, proceed anyway otherwise\n     CURLFTPSSL_CONTROL - SSL for the control connection or fail\n     CURLFTPSSL_ALL     - SSL for all communication or fail\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postfieldsize_large",
						"line": 1052,
						"value": "30120",
						"comment": " The _LARGE version of the standard POSTFIELDSIZE option\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tcp_nodelay",
						"line": 1054,
						"value": "121",
						"comment": " Enable/disable the TCP Nagle algorithm\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftpsslauth",
						"line": 1073,
						"value": "129",
						"comment": " 122 OBSOLETE, used in 7.12.3. Gone in 7.13.0\n\n 123 OBSOLETE. Gone in 7.16.0\n\n 124 OBSOLETE, used in 7.12.3. Gone in 7.13.0\n\n 125 OBSOLETE, used in 7.12.3. Gone in 7.13.0\n\n 126 OBSOLETE, used in 7.12.3. Gone in 7.13.0\n\n 127 OBSOLETE. Gone in 7.16.0\n\n 128 OBSOLETE. Gone in 7.16.0\n\n When FTP over SSL/TLS is selected (with CURLOPT_USE_SSL), this option\n     can be used to change libcurl's default action which is to first try\n     \"AUTH SSL\" and then \"AUTH TLS\" in this order, and proceed when a OK\n     response has been received.\n\n     Available parameters are:\n     CURLFTPAUTH_DEFAULT - let libcurl decide\n     CURLFTPAUTH_SSL     - try \"AUTH SSL\" first, then TLS\n     CURLFTPAUTH_TLS     - try \"AUTH TLS\" first, then SSL\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ioctlfunction",
						"line": 1074,
						"value": "20130",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ioctldata",
						"line": 1075,
						"value": "10131",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_account",
						"line": 1081,
						"value": "10134",
						"comment": " 132 OBSOLETE. Gone in 7.16.0\n\n 133 OBSOLETE. Gone in 7.16.0\n\n zero terminated string for pass on to the FTP server when asked for\n     \"account\" info\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cookielist",
						"line": 1083,
						"value": "10135",
						"comment": " feed cookies into cookie engine\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ignore_content_length",
						"line": 1085,
						"value": "136",
						"comment": " ignore Content-Length\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_skip_pasv_ip",
						"line": 1090,
						"value": "137",
						"comment": " Set to non-zero to skip the IP address received in a 227 PASV FTP server\n     response. Typically used for FTP-SSL purposes but is not restricted to\n     that. libcurl will then instead use the same IP address it used for the\n     control connection.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_filemethod",
						"line": 1093,
						"value": "138",
						"comment": " Select \"file method\" to use when doing FTP, see the curl_ftpmethod\n     above.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "localport",
						"line": 1095,
						"value": "139",
						"comment": " Local port number to bind the socket to\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "localportrange",
						"line": 1099,
						"value": "140",
						"comment": " Number of ports to try, including the first one set with LOCALPORT.\n     Thus, setting it to 1 will make no additional attempts but the first.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "connect_only",
						"line": 1102,
						"value": "141",
						"comment": " no transfer, set up connection and let application use the socket by\n     extracting it with CURLINFO_LASTSOCKET\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv_from_network_function",
						"line": 1105,
						"value": "20142",
						"comment": " Function that will be called to convert from the\n     network encoding (instead of using the iconv calls in libcurl)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv_to_network_function",
						"line": 1108,
						"value": "20143",
						"comment": " Function that will be called to convert to the\n     network encoding (instead of using the iconv calls in libcurl)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv_from_utf8_function",
						"line": 1112,
						"value": "20144",
						"comment": " Function that will be called to convert from UTF8\n     (instead of using the iconv calls in libcurl)\n     Note that this is used only for SSL certificate processing\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "max_send_speed_large",
						"line": 1115,
						"value": "30145",
						"comment": " if the connection proceeds too quickly then need to slow it down\n\n limit-rate: maximum number of bytes per second to send or receive\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "max_recv_speed_large",
						"line": 1116,
						"value": "30146",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_alternative_to_user",
						"line": 1118,
						"value": "10147",
						"comment": " Pointer to command string to send if USER/PASS fails.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sockoptfunction",
						"line": 1120,
						"value": "20148",
						"comment": " callback function for setting socket options\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl_sessionid_cache",
						"line": 1124,
						"value": "150",
						"comment": " set to 0 to disable session ID re-use for this transfer, default is\n     enabled (== 1)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_auth_types",
						"line": 1126,
						"value": "151",
						"comment": " allowed SSH authentication methods\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_public_keyfile",
						"line": 1128,
						"value": "10152",
						"comment": " Used by scp/sftp to do public/private key authentication\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_ssl_ccc",
						"line": 1131,
						"value": "154",
						"comment": " Send CCC (Clear Command Channel) after authentication\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "timeout_ms",
						"line": 1133,
						"value": "155",
						"comment": " Same as TIMEOUT and CONNECTTIMEOUT, but with ms resolution\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http_transfer_decoding",
						"line": 1137,
						"value": "157",
						"comment": " set to zero to disable the libcurl's decoding and thus pass the raw body\n     data to the application even when it is encoded/compressed\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "http_content_decoding",
						"line": 1138,
						"value": "158",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "new_file_perms",
						"line": 1141,
						"value": "159",
						"comment": " Permission used when creating new files and directories on the remote\n     server for protocols that support it, SFTP/SCP/FILE\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "new_directory_perms",
						"line": 1142,
						"value": "160",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "postredir",
						"line": 1145,
						"value": "161",
						"comment": " Set the behaviour of POST when redirecting. Values must be set to one\n     of CURL_REDIR* defines below. This used to be called CURLOPT_POST301\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_host_public_key_md5",
						"line": 1147,
						"value": "10162",
						"comment": " used by scp/sftp to verify the host's public key\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "opensocketfunction",
						"line": 1152,
						"value": "20163",
						"comment": " Callback function for opening socket (instead of socket(2)). Optionally,\n     callback is able change the address or refuse to connect returning\n     CURL_SOCKET_BAD.  The callback should have type\n     curl_opensocket_callback\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "opensocketdata",
						"line": 1153,
						"value": "10164",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "copypostfields",
						"line": 1155,
						"value": "10165",
						"comment": " POST volatile input fields.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxy_transfer_mode",
						"line": 1157,
						"value": "166",
						"comment": " set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "seekfunction",
						"line": 1159,
						"value": "20167",
						"comment": " Callback function for seeking in the input stream\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "seekdata",
						"line": 1160,
						"value": "10168",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "crlfile",
						"line": 1162,
						"value": "10169",
						"comment": " CRL file\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "issuercert",
						"line": 1164,
						"value": "10170",
						"comment": " Issuer certificate\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "address_scope",
						"line": 1166,
						"value": "171",
						"comment": " (IPv6) Address scope\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "certinfo",
						"line": 1170,
						"value": "172",
						"comment": " Collect certificate chain info and allow it to get retrievable with\n     CURLINFO_CERTINFO after the transfer is complete. (Unfortunately) only\n     working with OpenSSL-powered builds.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "username",
						"line": 1172,
						"value": "10173",
						"comment": " \"name\" and \"pwd\" to use when fetching.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "password",
						"line": 1173,
						"value": "10174",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxyusername",
						"line": 1175,
						"value": "10175",
						"comment": " \"name\" and \"pwd\" to use with Proxy when fetching.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "proxypassword",
						"line": 1176,
						"value": "10176",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "noproxy",
						"line": 1184,
						"value": "10177",
						"comment": " Comma separated list of hostnames defining no-proxy zones. These should\n     match both hostnames directly, and hostnames within a domain. For\n     example, local.com will match local.com and www.local.com, but NOT\n     notlocal.com or www.notlocal.com. For compatibility with other\n     implementations of this, .local.com will be considered to be the same as\n     local.com. A single * is the only valid wildcard, and effectively\n     disables the use of proxy.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tftp_blksize",
						"line": 1186,
						"value": "178",
						"comment": " block size for TFTP transfers\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "socks5_gssapi_service",
						"line": 1188,
						"value": "10179",
						"comment": " Socks Service\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "socks5_gssapi_nec",
						"line": 1190,
						"value": "180",
						"comment": " Socks Service\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "protocols",
						"line": 1195,
						"value": "181",
						"comment": " set the bitmask for the protocols that are allowed to be used for the\n     transfer, which thus helps the app which takes URLs from users or other\n     external inputs and want to restrict what protocol(s) to deal\n     with. Defaults to CURLPROTO_ALL.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "redir_protocols",
						"line": 1200,
						"value": "182",
						"comment": " set the bitmask for the protocols that libcurl is allowed to follow to,\n     as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs\n     to be set in both bitmasks to be allowed to get redirected to. Defaults\n     to all protocols except FILE and SCP.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_knownhosts",
						"line": 1202,
						"value": "10183",
						"comment": " set the SSH knownhost file name to use\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_keyfunction",
						"line": 1205,
						"value": "20184",
						"comment": " set the SSH host key callback, must point to a curl_sshkeycallback\n     function\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssh_keydata",
						"line": 1207,
						"value": "10185",
						"comment": " set the SSH host key callback custom pointer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "mail_from",
						"line": 1209,
						"value": "10186",
						"comment": " set the SMTP mail originator\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "mail_rcpt",
						"line": 1211,
						"value": "10187",
						"comment": " set the SMTP mail receiver(s)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ftp_use_pret",
						"line": 1213,
						"value": "188",
						"comment": " FTP: send PRET before PASV\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_request",
						"line": 1215,
						"value": "189",
						"comment": " RTSP request method (OPTIONS, SETUP, PLAY, etc...)\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_session_id",
						"line": 1217,
						"value": "10190",
						"comment": " The RTSP session identifier\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_stream_uri",
						"line": 1219,
						"value": "10191",
						"comment": " The RTSP stream URI\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_transport",
						"line": 1221,
						"value": "10192",
						"comment": " The Transport: header to use in RTSP requests\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_client_cseq",
						"line": 1223,
						"value": "193",
						"comment": " Manually initialize the client RTSP CSeq for this handle\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtsp_server_cseq",
						"line": 1225,
						"value": "194",
						"comment": " Manually initialize the server RTSP CSeq for this handle\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "interleavedata",
						"line": 1227,
						"value": "10195",
						"comment": " The stream to pass to INTERLEAVEFUNCTION.\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "interleavefunction",
						"line": 1229,
						"value": "20196",
						"comment": " Let the application define a custom write method for RTP data\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "wildcardmatch",
						"line": 1231,
						"value": "197",
						"comment": " Turn on wildcard matching\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "chunk_bgn_function",
						"line": 1234,
						"value": "20198",
						"comment": " Directory matching callback called before downloading of an\n     individual file (chunk) started\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "chunk_end_function",
						"line": 1237,
						"value": "20199",
						"comment": " Directory matching callback called after the file (chunk)\n     was downloaded, or skipped\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fnmatch_function",
						"line": 1239,
						"value": "20200",
						"comment": " Change match (fnmatch-like) callback for wildcard matching\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "chunk_data",
						"line": 1241,
						"value": "10201",
						"comment": " Let the application define custom chunk data pointer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "fnmatch_data",
						"line": 1243,
						"value": "10202",
						"comment": " FNMATCH_FUNCTION user pointer\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "resolve",
						"line": 1245,
						"value": "10203",
						"comment": " send linked-list of name:port:address sets\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_username",
						"line": 1247,
						"value": "10204",
						"comment": " Set a username for authenticated TLS\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_password",
						"line": 1249,
						"value": "10205",
						"comment": " Set a password for authenticated TLS\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_type",
						"line": 1251,
						"value": "10206",
						"comment": " Set authentication type for authenticated TLS\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "lastentry",
						"line": 1253,
						"value": "10207",
						"comment": " the last unused\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "writedata",
						"line": 1255,
						"value": "10001",
						"comment": "convenient alias\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "readdata",
						"line": 1256,
						"value": "10009",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "headerdata",
						"line": 1257,
						"value": "10029",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "rtspheader",
						"line": 1258,
						"value": "10023",
						"comment": "ditto\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlOption",
				"line": 730,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLoption",
				"line": 1261,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLOPT_SERVER_RESPONSE_TIMEOUT",
				"line": 1263,
				"comment": "\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)112",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "whatever",
						"line": 1269,
						"value": "0",
						"comment": " default, resolves addresses to all IP versions that your system allows\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "v4",
						"line": 1270,
						"value": "1",
						"comment": " resolve to ipv4 addresses\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "v6",
						"line": 1271,
						"value": "2",
						"comment": " resolve to ipv6 addresses\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlIpResolve",
				"line": 1268,
				"comment": " Below here follows defines for the CURLOPT_IPRESOLVE option. If a host\n   name resolves addresses using more than one IP protocol version, this\n   option might be handy to force libcurl to use a specific IP version.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLOPT_WRITEDATA",
				"line": 1275,
				"comment": " three convenient \"aliases\" that follow the name scheme better\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10001",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPT_READDATA",
				"line": 1277,
				"comment": "ditto\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10009",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPT_HEADERDATA",
				"line": 1279,
				"comment": "ditto\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10029",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLOPT_RTSPHEADER",
				"line": 1281,
				"comment": "ditto\n",
				"deco": "E3etc1c4curl10CurlOption",
				"init": "cast(CurlOption)10023",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1285,
						"value": "0",
						"comment": " setting this means we don't care, and that we'd\n             like the library to choose the best possible\n             for us!\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "v1_0",
						"line": 1288,
						"value": "1",
						"comment": " please use HTTP 1.0 in the request\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "v1_1",
						"line": 1289,
						"value": "2",
						"comment": " please use HTTP 1.1 in the request\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1290,
						"value": "3",
						"comment": " *ILLEGAL* http version\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlHttpVersion",
				"line": 1284,
				"comment": " These enums are for use with the CURLOPT_HTTP_VERSION option.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1297,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "options",
						"line": 1298,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "describe",
						"line": 1299,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "announce",
						"line": 1300,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "setup",
						"line": 1301,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "play",
						"line": 1302,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pause",
						"line": 1303,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "teardown",
						"line": 1304,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "get_parameter",
						"line": 1305,
						"value": "8",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "set_parameter",
						"line": 1306,
						"value": "9",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "record",
						"line": 1307,
						"value": "10",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "receive",
						"line": 1308,
						"value": "11",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1309,
						"value": "12",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlRtspReq",
				"line": 1296,
				"comment": " Public API enums for RTSP requests\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "ignored",
						"line": 1314,
						"value": "0",
						"comment": " The .netrc will never be read. This is the default.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "optional",
						"line": 1315,
						"value": "1",
						"comment": " A user:password in the URL will be preferred to one in the .netrc.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "required",
						"line": 1316,
						"value": "2",
						"comment": " A user:password in the URL will be ignored.\n Unless one is set programmatically, the .netrc\n will be queried.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1319,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlNetRcOption",
				"line": 1313,
				"comment": " These enums are for use with the CURLOPT_NETRC option.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "default_version",
						"line": 1324,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "tlsv1",
						"line": 1325,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "sslv2",
						"line": 1326,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "sslv3",
						"line": 1327,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1328,
						"value": "4",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlSslVersion",
				"line": 1323,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1333,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "srp",
						"line": 1334,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1335,
						"value": "2",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlTlsAuth",
				"line": 1332,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "get_all",
						"line": 1342,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post_301",
						"line": 1343,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post_302",
						"line": 1344,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "post_all",
						"line": 1346,
						"value": "3",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlRedir",
				"line": 1341,
				"comment": " symbols to use with CURLOPT_POSTREDIR.\n   CURL_REDIR_POST_301 and CURL_REDIR_POST_302 can be bitwise ORed so that\n   CURL_REDIR_POST_301 | CURL_REDIR_POST_302 == CURL_REDIR_POST_ALL\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1350,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ifmodsince",
						"line": 1351,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ifunmodsince",
						"line": 1352,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastmod",
						"line": 1353,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1354,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlTimeCond",
				"line": 1349,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_TimeCond",
				"line": 1357,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_strequal",
				"line": 1363,
				"comment": " curl_strequal() and curl_strnequal() are subject for removal in a future\n   libcurl, see lib/README.curlx for details\n",
				"deco": "UxPaxPaZi",
				"parameters": [
					{
						"name": "s1",
						"deco": "xPa"
					},
					{
						"name": "s2",
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) int(in char* s1, in char* s2)",
				"char": 6,
				"kind": "function"
			},
			{
				"name": "curl_strnequal",
				"line": 1365,
				"comment": "ditto\n\n curl_strequal() and curl_strnequal() are subject for removal in a future\n   libcurl, see lib/README.curlx for details\n",
				"deco": "UxPaxPamZi",
				"parameters": [
					{
						"name": "s1",
						"deco": "xPa"
					},
					{
						"name": "s2",
						"deco": "xPa"
					},
					{
						"name": "n",
						"deco": "m"
					}
				],
				"originalType": "extern (C) int(in char* s1, in char* s2, size_t n)",
				"char": 6,
				"kind": "function"
			},
			{
				"name": "curl_forms",
				"line": 1394,
				"comment": " structure to be used as parameter for CURLFORM_ARRAY\n",
				"members": [
					{
						"offset": 0,
						"name": "option",
						"line": 1396,
						"comment": "\n",
						"deco": "i",
						"originalType": "CURLformoption",
						"char": 20,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "value",
						"line": 1397,
						"comment": "\n",
						"deco": "Pxa",
						"char": 18,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 1417,
						"value": "0",
						"comment": " first, no error\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "memory",
						"line": 1418,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "option_twice",
						"line": 1419,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "null_ptr",
						"line": 1420,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown_option",
						"line": 1421,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "incomplete",
						"line": 1422,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "illegal_array",
						"line": 1423,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "disabled",
						"line": 1424,
						"value": "7",
						"comment": " libcurl was built with this disabled\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1425,
						"value": "8",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlFormAdd",
				"line": 1416,
				"comment": " use this for multipart formpost building\n\n Returns code for curl_formadd()\n\n Returns:\n CURL_FORMADD_OK             on success\n CURL_FORMADD_MEMORY         if the FormInfo allocation fails\n CURL_FORMADD_OPTION_TWICE   if one option is given twice for one Form\n CURL_FORMADD_NULL           if a null pointer was given for a char\n CURL_FORMADD_MEMORY         if the allocation of a FormInfo struct failed\n CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used\n CURL_FORMADD_INCOMPLETE     if the some FormInfo is not complete (or error)\n CURL_FORMADD_MEMORY         if a curl_httppost struct cannot be allocated\n CURL_FORMADD_MEMORY         if some allocation for string copying failed.\n CURL_FORMADD_ILLEGAL_ARRAY  if an illegal option is used in an array\n\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLFORMcode",
				"line": 1428,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_formadd",
				"line": 1441,
				"comment": " Name: curl_formadd()\n\n Description:\n\n Pretty advanced function for building multi-part formposts. Each invoke\n adds one part that together construct a full post. Then use\n CURLOPT_HTTPPOST to send it off to libcurl.\n",
				"deco": "UPPS3etc1c4curl13curl_httppostPPS3etc1c4curl13curl_httppostYi",
				"parameters": [
					{
						"name": "httppost",
						"deco": "PPS3etc1c4curl13curl_httppost"
					},
					{
						"name": "last_post",
						"deco": "PPS3etc1c4curl13curl_httppost"
					}
				],
				"originalType": "extern (C) CURLFORMcode(curl_httppost** httppost, curl_httppost** last_post, ...)",
				"char": 15,
				"kind": "function"
			},
			{
				"name": "curl_formget_callback",
				"line": 1451,
				"comment": " callback function for curl_formget()\n The void *arg pointer will be the one passed as second argument to\n   curl_formget().\n The character buffer passed to it must not be freed.\n Should return the buffer length passed to it as the argument \"len\" on\n   success.\n",
				"deco": "PUPvxPamZm",
				"char": 60,
				"kind": "alias"
			},
			{
				"name": "curl_formget",
				"line": 1463,
				"comment": " Name: curl_formget()\n\n Description:\n\n Serialize a curl_httppost struct built with curl_formadd().\n Accepts a void pointer as second argument which will be passed to\n the curl_formget_callback function.\n Returns 0 on success.\n",
				"deco": "UPS3etc1c4curl13curl_httppostPvPUPvxPamZmZi",
				"parameters": [
					{
						"name": "form",
						"deco": "PS3etc1c4curl13curl_httppost"
					},
					{
						"name": "arg",
						"deco": "Pv"
					},
					{
						"name": "append",
						"deco": "PUPvxPamZm"
					}
				],
				"originalType": "extern (C) int(curl_httppost* form, void* arg, curl_formget_callback append)",
				"char": 6,
				"kind": "function"
			},
			{
				"name": "curl_formfree",
				"line": 1471,
				"comment": " Name: curl_formfree()\n\n Description:\n\n Free a multipart formpost previously built with curl_formadd().\n",
				"deco": "UPS3etc1c4curl13curl_httppostZv",
				"parameters": [
					{
						"name": "form",
						"deco": "PS3etc1c4curl13curl_httppost"
					}
				],
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_getenv",
				"line": 1481,
				"comment": " Name: curl_getenv()\n\n Description:\n\n Returns a malloc()'ed string that MUST be curl_free()ed after usage is\n complete. DEPRECATED - see lib/README.curlx\n",
				"deco": "UxPaZPa",
				"parameters": [
					{
						"name": "variable",
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) char*(in char* variable)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_version",
				"line": 1490,
				"comment": " Name: curl_version()\n\n Description:\n\n Returns a static ascii string of the libcurl version.\n",
				"deco": "UZPa",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_easy_escape",
				"line": 1501,
				"comment": " Name: curl_easy_escape()\n\n Description:\n\n Escapes URL strings (converts all letters consider illegal in URLs to their\n %XX versions). This function returns a new allocated string or NULL if an\n error occurred.\n",
				"deco": "UNePvxPaiZPa",
				"parameters": [
					{
						"name": "handle",
						"deco": "Pv"
					},
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					}
				],
				"originalType": "@trusted extern (C) char*(CURL* handle, in char* string, int length)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_escape",
				"line": 1504,
				"comment": " the previous version:\n",
				"deco": "UNexPaiZPa",
				"parameters": [
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					}
				],
				"originalType": "@trusted extern (C) char*(in char* string, int length)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_easy_unescape",
				"line": 1518,
				"comment": " Name: curl_easy_unescape()\n\n Description:\n\n Unescapes URL encoding in strings (converts all %XX codes to their 8bit\n versions). This function returns a new allocated string or NULL if an error\n occurred.\n Conversion Note: On non-ASCII platforms the ASCII %XX codes are\n converted into the host encoding.\n",
				"deco": "UNePvxPaiPiZPa",
				"parameters": [
					{
						"name": "handle",
						"deco": "Pv"
					},
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					},
					{
						"name": "outlength",
						"deco": "Pi"
					}
				],
				"originalType": "@trusted extern (C) char*(CURL* handle, in char* string, int length, int* outlength)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_unescape",
				"line": 1521,
				"comment": " the previous version\n",
				"deco": "UNexPaiZPa",
				"parameters": [
					{
						"name": "string",
						"deco": "xPa"
					},
					{
						"name": "length",
						"deco": "i"
					}
				],
				"originalType": "@trusted extern (C) char*(in char* string, int length)",
				"char": 8,
				"kind": "function"
			},
			{
				"name": "curl_free",
				"line": 1531,
				"comment": " Name: curl_free()\n\n Description:\n\n Provided for de-allocation in the same translation unit that did the\n allocation. Added in libcurl 7.10\n",
				"deco": "UPvZv",
				"parameters": [
					{
						"name": "p",
						"deco": "Pv"
					}
				],
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_global_init",
				"line": 1543,
				"comment": " Name: curl_global_init()\n\n Description:\n\n curl_global_init() should be invoked exactly once for each application that\n uses libcurl and before any call of other libcurl functions.\n\n This function is not thread-safe!\n",
				"deco": "UlZi",
				"parameters": [
					{
						"name": "flags",
						"deco": "l"
					}
				],
				"originalType": "extern (C) CURLcode(c_long flags)",
				"char": 11,
				"kind": "function"
			},
			{
				"name": "curl_global_init_mem",
				"line": 1558,
				"comment": " Name: curl_global_init_mem()\n\n Description:\n\n curl_global_init() or curl_global_init_mem() should be invoked exactly once\n for each application that uses libcurl.  This function can be used to\n initialize libcurl and set user defined memory management callback\n functions.  Users can implement memory management routines to check for\n memory leaks, check for mis-use of the curl library etc.  User registered\n callback routines with be invoked by this library instead of the system\n memory management routines like malloc, free etc.\n",
				"deco": "UlPFmZPvPFPvZvPFPvmZPvPFxPaZPaPFmmZPvZi",
				"parameters": [
					{
						"name": "flags",
						"deco": "l"
					},
					{
						"name": "m",
						"deco": "PFmZPv"
					},
					{
						"name": "f",
						"deco": "PFPvZv"
					},
					{
						"name": "r",
						"deco": "PFPvmZPv"
					},
					{
						"name": "s",
						"deco": "PFxPaZPa"
					},
					{
						"name": "c",
						"deco": "PFmmZPv"
					}
				],
				"originalType": "extern (C) CURLcode(c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c)",
				"char": 11,
				"kind": "function"
			},
			{
				"name": "curl_global_cleanup",
				"line": 1568,
				"comment": " Name: curl_global_cleanup()\n\n Description:\n\n curl_global_cleanup() should be invoked exactly once for each application\n that uses libcurl\n",
				"deco": "UZv",
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_slist",
				"line": 1574,
				"comment": " linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"members": [],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "curl_slist_append",
				"line": 1588,
				"comment": " Name: curl_slist_append()\n\n Description:\n\n Appends a string to a linked list. If no list exists, it will be created\n first. Returns the new list, after appending.\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"deco": "UPS3etc1c4curl10curl_slistxPaZPS3etc1c4curl10curl_slist",
				"parameters": [
					{
						"deco": "PS3etc1c4curl10curl_slist"
					},
					{
						"deco": "xPa"
					}
				],
				"originalType": "extern (C) curl_slist*(curl_slist*, in char*)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_slist_free_all",
				"line": 1597,
				"comment": " Name: curl_slist_free_all()\n\n Description:\n\n free a previously built curl_slist.\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"deco": "UPS3etc1c4curl10curl_slistZv",
				"parameters": [
					{
						"deco": "PS3etc1c4curl10curl_slist"
					}
				],
				"char": 7,
				"kind": "function"
			},
			{
				"name": "curl_getdate",
				"line": 1608,
				"comment": " Name: curl_getdate()\n\n Description:\n\n Returns the time, in seconds since 1 Jan 1970 of the time string given in\n the first argument. The time argument in the second parameter is unused\n and should be set to NULL.\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"deco": "UPaPlZl",
				"parameters": [
					{
						"name": "p",
						"deco": "Pa"
					},
					{
						"name": "unused",
						"deco": "Pl"
					}
				],
				"originalType": "extern (C) time_t(char* p, time_t* unused)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "curl_certinfo",
				"line": 1612,
				"comment": " info about the certificate chain, only for OpenSSL builds. Asked\n   for with CURLOPT_CERTINFO / CURLINFO_CERTINFO\n\n linked-list structure for the CURLOPT_QUOTE option (and other)\n",
				"members": [
					{
						"offset": 0,
						"name": "num_of_certs",
						"line": 1614,
						"comment": " number of certificates with information\n",
						"deco": "i",
						"char": 9,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "certinfo",
						"line": 1615,
						"comment": " for each index in this array, there's a\n                              linked list with textual information in the\n                              format \"name: value\"\n",
						"deco": "PPS3etc1c4curl10curl_slist",
						"char": 18,
						"kind": "variable"
					}
				],
				"char": 1,
				"kind": "struct"
			},
			{
				"name": "CURLINFO_STRING",
				"line": 1623,
				"comment": "\n",
				"deco": "i",
				"init": "1048576",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_LONG",
				"line": 1625,
				"comment": "\n",
				"deco": "i",
				"init": "2097152",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_DOUBLE",
				"line": 1627,
				"comment": "\n",
				"deco": "i",
				"init": "3145728",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_SLIST",
				"line": 1629,
				"comment": "\n",
				"deco": "i",
				"init": "4194304",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_MASK",
				"line": 1631,
				"comment": "\n",
				"deco": "i",
				"init": "1048575",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "CURLINFO_TYPEMASK",
				"line": 1634,
				"comment": "\n",
				"deco": "i",
				"init": "15728640",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1638,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "effective_url",
						"line": 1639,
						"value": "1048577",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "response_code",
						"line": 1640,
						"value": "2097154",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "total_time",
						"line": 1641,
						"value": "3145731",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "namelookup_time",
						"line": 1642,
						"value": "3145732",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "connect_time",
						"line": 1643,
						"value": "3145733",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pretransfer_time",
						"line": 1644,
						"value": "3145734",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "size_upload",
						"line": 1645,
						"value": "3145735",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "size_download",
						"line": 1646,
						"value": "3145736",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "speed_download",
						"line": 1647,
						"value": "3145737",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "speed_upload",
						"line": 1648,
						"value": "3145738",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "header_size",
						"line": 1649,
						"value": "2097163",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "request_size",
						"line": 1650,
						"value": "2097164",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_verifyresult",
						"line": 1651,
						"value": "2097165",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "filetime",
						"line": 1652,
						"value": "2097166",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "content_length_download",
						"line": 1653,
						"value": "3145743",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "content_length_upload",
						"line": 1654,
						"value": "3145744",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "starttransfer_time",
						"line": 1655,
						"value": "3145745",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "content_type",
						"line": 1656,
						"value": "1048594",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "redirect_time",
						"line": 1657,
						"value": "3145747",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "redirect_count",
						"line": 1658,
						"value": "2097172",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "private_info",
						"line": 1659,
						"value": "1048597",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "http_connectcode",
						"line": 1660,
						"value": "2097174",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "httpauth_avail",
						"line": 1661,
						"value": "2097175",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "proxyauth_avail",
						"line": 1662,
						"value": "2097176",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "os_errno",
						"line": 1663,
						"value": "2097177",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "num_connects",
						"line": 1664,
						"value": "2097178",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_engines",
						"line": 1665,
						"value": "4194331",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "cookielist",
						"line": 1666,
						"value": "4194332",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastsocket",
						"line": 1667,
						"value": "2097181",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ftp_entry_path",
						"line": 1668,
						"value": "1048606",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "redirect_url",
						"line": 1669,
						"value": "1048607",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "primary_ip",
						"line": 1670,
						"value": "1048608",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "appconnect_time",
						"line": 1671,
						"value": "3145761",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "certinfo",
						"line": 1672,
						"value": "4194338",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "condition_unmet",
						"line": 1673,
						"value": "2097187",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_session_id",
						"line": 1674,
						"value": "1048612",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_client_cseq",
						"line": 1675,
						"value": "2097189",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_server_cseq",
						"line": 1676,
						"value": "2097190",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "rtsp_cseq_recv",
						"line": 1677,
						"value": "2097191",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "primary_port",
						"line": 1678,
						"value": "2097192",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "local_ip",
						"line": 1679,
						"value": "1048617",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "local_port",
						"line": 1680,
						"value": "2097194",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastone",
						"line": 1682,
						"value": "42",
						"comment": " Fill in new entries below here!\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlInfo",
				"line": 1637,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLINFO",
				"line": 1685,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLINFO_HTTP_CODE",
				"line": 1689,
				"comment": " CURLINFO_RESPONSE_CODE is the new name for the option previously known as\n   CURLINFO_HTTP_CODE\n",
				"deco": "E3etc1c4curl8CurlInfo",
				"init": "cast(CurlInfo)2097154",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1693,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "oldest",
						"line": 1694,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "least_recently_used",
						"line": 1695,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "least_traffic",
						"line": 1696,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "slowest",
						"line": 1697,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "callback",
						"line": 1698,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1699,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlClosePolicy",
				"line": 1692,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_closepolicy",
				"line": 1702,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ssl",
						"line": 1706,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "win32",
						"line": 1707,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 1709,
						"value": "3",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "nothing",
						"line": 1710,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "default_",
						"line": 1711,
						"value": "3",
						"comment": "all\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlGlobal",
				"line": 1705,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1720,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "share",
						"line": 1725,
						"value": "1",
						"comment": "  CURL_LOCK_DATA_SHARE is used internally to say that\n  the locking is just made to change the internal state of the share\n  itself.\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "cookie",
						"line": 1726,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "dns",
						"line": 1727,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ssl_session",
						"line": 1728,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "connect",
						"line": 1729,
						"value": "5",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1730,
						"value": "6",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlLockData",
				"line": 1719,
				"comment": " Setup defines, protos etc for the sharing stuff.\n\n Different data locks for a single share\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_lock_data",
				"line": 1733,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1737,
						"value": "0",
						"comment": " unspecified action\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "shared_access",
						"line": 1738,
						"value": "1",
						"comment": " for read perhaps\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "single",
						"line": 1739,
						"value": "2",
						"comment": " for write perhaps\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1740,
						"value": "3",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlLockAccess",
				"line": 1736,
				"comment": " Different lock access types\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_lock_access",
				"line": 1743,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_lock_function",
				"line": 1746,
				"comment": "\n",
				"deco": "PFPviiPvZv",
				"char": 98,
				"kind": "alias"
			},
			{
				"name": "curl_unlock_function",
				"line": 1748,
				"comment": "\n",
				"deco": "PFPviPvZv",
				"char": 71,
				"kind": "alias"
			},
			{
				"name": "CURLSH",
				"line": 1751,
				"comment": "\n",
				"deco": "v",
				"char": 12,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ok",
						"line": 1755,
						"value": "0",
						"comment": " all is fine\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_option",
						"line": 1756,
						"value": "1",
						"comment": " 1\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "in_use",
						"line": 1757,
						"value": "2",
						"comment": " 2\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "invalid",
						"line": 1758,
						"value": "3",
						"comment": " 3\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "nomem",
						"line": 1759,
						"value": "4",
						"comment": " out of memory\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1760,
						"value": "5",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlShError",
				"line": 1754,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLSHcode",
				"line": 1763,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "none",
						"line": 1768,
						"value": "0",
						"comment": " don't use\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "share",
						"line": 1769,
						"value": "1",
						"comment": " specify a data type to share\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unshare",
						"line": 1770,
						"value": "2",
						"comment": " specify which data type to stop sharing\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lockfunc",
						"line": 1771,
						"value": "3",
						"comment": " pass in a 'curl_lock_function' pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unlockfunc",
						"line": 1772,
						"value": "4",
						"comment": " pass in a 'curl_unlock_function' pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "userdata",
						"line": 1773,
						"value": "5",
						"comment": " pass in a user data pointer used in the lock/unlock\n                     callback functions\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1775,
						"value": "6",
						"comment": " never use\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlShOption",
				"line": 1767,
				"comment": " pass in a user data pointer used in the lock/unlock callback\n   functions\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLSHoption",
				"line": 1778,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_share_init",
				"line": 1782,
				"comment": "\n",
				"deco": "UZPv",
				"originalType": "extern (C) CURLSH*()",
				"char": 10,
				"kind": "function"
			},
			{
				"name": "curl_share_setopt",
				"line": 1784,
				"comment": "\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"deco": "Pv"
					},
					{
						"name": "option",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLSHcode(CURLSH*, CURLSHoption option, ...)",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "curl_share_cleanup",
				"line": 1786,
				"comment": "\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLSHcode(CURLSH*)",
				"char": 13,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "first",
						"line": 1795,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "second",
						"line": 1796,
						"value": "1",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "third",
						"line": 1797,
						"value": "2",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "fourth",
						"line": 1798,
						"value": "3",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 1799,
						"value": "4",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlVer",
				"line": 1794,
				"comment": " Structures for querying information about the curl library at runtime.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLversion",
				"line": 1802,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLVERSION_NOW",
				"line": 1809,
				"comment": " The 'CURLVERSION_NOW' is the symbolic name meant to be used by\n   basically all programs ever that want to get version information. It is\n   meant to be a built-in version number for what kind of struct the caller\n   expects. If the struct ever changes, we redefine the NOW to another enum\n   from above.\n",
				"deco": "E3etc1c4curl7CurlVer",
				"init": "cast(CurlVer)3",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"name": "_N28",
				"line": 1812,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "age",
						"line": 1814,
						"comment": " age of the returned struct\n",
						"deco": "i",
						"originalType": "CURLversion",
						"char": 15,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "version_",
						"line": 1815,
						"comment": " LIBCURL_VERSION\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "version_num",
						"line": 1816,
						"comment": " LIBCURL_VERSION_NUM\n",
						"deco": "k",
						"char": 8,
						"kind": "variable"
					},
					{
						"offset": 24,
						"name": "host",
						"line": 1817,
						"comment": " OS/host/cpu/machine when configured\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 32,
						"name": "features",
						"line": 1818,
						"comment": " bitmask, see defines below\n",
						"deco": "i",
						"char": 7,
						"kind": "variable"
					},
					{
						"offset": 40,
						"name": "ssl_version",
						"line": 1819,
						"comment": " human readable string\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 48,
						"name": "ssl_version_num",
						"line": 1820,
						"comment": " not used anymore, always 0\n",
						"deco": "l",
						"originalType": "c_long",
						"char": 10,
						"kind": "variable"
					},
					{
						"offset": 56,
						"name": "libz_version",
						"line": 1821,
						"comment": " human readable string\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 64,
						"name": "protocols",
						"line": 1823,
						"comment": " protocols is terminated by an entry with a NULL protoname\n",
						"deco": "PPxa",
						"char": 17,
						"kind": "variable"
					},
					{
						"offset": 72,
						"name": "ares",
						"line": 1825,
						"comment": " The fields below this were added in CURLVERSION_SECOND\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 88,
						"name": "libidn",
						"line": 1828,
						"comment": " This field was added in CURLVERSION_THIRD\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					},
					{
						"offset": 96,
						"name": "iconv_ver_num",
						"line": 1831,
						"comment": " These field were added in CURLVERSION_FOURTH\n\n Same as '_libiconv_version' if built with HAVE_ICONV\n",
						"deco": "i",
						"char": 7,
						"kind": "variable"
					},
					{
						"offset": 104,
						"name": "libssh_version",
						"line": 1832,
						"comment": " human readable string\n",
						"deco": "Pxa",
						"char": 16,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_version_info_data",
				"line": 1835,
				"comment": "\n",
				"deco": "S3etc1c4curl4_N28",
				"char": 12,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "ipv6",
						"line": 1840,
						"value": "1",
						"comment": " IPv6-enabled\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "kerberos4",
						"line": 1841,
						"value": "2",
						"comment": " kerberos auth is supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ssl",
						"line": 1842,
						"value": "4",
						"comment": " SSL options are present\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "libz",
						"line": 1843,
						"value": "8",
						"comment": " libz features are present\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "ntlm",
						"line": 1844,
						"value": "16",
						"comment": " NTLM auth is supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "gssnegotiate",
						"line": 1845,
						"value": "32",
						"comment": " Negotiate auth support\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "dbg",
						"line": 1846,
						"value": "64",
						"comment": " built with debug capabilities\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "asynchdns",
						"line": 1847,
						"value": "128",
						"comment": " asynchronous dns resolves\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "spnego",
						"line": 1848,
						"value": "256",
						"comment": " SPNEGO auth\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "largefile",
						"line": 1849,
						"value": "512",
						"comment": " supports files bigger than 2GB\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "idn",
						"line": 1850,
						"value": "1024",
						"comment": " International Domain Names support\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "sspi",
						"line": 1851,
						"value": "2048",
						"comment": " SSPI is supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "conv",
						"line": 1852,
						"value": "4096",
						"comment": " character conversions supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "curldebug",
						"line": 1853,
						"value": "8192",
						"comment": " debug memory tracking supported\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "tlsauth_srp",
						"line": 1854,
						"value": "16384",
						"comment": " TLS-SRP auth is supported\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlVersion",
				"line": 1839,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_version_info",
				"line": 1866,
				"comment": " Name: curl_version_info()\n\n Description:\n\n This function returns a pointer to a static copy of the version info\n struct. See above.\n",
				"deco": "UiZPS3etc1c4curl4_N28",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) curl_version_info_data*(CURLversion)",
				"char": 26,
				"kind": "function"
			},
			{
				"name": "curl_easy_strerror",
				"line": 1877,
				"comment": " Name: curl_easy_strerror()\n\n Description:\n\n The curl_easy_strerror function may be used to turn a CURLcode value\n into the equivalent human readable error string.  This is useful\n for printing meaningful error messages.\n",
				"deco": "UiZPxa",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) const(char)*(CURLcode)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_share_strerror",
				"line": 1888,
				"comment": " Name: curl_share_strerror()\n\n Description:\n\n The curl_share_strerror function may be used to turn a CURLSHcode value\n into the equivalent human readable error string.  This is useful\n for printing meaningful error messages.\n",
				"deco": "UiZPxa",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) const(char)*(CURLSHcode)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_easy_pause",
				"line": 1899,
				"comment": " Name: curl_easy_pause()\n\n Description:\n\n The curl_easy_pause function pauses or unpauses transfers. Select the new\n state by setting the bitmask, use the convenience defines below.\n\n",
				"deco": "UPviZi",
				"parameters": [
					{
						"name": "handle",
						"deco": "Pv"
					},
					{
						"name": "bitmask",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* handle, int bitmask)",
				"char": 11,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "recv",
						"line": 1905,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "recv_cont",
						"line": 1906,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "send",
						"line": 1907,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "send_cont",
						"line": 1908,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "all",
						"line": 1910,
						"value": "5",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "cont",
						"line": 1912,
						"value": "0",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlPause",
				"line": 1904,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_easy_init",
				"line": 1941,
				"comment": "\n",
				"deco": "UZPv",
				"originalType": "extern (C) CURL*()",
				"char": 10,
				"kind": "function"
			},
			{
				"name": "curl_easy_setopt",
				"line": 1943,
				"comment": "\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "option",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, CURLoption option, ...)",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "curl_easy_perform",
				"line": 1945,
				"comment": "\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl)",
				"char": 13,
				"kind": "function"
			},
			{
				"name": "curl_easy_cleanup",
				"line": 1947,
				"comment": "\n",
				"deco": "UPvZv",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) void(CURL* curl)",
				"char": 9,
				"kind": "function"
			},
			{
				"name": "curl_easy_getinfo",
				"line": 1963,
				"comment": " Name: curl_easy_getinfo()\n\n Description:\n\n Request internal information from the curl session with this function.  The\n third argument MUST be a pointer to a long, a pointer to a char * or a\n pointer to a double (as the documentation describes elsewhere).  The data\n pointed to will be filled in accordingly and can be relied upon only if the\n function returns CURLE_OK.  This function is intended to get used *AFTER* a\n performed transfer, all results from this function are undefined until the\n transfer is completed.\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "info",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, CURLINFO info, ...)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "curl_easy_duphandle",
				"line": 1978,
				"comment": " Name: curl_easy_duphandle()\n\n Description:\n\n Creates a new curl session handle with the same options set for the handle\n passed in. Duplicating a handle could only be a matter of cloning data and\n options, internal state info and things like persistant connections cannot\n be transfered. It is useful in multithreaded applications when you can run\n curl_easy_duphandle() for each new thread to avoid a series of identical\n curl_easy_setopt() invokes in every thread.\n",
				"deco": "UPvZPv",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURL*(CURL* curl)",
				"char": 19,
				"kind": "function"
			},
			{
				"name": "curl_easy_reset",
				"line": 1991,
				"comment": " Name: curl_easy_reset()\n\n Description:\n\n Re-initializes a CURL handle to the default values. This puts back the\n handle to the same state as it was in when it was just created.\n\n It does keep: live connections, the Session ID cache, the DNS cache and the\n cookies.\n",
				"deco": "UPvZv",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) void(CURL* curl)",
				"char": 18,
				"kind": "function"
			},
			{
				"name": "curl_easy_recv",
				"line": 2001,
				"comment": " Name: curl_easy_recv()\n\n Description:\n\n Receives data from the connected socket. Use after successful\n curl_easy_perform() with CURLOPT_CONNECT_ONLY option.\n",
				"deco": "UPvPvmPmZi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "buffer",
						"deco": "Pv"
					},
					{
						"name": "buflen",
						"deco": "m"
					},
					{
						"name": "n",
						"deco": "Pm"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, void* buffer, size_t buflen, size_t* n)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "curl_easy_send",
				"line": 2011,
				"comment": " Name: curl_easy_send()\n\n Description:\n\n Sends data over the connected socket. Use after successful\n curl_easy_perform() with CURLOPT_CONNECT_ONLY option.\n",
				"deco": "UPvPvmPmZi",
				"parameters": [
					{
						"name": "curl",
						"deco": "Pv"
					},
					{
						"name": "buffer",
						"deco": "Pv"
					},
					{
						"name": "buflen",
						"deco": "m"
					},
					{
						"name": "n",
						"deco": "Pm"
					}
				],
				"originalType": "extern (C) CURLcode(CURL* curl, void* buffer, size_t buflen, size_t* n)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "CURLM",
				"line": 2046,
				"comment": "\n",
				"deco": "v",
				"char": 12,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "call_multi_perform",
						"line": 2050,
						"value": "-1",
						"comment": " please call curl_multi_perform() or curl_multi_socket*() soon\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "ok",
						"line": 2051,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_handle",
						"line": 2052,
						"value": "1",
						"comment": " the passed-in handle is not a valid CURLM handle\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_easy_handle",
						"line": 2053,
						"value": "2",
						"comment": " an easy handle was not good/valid\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "out_of_memory",
						"line": 2054,
						"value": "3",
						"comment": " if you ever get this, you're in deep sh*t\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "internal_error",
						"line": 2055,
						"value": "4",
						"comment": " this is a libcurl bug\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "bad_socket",
						"line": 2056,
						"value": "5",
						"comment": " the passed in socket argument did not match\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "unknown_option",
						"line": 2057,
						"value": "6",
						"comment": " curl_multi_setopt() with unsupported option\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 2058,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlM",
				"line": 2049,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLMcode",
				"line": 2061,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "CURLM_CALL_MULTI_SOCKET",
				"line": 2066,
				"comment": " just to make code nicer when using curl_multi_socket() you can now check\n   for CURLM_CALL_MULTI_SOCKET too in the same style it works for\n   curl_multi_perform() and CURLM_CALL_MULTI_PERFORM\n",
				"deco": "E3etc1c4curl5CurlM",
				"init": "cast(CurlM)-1",
				"char": 6,
				"kind": "variable",
				"storageClass": [
					"enum"
				]
			},
			{
				"members": [
					{
						"name": "none",
						"line": 2071,
						"value": "0",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "done",
						"line": 2072,
						"value": "1",
						"comment": " This easy handle has completed. 'result' contains\n             the CURLcode of the transfer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "last",
						"line": 2074,
						"value": "2",
						"comment": " no used\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlMsg",
				"line": 2069,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLMSG",
				"line": 2077,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "_N31",
				"line": 2080,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "whatever",
						"line": 2082,
						"comment": " message-specific data\n",
						"deco": "Pv",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 0,
						"name": "result",
						"line": 2083,
						"comment": " return code for transfer\n",
						"deco": "i",
						"originalType": "CURLcode",
						"char": 14,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "union"
			},
			{
				"name": "CURLMsg",
				"line": 2087,
				"comment": "\n",
				"members": [
					{
						"offset": 0,
						"name": "msg",
						"line": 2089,
						"comment": " what this message means\n",
						"deco": "i",
						"originalType": "CURLMSG",
						"char": 13,
						"kind": "variable"
					},
					{
						"offset": 8,
						"name": "easy_handle",
						"line": 2090,
						"comment": " the handle it concerns\n",
						"deco": "Pv",
						"originalType": "CURL*",
						"char": 11,
						"kind": "variable"
					},
					{
						"offset": 16,
						"name": "data",
						"line": 2091,
						"comment": "\n",
						"deco": "S3etc1c4curl4_N31",
						"char": 10,
						"kind": "variable"
					}
				],
				"char": 12,
				"kind": "struct"
			},
			{
				"name": "curl_multi_init",
				"line": 2101,
				"comment": " Name:    curl_multi_init()\n\n Desc:    inititalize multi-style curl usage\n\n Returns: a new CURLM handle to use in all 'curl_multi' functions.\n",
				"deco": "UZPv",
				"originalType": "extern (C) CURLM*()",
				"char": 20,
				"kind": "function"
			},
			{
				"name": "curl_multi_add_handle",
				"line": 2110,
				"comment": " Name:    curl_multi_add_handle()\n\n Desc:    add a standard curl handle to the multi stack\n\n Returns: CURLMcode type, general multi error code.\n",
				"deco": "UPvPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "curl_handle",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, CURL* curl_handle)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_remove_handle",
				"line": 2119,
				"comment": " Name:    curl_multi_remove_handle()\n\n Desc:    removes a curl handle from the multi stack again\n\n Returns: CURLMcode type, general multi error code.\n",
				"deco": "UPvPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "curl_handle",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, CURL* curl_handle)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "fd_set",
				"line": 2132,
				"comment": " Name:    curl_multi_fdset()\n\n Desc:    Ask curl for its fd_set sets. The app can use these to select() or\n          poll() on. We want curl_multi_perform() called as soon as one of\n          them are ready.\n\n Returns: CURLMcode type, general multi error code.\n\n tmp decl\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_multi_fdset",
				"line": 2134,
				"comment": "\n",
				"deco": "UPvPiPiPiPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "read_fd_set",
						"deco": "Pi"
					},
					{
						"name": "write_fd_set",
						"deco": "Pi"
					},
					{
						"name": "exc_fd_set",
						"deco": "Pi"
					},
					{
						"name": "max_fd",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, fd_set* read_fd_set, fd_set* write_fd_set, fd_set* exc_fd_set, int* max_fd)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_perform",
				"line": 2152,
				"comment": " Name:    curl_multi_perform()\n\n Desc:    When the app thinks there's data available for curl it calls this\n          function to read/write whatever there is right now. This returns\n          as soon as the reads and writes are done. This function does not\n          require that there actually is data available for reading or that\n          data can be written, it can be called just in case. It returns\n          the number of handles that still transfer data in the second\n          argument's integer-pointer.\n\n Returns: CURLMcode type, general multi error code. *NOTE* that this only\n          returns errors etc regarding the whole multi stack. There might\n          still have occurred problems on invidual transfers even when this\n          returns OK.\n",
				"deco": "UPvPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, int* running_handles)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_cleanup",
				"line": 2164,
				"comment": " Name:    curl_multi_cleanup()\n\n Desc:    Cleans up and removes a whole multi stack. It does not free or\n          touch any individual easy handles in any way. We need to define\n          in what state those handles will be if this function is called\n          in the middle of a transfer.\n\n Returns: CURLMcode type, general multi error code.\n",
				"deco": "UPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_info_read",
				"line": 2194,
				"comment": " Name:    curl_multi_info_read()\n\n Desc:    Ask the multi handle if there's any messages/informationals from\n          the individual transfers. Messages include informationals such as\n          error code from the transfer or just the fact that a transfer is\n          completed. More details on these should be written down as well.\n\n          Repeated calls to this function will return a new struct each\n          time, until a special \"end of msgs\" struct is returned as a signal\n          that there is no more to get at this point.\n\n          The data the returned pointer points to will not survive calling\n          curl_multi_cleanup().\n\n          The 'CURLMsg' struct is meant to be very simple and only contain\n          very basic informations. If more involved information is wanted,\n          we will provide the particular \"transfer handle\" in that struct\n          and that should/could/would be used in subsequent\n          curl_easy_getinfo() calls (or similar). The point being that we\n          must never expose complex structs to applications, as then we'll\n          undoubtably get backwards compatibility problems in the future.\n\n Returns: A pointer to a filled-in struct, or NULL if it failed or ran out\n          of structs. It also writes the number of messages left in the\n          queue (after this read) in the integer the second argument points\n          to.\n",
				"deco": "UPvPiZPS3etc1c4curl7CURLMsg",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "msgs_in_queue",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMsg*(CURLM* multi_handle, int* msgs_in_queue)",
				"char": 22,
				"kind": "function"
			},
			{
				"name": "curl_multi_strerror",
				"line": 2205,
				"comment": " Name:    curl_multi_strerror()\n\n Desc:    The curl_multi_strerror function may be used to turn a CURLMcode\n          value into the equivalent human readable error string.  This is\n          useful for printing meaningful error messages.\n\n Returns: A pointer to a zero-terminated error message.\n",
				"deco": "UiZPxa",
				"parameters": [
					{
						"deco": "i"
					}
				],
				"originalType": "extern (C) const(char)*(CURLMcode)",
				"char": 25,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "none_",
						"line": 2217,
						"value": "0",
						"comment": " jdrewsen - underscored in order not to clash with reserved D symbols\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "in_",
						"line": 2218,
						"value": "1",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "out_",
						"line": 2219,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "inout_",
						"line": 2220,
						"value": "3",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "remove_",
						"line": 2221,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlPoll",
				"line": 2216,
				"comment": " Name:    curl_multi_socket() and\n          curl_multi_socket_all()\n\n Desc:    An alternative version of curl_multi_perform() that allows the\n          application to pass in one of the file descriptors that have been\n          detected to have \"action\" on them and let libcurl perform.\n          See man page for details.\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURL_SOCKET_TIMEOUT",
				"line": 2225,
				"comment": "\n",
				"char": 23,
				"kind": "alias"
			},
			{
				"members": [
					{
						"name": "in_",
						"line": 2229,
						"value": "1",
						"comment": " jdrewsen - underscored in order not to clash with reserved D symbols\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "out_",
						"line": 2230,
						"value": "2",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					},
					{
						"name": "err_",
						"line": 2231,
						"value": "4",
						"comment": "\n",
						"char": 3,
						"kind": "enum member"
					}
				],
				"name": "CurlCSelect",
				"line": 2228,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "curl_socket_callback",
				"line": 2240,
				"comment": "\n\n private socket pointer\n",
				"deco": "PUPvE3std6socket8socket_tiPvPvZi",
				"char": 36,
				"kind": "alias"
			},
			{
				"name": "curl_multi_timer_callback",
				"line": 2258,
				"comment": " private callback pointer\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n\n private callback pointer\n",
				"deco": "PUPvlPvZi",
				"char": 35,
				"kind": "alias"
			},
			{
				"name": "curl_multi_socket",
				"line": 2260,
				"comment": "ditto\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n\n private callback pointer\n",
				"deco": "UPvE3std6socket8socket_tPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "s",
						"deco": "E3std6socket8socket_t"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, curl_socket_t s, int* running_handles)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_multi_socket_action",
				"line": 2262,
				"comment": "ditto\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n\n private callback pointer\n",
				"deco": "UPvE3std6socket8socket_tiPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "s",
						"deco": "E3std6socket8socket_t"
					},
					{
						"name": "ev_bitmask",
						"deco": "i"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, curl_socket_t s, int ev_bitmask, int* running_handles)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_multi_socket_all",
				"line": 2264,
				"comment": "ditto\n\n Name:    curl_multi_timer_callback\n\n Desc:    Called by libcurl whenever the library detects a change in the\n          maximum number of milliseconds the app is allowed to wait before\n          curl_multi_socket() or curl_multi_perform() must be called\n          (to allow libcurl's timed events to take place).\n\n Returns: The callback should return zero.\n\n private callback pointer\n",
				"deco": "UPvPiZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "running_handles",
						"deco": "Pi"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, int* running_handles)",
				"char": 14,
				"kind": "function"
			},
			{
				"name": "curl_multi_timeout",
				"line": 2280,
				"comment": " This macro below was added in 7.16.3 to push users who recompile to use\n   the new curl_multi_socket_action() instead of the old curl_multi_socket()\n\n Name:    curl_multi_timeout()\n\n Desc:    Returns the maximum number of milliseconds the app is allowed to\n          wait before curl_multi_socket() or curl_multi_perform() must be\n          called (to allow libcurl's timed events to take place).\n\n Returns: CURLM error code.\n",
				"deco": "UPvPlZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "milliseconds",
						"deco": "Pl"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, c_long* milliseconds)",
				"char": 23,
				"kind": "function"
			},
			{
				"members": [
					{
						"name": "socketfunction",
						"line": 2284,
						"value": "20001",
						"comment": " This is the socket callback function pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "socketdata",
						"line": 2285,
						"value": "10002",
						"comment": " This is the argument passed to the socket callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "pipelining",
						"line": 2286,
						"value": "3",
						"comment": " set to 1 to enable pipelining for this multi handle\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "timerfunction",
						"line": 2287,
						"value": "20004",
						"comment": " This is the timer callback function pointer\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "timerdata",
						"line": 2288,
						"value": "10005",
						"comment": " This is the argument passed to the timer callback\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "maxconnects",
						"line": 2289,
						"value": "6",
						"comment": " maximum number of entries in the connection cache\n",
						"char": 5,
						"kind": "enum member"
					},
					{
						"name": "lastentry",
						"line": 2290,
						"value": "7",
						"comment": "\n",
						"char": 5,
						"kind": "enum member"
					}
				],
				"name": "CurlMOption",
				"line": 2283,
				"comment": "\n",
				"baseDeco": "i",
				"char": 1,
				"kind": "enum"
			},
			{
				"name": "CURLMoption",
				"line": 2293,
				"comment": "\n",
				"deco": "i",
				"char": 11,
				"kind": "alias"
			},
			{
				"name": "curl_multi_setopt",
				"line": 2303,
				"comment": " Name:    curl_multi_setopt()\n\n Desc:    Sets options for the multi handle.\n\n Returns: CURLM error code.\n",
				"deco": "UPviYi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "option",
						"deco": "i"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, CURLMoption option, ...)",
				"char": 23,
				"kind": "function"
			},
			{
				"name": "curl_multi_assign",
				"line": 2315,
				"comment": " Name:    curl_multi_assign()\n\n Desc:    This function sets an association in the multi handle between the\n          given socket and a private pointer of the application. This is\n          (only) useful for curl_multi_socket uses.\n\n Returns: CURLM error code.\n",
				"deco": "UPvE3std6socket8socket_tPvZi",
				"parameters": [
					{
						"name": "multi_handle",
						"deco": "Pv"
					},
					{
						"name": "sockfd",
						"deco": "E3std6socket8socket_t"
					},
					{
						"name": "sockp",
						"deco": "Pv"
					}
				],
				"originalType": "extern (C) CURLMcode(CURLM* multi_handle, curl_socket_t sockfd, void* sockp)",
				"char": 23,
				"kind": "function"
			}
		],
		"comment": "   This is an interface to the libcurl library.\n\n   Converted to D from curl headers by $(LINK2 http://www.digitalmars.com/d/2.0/htod.html, htod) and\n   cleaned up by Jonas Drewsen (jdrewsen)\n\n   Windows x86 note:\n   A DMD compatible libcurl static library can be downloaded from the dlang.org\n   $(LINK2 http://dlang.org/download.html, download page).\n\n Copyright (C) 1998 - 2010, Daniel Stenberg, &lt;daniel@haxx.se&gt;, et al.\n\n This software is licensed as described in the file COPYING, which\n you should have received as part of this distribution. The terms\n are also available at $(LINK http://curl.haxx.se/docs/copyright.html).\n\n You may opt to use, copy, modify, merge, publish, distribute and/or sell\n copies of the Software, and permit persons to whom the Software is\n furnished to do so, under the terms of the COPYING file.\n\n This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n KIND, either express or implied.\n\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sql.d",
		"name": "etc.c.odbc.sql",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/post/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sql` is the the main include for ODBC v3.0+ Core functions,\ncorresponding to the `sql.h` C header file. It `import`s `public`ly\n`etc.c.odbc.sqltypes` for conformity with the C header.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sqltypes.d",
		"name": "etc.c.odbc.sqltypes",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/thread/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com#post-cfk7ql:241p4n:241:40digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sqlext.d` corresponds to the `sqlext.h` C header file.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sqlext.d",
		"name": "etc.c.odbc.sqlext",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/thread/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com#post-cfk7ql:241p4n:241:40digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sqlext` corresponds to the `sqlext.h` C header file.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	},
	{
		"file": "/home/seb/dlang/docs/work/repo/phobos/etc/c/odbc/sqlucode.d",
		"name": "etc.c.odbc.sqlucode",
		"members": [],
		"comment": "Declarations for interfacing with the ODBC library.\n\nAdapted with minimal changes from the work of David L. Davis\n(refer to the $(WEB\nforum.dlang.org/thread/cfk7ql$(DOLLAR)1p4n$(DOLLAR)1@digitaldaemon.com#post-cfk7ql:241p4n:241:40digitaldaemon.com,\noriginal announcement)).\n\n`etc.c.odbc.sqlucode` corresponds to the `sqlucode.h` C include file.\n\nSee_Also: $(LUCKY ODBC API Reference on MSN Online)\n",
		"kind": "module"
	}
]
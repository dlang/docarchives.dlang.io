
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>std.conv - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css" />
<link rel="stylesheet" href="../css/style.css" />
<link rel="stylesheet" href="../css/print.css" media="print" />
<link rel="stylesheet" href="../css/cssmenu.css">
<link rel="shortcut icon" href="../favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0" />

</head>
<body id='std.conv' class='std'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top">	<div id="header">		<a class="logo" href=".."><img id="logo" width="125" height="95" alt="D Logo" src="../images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href=".." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    
    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <span id="search-query"><input id="q" name="q" placeholder="Search" tabindex="1000" /></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option selected value="dlang.org/phobos">Library Reference</option>
                    <option  value="forum.dlang.org">Discussion Forums</option>
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='../index.html'><span>D Lib Prerelease</span></a></li>
    <li><a href='../phobos/index.html'><span>Current Release (2.068.0)</span></a></li>
    
<li><a href='object.html'><span><em class="tt">object</em></span></a></li>
<li class='has-sub'><a href='#'><span><em class="tt">std</em></span></a>
<ul><li>  <a href="std_algorithm.html" title="std.algorithm"><span class="d_inlinecode donthyphenate notranslate">algorithm</span></a><ul><li>    <a href="std_algorithm_comparison.html" title="std.algorithm.comparison"><span class="d_inlinecode donthyphenate notranslate">comparison</span></a></li><li>    <a href="std_algorithm_iteration.html" title="std.algorithm.iteration"><span class="d_inlinecode donthyphenate notranslate">iteration</span></a></li><li>    <a href="std_algorithm_mutation.html" title="std.algorithm.mutation"><span class="d_inlinecode donthyphenate notranslate">mutation</span></a></li><li>    <a href="std_algorithm_searching.html" title="std.algorithm.searching"><span class="d_inlinecode donthyphenate notranslate">searching</span></a></li><li>    <a href="std_algorithm_setops.html" title="std.algorithm.setops"><span class="d_inlinecode donthyphenate notranslate">setops</span></a></li><li>    <a href="std_algorithm_sorting.html" title="std.algorithm.sorting"><span class="d_inlinecode donthyphenate notranslate">sorting</span></a>
  </li></ul></li><li>  <a href="std_array.html" title="std.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>  <a href="std_ascii.html" title="std.ascii"><span class="d_inlinecode donthyphenate notranslate">ascii</span></a></li><li>  <a href="std_base64.html" title="std.base64"><span class="d_inlinecode donthyphenate notranslate">base64</span></a></li><li>  <a href="std_bigint.html" title="std.bigint"><span class="d_inlinecode donthyphenate notranslate">bigint</span></a></li><li>  <a href="std_bitmanip.html" title="std.bitmanip"><span class="d_inlinecode donthyphenate notranslate">bitmanip</span></a></li><li>  <a href="std_compiler.html" title="std.compiler"><span class="d_inlinecode donthyphenate notranslate">compiler</span></a></li><li>  <a href="std_complex.html" title="std.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>  <a href="std_concurrency.html" title="std.concurrency"><span class="d_inlinecode donthyphenate notranslate">concurrency</span></a></li><li>  <a href="std_container.html" title="std.container"><span class="d_inlinecode donthyphenate notranslate">container</span></a><ul><li>    <a href="std_container_array.html" title="std.container.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>    <a href="std_container_binaryheap.html" title="std.container.binaryheap"><span class="d_inlinecode donthyphenate notranslate">binaryheap</span></a></li><li>    <a href="std_container_dlist.html" title="std.container.dlist"><span class="d_inlinecode donthyphenate notranslate">dlist</span></a></li><li>    <a href="std_container_rbtree.html" title="std.container.rbtree"><span class="d_inlinecode donthyphenate notranslate">rbtree</span></a></li><li>    <a href="std_container_slist.html" title="std.container.slist"><span class="d_inlinecode donthyphenate notranslate">slist</span></a></li><li>    <a href="std_container_util.html" title="std.container.util"><span class="d_inlinecode donthyphenate notranslate">util</span></a>
  </li></ul></li><li>  <a href="std_conv.html" title="std.conv"><span class="d_inlinecode donthyphenate notranslate">conv</span></a></li><li>  <a href="std_csv.html" title="std.csv"><span class="d_inlinecode donthyphenate notranslate">csv</span></a></li><li>  <a href="std_datetime.html" title="std.datetime"><span class="d_inlinecode donthyphenate notranslate">datetime</span></a></li><li>  <a href="std_demangle.html" title="std.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">digest</span></h7><ul><li>    <a href="std_digest_crc.html" title="std.digest.crc"><span class="d_inlinecode donthyphenate notranslate">crc</span></a></li><li>    <a href="std_digest_digest.html" title="std.digest.digest"><span class="d_inlinecode donthyphenate notranslate">digest</span></a></li><li>    <a href="std_digest_md.html" title="std.digest.md"><span class="d_inlinecode donthyphenate notranslate">md</span></a></li><li>    <a href="std_digest_ripemd.html" title="std.digest.ripemd"><span class="d_inlinecode donthyphenate notranslate">ripemd</span></a></li><li>    <a href="std_digest_sha.html" title="std.digest.sha"><span class="d_inlinecode donthyphenate notranslate">sha</span></a>
  </li></ul></li><li>  <a href="std_encoding.html" title="std.encoding"><span class="d_inlinecode donthyphenate notranslate">encoding</span></a></li><li>  <a href="std_exception.html" title="std.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">experimental</span></h7><ul><li>    <a href="std_experimental_logger.html" title="std.experimental.logger"><span class="d_inlinecode donthyphenate notranslate">logger</span></a><ul><li>      <a href="std_experimental_logger_core.html" title="std.experimental.logger.core"><span class="d_inlinecode donthyphenate notranslate">core</span></a></li><li>      <a href="std_experimental_logger_filelogger.html" title="std.experimental.logger.filelogger"><span class="d_inlinecode donthyphenate notranslate">filelogger</span></a></li><li>      <a href="std_experimental_logger_multilogger.html" title="std.experimental.logger.multilogger"><span class="d_inlinecode donthyphenate notranslate">multilogger</span></a></li><li>      <a href="std_experimental_logger_nulllogger.html" title="std.experimental.logger.nulllogger"><span class="d_inlinecode donthyphenate notranslate">nulllogger</span></a>
    </li></ul>
  </li></ul></li><li>  <a href="std_file.html" title="std.file"><span class="d_inlinecode donthyphenate notranslate">file</span></a></li><li>  <a href="std_format.html" title="std.format"><span class="d_inlinecode donthyphenate notranslate">format</span></a></li><li>  <a href="std_functional.html" title="std.functional"><span class="d_inlinecode donthyphenate notranslate">functional</span></a></li><li>  <a href="std_getopt.html" title="std.getopt"><span class="d_inlinecode donthyphenate notranslate">getopt</span></a></li><li>  <a href="std_json.html" title="std.json"><span class="d_inlinecode donthyphenate notranslate">json</span></a></li><li>  <a href="std_math.html" title="std.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="std_mathspecial.html" title="std.mathspecial"><span class="d_inlinecode donthyphenate notranslate">mathspecial</span></a></li><li>  <a href="std_meta.html" title="std.meta"><span class="d_inlinecode donthyphenate notranslate">meta</span></a></li><li>  <a href="std_metastrings.html" title="std.metastrings"><span class="d_inlinecode donthyphenate notranslate">metastrings</span></a></li><li>  <a href="std_mmfile.html" title="std.mmfile"><span class="d_inlinecode donthyphenate notranslate">mmfile</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">net</span></h7><ul><li>    <a href="std_net_curl.html" title="std.net.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="std_net_isemail.html" title="std.net.isemail"><span class="d_inlinecode donthyphenate notranslate">isemail</span></a>
  </li></ul></li><li>  <a href="std_numeric.html" title="std.numeric"><span class="d_inlinecode donthyphenate notranslate">numeric</span></a></li><li>  <a href="std_outbuffer.html" title="std.outbuffer"><span class="d_inlinecode donthyphenate notranslate">outbuffer</span></a></li><li>  <a href="std_parallelism.html" title="std.parallelism"><span class="d_inlinecode donthyphenate notranslate">parallelism</span></a></li><li>  <a href="std_path.html" title="std.path"><span class="d_inlinecode donthyphenate notranslate">path</span></a></li><li>  <a href="std_process.html" title="std.process"><span class="d_inlinecode donthyphenate notranslate">process</span></a></li><li>  <a href="std_random.html" title="std.random"><span class="d_inlinecode donthyphenate notranslate">random</span></a></li><li>  <a href="std_range.html" title="std.range"><span class="d_inlinecode donthyphenate notranslate">range</span></a><ul><li>    <a href="std_range_interfaces.html" title="std.range.interfaces"><span class="d_inlinecode donthyphenate notranslate">interfaces</span></a></li><li>    <a href="std_range_primitives.html" title="std.range.primitives"><span class="d_inlinecode donthyphenate notranslate">primitives</span></a>
  </li></ul></li><li>  <a href="std_regex.html" title="std.regex"><span class="d_inlinecode donthyphenate notranslate">regex</span></a></li><li>  <a href="std_signals.html" title="std.signals"><span class="d_inlinecode donthyphenate notranslate">signals</span></a></li><li>  <a href="std_socket.html" title="std.socket"><span class="d_inlinecode donthyphenate notranslate">socket</span></a></li><li>  <a href="std_stdint.html" title="std.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>  <a href="std_stdio.html" title="std.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>  <a href="std_stdiobase.html" title="std.stdiobase"><span class="d_inlinecode donthyphenate notranslate">stdiobase</span></a></li><li>  <a href="std_string.html" title="std.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>  <a href="std_syserror.html" title="std.syserror"><span class="d_inlinecode donthyphenate notranslate">syserror</span></a></li><li>  <a href="std_system.html" title="std.system"><span class="d_inlinecode donthyphenate notranslate">system</span></a></li><li>  <a href="std_traits.html" title="std.traits"><span class="d_inlinecode donthyphenate notranslate">traits</span></a></li><li>  <a href="std_typecons.html" title="std.typecons"><span class="d_inlinecode donthyphenate notranslate">typecons</span></a></li><li>  <a href="std_typetuple.html" title="std.typetuple"><span class="d_inlinecode donthyphenate notranslate">typetuple</span></a></li><li>  <a href="std_uni.html" title="std.uni"><span class="d_inlinecode donthyphenate notranslate">uni</span></a></li><li>  <a href="std_uri.html" title="std.uri"><span class="d_inlinecode donthyphenate notranslate">uri</span></a></li><li>  <a href="std_utf.html" title="std.utf"><span class="d_inlinecode donthyphenate notranslate">utf</span></a></li><li>  <a href="std_uuid.html" title="std.uuid"><span class="d_inlinecode donthyphenate notranslate">uuid</span></a></li><li>  <a href="std_variant.html" title="std.variant"><span class="d_inlinecode donthyphenate notranslate">variant</span></a></li><li>  <a href="std_xml.html" title="std.xml"><span class="d_inlinecode donthyphenate notranslate">xml</span></a></li><li>  <a href="std_zip.html" title="std.zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a></li><li>  <a href="std_zlib.html" title="std.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">etc</em></span></a>
<ul><li>  <h7><span class="d_inlinecode donthyphenate notranslate">c</span></h7><ul><li>    <a href="etc_c_curl.html" title="etc.c.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <h7><span class="d_inlinecode donthyphenate notranslate">odbc</span></h7><ul><li>      <a href="etc_c_odbc_sql.html" title="etc.c.odbc.sql"><span class="d_inlinecode donthyphenate notranslate">sql</span></a></li><li>      <a href="etc_c_odbc_sqlext.html" title="etc.c.odbc.sqlext"><span class="d_inlinecode donthyphenate notranslate">sqlext</span></a></li><li>      <a href="etc_c_odbc_sqltypes.html" title="etc.c.odbc.sqltypes"><span class="d_inlinecode donthyphenate notranslate">sqltypes</span></a></li><li>      <a href="etc_c_odbc_sqlucode.html" title="etc.c.odbc.sqlucode"><span class="d_inlinecode donthyphenate notranslate">sqlucode</span></a>
    </li></ul></li><li>    <a href="etc_c_sqlite3.html" title="etc.c.sqlite3"><span class="d_inlinecode donthyphenate notranslate">sqlite3</span></a></li><li>    <a href="etc_c_zlib.html" title="etc.c.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
  </li></ul>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">core</em></span></a>
<ul><li>  <a href="core_atomic.html" title="core.atomic"><span class="d_inlinecode donthyphenate notranslate">atomic</span></a></li><li>  <a href="core_bitop.html" title="core.bitop"><span class="d_inlinecode donthyphenate notranslate">bitop</span></a></li><li>  <a href="core_checkedint.html" title="core.checkedint"><span class="d_inlinecode donthyphenate notranslate">checkedint</span></a></li><li>  <a href="core_cpuid.html" title="core.cpuid"><span class="d_inlinecode donthyphenate notranslate">cpuid</span></a></li><li>  <a href="core_demangle.html" title="core.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <a href="core_exception.html" title="core.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="core_math.html" title="core.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="core_memory.html" title="core.memory"><span class="d_inlinecode donthyphenate notranslate">memory</span></a></li><li>  <a href="core_runtime.html" title="core.runtime"><span class="d_inlinecode donthyphenate notranslate">runtime</span></a></li><li>  <a href="core_simd.html" title="core.simd"><span class="d_inlinecode donthyphenate notranslate">simd</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">stdc</span></h7><ul><li>    <a href="core_stdc_complex.html" title="core.stdc.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>    <a href="core_stdc_ctype.html" title="core.stdc.ctype"><span class="d_inlinecode donthyphenate notranslate">ctype</span></a></li><li>    <a href="core_stdc_errno.html" title="core.stdc.errno"><span class="d_inlinecode donthyphenate notranslate">errno</span></a></li><li>    <a href="core_stdc_fenv.html" title="core.stdc.fenv"><span class="d_inlinecode donthyphenate notranslate">fenv</span></a></li><li>    <a href="core_stdc_float_.html" title="core.stdc.float_"><span class="d_inlinecode donthyphenate notranslate">float_</span></a></li><li>    <a href="core_stdc_inttypes.html" title="core.stdc.inttypes"><span class="d_inlinecode donthyphenate notranslate">inttypes</span></a></li><li>    <a href="core_stdc_limits.html" title="core.stdc.limits"><span class="d_inlinecode donthyphenate notranslate">limits</span></a></li><li>    <a href="core_stdc_locale.html" title="core.stdc.locale"><span class="d_inlinecode donthyphenate notranslate">locale</span></a></li><li>    <a href="core_stdc_math.html" title="core.stdc.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>    <a href="core_stdc_signal.html" title="core.stdc.signal"><span class="d_inlinecode donthyphenate notranslate">signal</span></a></li><li>    <a href="core_stdc_stdarg.html" title="core.stdc.stdarg"><span class="d_inlinecode donthyphenate notranslate">stdarg</span></a></li><li>    <a href="core_stdc_stddef.html" title="core.stdc.stddef"><span class="d_inlinecode donthyphenate notranslate">stddef</span></a></li><li>    <a href="core_stdc_stdint.html" title="core.stdc.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>    <a href="core_stdc_stdio.html" title="core.stdc.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>    <a href="core_stdc_stdlib.html" title="core.stdc.stdlib"><span class="d_inlinecode donthyphenate notranslate">stdlib</span></a></li><li>    <a href="core_stdc_string.html" title="core.stdc.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>    <a href="core_stdc_tgmath.html" title="core.stdc.tgmath"><span class="d_inlinecode donthyphenate notranslate">tgmath</span></a></li><li>    <a href="core_stdc_time.html" title="core.stdc.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>    <a href="core_stdc_wchar_.html" title="core.stdc.wchar_"><span class="d_inlinecode donthyphenate notranslate">wchar_</span></a></li><li>    <a href="core_stdc_wctype.html" title="core.stdc.wctype"><span class="d_inlinecode donthyphenate notranslate">wctype</span></a>
  </li></ul></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">sync</span></h7><ul><li>    <a href="core_sync_barrier.html" title="core.sync.barrier"><span class="d_inlinecode donthyphenate notranslate">barrier</span></a></li><li>    <a href="core_sync_condition.html" title="core.sync.condition"><span class="d_inlinecode donthyphenate notranslate">condition</span></a></li><li>    <a href="core_sync_config.html" title="core.sync.config"><span class="d_inlinecode donthyphenate notranslate">config</span></a></li><li>    <a href="core_sync_exception.html" title="core.sync.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>    <a href="core_sync_mutex.html" title="core.sync.mutex"><span class="d_inlinecode donthyphenate notranslate">mutex</span></a></li><li>    <a href="core_sync_rwmutex.html" title="core.sync.rwmutex"><span class="d_inlinecode donthyphenate notranslate">rwmutex</span></a></li><li>    <a href="core_sync_semaphore.html" title="core.sync.semaphore"><span class="d_inlinecode donthyphenate notranslate">semaphore</span></a>
  </li></ul></li><li>  <a href="core_thread.html" title="core.thread"><span class="d_inlinecode donthyphenate notranslate">thread</span></a></li><li>  <a href="core_time.html" title="core.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>  <a href="core_vararg.html" title="core.vararg"><span class="d_inlinecode donthyphenate notranslate">vararg</span></a>
</li></ul>
    <li><a href='http://code.dlang.org'><span>3rd Party Packages</span></a></li>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/phobos/&bug_severity=enhancement&component=phobos&op_sys=All&priority=P3&product=D&rep_platform=All&short_desc=%5Bstd.conv%5D&version=D2" class="button">Report a bug</a>
		<span >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</span>
	</span>
	<span class="tip">		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/conv.d" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
</div>
    <h1><span class="d_inlinecode donthyphenate notranslate">std.conv</span></h1>
    <div class="quickindex" id="quickindex"></div>
    <!--Generated by Ddoc from std/conv.d-->
<div class="summary">A one-stop shop for converting values from one type to another.
</div>
<div class="keyval License"><span class="key keyLicense">License:</span> <div class="val valLicense"><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

</div></div>
<div class="keyval Authors"><span class="key keyAuthors">Authors:</span> <div class="val valAuthors"><a href="http://digitalmars.com">Walter Bright</a>,
           <a href="http://erdani.org">Andrei Alexandrescu</a>,
           Shin Fujishiro,
           Adam D. Ruppe,
           Kenji Hara

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Source:</span>
<span class="phobos_src"><a class="https" href="https://github.com/D-Programming-Language/phobos/blob/master/std/conv.d">std/conv.d</a></span>

</div>

<dl><dt class="d_decl"><a name=".ConvException"></a><div class="quickindex" id="quickindex.ConvException"></div>class <a name="ConvException"></a><span class="ddoc_psymbol">ConvException</span>: <em class="u">object.Exception</em>;
</dt>
<dd><div class="summary">Thrown on conversion errors.</div>

</dd>
<dt class="d_decl"><a name=".ConvOverflowException"></a><div class="quickindex" id="quickindex.ConvOverflowException"></div>class <a name="ConvOverflowException"></a><span class="ddoc_psymbol">ConvOverflowException</span>: <em class="u">std.conv.ConvException</em>;
</dt>
<dd><div class="summary">Thrown on conversion overflow errors.</div>

</dd>
<dt class="d_decl"><a name=".to"></a><div class="quickindex" id="quickindex.to"></div>template <a name="to"></a><span class="ddoc_psymbol">to</span>(T)</dt>
<dd><div class="summary">The <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span></span> family of functions converts a value from type
<span class="d_param">Source</span> <a name="to"></a><span class="ddoc_psymbol">to</span> type <span class="d_param">Target</span>. The source type is
deduced and the target type must be specified, for example the
expression <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!int(42.0)</span> converts the number 42 from
<span class="d_param">double</span> <a name="to"></a><span class="ddoc_psymbol">to</span> <span class="d_param">int</span>. The conversion is "safe", i.e.,
it checks for overflow; <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!int(4.2e10)</span> would throw the
<span class="d_param">ConvOverflowException</span> exception. Overflow checks are only
inserted when necessary, e.g., <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!double(42)</span> does not do
any checking because any int fits in a double.
</div>
<div class="description">Converting a value <a name="to"></a><span class="ddoc_psymbol">to</span> its own type (useful mostly for generic code)
simply returns its argument.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">int</span> a = 42;
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(a); <span class="d_comment">// b is int with value 42
</span><span class="d_keyword">auto</span> c = <span class="d_psymbol">to</span>!<span class="d_keyword">double</span>(3.14); <span class="d_comment">// c is double with value 3.14
</span></pre>
<p></p>

Converting among numeric types is a safe way <a name="to"></a><span class="ddoc_psymbol">to</span> cast them around.
<p></p>

Conversions from floating-point types <a name="to"></a><span class="ddoc_psymbol">to</span> integral types allow loss of
precision (the fractional part of a floating-point number). The
conversion is truncating towards zero, the same way a cast would
truncate. (To round a floating point value when casting <a name="to"></a><span class="ddoc_psymbol">to</span> an
integral, use <span class="d_param">roundTo</span>.)

</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_keyword">int</span> a = 420;
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!<span class="d_keyword">long</span>(a); <span class="d_comment">// same as long b = a;
</span><span class="d_keyword">auto</span> c = <span class="d_psymbol">to</span>!<span class="d_keyword">byte</span>(a / 10); <span class="d_comment">// fine, c = 42
</span><span class="d_keyword">auto</span> d = <span class="d_psymbol">to</span>!<span class="d_keyword">byte</span>(a); <span class="d_comment">// throw ConvOverflowException
</span><span class="d_keyword">double</span> e = 4.2e6;
<span class="d_keyword">auto</span> f = <span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(e); <span class="d_comment">// f == 4200000
</span>e = -3.14;
<span class="d_keyword">auto</span> g = <span class="d_psymbol">to</span>!<span class="d_keyword">uint</span>(e); <span class="d_comment">// fails: floating-to-integral negative overflow
</span>e = 3.14;
<span class="d_keyword">auto</span> h = <span class="d_psymbol">to</span>!<span class="d_keyword">uint</span>(e); <span class="d_comment">// h = 3
</span>e = 3.99;
h = <span class="d_psymbol">to</span>!<span class="d_keyword">uint</span>(a); <span class="d_comment">// h = 3
</span>e = -3.99;
f = <span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(a); <span class="d_comment">// f = -3
</span></pre>
<p></p>

Conversions from integral types <a name="to"></a><span class="ddoc_psymbol">to</span> floating-point types always
succeed, but might lose accuracy. The largest integers with a
predecessor representable in floating-point format are 2^24-1 for
float, 2^53-1 for double, and 2^64-1 for <span class="d_param">real</span> (when
<span class="d_param">real</span> is 80-bit, e.g. on Intel machines).

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">int</span> a = 16_777_215; <span class="d_comment">// 2^24 - 1, largest proper integer representable as float
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(<span class="d_psymbol">to</span>!<span class="d_keyword">float</span>(a)) == a);
<span class="d_keyword">assert</span>(<span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(<span class="d_psymbol">to</span>!<span class="d_keyword">float</span>(-a)) == -a);
a += 2;
<span class="d_keyword">assert</span>(<span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(<span class="d_psymbol">to</span>!<span class="d_keyword">float</span>(a)) == a); <span class="d_comment">// fails!
</span></pre>
<p></p>

Conversions from string <a name="to"></a><span class="ddoc_psymbol">to</span> numeric types differ from the C equivalents
<span class="d_param">atoi()</span> and <span class="d_param">atol()</span> by checking for overflow and
not allowing whitespace.
<p></p>

For conversion of strings <a name="to"></a><span class="ddoc_psymbol">to</span> signed types, the grammar recognized is:
<pre>
<i>Integer</i>: <i>Sign UnsignedInteger</i>
<i>UnsignedInteger</i>
<i>Sign</i>:
    <b>+</b>
    <b>-</b>
</pre>
<p></p>

For conversion <a name="to"></a><span class="ddoc_psymbol">to</span> unsigned types, the grammar recognized is:
<pre>
<i>UnsignedInteger</i>:
    <i>DecimalDigit</i>
    <i>DecimalDigit</i> <i>UnsignedInteger</i>
</pre>
<p></p>

Converting an array <a name="to"></a><span class="ddoc_psymbol">to</span> another array type works by converting each
element in turn. Associative arrays can be converted <a name="to"></a><span class="ddoc_psymbol">to</span> associative
arrays as long as keys and values can in turn be converted.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [1, 2, 3];
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!(<span class="d_keyword">float</span>[])(a);
<span class="d_keyword">assert</span>(b == [1.0f, 2, 3]);
string str = <span class="d_string">"1 2 3 4 5 6"</span>;
<span class="d_keyword">auto</span> numbers = <span class="d_psymbol">to</span>!(<span class="d_keyword">double</span>[])(split(str));
<span class="d_keyword">assert</span>(numbers == [1.0, 2, 3, 4, 5, 6]);
<span class="d_keyword">int</span>[string] c;
c[<span class="d_string">"a"</span>] = 1;
c[<span class="d_string">"b"</span>] = 2;
<span class="d_keyword">auto</span> d = <span class="d_psymbol">to</span>!(<span class="d_keyword">double</span>[wstring])(c);
<span class="d_keyword">assert</span>(d[<span class="d_string">"a"w</span>] == 1 &amp;&amp; d[<span class="d_string">"b"w</span>] == 2);
</pre>
<p></p>

Conversions operate transitively, meaning that they work on arrays and
associative arrays of any complexity:
<p></p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[string][<span class="d_keyword">double</span>[<span class="d_keyword">int</span>[]]] a;
...
<span class="d_keyword">auto</span> b = <span class="d_psymbol">to</span>!(<span class="d_keyword">short</span>[wstring][string[<span class="d_keyword">double</span>[]]])(a);
</pre>
<p></p>

This conversion works because <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!short</span> applies <a name="to"></a><span class="ddoc_psymbol">to</span> an
<span class="d_param">int</span>, <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!wstring</span> applies <a name="to"></a><span class="ddoc_psymbol">to</span> a <span class="d_param">string</span>, <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!string</span> applies <a name="to"></a><span class="ddoc_psymbol">to</span> a <span class="d_param">double</span>, and
<span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!(double[])</span> applies <a name="to"></a><span class="ddoc_psymbol">to</span> an <span class="d_param">int[]</span>. The
conversion might throw an exception because <span class="d_param"><a name="to"></a><span class="ddoc_psymbol">to</span>!short</span>
might fail the range check.
<p></p>

<p></p>

   Entry point that dispatches <a name="to"></a><span class="ddoc_psymbol">to</span> the appropriate conversion
   primitive. Client code normally calls <span class="d_inlinecode donthyphenate notranslate">to!TargetType(value)</span>
   (and not some variant of <span class="d_inlinecode donthyphenate notranslate">toImpl</span>).</div>

</dd>
<dt class="d_decl"><a name=".toImpl"></a><div class="quickindex" id="quickindex.toImpl"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (isImplicitlyConvertible!(S, T) &amp;&amp; !isEnumStrToStr!(S, T) &amp;&amp; !isNullToStr!(S, T));
</dt>
<dd><div class="summary">If the source type is implicitly convertible to the target type, <span class="d_inlinecode donthyphenate notranslate">to</span> simply performs the implicit conversion.</div>

</dd>
<dt class="d_decl"><a name=".toImpl.2"></a><div class="quickindex" id="quickindex.toImpl.2"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (!isImplicitlyConvertible!(S, T) &amp;&amp; is(typeof(S.init.opCast!T()) : T) &amp;&amp; !isExactSomeString!T &amp;&amp; !is(typeof(T(<i>value</i>))));
</dt>
<dd><div class="summary">When source type supports member template function opCast, it is used.</div>

</dd>
<dt class="d_decl"><a name=".toImpl.3"></a><div class="quickindex" id="quickindex.toImpl.3"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (!isImplicitlyConvertible!(S, T) &amp;&amp; is(T == struct) &amp;&amp; is(typeof(T(<i>value</i>))));
<br>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (!isImplicitlyConvertible!(S, T) &amp;&amp; is(T == class) &amp;&amp; is(typeof(new T(<i>value</i>))));
</dt>
<dd><div class="summary">When target type supports 'converting construction', it is used.
<ul><li>If target type is struct, <span class="d_inlinecode donthyphenate notranslate">T(<i>value</i>)</span> is used.</li>
     <li>If target type is class, <span class="d_inlinecode donthyphenate notranslate">new T(<i>value</i>)</span> is used.</li></ul></div>

</dd>
<dt class="d_decl"><a name=".toImpl.4"></a><div class="quickindex" id="quickindex.toImpl.4"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (!isImplicitlyConvertible!(S, T) &amp;&amp; (is(S == class) || is(S == interface)) &amp;&amp; !is(typeof(<i>value</i>.opCast!T()) : T) &amp;&amp; (is(T == class) || is(T == interface)) &amp;&amp; !is(typeof(new T(<i>value</i>))));
</dt>
<dd><div class="summary">Object-to-object conversions by dynamic casting throw exception when the source is
non-<b>null</b> and the target is <b>null</b>.</div>

</dd>
<dt class="d_decl"><a name=".toImpl.5"></a><div class="quickindex" id="quickindex.toImpl.5"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (!(isImplicitlyConvertible!(S, T) &amp;&amp; !isEnumStrToStr!(S, T) &amp;&amp; !isNullToStr!(S, T)) &amp;&amp; !isInfinite!S &amp;&amp; isExactSomeString!T);
<br>pure @trusted T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>, uint <i>radix</i>, LetterCase <i>letterCase</i> = LetterCase.upper) if (isIntegral!S &amp;&amp; isExactSomeString!T);
</dt>
<dd><div class="summary">Stringize conversion from all types is supported.
<ul>  <li>String to string conversion works for any two string types having
       (<span class="d_inlinecode donthyphenate notranslate">char</span>, <span class="d_inlinecode donthyphenate notranslate">wchar</span>, <span class="d_inlinecode donthyphenate notranslate">dchar</span>) character widths and any
       combination of qualifiers (mutable, <span class="d_inlinecode donthyphenate notranslate">const</span>, or <span class="d_inlinecode donthyphenate notranslate">immutable</span>).</li>
  <li>Converts array (other than strings) to string.
       Each element is converted by calling <span class="d_inlinecode donthyphenate notranslate">to!T</span>.</li>
  <li>Associative array to string conversion.
       Each element is printed by calling <span class="d_inlinecode donthyphenate notranslate">to!T</span>.</li>
  <li>Object to string conversion calls <span class="d_inlinecode donthyphenate notranslate">toString</span> against the object or
       returns <span class="d_inlinecode donthyphenate notranslate">"<b>null</b>"</span> if the object is <b>null</b>.</li>
  <li>Struct to string conversion calls <span class="d_inlinecode donthyphenate notranslate">toString</span> against the struct if
       it is defined.</li>
  <li>For structs that do not define <span class="d_inlinecode donthyphenate notranslate">toString</span>, the conversion to string
       produces the list of fields.</li>
  <li>Enumerated types are converted to strings as their symbolic names.</li>
  <li>Boolean values are printed as <span class="d_inlinecode donthyphenate notranslate">"<b>true</b>"</span> or <span class="d_inlinecode donthyphenate notranslate">"<b>false</b>"</span>.</li>
  <li><span class="d_inlinecode donthyphenate notranslate">char</span>, <span class="d_inlinecode donthyphenate notranslate">wchar</span>, <span class="d_inlinecode donthyphenate notranslate">dchar</span> to a string type.</li>
  <li>Unsigned or signed integers to strings.
       <dl><dt>[special case]</dt>
            <dd>Convert integral <i>value</i> to string in <span class="d_param"><i>radix</i></span> <i>radix</i>.
            <i>radix</i> must be a <i>value</i> from 2 to 36.
            <i>value</i> is treated as a signed <i>value</i> only if <i>radix</i> is 10.
            The characters A through Z are used to represent values 10 through 36
            and their case is determined by the <span class="d_param"><i>letterCase</i></span> parameter.</dd></dl></li>
  <li>All floating point types to all string types.</li>
  <li>Pointer to string conversions prints the pointer as a <span class="d_inlinecode donthyphenate notranslate">size_t</span> <i>value</i>.
       If pointer is <span class="d_inlinecode donthyphenate notranslate">char*</span>, treat it as C-style strings.
       In that case, this function is <span class="d_inlinecode donthyphenate notranslate">@system</span>.</li></ul></div>

</dd>
<dt class="d_decl"><a name=".toImpl.6"></a><div class="quickindex" id="quickindex.toImpl.6"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (!isImplicitlyConvertible!(S, T) &amp;&amp; (isNumeric!S || isSomeChar!S || isBoolean!S) &amp;&amp; (isNumeric!T || isSomeChar!T || isBoolean!T) &amp;&amp; !is(T == enum));
</dt>
<dd><div class="summary">Narrowing numeric-numeric conversions throw when the <i>value</i> does not
fit in the narrower type.</div>

</dd>
<dt class="d_decl"><a name=".toImpl.7"></a><div class="quickindex" id="quickindex.toImpl.7"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (!isImplicitlyConvertible!(S, T) &amp;&amp; !isSomeString!S &amp;&amp; isDynamicArray!S &amp;&amp; !isExactSomeString!T &amp;&amp; isArray!T);
</dt>
<dd><div class="summary">Array-to-array conversion (except when target is a string type)
converts each element in turn by using <span class="d_inlinecode donthyphenate notranslate">to</span>.</div>

</dd>
<dt class="d_decl"><a name=".toImpl.8"></a><div class="quickindex" id="quickindex.toImpl.8"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (isAssociativeArray!S &amp;&amp; isAssociativeArray!T &amp;&amp; !is(T == enum));
</dt>
<dd><div class="summary">Associative array to associative array conversion converts each key
and each <i>value</i> in turn.</div>

</dd>
<dt class="d_decl"><a name=".toImpl.9"></a><div class="quickindex" id="quickindex.toImpl.9"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (isExactSomeString!S &amp;&amp; isDynamicArray!S &amp;&amp; !isExactSomeString!T &amp;&amp; is(typeof(parse!T(<i>value</i>))));
<br>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>, uint <i>radix</i>) if (isExactSomeString!S &amp;&amp; isDynamicArray!S &amp;&amp; !isExactSomeString!T &amp;&amp; is(typeof(parse!T(<i>value</i>, <i>radix</i>))));
</dt>
<dd><div class="summary">String to non-string conversion runs parsing.
<ul>  <li>When the source is a wide string, it is first converted to a narrow
       string and then parsed.</li>
  <li>When the source is a narrow string, normal text parsing occurs.</li></ul></div>

</dd>
<dt class="d_decl"><a name=".toImpl.10"></a><div class="quickindex" id="quickindex.toImpl.10"></div>T <a name="toImpl"></a><span class="ddoc_psymbol">toImpl</span>(T, S)(S <i>value</i>) if (is(T == enum) &amp;&amp; !is(S == enum) &amp;&amp; is(typeof(<i>value</i> == OriginalType!T.init)) &amp;&amp; !isFloatingPoint!(OriginalType!T) &amp;&amp; !isSomeString!(OriginalType!T));
</dt>
<dd><div class="summary">Convert a <i>value</i> that is implicitly convertible to the enum base type
into an Enum <i>value</i>. If the <i>value</i> does not match any enum member values
a ConvException is thrown.
Enums with floating-point or string base types are not supported.</div>

</dd>
<dt class="d_decl"><a name=".roundTo"></a><div class="quickindex" id="quickindex.roundTo"></div>template <a name="roundTo"></a><span class="ddoc_psymbol">roundTo</span>(Target)</dt>
<dd><div class="summary">Rounded conversion from floating point to integral.
</div>
<div class="description">Rounded conversions do not work with non-integral target types.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(3.14) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(3.49) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(3.5) == 4);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(3.999) == 4);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(-3.14) == -3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(-3.49) == -3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(-3.5) == -4);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!<span class="d_keyword">int</span>(-3.999) == -4);
<span class="d_keyword">assert</span>(<span class="d_psymbol">roundTo</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>)(to!(<span class="d_keyword">const</span> <span class="d_keyword">double</span>)(-3.999)) == -4);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".parse"></a><div class="quickindex" id="quickindex.parse"></div>Target <a name="parse"></a><span class="ddoc_psymbol">parse</span>(Target, Source)(ref Source <i>s</i>) if (isInputRange!Source &amp;&amp; isSomeChar!(ElementType!Source) &amp;&amp; is(Unqual!Target == bool));
<br>Target <a name="parse"></a><span class="ddoc_psymbol">parse</span>(Target, Source)(ref Source <i>s</i>, uint <i>radix</i>) if (isSomeChar!(ElementType!Source) &amp;&amp; isIntegral!Target &amp;&amp; !is(Target == enum));
</dt>
<dd><div class="summary">The <span class="d_param"><a name="parse"></a><span class="ddoc_psymbol">parse</span></span> family of functions works quite like the
 <span class="d_param">to</span> family, except that (1) it only works with character ranges
 as input, (2) takes the input by reference and advances it to
 the position following the conversion, and (3) does not throw if it
 could not convert the entire input. It still throws if an overflow
 occurred during conversion or if no character of the input
 was meaningfully converted.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.string : munch;
string test = <span class="d_string">"123 \t  76.14"</span>;
<span class="d_keyword">auto</span> a = <span class="d_psymbol">parse</span>!<span class="d_keyword">uint</span>(test);
<span class="d_keyword">assert</span>(a == 123);
<span class="d_keyword">assert</span>(test == <span class="d_string">" \t  76.14"</span>); <span class="d_comment">// parse bumps string
</span>munch(test, <span class="d_string">" \t\n\r"</span>); <span class="d_comment">// skip ws
</span><span class="d_keyword">assert</span>(test == <span class="d_string">"76.14"</span>);
<span class="d_keyword">auto</span> b = <span class="d_psymbol">parse</span>!<span class="d_keyword">double</span>(test);
<span class="d_keyword">assert</span>(b == 76.14);
<span class="d_keyword">assert</span>(test == <span class="d_string">""</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".parse.2"></a><div class="quickindex" id="quickindex.parse.2"></div>Target <a name="parse"></a><span class="ddoc_psymbol">parse</span>(Target, Source)(ref Source <i>s</i>) if (isExactSomeString!Source &amp;&amp; staticIndexOf!(Unqual!Target, dchar, Unqual!(ElementEncodingType!Source)) &gt;= 0);
</dt>
<dd><div class="summary">Parsing one character off a string returns the character and bumps the
string up one position.</div>

</dd>
<dt class="d_decl"><a name=".parse.3"></a><div class="quickindex" id="quickindex.parse.3"></div>Target <a name="parse"></a><span class="ddoc_psymbol">parse</span>(Target, Source)(ref Source <i>s</i>, dchar <i>lbracket</i> = '[', dchar <i>rbracket</i> = ']', dchar <i>comma</i> = ',') if (isExactSomeString!Source &amp;&amp; isDynamicArray!Target &amp;&amp; !is(Target == enum));
<br>Target <a name="parse"></a><span class="ddoc_psymbol">parse</span>(Target, Source)(ref Source <i>s</i>, dchar <i>lbracket</i> = '[', dchar <i>rbracket</i> = ']', dchar <i>comma</i> = ',') if (isExactSomeString!Source &amp;&amp; isStaticArray!Target &amp;&amp; !is(Target == enum));
</dt>
<dd><div class="summary">Parses an array from a string given the left bracket (default <span class="d_inlinecode donthyphenate notranslate"> '['</span>), right bracket (default <span class="d_inlinecode donthyphenate notranslate">']'</span>), and element separator (by
 default <span class="d_inlinecode donthyphenate notranslate">','</span>).</div>

</dd>
<dt class="d_decl"><a name=".parse.4"></a><div class="quickindex" id="quickindex.parse.4"></div>Target <a name="parse"></a><span class="ddoc_psymbol">parse</span>(Target, Source)(ref Source <i>s</i>, dchar <i>lbracket</i> = '[', dchar <i>rbracket</i> = ']', dchar <i>keyval</i> = ':', dchar <i>comma</i> = ',') if (isExactSomeString!Source &amp;&amp; isAssociativeArray!Target &amp;&amp; !is(Target == enum));
</dt>
<dd><div class="summary">Parses an associative array from a string given the left bracket (default <span class="d_inlinecode donthyphenate notranslate"> '['</span>), right bracket (default <span class="d_inlinecode donthyphenate notranslate">']'</span>), key-value separator (default <span class="d_inlinecode donthyphenate notranslate"> ':'</span>), and element seprator (by default <span class="d_inlinecode donthyphenate notranslate">','</span>).</div>

</dd>
<dt class="d_decl"><a name=".text"></a><div class="quickindex" id="quickindex.text"></div>string <a name="text"></a><span class="ddoc_psymbol">text</span>(T...)(T <i>args</i>);
<br><a name=".wtext"></a><div class="quickindex" id="quickindex.wtext"></div>wstring <a name="wtext"></a><span class="ddoc_psymbol">wtext</span>(T...)(T <i>args</i>);
<br><a name=".dtext"></a><div class="quickindex" id="quickindex.dtext"></div>dstring <a name="dtext"></a><span class="ddoc_psymbol">dtext</span>(T...)(T <i>args</i>);
</dt>
<dd><div class="summary">Convenience functions for converting any number and types of
 arguments into text (the three character widths).</div>

</dd>
<dt class="d_decl"><a name=".octal"></a><div class="quickindex" id="quickindex.octal"></div>@property int <a name="octal"></a><span class="ddoc_psymbol">octal</span>(string num)() if (octalFitsInInt!num &amp;&amp; !literalIsLong!num &amp;&amp; !literalIsUnsigned!num);
<br>@property long <a name="octal"></a><span class="ddoc_psymbol">octal</span>(string num)() if ((!octalFitsInInt!num || literalIsLong!num) &amp;&amp; !literalIsUnsigned!num);
<br>@property uint <a name="octal"></a><span class="ddoc_psymbol">octal</span>(string num)() if (octalFitsInInt!num &amp;&amp; !literalIsLong!num &amp;&amp; literalIsUnsigned!num);
<br>@property ulong <a name="octal"></a><span class="ddoc_psymbol">octal</span>(string num)() if ((!octalFitsInInt!num || literalIsLong!num) &amp;&amp; literalIsUnsigned!num);
<br>template <a name="octal"></a><span class="ddoc_psymbol">octal</span>(alias s) if (isIntegral!(typeof(s)))</dt>
<dd><div class="summary">The <span class="d_inlinecode donthyphenate notranslate"><a name="octal"></a><span class="ddoc_psymbol">octal</span></span> facility provides a means to declare a number in base 8.
Using <span class="d_inlinecode donthyphenate notranslate"><a name="octal"></a><span class="ddoc_psymbol">octal</span>!177</span> or <span class="d_inlinecode donthyphenate notranslate"><a name="octal"></a><span class="ddoc_psymbol">octal</span>!"177"</span> for 127 represented in <a name="octal"></a><span class="ddoc_psymbol">octal</span>
(same as 0177 in C).
</div>
<div class="description">The rules for strings are the usual for literals: If it can fit in an
<span class="d_inlinecode donthyphenate notranslate">int</span>, it is an <span class="d_inlinecode donthyphenate notranslate">int</span>. Otherwise, it is a <span class="d_inlinecode donthyphenate notranslate">long</span>. But, if the
user specifically asks for a <span class="d_inlinecode donthyphenate notranslate">long</span> with the <span class="d_inlinecode donthyphenate notranslate">L</span> suffix, always
give the <span class="d_inlinecode donthyphenate notranslate">long</span>. Give an unsigned iff it is asked for with the <span class="d_inlinecode donthyphenate notranslate">U</span> or <span class="d_inlinecode donthyphenate notranslate">u</span> suffix. Octals created from integers preserve the type
of the passed-in integral.

</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#parse"><span class="d_inlinecode donthyphenate notranslate">parse</span></a> for parsing <a name="octal"></a><span class="ddoc_psymbol">octal</span> strings at runtime.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// same as 0177
</span><span class="d_keyword">auto</span> x = <span class="d_psymbol">octal</span>!177;
<span class="d_comment">// octal is a compile-time device
</span><span class="d_keyword">enum</span> y = <span class="d_psymbol">octal</span>!160;
<span class="d_comment">// Create an unsigned octal
</span><span class="d_keyword">auto</span> z = <span class="d_psymbol">octal</span>!<span class="d_string">"1_000_000u"</span>;
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".emplace"></a><div class="quickindex" id="quickindex.emplace"></div>pure nothrow @safe T* <a name="emplace"></a><span class="ddoc_psymbol">emplace</span>(T)(T* <i>chunk</i>);
</dt>
<dd><div class="summary">Given a pointer <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span> to uninitialized memory (but already typed
as <span class="d_inlinecode donthyphenate notranslate">T</span>), constructs an object of non-<span class="d_inlinecode donthyphenate notranslate">class</span> type <span class="d_inlinecode donthyphenate notranslate">T</span> at that
address.
</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A pointer to the newly constructed object (which is the same
as <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span>).</div></div>

</dd>
<dt class="d_decl"><a name=".emplace.2"></a><div class="quickindex" id="quickindex.emplace.2"></div>T* <a name="emplace"></a><span class="ddoc_psymbol">emplace</span>(T, Args...)(T* <i>chunk</i>, auto ref Args <i>args</i>) if (!is(T == struct) &amp;&amp; Args.length == 1);
<br>T* <a name="emplace"></a><span class="ddoc_psymbol">emplace</span>(T, Args...)(T* <i>chunk</i>, auto ref Args <i>args</i>) if (is(T == struct));
</dt>
<dd><div class="summary">Given a pointer <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span> to uninitialized memory (but already typed
as a non-class type <span class="d_inlinecode donthyphenate notranslate">T</span>), constructs an object of type <span class="d_inlinecode donthyphenate notranslate">T</span> at
that address from arguments <span class="d_inlinecode donthyphenate notranslate"><i>args</i></span>.
</div>
<div class="description">This function can be <span class="d_inlinecode donthyphenate notranslate">@trusted</span> if the corresponding constructor of
<span class="d_inlinecode donthyphenate notranslate">T</span> is <span class="d_inlinecode donthyphenate notranslate">@safe</span>.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A pointer to the newly constructed object (which is the same
as <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span>).</div></div>

</dd>
<dt class="d_decl"><a name=".emplace.3"></a><div class="quickindex" id="quickindex.emplace.3"></div>T <a name="emplace"></a><span class="ddoc_psymbol">emplace</span>(T, Args...)(void[] <i>chunk</i>, auto ref Args <i>args</i>) if (is(T == class));
</dt>
<dd><div class="summary">Given a raw memory area <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span>, constructs an object of <span class="d_inlinecode donthyphenate notranslate">class</span>
type <span class="d_inlinecode donthyphenate notranslate">T</span> at that address. The constructor is passed the arguments
<span class="d_inlinecode donthyphenate notranslate">Args</span>. The <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span> must be as least as large as <span class="d_inlinecode donthyphenate notranslate">T</span> needs
and should have an alignment multiple of <span class="d_inlinecode donthyphenate notranslate">T</span>'s alignment. (The size
of a <span class="d_inlinecode donthyphenate notranslate">class</span> instance is obtained by using <span class="d_inlinecode donthyphenate notranslate">_traits(classInstanceSize, T)</span>).
</div>
<div class="description">This function can be <span class="d_inlinecode donthyphenate notranslate">@trusted</span> if the corresponding constructor of
<span class="d_inlinecode donthyphenate notranslate">T</span> is <span class="d_inlinecode donthyphenate notranslate">@safe</span>.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A pointer to the newly constructed object.</div></div>

</dd>
<dt class="d_decl"><a name=".emplace.4"></a><div class="quickindex" id="quickindex.emplace.4"></div>T* <a name="emplace"></a><span class="ddoc_psymbol">emplace</span>(T, Args...)(void[] <i>chunk</i>, auto ref Args <i>args</i>) if (!is(T == class));
</dt>
<dd><div class="summary">Given a raw memory area <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span>, constructs an object of non-<span class="d_inlinecode donthyphenate notranslate">class</span> type <span class="d_inlinecode donthyphenate notranslate">T</span> at that address. The constructor is passed the
arguments <span class="d_inlinecode donthyphenate notranslate"><i>args</i></span>, if any. The <span class="d_inlinecode donthyphenate notranslate"><i>chunk</i></span> must be as least as large
as <span class="d_inlinecode donthyphenate notranslate">T</span> needs and should have an alignment multiple of <span class="d_inlinecode donthyphenate notranslate">T</span>'s
alignment.
</div>
<div class="description">This function can be <span class="d_inlinecode donthyphenate notranslate">@trusted</span> if the corresponding constructor of
<span class="d_inlinecode donthyphenate notranslate">T</span> is <span class="d_inlinecode donthyphenate notranslate">@safe</span>.

</div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">A pointer to the newly constructed object.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> a, b;
}
<span class="d_keyword">auto</span> p = <span class="d_keyword">new</span> <span class="d_keyword">void</span>[S.sizeof];
S s;
s.a = 42;
s.b = 43;
<span class="d_keyword">auto</span> s1 = <span class="d_psymbol">emplace</span>!S(p, s);
<span class="d_keyword">assert</span>(s1.a == 42 &amp;&amp; s1.b == 43);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".unsigned"></a><div class="quickindex" id="quickindex.unsigned"></div>auto <a name="unsigned"></a><span class="ddoc_psymbol">unsigned</span>(T)(T <i>x</i>) if (isIntegral!T);
</dt>
<dd><div class="summary">Returns the corresponding unsigned value for <span class="d_inlinecode donthyphenate notranslate"><i>x</i></span> (e.g. if <span class="d_inlinecode donthyphenate notranslate"><i>x</i></span> has type
    <span class="d_inlinecode donthyphenate notranslate">int</span>, it returns <span class="d_inlinecode donthyphenate notranslate">cast(uint) <i>x</i></span>). The advantage compared to the cast
    is that you do not need to rewrite the cast if <span class="d_inlinecode donthyphenate notranslate"><i>x</i></span> later changes type
    (e.g from <span class="d_inlinecode donthyphenate notranslate">int</span> to <span class="d_inlinecode donthyphenate notranslate">long</span>).
</div>
<div class="description">Note that the result is always mutable even if the original type was const
    or immutable. In order to retain the constness, use <span class="libref"><a href="http://dlang.org/phobos/std_traits.html#Unsigned"><span class="d_inlinecode donthyphenate notranslate">std.traits.Unsigned</span></a></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">immutable</span> <span class="d_keyword">int</span> s = 42;
<span class="d_keyword">auto</span> u1 = <span class="d_psymbol">unsigned</span>(s); <span class="d_comment">//not qualified
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(u1) == <span class="d_keyword">uint</span>));
Unsigned!(<span class="d_keyword">typeof</span>(s)) u2 = <span class="d_psymbol">unsigned</span>(s); <span class="d_comment">//same qualification
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(u2) == <span class="d_keyword">immutable</span> <span class="d_keyword">uint</span>));
<span class="d_keyword">immutable</span> u3 = <span class="d_psymbol">unsigned</span>(s); <span class="d_comment">//explicitly qualified
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".signed"></a><div class="quickindex" id="quickindex.signed"></div>auto <a name="signed"></a><span class="ddoc_psymbol">signed</span>(T)(T <i>x</i>) if (isIntegral!T);
</dt>
<dd><div class="summary">Returns the corresponding signed value for <span class="d_inlinecode donthyphenate notranslate"><i>x</i></span> (e.g. if <span class="d_inlinecode donthyphenate notranslate"><i>x</i></span> has type
    <span class="d_inlinecode donthyphenate notranslate">uint</span>, it returns <span class="d_inlinecode donthyphenate notranslate">cast(int) <i>x</i></span>). The advantage compared to the cast
    is that you do not need to rewrite the cast if <span class="d_inlinecode donthyphenate notranslate"><i>x</i></span> later changes type
    (e.g from <span class="d_inlinecode donthyphenate notranslate">uint</span> to <span class="d_inlinecode donthyphenate notranslate">ulong</span>).
</div>
<div class="description">Note that the result is always mutable even if the original type was const
    or immutable. In order to retain the constness, use <span class="libref"><a href="http://dlang.org/phobos/std_traits.html#Signed"><span class="d_inlinecode donthyphenate notranslate">std.traits.Signed</span></a></span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">immutable</span> <span class="d_keyword">uint</span> u = 42;
<span class="d_keyword">auto</span> s1 = <span class="d_psymbol">signed</span>(u); <span class="d_comment">//not qualified
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(s1) == <span class="d_keyword">int</span>));
Signed!(<span class="d_keyword">typeof</span>(u)) s2 = <span class="d_psymbol">signed</span>(u); <span class="d_comment">//same qualification
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(s2) == <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>));
<span class="d_keyword">immutable</span> s3 = <span class="d_psymbol">signed</span>(u); <span class="d_comment">//explicitly qualified
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".castFrom"></a><div class="quickindex" id="quickindex.castFrom"></div>template <a name="castFrom"></a><span class="ddoc_psymbol">castFrom</span>(From)</dt>
<dd><div class="summary">A wrapper on top of the built-in cast operator that allows one to restrict
    casting of the original type of the value.
</div>
<div class="description">A common issue with using a raw cast is that it may silently continue to
    compile even if the value's type has changed during refactoring,
    which breaks the initial assumption about the cast.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">From</td>
<td class="param_desc">The type to cast from. The programmer must ensure it is legal
                to make this cast.</td></tr>
</table></div></div>

<dl><dt class="d_decl"><a name=".castFrom.to"></a><div class="quickindex" id="quickindex.castFrom.to"></div>ref @system auto <a name="to"></a><span class="ddoc_psymbol">to</span>(To, T)(auto ref T <i>value</i>);
</dt>
<dd><div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">To</td>
<td class="param_desc">The type to cast to.</td></tr>
<tr class="param"><td class="param_id">T <i>value</i></td>
<td class="param_desc">The <i>value</i> to cast. It must be of type <span class="d_inlinecode donthyphenate notranslate">From</span>,
                    otherwise a compile-time error is emitted.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">the <i>value</i> after the cast, returned by reference if possible.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// Regular cast, which has been verified to be legal by the programmer:
</span>{
    <span class="d_keyword">long</span> x;
    <span class="d_keyword">auto</span> y = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) x;
}

<span class="d_comment">// However this will still compile if 'x' is changed to be a pointer:
</span>{
    <span class="d_keyword">long</span>* x;
    <span class="d_keyword">auto</span> y = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) x;
}

<span class="d_comment">// castFrom provides a more reliable alternative to casting:
</span>{
    <span class="d_keyword">long</span> x;
    <span class="d_keyword">auto</span> y = castFrom!<span class="d_keyword">long</span>.<span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(x);
}

<span class="d_comment">// Changing the type of 'x' will now issue a compiler error,
</span><span class="d_comment">// allowing bad casts to be caught before it's too late:
</span>{
    <span class="d_keyword">long</span>* x;
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span> (
        !<span class="d_keyword">__traits</span>(compiles, castFrom!<span class="d_keyword">long</span>.<span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(x))
    );

    <span class="d_comment">// if cast is still needed, must be changed to:
</span>    <span class="d_keyword">auto</span> y = castFrom!(<span class="d_keyword">long</span>*).<span class="d_psymbol">to</span>!<span class="d_keyword">int</span>(x);
}
</pre>
</div></div>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".hexString"></a><div class="quickindex" id="quickindex.hexString"></div>template <a name="hexString"></a><span class="ddoc_psymbol">hexString</span>(string hexData) if (hexData.isHexLiteral)<br>template <a name="hexString"></a><span class="ddoc_psymbol">hexString</span>(wstring hexData) if (hexData.isHexLiteral)<br>template <a name="hexString"></a><span class="ddoc_psymbol">hexString</span>(dstring hexData) if (hexData.isHexLiteral)</dt>
<dd><div class="summary">Converts a hex literal to a string at compile time.
</div>
<div class="description">Takes a string made of hexadecimal digits and returns
the matching string by converting each pair of digits to a character.
The input string can also include white characters, which can be used
to keep the literal string readable in the source code.
<p></p>

The function is intended to replace the hexadecimal literal strings
starting with <span class="d_inlinecode donthyphenate notranslate">'x'</span>, which could be removed to simplify the core language.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">hexData</td>
<td class="param_desc">string to be converted.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">a <span class="d_inlinecode donthyphenate notranslate">string</span>, a <span class="d_inlinecode donthyphenate notranslate">wstring</span> or a <span class="d_inlinecode donthyphenate notranslate">dstring</span>, according to the type of hexData.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// conversion at compile time
</span><span class="d_keyword">auto</span> string1 = <span class="d_psymbol">hexString</span>!<span class="d_string">"304A314B"</span>;
<span class="d_keyword">assert</span>(string1 == <span class="d_string">"0J1K"</span>);
<span class="d_keyword">auto</span> string2 = <span class="d_psymbol">hexString</span>!<span class="d_string">"304A314B"w</span>;
<span class="d_keyword">assert</span>(string2 == <span class="d_string">"0J1K"w</span>);
<span class="d_keyword">auto</span> string3 = <span class="d_psymbol">hexString</span>!<span class="d_string">"304A314B"d</span>;
<span class="d_keyword">assert</span>(string3 == <span class="d_string">"0J1K"d</span>);
</pre>
</div></div>
</dd>
</dl>

</div>
<div id="copyright">Copyright Digital Mars 2007-.

 | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Tue Jul  4 02:26:58 2017
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('<script src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>

<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(listanchors);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
</body>
</html>

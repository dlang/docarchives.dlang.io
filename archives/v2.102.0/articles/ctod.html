
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Programming in D for C Programmers - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Programming in D for C Programmers' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Google Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    
    <div class="head">        <h2>Articles</h2>
        <p class="Articles, ../articles/index.html, overview">            <a href="../articles/index.html">overview</a></p>
    </div>
    <ul><li><a href='        ../articles/faq.html'>FAQ</a></li><li><a href='        ../articles/const-faq.html'>const(FAQ)</a></li><li><a href='        ../articles/d-floating-point.html'>Floating Point</a></li><li><a href='        ../articles/warnings.html'>Warnings</a></li><li><a href='        ../articles/rationale.html'>Rationale</a></li><li><a href='        ../articles/builtin.html'>Builtin Rationale</a></li><li><a href='        ../articles/ctod.html'>C to D</a></li><li><a href='        ../articles/cpptod.html'>C++ to D</a></li><li><a href='        ../articles/pretod.html'>C Preprocessor vs D</a></li><li><a href='        ../articles/code_coverage.html'>Code coverage analysis</a></li><li><a href='        ../articles/exception-safe.html'>Exception Safety</a></li><li><a href='        ../articles/hijack.html'>Hijacking</a></li><li><a href='        ../articles/intro-to-datetime.html'>Introduction to std.datetime</a></li><li><a href='        ../articles/lazy-evaluation.html'>Lazy Evaluation</a></li><li><a href='        ../articles/migrate-to-shared.html'>Migrating to Shared</a></li><li><a href='        ../articles/mixin.html'>String Mixins</a></li><li><a href='        ../articles/regular-expression.html'>Regular Expressions</a></li><li><a href='        ../articles/safed.html'>SafeD</a></li><li><a href='        ../articles/templates-revisited.html'>Templates Revisited</a></li><li><a href='        ../articles/ctarguments.html'>Compile-time Sequences</a></li><li><a href='        ../articles/variadic-function-templates.html'>Variadic Templates</a></li><li><a href='        ../articles/d-array-article.html'>D Slices</a></li><li><a href='        ../articles/cppcontracts.html'>D's Contract Programming</a></li><li><a href='        ../articles/template-comparison.html'>Template Comparison</a></li><li><a href='        ../articles/dll-linux.html'>Writing Shared Libraries
    </a></li></ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BProgramming in D for C Programmers%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/articles/ctod.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Programming in D for C Programmers</h1>
        
        


<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#sizeof">Getting the Size of a Type</a></li>
    <li><a href="#maxmin">Get the max and min values of a type</a></li>
    <li><a href="#types">Primitive Types</a></li>
    <li><a href="#floating">Special Floating Point Values</a></li>
    <li><a href="#modulus">Remainder after division of floating point numbers</a></li>
    <li><a href="#nans">Dealing with NANs in floating point compares</a></li>
    <li><a href="#assert">Asserts are a necessary part of any good defensive coding strategy</a></li>
    <li><a href="#arrayinit">Initializing all elements of an array</a></li>
    <li><a href="#arrayloop">Looping through an array</a></li>
    <li><a href="#arraycreate">Creating an array of variable size</a></li>
    <li><a href="#strcat">String Concatenation</a></li>
    <li><a href="#printf">Formatted printing</a></li>
    <li><a href="#forwardfunc">Forward referencing functions</a></li>
    <li><a href="#funcvoid">Functions that have no arguments</a></li>
    <li><a href="#labeledbreak">Labeled break and continue statements</a></li>
    <li><a href="#goto">Goto Statements</a></li>
    <li><a href="#tagspace">Struct tag name space</a></li>
    <li><a href="#stringlookup">Looking up strings</a></li>
    <li><a href="#align">Setting struct member alignment</a></li>
    <li><a href="#anonymous">Anonymous Structs and Unions</a></li>
    <li><a href="#declaring">Declaring struct types and variables</a></li>
    <li><a href="#fieldoffset">Getting the offset of a struct member</a></li>
    <li><a href="#unioninit">Union Initializations</a></li>
    <li><a href="#structinit">Struct Initializations</a></li>
    <li><a href="#arrayinit2">Array Initializations</a></li>
    <li><a href="#stringlit">Escaped String Literals</a></li>
    <li><a href="#ascii">ASCII versus Wide Characters</a></li>
    <li><a href="#arrayenum">Arrays that parallel an enum</a></li>
    <li><a href="#typedefs">Creating a new type with typedef</a></li>
    <li><a href="#structcmp">Comparing structs</a></li>
    <li><a href="#stringcmp">Comparing strings</a></li>
    <li><a href="#sort">Sorting arrays</a></li>
    <li><a href="#strings">String literals</a></li>
    <li><a href="#traversal">Data Structure Traversal</a></li>
    <li><a href="#ushr">Unsigned Right Shift</a></li>
    <li><a href="#closures">Dynamic Closures</a></li>
    <li><a href="#variadic">Variadic Function Parameters</a></li>
</ol>
</div>





<p>Every experienced C programmer accumulates a series of idioms and techniques
which become second nature. Sometimes, when learning a new language, those
idioms can be so comfortable it's hard to see how to do the equivalent in the
new language. So here's a collection of common C techniques, and how to do the
corresponding task in D.
</p>

<p>Since C does not have object-oriented features, there's a separate section
for object-oriented issues
<a href="cpptod.html">Programming in D for C++ Programmers</a>.
</p>

<p>The C preprocessor is covered in
<a href="pretod.html">The C Preprocessor vs D</a>.
</p>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="sizeof" href="#sizeof">Getting the Size of a Type</a></h2>

<h4>The C Way</h4>

<pre class="ccode notranslate">sizeof(int)
sizeof(char *)
sizeof(double)
sizeof(struct Foo)
</pre>

<h4>The D Way</h4>

<p>Use the <span class="d_inlinecode donthyphenate notranslate">sizeof</span> property:</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span>.sizeof
(<span class="d_keyword">char</span> *).sizeof
<span class="d_keyword">double</span>.sizeof
Foo.sizeof
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="maxmin" href="#maxmin">Get the max and min values of a type</a></h2>

<h4>The C Way</h4>

<pre class="ccode notranslate">#include &lt;limits.h&gt;
#include &lt;math.h&gt;

CHAR_MAX
CHAR_MIN
ULONG_MAX
DBL_MIN
</pre>

<h4>The D Way</h4>

<pre class="d_code notranslate"><span class="d_keyword">char</span>.max
<span class="d_keyword">char</span>.min
<span class="d_keyword">ulong</span>.max
<span class="d_keyword">double</span>.min
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="types" href="#types">Primitive Types</a></h2>

<h4>C to D types</h4>

<pre class="ccode notranslate">bool               =&gt;        bool
char               =&gt;        char
signed char        =&gt;        byte
unsigned char      =&gt;        ubyte
short              =&gt;        short
unsigned short     =&gt;        ushort
wchar_t            =&gt;        core.stdc.stddef.wchar_t
int                =&gt;        int
unsigned           =&gt;        uint
long               =&gt;        core.stdc.config.c_long
unsigned long      =&gt;        core.stdc.config.c_ulong
long long          =&gt;        long
unsigned long long =&gt;        ulong
float              =&gt;        float
double             =&gt;        double
long double        =&gt;        real
_Imaginary long double =&gt;    ireal
_Complex long double   =&gt;    creal
</pre>
<p>       Although <span class="d_inlinecode donthyphenate notranslate">char</span> is an unsigned 8-bit type, and
       <span class="d_inlinecode donthyphenate notranslate">wchar</span> is an unsigned 16-bit type, they have their own separate types
       in order to aid overloading and type safety.
</p>
<p>       Ints and unsigneds in C are of varying size; not so in D.</p>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="floating" href="#floating">Special Floating Point Values</a></h2>

<h4>The C Way</h4>

<pre class="ccode notranslate">#include &lt;fp.h&gt;

NAN
INFINITY

#include &lt;float.h&gt;

DBL_DIG
DBL_EPSILON
DBL_MANT_DIG
DBL_MAX_10_EXP
DBL_MAX_EXP
DBL_MIN_10_EXP
DBL_MIN_EXP
</pre>

<h4>The D Way</h4>

<pre class="d_code notranslate"><span class="d_keyword">double</span>.nan
<span class="d_keyword">double</span>.infinity
<span class="d_keyword">double</span>.dig
<span class="d_keyword">double</span>.epsilon
<span class="d_keyword">double</span>.mant_dig
<span class="d_keyword">double</span>.max_10_exp
<span class="d_keyword">double</span>.max_exp
<span class="d_keyword">double</span>.min_10_exp
<span class="d_keyword">double</span>.min_exp
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="modulus" href="#modulus">Remainder after division of floating point numbers</a></h2>

<h4>The C Way</h4>

<pre class="ccode notranslate">#include &lt;math.h&gt;

float f = fmodf(x,y);
double d = fmod(x,y);
long double r = fmodl(x,y);
</pre>

<h4>The D Way</h4>

D supports the remainder (<span class="d_inlinecode donthyphenate notranslate">%</span>) operator on floating point operands:

<pre class="d_code notranslate"><span class="d_keyword">float</span> f = x % y;
<span class="d_keyword">double</span> d = x % y;
<span class="d_keyword">real</span> r = x % y;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="nans" href="#nans">Dealing with NANs in floating point compares</a></h2>

<h4>The C Way</h4>

       C doesn't define what happens if an operand to a compare
       is <span class="d_inlinecode donthyphenate notranslate">NAN</span>, and few C compilers check for it (the Digital Mars
       C compiler is an exception, DM's compilers do check for <span class="d_inlinecode donthyphenate notranslate">NAN</span> operands).

<pre class="ccode notranslate">#include &lt;math.h&gt;

if (isnan(x) || isnan(y))
    result = false;
else
    result = (x &lt; y);
</pre>

<h4>The D Way</h4>

       D offers a full complement of comparisons and operators
       that work with NAN arguments.

<pre class="d_code notranslate">result = (x &lt; y);        <span class="d_comment">// false if x or y is nan
</span></pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="assert" href="#assert">Asserts are a necessary part of any good defensive coding strategy</a></h2>

<h4>The C Way</h4>
<p>C doesn't directly support assert in the language, but does define a macro
in the standard library header assert.h. That macro writes a diagnostic message
on stderr when the condition given as parameter is not true. The message will
use __FILE__, __LINE__ and __func__ (C99) to localize the failing assertion.</p>

<pre class="ccode notranslate">#include &lt;assert.h&gt;

assert(e == 0);
</pre>

<h4>The D Way</h4>

D simply builds assert into the language:

<pre class="d_code notranslate"><span class="d_keyword">assert</span>(e == 0);
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="arrayinit" href="#arrayinit">Initializing all elements of an array</a></h2>

<h4>The C Way</h4>

<pre class="ccode notranslate">#define ARRAY_LENGTH        17
int array[ARRAY_LENGTH];
for (i = 0; i &lt; ARRAY_LENGTH; i++)
    array[i] = value;
</pre>

<h4>The D Way</h4>

<pre class="d_code notranslate"><span class="d_keyword">int</span>[17] array;
array[] = value;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="arrayloop" href="#arrayloop">Looping through an array</a></h2>

<h4>The C Way</h4>
<p>       The array length is defined separately, or a clumsy and error prone
       <span class="d_inlinecode donthyphenate notranslate">sizeof()</span> expression is used to get the length.</p>

<pre class="ccode notranslate">#define ARRAY_LENGTH        17
int array[ARRAY_LENGTH];
for (size_t i = 0; i &lt; ARRAY_LENGTH; i++)
    func(array[i]);
</pre>

or:

<pre class="ccode notranslate">int array[17];
for (size_t i = 0; i &lt; sizeof(array) / sizeof(array[0]); i++)
    func(array[i]);
</pre>

<h4>The D Way</h4>

The length of an array is accessible through the <span class="d_inlinecode donthyphenate notranslate">length</span> property.

<pre class="d_code notranslate"><span class="d_keyword">int</span>[17] array;
<span class="d_keyword">foreach</span> (i; 0 .. array.length)
     func(array[i]);
</pre>

or even better (for value access):

<pre class="d_code notranslate"><span class="d_keyword">int</span>[17] array;
<span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> value; array)
    func(value);
</pre>

In D, the element type can be inferred even without using an explicit type qualifier:

<pre class="d_code notranslate"><span class="d_keyword">int</span>[17] array;
<span class="d_keyword">foreach</span> (value; array)
    func(value);
</pre>

or through the <span class="d_inlinecode donthyphenate notranslate">ref</span> keyword (for reference access):

<pre class="d_code notranslate"><span class="d_keyword">int</span>[17] array;
<span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> value; array)
    value += 42;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="arraycreate" href="#arraycreate">Creating an array of variable size</a></h2>

<h4>The C Way</h4>

       C cannot do this with arrays. It is necessary to create a separate
       variable for the length, and then explicitly manage the size of
       the array:

<pre class="ccode notranslate">#include &lt;stdlib.h&gt;

int array_length;
int *array;
int *newarray;

newarray = realloc(array, (array_length + 1) * sizeof(int));
if (!newarray)
    error("out of memory");
array = newarray;
array[array_length++] = x;
</pre>

<h4>The D Way</h4>

       D supports dynamic arrays, which can be easily resized. D supports
       all the requisite memory management.

<pre class="d_code notranslate"><span class="d_keyword">int</span>[] array;
<span class="d_keyword">int</span> x;
array.length = array.length + 1;
array[array.length - 1] = x;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="strcat" href="#strcat">String Concatenation</a></h2>

<h4>The C Way</h4>

       There are several difficulties to be resolved, like
       when can storage be freed, dealing with null pointers,
       finding the length of the strings, and memory allocation:

<pre class="ccode notranslate">#include &lt;string.h&gt;

char *s1;
char *s2;
char *s;

// Concatenate s1 and s2, and put result in s
s = malloc((s1 ? strlen(s1) : 0) +
           (s2 ? strlen(s2) : 0) + 1);
if (!s)
    error("out of memory");
if (s1)
    strcpy(s, s1);
else
    *s = 0;
if (s2)
    strcpy(s + strlen(s), s2);

// Append "hello" to s
char hello[] = "hello";
size_t lens = s ? strlen(s) : 0;
char *news = realloc(s, lens + sizeof(hello) + 1);
if (!news)
    error("out of memory");
s = news;
memcpy(s + lens, hello, sizeof(hello));
</pre>

<h4>The D Way</h4>

       D overloads the operators <span class="d_inlinecode donthyphenate notranslate">~</span> and <span class="d_inlinecode donthyphenate notranslate">~=</span> for char and wchar arrays to mean
       concatenate and append, respectively:

<pre class="d_code notranslate">string s1;
string s2;
string s;

s = s1 ~ s2;
s ~= <span class="d_string">"hello"</span>;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="printf" href="#printf">Formatted printing</a></h2>

<h4>The C Way</h4>

       printf() is the general purpose formatted print routine:

<pre class="ccode notranslate">#include &lt;stdio.h&gt;

printf("Calling all cars %d times!\n", ntimes);
</pre>

<h4>The D Way</h4>

       What can we say? printf() rules:

<pre class="d_code notranslate">printf(<span class="d_string">"Calling all cars %d times!\n"</span>, ntimes);
</pre>

        writefln() improves on printf() by being type-aware and type-safe:

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

writefln(<span class="d_string">"Calling all cars %s times!"</span>, ntimes);
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="forwardfunc" href="#forwardfunc">Forward referencing functions</a></h2>

<h4>The C Way</h4>

       Functions cannot be forward referenced. Hence, to call a function
       not yet encountered in the source file, it is necessary to insert
       a function declaration lexically preceding the call.

<pre class="ccode notranslate">void forwardfunc();

void myfunc()
{
    forwardfunc();
}

void forwardfunc()
{
    ...
}
</pre>

<h4>The D Way</h4>

        The program is looked at as a whole, and so not only is it not
        necessary to code forward declarations, it is not even allowed!
        D avoids the tedium and errors associated with writing forward
        referenced function declarations twice.
        Functions can be defined in any order.

<pre class="d_code notranslate"><span class="d_keyword">void</span> myfunc()
{
    forwardfunc();
}

<span class="d_keyword">void</span> forwardfunc()
{
    ...
}
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="funcvoid" href="#funcvoid">Functions that have no arguments</a></h2>

<h4>The C Way</h4>

<pre class="ccode notranslate">void foo(void);
</pre>

<h4>The D Way</h4>

       D is a strongly typed language, so there is no need to explicitly
       say a function takes no arguments, just don't declare it as having
       arguments.

<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    ...
}
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="labeledbreak" href="#labeledbreak">Labeled break and continue statements</a></h2>

<h4>The C Way</h4>

       Break and continue statements only apply to the innermost nested loop or
       switch, so a multilevel break must use a goto:

<pre class="ccode notranslate">    for (i = 0; i &lt; 10; i++)
    {
        for (j = 0; j &lt; 10; j++)
        {
            if (j == 3)
                goto Louter;
            if (j == 4)
                goto L2;
        }
        L2:
        ;
    }

Louter:
    ;
</pre>

<h4>The D Way</h4>

       Break and continue statements can be followed by a label. The label
       is the label for an enclosing loop or switch, and the break applies
       to that loop.

<pre class="d_code notranslate">Louter:
    <span class="d_keyword">for</span> (i = 0; i &lt; 10; i++)
    {
        <span class="d_keyword">for</span> (j = 0; j &lt; 10; j++)
        {
            <span class="d_keyword">if</span> (j == 3)
                <span class="d_keyword">break</span> Louter;
            <span class="d_keyword">if</span> (j == 4)
                <span class="d_keyword">continue</span> Louter;
        }
    }
    <span class="d_comment">// break Louter goes here
</span></pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="goto" href="#goto">Goto Statements</a></h2>

<h4>The C Way</h4>

       The much maligned goto statement is a staple for professional C coders.
       It's
       necessary to make up for sometimes inadequate control flow statements.

<h4>The D Way</h4>

       Many C-way goto statements can be eliminated with the D feature of
       labeled
       break and continue statements. But D is a practical language for
       practical
       programmers who know when the rules need to be broken. So of course D
       supports goto statements.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="tagspace" href="#tagspace">Struct tag name space</a></h2>

<h4>The C Way</h4>

       It's annoying to have to use the <span class="d_inlinecode donthyphenate notranslate">struct</span> keyword every time a type is specified,
       so a common idiom is to use:

<pre class="ccode notranslate">typedef struct ABC { ... } ABC;
</pre>

<h4>The D Way</h4>

       Struct tag names are not in a separate name space, they are in the same name
       space as ordinary names. Hence:

<pre class="d_code notranslate"><span class="d_keyword">struct</span> ABC { ... }
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="stringlookup" href="#stringlookup">Looking up strings</a></h2>

<h4>The C Way</h4>

       Given a string, compare the string against a list of possible
       values and take action based on which one it is. A typical use
       for this might be command line argument processing.

<pre class="ccode notranslate">#include &lt;string.h&gt;
void dostring(char *s)
{
    enum Strings { Hello, Goodbye, Maybe, Max };
    static char *table[] = { [Hello]  ="hello",
                             [Goodbye]="goodbye",
                             [Maybe]  ="maybe" };
    int i;

    for (i = 0; i &lt; Max; i++)
    {
        if (strcmp(s, table[i]) == 0)
            break;
    }
    switch (i)
    {
        case Hello:   ...
        case Goodbye: ...
        case Maybe:   ...
        default:      ...
    }
}
</pre>

       The problem with this is trying to maintain 3 parallel data
       structures, the enum, the table, and the switch cases. If there
       are a lot of values, the connection between the 3 may not be so
       obvious when doing maintenance, and so the situation is ripe for
       bugs. Designated initializers as were introduced with C99 allow
       to link correctly 2 of the 3 data structures, but at the cost of
       a lot of typing.

       Additionally, if the number of values becomes large, a binary or
       hash lookup will yield a considerable performance increase over
       a simple linear search. But coding these can be time consuming,
       and they need to be debugged. It's typical that such just never
       gets done.

<h4>The D Way</h4>

       D extends the concept of switch statements to be able to handle
       strings as well as numbers. Then, the way to code the string
       lookup becomes straightforward:

<pre class="d_code notranslate"><span class="d_keyword">void</span> dostring(string s)
{
    <span class="d_keyword">switch</span> (s)
    {
        <span class="d_keyword">case</span> <span class="d_string">"hello"</span>:   ...
        <span class="d_keyword">case</span> <span class="d_string">"goodbye"</span>: ...
        <span class="d_keyword">case</span> <span class="d_string">"maybe"</span>:   ...
        <span class="d_keyword">default</span>:        ...
    }
}
</pre>

       Adding new cases becomes easy. The compiler can be relied on
       to generate a fast lookup scheme for it, eliminating the bugs
       and time required in hand-coding one.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="align" href="#align">Setting struct member alignment</a></h2>

<h4>The C Way</h4>

       It's done through a command line switch which affects the entire
       program, and woe results if any modules or libraries didn't get
       recompiled. To address this, <span class="d_inlinecode donthyphenate notranslate">#pragma</span>s are used:

<pre class="ccode notranslate">#pragma pack(1)
struct ABC
{
    ...
};
#pragma pack()
</pre>

       But <span class="d_inlinecode donthyphenate notranslate">#pragma</span>s are nonportable both in theory and in practice from
       compiler to compiler.

<h4>The D Way</h4>

        <p>D has a syntax for setting the alignment that is common
        to all D compilers. The actual alignment done is compatible
        with the companion C compiler's alignment, for ABI compatibility.
        To match a particular layout across architectures, use
        <span class="d_inlinecode donthyphenate notranslate">align(1)</span> and manually specify it.
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> ABC
{
    <span class="d_keyword">int</span> z;              <span class="d_comment">// z is aligned to the default
</span>
    <span class="d_keyword">align</span> (1) <span class="d_keyword">int</span> x;    <span class="d_comment">// x is byte aligned
</span>    <span class="d_keyword">align</span> (4)
    {
        ...             <span class="d_comment">// declarations in {} are 32-bit aligned
</span>    }
    <span class="d_keyword">align</span> (2):          <span class="d_comment">// switch to 16-bit alignment from here on
</span>
    <span class="d_keyword">int</span> y;              <span class="d_comment">// y is 16-bit aligned
</span>}
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="anonymous" href="#anonymous">Anonymous Structs and Unions</a></h2>

Sometimes, it's nice to control the layout of a struct with nested structs and unions.

<h4>The C Way</h4>

       Before C11 C didn't allow for anonymous structs or unions, which meant that
       dummy member names were necessary:

<pre class="ccode notranslate">struct Foo
{
    int i;
    union
    {
        struct { int x; long y; } abc;
        char *p;
    } bar;
};

#define x bar.abc.x
#define y bar.abc.y
#define p bar.p

struct Foo f;

f.i;
f.x;
f.y;
f.p;
</pre>

       Not only is it clumsy, but using macros means a symbolic debugger won't understand
       what is being done, and the macros have global scope instead of struct scope.

<h4>The D Way</h4>

       Anonymous structs and unions are used to control the layout in a
       more natural manner:

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
    <span class="d_keyword">int</span> i;
    <span class="d_keyword">union</span>
    {
        <span class="d_keyword">struct</span> { <span class="d_keyword">int</span> x; <span class="d_keyword">long</span> y; }
        <span class="d_keyword">char</span>* p;
    }
}

Foo f;

f.i;
f.x;
f.y;
f.p;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="declaring" href="#declaring">Declaring struct types and variables</a></h2>

<h4>The C Way</h4>

        <p>Is to do it in one statement ending with a semicolon:</p>

<pre class="ccode notranslate">struct Foo { int x; int y; } foo;
</pre>

        <p>Or to separate the two:</p>

<pre class="ccode notranslate">struct Foo { int x; int y; };   // note terminating ;
struct Foo foo;
</pre>

<h4>The D Way</h4>

        <p>Struct definitions and declarations can't be done in the same
        statement:
        </p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo { <span class="d_keyword">int</span> x; <span class="d_keyword">int</span> y; }    <span class="d_comment">// note there is no terminating ;
</span>Foo foo;
</pre>

        <p>which means that the terminating ; can be dispensed with,
        eliminating the confusing difference between struct {} and function
        block {} in how semicolons are used.
        </p>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="fieldoffset" href="#fieldoffset">Getting the offset of a struct member</a></h2>

<h4>The C Way</h4>

       Naturally, another macro is used:

<pre class="ccode notranslate">#include &lt;stddef&gt;
struct Foo { int x; int y; };

off = offsetof(Foo, y);
</pre>

<h4>The D Way</h4>

       An offset is just another property:

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo { <span class="d_keyword">int</span> x; <span class="d_keyword">int</span> y; }

off = Foo.y.offsetof;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="unioninit" href="#unioninit">Union Initializations</a></h2>

<h4>The C Way</h4>

       Unions are initialized using the "first member" rule:

<pre class="ccode notranslate">union U { int a; long b; };
union U x = { 5 };                // initialize member 'a' to 5
union U y = { .b = 42l };         // initialize member 'b' to 42 (C99)

</pre>

       Adding union members or rearranging them can have disastrous consequences
       for any initializers. Designated initializers in C99 fix that issue.

<h4>The D Way</h4>

       In D, which member is being initialized is mentioned explicitly:

<pre class="d_code notranslate"><span class="d_keyword">union</span> U { <span class="d_keyword">int</span> a; <span class="d_keyword">long</span> b; }
U x = { a:5 };
</pre>

       avoiding the confusion and maintenance problems.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="structinit" href="#structinit">Struct Initializations</a></h2>

<h4>The C Way</h4>

       Members are initialized by their position within the { }s:

<pre class="ccode notranslate">struct S { int a; int b; };
struct S x = { 5, 3 };
struct S y = { .b=3, .a=5  };   /* C99 */
</pre>

       This isn't much of a problem with small structs, but when there
       are numerous members, it becomes tedious to get the initializers
       carefully lined up with the field declarations. Then, if members are
       added or rearranged, all the initializations have to be found and
       modified appropriately. This is a minefield for bugs. Designated
       initializers in C99 fix that issue.

<h4>The D Way</h4>

       Member initialization can be done explicitly:

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; <span class="d_keyword">int</span> b; }
S x = { b:3, a:5 };
</pre>

       The meaning is clear, and there no longer is a positional dependence.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="arrayinit2" href="#arrayinit2">Array Initializations</a></h2>

<h4>The C Way</h4>

       C initializes arrays by positional dependence. C99 fixes the issue:
<pre class="ccode notranslate">int a[3] = { 3,2,1 };
int a[3] = { [2]=1, [0]=3, [1]=2 };  /* C99 designated initializer */
int a[3] = { [2]=1, [0]=3, 2 };      /* C99 designated initializer */
</pre>
       Nested arrays may or may not have the { }:
<pre class="ccode notranslate">int b[3][2] = { 2,3, {6,5}, 3,4 };
</pre>

<h4>The D Way</h4>

       D does it by positional dependence too, but an index can be used as well.
       The D syntax is lighter than C99 designated initializers.
       The following all produce the same result:

<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] a = [ 3, 2, 0 ];
<span class="d_keyword">int</span>[3] a = [ 3, 2 ];            <span class="d_comment">// unsupplied initializers are 0, just like in C
</span><span class="d_keyword">int</span>[3] a = [ 2:0, 0:3, 1:2 ];
<span class="d_keyword">int</span>[3] a = [ 2:0, 0:3, 2 ];     <span class="d_comment">// if not supplied, the index is the
</span>                                <span class="d_comment">// previous one plus one.
</span></pre>

        This can be handy if the array will be indexed by an enum, and the order of
       enums may be changed or added to:

<pre class="d_code notranslate"><span class="d_keyword">enum</span> color { black, red, green }
<span class="d_keyword">int</span>[3] c = [ black:3, green:2, red:5 ];
</pre>

        Nested array initializations must be explicit and consistent with the
        array types:

<pre class="d_code notranslate"><span class="d_keyword">int</span>[2][3] b = [ [2,3], [6,5], [3,4] ];

<span class="d_keyword">int</span>[2][3] b = [[2,6,3],[3,5,4]];            <span class="d_comment">// error
</span></pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="stringlit" href="#stringlit">Escaped String Literals</a></h2>

<h4>The C Way</h4>

       C has problems with the DOS file system because a \ is an escape in a string.
       To specifiy the file c:\root\file.c you would use:
<pre class="ccode notranslate">char file[] = "c:\\root\\file.c";
</pre>
This gets even more unpleasant with regular expressions.
Consider the escape sequence to match a quoted string:
<pre class="ccode notranslate">/"[^\\]*(\\.[^\\]*)*"/
</pre>
<p>In C, this horror is expressed as:</p>
<pre class="ccode notranslate">char quoteString[] = "\"[^\\\\]*(\\\\.[^\\\\]*)*\"";
</pre>
<h4>The D Way</h4>

    D has both C-style string literals which can use escaping,
    and WYSIWYG (what you see is what you get) raw strings,
    usable with the <span class="d_inlinecode donthyphenate notranslate">`foo`</span> and <span class="d_inlinecode donthyphenate notranslate">r"bar"</span> syntax:

<pre class="d_code notranslate">string file = <span class="d_string">r"c:\root\file.c"</span>;  <span class="d_comment">// c:\root\file.c
</span>string quotedString = <span class="d_string">`"[^\\]*(\\.[^\\]*)*"`</span>;  <span class="d_comment">// "[^\\]*(\\.[^\\]*)*"
</span></pre>

       The famous hello world string becomes:

<pre class="d_code notranslate">string hello = <span class="d_string">"hello world\n"</span>;
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="ascii" href="#ascii">ASCII versus Wide Characters</a></h2>

<p>Modern programming requires that wchar strings be supported in an easy way, for internationalization of the programs.</p>

<h4>The C Way</h4>

       C uses the wchar_t and the L prefix on strings:
<pre class="ccode notranslate">#include &lt;wchar.h&gt;
char foo_ascii[] = "hello";
wchar_t foo_wchar[] = L"hello";
</pre>
Things get worse if code is written to be both ascii and wchar compatible.
A macro is used to switch strings from ascii to wchar:
<pre class="ccode notranslate">#include &lt;tchar.h&gt;
tchar string[] = TEXT("hello");
</pre>
    Furthermore, in practice <span class="d_inlinecode donthyphenate notranslate">wchar_t</span> is not usable in portable code as its size
    is implementation dependent. On POSIX conforming machines it generally
    represents an UTF-32 codeunit, on Windows an UTF-16 code unit. C11 introduced
    C++11 types char16_t and char32_t to overcome this issue.

<h4>The D Way</h4>

    The type of a string is determined by semantic analysis, so there is no need
    to wrap strings in a macro call. Alternatively, if type inference is used, the
    string can have a <span class="d_inlinecode donthyphenate notranslate">c</span>, <span class="d_inlinecode donthyphenate notranslate">w</span> or <span class="d_inlinecode donthyphenate notranslate">d</span> suffix, representing UTF-8,
    UTF-16 and UTF-32 encoding, respectively. If no suffix is used the type is
    inferred to be a UTF-8 string:
<pre class="d_code notranslate">string  utf8  = <span class="d_string">"hello"</span>;     <span class="d_comment">// UTF-8 string
</span>wstring utf16 = <span class="d_string">"hello"</span>;     <span class="d_comment">// UTF-16 string
</span>dstring utf32 = <span class="d_string">"hello"</span>;     <span class="d_comment">// UTF-32 string
</span>
<span class="d_keyword">auto</span> str    = <span class="d_string">"hello"</span>;       <span class="d_comment">// UTF-8 string
</span><span class="d_keyword">auto</span> _utf8  = <span class="d_string">"hello"c</span>;      <span class="d_comment">// UTF-8 string
</span><span class="d_keyword">auto</span> _utf16 = <span class="d_string">"hello"w</span>;      <span class="d_comment">// UTF-16 string
</span><span class="d_keyword">auto</span> _utf32 = <span class="d_string">"hello"d</span>;      <span class="d_comment">// UTF-32 string
</span></pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="arrayenum" href="#arrayenum">Arrays that parallel an enum</a></h2>

<h4>The C Way</h4>

       Consider:
<pre class="ccode notranslate">enum COLORS { red, blue, green, max };
char *cstring[max] = {"red", "blue", "green" };
char *cstring[max] = {[red]="red", [blue]="blue", [green]="green" };  /* C99 */
</pre>
       This is fairly easy to get right because the number of entries is small.
       But suppose it gets to be fairly large. Then it can get difficult to
       maintain correctly when new entries are added. C99 added designated
       initializers to solve that problem.

<h4>The D Way</h4>
<pre class="d_code notranslate"><span class="d_keyword">enum</span> COLORS { red, blue, green }

string[COLORS.max + 1] cstring =
[
    COLORS.red   : <span class="d_string">"red"</span>,
    COLORS.blue  : <span class="d_string">"blue"</span>,
    COLORS.green : <span class="d_string">"green"</span>,
];
</pre>

Not perfect, but better.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="typedefs" href="#typedefs">Creating a new type with typedef</a></h2>

<h4>The C Way</h4>

        Typedefs in C are weak, that is, they really do not introduce
        a new type. The compiler doesn't distinguish between a typedef
        and its underlying type.

<pre class="ccode notranslate">typedef void *Handle;
void foo(void *);
void bar(Handle);

Handle h;
foo(h);         // coding bug not caught
bar(h);         // ok
</pre>

        The C solution is to create a dummy struct whose sole
        purpose is to get type checking and overloading on the new type.

<pre class="ccode notranslate">struct Handle__ { void *value; }
typedef struct Handle__ *Handle;
void foo(void *);
void bar(Handle);

Handle h;
foo(h);         // syntax error
bar(h);         // ok
</pre>

        Having a default value for the type involves defining a macro,
        a naming convention, and then pedantically following that convention:

<pre class="ccode notranslate">#define HANDLE_INIT ((Handle)-1)

Handle h = HANDLE_INIT;
h = func();
if (h != HANDLE_INIT)
    ...
</pre>

        For the struct solution, things get even more complex:

<pre class="ccode notranslate">struct Handle__ HANDLE_INIT;

void init_handle(void)  // call this function upon startup
{
    HANDLE_INIT.value = (void *)-1;
}

Handle h = HANDLE_INIT;
h = func();
if (memcmp(&amp;h,&amp;HANDLE_INIT,sizeof(Handle)) != 0)
    ...
</pre>

        There are 4 names to remember: <span class="d_inlinecode donthyphenate notranslate">Handle, HANDLE_INIT,
        struct Handle__, value</span>.

<h4>The D Way</h4>

    D has powerful metaprogramming abilities which allow it to implement
    <span class="d_inlinecode donthyphenate notranslate">typedef</span> as a library feature. Simply import <span class="d_inlinecode donthyphenate notranslate">std.typecons</span> and
    use the <span class="d_inlinecode donthyphenate notranslate">Typedef</span> template:

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.typecons;

<span class="d_keyword">alias</span> Handle = Typedef!(<span class="d_keyword">void</span>*);
<span class="d_keyword">void</span> foo(<span class="d_keyword">void</span>*);
<span class="d_keyword">void</span> bar(Handle);

Handle h;
foo(h);  <span class="d_comment">// syntax error
</span>bar(h);  <span class="d_comment">// ok
</span></pre>

        To handle a default value, pass the initializer to the <span class="d_inlinecode donthyphenate notranslate">Typedef</span>
    template as the second argument and refer to it with the
    <span class="d_inlinecode donthyphenate notranslate">.init</span> property:

<pre class="d_code notranslate"><span class="d_keyword">alias</span> Handle = Typedef!(<span class="d_keyword">void</span>*, <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)-1);
Handle h;
h = func();
<span class="d_keyword">if</span> (h != Handle.init)
    ...
</pre>

        Now there's only one name to remember: <span class="d_inlinecode donthyphenate notranslate">Handle</span>.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="structcmp" href="#structcmp">Comparing structs</a></h2>

<h4>The C Way</h4>

        While C defines struct assignment in a simple, convenient manner:

<pre class="ccode notranslate">struct A x, y;
...
x = y;
</pre>

        it does not for struct comparisons. Hence, to compare two struct
        instances for equality:

<pre class="ccode notranslate">#include &lt;string.h&gt;

struct A x, y;
...
if (memcmp(&amp;x, &amp;y, sizeof(struct A)) == 0)
    ...
</pre>

        <p>Note the obtuseness of this, coupled with the lack of any kind
        of help from the language with type checking.</p>

        <p>There's a nasty bug lurking in the memcmp().
        The layout of a struct, due to alignment, can have 'holes' in it.
        C does not guarantee those holes are assigned any values, and so
        two different struct instances can have the same value for each member,
        but compare different because the holes contain different garbage.</p>

<h4>The D Way</h4>

        D does it the obvious, straightforward way:

<pre class="d_code notranslate">A x, y;
...
<span class="d_keyword">if</span> (x == y)
    ...
</pre>


<hr>
<h2><a class="anchor" title="Permalink to this section" id="stringcmp" href="#stringcmp">Comparing strings</a></h2>

<h4>The C Way</h4>

        The library function strcmp() is used:
<pre class="ccode notranslate">char str[] = "hello";

if (strcmp(str, "betty") == 0)  // do strings match?
    ...
</pre>

        C uses 0 terminated strings, so the C way has an inherent
        inefficiency in constantly scanning for the terminating 0.

<h4>The D Way</h4>

        Why not use the <span class="d_inlinecode donthyphenate notranslate">==</span> operator?

<pre class="d_code notranslate">string str = <span class="d_string">"hello"</span>;

<span class="d_keyword">if</span> (str == <span class="d_string">"betty"</span>)
    ...
</pre>

        <p>D strings have the length stored separately from the string.
        Thus, the implementation of string compares can be much faster
        than in C (the difference being equivalent to the difference
        in speed between the C memcmp() and strcmp()).</p>

        <p>D supports comparison operators on strings, too:</p>

<pre class="d_code notranslate">string str = <span class="d_string">"hello"</span>;

<span class="d_keyword">if</span> (str &lt; <span class="d_string">"betty"</span>)
    ...
</pre>

        which is useful for sorting/searching.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="sort" href="#sort">Sorting arrays</a></h2>

<h4>The C Way</h4>

        Although many C programmers tend to reimplmement bubble sorts
        over and over, the right way to sort in C is to use qsort():

<pre class="ccode notranslate">int compare(const void *p1, const void *p2)
{
    type *t1 = (type *)p1;
    type *t2 = (type *)p2;

    return *t1 - *t2;
}

type array[10];
...
qsort(array, sizeof(array)/sizeof(array[0]),
        sizeof(array[0]), compare);
</pre>

        A compare() must be written for each type, and much careful
        typo-prone code needs to be written to make it work. The indirect function
        call required for each comparison limits the achievable performance of the
        <span class="d_inlinecode donthyphenate notranslate">qsort()</span> routine.


<h4>The D Way</h4>

    D has a powerful <span class="d_inlinecode donthyphenate notranslate">std.algorithm</span> module with optimized
    sorting routines, which work for any built-in or user-defined
    type which can be compared:

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.algorithm;
type[] array;
...
sort(array);      <span class="d_comment">// sort array in-place
</span></pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="strings" href="#strings">String literals</a></h2>

<h4>The C Way</h4>

        String literals in C cannot span multiple lines, so to have
        a block of text it is necessary to use \ line splicing:

<pre class="ccode notranslate">"This text spans\n\
multiple\n\
lines\n"
</pre>

        C's string literal concatenation doesn't really solve the problem:

<pre class="ccode notranslate">"This text spans\n"
"multiple\n"
"lines\n"
</pre>

        If there is a lot of text, this can wind up being tedious.

<h4>The D Way</h4>

        String literals can span multiple lines, as in:

<pre class="d_code notranslate"><span class="d_string">"This text spans
multiple
lines
"</span>
</pre>

        So blocks of text can just be cut and pasted into the D
        source.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="traversal" href="#traversal">Data Structure Traversal</a></h2>

<h4>The C Way</h4>

    <p>Consider a function to traverse a recursive data structure.
    In this example, there's a simple symbol table of strings.
    The data structure is an array of binary trees.
    The code needs to do an exhaustive search of it to find
    a particular string in it, and determine if it is a unique
    instance.</p>

    <p>To make this work, a helper function <span class="d_inlinecode donthyphenate notranslate">membersearchx</span>
    is needed to recursively
    walk the trees. The helper function needs to read and write
    some context outside of the trees, so a custom <span class="d_inlinecode donthyphenate notranslate">struct Paramblock</span>
    is created and a pointer to it is used to maximize efficiency.</p>

<pre class="ccode notranslate">struct Symbol
{
    char *id;
    struct Symbol *left;
    struct Symbol *right;
};

struct Paramblock
{
    char *id;
    struct Symbol *sm;
};

static void membersearchx(struct Paramblock *p, struct Symbol *s)
{
    while (s)
    {
        if (strcmp(p-&gt;id,s-&gt;id) == 0)
        {
            if (p-&gt;sm)
                error("ambiguous member %s\n",p-&gt;id);
            p-&gt;sm = s;
        }

        if (s-&gt;left)
            membersearchx(p,s-&gt;left);
        s = s-&gt;right;
    }
}

struct Symbol *symbol_membersearch(Symbol *table[], int tablemax, char *id)
{
    struct Paramblock pb;
    int i;

    pb.id = id;
    pb.sm = NULL;
    for (i = 0; i &lt; tablemax; i++)
    {
        membersearchx(pb, table[i]);
    }
    return pb.sm;
}
</pre>

<h4>The D Way</h4>

    <p>This is the same algorithm in D, and it shrinks dramatically.
    Since nested functions have access to the lexically enclosing
    function's variables, there's no need for a Paramblock or
    to deal with its bookkeeping details. The nested helper function
    is contained wholly within the function that needs it,
    improving locality and maintainability.</p>

    <p>The performance of the two versions is indistinguishable.</p>

<pre class="d_code notranslate"><span class="d_keyword">class</span> Symbol
{
    string id;
    Symbol left;
    Symbol right;
}

Symbol symbol_membersearch(Symbol[] table, string id)
{
    Symbol sm;

    <span class="d_keyword">void</span> membersearchx(Symbol s)
    {
        <span class="d_keyword">while</span> (s)
        {
            <span class="d_keyword">if</span> (id == s.id)
            {
                <span class="d_keyword">if</span> (sm)
                    error(<span class="d_string">"ambiguous member %s\n"</span>, id);
                sm = s;
            }

            <span class="d_keyword">if</span> (s.left)
                membersearchx(s.left);
            s = s.right;
        }
    }

    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; table.length; i++)
    {
        membersearchx(table[i]);
    }

    <span class="d_keyword">return</span> sm;
}
</pre>

<hr>
<h2><a class="anchor" title="Permalink to this section" id="ushr" href="#ushr">Unsigned Right Shift</a></h2>

<h4>The C Way</h4>

        The right shift operators <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;</span> and <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;=</span> are signed
        shifts if the left operand is a signed integral type, and
        are unsigned right shifts if the left operand is an unsigned
        integral type. To produce an unsigned right shift on an int,
        a cast is necessary:

<pre class="ccode notranslate">int i, j;
...
j = (unsigned)i &gt;&gt; 3;
</pre>

        If <span class="d_inlinecode donthyphenate notranslate">i</span> is an <span class="d_inlinecode donthyphenate notranslate">int</span>, this works fine. But if <span class="d_inlinecode donthyphenate notranslate">i</span> is
        of a type created with typedef,

<pre class="ccode notranslate">myint i, j;
...
j = (unsigned)i &gt;&gt; 3;
</pre>

        and <span class="d_inlinecode donthyphenate notranslate">myint</span> happens to be a <span class="d_inlinecode donthyphenate notranslate">long int</span>, then the cast to
        unsigned
        will silently throw away the most significant bits, corrupting
        the answer.

<h4>The D Way</h4>

        D has the right shift operators <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;</span> and <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;=</span> which
        behave as they do in C. But D also has explicitly unsigned
        right shift operators <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;</span> and <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;=</span> which will
        do an unsigned right shift regardless of the sign of the left
        operand. Hence,

<pre class="d_code notranslate">myint i, j;
...
j = i &gt;&gt;&gt; 3;
</pre>

        avoids the unsafe cast and will work as expected with any integral
        type.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="closures" href="#closures">Dynamic Closures</a></h2>

<h4>The C Way</h4>

        <p>Consider a reusable container type. In order to be reusable,
        it must support a way to apply arbitrary code to each element
        of the container. This is done by creating an <i>apply</i> function
        that accepts a function pointer to which is passed each
        element of the container contents.</p>

        <p>A generic context pointer is also needed, represented here by
        <span class="d_inlinecode donthyphenate notranslate">void *p</span>. The example here is of a trivial container
        class that holds an array of ints, and a user of that container
        that computes the maximum of those ints.</p>

<pre class="ccode notranslate">void apply(void *p, int *array, int dim, void (*fp)(void *, int))
{
    for (int i = 0; i &lt; dim; i++)
        fp(p, array[i]);
}

struct Collection
{
    int array[10];
};

void comp_max(void *p, int i)
{
    int *pmax = (int *)p;

    if (i &gt; *pmax)
        *pmax = i;
}

void func(struct Collection *c)
{
    int max = INT_MIN;

    apply(&amp;max, c-&gt;array, sizeof(c-&gt;array)/sizeof(c-&gt;array[0]), comp_max);
}
</pre>

        <p>While this works, it isn't very flexible.</p>

<h4>The D Way</h4>

        The D version makes use of <i>delegates</i> to transmit
        context information for the <i>apply</i> function,
        and <i>nested functions</i> both to capture context
        information and to improve locality.

<pre class="d_code notranslate"><span class="d_keyword">class</span> Collection
{
    <span class="d_keyword">int</span>[10] array;

    <span class="d_keyword">void</span> apply(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span>) fp)
    {
        <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; array.length; i++)
            fp(array[i]);
    }
}

<span class="d_keyword">void</span> func(Collection c)
{
    <span class="d_keyword">int</span> max = <span class="d_keyword">int</span>.min;

    <span class="d_keyword">void</span> comp_max(<span class="d_keyword">int</span> i)
    {
        <span class="d_keyword">if</span> (i &gt; max)
            max = i;
    }

    c.apply(&amp;comp_max);
}
</pre>

        Pointers are eliminated, as well as casting and generic
        pointers. The D version is fully type safe.
        An alternate method in D makes use of <i>function literals</i>:

<pre class="d_code notranslate"><span class="d_keyword">void</span> func(Collection c)
{
    <span class="d_keyword">int</span> max = <span class="d_keyword">int</span>.min;

    c.apply(<span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i) { <span class="d_keyword">if</span> (i &gt; max) max = i; } );
}
</pre>

        eliminating the need to create irrelevant function names.

<hr>
<h2><a class="anchor" title="Permalink to this section" id="variadic" href="#variadic">Variadic Function Parameters</a></h2>

        The task is to write a function that takes a varying
        number of arguments, such as a function that sums
        its arguments.

<h4>The C Way</h4>

<pre class="ccode notranslate">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

int <b>sum</b>(int dim, ...)
{
    int i;
    int s = 0;
    va_list ap;

    va_start(ap, dim);
    for (i = 0; i &lt; dim; i++)
        s += va_arg(ap, int);
    va_end(ap);
    return s;
}

int main()
{
    int i;

    i = <b>sum</b>(3, 8,7,6);
    printf("sum = %d\n", i);

    return 0;
}
</pre>

        There are two problems with this. The first is that the
        <span class="d_inlinecode donthyphenate notranslate">sum</span> function needs to know how many arguments were
        supplied. It has to be explicitly written, and it can get
        out of sync with respect to the actual number of arguments
        written.
        The second is that there's no way to check that the
        types of the arguments provided really were ints, and not
        doubles, strings, structs, etc.

<h4>The D Way</h4>

        The <span class="d_inlinecode donthyphenate notranslate">...</span> following an array parameter declaration means that
        the trailing arguments are collected together to form
        an array. The arguments are type checked against the array
        type, and the number of arguments becomes a property
        of the array:

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> <b>sum</b>(<span class="d_keyword">int</span>[] values ...)
{
    <span class="d_keyword">int</span> s = 0;

    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; values)
        s += x;
    <span class="d_keyword">return</span> s;
}

<span class="d_keyword">int</span> main()
{
    <span class="d_keyword">int</span> i;

    i = <b>sum</b>(8,7,6);
    writefln(<span class="d_string">"sum = %d"</span>, i);

    <span class="d_keyword">return</span> 0;
}
</pre>



        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

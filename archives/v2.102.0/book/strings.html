
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Strings - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Strings' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BStrings%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/strings.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Strings</h1>
        
        



<p>We have used strings in many programs that we have seen so far. Strings are a combination of the two features that we have covered in the last three chapters: characters and arrays. In the simplest definition, strings are nothing but arrays of characters. For example, <code class="d_inline">char[]</code> is a type of string.
</p>

<p>This simple definition may be misleading. As we have seen in the <a href="characters.html">Characters chapter</a>, D has three separate character types. Arrays of these character types lead to three separate string types, some of which may have surprising outcomes in some string operations.
</p>

<h5 class="subsection"><a id="ix_Strings.readln" content="readln"></a> <a id="ix_Strings.strip" content="strip"></a> <code class="d_inline">readln</code> and <code class="d_inline">strip</code>, instead of <code class="d_inline">readf</code></h5>

<p>There are surprises even when reading strings from the terminal.
</p>

<p>Being character arrays, strings can contain control characters like <code class="d_inline"><span class="d_string">'\n'</span></code> as well. When reading strings from the input, the control character that corresponds to the Enter key that is pressed at the end of the input becomes a part of the string as well. Further, because there is no way to tell <code class="d_inline">readf()</code> how many characters to read, it continues to read until the end of the entire input. For these reasons, <code class="d_inline">readf()</code> does not work as intended when reading strings:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">char</span>[] name;

    write(<span class="d_string">"What is your name? "</span>);
    readf(<span class="d_string">" %s"</span>, &amp;name);

    writeln(<span class="d_string">"Hello "</span>, name, <span class="d_string">"!"</span>);
}
</pre>

<p>The Enter key that the user presses after the name does not terminate the input. <code class="d_inline">readf()</code> continues to wait for more characters to add to the string:
</p>

<pre class="shell">What is your name? Mert
   <span class="shell_note">← The input is not terminated although Enter has been pressed</span>
   <span class="shell_note">← (Let's assume that Enter is pressed a second time here)</span>
</pre>

<p>One way of terminating the standard input stream in a terminal is pressing Ctrl-D under Unix-based systems and Ctrl-Z under Windows systems. If the user eventually terminates the input that way, we see that the new-line characters have been read as parts of the string as well:
</p>

<pre class="shell">Hello Mert
   <span class="shell_note_wrong">← new-line character after the name</span>
!  <span class="shell_note_wrong">← (one more before the exclamation mark)</span>
</pre>

<p>The exclamation mark appears after those characters instead of being printed right after the name.
</p>

<p><code class="d_inline">readln()</code> is more suitable when reading strings. Short for "read line", <code class="d_inline">readln()</code> reads until the end of the line. It is used differently because the <code class="d_inline"><span class="d_string">" %s"</span></code> format string and the <code class="d_inline">&amp;</code> operator are not needed:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">char</span>[] name;

    write(<span class="d_string">"What is your name? "</span>);
    <span class="hilite">readln(name)</span>;

    writeln(<span class="d_string">"Hello "</span>, name, <span class="d_string">"!"</span>);
}
</pre>

<p><code class="d_inline">readln()</code> stores the new-line character as well. This is so that the program has a way of determining whether the input consisted of a complete line or whether the end of input has been reached:
</p>

<pre class="shell">What is your name? Mert
Hello Mert
!  <span class="shell_note_wrong">← new-line character before the exclamation mark</span>
</pre>

<p>Such control characters as well as all whitespace characters at both ends of strings can be removed by <code class="d_inline">std.string.strip</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="hilite"><span class="d_keyword">import</span> std.string;</span>

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">char</span>[] name;

    write(<span class="d_string">"What is your name? "</span>);
    readln(name);
    <span class="hilite">name = strip(name);</span>

    writeln(<span class="d_string">"Hello "</span>, name, <span class="d_string">"!"</span>);
}
</pre>

<p>The <code class="d_inline">strip()</code> expression above returns a new string that does not contain the trailing control characters. Assigning that return value back to <code class="d_inline">name</code> produces the intended output:
</p>

<pre class="shell">What is your name? Mert
Hello Mert!    <span class="shell_note">← no new-line character</span>
</pre>

<p><code class="d_inline">readln()</code> can be used without a parameter. In that case it <i>returns</i> the line that it has just read. Chaining the result of <code class="d_inline">readln()</code> to <code class="d_inline">strip()</code> enables a shorter and more readable syntax:
</p>

<pre class="d_code">    string name = strip(readln());
</pre>

<p>I will start using that form after introducing the <code class="d_inline">string</code> type below.
</p>

<h5 class="subsection"><a id="ix_Strings.formattedRead" content="formattedRead"></a> <code class="d_inline">formattedRead</code> for parsing strings</h5>

<p>Once a line is read from the input or from any other source, it is possible to parse and convert separate data that it may contain with <code class="d_inline">formattedRead()</code> from the <code class="d_inline">std.format</code> module. Its first parameter is the line that contains the data, and the rest of the parameters are used exacly like <code class="d_inline">readf()</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;
<span class="hilite"><span class="d_keyword">import</span> std.format;</span>

<span class="d_keyword">void</span> main() {
    write(<span class="d_string">"Please enter your name and age,"</span> ~
          <span class="d_string">" separated with a space: "</span>);

    string line = strip(readln());

    string name;
    <span class="d_keyword">int</span> age;
    <span class="hilite">formattedRead</span>(line, <span class="d_string">" %s %s"</span>, name, age);

    writeln(<span class="d_string">"Your name is "</span>, name,
            <span class="d_string">", and your age is "</span>, age, '.');
}
</pre>

<pre class="shell">Please enter your name and age, separated with a space: <span class="hilite">Mert 30</span>
Your name is <span class="hilite">Mert</span>, and your age is <span class="hilite">30</span>.
</pre>

<p>Both <code class="d_inline">readf()</code> and <code class="d_inline">formattedRead()</code> <i>return</i> the number of items that they could parse and convert successfully. That value can be compared against the expected number of data items so that the input can be validated. For example, as the <code class="d_inline">formattedRead()</code> call above expects to read <i>two</i> items (a <code class="d_inline">string</code> as name and an <code class="d_inline">int</code> as age), the following check ensures that it really is the case:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">uint</span> items</span> = formattedRead(line, <span class="d_string">" %s %s"</span>, name, age);

    <span class="d_keyword">if</span> (<span class="hilite">items != 2</span>) {
        writeln(<span class="d_string">"Error: Unexpected line."</span>);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"Your name is "</span>, name,
                <span class="d_string">", and your age is "</span>, age, '.');
    }
</pre>

<p>When the input cannot be converted to <code class="d_inline">name</code> and <code class="d_inline">age</code>, the program prints an error:
</p>

<pre class="shell">Please enter your name and age, separated with a space: <span class="hilite">Mert</span>
Error: Unexpected line.
</pre>

<h5 class="subsection"><a id="ix_Strings.&quot;" content="&quot;"></a> Double quotes, not single quotes</h5>

<p>We have seen that single quotes are used to define character literals. String literals are defined with double quotes. <code class="d_inline"><span class="d_string">'a'</span></code> is a character; <code class="d_inline"><span class="d_string">"a"</span></code> is a string that contains a single character.
</p>

<h5 class="subsection"><a id="ix_Strings.string" content="string"></a> <a id="ix_Strings.wstring" content="wstring"></a> <a id="ix_Strings.dstring" content="dstring"></a> <a id="ix_Strings.char[]" content="char[]"></a> <a id="ix_Strings.wchar[]" content="wchar[]"></a> <a id="ix_Strings.dchar[]" content="dchar[]"></a> <a id="ix_Strings.immutable" content="immutable"></a> <code class="d_inline">string</code>, <code class="d_inline">wstring</code>, and <code class="d_inline">dstring</code> are immutable</h5>

<p>There are three string types that correspond to the three character types: <code class="d_inline">char[]</code>, <code class="d_inline">wchar[]</code>, and <code class="d_inline">dchar[]</code>.
</p>

<p>There are three <i>aliases</i> of the <i>immutable</i> versions of those types: <code class="d_inline">string</code>, <code class="d_inline">wstring</code>, and <code class="d_inline">dstring</code>. The characters of the variables that are defined by these aliases cannot be modified. For example, the characters of a <code class="d_inline">wchar[]</code> can be modified but the characters of a <code class="d_inline">wstring</code> cannot be modified. (We will see D's <i>immutability</i> concept in later chapters.)
</p>

<p>For example, the following code that tries to capitalize the first letter of a <code class="d_inline">string</code> would cause a compilation error:
</p>

<pre class="d_code">    string cannotBeMutated = <span class="d_string">"hello"</span>;
    cannotBeMutated[0] = 'H';             <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>We may think of defining the variable as a <code class="d_inline">char[]</code> instead of the <code class="d_inline">string</code> alias but that cannot be compiled either:
</p>

<pre class="d_code">    <span class="d_keyword">char</span>[] a_slice = <span class="d_string">"hello"</span>;  <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>This time the compilation error is due to the combination of two factors:
</p>

<ol><li>The type of string literals like <code class="d_inline"><span class="d_string">"hello"</span></code> is <code class="d_inline">string</code>, not <code class="d_inline">char[]</code>, so they are immutable.
</li>
<li>The <code class="d_inline">char[]</code> on the left-hand side is a slice, which, if the code compiled, would provide access to all of the characters of the right-hand side.
</li>
</ol>

<p>Since <code class="d_inline">char[]</code> is mutable and <code class="d_inline">string</code> is not, there is a mismatch. The compiler does not allow accessing characters of an immutable array through a mutable slice.
</p>

<p>The solution here is to take a copy of the immutable string by using the <code class="d_inline">.dup</code> property:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">char</span>[] s = <span class="d_string">"hello"</span><span class="hilite">.dup</span>;
    s[0] = 'H';
    writeln(s);
}
</pre>

<p>The program can now be compiled and will print the modified string:
</p>

<pre class="shell">Hello
</pre>

<p>Similarly, <code class="d_inline">char[]</code> cannot be used where a <code class="d_inline">string</code> is needed. In such cases, the <code class="d_inline">.idup</code> property can be used to produce an immutable <code class="d_inline">string</code> variable from a mutable <code class="d_inline">char[]</code> variable. For example, if <code class="d_inline">s</code> is a variable of type <code class="d_inline">char[]</code>, the following line will fail to compile:
</p>

<pre class="d_code">    string result = s ~ '.';          <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>When the type of <code class="d_inline">s</code> is <code class="d_inline">char[]</code>, the type of the expression on the right-hand side of the assignment above is <code class="d_inline">char[]</code> as well. <code class="d_inline">.idup</code> is used for producing immutable strings from existing strings:
</p>

<pre class="d_code">    string result = (s ~ '.')<span class="hilite">.idup</span>;   <span class="d_comment">// ← now compiles
</span></pre>

<h5 class="subsection"><a id="ix_Strings.length, string" content="length, string"></a> Potentially confusing length of strings</h5>

<p>We have seen that some Unicode characters are represented by more than one byte. For example, the character 'é' (the latin letter 'e' combined with an acute accent) is represented by Unicode encodings using at least two bytes. This fact is reflected in the <code class="d_inline">.length</code> property of strings:
</p>

<pre class="d_code">    writeln(<span class="d_string">"résumé"</span>.length);
</pre>

<p>Although "résumé" contains six <i>letters</i>, the length of the <code class="d_inline">string</code> is the number of UTF-8 code units that it contains:
</p>

<pre class="shell">8
</pre>

<p>The type of the elements of string literals like <code class="d_inline"><span class="d_string">"hello"</span></code> is <code class="d_inline">char</code> and each <code class="d_inline">char</code> value represents a UTF-8 code unit. A problem that this may cause is when we try to replace a two-code-unit character with a single-code-unit character:
</p>

<pre class="d_code">    <span class="d_keyword">char</span>[] s = <span class="d_string">"résumé"</span>.dup;
    writeln(<span class="d_string">"Before: "</span>, s);
    s[1] = 'e';
    s[5] = 'e';
    writeln(<span class="d_string">"After : "</span>, s);
</pre>

<p>The two 'e' characters do not replace the two 'é' characters; they replace single code units, resulting in an invalid UTF-8 encoding:
</p>

<pre class="shell">Before: résumé
After : re�sueé    <span class="shell_note_wrong">← INCORRECT</span>
</pre>

<p>When dealing with letters, symbols, and other Unicode characters directly, as in the code above, the correct type to use is <code class="d_inline">dchar</code>:
</p>

<pre class="d_code">    <span class="d_keyword">dchar</span>[] s = <span class="d_string">"résumé"d</span>.dup;
    writeln(<span class="d_string">"Before: "</span>, s);
    s[1] = 'e';
    s[5] = 'e';
    writeln(<span class="d_string">"After : "</span>, s);
</pre>

<p>The output:
</p>

<pre class="shell">Before: résumé
After : resume
</pre>

<p>Please note the two differences in the new code:
</p>
<ol><li>The type of the string is <code class="d_inline">dchar[]</code>.
<li>There is a <code class="d_inline">d</code> at the end of the literal <code class="d_inline"><span class="d_string">"résumé"d</span></code>, specifying its type as an array of <code class="d_inline">dchar</code>s.</li>
</li>
</ol>

<p>In any case, keep in mind that the use of <code class="d_inline">dchar[]</code> and <code class="d_inline">dstring</code> does not solve all of the problems of manipulating Unicode characters. For instance, if the user inputs the text "résumé" you and your program cannot assume that the string length will be 6 even for <code class="d_inline">dchar</code> strings. It might be greater if e.g. at least one of the 'é' characters is not encoded as a single code point but as the combination of an 'e' and a combining accute accent. To avoid dealing with this and many other Unicode issues, consider using a Unicode-aware text manipulation library in your programs.
</p>

<h5 class="subsection"><a id="ix_Strings.literal, string" content="literal, string"></a> String literals</h5>

<p>The optional character that is specified after string literals determines the type of the elements of the string:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
     string s = <span class="d_string">"résumé"c</span>;   <span class="d_comment">// same as "résumé"
</span>    wstring w = <span class="d_string">"résumé"w</span>;
    dstring d = <span class="d_string">"résumé"d</span>;

    writeln(s.length);
    writeln(w.length);
    writeln(d.length);
}
</pre>

<p>The output:
</p>

<pre class="shell">8
6
6
</pre>

<p>Because all of the Unicode characters of "résumé" can be represented by a single <code class="d_inline">wchar</code> or <code class="d_inline">dchar</code>, the last two lengths are equal to the number of characters.
</p>

<h5 class="subsection"><a id="ix_Strings.concatenation, string" content="concatenation, string"></a> String concatenation</h5>

<p>Since they are actually arrays, all of the array operations can be applied to strings as well. <code class="d_inline">~</code> concatenates two strings and <code class="d_inline">~=</code> appends to an existing string:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;

<span class="d_keyword">void</span> main() {
    write(<span class="d_string">"What is your name? "</span>);
    string name = strip(readln());

    <span class="d_comment">// Concatenate:
</span>    string greeting = <span class="d_string">"Hello "</span> ~ name;

    <span class="d_comment">// Append:
</span>    greeting ~= <span class="d_string">"! Welcome..."</span>;

    writeln(greeting);
}
</pre>

<p>The output:
</p>

<pre class="shell">What is your name? Can
Hello Can! Welcome...
</pre>

<h5 class="subsection">Comparing strings</h5>

<p><i><b>Note:</b> Unicode does not define how the characters are ordered other than their Unicode codes. For that reason, you may get results that don't match your expectations below.</i>
</p>

<p>We have used comparison operators <code class="d_inline">&lt;</code>, <code class="d_inline">&gt;=</code>, etc. with integer and floating point values before. The same operators can be used with strings as well, but with a different meaning: strings are ordered <i>lexicographically</i>. This ordering takes each character's Unicode code to be its place in a hypothetical grand Unicode alphabet. The concepts of <i>less</i> and <i>greater</i> are replaced with <i>before</i> and <i>after</i> in this hypothetical alphabet:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;

<span class="d_keyword">void</span> main() {
    write(<span class="d_string">"      Enter a string: "</span>);
    string s1 = strip(readln());

    write(<span class="d_string">"Enter another string: "</span>);
    string s2 = strip(readln());

    <span class="d_keyword">if</span> (s1 <span class="hilite">==</span> s2) {
        writeln(<span class="d_string">"They are the same!"</span>);

    } <span class="d_keyword">else</span> {
        string former;
        string latter;

        <span class="d_keyword">if</span> (s1 <span class="hilite">&lt;</span> s2) {
            former = s1;
            latter = s2;

        } <span class="d_keyword">else</span> {
            former = s2;
            latter = s1;
        }

        writeln(<span class="d_string">"'"</span>, former, <span class="d_string">"' comes before '"</span>, latter, <span class="d_string">"'."</span>);
    }
}
</pre>

<p>Because Unicode adopts the letters of the basic Latin alphabet from the ASCII table, the strings that contain only the letters of the ASCII table will always be ordered correctly.
</p>

<h5 class="subsection">Lowercase and uppercase are different</h5>

<p>Because each character has a unique code, every letter variant is different from the others. For example, 'A' and 'a' are different letters, when directly comparing Unicode strings.
</p>

<p>Additionally, as a consequence of their ASCII code values, all of the latin uppercase letters are sorted before all of the lowercase letters. For example, 'B' comes before 'a'. The <code class="d_inline">icmp()</code> function of the <code class="d_inline">std.string</code> module can be used when strings need to be compared regardless of lowercase and uppercase. You can see the functions of this module at <a href="http://dlang.org/phobos/std_string.html">its online documentation</a>.
</p>

<p>Because strings are arrays (and as a corollary, <i>ranges</i>), the functions of the <code class="d_inline">std.array</code>, <code class="d_inline">std.algorithm</code>, and <code class="d_inline">std.range</code> modules are very useful with strings as well.
</p>

<h5 class="subsection">Problemler</h5>
    <ol>
<li>Browse the documentations of the <code class="d_inline">std.string</code>, <code class="d_inline">std.array</code>, <code class="d_inline">std.algorithm</code>, and <code class="d_inline">std.range</code> modules.
</li>

<li>Write a program that makes use of the <code class="d_inline">~</code> operator: The user enters the first name and the last name, all in lowercase letters. Produce the full name that contains the proper capitalization of the first and last names. For example, when the strings are "ebru" and "domates" the program should print "Ebru&nbsp;Domates".
</li>

<li>Read a line from the input and print the part between the first and last 'e' letters of the line. For example, when the line is "this line has five words" the program should print "e has five".

<p>You may find the <code class="d_inline">indexOf()</code> and <code class="d_inline">lastIndexOf()</code> functions useful to get the two indexes needed to produce a slice.
</p>

<p>As it is indicated in their documentation, the return types of <code class="d_inline">indexOf()</code> and <code class="d_inline">lastIndexOf()</code> are not <code class="d_inline">int</code> nor <code class="d_inline">size_t</code>, but <code class="d_inline">ptrdiff_t</code>. You may have to define variables of that exact type:
</p>

<pre class="d_code">    ptrdiff_t first_e = indexOf(line, 'e');
</pre>

<p>It is possible to define variables with the <code class="d_inline">auto</code> keyword, which we will see in a later chapter:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> first_e = indexOf(line, 'e');
</pre>

</li>

</ol> <div class="cozum_link_cok"><p><a target="ddili_cozum" href="strings.cozum.html"><i>... çözümler</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 20:50:22 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

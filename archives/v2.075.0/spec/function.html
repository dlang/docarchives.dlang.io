
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2017 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Functions - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Functions' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.freenode.net/d'>IRC</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation.html'>Foundation</a></li>
    <li><a href='../donate.html'>Donate</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option selected value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    
    <div class="head">        <h2>Language Reference</h2>
        <p class="subnav-duplicate">            <a href="../spec/spec.html">table of contents</a></p>
    </div>
    <ul>        <li><a href='            ../spec/intro.html'>Introduction</a></li><li><a href='            ../spec/lex.html'>Lexical</a></li><li><a href='            ../spec/grammar.html'>Grammar</a></li><li><a href='            ../spec/module.html'>Modules</a></li><li><a href='            ../spec/declaration.html'>Declarations</a></li><li><a href='            ../spec/type.html'>Types</a></li><li><a href='            ../spec/property.html'>Properties</a></li><li><a href='            ../spec/attribute.html'>Attributes</a></li><li><a href='            ../spec/pragma.html'>Pragmas</a></li><li><a href='            ../spec/expression.html'>Expressions</a></li><li><a href='            ../spec/statement.html'>Statements</a></li><li><a href='            ../spec/arrays.html'>Arrays</a></li><li><a href='            ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='            ../spec/struct.html'>Structs and Unions</a></li><li><a href='            ../spec/class.html'>Classes</a></li><li><a href='            ../spec/interface.html'>Interfaces</a></li><li><a href='            ../spec/enum.html'>Enums</a></li><li><a href='            ../spec/const3.html'>Type Qualifiers</a></li><li><a href='            ../spec/function.html'>Functions</a></li><li><a href='            ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='            ../spec/template.html'>Templates</a></li><li><a href='            ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='            ../spec/contracts.html'>Contract Programming</a></li><li><a href='            ../spec/version.html'>Conditional Compilation</a></li><li><a href='            ../spec/traits.html'>Traits</a></li><li><a href='            ../spec/errors.html'>Error Handling</a></li><li><a href='            ../spec/unittest.html'>Unit Tests</a></li><li><a href='            ../spec/garbage.html'>Garbage Collection</a></li><li><a href='            ../spec/float.html'>Floating Point</a></li><li><a href='            ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='            ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='            ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='            ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='            ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='            ../spec/portability.html'>Portability Guide</a></li><li><a href='            ../spec/entity.html'>Named Character Entities</a></li><li><a href='            ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='            ../spec/abi.html'>Application Binary Interface</a></li><li><a href='            ../spec/simd.html'>Vector Extensions
        </a></li>
    </ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;bug_severity=enhancement&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BFunctions%5D&amp;version=D2">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/spec/function.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Functions</h1>
        
        <div class="blankline"></div>
<div class="blankline"></div>
<div class="blankline"></div>
<div class="page-contents quickindex">    <div class="page-contents-header">        <h3>Contents</h3>
    </div>
    <ol>        <li><a href="#grammar">Grammar</a></li>
        <li><a href="#contracts">Contracts</a></li>
        <li><a href="#function-return-values">Function Return Values</a></li>
        <li><a href="#function-declarations">Functions Without Bodies</a></li>
        <li><a href="#pure-functions">Pure Functions</a></li>
        <li><a href="#nothrow-functions">Nothrow Functions</a></li>
        <li><a href="#ref-functions">Ref Functions</a></li>
        <li><a href="#auto-functions">Auto Functions</a></li>
        <li><a href="#auto-ref-functions">Auto Ref Functions</a></li>
        <li><a href="#inout-functions">Inout Functions</a></li>
        <li><a href="#optional-parenthesis">Optional Parentheses</a></li>
        <li><a href="#property-functions">Property Functions</a></li>
        <li><a href="#virtual-functions">Virtual Functions</a></li>
        <li><a href="#function-inheritance">Function Inheritance and Overriding</a></li>
        <li><a href="#inline-functions">Inline Functions</a></li>
        <li><a href="#function-overloading">Function Overloading</a><ol>            <li><a href="#overload-sets">Overload Sets</a></li>
        </ol></li>
        <li><a href="#parameters">Function Parameters</a><ol>            <li><a href="#function-default-args">Function Default Arguments</a></li>
            <li><a href="#return-ref-parameters">Return Ref Parameters</a></li>
            <li><a href="#variadic">Variadic Functions</a></li>
        </ol></li>
        <li><a href="#nested">Nested Functions</a><ol>            <li><a href="#closures">Delegates, Function Pointers, and  Closures</a></li>
            <li><a href="#anonymous">Anonymous Functions and Anonymous Delegates</a></li>
        </ol></li>
        <li><a href="#main">main() Function</a></li>
        <li><a href="#function-templates">Function Templates</a></li>
        <li><a href="#interpretation">Compile Time Function Execution (CTFE)</a><ol>            <li><a href="#string-mixins">String Mixins and Compile Time Function Execution</a></li>
        </ol></li>
        <li><a href="#function-safety">Function Safety</a><ol>            <li><a href="#safe-functions">Safe Functions</a></li>
            <li><a href="#trusted-functions">Trusted Functions</a></li>
            <li><a href="#system-functions">System Functions</a></li>
        </ol></li>
        <li><a href="#function-attribute-inference">Function Attribute Inference</a></li>
        <li><a href="#pseudo-member">Uniform Function Call Syntax (UFCS)</a></li>
    </ol>
</div>

<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="grammar" href="#grammar">Grammar</a></h4>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FuncDeclaration"><span class="gname">FuncDeclaration</span></a>:
    <a href="../spec/declaration.html#StorageClasses"><i>StorageClasses</i></a><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="#FuncDeclarator"><i>FuncDeclarator</i></a> <a href="#FunctionBody"><i>FunctionBody</i></a>
    <a href="#AutoFuncDeclaration"><i>AutoFuncDeclaration</i></a>
<div class="blankline"></div>
<a id="AutoFuncDeclaration"><span class="gname">AutoFuncDeclaration</span></a>:
    <a href="../spec/declaration.html#StorageClasses"><i>StorageClasses</i></a> <i>Identifier</i> <a href="#FuncDeclaratorSuffix"><i>FuncDeclaratorSuffix</i></a> <a href="#FunctionBody"><i>FunctionBody</i></a>
<div class="blankline"></div>
<a id="FuncDeclarator"><span class="gname">FuncDeclarator</span></a>:
    <a href="../spec/declaration.html#BasicType2"><i>BasicType2</i></a><sub>opt</sub> <i>Identifier</i> <a href="#FuncDeclaratorSuffix"><i>FuncDeclaratorSuffix</i></a>
<div class="blankline"></div>
<a id="FuncDeclaratorSuffix"><span class="gname">FuncDeclaratorSuffix</span></a>:
    <a href="#Parameters"><i>Parameters</i></a> <a href="#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub>
    <a href="../spec/template.html#TemplateParameters"><i>TemplateParameters</i></a> <a href="#Parameters"><i>Parameters</i></a> <a href="#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub> <a href="../spec/template.html#Constraint"><i>Constraint</i></a><sub>opt</sub>
</pre>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="Parameters"><span class="gname">Parameters</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ParameterList"><i>ParameterList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<a id="ParameterList"><span class="gname">ParameterList</span></a>:
    <a href="#Parameter"><i>Parameter</i></a>
    <a href="#Parameter"><i>Parameter</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>ParameterList</i>
    <span class="d_inlinecode donthyphenate notranslate">...</span>
<div class="blankline"></div>
<a id="Parameter"><span class="gname">Parameter</span></a>:
    <i>InOut</i><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="../spec/declaration.html#Declarator"><i>Declarator</i></a>
    <i>InOut</i><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="../spec/declaration.html#Declarator"><i>Declarator</i></a> <span class="d_inlinecode donthyphenate notranslate">...</span>
    <i>InOut</i><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <a href="../spec/declaration.html#Declarator"><i>Declarator</i></a> = <a href="../spec/expression.html#AssignExpression"><i>AssignExpression</i></a>
    <i>InOut</i><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a>
    <i>InOut</i><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">...</span>
<div class="blankline"></div>
<a id="InOut"><span class="gname">InOut</span></a>:
    <i>InOutX</i>
    <i>InOut InOutX</i>
<div class="blankline"></div>
<a id="InOutX"><span class="gname">InOutX</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">auto</span>
    <a href="../spec/declaration.html#TypeCtor"><i>TypeCtor</i></a>
    <span class="d_inlinecode donthyphenate notranslate">final</span>
    <span class="d_inlinecode donthyphenate notranslate">in</span>
    <span class="d_inlinecode donthyphenate notranslate">lazy</span>
    <span class="d_inlinecode donthyphenate notranslate">out</span>
    <span class="d_inlinecode donthyphenate notranslate">ref</span>
    <a href="#return-ref-parameters"><span class="d_inlinecode donthyphenate notranslate">return ref</span></a>
    <span class="d_inlinecode donthyphenate notranslate">scope</span>
<div class="blankline"></div>
<a id="FunctionAttributes"><span class="gname">FunctionAttributes</span></a>:
    <a href="#FunctionAttribute"><i>FunctionAttribute</i></a>
    <a href="#FunctionAttribute"><i>FunctionAttribute</i></a> <i>FunctionAttributes</i>
<div class="blankline"></div>
<a id="FunctionAttribute"><span class="gname">FunctionAttribute</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">nothrow</span>
    <span class="d_inlinecode donthyphenate notranslate">pure</span>
    <a href="../spec/attribute.html#Property"><i>Property</i></a>
<div class="blankline"></div>
<a id="MemberFunctionAttributes"><span class="gname">MemberFunctionAttributes</span></a>:
    <a href="#MemberFunctionAttribute"><i>MemberFunctionAttribute</i></a>
    <a href="#MemberFunctionAttribute"><i>MemberFunctionAttribute</i></a> <i>MemberFunctionAttributes</i>
<div class="blankline"></div>
<a id="MemberFunctionAttribute"><span class="gname">MemberFunctionAttribute</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">const</span>
    <span class="d_inlinecode donthyphenate notranslate">immutable</span>
    <span class="d_inlinecode donthyphenate notranslate">inout</span>
    <span class="d_inlinecode donthyphenate notranslate">return</span>
    <span class="d_inlinecode donthyphenate notranslate">shared</span>
    <a href="#FunctionAttribute"><i>FunctionAttribute</i></a>
</pre>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FunctionBody"><span class="gname">FunctionBody</span></a>:
    <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
    <a href="#FunctionContracts"><i>FunctionContracts</i></a><sub>opt</sub> <a href="#BodyStatement"><i>BodyStatement</i></a>
    <a href="#FunctionContracts"><i>FunctionContracts</i></a>
<div class="blankline"></div>
<a id="FunctionContracts"><span class="gname">FunctionContracts</span></a>:
    <a href="#InStatement"><i>InStatement</i></a> <a href="#OutStatement"><i>OutStatement</i></a><sub>opt</sub>
    <a href="#OutStatement"><i>OutStatement</i></a> <a href="#InStatement"><i>InStatement</i></a><sub>opt</sub>
<div class="blankline"></div>
<a id="InStatement"><span class="gname">InStatement</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">in</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
<div class="blankline"></div>
<a id="OutStatement"><span class="gname">OutStatement</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">out</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
    <span class="d_inlinecode donthyphenate notranslate">out</span> <span class="d_inlinecode donthyphenate notranslate">(</span> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">)</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
<div class="blankline"></div>
<a id="BodyStatement"><span class="gname">BodyStatement</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">body</span> <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="contracts" href="#contracts">Contracts</a></h4>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">in</span> and <span class="d_inlinecode donthyphenate notranslate">out</span> blocks of a function declaration specify
    the pre- and post-conditions of the function. They are used in
    <a href="contracts.html">Contract Programming</a>.
    The code inside these blocks should
    not have any side-effects, including modifying function parameters
    and/or return values.
    </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="function-return-values" href="#function-return-values">Function Return Values</a></h4>
<div class="blankline"></div>
        <p>Function return values are considered to be rvalues.
        This means they cannot be passed by reference to other functions.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="function-declarations" href="#function-declarations">Functions Without Bodies</a></h4>
<div class="blankline"></div>
    <p>Functions without bodies:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo();
</pre>
<div class="blankline"></div>
    <p>that are not declared as <span class="d_inlinecode donthyphenate notranslate">abstract</span> are expected to have their implementations
    elsewhere, and that implementation will be provided at the link step.
    This enables an implementation of a function to be completely hidden from the user
    of it, and the implementation may be in another language such as C, assembler, etc.
    </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="pure-functions" href="#pure-functions">Pure Functions</a></h4>
<div class="blankline"></div>
        <p>Pure functions are functions that cannot access global/static
        mutable state, except if their arguments contain pointers to such. This
        enables optimizations based on the fact that a pure function may at most
        mutate state reachable through its parameters. To that end, a pure
        function:</p>
<div class="blankline"></div>
        <ul>        <li>does not read or write any global or static mutable state</li>
        <li>cannot call functions that are not pure</li>
        <li>can override an impure function, but cannot be overridden by an impure function</li>
        <li>is covariant with an impure function</li>
        <li>cannot perform I/O</li>
        </ul>
<div class="blankline"></div>
        <p>This definition of mutable functions is more general than the one
        traditionally employed by pure functional languages because it allows a
        D pure function to use state mutation, as long as all state is created
        internally or reachable through its arguments. In particular, a pure
        function may allocate memory by means of e.g. <span class="d_inlinecode donthyphenate notranslate">new</span> or <span class="d_inlinecode donthyphenate notranslate">malloc</span> without
        these being special cases. A pure function is allowed to loop
        indefinitely or terminate the program.</p>
<div class="blankline"></div>
        <p>As a concession to practicality, a pure function can also:</p>
<div class="blankline"></div>
        <ul>        <li>read and write the floating point exception flags</li>
        <li>read and write the floating point mode flags, as long as those
        flags are restored to their initial state upon function entry</li>
        <li>perform impure operations in statements that are in a
        <a href="../spec/version.html#ConditionalStatement"><i>ConditionalStatement</i></a>
        controlled by a <a href="../spec/version.html#DebugCondition"><i>DebugCondition</i></a>.</li>
        </ul>
<div class="blankline"></div>
        <p>A pure function can throw exceptions.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">int</span> x;
<span class="d_keyword">immutable</span> <span class="d_keyword">int</span> y;
<span class="d_keyword">const</span> <span class="d_keyword">int</span>* pz;

<span class="d_keyword">pure</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i,
             <span class="d_keyword">char</span>* p,
             <span class="d_keyword">const</span> <span class="d_keyword">char</span>* q,
             <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>* s)
{
    <span class="d_keyword">debug</span> writeln(<span class="d_string">"in foo()"</span>); <span class="d_comment">// ok, impure code allowed in debug statement
</span>    x = i;   <span class="d_comment">// error, modifying global state
</span>    i = x;   <span class="d_comment">// error, reading mutable global state
</span>    i = y;   <span class="d_comment">// ok, reading immutable global state
</span>    i = *pz; <span class="d_comment">// error, reading const global state
</span>    <span class="d_keyword">return</span> i;
}
</pre>
<div class="blankline"></div>
    <p>An implementation may assume that a <span class="d_inlinecode donthyphenate notranslate">pure</span> function that (a) accepts
    only parameters without mutable indirections, and (b) returns a result
    without mutable indirections, will have the same effect for all invocation
    with equivalent arguments, and is allowed to memoize the result of the
    function under the assumption that equivalent parameters always produce
    equivalent results. Such functions are termed <i>strongly <span class="d_inlinecode donthyphenate notranslate">pure</span></i> functions
    in this document. Note that a strongly pure function may still have behavior
    inconsistent with memoization by e.g. using <span class="d_inlinecode donthyphenate notranslate">cast</span>s or by changing behavior
    depending on the address of its parameters. An implementation is currently
    not required to enforce validity of memoization in all cases.</p>
<div class="blankline"></div>
    <p>A pure function that accepts only parameters without mutable
    indirections and returns a result that has mutable indirections is called a
    <i>pure factory function</i>. An implementation may assume that all mutable
    memory returned by the call is not referenced by any other part of the
    program, i.e. it is newly allocated by the function. Conversely, the mutable
    references of the result may be assumed to not refer to any object that
    existed before the function call. For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> List { <span class="d_keyword">int</span> payload; List* next; }
<span class="d_keyword">pure</span> List* make(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
{
    <span class="d_keyword">auto</span> result = <span class="d_keyword">new</span> List(a, <span class="d_keyword">null</span>);
    result.next = <span class="d_keyword">new</span> List(b, result);
    <span class="d_keyword">return</span> result;
}
</pre>
<div class="blankline"></div>
    <p>Here, an implementation may assume (without having knowledge of the body
    of <span class="d_inlinecode donthyphenate notranslate">make</span>) that all references in <span class="d_inlinecode donthyphenate notranslate">make</span>'s result refer to other <span class="d_inlinecode donthyphenate notranslate">List</span>
    objects created by <span class="d_inlinecode donthyphenate notranslate">make</span>, and that no other part of the program refers to
    any of these objects.</p>
<div class="blankline"></div>
    <p>Any <span class="d_inlinecode donthyphenate notranslate">pure</span> function that is not strongly pure cannot be assumed to be
    memoizable, and calls to it may not be elided even if it returns <span class="d_inlinecode donthyphenate notranslate">void</span>
    (save for compiler optimizations that prove the function has no effect).
    Function calls may still be elided, or results be memoized, by means of
    traditional inlining and optimization techniques available for all
    functions.</p>
<div class="blankline"></div>
    <p>If a strongly pure function throws an exception or an error, the
    assumptions related to memoization and references do not carry to the thrown
    exception.</p>
<div class="blankline"></div>
    <p>Pure destructors do not benefit of special elision.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="nothrow-functions" href="#nothrow-functions">Nothrow Functions</a></h4>
<div class="blankline"></div>
        <p>Nothrow functions can only throw exceptions derived
        from class <i>Error</i>.
        </p>
<div class="blankline"></div>
        <p>Nothrow functions are covariant with throwing ones.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="ref-functions" href="#ref-functions">Ref Functions</a></h4>
<div class="blankline"></div>
        <p>Ref functions allow functions to return by reference.
        This is analogous to ref function parameters.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo()
{
    <span class="d_keyword">auto</span> p = <span class="d_keyword">new</span> <span class="d_keyword">int</span>;
    <span class="d_keyword">return</span> *p;
}
...
foo() = 3;  <span class="d_comment">// reference returns can be lvalues
</span></pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="auto-functions" href="#auto-functions">Auto Functions</a></h4>
<div class="blankline"></div>
    <p>Auto functions have their return type inferred from any
        <a href="../spec/statement.html#ReturnStatement"><i>ReturnStatement</i></a>s in the function body.
    </p>
<div class="blankline"></div>
    <p>An auto function is declared without a return type.
        If it does not already have a storage class, use the
        <span class="d_keyword">auto</span> storage class.
    </p>
<div class="blankline"></div>
    <p>If there are multiple <i>ReturnStatement</i>s, the types
        of them must be implicitly convertible to a common type.
        If there are no <i>ReturnStatement</i>s, the return type is inferred
        to be <span class="d_keyword">void</span>.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> foo(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x + 3; }          <span class="d_comment">// inferred to be int
</span><span class="d_keyword">auto</span> foo(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; <span class="d_keyword">return</span> 2.5; }  <span class="d_comment">// inferred to be double
</span></pre>
    </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="auto-ref-functions" href="#auto-ref-functions">Auto Ref Functions</a></h4>
<div class="blankline"></div>
    <p>Auto ref functions infer their return type just as
        <a href="#auto-functions">auto functions</a> do.
        In addition, they become <a href="#ref-functions">ref functions</a>
        if all return expressions are lvalues,
        and it would not be a reference to a local or a parameter.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">int</span> x)     { <span class="d_keyword">return</span> x; }  <span class="d_comment">// value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo()          { <span class="d_keyword">return</span> 3; }  <span class="d_comment">// value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo() { <span class="d_keyword">static</span> <span class="d_keyword">int</span> x; <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span></pre>
    </p>
<div class="blankline"></div>
    <p>The ref-ness of a function is determined from all
        <a href="../spec/statement.html#ReturnStatement"><i>ReturnStatement</i></a>s in the function body:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> 3; <span class="d_keyword">return</span> x; }  <span class="d_comment">// ok, value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; <span class="d_keyword">return</span> 3; }  <span class="d_comment">// ok, value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x, <span class="d_keyword">ref</span> <span class="d_keyword">double</span> y)
{
    <span class="d_keyword">return</span> x; <span class="d_keyword">return</span> y;
    <span class="d_comment">// The return type is deduced to double, but cast(double)x is not an lvalue,
</span>    <span class="d_comment">// then become a value return.
</span>}
</pre>
    </p>
<div class="blankline"></div>
    <p>Auto ref function can have explicit return type.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ok, ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">double</span> x) { <span class="d_keyword">return</span> x; }   <span class="d_comment">// error, cannot convert double to int
</span></pre>
    </p>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="inout-functions" href="#inout-functions">Inout Functions</a></h4>
<div class="blankline"></div>
    <p>Functions that deal with mutable, const, or immutable types with
        equanimity often need to transmit their type to the return value:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] foo(<span class="d_keyword">int</span>[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }

<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }

<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }
</pre>
    </p>
<div class="blankline"></div>
    <p>The code generated by these three functions is identical.
        To indicate that these can be one function, the <span class="d_keyword">inout</span>
        type constructor is employed:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }
</pre>
    </p>
<div class="blankline"></div>
    <p>The <span class="d_keyword">inout</span> forms a wildcard that stands in for
        any of mutable, const, immutable, inout, or inout const. When the
        function is called, the inout of the return type is changed to whatever
        the mutable, const, immutable, inout, or inout const status of the
        argument type to the parameter inout was.
    </p>
<div class="blankline"></div>
    <p>Inout types can be implicitly converted to const or inout const,
        but to nothing else. Other types cannot be implicitly converted to inout.
        Casting to or from inout is not allowed in @safe functions.
    </p>
<div class="blankline"></div>
    <p>A set of arguments to a function with inout parameters is considered
        a match if any inout argument types match exactly, or:</p>
<div class="blankline"></div>
    <ol>        <li>No argument types are composed of inout types.</li>
        <li>A mutable, const or immutable argument type can be matched against each
        corresponding parameter inout type.</li>
    </ol>
<div class="blankline"></div>
    <p>If such a match occurs, the inout is considered the common qualifier of
        the matched qualifiers. If more than two parameters exist, the common
        qualifier calculation is recursively applied.
    </p>
<div class="blankline"></div>
    <center><table><caption>Common qualifier of the two type qualifiers</caption>        <tr><td></td><td><i>mutable</i></td><td><span class="d_inlinecode donthyphenate notranslate">const</span></td><td><span class="d_inlinecode donthyphenate notranslate">immutable</span></td><td><span class="d_inlinecode donthyphenate notranslate">inout</span></td><td><span class="d_inlinecode donthyphenate notranslate">inout const</span></td></tr>
        <tr><td><i>mutable</i> (= m)</td><td>m</td><td>c</td><td>c</td><td>c</td><td>c</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">const</span> (= c)</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable</span> (= i)</td><td>c</td><td>c</td><td>i</td><td>wc</td><td>wc</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">inout</span> (= w)</td><td>c</td><td>c</td><td>wc</td><td>w</td><td>wc</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">inout const</span> (= wc)</td><td>c</td><td>c</td><td>wc</td><td>wc</td><td>wc</td></tr>
    </table></center>
<div class="blankline"></div>
    <p>The inout in the return type is then rewritten to be the inout matched
        qualifiers:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] ma;
<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] ca;
<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] ia;

<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] a) { <span class="d_keyword">return</span> a; }
<span class="d_keyword">void</span> test1()
{
    <span class="d_comment">// inout matches to mutable, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to int[]
</span>    <span class="d_keyword">int</span>[] x = foo(ma);

    <span class="d_comment">// inout matches to const, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to const(int)[]
</span>    <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] y = foo(ca);

    <span class="d_comment">// inout matches to immutable, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to immutable(int)[]
</span>    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] z = foo(ia);
}

<span class="d_keyword">inout</span>(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>))[] bar(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] a) { <span class="d_keyword">return</span> a; }
<span class="d_keyword">void</span> test2()
{
    <span class="d_comment">// inout matches to mutable, so inout(const(int))[] is
</span>    <span class="d_comment">// rewritten to const(int)[]
</span>    <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] x = bar(ma);

    <span class="d_comment">// inout matches to const, so inout(const(int))[] is
</span>    <span class="d_comment">// rewritten to const(int)[]
</span>    <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] y = bar(ca);

    <span class="d_comment">// inout matches to immutable, so inout(int)[] is
</span>    <span class="d_comment">// rewritten to immutable(int)[]
</span>    <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] z = bar(ia);
}
</pre>
    </p>
<div class="blankline"></div>
    <p><b>Note:</b> Shared types are not overlooked. Shared types cannot
        be matched with inout.
    </p>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="optional-parenthesis" href="#optional-parenthesis">Optional Parentheses</a></h4>
<div class="blankline"></div>
    <p>If a function call passes no explicit argument, i.e. it would syntactically use <span class="d_inlinecode donthyphenate notranslate">()</span>, then these parentheses
    may be omitted, similar to a getter invocation of a
        <a href="#property-functions">property function</a>.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo() {}   <span class="d_comment">// no arguments
</span><span class="d_keyword">void</span> fun(<span class="d_keyword">int</span> x = 10) { }
<span class="d_keyword">void</span> bar(<span class="d_keyword">int</span>[] arr) {}  <span class="d_comment">// for UFCS
</span>
<span class="d_keyword">void</span> main()
{
    foo();      <span class="d_comment">// OK
</span>    foo;        <span class="d_comment">// also OK
</span>    fun;        <span class="d_comment">// OK
</span>
    <span class="d_keyword">int</span>[] arr;
    arr.bar();  <span class="d_comment">// OK
</span>    arr.bar;    <span class="d_comment">// also OK
</span>}
</pre>
<div class="blankline"></div>
    <p>Optional parentheses are not applied to delegates or function pointers.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

    <span class="d_keyword">assert</span>(fp == 6);    <span class="d_comment">// Error, incompatible types int function() and int
</span>    <span class="d_keyword">assert</span>(*fp == 6);   <span class="d_comment">// Error, incompatible types int() and int
</span>
    <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
    <span class="d_keyword">assert</span>(dg == 6);    <span class="d_comment">// Error, incompatible types int delegate() and int
</span>}
</pre>
<div class="blankline"></div>
    <p>If a function returns a delegate or function pointer, the parantheses are required if the
    returned value is to be called.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S {
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>() callfp() { <span class="d_keyword">return</span> &amp;numfp; }
    <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() calldg() { <span class="d_keyword">return</span> &amp;numdg; }
    <span class="d_keyword">int</span> numdg() { <span class="d_keyword">return</span> 6; }
}

<span class="d_keyword">int</span> numfp() { <span class="d_keyword">return</span> 6; }

<span class="d_keyword">void</span> main()
{
    S s;
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

    fp = s.callfp;
    <span class="d_keyword">assert</span>(fp() == 6);

    fp = s.callfp();
    <span class="d_keyword">assert</span>(fp() == 6);

    <span class="d_keyword">int</span> x = s.callfp()();
    <span class="d_keyword">assert</span>(x == 6);

    <span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;

    dg = s.calldg;
    <span class="d_keyword">assert</span>(dg() == 6);

    dg = s.calldg();
    <span class="d_keyword">assert</span>(dg() == 6);

    <span class="d_keyword">int</span> y = s.calldg()();
    <span class="d_keyword">assert</span>(y == 6);
}
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="property-functions" href="#property-functions">Property Functions</a></h4>
<div class="blankline"></div>
    <p>Properties are functions that can be syntactically treated
    as if they were fields or variables. Properties can be read from or written to.
    A property is read by calling a method or function with no arguments;
    a property is written by calling a method or function with its argument
    being the value it is set to.
    </p>
<div class="blankline"></div>
    <p>Simple getter and setter properties can be written using <a href="#pseudo-member">UFCS</a>.
    These can be enhanced with the additon of the <span class="d_inlinecode donthyphenate notranslate">@property</span> attribute to the function, which
    adds the following behaviors:
    </p>
<div class="blankline"></div>
    <ul>    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> functions cannot be overloaded with non-<span class="d_inlinecode donthyphenate notranslate">@property</span> functions with the same name.</li>
    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> functions can only have zero, one or two parameters.</li>
    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> functions cannot have variadic parameters.</li>
    <li>For the expression <span class="d_inlinecode donthyphenate notranslate">typeof(exp)</span> where <span class="d_inlinecode donthyphenate notranslate">exp</span> is an <span class="d_inlinecode donthyphenate notranslate">@property</span> function,
    the type is the return type of the function, rather than the type of the function.</li>
    <li>For the expression <span class="d_inlinecode donthyphenate notranslate">__traits(compiles, exp)</span> where <span class="d_inlinecode donthyphenate notranslate">exp</span> is an <span class="d_inlinecode donthyphenate notranslate">@property</span> function,
    a further check is made to see if the function can be called.</li>
    <li><span class="d_inlinecode donthyphenate notranslate">@property</span> are mangled differently, meaning that <span class="d_inlinecode donthyphenate notranslate">@property</span> must be consistently
    used across different compilation units.</li>
    <li>The ObjectiveC interface recognizes <span class="d_inlinecode donthyphenate notranslate">@property</span> setter functions as special and modifies
    them accordingly.</li>
    </ul>
<div class="blankline"></div>
    <p>A simple property would be:</p>
<div class="blankline"></div>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
    @property <span class="d_keyword">int</span> data() { <span class="d_keyword">return</span> m_data; } <span class="d_comment">// read property
</span>
    @property <span class="d_keyword">int</span> data(<span class="d_keyword">int</span> value) { <span class="d_keyword">return</span> m_data = value; } <span class="d_comment">// write property
</span>
  <span class="d_keyword">private</span>:
    <span class="d_keyword">int</span> m_data;
}
</pre>
<div class="blankline"></div>
        <p>To use it:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> test()
{
    Foo f;

    f.data = 3;        <span class="d_comment">// same as f.data(3);
</span>    <span class="d_keyword">return</span> f.data + 3; <span class="d_comment">// same as return f.data() + 3;
</span>}
</pre>
<div class="blankline"></div>
    <p>The absence of a read method means that the property is write-only.
    The absence of a write method means that the property is read-only.
    Multiple write methods can exist; the correct one is selected using
    the usual function overloading rules.
    </p>
<div class="blankline"></div>
    <p>In all the other respects, these methods are like any other methods.
    They can be static, have different linkages,  have their address taken, etc.
    </p>
<div class="blankline"></div>
    <p>The built in properties <span class="d_inlinecode donthyphenate notranslate">.sizeof</span>, <span class="d_inlinecode donthyphenate notranslate">.alignof</span>, and <span class="d_inlinecode donthyphenate notranslate">.mangleof</span>
    may not be declared as fields or methods in structs, unions, classes or enums.
    </p>
<div class="blankline"></div>
        <p>If a property function has no parameters, it works as a getter.
        If has exactly one parameter, it works as a setter.
        </p>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="virtual-functions" href="#virtual-functions">Virtual Functions</a></h4>
<div class="blankline"></div>
        <p>Virtual functions are functions that are called indirectly through a
        function pointer table, called a vtbl[], rather than directly. All
        <span class="d_inlinecode donthyphenate notranslate">public</span> and <span class="d_inlinecode donthyphenate notranslate">protected</span> member functions which are non-static and
        are not templatized are virtual unless the compiler can determine that
        they will never be overridden (e.g. they are marked with <span class="d_inlinecode donthyphenate notranslate">final</span> and
        do not override any functions in a base class), in which case, it will
        make them non-virtual. This results in fewer bugs caused by not
        declaring a function virtual and then overriding it anyway.
        </p>
<div class="blankline"></div>
        <p>Member functions which are <span class="d_inlinecode donthyphenate notranslate">private</span> or <span class="d_inlinecode donthyphenate notranslate">package</span> are never
        virtual, and hence cannot be overridden.
        </p>
<div class="blankline"></div>
        <p>Functions with non-D linkage cannot be virtual and hence cannot be
        overridden.
        </p>
<div class="blankline"></div>
        <p>Member template functions cannot be virtual and hence cannot be
        overridden.
        </p>
<div class="blankline"></div>
        <p>Functions marked as <span class="d_inlinecode donthyphenate notranslate">final</span> may not be overridden in a
        derived class, unless they are also <span class="d_inlinecode donthyphenate notranslate">private</span>.
        For example:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> def() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">int</span> foo() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">private</span> <span class="d_keyword">int</span> bar() { ... }
    <span class="d_keyword">private</span> <span class="d_keyword">int</span> abc() { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> def() { ... }  <span class="d_comment">// ok, overrides A.def
</span>    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo() { ... }  <span class="d_comment">// error, A.foo is final
</span>    <span class="d_keyword">int</span> bar() { ... }  <span class="d_comment">// ok, A.bar is final private, but not virtual
</span>    <span class="d_keyword">int</span> abc() { ... }  <span class="d_comment">// ok, A.abc is not virtual, B.abc is virtual
</span>}

<span class="d_keyword">void</span> test(A a)
{
    a.def();    <span class="d_comment">// calls B.def
</span>    a.foo();    <span class="d_comment">// calls A.foo
</span>    a.bar();    <span class="d_comment">// calls A.bar
</span>    a.abc();    <span class="d_comment">// calls A.abc
</span>}

<span class="d_keyword">void</span> func()
{
    B b = <span class="d_keyword">new</span> B();
    test(b);
}
</pre>
<div class="blankline"></div>
        <p>Covariant return types
        are supported, which means that the
        overriding function in a derived class can return a type
        that is derived from the type returned by the overridden function:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">class</span> Foo
{
    A test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }
}

<span class="d_keyword">class</span> Bar : Foo
{
    <span class="d_keyword">override</span> B test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; } <span class="d_comment">// overrides and is covariant with Foo.test()
</span>}
</pre>
<div class="blankline"></div>
        <p>Virtual functions all have a hidden parameter called the
        <i>this</i> reference, which refers to the class object for which
        the function is called.
        </p>
<div class="blankline"></div>
        <p>To avoid dynamic binding on member function call, insert
        base class name before the member function name. For example:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> B
{
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 1; }
}
<span class="d_keyword">class</span> C : B
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 2; }

    <span class="d_keyword">void</span> test()
    {
        <span class="d_keyword">assert</span>(B.foo() == 1);  <span class="d_comment">// translated to this.B.foo(), and
</span>                               <span class="d_comment">// calls B.foo statically.
</span>        <span class="d_keyword">assert</span>(C.foo() == 2);  <span class="d_comment">// calls C.foo statically, even if
</span>                               <span class="d_comment">// the actual instance of 'this' is D.
</span>    }
}
<span class="d_keyword">class</span> D : C
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 3; }
}
<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> d = <span class="d_keyword">new</span> D();
    <span class="d_keyword">assert</span>(d.foo() == 3);    <span class="d_comment">// calls D.foo
</span>    <span class="d_keyword">assert</span>(d.B.foo() == 1);  <span class="d_comment">// calls B.foo
</span>    <span class="d_keyword">assert</span>(d.C.foo() == 2);  <span class="d_comment">// calls C.foo
</span>    d.test();
}
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="function-inheritance" href="#function-inheritance">Function Inheritance and Overriding</a></h4>
<div class="blankline"></div>
        A function in a derived class with the same name and parameter
        types as a function in a base class overrides that function:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo(1);   <span class="d_comment">// calls B.foo(int)
</span>}
</pre>
<div class="blankline"></div>
        <p>However, when doing overload resolution, the functions in the base
        class are not considered:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    b.foo(1);  <span class="d_comment">// calls B.foo(long), since A.foo(int) not considered
</span>    A a = b;

    a.foo(1);  <span class="d_comment">// issues runtime error (instead of calling A.foo(int))
</span>}
</pre>
<div class="blankline"></div>
        <p>To consider the base class's functions in the overload resolution
        process, use an <i>AliasDeclaration</i>:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <b><i><span class="d_keyword">alias</span> foo = A.foo;</i></b>
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo(1);      <span class="d_comment">// calls A.foo(int)
</span>    B b = <span class="d_keyword">new</span> B();
    b.foo(1);      <span class="d_comment">// calls A.foo(int)
</span>}
</pre>
<div class="blankline"></div>
        <p>If such an <i>AliasDeclaration</i> is not used, the derived
        class's functions completely override all the functions of the
        same name in the base class, even if the types of the parameters
        in the base class functions are different. If, through
        implicit conversions to the base class, those other functions do
        get called, a compile-time error will be given:
        </p>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> <b><i>set</i></b>(<span class="d_keyword">long</span> i) { }
    <span class="d_keyword">void</span> set(<span class="d_keyword">int</span> i)  { }
}
<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> set(<span class="d_keyword">long</span> i) { }
}

<span class="d_keyword">void</span> foo(A a)
{
    <span class="d_keyword">int</span> i;
    a.set(3);   <span class="d_comment">// error, use of A.set(int) is hidden by B
</span>                <span class="d_comment">// use 'alias set = A.set;' to introduce base class overload set.
</span>    <span class="d_keyword">assert</span>(i == 1);
}

<span class="d_keyword">void</span> main()
{
    foo(<span class="d_keyword">new</span> B);
}
</pre>
        <p>If an error occurs during the compilation of your program,
        the use of overloads and overrides needs to be reexamined in the
        relevant classes.</p>
<div class="blankline"></div>
        <p>The compiler will not give an error if the hidden function
        is disjoint, as far as overloading is concerned, from all the
        other virtual functions is the inheritance hierarchy.</p>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>A function parameter's default value is not inherited:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> <b><i>foo</i></b>(<span class="d_keyword">int</span> x = 5) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b><i>x = 7</i></b>) { ... }
}

<span class="d_keyword">class</span> C : B
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b><i>x</i></b>) { ... }
}

<span class="d_keyword">void</span> test()
{
    A a = <span class="d_keyword">new</span> A();
    a.foo();       <span class="d_comment">// calls A.foo(5)
</span>
    B b = <span class="d_keyword">new</span> B();
    b.foo();       <span class="d_comment">// calls B.foo(7)
</span>
    C c = <span class="d_keyword">new</span> C();
    c.foo();       <span class="d_comment">// error, need an argument for C.foo
</span>}
</pre>
<div class="blankline"></div>
        <p>If a derived class overrides a base class member function with diferrent
        <a href="#FunctionAttributes"><i>FunctionAttributes</i></a>, the missing attributes will be
        automatically compensated by the compiler.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> B
{
    <span class="d_keyword">void</span> foo() <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @safe {}
}
<span class="d_keyword">class</span> D : B
{
    <span class="d_keyword">override</span> <span class="d_keyword">void</span> foo() {}
}
<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> d = <span class="d_keyword">new</span> D();
    <span class="d_keyword">pragma</span>(msg, <span class="d_keyword">typeof</span>(&amp;d.foo));
    <span class="d_comment">// prints "void delegate() pure nothrow @safe" in compile time
</span>}
</pre>
<div class="blankline"></div>
    <p>It's not allowed to mark an overridden method with the attributes
    <a href="attribute.html#disable"><span class="d_inlinecode donthyphenate notranslate">@disable</span></a> or
    <a href="attribute.html#deprecated"><span class="d_inlinecode donthyphenate notranslate">deprecated</span></a>.
    To stop the compilation or to output the deprecation message, the compiler
    must be able to determine the target of the call, which can't be guaranteed
    when it is virtual.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> B
{
    <span class="d_keyword">void</span> foo() {}
}

<span class="d_keyword">class</span> D : B
{
    @disable <span class="d_keyword">override</span> <span class="d_keyword">void</span> foo() {}
}

<span class="d_keyword">void</span> main()
{
    B b = <span class="d_keyword">new</span> D;
    b.foo(); <span class="d_comment">// would compiles and then the most derived would be called even if disabled.
</span>}
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="inline-functions" href="#inline-functions">Inline Functions</a></h4>
<div class="blankline"></div>
        <p>The compiler makes the decision whether to inline a function or not.
        This decision may be controlled by <a href="pragma.html#inline"><span class="d_inlinecode donthyphenate notranslate">pragma(inline)</span></a>,
        assuming that the compiler implements it, which is not mandatory.</p>
<div class="blankline"></div>
        <p>Note that any <a href="../spec/expression.html#FunctionLiteral"><i>FunctionLiteral</i></a> should be inlined
        when used in its declaration scope.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function-overloading" href="#function-overloading">Function Overloading</a></h3>
<div class="blankline"></div>
        <p>Functions are overloaded based on how well the arguments
        to a function can match up with the parameters.
        The function with the <i>best</i> match is selected.
        The levels of matching are:
        </p>
<div class="blankline"></div>
        <ol>        <li>no match</li>
        <li>match with implicit conversions</li>
        <li>match with conversion to const</li>
        <li>exact match</li>
        </ol>
<div class="blankline"></div>
        <p>Each argument (including any <span class="d_inlinecode donthyphenate notranslate">this</span> pointer) is
        compared against the function's corresponding parameter, to
        determine the match level for that argument. The match level
        for a function is the <i>worst</i> match level of each of its
        arguments.</p>
<div class="blankline"></div>
        <p>Literals do not match <span class="d_inlinecode donthyphenate notranslate">ref</span> or <span class="d_inlinecode donthyphenate notranslate">out</span> parameters.</p>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>If two or more functions have the same match level,
        then <a class="anchor" title="Permalink to this section" id="partial-ordering" href="#partial-ordering"><i>partial ordering</i></a>
        is used to try to find the best match.
        Partial ordering finds the most specialized function.
        If neither function is more specialized than the other,
        then it is an ambiguity error.
        Partial ordering is determined for functions <span class="d_inlinecode donthyphenate notranslate">f()</span>
        and <span class="d_inlinecode donthyphenate notranslate">g()</span> by taking the parameter types of <span class="d_inlinecode donthyphenate notranslate">f()</span>,
        constructing a list of arguments by taking the default values
        of those types, and attempting to match them against <span class="d_inlinecode donthyphenate notranslate">g()</span>.
        If it succeeds, then <span class="d_inlinecode donthyphenate notranslate">g()</span> is at least as specialized
        as <span class="d_inlinecode donthyphenate notranslate">f()</span>.
        For example:
        </p>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }
<span class="d_keyword">class</span> C : B { }
<span class="d_keyword">void</span> foo(A);
<span class="d_keyword">void</span> foo(B);

<span class="d_keyword">void</span> test()
{
    C c;
    <span class="d_comment">/* Both foo(A) and foo(B) match with implicit conversion rules.
     * Applying partial ordering rules,
     * foo(B) cannot be called with an A, and foo(A) can be called
     * with a B. Therefore, foo(B) is more specialized, and is selected.
     */</span>
    foo(c); <span class="d_comment">// calls foo(B)
</span>}
</pre>
        <p>A function with a variadic argument is considered less
        specialized than a function without.
        </p>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>Functions defined with non-D linkage cannot be overloaded.
        This is because the name mangling might not take the parameter types
        into account.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="overload-sets" href="#overload-sets">Overload Sets</a></h3>
<div class="blankline"></div>
        <p>Functions declared at the same scope overload against each
        other, and are called an <i>Overload Set</i>.
        A typical example of an overload set are functions defined
        at module level:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">module</span> A;
<span class="d_keyword">void</span> foo() { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">long</span> i) { }
</pre>
<div class="blankline"></div>
        <p><span class="d_inlinecode donthyphenate notranslate">A.foo()</span> and <span class="d_inlinecode donthyphenate notranslate">A.foo(long)</span> form an overload set.
        A different module can also define functions with the same name:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">module</span> B;
<span class="d_keyword">class</span> C { }
<span class="d_keyword">void</span> foo(C) { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> i) { }
</pre>
<div class="blankline"></div>
        <p>and A and B can be imported by a third module, C.
        Both overload sets, the <span class="d_inlinecode donthyphenate notranslate">A.foo</span> overload set and the <span class="d_inlinecode donthyphenate notranslate">B.foo</span>
        overload set, are found. An instance of <span class="d_inlinecode donthyphenate notranslate">foo</span> is selected
        based on it matching in exactly one overload set:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">void</span> bar(C c)
{
    foo();    <span class="d_comment">// calls A.foo()
</span>    foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>    foo(c);   <span class="d_comment">// calls B.foo(C)
</span>    foo(1,2); <span class="d_comment">// error, does not match any foo
</span>    foo(1);   <span class="d_comment">// error, matches A.foo(long) and B.foo(int)
</span>    A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</pre>
<div class="blankline"></div>
        <p>Even though <span class="d_inlinecode donthyphenate notranslate">B.foo(int)</span> is a better match than <span class="d_inlinecode donthyphenate notranslate">        A.foo(long)</span> for <span class="d_inlinecode donthyphenate notranslate">foo(1)</span>,
        it is an error because the two matches are in
        different overload sets.
        </p>
<div class="blankline"></div>
        <p>Overload sets can be merged with an alias declaration:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">alias</span> foo = A.foo;
<span class="d_keyword">alias</span> foo = B.foo;

<span class="d_keyword">void</span> bar(C c)
{
    foo();    <span class="d_comment">// calls A.foo()
</span>    foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>    foo(c);   <span class="d_comment">// calls B.foo(C)
</span>    foo(1,2); <span class="d_comment">// error, does not match any foo
</span>    foo(1);   <span class="d_comment">// calls B.foo(int)
</span>    A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="parameters" href="#parameters">Function Parameters</a></h4>
<div class="blankline"></div>
        <p>Parameter storage classes are <span class="d_inlinecode donthyphenate notranslate">in</span>, <span class="d_inlinecode donthyphenate notranslate">out</span>,
        <span class="d_inlinecode donthyphenate notranslate">ref</span>, <span class="d_inlinecode donthyphenate notranslate">lazy</span>, <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span>, <span class="d_inlinecode donthyphenate notranslate">shared</span>,
        <span class="d_inlinecode donthyphenate notranslate">inout</span> or
        <span class="d_inlinecode donthyphenate notranslate">scope</span>.
        For example:
        </p>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">in</span> <span class="d_keyword">int</span> x, <span class="d_keyword">out</span> <span class="d_keyword">int</span> y, <span class="d_keyword">ref</span> <span class="d_keyword">int</span> z, <span class="d_keyword">int</span> q);
</pre>
<div class="blankline"></div>
        <p>x is <span class="d_inlinecode donthyphenate notranslate">in</span>, y is <span class="d_inlinecode donthyphenate notranslate">out</span>, z is <span class="d_inlinecode donthyphenate notranslate">ref</span>, and q is none.
        </p>
<div class="blankline"></div>
        <ul>        <li>The function declaration makes it clear what the inputs and
        outputs to the function are.</li>
        <li>It eliminates the need for IDL (interface description language) as a separate language.</li>
        <li>It provides more information to the compiler, enabling more
        error checking and
        possibly better code generation.</li>
        </ul>
<div class="blankline"></div>
    <center><table><caption>Parameter Storage Classes</caption>    <tr><th class="donthyphenate"><b>Storage Class</b></th><th class="donthyphenate"><b>Description</b></th></tr>
    <tr><td><i>none</i></td><td>parameter becomes a mutable copy of its argument</td></tr>
<div class="blankline"></div>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">in</span></td><td>equivalent to <span class="d_inlinecode donthyphenate notranslate">const scope</span></td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">out</span></td><td>parameter is initialized upon function entry with the default value
    for its type</td></tr>
<div class="blankline"></div>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">ref</span></td><td>  parameter is passed by reference</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">scope</span></td><td>references in the parameter
    cannot be escaped (e.g. assigned to a global variable).
    Ignored for parameters with no references</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">lazy</span></td><td>argument is evaluated by the called function and not by the caller</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">const</span></td><td>argument is implicitly converted to a const type</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable</span></td><td>argument is implicitly converted to an immutable type</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">shared</span></td><td>argument is implicitly converted to a shared type</td></tr>
    <tr><td><span class="d_inlinecode donthyphenate notranslate">inout</span></td><td>argument is implicitly converted to an inout type</td></tr>
    </table></center>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x)
{
    <span class="d_comment">// x is set to int.init,
</span>    <span class="d_comment">// which is 0, at start of foo()
</span>}

<span class="d_keyword">int</span> a = 3;
foo(a);
<span class="d_comment">// a is now 0
</span>
<span class="d_keyword">void</span> abc(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x)
{
    x = 2;
}

<span class="d_keyword">int</span> y = 3;
abc(y);
<span class="d_comment">// y is now 2
</span>
<span class="d_keyword">void</span> def(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x)
{
    x += 1;
}

<span class="d_keyword">int</span> z = 3;
def(z);
<span class="d_comment">// z is now 4
</span></pre>
<div class="blankline"></div>
        <p>For dynamic array and object parameters, which are passed
        by reference, in/out/ref
        apply only to the reference and not the contents.
        </p>
<div class="blankline"></div>
        <p><span class="d_inlinecode donthyphenate notranslate">lazy</span> arguments are evaluated not when the function is called,
        but when the parameter is evaluated within the function. Hence,
        a <span class="d_inlinecode donthyphenate notranslate">lazy</span> argument can be executed 0 or more times. A <span class="d_inlinecode donthyphenate notranslate">lazy</span> parameter
        cannot be an lvalue.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> dotimes(<span class="d_keyword">int</span> n, <span class="d_keyword">lazy</span> <span class="d_keyword">void</span> exp)
{
    <span class="d_keyword">while</span> (n--)
        exp();
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> x;
    dotimes(3, writeln(x++));
}
</pre>
<div class="blankline"></div>
        <p>prints to the console:</p>
<div class="blankline"></div>
<pre class="console notranslate">0
1
2
</pre>
<div class="blankline"></div>
        <p>A <span class="d_inlinecode donthyphenate notranslate">lazy</span> parameter of type <span class="d_inlinecode donthyphenate notranslate">void</span> can accept an argument
        of any type.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="function-default-args" href="#function-default-args">Function Default Arguments</a></h4>
<div class="blankline"></div>
        <p>Function parameter declarations can have default values:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y = 3)
{
    ...
}
...
foo(4);   <span class="d_comment">// same as foo(4, 3);
</span></pre>
<div class="blankline"></div>
        <p>Default parameters are evaluated in the context of the
        function declaration.
        If the default value for a parameter is given, all following
        parameters must also have default values.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="return-ref-parameters" href="#return-ref-parameters">Return Ref Parameters</a></h4>
<div class="blankline"></div>
        <p>Note: The <span class="d_inlinecode donthyphenate notranslate">return</span> attribute is currently only enforced by <span class="d_inlinecode donthyphenate notranslate">dmd</span>
        when the <span class="d_inlinecode donthyphenate notranslate">-dip25</span> switch is passed.
        </p>
<div class="blankline"></div>
        <p>Return ref parameters are used with
        <a href="#ref-functions">ref functions</a> to ensure that the
        returned reference will not outlive the matching argument's lifetime.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">ref</span> <span class="d_keyword">int</span> identity(<span class="d_keyword">return</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) {
  <span class="d_keyword">return</span> x; <span class="d_comment">// pass-through function that does nothing
</span>}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> fun() {
  <span class="d_keyword">int</span> x;
  <span class="d_keyword">return</span> identity(x); <span class="d_comment">// Error: escaping reference to local variable x
</span>}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> gun(<span class="d_keyword">return</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) {
  <span class="d_keyword">return</span> identity(x); <span class="d_comment">// OK
</span>}
</pre>
<div class="blankline"></div>
        <p>Ref methods marked with the <span class="d_inlinecode donthyphenate notranslate">return</span> attribute ensure the returned
        reference will not outlive the respective aggregate instance.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">private</span> <span class="d_keyword">int</span> x;
    <span class="d_keyword">ref</span> <span class="d_keyword">int</span> get() <span class="d_keyword">return</span> { <span class="d_keyword">return</span> x; }
}

<span class="d_keyword">ref</span> <span class="d_keyword">int</span> escape()
{
    S s;
    <span class="d_keyword">return</span> s.get(); <span class="d_comment">// Error: escaping reference to local variable s
</span>}
</pre>
<div class="blankline"></div>
Template functions and lambdas can deduce the <span class="d_inlinecode donthyphenate notranslate">return</span> attribute.
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="variadic" href="#variadic">Variadic Functions</a></h3>
<div class="blankline"></div>
        Functions taking a variable number of arguments are called
        variadic functions. A variadic function can take one of
        three forms:
<div class="blankline"></div>
        <ol>        <li>C-style variadic functions</li>
        <li>Variadic functions with type info</li>
        <li>Typesafe variadic functions</li>
        </ol>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="c_style_cariadic_functions" href="#c_style_cariadic_functions">C-style Variadic Functions</a></h4>
<div class="blankline"></div>
        A C-style variadic function is declared as taking
        a parameter of ... after the required function parameters.
        It has non-D linkage, such as <span class="d_inlinecode donthyphenate notranslate">extern (C)</span>:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C) <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...);

foo(3, 4);      <span class="d_comment">// ok
</span>foo(3, 4, 6.8); <span class="d_comment">// ok, one variadic argument
</span>foo(2);         <span class="d_comment">// error, y is a required argument
</span></pre>
<div class="blankline"></div>
        There must be at least one non-variadic parameter declared.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> def(...); <span class="d_comment">// error, must have at least one parameter
</span></pre>
<div class="blankline"></div>
        <p>        C-style variadic functions match the C calling convention for
        variadic functions, and is most useful for calling C library
        functions like <span class="d_inlinecode donthyphenate notranslate">printf</span>.
    </p>
<div class="blankline"></div>
    <p>C-style variadic functions cannot be marked as <span class="d_inlinecode donthyphenate notranslate">@safe</span>.</p>
<div class="blankline"></div>
    <p>Access to variadic arguments is done using the standard library
    module <span class="d_inlinecode donthyphenate notranslate">core.stdc.stdarg</span>.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.stdc.stdarg;

<span class="d_keyword">void</span> test()
{
    foo(3, 4, 5);   <span class="d_comment">// first variadic argument is 5
</span>}

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{
    va_list args;

    va_start(args, y);  <span class="d_comment">// y is the last named parameter
</span>
    <span class="d_keyword">int</span> z;
    va_arg(args, z);  <span class="d_comment">// z is set to 5
</span>}
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="d_style_variadic_functions" href="#d_style_variadic_functions">D-style Variadic Functions</a></h4>
<div class="blankline"></div>
        Variadic functions with argument and type info are declared as taking
        a parameter of ... after the required function parameters.
        It has D linkage, and need not have any non-variadic parameters
        declared:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">char</span> c, ...);   <span class="d_comment">// one required parameter: c
</span><span class="d_keyword">int</span> def(...);           <span class="d_comment">// ok
</span></pre>
<div class="blankline"></div>
    To access them, the following import is required:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.vararg;
</pre>
<div class="blankline"></div>
        These variadic functions have a special local variable declared for
        them,
        <span class="d_inlinecode donthyphenate notranslate">_argptr</span>, which is a <span class="d_inlinecode donthyphenate notranslate">core.vararg</span>
    reference to the first of the variadic
        arguments. To access the arguments, <span class="d_inlinecode donthyphenate notranslate">_argptr</span> must be used
    in conjuction with <span class="d_inlinecode donthyphenate notranslate">va_arg</span>:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.vararg;

<span class="d_keyword">void</span> test()
{
    foo(3, 4, 5);   <span class="d_comment">// first variadic argument is 5
</span>}

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{
    <span class="d_keyword">int</span> z;

    z = va_arg!<span class="d_keyword">int</span>(_argptr); <span class="d_comment">// z is set to 5
</span>}
</pre>
<div class="blankline"></div>
        An additional hidden argument
        with the name <span class="d_inlinecode donthyphenate notranslate">_arguments</span> and type <span class="d_inlinecode donthyphenate notranslate">TypeInfo[]</span>
        is passed to the function.
        <span class="d_inlinecode donthyphenate notranslate">_arguments</span> gives the number of arguments and the type
        of each, enabling type safety to be checked at run time.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> core.vararg;

<span class="d_keyword">class</span> Foo { <span class="d_keyword">int</span> x = 3; }
<span class="d_keyword">class</span> Bar { <span class="d_keyword">long</span> y = 4; }

<span class="d_keyword">void</span> printargs(<span class="d_keyword">int</span> x, ...)
{
    writefln(<span class="d_string">"%d arguments"</span>, _arguments.length);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; _arguments.length; i++)
    {
        writeln(_arguments[i]);

        <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
        {
            <span class="d_keyword">int</span> j = va_arg!(<span class="d_keyword">int</span>)(_argptr);
            writefln(<span class="d_string">"\t%d"</span>, j);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
        {
            <span class="d_keyword">long</span> j = va_arg!(<span class="d_keyword">long</span>)(_argptr);
            writefln(<span class="d_string">"\t%d"</span>, j);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
        {
            <span class="d_keyword">double</span> d = va_arg!(<span class="d_keyword">double</span>)(_argptr);
            writefln(<span class="d_string">"\t%g"</span>, d);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(Foo))
        {
            Foo f = va_arg!(Foo)(_argptr);
            writefln(<span class="d_string">"\t%s"</span>, f);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(Bar))
        {
            Bar b = va_arg!(Bar)(_argptr);
            writefln(<span class="d_string">"\t%s"</span>, b);
        }
        <span class="d_keyword">else</span>
            <span class="d_keyword">assert</span>(0);
    }
}

<span class="d_keyword">void</span> main()
{
    Foo f = <span class="d_keyword">new</span> Foo();
    Bar b = <span class="d_keyword">new</span> Bar();

    writefln(<span class="d_string">"%s"</span>, f);
    printargs(1, 2, 3L, 4.5, f, b);
}
</pre>
<div class="blankline"></div>
        which prints:
<div class="blankline"></div>
<pre class="d_code notranslate">0x00870FE0
5 arguments
<span class="d_keyword">int</span>
        2
<span class="d_keyword">long</span>
        3
<span class="d_keyword">double</span>
        4.5
Foo
        0x00870FE0
Bar
        0x00870FD0
</pre>
<div class="blankline"></div>
    <p>D-style variadic functions cannot be marked as <span class="d_inlinecode donthyphenate notranslate">@safe</span>.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="typesafe_variadic_functions" href="#typesafe_variadic_functions">Typesafe Variadic Functions</a></h4>
<div class="blankline"></div>
        <p>Typesafe variadic functions are used when the variable argument
        portion of the arguments are used to construct an array or
        class object.</p>
<div class="blankline"></div>
        <p>For arrays:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> test()
{
    <span class="d_keyword">return</span> sum(1, 2, 3) + sum(); <span class="d_comment">// returns 6+0
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">return</span> sum(ii);             <span class="d_comment">// returns 15
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
        s += x;
    <span class="d_keyword">return</span> s;
}
</pre>
<div class="blankline"></div>
        For static arrays:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> test()
{
    <span class="d_keyword">return</span> sum(2, 3);   <span class="d_comment">// error, need 3 values for array
</span>    <span class="d_keyword">return</span> sum(1, 2, 3); <span class="d_comment">// returns 6
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">int</span>[] jj = ii;
    <span class="d_keyword">return</span> sum(ii); <span class="d_comment">// returns 15
</span>    <span class="d_keyword">return</span> sum(jj); <span class="d_comment">// error, type mismatch
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[3] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
        s += x;
    <span class="d_keyword">return</span> s;
}
</pre>
<div class="blankline"></div>
        For class objects:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">int</span> x;
    string s;

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x, string s)
    {
        <span class="d_keyword">this</span>.x = x;
        <span class="d_keyword">this</span>.s = s;
    }
}

<span class="d_keyword">void</span> test(<span class="d_keyword">int</span> x, Foo f ...);

...

Foo g = <span class="d_keyword">new</span> Foo(3, <span class="d_string">"abc"</span>);
test(1, g);         <span class="d_comment">// ok, since g is an instance of Foo
</span>test(1, 4, <span class="d_string">"def"</span>);  <span class="d_comment">// ok
</span>test(1, 5);         <span class="d_comment">// error, no matching constructor for Foo
</span></pre>
<div class="blankline"></div>
        An implementation may construct the object or array instance
        on the stack. Therefore, it is an error to refer to that
        instance after the variadic function has returned:
<div class="blankline"></div>
<pre class="d_code notranslate">Foo test(Foo f ...)
{
    <span class="d_keyword">return</span> f;   <span class="d_comment">// error, f instance contents invalid after return
</span>}

<span class="d_keyword">int</span>[] test(<span class="d_keyword">int</span>[] a ...)
{
    <span class="d_keyword">return</span> a;       <span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a[0..1]; <span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a.dup;   <span class="d_comment">// ok, since copy is made
</span>}
</pre>
<div class="blankline"></div>
        For other types, the argument is built with itself, as in:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> test(<span class="d_keyword">int</span> i ...)
{
    <span class="d_keyword">return</span> i;
}

...
test(3);    <span class="d_comment">// returns 3
</span>test(3, 4); <span class="d_comment">// error, too many arguments
</span><span class="d_keyword">int</span>[] x;
test(x);    <span class="d_comment">// error, type mismatch
</span></pre>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="lazy_variadic_functions" href="#lazy_variadic_functions">Lazy Variadic Functions</a></h4>
<div class="blankline"></div>
        <p>If the variadic parameter is an array of delegates
        with no parameters:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>()[] dgs ...);
</pre>
<div class="blankline"></div>
        <p>Then each of the arguments whose type does not match that
        of the delegate is converted to a delegate.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
foo(1, 3+x, dg, <span class="d_keyword">cast</span>(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>())<span class="d_keyword">null</span>);
</pre>
<div class="blankline"></div>
        <p>is the same as:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">foo( { <span class="d_keyword">return</span> 1; }, { <span class="d_keyword">return</span> 3+x; }, dg, <span class="d_keyword">null</span> );
</pre>
<div class="blankline"></div>
<h3><span id="Local Variables"><a class="anchor" title="Permalink to this section" id="local-variables" href="#local-variables">Local Variables</a></span></h3>
<div class="blankline"></div>
        <p>It is an error to use a local variable without first assigning it a
        value. The implementation may not always be able to detect these
        cases. Other language compilers sometimes issue a warning for this,
        but since it is always a bug, it should be an error.
        </p>
<div class="blankline"></div>
        <p>It is an error to declare a local variable that hides another local
        variable in the same function:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> func(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">int</span> x;       <span class="d_comment">// error, hides previous definition of x
</span>    <span class="d_keyword">double</span> y;
    ...
    {
        <span class="d_keyword">char</span> y;  <span class="d_comment">// error, hides previous definition of y
</span>        <span class="d_keyword">int</span> z;
    }
    {
        <span class="d_keyword">wchar</span> z; <span class="d_comment">// legal, previous z is out of scope
</span>    }
}
</pre>
<div class="blankline"></div>
        <p>While this might look unreasonable, in practice whenever
        this is done it either is a
        bug or at least looks like a bug.
        </p>
<div class="blankline"></div>
        <p>It is an error to return the address of or a reference to a
        local variable.
        </p>
<div class="blankline"></div>
        <p>It is an error to have a local variable and a label with the same
        name.
        </p>
<div class="blankline"></div>
<h3><span id="Local Static Variables"><a class="anchor" title="Permalink to this section" id="local-static-variables" href="#local-static-variables">Local Static Variables</a></span></h3>
<div class="blankline"></div>
    <p>Local variables in functions can be declared as static
    or <span class="d_inlinecode donthyphenate notranslate">__gshared</span> in which case they are statically allocated
    rather than being allocated on the stack.
    As such, their value persists beyond the exit of the function.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> n;
    <span class="d_keyword">if</span> (++n == 100)
        writeln(<span class="d_string">"called 100 times"</span>);
}
</pre>
<div class="blankline"></div>
    <p>The initializer for a static variable must be evaluatable at
    compile time, and they are initialized upon the start of the thread
    (or the start of the program for <span class="d_inlinecode donthyphenate notranslate">__gshared</span>).
    There are no static constructors or static destructors
    for static local variables.
    </p>
<div class="blankline"></div>
    <p>Although static variable name visibility follows the usual scoping
    rules, the names of them must be unique within a particular function.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    { <span class="d_keyword">static</span> <span class="d_keyword">int</span> x; }
    { <span class="d_keyword">static</span> <span class="d_keyword">int</span> x; } <span class="d_comment">// error
</span>    { <span class="d_keyword">int</span> i; }
    { <span class="d_keyword">int</span> i; } <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="nested" href="#nested">Nested Functions</a></h3>
<div class="blankline"></div>
        <p>Functions may be nested within other functions:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> 1; }

        <span class="d_keyword">return</span> b + abc();
    }
    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3); <span class="d_comment">// i is assigned 4
</span>}
</pre>
<div class="blankline"></div>
        <p>Nested functions can be accessed only if the name is in scope.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">void</span> A()
    {
        B(); <span class="d_comment">// error, B() is forward referenced
</span>        C(); <span class="d_comment">// error, C undefined
</span>    }
    <span class="d_keyword">void</span> B()
    {
        A(); <span class="d_comment">// ok, in scope
</span>        <span class="d_keyword">void</span> C()
        {
            <span class="d_keyword">void</span> D()
            {
                A();      <span class="d_comment">// ok
</span>                B();      <span class="d_comment">// ok
</span>                C();      <span class="d_comment">// ok
</span>                D();      <span class="d_comment">// ok
</span>            }
        }
    }
    A(); <span class="d_comment">// ok
</span>    B(); <span class="d_comment">// ok
</span>    C(); <span class="d_comment">// error, C undefined
</span>}
</pre>
<div class="blankline"></div>
        <p>and:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> b + 1; }
    <span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> foo(b); }   <span class="d_comment">// ok
</span>    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);     <span class="d_comment">// ok
</span>    <span class="d_keyword">int</span> j = bar.foo(3); <span class="d_comment">// error, bar.foo not visible
</span>}
</pre>
<div class="blankline"></div>
        <p>Nested functions have access to the variables and other symbols
        defined by the lexically enclosing function.
        This access includes both the ability to read and write them.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        b += c;       <span class="d_comment">// 4 is added to b
</span>        c++;          <span class="d_comment">// bar.c is now 5
</span>        <span class="d_keyword">return</span> b + c; <span class="d_comment">// 12 is returned
</span>    }
    c = 4;
    <span class="d_keyword">int</span> i = foo(a); <span class="d_comment">// i is set to 12
</span>    <span class="d_keyword">return</span> i + c;   <span class="d_comment">// returns 17
</span>}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3); <span class="d_comment">// i is assigned 17
</span>}
</pre>
<div class="blankline"></div>
        <p>This access can span multiple nesting levels:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        <span class="d_keyword">int</span> abc()
        {
            <span class="d_keyword">return</span> c;   <span class="d_comment">// access bar.c
</span>        }
        <span class="d_keyword">return</span> b + c + abc();
    }
    <span class="d_keyword">return</span> foo(3);
}
</pre>
<div class="blankline"></div>
        <p>Static nested functions cannot access any stack variables of
        any lexically enclosing function, but can access static variables.
        This is analogous to how static member functions behave.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> c;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> d;

    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
        b = d;          <span class="d_comment">// ok
</span>        b = c;          <span class="d_comment">// error, foo() cannot access frame of bar()
</span>        <span class="d_keyword">return</span> b + 1;
    }
    <span class="d_keyword">return</span> foo(a);
}
</pre>
<div class="blankline"></div>
        <p>Functions can be nested within member functions:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
    <span class="d_keyword">int</span> a;

    <span class="d_keyword">int</span> bar()
    {
        <span class="d_keyword">int</span> c;

        <span class="d_keyword">int</span> foo()
        {
            <span class="d_keyword">return</span> c + a;
        }
        <span class="d_keyword">return</span> 0;
    }
}
</pre>
<div class="blankline"></div>
        <p>Nested functions always have the D function linkage type.
        </p>
<div class="blankline"></div>
        <p>Unlike module level declarations, declarations within function
        scope are processed in order. This means that two nested functions
        cannot mutually call each other:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> foo() { bar(); } <span class="d_comment">// error, bar not defined
</span>    <span class="d_keyword">void</span> bar() { foo(); } <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
        <p>There are several workarounds for this limitation:</p>
<div class="blankline"></div>
<ul><div class="blankline"></div>
        <li>Declare the functions to be static members of a nested struct:</li>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">struct</span> S
    {
        <span class="d_keyword">static</span> <span class="d_keyword">void</span> foo() { bar(); } <span class="d_comment">// ok
</span>        <span class="d_keyword">static</span> <span class="d_keyword">void</span> bar() { foo(); } <span class="d_comment">// ok
</span>    }

    S.foo();  <span class="d_comment">// compiles (but note the infinite runtime loop)
</span>}
</pre>
<div class="blankline"></div>
        <li>Declare one or more of the functions to be function templates
        even if they take no specific template arguments:</li>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> foo()() { bar(); } <span class="d_comment">// ok (foo is a function template)
</span>    <span class="d_keyword">void</span> bar()   { foo(); } <span class="d_comment">// ok
</span>}
</pre>
<div class="blankline"></div>
        <li>Declare the functions inside of a mixin template:</li>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">mixin</span> <span class="d_keyword">template</span> T()
{
    <span class="d_keyword">void</span> foo() { bar(); } <span class="d_comment">// ok
</span>    <span class="d_keyword">void</span> bar() { foo(); } <span class="d_comment">// ok
</span>}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">mixin</span> T!();
}
</pre>
<div class="blankline"></div>
        <li>Use a delegate:</li>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() fp;
    <span class="d_keyword">void</span> foo() { fp(); }
    <span class="d_keyword">void</span> bar() { foo(); }
    fp = &amp;bar;
}
</pre>
<div class="blankline"></div>
    </ul>
<div class="blankline"></div>
    <p>Nested functions cannot be overloaded.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="closures" href="#closures">Delegates, Function Pointers, and  Closures</a></h4>
<div class="blankline"></div>
        <p>A function pointer can point to a static nested function:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    fp = &amp;foo;
}

<span class="d_keyword">void</span> bar()
{
    test();
    <span class="d_keyword">int</span> i = fp();       <span class="d_comment">// i is set to 10
</span>}
</pre>
<div class="blankline"></div>
        <p><b>Note:</b> Two functions with identical bodies, or two functions
        that compile to identical assembly code, are not guaranteed to have
        distinct function pointer values. The compiler is free to merge
        functions bodies into one if they compile to identical code.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x + 1; }
<span class="d_keyword">int</span> def(<span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> y + 1; }

<span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp1 = &amp;abc;
<span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp2 = &amp;def;
<span class="d_comment">// Do not rely on fp1 and fp2 being different values; the compiler may merge
</span><span class="d_comment">// them.
</span></pre>
<div class="blankline"></div>
        <p>A delegate can be set to a non-static nested function:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    dg = &amp;foo;
    <span class="d_keyword">int</span> i = dg(); <span class="d_comment">// i is set to 10
</span>}
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>The stack variables referenced by a nested function are
        still valid even after the function exits (this is different
        from D 1.0). This is called a <i>closure</i>.
        Returning addresses of stack variables, however, is not
        a closure and is an error.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>* bar()
{
    <span class="d_keyword">int</span> b;
    test();
    <span class="d_keyword">int</span> i = dg(); <span class="d_comment">// ok, test.a is in a closure and still exists
</span>    <span class="d_keyword">return</span> &amp;b;    <span class="d_comment">// error, bar.b not valid after bar() exits
</span>}
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>Delegates to non-static nested functions contain two pieces of
        data: the pointer to the stack frame of the lexically enclosing
        function (called the <i>frame pointer</i>) and the address of the
        function. This is analogous to struct/class non-static member
        function delegates consisting of a <i>this</i> pointer and
        the address of the member function.
        Both forms of delegates are interchangeable, and are actually
        the same type:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> Foo
{
    <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> a; }
}

<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg)
{
    <span class="d_keyword">return</span> dg() + 1;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> x = 27;
    <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> x; }
    Foo f;
    <span class="d_keyword">int</span> i;

    i = foo(&amp;abc);   <span class="d_comment">// i is set to 28
</span>    i = foo(&amp;f.bar); <span class="d_comment">// i is set to 8
</span>}
</pre>
<div class="blankline"></div>
        <p>This combining of the environment and the function is called
        a <i>dynamic closure</i>.
        </p>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">.ptr</span> property of a delegate will return the
        <i>frame pointer</i> value as a <span class="d_inlinecode donthyphenate notranslate">void*</span>.
        </p>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">.funcptr</span> property of a delegate will return the
        <i>function pointer</i> value as a function type.
        </p>
<div class="blankline"></div>
        <p><b>Future directions:</b> Function pointers and delegates may merge
        into a common syntax and be interchangeable with each other.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="anonymous" href="#anonymous">Anonymous Functions and Anonymous Delegates</a></h4>
<div class="blankline"></div>
        <p>See <a href="../spec/expression.html#FunctionLiteral"><i>FunctionLiteral</i></a>s.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="main" href="#main"><span class="d_inlinecode donthyphenate notranslate">main()</span> Function</a></h3>
<div class="blankline"></div>
        <p>For console programs, <span class="d_inlinecode donthyphenate notranslate">main()</span> serves as the entry point.
        It gets called after all the module initializers are run, and
        after any unittests are run.
        After it returns, all the module destructors are run.
        <span class="d_inlinecode donthyphenate notranslate">main()</span> must be declared using one of the following forms:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main() { ... }
<span class="d_keyword">void</span> main(string[] args) { ... }
<span class="d_keyword">int</span> main() { ... }
<span class="d_keyword">int</span> main(string[] args) { ... }
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function-templates" href="#function-templates">Function Templates</a></h3>
<div class="blankline"></div>
    <p>Template functions are useful for avoiding code duplication -
    instead of writing several copies of a function, each with a
    different parameter type, a single function template can be sufficient.
    For example:
    </p>
<pre class="d_code notranslate"><span class="d_comment">// Only one copy of func needs to be written
</span><span class="d_keyword">void</span> func(T)(T x)
{
    writeln(x);
}

<span class="d_keyword">void</span> main()
{
    func!(<span class="d_keyword">int</span>)(1); <span class="d_comment">// pass an int
</span>    func(1);    <span class="d_comment">// pass an int, inferring T = int
</span>    func(<span class="d_string">"x"</span>);  <span class="d_comment">// pass a string
</span>    func(1.0);  <span class="d_comment">// pass a float
</span>
    <span class="d_keyword">struct</span> S {}
    S s;
    func(s);    <span class="d_comment">// pass a struct
</span>}
</pre>
    <p><span class="d_inlinecode donthyphenate notranslate">func</span> takes a template parameter <span class="d_inlinecode donthyphenate notranslate">T</span> and a runtime
    parameter, <span class="d_inlinecode donthyphenate notranslate">x</span>. <span class="d_inlinecode donthyphenate notranslate">T</span> is a placeholder identifier that can accept
    any type. In this case <span class="d_inlinecode donthyphenate notranslate">T</span> can be inferred from the runtime argument
    type.</p>
<div class="blankline"></div>
    <p><b>Note:</b> Using the name <span class="d_inlinecode donthyphenate notranslate">T</span> is just a convention. The name
    <span class="d_inlinecode donthyphenate notranslate">TypeOfX</span> could have been used instead.</p>
<div class="blankline"></div>
    <p>For more information, see
    <a href="../spec/template.html#function-templates">function templates</a>.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="interpretation" href="#interpretation">Compile Time Function Execution (CTFE)</a></h3>
<div class="blankline"></div>
    <p>Functions which are both portable and free of side-effects can be
    executed at compile time. This is useful when constant folding
    algorithms need to include recursion and looping. Compile time function
    execution is subject to the following restrictions:
    </p>
<div class="blankline"></div>
    <ol>    <li>The function source code must be available to the compiler. Functions
        which exist in the source code only as <span class="d_keyword">extern</span> declarations
        cannot be executed at compile time.</li>
<div class="blankline"></div>
    <li>Executed expressions may not reference any global or local
        static variables.</li>
<div class="blankline"></div>
    <li><span class="d_keyword">asm</span> statements are not permitted</li>
<div class="blankline"></div>
    <li>Non-portable casts (eg, from <span class="d_inlinecode donthyphenate notranslate">int[]</span> to <span class="d_inlinecode donthyphenate notranslate">float[]</span>), including
        casts which depend on endianness, are not permitted.
        Casts between signed and unsigned types are permitted</li>
    <li>Reinterpretation of overlapped fields in a Union.</li>
    </ol>
<div class="blankline"></div>
    <p>Pointers are permitted in CTFE, provided they are used safely:</p>
<div class="blankline"></div>
    <ul>        <li>        C-style semantics on pointer arithmetic are strictly enforced.
        Pointer arithmetic is permitted only on pointers which point to static
        or dynamic array elements. Such pointers must point to an element of
        the array, or to the first element past the array.
        Pointer arithmetic is completely forbidden on pointers which are null,
        or which point to a non-array.
        </li>
<div class="blankline"></div>
        <li>        The memory location of different memory blocks is not defined.
        Ordered comparison (<span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;=</span>) between two pointers is permitted
        when both pointers point to the same array, or when at least one
        pointer is <span class="d_inlinecode donthyphenate notranslate">null</span>.
        </li>
<div class="blankline"></div>
        <li>        Pointer comparisons between independent memory blocks will generate
        a compile-time error, unless two such comparisons are combined
        using <span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> or <span class="d_inlinecode donthyphenate notranslate">|</span><span class="d_inlinecode donthyphenate notranslate">|</span> to yield a result which is independent of the
        ordering of memory blocks. Each comparison must consist of two pointer
        expressions compared with <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span>,
        or <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, and may optionally be
        negated with <span class="d_inlinecode donthyphenate notranslate">!</span>.
<div class="blankline"></div>
        <p>        For example, the expression <span class="d_inlinecode donthyphenate notranslate">(p1 &gt; q1 &amp;&amp; p2 &lt;= q2)</span>
        is permitted when <span class="d_inlinecode donthyphenate notranslate">p1</span>, <span class="d_inlinecode donthyphenate notranslate">p2</span> are expressions yielding pointers
        to memory block <i>P</i>, and <span class="d_inlinecode donthyphenate notranslate">q1</span>, <span class="d_inlinecode donthyphenate notranslate">q2</span> are expressions yielding
        pointers to memory block <i>Q</i>, even when <i>P</i> and <i>Q</i> are
        unrelated memory blocks.
        It returns true if <span class="d_inlinecode donthyphenate notranslate">[p1..p2]</span> lies inside <span class="d_inlinecode donthyphenate notranslate">[q1..q2]</span>, and false otherwise.
        Similarly, the expression <span class="d_inlinecode donthyphenate notranslate">(p1 &lt; q1 || p2 &gt; q2)</span> is true if
        <span class="d_inlinecode donthyphenate notranslate">[p1..p2]</span> lies outside <span class="d_inlinecode donthyphenate notranslate">[q1..q2]</span>, and false otherwise.
        </p>
        </li>
<div class="blankline"></div>
        <li>        Equality comparisons (==, !=, <span class="d_keyword">is</span>, <span class="d_keyword">!is</span>) are
        permitted between all pointers, without restriction.
        </li>
<div class="blankline"></div>
        <li>        Any pointer may be cast to <span class="d_inlinecode donthyphenate notranslate">void *</span> and from <span class="d_inlinecode donthyphenate notranslate">void *</span> back to
        its original type. Casting between pointer and non-pointer types is
        prohibited.
        </li>
    </ul>
<div class="blankline"></div>
    <p>Note that the above restrictions apply only to expressions which are
        actually executed. For example:
    </p>
<pre class="d_code notranslate"><span class="d_keyword">static</span> <span class="d_keyword">int</span> y = 0;

<span class="d_keyword">int</span> countTen(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">if</span> (x &gt; 10)
        ++y;
    <span class="d_keyword">return</span> x;
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(countTen(6) == 6); <span class="d_comment">// OK
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(countTen(12) == 12);  <span class="d_comment">// invalid, modifies y.
</span></pre>
    <p>The <span class="d_inlinecode donthyphenate notranslate">__ctfe</span> boolean pseudo-variable, which evaluates to <span class="d_keyword">true</span>
        at compile time, but <span class="d_keyword">false</span> at run time, can be used to provide
        an alternative execution path to avoid operations which are forbidden
        at compile time. Every usage of <span class="d_inlinecode donthyphenate notranslate">__ctfe</span> is evaluated before
        code generation and therefore has no run-time cost, even if no optimizer
        is used.
    </p>
<div class="blankline"></div>
<div class="blankline"></div>
    <p>In order to be executed at compile time, the function
    must appear in a context where it must be so executed, for
    example:</p>
<div class="blankline"></div>
    <ul>    <li>initialization of a static variable</li>
    <li>dimension of a static array</li>
    <li>argument for a template value parameter</li>
    </ul>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">template</span> eval( A... )
{
    <span class="d_keyword">const</span> <span class="d_keyword">typeof</span>(A[0]) eval = A[0];
}

<span class="d_keyword">int</span> square(<span class="d_keyword">int</span> i)
{
    <span class="d_keyword">return</span> i * i;
}

<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> j = square(3);     <span class="d_comment">// compile time
</span>    writeln(j);
    writeln(square(4));      <span class="d_comment">// run time
</span>    writeln(eval!(square(5))); <span class="d_comment">// compile time
</span>}
</pre>
<div class="blankline"></div>
    <p>Executing functions at compile time can take considerably
    longer than executing it at run time.
    If the function goes into an infinite loop, it will hang at
    compile time (rather than hanging at run time).
    </p>
<div class="blankline"></div>
    <p>Non-recoverable errors (such as <span class="d_keyword">assert</span> failures) do not
    throw exceptions; instead, they end interpretation immediately.
    </p>
<div class="blankline"></div>
    <p>Functions executed at compile time can give different results
    from run time in the following scenarios:
    </p>
<div class="blankline"></div>
    <ul><div class="blankline"></div>
    <li>floating point computations may be done at a higher
    precision than run time</li>
    <li>dependency on implementation defined order of evaluation</li>
    <li>use of uninitialized variables</li>
<div class="blankline"></div>
    </ul>
<div class="blankline"></div>
    <p>These are the same kinds of scenarios where different
    optimization settings affect the results.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="string-mixins" href="#string-mixins">String Mixins and Compile Time Function Execution</a></h4>
<div class="blankline"></div>
        <p>Any functions that execute at compile time must also
        be executable at run time. The compile time evaluation of
        a function does the equivalent of running the function at
        run time. This means that the semantics of a function cannot
        depend on compile time values of the function. For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">char</span>[] s)
{
    <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(s);
}

<span class="d_keyword">const</span> <span class="d_keyword">int</span> x = foo(<span class="d_string">"1"</span>);
</pre>
<div class="blankline"></div>
        <p>is illegal, because the runtime code for foo() cannot be
        generated. A function template would be the appropriate
        method to implement this sort of thing.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function-safety" href="#function-safety">Function Safety</a></h3>
<div class="blankline"></div>
        <p><i>Safe functions</i> are functions that are statically checked
        to exhibit no possibility of
        <a href="../glossary.html#undefined_behavior"><i>undefined behavior</i></a>.
        Undefined behavior is often used as a vector for malicious
        attacks.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="safe-functions" href="#safe-functions">Safe Functions</a></h4>
<div class="blankline"></div>
        <p>Safe functions are marked with the <span class="d_inlinecode donthyphenate notranslate">@safe</span> attribute.</p>
<div class="blankline"></div>
        <p>The following operations are not allowed in safe
        functions:</p>
<div class="blankline"></div>
        <ul>        <li>No casting from a pointer type to any type other than <span class="d_inlinecode donthyphenate notranslate">void*</span>.</li>
        <li>No casting from any non-pointer type to a pointer type.</li>
        <li>No modification of pointer values.</li>
        <li>Cannot access unions that have pointers or references overlapping
        with other types.</li>
        <li>Calling any system functions.</li>
        <li>No catching of exceptions that are not derived from <span class="d_inlinecode donthyphenate notranslate">class Exception</span>.</li>
        <li>No inline assembler.</li>
        <li>No explicit casting of mutable objects to immutable.</li>
        <li>No explicit casting of immutable objects to mutable.</li>
        <li>No explicit casting of thread local objects to shared.</li>
        <li>No explicit casting of shared objects to thread local.</li>
        <li>No taking the address of a local variable or function parameter.</li>
        <li>Cannot access <span class="d_inlinecode donthyphenate notranslate">__gshared</span> variables.</li>
        </ul>
<div class="blankline"></div>
        <p>Functions nested inside safe functions default to being
        safe functions.
        </p>
<div class="blankline"></div>
        <p>Safe functions are covariant with trusted or system functions.</p>
<div class="blankline"></div>
        <p><b>Note:</b> The verifiable safety of functions may be compromised by
        bugs in the compiler and specification. Please report all such errors
        so they can be corrected.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="trusted-functions" href="#trusted-functions">Trusted Functions</a></h4>
<div class="blankline"></div>
        <p>Trusted functions are marked with the <span class="d_inlinecode donthyphenate notranslate">@trusted</span> attribute.</p>
<div class="blankline"></div>
        <p>Trusted functions are guaranteed by the programmer to not exhibit
        any undefined behavior if called by a safe function.
        Generally, trusted functions should be kept small so that they are
        easier to manually verify.
        </p>
<div class="blankline"></div>
        <p>Trusted functions may call safe, trusted, or system functions.
        </p>
<div class="blankline"></div>
        <p>Trusted functions are covariant with safe or system functions.</p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="system-functions" href="#system-functions">System Functions</a></h4>
<div class="blankline"></div>
        <p>System functions are functions not marked with <span class="d_inlinecode donthyphenate notranslate">@safe</span> or
        <span class="d_inlinecode donthyphenate notranslate">@trusted</span>
        and are not nested inside <span class="d_inlinecode donthyphenate notranslate">@safe</span> functions.
        System functions may be marked with the <span class="d_inlinecode donthyphenate notranslate">@system</span> attribute.
        A function being system does not mean it actually is unsafe, it just
        means that the compiler is unable to verify that it cannot exhibit
        undefined behavior.
        </p>
<div class="blankline"></div>
        <p>System functions are <b>not</b> covariant with trusted or safe functions.
        </p>
<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function-attribute-inference" href="#function-attribute-inference">Function Attribute Inference</a></h3>
<div class="blankline"></div>
        <p><a href="../spec/expression.html#FunctionLiteral"><i>FunctionLiteral</i></a>s and
        <a href="../spec/template.html#function-templates">function template</a>s, since their function bodies
        are always present, infer the
        <a href="#pure-functions"><span class="d_inlinecode donthyphenate notranslate">pure</span></a>,
        <a href="#nothrow-functions"><span class="d_inlinecode donthyphenate notranslate">nothrow</span></a>,
        <a href="#safe-functions"><span class="d_inlinecode donthyphenate notranslate">@safe</span></a>, and
        <a href="attribute.html#nogc"><span class="d_inlinecode donthyphenate notranslate">@nogc</span></a> attributes unless
        specifically overridden.
        </p>
<div class="blankline"></div>
        <p>Attribute inference is not done for other functions, even if the function
        body is present.
        </p>
<div class="blankline"></div>
        <p>The inference is done by determining if the function body follows the
        rules of the particular attribute.
        </p>
<div class="blankline"></div>
        <p>Cyclic functions (i.e. functions that wind up directly or indirectly
        calling themselves) are inferred as being impure, throwing, and @system.
        </p>
<div class="blankline"></div>
        <p>If a function attempts to test itself for those attributes, then
        the function is inferred as not having those attributes.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="pseudo-member" href="#pseudo-member">Uniform Function Call Syntax (UFCS)</a></h3>
<div class="blankline"></div>
        <p>A free function can be called with a syntax that looks as if the function
        were a member function of its first parameter type.
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> func(X thisObj);

X obj;
obj.func();
<span class="d_comment">// If 'obj' does not have regular member 'func',
</span><span class="d_comment">// it's automatically rewritten to 'func(obj)'
</span></pre>
<div class="blankline"></div>
    <p>This provides a way to add functions to a class externally as if they were
    public final member functions, which enables
    <a href="http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321">    function chaining and component programming</a>.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate">stdin.byLine(KeepTerminator.yes)
    .map!(a =&gt; a.idup)
    .array
    .sort
    .copy(stdout.lockingTextWriter());
</pre>
<div class="blankline"></div>
        <p>It also works with <span class="d_inlinecode donthyphenate notranslate">@property</span> functions:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">@property prop(X thisObj);
@property prop(X thisObj, <span class="d_keyword">int</span> value);

X obj;
obj.prop;      <span class="d_comment">// Rewrites to: prop(obj);
</span>obj.prop = 1;  <span class="d_comment">// Rewrites to: prop(obj, 1);
</span></pre>
<div class="blankline"></div>
        <p>Syntactically parenthesis-less check for <span class="d_inlinecode donthyphenate notranslate">@property</span>
        functions is done at the same time as UFCS rewrite.</p>
<div class="blankline"></div>
        <p>When UFCS rewrite is necessary, compiler searches the name
        on accessible module level scope, in order from the innermost scope.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">module</span> a;
<span class="d_keyword">void</span> foo(X);
<span class="d_keyword">alias</span> boo = foo;
<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">void</span> bar(X);
    <span class="d_keyword">import</span> b : baz;  <span class="d_comment">// void baz(X);
</span>
    X obj;
    obj.foo();    <span class="d_comment">// OK, calls a.foo;
</span>    <span class="d_comment">//obj.bar();  // NG, UFCS does not see nested functions
</span>    obj.baz();    <span class="d_comment">// OK, calls b.baz, because it is declared at the
</span>                  <span class="d_comment">// top level scope of module b
</span>
    <span class="d_keyword">import</span> b : boo = baz;
    obj.boo();    <span class="d_comment">// OK, calls aliased b.baz instead of a.boo (== a.foo),
</span>                  <span class="d_comment">// because the declared alias name 'boo' in local scope
</span>                  <span class="d_comment">// overrides module scope name
</span>}
<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> mfoo(X);
    <span class="d_keyword">static</span> <span class="d_keyword">void</span> sbar(X);
    <span class="d_keyword">import</span> b : ibaz = baz;  <span class="d_comment">// void baz(X);
</span>    <span class="d_keyword">void</span> test()
    {
        X obj;
        <span class="d_comment">//obj.mfoo();  // NG, UFCS does not see member functions
</span>        <span class="d_comment">//obj.sbar();  // NG, UFCS does not see static member functions
</span>        obj.ibaz();    <span class="d_comment">// OK, ibaz is an alias of baz which declared at
</span>                       <span class="d_comment">//     the top level scope of module b
</span>    }
}
</pre>
<div class="blankline"></div>
        <p>The reason why local symbols are not considered by UFCS, is
        to avoid unexpected name conflicts. See below problematic examples.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> front(<span class="d_keyword">int</span>[] arr) { <span class="d_keyword">return</span> arr[0]; }

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[] a = [1,2,3];
    <span class="d_keyword">auto</span> x = a.front();   <span class="d_comment">// call .front by UFCS
</span>
    <span class="d_keyword">auto</span> front = x;       <span class="d_comment">// front is now a variable
</span>    <span class="d_keyword">auto</span> y = a.front();   <span class="d_comment">// Error, front is not a function
</span>}

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span>[] arr;
    <span class="d_keyword">int</span> front()
    {
        <span class="d_keyword">return</span> arr.front(); <span class="d_comment">// Error, C.front is not callable
</span>                            <span class="d_comment">// using argument types (int[])
</span>    }
}
</pre>
<div class="blankline"></div>

<div style="float: left"><i class="fa fa-angle-left" aria-hidden="true"></i> <a href="../spec/const3.html">Type Qualifiers</a></div>
<div style="float: right"><a href="../spec/operatoroverloading.html">Operator Overloading</a> <i class="fa fa-angle-right" aria-hidden="true"></i></div>
<div style="clear:both"></div>



        <div class="smallprint" id="copyright">Copyright &copy; 1999-2017 by the <a href="../foundation.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Wed Jul 19 22:20:28 2017
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Bit Operations - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Bit Operations' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BBit Operations%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/bit_operations.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Bit Operations</h1>
        
        



<p>This chapter covers operations on bits, the smallest data units. Bit operations are among the most fundamental features of microprocessors.
</p>

<p>System programmers must understand bit operations at least to use <i>flag</i> parameters correctly.
</p>

<h5 class="subsection">Representation of data at the lowest level</h5>

<p>Programming languages are abstractions. A user type like <code class="d_inline">Student</code> defined in a programming language is not directly related to the internals of the computer. Programming languages are tools that help humans use the hardware without needing to know the details of the hardware.
</p>

<p>Although it is usually not necessary to deal with the hardware directly, it is helpful to understand how data is represented at hardware level.
</p>

<h6><a id="ix_Bit Operations.transistor" content="transistor"></a> Transistor</h6>

<p>The processing abilities of modern electronic devices are mostly based on the electronic element called <i>the transistor</i>. A significant ability of the transistor is that it can be controlled by other parts of the electronic circuit that the transistor is a part of. In a way, it allows the electronic circuit be aware of itself and be able to change its own state.
</p>

<h6><a id="ix_Bit Operations.bit" content="bit"></a> Bit</h6>

<p>The smallest unit of information is a bit. A bit can be represented by any two-state system (e.g. by a special arrangement of a few transistors of an electronic circuit). A bit can have one of two values: 0 or 1. In the computer's memory, the information that is stored in a bit persists until a new value is stored or until the energy source is disconnected.
</p>

<p>Computers do not provide direct access to bits. One reason is that doing so would complicate the design of the computer and as a consequence make the computer more expensive. Another reason is that there are not many concepts that can be represented by a single bit.
</p>

<h6><a id="ix_Bit Operations.byte" content="byte"></a> Byte</h6>

<p>A byte is a combination of 8 bits. The smallest unit of information that can be addressed uniquely is a byte. Computers read from or write to memory at least one byte at a time.
</p>

<p>For that reason, although it carries one bit of information (<code class="d_inline">false</code> or <code class="d_inline">true</code>), even <code class="d_inline">bool</code> must be implemented as one byte:
</p>

<pre class="d_code">    writefln(<span class="d_string">"%s is %s byte(s)"</span>, <span class="d_keyword">bool</span>.stringof, <span class="d_keyword">bool</span>.sizeof);
</pre>

<pre class="shell">bool is 1 byte(s)
</pre>

<h6><a id="ix_Bit Operations.register, CPU" content="register, CPU"></a> Register</h6>

<p>Data that are being operated on in a microprocessor are stored in registers. Registers provide very limited but very fast operations.
</p>

<p>The size of the registers depend on the architecture of the microprocessor. For example, 32-bit microprocessors commonly have 4-byte registers and 64-bit microprocessors commonly have 8-byte registers. The size of the registers determine how much information the microprocessor can process efficiently at a time and how many memory addresses that it can support.
</p>

<p>Every task that is achieved by a programming language ends up being executed by one or more registers of the microprocessor.
</p>

<h5 class="subsection"><a id="ix_Bit Operations.binary system" content="binary system"></a> Binary number system</h5>

<p>The decimal number system which is used in daily life consists of 10 numerals: 0123456789. In contrast, the binary number system which is used by computer hardware consists of 2 numerals: 0 and 1. This is a direct consequence of a bit consisting of two values. If bits had three values then the computers would use a number system based on three numerals.
</p>

<p>The digits of the decimal system are named incrementally as <i>ones</i>, <i>tens</i>, <i>hundreds</i>, <i>thousands</i>, etc. For example, the number 1023 can be expanded as in the following way:
</p>

<pre class="mono">1023 == 1 count of thousand, no hundred, 2 counts of ten, and 3 counts of one
</pre>

<p>Naturally, moving one digit to the left multiplies the value of that digit by 10: 1, 10, 100, 1000, etc.
</p>

<p>When the same rules are applied to a system that has two numerals, we arrive at the binary number system. The digits are named incrementally as <i>ones</i>, <i>twos</i>, <i>fours</i>, <i>eights</i>, etc. In other words, moving one digit to the left would multiply the value of that digit by 2: 1, 2, 4, 8, etc. For example, the <i>binary</i> number 1011 can be expanded as in the following way:
</p>

<pre class="mono">1011 == 1 count of eight, no four, 1 count of two, and 1 count of one
</pre>

<p>To make it easy to refer to digits, they are numbered from the rightmost digit to the leftmost digit, starting by 0. The following table lists the values of all of the digits of a 32-bit unsigned number in the binary system:
</p>

<table class="narrow" border="1" cellpadding="4" cellspacing="0"><tr><th scope="col">Digit</th> <th scope="col">Value</th></tr>
<tr align="right"><td>31</td><td>2,147,483,648</td></tr>
<tr align="right"><td>30</td><td>1,073,741,824</td></tr>
<tr align="right"><td>29</td><td>536,870,912</td></tr>
<tr align="right"><td>28</td><td>268,435,456</td></tr>
<tr align="right"><td>27</td><td>134,217,728</td></tr>
<tr align="right"><td>26</td><td>67,108,864</td></tr>
<tr align="right"><td>25</td><td>33,554,432</td></tr>
<tr align="right"><td>24</td><td>16,777,216</td></tr>
<tr align="right"><td>23</td><td>8,388,608</td></tr>
<tr align="right"><td>22</td><td>4,194,304</td></tr>
<tr align="right"><td>21</td><td>2,097,152</td></tr>
<tr align="right"><td>20</td><td>1,048,576</td></tr>
<tr align="right"><td>19</td><td>524,288</td></tr>
<tr align="right"><td>18</td><td>262,144</td></tr>
<tr align="right"><td>17</td><td>131,072</td></tr>
<tr align="right"><td>16</td><td>65,536</td></tr>
<tr align="right"><td>15</td><td>32,768</td></tr>
<tr align="right"><td>14</td><td>16,384</td></tr>
<tr align="right"><td>13</td><td>8,192</td></tr>
<tr align="right"><td>12</td><td>4,096</td></tr>
<tr align="right"><td>11</td><td>2,048</td></tr>
<tr align="right"><td>10</td><td>1,024</td></tr>
<tr align="right"><td>9</td><td>512</td></tr>
<tr align="right"><td>8</td><td>256</td></tr>
<tr align="right"><td>7</td><td>128</td></tr>
<tr align="right"><td>6</td><td>64</td></tr>
<tr align="right"><td>5</td><td>32</td></tr>
<tr align="right"><td>4</td><td>16</td></tr>
<tr align="right"><td>3</td><td>8</td></tr>
<tr align="right"><td>2</td><td>4</td></tr>
<tr align="right"><td>1</td><td>2</td></tr>
<tr align="right"><td>0</td><td>1</td></tr>
</table>

<p>The bits that have higher values are called the <i>upper</i> bits and the bits that have lower values are called the <i>lower</i> bits.
</p>

<p>Remembering from <a href="literals.html">the Literals chapter</a> that binary literals are specified by the <code class="d_inline">0b</code> prefix, the following program demonstrates how the value of a literal would correspond to the rows of the previous table:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_comment">//               1073741824                     4 1
</span>    <span class="d_comment">//               ↓                              ↓ ↓
</span>    <span class="d_keyword">int</span> number = 0b_01000000_00000000_00000000_00000101;
    writeln(number);
}
</pre>

<p>The output:
</p>

<pre class="shell">1073741829
</pre>

<p>Note that the literal consists of only three nonzero bits. The value that is printed is the sum of the values that correspond to those bits from the previous table: 1073741824 + 4 + 1 == 1073741829.
</p>

<h6><a id="ix_Bit Operations.sign bit" content="sign bit"></a> The <i>sign</i> bit of signed integer types</h6>

<p>The uppermost bit of a signed type determines whether the value is positive or negative:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> number = 0b_<span class="hilite">1</span>0000000_00000000_00000000_00000000;
    writeln(number);
</pre>

<pre class="shell">-2147483648
</pre>

<p>However, the uppermost bit is not entirely separate from the value. For example, as evidenced above, the fact that all of the other bits of the number being 0 does not mean that the value is -0. (In fact, -0 is not a valid value for integers.) I will not get into more detail in this chapter other than noting that this is due to the <i>twos complement</i> representation, which is used by D as well.
</p>

<p>What is important here is that 2,147,483,648; the highest value in the previous table, is only for unsigned integer types. The same experiment with <code class="d_inline">uint</code> would print that exact value:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">uint</span></span> number = 0b_10000000_00000000_00000000_00000000;
    writeln(number);
</pre>

<pre class="shell">2147483648
</pre>

<p>Partly for that reason, unless there is a reason not to, bit operations must always be executed on unsigned types: <code class="d_inline">ubyte</code>, <code class="d_inline">ushort</code>, <code class="d_inline">uint</code>, and <code class="d_inline">ulong</code>.
</p>

<h5 class="subsection"><a id="ix_Bit Operations.hexadecimal system" content="hexadecimal system"></a> Hexadecimal number system</h5>

<p>As can be seen in the literals above, consisting only of 0s and 1s, the binary system may not be readable especially when the numbers are large. For that reason, the more readable hexadecimal system has been widely adopted especially in computer technologies.
</p>

<p>The hexadecimal system has 16 numerals. Since alphabets do not have more than 10 numerals, this system borrows 6 letters from the Latin alphabet and uses them along with regular numerals: 0123456789abcdef. The numerals a, b, c, d, e, and f have the values 10, 11, 12, 13, 14, and 15, respectively. The letters ABCDEF can be used as well.
</p>

<p>Similar to other number systems, the value of every digit is 16 times the value of the digit on its right-hand side: 1, 16, 256, 4096, etc. For example, the values of all of the digits of an 8-digit unsigned hexadecimal number are the following:
</p>

<table class="narrow" border="1" cellpadding="4" cellspacing="0"><tr><th scope="col">Digit</th> <th scope="col">Value</th></tr>
<tr align="right"><td>7</td><td>268,435,456</td></tr>
<tr align="right"><td>6</td><td>16,777,216</td></tr>
<tr align="right"><td>5</td><td>1,048,576</td></tr>
<tr align="right"><td>4</td><td>65,536</td></tr>
<tr align="right"><td>3</td><td>4,096</td></tr>
<tr align="right"><td>2</td><td>256</td></tr>
<tr align="right"><td>1</td><td>16</td></tr>
<tr align="right"><td>0</td><td>1</td></tr>
</table>

<p>Remembering that hexadecimal literals are specified by the <code class="d_inline">0x</code> prefix, we can see how the values of the digits contribute to the overall value of a number:
</p>

<pre class="d_code">    <span class="d_comment">//           1048576 4096 1
</span>    <span class="d_comment">//                 ↓  ↓  ↓
</span>    <span class="d_keyword">uint</span> number = 0x_0030_a00f;
    writeln(number);
</pre>

<pre class="shell">3186703
</pre>

<p>The value that is printed is by the contributions of all of the nonzero digits: 3 count of 1048576, <code class="d_inline">a</code> count of 4096, and <code class="d_inline">f</code> count of 1. Remembering that <code class="d_inline">a</code> represents 10 and <code class="d_inline">f</code> represents 15, the value is 3145728 + 40960 + 15 == 3186703.
</p>

<p>It is straightforward to convert between binary and hexadecimal numbers. In order to convert a hexadecimal number to binary, the digits of the hexadecimal number are converted to their binary representations individually. The corresponding representations in the three number systems are as in the following table:
</p>

<table class="narrow" border="1" cellpadding="4" cellspacing="0"><tr><th scope="col" align="center">Hexadecimal</th> <th scope="col">Binary</th>  <th scope="col">Decimal</th></tr>
<tr align="center"><td>0</td><td>0000</td><td>0</td></tr>
<tr align="center"><td>1</td><td>0001</td><td>1</td></tr>
<tr align="center"><td>2</td><td>0010</td><td>2</td></tr>
<tr align="center"><td>3</td><td>0011</td><td>3</td></tr>
<tr align="center"><td>4</td><td>0100</td><td>4</td></tr>
<tr align="center"><td>5</td><td>0101</td><td>5</td></tr>
<tr align="center"><td>6</td><td>0110</td><td>6</td></tr>
<tr align="center"><td>7</td><td>0111</td><td>7</td></tr>
<tr align="center"><td>8</td><td>1000</td><td>8</td></tr>
<tr align="center"><td>9</td><td>1001</td><td>9</td></tr>
<tr align="center"><td>a</td><td>1010</td><td>10</td></tr>
<tr align="center"><td>b</td><td>1011</td><td>11</td></tr>
<tr align="center"><td>c</td><td>1100</td><td>12</td></tr>
<tr align="center"><td>d</td><td>1101</td><td>13</td></tr>
<tr align="center"><td>e</td><td>1110</td><td>14</td></tr>
<tr align="center"><td>f</td><td>1111</td><td>15</td></tr>
</table>

<p>For example, the hexadecimal number 0x0030a00f can be written in the binary form by converting its digits individually according to the previous table:
</p>

<pre class="d_code">    <span class="d_comment">// hexadecimal:     0    0    3    0    a    0    0    f
</span>    <span class="d_keyword">uint</span> binary = 0b_0000_0000_0011_0000_1010_0000_0000_1111;
</pre>

<p>Converting from binary to hexadecimal is the reverse: The digits of the binary number are converted to their hexadecimal representations four digits at a time. For example, here is how to write in hexadecimal the same binary value that we have used earlier:
</p>
<pre class="d_code">    <span class="d_comment">// binary:           0100 0000 0000 0000 0000 0000 0000 0101
</span>    <span class="d_keyword">uint</span> hexadecimal = 0x___4____0____0____0____0____0____0____5;
</pre>

<h5 class="subsection">Bit operations</h5>

<p>After going over how values are represented by bits and how numbers are represented in binary and hexadecimal, we can now see operations that change values at bit-level.
</p>

<p>Because there is no direct access to individual bits, even though these operations are at bit-level, they affect at least 8 bits at a time. For example, for a variable of type <code class="d_inline">ubyte</code>, a bit operation would be applied to all of the 8 bits of that variable.
</p>

<p>As the uppermost bit is the sign bit for signed types, I will ignore signed types and use only <code class="d_inline">uint</code> in the examples below. You can repeat these operations with <code class="d_inline">ubyte</code>, <code class="d_inline">ushort</code>, and <code class="d_inline">ulong</code>; as well as <code class="d_inline">byte</code>, <code class="d_inline">short</code>, <code class="d_inline">int</code>, and <code class="d_inline">long</code> as long as you remember the special meaning of the uppermost bit.
</p>

<p>Let's first define a function which will be useful later when examining how bit operators work. This function will print a value in binary, hexadecimal, and decimal systems:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> print(<span class="d_keyword">uint</span> number) {
    writefln(<span class="d_string">"  %032b %08x %10s"</span>, number, number, number);
}

<span class="d_keyword">void</span> main() {
    print(123456789);
}
</pre>

<p>Here is the same value printed in the binary, hexadecimal, and decimal number systems:
</p>

<pre class="shell">  00000111010110111100110100010101 075bcd15  123456789
</pre>

<h6><a id="ix_Bit Operations.~, bitwise complement" content="~, bitwise complement"></a> <a id="ix_Bit Operations.complement, bitwise operator" content="complement, bitwise operator"></a> Complement operator: <code class="d_inline">~</code></h6>

<p><i>Not to be confused with the <i>binary</i> <code class="d_inline">~</code> operator that is used for array concatenation, this is the unary <code class="d_inline">~</code> operator.</i>
</p>

<p>This operator converts each bit of a value to its opposite: The bits that are 0 become 1, and the bits that are 1 become 0.
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 123456789;
    print(value);
    writeln(<span class="d_string">"~ --------------------------------"</span>);
    print(<span class="hilite">~</span>value);
</pre>

<p>The effect is obvious in the binary representation. Every bit has been reversed (under the dashed line):
</p>

<pre class="shell">  00000111010110111100110100010101 075bcd15  123456789
~ --------------------------------
  11111000101001000011001011101010 f8a432ea 4171510506
</pre>

<p>Here is the summary of how the unary <code class="d_inline">~</code> operator works:
</p>

<pre class="mono">~0 → 1
~1 → 0
</pre>

<h6><a id="ix_Bit Operations.&amp;, bitwise and" content="&amp;, bitwise and"></a> <a id="ix_Bit Operations.and, bitwise operator" content="and, bitwise operator"></a> <i>And</i> operator: <code class="d_inline">&amp;</code></h6>

<p><code class="d_inline">&amp;</code> is a binary operator, written between two expressions. The microprocessor considers two corresponding bits of the two expressions separately from all of the other bits: Bits 31, 30, 29, etc. of the expressions are evaluated separately. The value of each resultant bit is 1 if both of the corresponding bits of the expressions are 1; 0 otherwise.
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> lhs = 123456789;
    <span class="d_keyword">uint</span> rhs = 987654321;

    print(lhs);
    print(rhs);
    writeln(<span class="d_string">"&amp; --------------------------------"</span>);
    print(lhs <span class="hilite">&amp;</span> rhs);
</pre>

<p>The following output contains first the left-hand side expression (lhs) and then the right-hand side expression (rhs). The result of the <code class="d_inline">&amp;</code> operation is under the dashed line:
</p>

<pre class="shell">  00000111010110111100110100010101 075bcd15  123456789
  00111010110111100110100010110001 3ade68b1  987654321
&amp; --------------------------------
  00000010010110100100100000010001 025a4811   39471121
</pre>

<p>Note that the bits of the result that have the value 1 are the ones where the corresponding bits of the expressions are both 1.
</p>

<p>This operator is called the <i>and</i> operator because it produces 1 when both the left-hand side <i>and</i> the right-hand side bits are 1. Among the four possible combinations of 0 and 1 values, only the one where both of the values are 1 produces 1:
</p>

<pre class="mono">0 &amp; 0 → 0
0 &amp; 1 → 0
1 &amp; 0 → 0
1 &amp; 1 → 1
</pre>

<p>Observations:
</p>

<ul>
<li>When one of the bits is 0, regardless of the other bit the result is always 0. Accordingly, "<i>anding</i> a bit by 0" means to clear that bit.</li>

<li>When one of the bits is 1, the result is the value of the other bit; <i>anding</i> by 1 has no effect.</li>

</ul>

<h6><a id="ix_Bit Operations.|" content="|"></a> <a id="ix_Bit Operations.or, bitwise operator" content="or, bitwise operator"></a> <i>Or</i> operator: <code class="d_inline">|</code></h6>

<p><code class="d_inline">|</code> is a binary operator, written between two expressions. The microprocessor considers two corresponding bits of the two expressions separately from all of the other bits. The value of each resultant bit is 0 if both of the corresponding bits of the expressions are 0; 1 otherwise.
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> lhs = 123456789;
    <span class="d_keyword">uint</span> rhs = 987654321;

    print(lhs);
    print(rhs);
    writeln(<span class="d_string">"| --------------------------------"</span>);
    print(lhs <span class="hilite">|</span> rhs);
</pre>

<pre class="shell">  00000111010110111100110100010101 075bcd15  123456789
  00111010110111100110100010110001 3ade68b1  987654321
| --------------------------------
  00111111110111111110110110110101 3fdfedb5 1071639989
</pre>

<p>Note that the bits of the result that have the value 0 are the ones where the corresponding bits of the expressions are both 0. When the corresponding bit in the left-hand side or in the right-hand side is 1, then the result is 1:
</p>

<pre class="mono">0 | 0 → 0
0 | 1 → 1
1 | 0 → 1
1 | 1 → 1
</pre>

<p>Observations:
</p>

<ul>
<li>When one of the bits is 1, regardless of the other bit the result is always 1. Accordingly, "<i>orring</i> a bit by 1" means to set it.</li>

<li>When one of the bits is 0, the result is the value of the other bit; <i>orring</i> by 0 has no effect.</li>

</ul>

<h6><a id="ix_Bit Operations.^, bitwise exclusive or" content="^, bitwise exclusive or"></a> <a id="ix_Bit Operations.xor, bitwise operator" content="xor, bitwise operator"></a> <a id="ix_Bit Operations.exclusive or, bitwise operator" content="exclusive or, bitwise operator"></a> <i>Xor</i> operator: <code class="d_inline">^</code></h6>

<p><i>Xor</i> is the short for <i>exclusive or</i>. This is a binary operator as well. It produces 1 if the corresponding bits of the two expressions are different:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> lhs = 123456789;
    <span class="d_keyword">uint</span> rhs = 987654321;

    print(lhs);
    print(rhs);
    writeln(<span class="d_string">"^ --------------------------------"</span>);
    print(lhs <span class="hilite">^</span> rhs);
</pre>

<pre class="shell">  00000111010110111100110100010101 075bcd15  123456789
  00111010110111100110100010110001 3ade68b1  987654321
^ --------------------------------
  00111101100001011010010110100100 3d85a5a4 1032168868
</pre>

<p>Note that the bits of the result that have the value 1 are the ones where the corresponding bits of the expressions are different from each other.
</p>

<pre class="mono">0 ^ 0 → 0
0 ^ 1 → 1
1 ^ 0 → 1
1 ^ 1 → 0
</pre>

<p>Observation:
</p>

<ul><li>"<i>Xorring</i> a bit" with itself means to clear that bit.</li>
</ul>

<p>Regardless of its value, <i>xorring</i> a variable with itself always produces 0:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 123456789;

    print(value ^ value);
</pre>

<pre class="shell">  00000000000000000000000000000000 00000000          0
</pre>

<h6><a id="ix_Bit Operations.&gt;&gt;" content="&gt;&gt;"></a> <a id="ix_Bit Operations.right shift, bitwise operator" content="right shift, bitwise operator"></a> Right-shift operator: <code class="d_inline">&gt;&gt;</code></h6>

<p>This operator shifts the bits of an expression by the specified number of bits to the right. The rightmost bits, which do not have room to shift into, get <i>dropped</i> from the value. For unsigned types, the leftmost bits are filled with zeros.
</p>

<p>The following example produces a result by shifting a value by two bits to the right:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 123456789;
    print(value);
    print(value <span class="hilite">&gt;&gt;</span> 2);
</pre>

<p>In the following output, I highlighted both the bits that are going to be lost due to dropping off from the right-hand side and the leftmost bits that get the value 0:
</p>

<pre class="shell">  000001110101101111001101000101<span class="hilite">01</span> 075bcd15  123456789
  <span class="hilite">00</span>000001110101101111001101000101 01d6f345   30864197
</pre>

<p>Note that the bits that are not highlighted have been shifted two bit positions to the right.
</p>

<p><a id="ix_Bit Operations.sign extension" content="sign extension"></a> The new bits that enter from the left-hand side are 0 only for unsigned types. For signed types, the value of the leftmost bits are determined by a process called <i>sign extension</i>. Sign extension preserves the value of the sign bit of the original expression. The value of that bit is used for all of the bits that <i>enter</i> from the left.
</p>

<p>Let's see this effect on a value of a signed type where the sign bit is 1 (i.e. the value is negative):
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">int</span></span> value = 0x80010300;
    print(value);
    print(value &gt;&gt; 3);
</pre>

<p>Because the leftmost bit of the original value is 1, all of the new bits of the result are 1 as well:
</p>

<pre class="shell">  <em class="u">1</em>0000000000000010000001100000<span class="hilite">000</span> 80010300 2147549952
  <span class="hilite">111</span>10000000000000010000001100000 f0002060 4026540128
</pre>

<p>When the leftmost bit is 0, then all new bits are 0:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">int</span></span> value = 0x40010300;
    print(value);
    print(value &gt;&gt; 3);
</pre>

<pre class="shell">  <em class="u">0</em>1000000000000010000001100000<span class="hilite">000</span> 40010300 1073808128
  <span class="hilite">000</span>01000000000000010000001100000 08002060  134226016
</pre>

<h6><a id="ix_Bit Operations.&gt;&gt;&gt;" content="&gt;&gt;&gt;"></a> <a id="ix_Bit Operations.unsigned right shift, bitwise operator" content="unsigned right shift, bitwise operator"></a> Unsigned right-shift operator: <code class="d_inline">&gt;&gt;&gt;</code></h6>

<p>This operator works similarly to the regular right-shift operator. The difference is that the new leftmost bits are always 0 regardless of the type of the expression and the value of the leftmost bit:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> value = 0x80010300;
    print(value);
    print(value <span class="hilite">&gt;&gt;&gt;</span> 3);
</pre>

<pre class="shell">  10000000000000010000001100000<span class="hilite">000</span> 80010300 2147549952
  <span class="hilite">000</span>10000000000000010000001100000 10002060  268443744
</pre>

<h6><a id="ix_Bit Operations.&lt;&lt;" content="&lt;&lt;"></a> <a id="ix_Bit Operations.left shift, bitwise operator" content="left shift, bitwise operator"></a> Left-shift operator: <code class="d_inline">&lt;&lt;</code></h6>

<p>This operator works as the reverse of the right-shift operator. The bits are shifted to the left:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 123456789;
    print(value);
    print(value <span class="hilite">&lt;&lt;</span> 4);
</pre>

<p>The bits on the left-hand side are lost and the new bits on the right-hand side are 0:
</p>

<pre class="shell">  <span class="hilite">0000</span>0111010110111100110100010101 075bcd15  123456789
  0111010110111100110100010101<span class="hilite">0000</span> 75bcd150 1975308624
</pre>

<h6><a id="ix_Bit Operations.assignment, operation result" content="assignment, operation result"></a> Operators with assignment</h6>

<p>All of the binary operators above have assignment counterparts: <code class="d_inline">&amp;=</code>, <code class="d_inline">|=</code>, <code class="d_inline">^=</code>, <code class="d_inline">&gt;&gt;=</code>, <code class="d_inline">&gt;&gt;&gt;=</code>, and <code class="d_inline">&lt;&lt;=</code>. Similar to the operators that we saw in <a href="arithmetic.html">the Integers and Arithmetic Operations chapter</a>, these operators assign the result back to the left-hand operand.
</p>

<p>Let's see this on the <code class="d_inline">&amp;=</code> operator:
</p>

<pre class="d_code">    value = value &amp; 123;
    value &amp;= 123;         <span class="d_comment">// the same as above
</span></pre>

<h5 class="subsection">Semantics</h5>

<p>Merely understanding how these operators work at bit-level may not be sufficient to see how they are useful in programs. The following sections describe common ways that these operators are used in.
</p>

<h6><code class="d_inline">|</code> is a union set</h6>

<p>The <code class="d_inline">|</code> operator produces the union of the 1 bits in the two expressions.
</p>

<p>As an extreme example, let's consider two values that both have alternating bits set to 1. The union of these values would produce a result where all of the bits are 1:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> lhs = 0xaaaaaaaa;
    <span class="d_keyword">uint</span> rhs = 0x55555555;

    print(lhs);
    print(rhs);
    writeln(<span class="d_string">"| --------------------------------"</span>);
    print(lhs | rhs);
</pre>

<pre class="shell">  10101010101010101010101010101010 aaaaaaaa 2863311530
  01010101010101010101010101010101 55555555 1431655765
| --------------------------------
  11111111111111111111111111111111 ffffffff 4294967295
</pre>

<h6><code class="d_inline">&amp;</code> is an intersection set</h6>

<p>The <code class="d_inline">&amp;</code> operator produces the intersection of the 1 bits in the two expressions.
</p>

<p>As an extreme example, let's consider the last two values again. Since none of the 1 bits of the previous two expressions match the ones in the other expression, all of the bits of the result are 0:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> lhs = 0xaaaaaaaa;
    <span class="d_keyword">uint</span> rhs = 0x55555555;

    print(lhs);
    print(rhs);
    writeln(<span class="d_string">"&amp; --------------------------------"</span>);
    print(lhs &amp; rhs);
</pre>

<pre class="shell">  10101010101010101010101010101010 aaaaaaaa 2863311530
  01010101010101010101010101010101 55555555 1431655765
&amp; --------------------------------
  00000000000000000000000000000000 00000000          0
</pre>

<h6><code class="d_inline">|=</code> sets selected bits to 1</h6>

<p>To understand how this works, it helps to see one of the expressions as the <i>actual</i> expression and the other expression as a <i>selector</i> for the bits to set to 1:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> expression = 0x00ff00ff;
    <span class="d_keyword">uint</span> bitsToSet = 0x10001000;

    write(<span class="d_string">"before     :"</span>); print(expression);
    write(<span class="d_string">"to set to 1:"</span>); print(bitsToSet);

    expression <span class="hilite">|=</span> bitsToSet;
    write(<span class="d_string">"after      :"</span>); print(expression);
</pre>

<p>The before and after values of the bits that are affected are highlighted:
</p>

<pre class="shell">before     :  000<span class="hilite">0</span>000011111111000<span class="hilite">0</span>000011111111 00ff00ff   16711935
to set to 1:  00010000000000000001000000000000 10001000  268439552
after      :  000<span class="hilite">1</span>000011111111000<span class="hilite">1</span>000011111111 10ff10ff  285151487
</pre>

<p>In a sense, <code class="d_inline">bitsToSet</code> determines which bits to set to 1. The other bits are not affected.
</p>

<h6><code class="d_inline">&amp;=</code> clears selected bits</h6>

<p>One of the expressions can be seen as the <i>actual</i> expression and the other expression can be seen as a <i>selector</i> for the bits to clear (to set to 0):
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> expression = 0x00ff00ff;
    <span class="d_keyword">uint</span> bitsToClear = 0xffefffef;

    write(<span class="d_string">"before       :"</span>); print(expression);
    write(<span class="d_string">"bits to clear:"</span>); print(bitsToClear);

    expression <span class="hilite">&amp;=</span> bitsToClear;
    write(<span class="d_string">"after        :"</span>); print(expression);
</pre>

<p>The before and after values of the bits that are affected are highlighted:
</p>

<pre class="shell">before       :  00000000111<span class="hilite">1</span>111100000000111<span class="hilite">1</span>1111 00ff00ff   16711935
bits to clear:  11111111111011111111111111101111 ffefffef 4293918703
after        :  00000000111<span class="hilite">0</span>111100000000111<span class="hilite">0</span>1111 00ef00ef   15663343
</pre>

<p>In a sense, <code class="d_inline">bitsToClear</code> determines which bits to set to 0. The other bits are not affected.
</p>

<h6><code class="d_inline">&amp;</code> determines whether a bit is 1 or not</h6>

<p>If one of the expressions has only one bit set to 1, then it can be used to query whether the corresponding bit of the other expression is 1:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> expression = 123456789;
    <span class="d_keyword">uint</span> bitToQuery = 0x00010000;

    print(expression);
    print(bitToQuery);
    writeln(expression <span class="hilite">&amp;</span> bitToQuery ? <span class="d_string">"yes, 1"</span> : <span class="d_string">"not 1"</span>);
</pre>

<p>The bit that is being <i>queried</i> is highlighted:
</p>

<pre class="shell">  000001110101101<span class="hilite">1</span>1100110100010101 075bcd15  123456789
  00000000000000010000000000000000 00010000      65536
yes, 1
</pre>

<p>Let's query another bit of the same expression by this time having another bit of <code class="d_inline">bitToQuery</code> set to 1:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> bitToQuery = 0x00001000;
</pre>

<pre class="shell">0000011101011011110<span class="hilite">0</span>110100010101 075bcd15  123456789
00000000000000000001000000000000 00001000       4096
not 1
</pre>

<p>When the query expression has more than one bit set to 1, then the query would determine whether <i>any</i> of the corresponding bits in the other expression are 1.
</p>

<h6>Right-shifting by one is the equivalent of dividing by two</h6>

<p>Shifting all of the bits of a value by one position to the right produces half of the original value. The reason for this can be seen in the digit-value table above: In that table, every bit has half the value of the bit that is on its left.
</p>

<p>Shifting a value to the right multiple bits at a time means dividing by 2 for that many times. For example, right-shifting by 3 bits would divide a value by 8:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 8000;

    writeln(value &gt;&gt; 3);
</pre>

<pre class="shell">1000
</pre>

<p>According to how the <i>twos complement</i> system works, right-shifting has the same effect on signed values:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">int</span></span> value = -8000;

    writeln(value &gt;&gt; 3);
</pre>

<pre class="shell">-1000
</pre>

<h6>Left-shifting by one is the equivalent of multiplying by two</h6>

<p>Because each bit is two times the value of the bit on its right, shifting a value one bit to the left means multiplying that value by two:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 10;

    writeln(value &lt;&lt; 5);
</pre>

<p>Multiplying by 2 a total of 5 times is the same as multiplying by 32:
</p>

<pre class="shell">320
</pre>

<h5 class="subsection">Common uses</h5>

<h6><a id="ix_Bit Operations.flag, bit" content="flag, bit"></a> Flags</h6>

<p>Flags are single-bit independent data that are kept together in the same variable. As they are only one bit wide each, they are suitable for representing binary concepts like enabled/disabled, valid/invalid, etc.
</p>

<p>Such one-bit concepts are sometimes encountered in D modules that are based on C libraries.
</p>

<p>Flags are usually defined as non-overlapping values of an <code class="d_inline">enum</code> type.
</p>

<p>As an example, let's consider a car racing game where the realism of the game is configurable:
</p>

<ul><li>The fuel consumption is realistic or not.</li>
<li>Collisions can damage the cars or not.</li>
<li>Tires can deteriorate by use or not.</li>
<li>Skid marks are left on the road surface or not.</li>
</ul>

<p>These configuration options can be specified at run time by the following <code class="d_inline">enum</code> values:
</p>

<pre class="d_code"><span class="d_keyword">enum</span> Realism {
    fuelUse    = 1 &lt;&lt; 0,
    bodyDamage = 1 &lt;&lt; 1,
    tireUse    = 1 &lt;&lt; 2,
    skidMarks  = 1 &lt;&lt; 3
}
</pre>

<p>Note that all of those values consist of single bits that do not conflict with each other. Each value is determined by left-shifting 1 by a different number of bits. The corresponding bit representations are the following:
</p>

<pre class="mono">fuelUse   : 0001
bodyDamage: 0010
tireUse   : 0100
skidMarks : 1000
</pre>

<p>Since their 1 bits do not match others', these values can be combined by the <code class="d_inline">|</code> operator to be kept in the same variable. For example, the two configuration options that are related to tires can be combined as in the following code:
</p>

<pre class="d_code">    Realism flags = Realism.tireUse | Realism.skidMarks;
    writefln(<span class="d_string">"%b"</span>, flags);
</pre>

<p>The bits of these two flags would be side-by-side in the variable <code class="d_inline">flags</code>:
</p>

<pre class="shell">1100
</pre>

<p>Later, these flags can be queried by the <code class="d_inline">&amp;</code> operator:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (flags &amp; Realism.fuelUse) {
        <span class="d_comment">// ... code related to fuel consumption ...
</span>    }

    <span class="d_keyword">if</span> (flags &amp; Realism.tireUse) {
        <span class="d_comment">// ... code related to tire consumption ...
</span>    }
</pre>

<p>The <code class="d_inline">&amp;</code> operator produces 1 only if the specified flag is set in <code class="d_inline">flags</code>.
</p>

<p>Also note that the result is usable in the <code class="d_inline">if</code> condition due to automatic conversion of the nonzero value to <code class="d_inline">true</code>. The conditional expression is <code class="d_inline">false</code> when the result of <code class="d_inline">&amp;</code> is 0 and <code class="d_inline">true</code> otherwise. As a result, the corresponding code block is executed only if the flag is enabled.
</p>

<h6><a id="ix_Bit Operations.mask, bit" content="mask, bit"></a> Masking</h6>

<p>In some libraries and some protocols an integer value may carry more than one piece of information. For example, the upper 3 bits of a 32-bit value may have a certain meaning, while the lower 29 bits may have another meaning. These separate parts of data can be extracted from the variable by masking.
</p>

<p>The four octets of an IPv4 address are an example of this concept. The octets are the individual values that make up the common dotted representation of an IPv4 address. They are all kept in a single 32-bit value.  For example, the IPv4 address 192.168.1.2 is the 32-bit value 0xc0a80102:
</p>

<pre class="mono">c0 == 12 * 16 + 0 = 192
a8 == 10 * 16 + 8 = 168
01 ==  0 * 16 + 1 =   1
02 ==  0 * 16 + 2 =   2
</pre>

<p>A mask consists of a number of 1 bits that would <i>cover</i> the specific part of a variable. <i>"And"ing</i> the value by the mask extracts the part of the variable that is covered by that mask. For example, the mask value of 0x000000ff would cover the lower 8 bits of a value:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 123456789;
    <span class="d_keyword">uint</span> mask  = 0x000000ff;

    write(<span class="d_string">"value :"</span>); print(value);
    write(<span class="d_string">"mask  :"</span>); print(mask);
    write(<span class="d_string">"result:"</span>); print(value &amp; mask);
</pre>

<p>The bits that are covered by the mask are highlighted. All of the other bits are cleared:
</p>

<pre class="shell">value :  000001110101101111001101<span class="hilite">00010101</span> 075bcd15  123456789
mask  :  00000000000000000000000011111111 000000ff        255
result:  000000000000000000000000<span class="hilite">00010101</span> 00000015         21
</pre>

<p>Let's apply the same method to the 0xc0a80102 IPv4 address with a mask that would cover the uppermost 8 bits:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 0xc0a80102;
    <span class="d_keyword">uint</span> mask  = 0xff000000;

    write(<span class="d_string">"value :"</span>); print(value);
    write(<span class="d_string">"mask  :"</span>); print(mask);
    write(<span class="d_string">"result:"</span>); print(value &amp; mask);
</pre>

<p>This mask covers the uppermost 8 bits of the value:
</p>

<pre class="shell">value :  <span class="hilite">11000000</span>101010000000000100000010 c0a80102 3232235778
mask  :  11111111000000000000000000000000 ff000000 4278190080
result:  <span class="hilite">11000000</span>000000000000000000000000 c0000000 3221225472
</pre>

<p>However, note that the printed result is not the expected 192 but 3221225472. That is because the masked value must also be shifted all the way to the right-hand side. Shifting the value 24 bit positions to the right would produce the value that those 8 bits represent:
</p>

<pre class="d_code">    <span class="d_keyword">uint</span> value = 0xc0a80102;
    <span class="d_keyword">uint</span> mask  = 0xff000000;

    write(<span class="d_string">"value :"</span>); print(value);
    write(<span class="d_string">"mask  :"</span>); print(mask);
    write(<span class="d_string">"result:"</span>); print((value &amp; mask) <span class="hilite">&gt;&gt; 24</span>);
</pre>

<pre class="shell">value :  <span class="hilite">11000000</span>101010000000000100000010 c0a80102 3232235778
mask  :  11111111000000000000000000000000 ff000000 4278190080
result:  000000000000000000000000<span class="hilite">11000000</span> 000000c0        <span class="hilite">192</span>
</pre>

<h5 class="subsection">Problemler</h5>
    <ol>
<li>Write a function that returns an IPv4 address in its dotted form:

<pre class="d_code">string dotted(<span class="d_keyword">uint</span> address) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">unittest</span> {
    <span class="d_keyword">assert</span>(dotted(0xc0a80102) == <span class="d_string">"192.168.1.2"</span>);
}
</pre>

</li>

<li>Write a function that converts four octet values to the corresponding 32-bit IPv4 address:

<pre class="d_code"><span class="d_keyword">uint</span> ipAddress(<span class="d_keyword">ubyte</span> octet3,    <span class="d_comment">// most significant octet
</span>               <span class="d_keyword">ubyte</span> octet2,
               <span class="d_keyword">ubyte</span> octet1,
               <span class="d_keyword">ubyte</span> octet0) {  <span class="d_comment">// least significant octet
</span>    <span class="d_comment">// ...
</span>}

<span class="d_keyword">unittest</span> {
    <span class="d_keyword">assert</span>(ipAddress(192, 168, 1, 2) == 0xc0a80102);
}
</pre>

</li>

<li>Write a function that can be used for making a mask. It should start with the specified bit and have the specified width:

<pre class="d_code"><span class="d_keyword">uint</span> mask(<span class="d_keyword">int</span> lowestBit, <span class="d_keyword">int</span> width) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">unittest</span> {
    <span class="d_keyword">assert</span>(mask(2, 5) ==
           0b_0000_0000_0000_0000_0000_0000_0111_1100);
    <span class="d_comment">//                                            ↑
</span>    <span class="d_comment">//                              lowest bit is 2,
</span>    <span class="d_comment">//                              and the mask is 5-bit wide
</span>}
</pre>

</li>

</ol> <div class="cozum_link_cok"><p><a target="ddili_cozum" href="bit_operations.cozum.html"><i>... çözümler</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 21:09:29 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Floating Point Types - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Floating Point Types' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BFloating Point Types%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/floating_point.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Floating Point Types</h1>
        
        



<p>In the previous chapter, we have seen that despite their ease of use, arithmetic operations on integers are prone to programming errors due to overflow and truncation. We have also seen that integers cannot have values with fractional parts, as in 1.25.
</p>

<p>Floating point types are designed to support fractional parts. The "point" in their name comes from the <i>radix point</i>, which separates the integer part from the fractional part, and "floating" refers to a detail in how these types are implemented: the decimal point <i>floats</i> left and right as appropriate. (This detail is not important when using these types.)
</p>

<p>We must cover important details in this chapter as well. Before doing that, I would like to give a list of some of the interesting aspects of floating point types:
</p>

<ul>
<li>Adding 0.001 a thousand times is not the same as adding 1.</li>

<li>Using the logical operators <code class="d_inline">==</code> and <code class="d_inline">!=</code> with floating point types is erroneous in most cases.</li>

<li>The initial value of floating point types is <code class="d_inline">.nan</code>, not 0. <code class="d_inline">.nan</code> may not be used in expressions in any meaningful way. When used in comparison operations, <code class="d_inline">.nan</code> is not less than nor greater than any value.</li>

<li>The two overflow values are <code class="d_inline">.infinity</code> and negative <code class="d_inline">.infinity</code>.</li>
</ul>

<p>Although floating point types are more useful in some cases, they have peculiarities that every programmer must know. Compared to integers, they are very good at avoiding truncation because their main purpose is to support fractional values. Like any other type, being based on a certain number of bits, they too are prone to overflow, but compared to integers, the range of values that they can support is vast. Additionally, instead of being silent in the case of overflow, they get the special values of positive and negative <i>infinity</i>.
</p>

<p><a id="ix_Floating Point Types.float" content="float"></a>
<a id="ix_Floating Point Types.double" content="double"></a>
<a id="ix_Floating Point Types.real" content="real"></a>
As a reminder, the floating point types are the following:
</p>

<table class="wide" border="1" cellpadding="4" cellspacing="0">
<tr align="center"><th scope="col">Type</th> <th scope="col">Number of Bits</th> <th scope="col">Initial Value</th></tr>
<tr align="center"><td>float</td>
	<td>32</td>
	<td>float.nan</td>
</tr>
<tr align="center"><td>double</td>

	<td>64</td>
	<td>double.nan</td>
</tr>
<tr align="center"><td>real</td>
	<td>at least 64, maybe more<br/>(e.g. 80, depending on hardware support)</td>

	<td>real.nan</td>
</tr>
</table>

<h5 class="subsection">Floating point type properties</h5>

<p>Floating point types have more properties than other types:
</p>

<ul>
<li><code class="d_inline">.stringof</code> is the name of the type.</li>

<li><code class="d_inline">.sizeof</code> is the length of the type in terms of bytes. (In order to determine the bit count, this value must be multiplied by 8, the number of bits in a byte.)</li>

<li><a id="ix_Floating Point Types..min, floating point" content=".min, floating point"></a> <code class="d_inline">.max</code> is the short for "maximum" and is the maximum value that the type can have. There is no separate <code class="d_inline">.min</code> property for floating types; the negative of <code class="d_inline">.max</code> is the minimum value that the type can have. For example, the minimum value of <code class="d_inline">double</code> is <code class="d_inline">-double.max</code>.</li>

<li><a id="ix_Floating Point Types..min_normal" content=".min_normal"></a> <a id="ix_Floating Point Types.underflow" content="underflow"></a> <code class="d_inline">.min_normal</code> is the smallest positive value that this type can represent with its normal precision. (Precision is explained below.) The type can represent smaller values than <code class="d_inline">.min_normal</code> but those values cannot be as precise as other values of the type and are generally slower to compute.  The condition of a floating point value being between negative <code class="d_inline">.min_normal</code> and positive <code class="d_inline">.min_normal</code> (excluding 0) is called <i>underflow</i>.</li>

<li><a id="ix_Floating Point Types..dig" content=".dig"></a> <code class="d_inline">.dig</code> is short for "digits" and specifies the number of digits that signify the precision of the type.</li>

<li><a id="ix_Floating Point Types..infinity" content=".infinity"></a> <a id="ix_Floating Point Types.overflow, floating point" content="overflow, floating point"></a> <code class="d_inline">.infinity</code> is the special value used to denote overflow.</li>

</ul>

<p>Other properties of floating point types are used less commonly. You can see all of them at <a href="http://dlang.org/property.html">Properties for Floating Point Types at dlang.org</a>.
</p>

<p>The properties of floating point types and their relations can be shown on a number line like the following:
</p>

<pre class="mono">   +     +─────────+─────────+   ...   +   ...   +─────────+─────────+     +
   │   -max       -1         │         0         │         1        max    │
   │                         │                   │                         │
-infinity               -min_normal          min_normal               infinity
</pre>

<p>Other than the two special infinity values, the line above is to scale: the number of values that can be represented between <code class="d_inline">min_normal</code> and 1 is equal to the number of values that can be represented between 1 and <code class="d_inline">max</code>. This means that the precision of the fractional parts of the values that are between <code class="d_inline">min_normal</code> and 1 is very high. (The same is true for the negative side as well.)
</p>

<h5 class="subsection"><a id="ix_Floating Point Types..nan" content=".nan"></a> <code class="d_inline">.nan</code></h5>

<p>We have already seen that this is the default value of floating point variables. <code class="d_inline">.nan</code> may appear as a result of meaningless floating point expressions as well. For example, the floating point expressions in the following program all produce <code class="d_inline">double.nan</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">double</span> zero = 0;
    <span class="d_keyword">double</span> infinity = <span class="d_keyword">double</span>.infinity;

    writeln(<span class="d_string">"any expression with nan: "</span>, <span class="d_keyword">double</span>.nan + 1);
    writeln(<span class="d_string">"zero / zero            : "</span>, zero / zero);
    writeln(<span class="d_string">"zero * infinity        : "</span>, zero * infinity);
    writeln(<span class="d_string">"infinity / infinity    : "</span>, infinity / infinity);
    writeln(<span class="d_string">"infinity - infinity    : "</span>, infinity - infinity);
}
</pre>

<p><code class="d_inline">.nan</code> is not useful just because it indicates an uninitialized value. It is also useful because it is propagated through computations, making it easier and earlier to detect errors.
</p>

<h5 class="subsection">Specifying floating point values</h5>

<p>Floating point values can be built from integer values without a decimal point, like 123, or created directly with a decimal point, like 123.0.
</p>

<p>Floating point values can also be specified with the special floating point syntax, as in <code class="d_inline">1.23e+4</code>. The <code class="d_inline">e+</code> part in that syntax can be read as "times 10 to the power of". According to that reading, the previous value is "1.23 times 10 to the power of 4", which is the same as "1.23 times 10<sup>4</sup>", which in turn is the same as 1.23x10000, being equal to 12300.
</p>

<p>If the value after <code class="d_inline">e</code> is negative, as in <code class="d_inline">5.67e-3</code>, then it is read as "divided by 10 to the power of". Accordingly, this example is "5.67 divided by 10<sup>3</sup>", which in turn is the same as 5.67/1000, being equal to 0.00567.
</p>

<p>The floating point format is apparent in the output of the following program that prints the properties of the three floating point types:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    writeln(<span class="d_string">"Type                    : "</span>, <span class="d_keyword">float</span>.stringof);
    writeln(<span class="d_string">"Precision               : "</span>, <span class="d_keyword">float</span>.dig);
    writeln(<span class="d_string">"Minimum normalized value: "</span>, <span class="d_keyword">float</span>.min_normal);
    writeln(<span class="d_string">"Minimum value           : "</span>, -<span class="d_keyword">float</span>.max);
    writeln(<span class="d_string">"Maximum value           : "</span>, <span class="d_keyword">float</span>.max);
    writeln();

    writeln(<span class="d_string">"Type                    : "</span>, <span class="d_keyword">double</span>.stringof);
    writeln(<span class="d_string">"Precision               : "</span>, <span class="d_keyword">double</span>.dig);
    writeln(<span class="d_string">"Minimum normalized value: "</span>, <span class="d_keyword">double</span>.min_normal);
    writeln(<span class="d_string">"Minimum value           : "</span>, -<span class="d_keyword">double</span>.max);
    writeln(<span class="d_string">"Maximum value           : "</span>, <span class="d_keyword">double</span>.max);
    writeln();

    writeln(<span class="d_string">"Type                    : "</span>, <span class="d_keyword">real</span>.stringof);
    writeln(<span class="d_string">"Precision               : "</span>, <span class="d_keyword">real</span>.dig);
    writeln(<span class="d_string">"Minimum normalized value: "</span>, <span class="d_keyword">real</span>.min_normal);
    writeln(<span class="d_string">"Minimum value           : "</span>, -<span class="d_keyword">real</span>.max);
    writeln(<span class="d_string">"Maximum value           : "</span>, <span class="d_keyword">real</span>.max);
}
</pre>

<p>The output of the program is the following in my environment. Since <code class="d_inline">real</code> depends on the hardware, you may get a different output:
</p>

<pre class="shell">Type                    : float
Precision               : 6
Minimum normalized value: 1.17549e-38
Minimum value           : -3.40282e+38
Maximum value           : 3.40282e+38

Type                    : double
Precision               : 15
Minimum normalized value: 2.22507e-308
Minimum value           : -1.79769e+308
Maximum value           : 1.79769e+308

Type                    : real
Precision               : 18
Minimum normalized value: 3.3621e-4932
Minimum value           : -1.18973e+4932
Maximum value           : 1.18973e+4932
</pre>

<p><i><b>Note:</b> Although <code class="d_inline">double</code> and <code class="d_inline">real</code> have more precision than <code class="d_inline">float</code>, <code class="d_inline">writeln</code> prints all floating point values with 6 digits of precision. (Precision is explained below.)</i>
</p>

<h6>Observations</h6>

<p>As you will remember from the previous chapter, the maximum value of <code class="d_inline">ulong</code> has 20 digits: 18,446,744,073,709,551,616. That value looks small when compared to even the smallest floating point type: <code class="d_inline">float</code> can have values up to the 10<sup>38</sup> range, e.g. 340,282,000,000,000,000,000,000,000,000,000,000,000. The maximum value of <code class="d_inline">real</code> is in the range 10<sup>4932</sup>, a value with more than 4900 digits!
</p>

<p>As another observation, let's look at the minimum value that <code class="d_inline">double</code> can represent with 15-digit precision:
</p>

<pre class="mono">    0.000...<i>(there&nbsp;are&nbsp;300&nbsp;more&nbsp;zeroes&nbsp;here)</i>...0000222507385850720
</pre>

<h5 class="subsection">Overflow is not ignored</h5>

<p>Despite being able to take very large values, floating point types are prone to overflow as well. The floating point types are safer than integer types in this regard because overflow is not ignored. The values that overflow on the positive side become <code class="d_inline">.infinity</code>, and the values that overflow on the negative side become <code class="d_inline">&#8209;.infinity</code>. To see this, let's increase the value of <code class="d_inline">.max</code> by 10%. Since the value is already at the maximum, increasing by 10% would overflow:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">real</span> value = <span class="d_keyword">real</span>.max;

    writeln(<span class="d_string">"Before         : "</span>, value);

    <span class="d_comment">// Multiplying by 1.1 is the same as adding 10%
</span>    value *= 1.1;
    writeln(<span class="d_string">"Added 10%      : "</span>, value);

    <span class="d_comment">// Let's try to reduce its value by dividing in half
</span>    value /= 2;
    writeln(<span class="d_string">"Divided in half: "</span>, value);
}
</pre>

<p>Once the value overflows and becomes <code class="d_inline">real.infinity</code>, it remains that way even after being divided in half:
</p>

<pre class="shell">Before         : 1.18973e+4932
Added 10%      : inf
Divided in half: inf
</pre>

<h5 class="subsection"><a id="ix_Floating Point Types.precision" content="precision"></a> Precision</h5>

<p>Precision is a concept that we come across in daily life but do not talk about much. Precision is the number of digits that is used when specifying a value. For example, when we say that the third of 100 is 33, the precision is 2 because 33 has 2 digits. When the value is specified more precisely as 33.33, then the precision is 4 digits.
</p>

<p>The number of bits that each floating type has, not only affects its maximum value, but also its precision. The greater the number of bits, the more precise the values are.
</p>

<h5 class="subsection">There is no truncation in division</h5>

<p>As we have seen in the previous chapter, integer division cannot preserve the fractional part of a result:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> first = 3;
    <span class="d_keyword">int</span> second = 2;
    writeln(first / second);
</pre>

<p>Output:
</p>

<pre class="shell">1
</pre>

<p>Floating point types don't have this <i>truncation</i> problem; they are specifically designed for preserving the fractional parts:
</p>

<pre class="d_code">    <span class="d_keyword">double</span> first = 3;
    <span class="d_keyword">double</span> second = 2;
    writeln(first / second);
</pre>

<p>Output:
</p>

<pre class="shell">1.5
</pre>

<p>The accuracy of the fractional part depends on the precision of the type: <code class="d_inline">real</code> has the highest precision and <code class="d_inline">float</code> has the lowest precision.
</p>

<h5 class="subsection">Which type to use</h5>

<p>Unless there is a specific reason not to, you can choose <code class="d_inline">double</code> for floating point values. <code class="d_inline">float</code> has low precision but due to being smaller than the other types it may be useful when memory is limited. On the other hand, since the precision of <code class="d_inline">real</code> is higher than <code class="d_inline">double</code> on some hardware, it would be preferable for high precision calculations.
</p>

<h5 class="subsection">Cannot represent all values</h5>

<p>We cannot represent certain values in our daily lives. In the decimal system that we use daily, the digits before the decimal point represent ones, tens, hundreds, etc. and the digits after the decimal point represent tenths, hundredths, thousandths, etc.
</p>

<p>If a value is created from a combination of these values, it can be represented exactly. For example, because the value 0.23 consists of 2 tenths and 3 hundredths it is represented exactly. On the other hand, the value 1/3 cannot be exactly represented in the decimal system because the number of digits is always insufficient, no matter how many are specified: 0.33333...
</p>

<p>The situation is very similar with the floating point types. Because these types are based on a certain number of bits, they cannot represent every value exactly.
</p>

<p>The difference with the binary system that the computers use is that the digits before the decimal point are ones, twos, fours, etc. and the digits after the decimal point are halves, quarters, eighths, etc. Only the values that are exact combinations of those digits can be represented exactly.
</p>

<p>A value that cannot be represented exactly in the binary system used by computers is 0.1, as in 10 cents. Although this value can be represented exactly in the decimal system, its binary representation never ends and continuously repeats four digits: 0.0001100110011... (Note that the value is written in binary system, not decimal.) It is always inaccurate at some level depending on the precision of the floating point type that is used.
</p>

<p>The following program demonstrates this problem. The value of a variable is being incremented by 0.001 a thousand times in a loop. Surprisingly, the result is not 1:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">float</span> result = 0;

    <span class="d_comment">// Adding 0.001 for a thousand times:
</span>    <span class="d_keyword">int</span> counter = 1;
    <span class="d_keyword">while</span> (counter &lt;= 1000) {
        result += 0.001;
        ++counter;
    }

    <span class="d_keyword">if</span> (result == 1) {
        writeln(<span class="d_string">"As expected: 1"</span>);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"DIFFERENT: "</span>, result);
    }
}
</pre>

<p>Because 0.001 cannot be represented exactly, that inaccuracy affects the result at every iteration:
</p>

<pre class="shell">DIFFERENT: 0.999991
</pre>

<p><i><b>Note:</b> The variable <code class="d_inline">counter</code> above is a loop counter. Defining a variable explicitly for that purpose is not recommended. Instead, a common approach is to use a <code class="d_inline">foreach</code> loop, which we will see in <a href="foreach.html">a later chapter</a>.</i>
</p>

<h5 class="subsection"><a id="ix_Floating Point Types.unordered" content="unordered"></a>  Unorderedness</h5>

<p>The same comparison operators that we have covered with integers are used with floating point types as well. However, since the special value <code class="d_inline">.nan</code> represents invalid floating point values, comparing <code class="d_inline">.nan</code> to other values is not meaningful. For example, it does not make sense to ask whether <code class="d_inline">.nan</code> or <code class="d_inline">1</code> is greater.
</p>

<p>For that reason, floating point values introduce another comparison concept: unorderedness. Being unordered means that at least one of the values is <code class="d_inline">.nan</code>.
</p>

<p>The following table lists all the floating point comparison operators. All of them are binary operators (meaning that they take two operands) and used as in <code class="d_inline">left&nbsp;==&nbsp;right</code>. The columns that contain <code class="d_inline">false</code> and <code class="d_inline">true</code> are the results of the comparison operations.
</p>

<p>The last column indicates whether the operation is meaningful if one of the operands is <code class="d_inline">.nan</code>. For example, even though the result of the expression <code class="d_inline">1.2 &lt; real.nan</code> is <code class="d_inline">false</code>, that result is meaningless because one of the operands is <code class="d_inline">real.nan</code>. The result of the reverse comparison <code class="d_inline">real.nan &lt; 1.2</code> would produce <code class="d_inline">false</code> as well. The abreviation lhs stands for <i>left-hand side</i>, indicating the expression on the left-hand side of each operator.
</p>

<table class="full" border="1" cellpadding="4" cellspacing="0">
<tr align="center">	<th scope="col"><br/>Operator</th>
<th scope="col"><br/>Meaning</th>
<th scope="col">If lhs<br/>is greater</th>
<th scope="col">If lhs<br/>is less</th>
<th scope="col">If both<br/>are equal</th>

<th scope="col">If at least<br/>one is .nan</th>
<th scope="col">Meaningful<br/>with .nan</th>
</tr>
<tr align="center">	<td>==</td><td>is equal to</td>	<td><span class="unordered_false">false</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_true">true</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_yes">yes</span></td>

</tr>
<tr align="center">	<td>!=</td><td>is not equal to</td>	<td><span class="unordered_true">true</span></td><td><span class="unordered_true">true</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_true">true</span></td><td><span class="unordered_yes">yes</span></td>
</tr>
<tr align="center">	<td>&gt;</td><td>is greater than</td>	<td><span class="unordered_true">true</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_no">no</span></td>

</tr>
<tr align="center">	<td>&gt;=</td><td>is greater than or equal to</td>	<td><span class="unordered_true">true</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_true">true</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_no">no</span></td>
</tr>
<tr align="center">	<td>&lt;</td><td>is less than</td>	<td><span class="unordered_false">false</span></td><td><span class="unordered_true">true</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_no">no</span></td>

</tr>
<tr align="center">	<td>&lt;=</td><td>is less than or equal to</td>	<td><span class="unordered_false">false</span></td><td><span class="unordered_true">true</span></td><td><span class="unordered_true">true</span></td><td><span class="unordered_false">false</span></td><td><span class="unordered_no">no</span></td>
</tr>
</table>

<p>Although meaningful to use with <code class="d_inline">.nan</code>, the <code class="d_inline">==</code> operator always produces <code class="d_inline">false</code> when used with a <code class="d_inline">.nan</code> value. This is the case even when both values are <code class="d_inline">.nan</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">if</span> (<span class="d_keyword">double</span>.nan == <span class="d_keyword">double</span>.nan) {
        writeln(<span class="d_string">"equal"</span>);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"not equal"</span>);
    }
}
</pre>

<p>Although one would expect <code class="d_inline">double.nan</code> to be equal to itself, the result of the comparison is <code class="d_inline">false</code>:
</p>

<pre class="shell">not equal
</pre>

<h6><a id="ix_Floating Point Types.isNan, std.math" content="isNan, std.math"></a> <code class="d_inline">isNaN()</code> for <code class="d_inline">.nan</code> equality comparison</h6>

<p>As we have seen above, it is not possible to use the <code class="d_inline">==</code> operator to determine whether the value of a floating point variable is <code class="d_inline">.nan</code>:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (variable == <span class="d_keyword">double</span>.nan) {    <span class="d_comment">// ← <span class="code_note_wrong">WRONG</span></span>
        <span class="d_comment">// ...
</span>    }
</pre>

<p><code class="d_inline">isNaN()</code> function from the <code class="d_inline">std.math</code> module is for determining whether a value is <code class="d_inline">.nan</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.math;
<span class="d_comment">// ...
</span>    <span class="d_keyword">if</span> (isNaN(variable)) {           <span class="d_comment">// ← correct</span>
        <span class="d_comment">// ...
</span>    }
</pre>

<p>Similarly, to determine whether a value is <i>not</i> <code class="d_inline">.nan</code>, one must use <code class="d_inline">!isNaN()</code> because otherwise the <code class="d_inline">!=</code> operator would always produce <code class="d_inline">true</code>.
</p>

<h5 class="subsection">Problemler</h5>
    <ol>
<li>Instead of <code class="d_inline">float</code>, use <code class="d_inline">double</code> (or <code class="d_inline">real</code>) in the program above which added 0.001 a thousand times:

<pre class="d_code">    <span class="hilite"><span class="d_keyword">double</span></span> result = 0;
</pre>

<p>This exercise demonstrates how misleading floating point equality comparisons can be.
</p>

</li>

<li>Modify the calculator from the previous chapter to support floating point types. The new calculator should work more accurately with that change. When trying the calculator, you can enter floating point values in various formats, as in 1000, 1.23, and 1.23e4.
</li>

<li>Write a program that reads 5 floating point values from the input. Make the program first print twice of each value and then one fifth of each value.

<p>This exercise is a preparation for the array concept of the next chapter. If you write this program with what you have seen so far, you will understand arrays more easily and will better appreciate them.
</p>

</li>

</ol> <div class="cozum_link_cok"><p><a target="ddili_cozum" href="floating_point.cozum.html"><i>... çözümler</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Jan 29 21:09:26 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>dmd.clone</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">dmd.clone</h1>
        <section id="module_content"><section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Builds struct member functions if needed and not defined by the user.
 Includes <code class="code">opEquals</code>, <code class="code">opAssign</code>, post blit, copy constructor and destructor.

  </p>
</div>
<div class="ddoc_authors">
  <h4>Authors</h4>
  <p class="para">
    <a href="https://www.digitalmars.com">Walter Bright</a>

  </p>
</div>
<div class="ddoc_license">
  <h4>License</h4>
  <p class="para">
    <a href="https://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">Source:</span>
<a href="https://github.com/dlang/dmd/blob/master/src/dmd/clone.d">clone.d</a>

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">Documentation:</span>
<a href="https://dlang.org/phobos/dmd_clone.html">https://dlang.org/phobos/dmd_clone.html</a>

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">Coverage:</span>
<a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/clone.d">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/clone.d</a>
  </p>
</div>

</section>
<section class="section ddoc_module_members_section">
  <div class="ddoc_module_members">
    <ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#mergeFuncAttrs" id="mergeFuncAttrs"><code class="code">mergeFuncAttrs</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="mergeFuncAttrs"></span>pure StorageClass <code class="code">mergeFuncAttrs</code>(StorageClass <code class="code">s1</code>, const FuncDeclaration <code class="code">f</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Merge function attributes pure, nothrow, @safe, @nogc, and @disable
 from <code class="code">f</code> into <code class="code">s1</code>.

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">StorageClass <code class="code">s1</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      storage class to merge into
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">FuncDeclaration <code class="code">f</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      function
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_returns">
  <h4>Return Value</h4>
  <p class="para">
    merged storage class
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#hasIdentityOpAssign" id="hasIdentityOpAssign"><code class="code">hasIdentityOpAssign</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="hasIdentityOpAssign"></span>FuncDeclaration <code class="code">hasIdentityOpAssign</code>(AggregateDeclaration <code class="code">ad</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Check given aggregate actually has an identity opAssign or not.

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">AggregateDeclaration <code class="code">ad</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      struct or class
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">Scope* <code class="code">sc</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      current scope
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_returns">
  <h4>Return Value</h4>
  <p class="para">
    if found, returns FuncDeclaration of opAssign, otherwise <code class="code">null</code>
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildOpAssign" id="buildOpAssign"><code class="code">buildOpAssign</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildOpAssign"></span>FuncDeclaration <code class="code">buildOpAssign</code>(StructDeclaration <code class="code">sd</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Build opAssign for a <code class="code">struct</code>.

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
     The generated <code class="code">opAssign</code> function has the following signature:

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">ref</span> S opAssign(S s)    <span class="comment">// S is the name of the `struct`
</span></code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
 The opAssign function will be built for a struct <code class="code">S</code> if the
 following constraints are met:

<ol><li><code class="code">S</code> does not have an identity <code class="code">opAssign</code> defined.
</li>
<li><code class="code">S</code> has at least one of the following members: a postblit (user-defined or)
</li>
 generated for fields that have a defined postblit</ol>, a destructor
 (user-defined or generated for fields that have a defined destructor)
 or at least one field that has a defined <code class="code">opAssign</code>.

<ol start="3"><li><code class="code">S</code> does not have any non-mutable fields.
</li>
</ol>
 If <code class="code">S</code> has a disabled destructor or at least one field that has a disabled
 <code class="code">opAssign</code>, <code class="code">S.opAssign</code> is going to be generated, but marked with <code class="code">@disable</code>
<br><br>
 If <code class="code">S</code> defines a destructor, the generated code for <code class="code">opAssign</code> is:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code">S __swap = <span class="keyword">void</span>;
__swap = <span class="keyword">this</span>;   <span class="comment">// bit copy
</span><span class="keyword">this</span> = s;        <span class="comment">// bit copy
</span>__swap.dtor();
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
 Otherwise, if <code class="code">S</code> defines a postblit, the generated code for <code class="code">opAssign</code> is:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">this</span> = s;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
 Note that the parameter to the generated <code class="code">opAssign</code> is passed by value, which means
 that the postblit is going to be called (if it is defined) in both  of the above
 situations before entering the body of <code class="code">opAssign</code>. The assignments in the above generated
 function bodies are blit expressions, so they can be regarded as <code class="code">memcpy</code>s
 (<code class="code">opAssign</code> is not called as this will result in an infinite recursion; the postblit
 is not called because it has already been called when the parameter was passed by value).
<br><br>
 If <code class="code">S</code> does not have a postblit or a destructor, but contains at least one field that defines
 an <code class="code">opAssign</code> function (which is not disabled), then the body will make member-wise
 assignments:
<br><br>

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">this</span>.field1 = s.field1;
<span class="keyword">this</span>.field2 = s.field2;
...;
</code></li>
      </ol>
    </div>
  </div>
</section>
<br><br>
 In this situation, the assignemnts are actual assign expressions (<code class="code">opAssign</code> is used
 if defined).


  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">References:</span>
<a href="https://dlang.org/spec/struct.html#assign-overload">https://dlang.org/spec/struct.html#assign-overload</a>

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">StructDeclaration <code class="code">sd</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      struct to generate opAssign for
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">Scope* <code class="code">sc</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      context
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_returns">
  <h4>Return Value</h4>
  <p class="para">
    generated <code class="code">opAssign</code> function
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#needOpEquals" id="needOpEquals"><code class="code">needOpEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="needOpEquals"></span>bool <code class="code">needOpEquals</code>(StructDeclaration <code class="code">sd</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    We need an opEquals for the struct if
 any fields has an opEquals.
 Generate one if a user-specified one does not exist.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildOpEquals" id="buildOpEquals"><code class="code">buildOpEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildOpEquals"></span>FuncDeclaration <code class="code">buildOpEquals</code>(StructDeclaration <code class="code">sd</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Build opEquals for struct.
      const bool opEquals(const S s) { ... }

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    By fixing <a href="https://issues.dlang.org/show_bug.cgi?id=3789">https://issues.dlang.org/show_bug.cgi?id=3789</a>
 opEquals is changed to be never implicitly generated.
 Now, struct objects comparison s1 == s2 is translated to:
      s1.tupleof == s2.tupleof
 to calculate structural equality. See EqualExp.op_overload.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildXopEquals" id="buildXopEquals"><code class="code">buildXopEquals</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildXopEquals"></span>FuncDeclaration <code class="code">buildXopEquals</code>(StructDeclaration <code class="code">sd</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Build __xopEquals for TypeInfo_Struct
      bool __xopEquals(ref const S p) const
      {
          return this == p;
      }

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This is called by TypeInfo.equals(p1, p2). If the struct does not support
 const objects comparison, it will throw "not implemented" Error in runtime.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildXopCmp" id="buildXopCmp"><code class="code">buildXopCmp</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildXopCmp"></span>FuncDeclaration <code class="code">buildXopCmp</code>(StructDeclaration <code class="code">sd</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Build __xopCmp for TypeInfo_Struct
      int __xopCmp(ref const S p) const
      {
          return this.opCmp(p);
      }

  </p>
</div>
<div class="ddoc_description">
  <h4>Discussion</h4>
  <p class="para">
    This is called by TypeInfo.compare(p1, p2). If the struct does not support
 const objects comparison, it will throw "not implemented" Error in runtime.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildXtoHash" id="buildXtoHash"><code class="code">buildXtoHash</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildXtoHash"></span>FuncDeclaration <code class="code">buildXtoHash</code>(StructDeclaration <code class="code">sd</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Build _xtoHash for non-bitwise hashing
      static hash_t xtoHash(ref const S p) nothrow @trusted;
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildDtors" id="buildDtors"><code class="code">buildDtors</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildDtors"></span>void <code class="code">buildDtors</code>(AggregateDeclaration <code class="code">ad</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Create aggregate destructor for struct/class by aggregating
 all the destructors in userDtors[] with the destructors for
 all the members.
 Sets <code class="code">ad</code>'s fieldDtor, aggrDtor, dtor and tidtor fields.

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">AggregateDeclaration <code class="code">ad</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      struct or class to build destructor for
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">Scope* <code class="code">sc</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      context
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">Note:</span>
Close similarity with StructDeclaration::buildPostBlit(),
 and the ordering changes (runs backward instead of forwards).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildInv" id="buildInv"><code class="code">buildInv</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildInv"></span>FuncDeclaration <code class="code">buildInv</code>(AggregateDeclaration <code class="code">ad</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
     Create inclusive invariant for struct/class by aggregating
 all the invariants in invs[].

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">void</span> __invariant() <span class="keyword">const</span> [<span class="keyword">pure</span> <span class="keyword">nothrow</span> @trusted]
{
    invs[0](), invs[1](), ...;
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildPostBlit" id="buildPostBlit"><code class="code">buildPostBlit</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildPostBlit"></span>FuncDeclaration <code class="code">buildPostBlit</code>(StructDeclaration <code class="code">sd</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Create inclusive postblit for struct by aggregating
 all the postblits in postblits[] with the postblits for
 all the members.
 Note the close similarity with AggregateDeclaration::buildDtor(),
 and the ordering changes (runs forward instead of backwards).
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#buildCopyCtor" id="buildCopyCtor"><code class="code">buildCopyCtor</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="buildCopyCtor"></span>bool <code class="code">buildCopyCtor</code>(StructDeclaration <code class="code">sd</code>, Scope* <code class="code">sc</code>);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Generates a copy constructor if needCopyCtor() returns <code class="code">true</code>.
 The generated copy constructor will be of the form:
   this(ref return scope inout(S) rhs) inout
   {
      this.field1 = rhs.field1;
      this.field2 = rhs.field2;
      ...
   }

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">StructDeclaration <code class="code">sd</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      the <code class="code">struct</code> for which the copy constructor is generated
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">Scope* <code class="code">sc</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      the scope where the copy constructor is generated
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_returns">
  <h4>Return Value</h4>
  <p class="para">
    <code class="code">true</code> if <code class="code">struct</code> <code class="code">sd</code> defines a copy constructor (explicitly or generated),
  <code class="code">false</code> otherwise.
  </p>
</div>

</section>

</div>

</li>
</ul>
  </div>
</section>
</section>
      </article>
    </div>
  </body>
</html>

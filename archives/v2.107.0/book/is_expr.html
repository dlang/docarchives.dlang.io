
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>is Expression - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='is Expression' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5Bis Expression%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/is_expr.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>is Expression</h1>
        
        



<p>The <code class="d_inline">is</code> <i>expression</i> is not related to the <code class="d_inline">is</code> <i>operator</i> that we saw in <a href="null_is.html">The <code class="d_inline">null</code> Value and the <code class="d_inline">is</code> Operator chapter</a>, neither syntactically nor semantically:
</p>

<pre class="d_code">    a <span class="d_keyword">is</span> b            <span class="d_comment">// is operator, which we have seen before
</span>
    <span class="d_keyword">is</span> (<span class="d_comment">/* ... */</span>)    <span class="d_comment">// is expression
</span></pre>

<p>The <code class="d_inline">is</code> expression is evaluated at compile time. It produces an <code class="d_inline">int</code> value, either 0 or 1 depending on the expression specified in parentheses. Although the expression that it takes is not a logical expression, the <code class="d_inline">is</code> expression itself is used as a compile time logical expression. It is especially useful in <code class="d_inline">static if</code> conditionals and template constraints.
</p>

<p>The condition that it takes is always about types, which must be written in one of several syntaxes.
</p>

<h5 class="subsection"><code class="d_inline">is (<i>T</i>)</code></h5>

<p>Determines whether <code class="d_inline">T</code> is valid as a type.
</p>

<p>It is difficult to come up with examples for this use at this point. We will take advantage of it in later chapters with template parameters.
</p>

<pre class="d_code">    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="d_keyword">int</span>)) {
        writeln(<span class="d_string">"valid"</span>);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"invalid"</span>);
    }
</pre>

<p><code class="d_inline">int</code> above is a valid type:
</p>

<pre class="shell">valid
</pre>

<p>As another example, because <code class="d_inline">void</code> is not valid as the key type of an associative array, the <code class="d_inline">else</code> block would be enabled below:
</p>

<pre class="d_code">    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (string[<span class="d_keyword">void</span>])) {
        writeln(<span class="d_string">"valid"</span>);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"invalid"</span>);
    }
</pre>

<p>The output:
</p>

<pre class="shell">invalid
</pre>


<h5 class="subsection"><code class="d_inline">is (<i>T Alias</i>)</code></h5>

<p>Works in the same way as the previous syntax. Additionally, defines <code class="d_inline">Alias</code> as an alias of <code class="d_inline">T</code>:
</p>

<pre class="d_code">    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="d_keyword">int</span> NewAlias)) {
        writeln(<span class="d_string">"valid"</span>);
        NewAlias var = 42; <span class="d_comment">// int and NewAlias are the same
</span>
    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"invalid"</span>);
    }
</pre>

<p>Such aliases are useful especially in more complex <code class="d_inline">is</code> expressions as we will see below.
</p>

<h5 class="subsection"><code class="d_inline">is (<i>T</i> : <i>OtherT</i>)</code></h5>

<p>Determines whether <code class="d_inline">T</code> can automatically be converted to <code class="d_inline">OtherT</code>.
</p>

<p>It is used for detecting automatic type conversions which we have seen in <a href="cast.html">the Type Conversions chapter</a>, as well as relationships like "this type is of that type", which we have seen in <a href="inheritance.html">the Inheritance chapter</a>.
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">interface</span> Clock {
    <span class="d_keyword">void</span> tellTime();
}

<span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_keyword">override</span> <span class="d_keyword">void</span> tellTime() {
        writeln(<span class="d_string">"10:00"</span>);
    }
}

<span class="d_keyword">void</span> myFunction(T)(T parameter) {
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="hilite"><span class="d_keyword">is</span> (T : Clock)</span>) {
        <span class="d_comment">// If we are here then T can be used as a Clock
</span>        writeln(<span class="d_string">"This is a Clock; we can tell the time"</span>);
        parameter.tellTime();

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"This is not a Clock"</span>);
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> var = <span class="d_keyword">new</span> AlarmClock;
    myFunction(var);
    myFunction(42);
}
</pre>

<p>When the <code class="d_inline">myFunction()</code> template is instantiated for a type that can be used like a <code class="d_inline">Clock</code>, then the <code class="d_inline">tellTime()</code> member function is called on its parameter. Otherwise, the <code class="d_inline">else</code> clause gets compiled:
</p>

<pre class="shell">This is a Clock; we can tell the time  <span class="shell_note">← for AlarmClock</span>
10:00                                  <span class="shell_note">← for AlarmClock</span>
This is not a Clock                    <span class="shell_note">← for int</span>
</pre>

<h5 class="subsection"><code class="d_inline">is (<i>T Alias</i> : <i>OtherT</i>)</code></h5>

<p>Works in the same way as the previous syntax. Additionally, defines <code class="d_inline">Alias</code> as an alias of <code class="d_inline">T</code>.
</p>

<h5 class="subsection"><code class="d_inline">is (<i>T</i> == <i>Specifier</i>)</code></h5>

<p>Determines whether <code class="d_inline">T</code> <i>is the same type</i> as <code class="d_inline">Specifier</code> or whether <code class="d_inline">T</code> <i>matches that specifier</i>.
</p>

<h6>Whether the same type</h6>

<p>When we change the previous example to use <code class="d_inline">==</code> instead of <code class="d_inline">:</code>, the condition would not be satisfied for <code class="d_inline">AlarmClock</code>:
</p>

<pre class="d_code">    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T <span class="hilite">==</span> Clock)) {
        writeln(<span class="d_string">"This is a Clock; we can tell the time"</span>);
        parameter.tellTime();

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"This is not a Clock"</span>);
    }
</pre>

<p>Although <code class="d_inline">AlarmClock</code> <i>is a</i> <code class="d_inline">Clock</code>, it is not exactly the same type as <code class="d_inline">Clock</code>. For that reason, now the condition is invalid for both <code class="d_inline">AlarmClock</code> and <code class="d_inline">int</code>:
</p>

<pre class="shell">This is not a Clock
This is not a Clock
</pre>

<h6>Whether matches the same specifier</h6>

<p>When <code class="d_inline">Specifier</code> is one of the following keywords, this use of <code class="d_inline">is</code> determines whether the type matches that specifier (we will see some of these keywords in later chapters):
</p>

<ul><li><a id="ix_is Expression.struct, is expression" content="struct, is expression"></a> <code class="d_inline">struct</code></li>
<li><a id="ix_is Expression.union, is expression" content="union, is expression"></a> <code class="d_inline">union</code></li>
<li><a id="ix_is Expression.class, is expression" content="class, is expression"></a> <code class="d_inline">class</code></li>
<li><a id="ix_is Expression.interface, is expression" content="interface, is expression"></a> <code class="d_inline">interface</code></li>
<li><a id="ix_is Expression.enum, is expression" content="enum, is expression"></a> <code class="d_inline">enum</code></li>
<li><a id="ix_is Expression.function, is expression" content="function, is expression"></a> <code class="d_inline">function</code></li>
<li><a id="ix_is Expression.delegate, is expression" content="delegate, is expression"></a> <code class="d_inline">delegate</code></li>
<li><a id="ix_is Expression.const, is expression" content="const, is expression"></a> <code class="d_inline">const</code></li>
<li><a id="ix_is Expression.immutable, is expression" content="immutable, is expression"></a> <code class="d_inline">immutable</code></li>
<li><a id="ix_is Expression.shared, is expression" content="shared, is expression"></a> <code class="d_inline">shared</code></li>
</ul>

<pre class="d_code"><span class="d_keyword">void</span> myFunction(T)(T parameter) {
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T == <span class="d_keyword">class</span>)) {
        writeln(<span class="d_string">"This is a class type"</span>);

    } <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T == <span class="d_keyword">enum</span>)) {
        writeln(<span class="d_string">"This is an enum type"</span>);

    } <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T == <span class="d_keyword">const</span>)) {
        writeln(<span class="d_string">"This is a const type"</span>);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"This is some other type"</span>);
    }
}
</pre>

<p>Function templates can take advantage of such information to behave differently depending on the type that the template is instantiated with. The following code demonstrates how different blocks of the template above get compiled for different types:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> var = <span class="d_keyword">new</span> AlarmClock;
    myFunction(var);

    <span class="d_comment">// (enum WeekDays will be defined below for another example)
</span>    myFunction(WeekDays.Monday);

    <span class="d_keyword">const</span> <span class="d_keyword">double</span> number = 1.2;
    myFunction(number);

    myFunction(42);
</pre>

<p>The output:
</p>

<pre class="shell">This is a class type
This is an enum type
This is a const type
This is some other type
</pre>

<h5 class="subsection"><code class="d_inline">is (<i>T identifier</i> == <i>Specifier</i>)</code></h5>

<p><a id="ix_is Expression.super, is expression" content="super, is expression"></a>
<a id="ix_is Expression.return, is expression" content="return, is expression"></a>
<a id="ix_is Expression.__parameters, is expression" content="__parameters, is expression"></a>
Works in the same way as the previous syntax. <code class="d_inline">identifier</code> is either an alias of the type; or some other information depending on <code class="d_inline">Specifier</code>:
</p>

<table class="wide" border="1" cellpadding="4" cellspacing="0">
<tr>	<th  style="padding-left:1em; padding-right:1em;" scope="col"><code class="d_inline">Specifier</code></th>
<th scope="col">The meaning of <code class="d_inline">identifier</code></th>

</tr>

<tr>	<td><code class="d_inline">struct</code></td>
<td>alias of the type that satisfied the condition</td>
</tr>

<tr>	<td><code class="d_inline">union</code></td>
<td>alias of the type that satisfied the condition</td>
</tr>

<tr>	<td><code class="d_inline">class</code></td>
<td>alias of the type that satisfied the condition</td>
</tr>

<tr>	<td><code class="d_inline">interface</code></td>
<td>alias of the type that satisfied the condition</td>
</tr>

<tr>	<td><code class="d_inline">super</code></td>
<td>a <i>tuple</i> consisting of the base classes and the interfaces</td>
</tr>

<tr>	<td><code class="d_inline">enum</code></td>
<td>the actual implementation type of the <code class="d_inline">enum</code></td>
</tr>

<tr>	<td><code class="d_inline">function</code></td>
<td>a <i>tuple</i> consisting of the function parameters</td>
</tr>

<tr>	<td><code class="d_inline">delegate</code></td>
<td>the type of the <code class="d_inline">delegate</code></td>
</tr>

<tr>	<td><code class="d_inline">return</code></td>
<td>the return type of the regular function, the <code class="d_inline">delegate</code>, or the function pointer</td>
</tr>

<tr>	<td><code class="d_inline">__parameters</code></td>
<td>a <i>tuple</i> consisting of the parameters of the regular function, the <code class="d_inline">delegate</code>, or the function pointer</td>
</tr>

<tr>	<td><code class="d_inline">const</code></td>
<td>alias of the type that satisfied the condition</td>
</tr>

<tr>	<td><code class="d_inline">immutable</code></td>
<td>alias of the type that satisfied the condition</td>
</tr>

<tr>	<td><code class="d_inline">shared</code></td>
<td>alias of the type that satisfied the condition</td>
</tr>

</table>

<p>Let's first define various types before experimenting with this syntax:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">interface</span> Clock {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">enum</span> WeekDays {
    Monday, Tuesday, Wednesday, Thursday, Friday,
    Saturday, Sunday
}

<span class="d_keyword">char</span> foo(<span class="d_keyword">double</span> d, <span class="d_keyword">int</span> i, Clock c) {
    <span class="d_keyword">return</span> 'a';
}
</pre>

<p>The following function template uses different specifiers with this syntax of the <code class="d_inline">is</code> expression:
</p>

<pre class="d_code"><span class="d_keyword">void</span> myFunction(T)(T parameter) {
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T LocalAlias == <span class="d_keyword">struct</span>)) {
        writefln(<span class="d_string">"\n--- struct ---"</span>);
        <span class="d_comment">// LocalAlias is the same as T. 'parameter' is the
</span>        <span class="d_comment">// struct object that has been passed to this
</span>        <span class="d_comment">// function.
</span>
        writefln(<span class="d_string">"Constructing a new %s object by copying it."</span>,
                 LocalAlias.stringof);
        LocalAlias theCopy = parameter;
    }

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T baseTypes == <span class="d_keyword">super</span>)) {
        writeln(<span class="d_string">"\n--- super ---"</span>);
        <span class="d_comment">// The 'baseTypes' tuple contains all of the base
</span>        <span class="d_comment">// types of T. 'parameter' is the class variable that
</span>        <span class="d_comment">// has been passed to this function.
</span>
        writefln(<span class="d_string">"class %s has %s base types."</span>,
                 T.stringof, baseTypes.length);

        writeln(<span class="d_string">"All of the bases: "</span>, baseTypes.stringof);
        writeln(<span class="d_string">"The topmost base: "</span>, baseTypes[0].stringof);
    }

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T ImplT == <span class="d_keyword">enum</span>)) {
        writeln(<span class="d_string">"\n--- enum ---"</span>);
        <span class="d_comment">// 'ImplT' is the actual implementation type of this
</span>        <span class="d_comment">//  enum type. 'parameter' is the enum value that has
</span>        <span class="d_comment">//  been passed to this function.
</span>
        writefln(<span class="d_string">"The implementation type of enum %s is %s"</span>,
                 T.stringof, ImplT.stringof);
    }

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T ReturnT == <span class="d_keyword">return</span>)) {
        writeln(<span class="d_string">"\n--- return ---"</span>);
        <span class="d_comment">// 'ReturnT' is the return type of the function
</span>        <span class="d_comment">// pointer that has been passed to this function.
</span>
        writefln(<span class="d_string">"This is a function with a return type of %s:"</span>,
                 ReturnT.stringof);
        writeln(<span class="d_string">"    "</span>, T.stringof);
        write(<span class="d_string">"calling it... "</span>);

        <span class="d_comment">// Note: Function pointers can be called like
</span>        <span class="d_comment">// functions
</span>        ReturnT result = parameter(1.5, 42, <span class="d_keyword">new</span> AlarmClock);
        writefln(<span class="d_string">"and the result is '%s'"</span>, result);
    }
}
</pre>

<p>Let's now call that function template with various types that we have defined above:
</p>

<pre class="d_code">    <span class="d_comment">// Calling with a struct object
</span>    myFunction(Point());

    <span class="d_comment">// Calling with a class reference
</span>    myFunction(<span class="d_keyword">new</span> AlarmClock);

    <span class="d_comment">// Calling with an enum value
</span>    myFunction(WeekDays.Monday);

    <span class="d_comment">// Calling with a function pointer
</span>    myFunction(&amp;foo);
</pre>

<p>The output:
</p>

<pre class="shell">--- struct ---
Constructing a new Point object by copying it.

--- super ---
class AlarmClock has 2 base types.
All of the bases: (Object, Clock)
The topmost base: Object

--- enum ---
The implementation type of enum WeekDays is int

--- return ---
This is a function with a return type of char:
    char function(double d, int i, Clock c)
calling it... and the result is 'a'
</pre>

<h5 class="subsection"><code class="d_inline">is (/* ... */ <i>Specifier</i>, <i>TemplateParamList</i>)</code></h5>

<p>There are four different syntaxes of the <code class="d_inline">is</code> expression that uses a template parameter list:
</p>

<ul>
<li><code class="d_inline">is (<i>T</i> : <i>Specifier</i>, <i>TemplateParamList</i>)</code></li>

<li><code class="d_inline">is (<i>T</i> == <i>Specifier</i>, <i>TemplateParamList</i>)</code></li>

<li><code class="d_inline">is (<i>T identifier</i> : <i>Specifier</i>, <i>TemplateParamList</i>)</code></li>

<li><code class="d_inline">is (<i>T identifier</i> == <i>Specifier</i>, <i>TemplateParamList</i>)</code></li>

</ul>

<p>These syntaxes allow for more complex cases.
</p>

<p><code class="d_inline">identifier</code>, <code class="d_inline">Specifier</code>, <code class="d_inline">:</code>, and <code class="d_inline">==</code> all have the same meanings as described above.
</p>

<p><code class="d_inline">TemplateParamList</code> is both a part of the condition that needs to be satisfied and a facility to define additional aliases if the condition is indeed satisfied. It works in the same way as template type deduction.
</p>

<p>As a simple example, let's assume that an <code class="d_inline">is</code> expression needs to match associative arrays that have keys of type <code class="d_inline">string</code>:
</p>

<pre class="d_code">    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T == Value[Key],   <span class="d_comment">// (1)
</span>                   Value,             <span class="d_comment">// (2)
</span>                   Key : string)) {   <span class="d_comment">// (3)
</span></pre>

<p>That condition can be explained in three parts where the last two are parts of the <code class="d_inline">TemplateParamList</code>:
</p>

<ol><li>If <code class="d_inline">T</code> matches the syntax of <code class="d_inline">Value[Key]</code></li>
<li>If <code class="d_inline">Value</code> is a type</li>
<li>If <code class="d_inline">Key</code> is <code class="d_inline">string</code> (remember <a href="templates.html">template specialization syntax</a>)</li>
</ol>

<p>Having <code class="d_inline">Value[Key]</code> as the <code class="d_inline">Specifier</code> requires that <code class="d_inline">T</code> is an associative array. Leaving <code class="d_inline">Value</code> <i>as is</i> means that it can be any type. Additionally, the key type of the associative array must be <code class="d_inline">string</code>. As a result, the previous <code class="d_inline">is</code> expression means "if <code class="d_inline">T</code> is an associative array where the key type is <code class="d_inline">string</code>."
</p>

<p>The following program tests that <code class="d_inline">is</code> expression with four different types:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> myFunction(T)(T parameter) {
    writefln(<span class="d_string">"\n--- Called with %s ---"</span>, T.stringof);

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (T == Value[Key],
                   Value,
                   Key : string)) {

        writeln(<span class="d_string">"Yes, the condition has been satisfied."</span>);

        writeln(<span class="d_string">"The value type: "</span>, Value.stringof);
        writeln(<span class="d_string">"The key type  : "</span>, Key.stringof);

    } <span class="d_keyword">else</span> {
        writeln(<span class="d_string">"No, the condition has not been satisfied."</span>);
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">int</span> number;
    myFunction(number);

    <span class="d_keyword">int</span>[string] intTable;
    myFunction(intTable);

    <span class="d_keyword">double</span>[string] doubleTable;
    myFunction(doubleTable);

    <span class="d_keyword">dchar</span>[<span class="d_keyword">long</span>] dcharTable;
    myFunction(dcharTable);
}
</pre>

<p>The condition is satisfied only if the key type is <code class="d_inline">string</code>:
</p>

<pre class="shell">--- Called with int ---
No, the condition has not been satisfied.

--- Called with int[string] ---
Yes, the condition has been satisfied.
The value type: int
The key type  : string

--- Called with double[string] ---
Yes, the condition has been satisfied.
The value type: double
The key type  : string

--- Called with dchar[long] ---
No, the condition has not been satisfied.
</pre>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Fri Feb  2 10:24:02 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Operator Overloading - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Operator Overloading' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BOperator Overloading%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/operator_overloading.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Operator Overloading</h1>
        
        



<p>The topics covered in this chapter apply mostly for classes as well. The biggest difference is that the behavior of assignment operation <code class="d_inline">opAssign()</code> cannot be overloaded for classes.
</p>

<p>Operator overloading involves many concepts, some of which will be covered later in the book (templates, <code class="d_inline">auto ref</code>, etc.). For that reason, you may find this chapter to be harder to follow than the previous ones.
</p>

<p>Operator overloading enables defining how user-defined types behave when used with operators. In this context, the term <i>overload</i> means providing the definition of an operator for a specific type.
</p>

<p>We have seen how to define structs and their member functions in previous chapters. As an example, we have defined the <code class="d_inline">increment()</code> member function to be able to add <code class="d_inline">Duration</code> objects to <code class="d_inline">TimeOfDay</code> objects. Here are the two structs from previous chapters, with only the parts that are relevant to this chapter:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Duration {
    <span class="d_keyword">int</span> minute;
}

<span class="d_keyword">struct</span> TimeOfDay {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">void</span> <span class="hilite">increment</span>(Duration duration) {
        minute += duration.minute;

        hour += minute / 60;
        minute %= 60;
        hour %= 24;
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> lunchTime = TimeOfDay(12, 0);
    lunchTime<span class="hilite">.increment</span>(Duration(10));
}
</pre>

<p>A benefit of member functions is being able to define operations of a type alongside the member variables of that type.
</p>

<p>Despite their advantages, member functions can be seen as being limited compared to operations on fundamental types. After all, fundamental types can readily be used with operators:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> weight = 50;
    weight <span class="hilite">+=</span> 10;                       <span class="d_comment">// by an operator
</span></pre>

<p>According to what we have seen so far, similar operations can only be achieved by member functions for user-defined types:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> lunchTime = TimeOfDay(12, 0);
    lunchTime<span class="hilite">.increment</span>(Duration(10));  <span class="d_comment">// by a member function
</span></pre>

<p>Operator overloading enables using structs and classes with operators as well. For example, assuming that the <code class="d_inline">+=</code> operator is defined for <code class="d_inline">TimeOfDay</code>, the operation above can be written in exactly the same way as with fundamental types:
</p>

<pre class="d_code">    lunchTime <span class="hilite">+=</span> Duration(10);          <span class="d_comment">// by an operator
</span>                                        <span class="d_comment">// (even for a struct)
</span></pre>

<p>Before getting to the details of operator overloading, let's first see how the line above would be enabled for <code class="d_inline">TimeOfDay</code>. What is needed is to redefine the <code class="d_inline">increment()</code> member function under the special name <code class="d_inline">opOpAssign(string op)</code> and also to specify that this definition is for the <code class="d_inline">+</code> character. As it will be explained below, this definition actually corresponds to the <code class="d_inline">+=</code> operator.
</p>

<p>The definition of this member function does not look like the ones that we have seen so far. That is because <code class="d_inline">opOpAssign</code> is actually a <i>function template</i>. Since we will see templates in much later chapters, I will have to ask you to accept the operator overloading syntax as is for now:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> TimeOfDay {
<span class="d_comment">// ...
</span>    <span class="d_keyword">ref</span> TimeOfDay opOpAssign(string op)(Duration duration) <span class="d_comment">// (1)
</span>            <span class="d_keyword">if</span> (op == <span class="d_string">"+"</span>) {                               <span class="d_comment">// (2)
</span>
        minute += duration.minute;
        hour += minute / 60;
        minute %= 60;
        hour %= 24;

        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}
</pre>

<p>The template definition consists of two parts:
</p>

<ol>
<li><code class="d_inline">opOpAssign(string op)</code>: This part must be written as is and should be accepted as the <i>name</i> of the function. We will see below that there are other member functions in addition to <code class="d_inline">opOpAssign</code>.
</li>

<li><code class="d_inline">if (op == <code class="d_inline"><span class="d_string">"+"</span></code>)</code>: <code class="d_inline">opOpAssign</code> is used for more than one operator overload. <code class="d_inline"><code class="d_inline"><span class="d_string">"+"</span></code></code> specifies that this is the operator overload that corresponds to the <code class="d_inline">+</code> character. This syntax is a <i>template constraint</i>, which will also be covered in later chapters.
</li>

</ol>

<p>Also note that this time the return type is different from the return type of the <code class="d_inline">increment()</code> member function: It is not <code class="d_inline">void</code> anymore. We will discuss the return types of operators later below.
</p>

<p>Behind the scenes, the compiler replaces the uses of the <code class="d_inline">+=</code> operator with calls to the <code class="d_inline">opOpAssign!<code class="d_inline"><span class="d_string">"+"</span></code></code> member function:
</p>

<pre class="d_code">    lunchTime += Duration(10);

    <span class="d_comment">// The following line is the equivalent of the previous one
</span>    lunchTime.opOpAssign!<span class="d_string">"+"</span>(Duration(10));
</pre>

<p>The <code class="d_inline">!<code class="d_inline"><span class="d_string">"+"</span></code></code> part that is after <code class="d_inline">opOpAssign</code> specifies that this call is for the definition of the operator for the <code class="d_inline">+</code> character. We will cover this template syntax in later chapters as well.
</p>

<p>Note that the operator definition that corresponds to <code class="d_inline">+=</code> is defined by <code class="d_inline"><span class="d_string">"+"</span></code>, not by <code class="d_inline"><span class="d_string">"+="</span></code>. The <code class="d_inline">Assign</code> in the name of <code class="d_inline">opOpAssign()</code> already implies that this name is for an assignment operator.
</p>

<p>Being able to define the behaviors of operators brings a responsibility: The programmer must observe expectations. As an extreme example, the previous operator could have been defined to decrement the time value instead of incrementing it. However, people who read the code would still expect the value to be incremented by the <code class="d_inline">+=</code> operator.
</p>

<p>To some extent, the return types of operators can also be chosen freely. Still, general expectations must be observed for the return types as well.
</p>

<p>Keep in mind that operators that behave unnaturally would cause confusion and bugs.
</p>

<h5 class="subsection">Overloadable operators</h5>

<p>There are different kinds of operators that can be overloaded.
</p>

<h6><a id="ix_Operator Overloading.unary operator" content="unary operator"></a> <a id="ix_Operator Overloading.operator, unary" content="operator, unary"></a> <a id="ix_Operator Overloading.opUnary" content="opUnary"></a> Unary operators</h6>

<p>An operator that takes a single operand is called a unary operator:
</p>

<pre class="d_code">    ++weight;
</pre>

<p><code class="d_inline">++</code> is a unary operator because it works on a single variable.
</p>

<p>Unary operators are defined by member functions named <code class="d_inline">opUnary</code>. <code class="d_inline">opUnary</code> does not take any parameters because it uses only the object that the operator is being executed on.
</p>

<p><a id="ix_Operator Overloading.-, negation" content="-, negation"></a>
<a id="ix_Operator Overloading.+, plus sign" content="+, plus sign"></a>
<a id="ix_Operator Overloading.~, bitwise complement" content="~, bitwise complement"></a>
<a id="ix_Operator Overloading.*, pointee access" content="*, pointee access"></a>
<a id="ix_Operator Overloading.++, pre-increment" content="++, pre-increment"></a>
<a id="ix_Operator Overloading.--, pre-decrement" content="--, pre-decrement"></a>
The overloadable unary operators and the corresponding operator strings are the following:
</p>

<table class="full" border="1" cellpadding="4" cellspacing="0"><tr align="center"><th scope="col">Operator</th> <th scope="col">Description</th> <th scope="col">Operator String</th></tr>
<tr align="center"><td>-object</td> <td>negative of (numeric complement of)</td> <td>"-"</td></tr>
<tr align="center"><td>+object</td> <td>the same value as (or, a copy of)</td> <td>"+"</td></tr>
<tr align="center"><td>~object</td> <td>bitwise negation</td> <td>"~"</td></tr>
<tr align="center"><td>*object</td> <td>access to what it points to</td> <td>"*"</td></tr>
<tr align="center"><td>++object</td> <td>increment</td> <td>"++"</td></tr>
<tr align="center"><td>--object</td> <td>decrement</td> <td>"--"</td></tr>
</table>

<p>For example, the <code class="d_inline">++</code> operator for <code class="d_inline">Duration</code> can be defined like this:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Duration {
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">ref</span> Duration opUnary(string op)()
            <span class="d_keyword">if</span> (op == <span class="d_string">"++"</span>) {
        ++minute;
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}
</pre>

<p>Note that the return type of the operator is marked as <code class="d_inline">ref</code> here as well. This will be explained later below.
</p>

<p><code class="d_inline">Duration</code> objects can now be incremented by <code class="d_inline">++</code>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> duration = Duration(20);
    ++duration;
</pre>

<p><a id="ix_Operator Overloading.++, post-increment" content="++, post-increment"></a> <a id="ix_Operator Overloading.--, post-decrement" content="--, post-decrement"></a> The post-increment and post-decrement operators cannot be overloaded. The <code class="d_inline">object++</code> and <code class="d_inline">object--</code> uses are handled by the compiler automatically by saving the previous value of the object. For example, the compiler applies the equivalent of the following code for post-increment:
</p>

<pre class="d_code">    <span class="d_comment">/* The previous value is copied by the compiler
     * automatically: */</span>
    Duration __previousValue__ = duration;

    <span class="d_comment">/* The ++ operator is called: */</span>
    ++duration;

    <span class="d_comment">/* Then __previousValue__ is used as the value of the
     * post-increment operation. */</span>
</pre>

<p>Unlike some other languages, the copy inside post-increment has no cost in D if the value of the post-increment expression is not actually used. This is because the compiler replaces such post-increment expressions with their pre-increment counterparts:
</p>

<pre class="d_code">    <span class="d_comment">/* The value of the expression is not used below. The
     * only effect of the expression is incrementing 'i'. */</span>
    i++;
</pre>

<p>Because the <i>previous value</i> of <code class="d_inline">i</code> is not actually used above, the compiler replaces the expression with the following one:
</p>

<pre class="d_code">    <span class="d_comment">/* The expression that is actually used by the compiler: */</span>
    ++i;
</pre>

<p>Additionally, if an <code class="d_inline">opBinary</code> overload supports the <code class="d_inline">duration += 1</code> usage, then <code class="d_inline">opUnary</code> need not be overloaded for <code class="d_inline">++duration</code> and <code class="d_inline">duration++</code>. Instead, the compiler uses the <code class="d_inline">duration += 1</code> expression behind the scenes. Similarly, the <code class="d_inline">duration -= 1</code> overload covers the uses of <code class="d_inline">--duration</code> and <code class="d_inline">duration--</code> as well.
</p>

<h6><a id="ix_Operator Overloading.binary operator" content="binary operator"></a> <a id="ix_Operator Overloading.operator, binary" content="operator, binary"></a> Binary operators</h6>

<p>An operator that takes two operands is called a binary operator:
</p>

<pre class="d_code">    totalWeight <span class="hilite">=</span> boxWeight <span class="hilite">+</span> chocolateWeight;
</pre>

<p>The line above has two separate binary operators: the <code class="d_inline">+</code> operator, which adds the values of the two operands that are on its two sides, and the <code class="d_inline">=</code> operator that assigns the value of its right-hand operand to its left-hand operand.
</p>

<p><a id="ix_Operator Overloading.+, addition" content="+, addition"></a>
<a id="ix_Operator Overloading.-, subtraction" content="-, subtraction"></a>
<a id="ix_Operator Overloading.*, multiplication" content="*, multiplication"></a>
<a id="ix_Operator Overloading./" content="/"></a>
<a id="ix_Operator Overloading.%" content="%"></a>
<a id="ix_Operator Overloading.^^" content="^^"></a>
<a id="ix_Operator Overloading.&amp;, bitwise and" content="&amp;, bitwise and"></a>
<a id="ix_Operator Overloading.|" content="|"></a>
<a id="ix_Operator Overloading.^, bitwise exclusive or" content="^, bitwise exclusive or"></a>
<a id="ix_Operator Overloading.&lt;&lt;" content="&lt;&lt;"></a>
<a id="ix_Operator Overloading.&gt;&gt;" content="&gt;&gt;"></a>
<a id="ix_Operator Overloading.&gt;&gt;&gt;" content="&gt;&gt;&gt;"></a>
<a id="ix_Operator Overloading.~, concatenation" content="~, concatenation"></a>
<a id="ix_Operator Overloading.in, operator" content="in, operator"></a>
<a id="ix_Operator Overloading.==" content="=="></a>
<a id="ix_Operator Overloading.!=" content="!="></a>
<a id="ix_Operator Overloading.&lt;, less than" content="&lt;, less than"></a>
<a id="ix_Operator Overloading.&lt;=" content="&lt;="></a>
<a id="ix_Operator Overloading.&gt;, greater than" content="&gt;, greater than"></a>
<a id="ix_Operator Overloading.&gt;=" content="&gt;="></a>
<a id="ix_Operator Overloading.=" content="="></a>
<a id="ix_Operator Overloading.+=" content="+="></a>
<a id="ix_Operator Overloading.-=" content="-="></a>
<a id="ix_Operator Overloading.*=" content="*="></a>
<a id="ix_Operator Overloading./=" content="/="></a>
<a id="ix_Operator Overloading.%=" content="%="></a>
<a id="ix_Operator Overloading.^^=" content="^^="></a>
<a id="ix_Operator Overloading.&amp;=" content="&amp;="></a>
<a id="ix_Operator Overloading.|=" content="|="></a>
<a id="ix_Operator Overloading.^=" content="^="></a>
<a id="ix_Operator Overloading.&lt;&lt;=" content="&lt;&lt;="></a>
<a id="ix_Operator Overloading.&gt;&gt;=" content="&gt;&gt;="></a>
<a id="ix_Operator Overloading.&gt;&gt;&gt;=" content="&gt;&gt;&gt;="></a>
<a id="ix_Operator Overloading.~=" content="~="></a>
<a id="ix_Operator Overloading.opBinary" content="opBinary"></a>
<a id="ix_Operator Overloading.opAssign" content="opAssign"></a>
<a id="ix_Operator Overloading.opOpAssign" content="opOpAssign"></a>
<a id="ix_Operator Overloading.opBinaryRight" content="opBinaryRight"></a>
The rightmost column below describes the category of each operator. The ones marked as "=" assign to the left-hand side object.
</p>

<table class="full" border="1" cellpadding="4" cellspacing="0"><tr align="center"><th scope="col"><br/>Operator</th> <th scope="col"><br/>Description</th> <th scope="col"><br/>Function name</th> <th scope="col">Function name<br/>for right-hand side</th> <th scope="col"><br/>Category</th></tr>
<tr align="center"><td>+</td> <td>add</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>arithmetic</td></tr>
<tr align="center"><td>-</td> <td>subtract</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>arithmetic</td></tr>
<tr align="center"><td>*</td> <td>multiply</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>arithmetic</td></tr>
<tr align="center"><td>/</td> <td>divide</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>arithmetic</td></tr>
<tr align="center"><td>%</td> <td>remainder of</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>arithmetic</td></tr>
<tr align="center"><td>^^</td> <td>to the power of</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>arithmetic</td></tr>
<tr align="center"><td>&amp;</td> <td>bitwise <i>and</i></td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>bitwise</td></tr>
<tr align="center"><td>|</td> <td>bitwise <i>or</i></td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>bitwise</td></tr>
<tr align="center"><td>^</td> <td>bitwise <i>xor</i></td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>bitwise</td></tr>
<tr align="center"><td>&lt;&lt;</td> <td>left-shift</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>bitwise</td></tr>
<tr align="center"><td>&gt;&gt;</td> <td>right-shift</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>bitwise</td></tr>
<tr align="center"><td>&gt;&gt;&gt;</td> <td>unsigned right-shift</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td>bitwise</td></tr>
<tr align="center"><td>~</td> <td>concatenate</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td></td></tr>
<tr align="center"><td>in</td> <td>whether contained in</td> <td>	opBinary</td> <td>	opBinaryRight</td> <td></td></tr>
<tr align="center"><td>==</td> <td>whether equal to</td> <td>	opEquals</td> <td>	-</td> <td>logical</td></tr>
<tr align="center"><td>!=</td> <td>whether not equal to</td> <td>	opEquals</td> <td>	-</td> <td>logical</td></tr>
<tr align="center"><td>&lt;</td> <td>whether before</td> <td>	opCmp</td> <td>	-</td> <td>sorting</td></tr>
<tr align="center"><td>&lt;=</td> <td>whether not after</td> <td>	opCmp</td> <td>	-</td> <td>sorting</td></tr>
<tr align="center"><td>&gt;</td> <td>whether after</td> <td>	opCmp</td> <td>	-</td> <td>sorting</td></tr>
<tr align="center"><td>&gt;=</td> <td>whether not before</td> <td>	opCmp</td> <td>	-</td> <td>sorting</td></tr>
<tr align="center"><td>=</td> <td>assign</td> <td>	opAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>+=</td> <td>increment by</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>-=</td> <td>decrement by</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>*=</td> <td>multiply and assign</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>/=</td> <td>divide and assign</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>%=</td> <td>assign the remainder of</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>^^=</td> <td>assign the power of</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>&amp;=</td> <td>assign the result of &amp;</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>|=</td> <td>assign the result of |</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>^=</td> <td>assign the result of ^</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>&lt;&lt;=</td> <td>assign the result of &lt;&lt;</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>&gt;&gt;=</td> <td>assign the result of &gt;&gt;</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>&gt;&gt;&gt;=</td> <td>assign the result of &gt;&gt;&gt;</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
<tr align="center"><td>~=</td> <td>append</td> <td>	opOpAssign</td> <td>	-</td> <td>=</td></tr>
</table>

<p><code class="d_inline">opBinaryRight</code> is for when the object can appear on the right-hand side of the operator. Let's assume a binary operator that we shall call <i>op</i> appears in the program:
</p>

<pre class="d_code">    x <i>op</i> y
</pre>

<p>In order to determine what member function to call, the compiler considers the following two options:
</p>

<pre class="d_code">    <span class="d_comment">// the definition for x being on the left:
</span>    x.opBinary!<span class="d_string">"op"</span>(y);

    <span class="d_comment">// the definition for y being on the right:
</span>    y.opBinaryRight!<span class="d_string">"op"</span>(x);
</pre>

<p>The compiler picks the option that is a better match than the other.
</p>

<p><code class="d_inline">opBinaryRight</code> is useful when defining arithmetic types that would normally work on both sides of an operator like e.g. <code class="d_inline">int</code> does:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> x = MyInt(42);
    x + 1;    <span class="d_comment">// calls opBinary!"+"
</span>    1 + x;    <span class="d_comment">// calls opBinaryRight!"+"
</span></pre>

<p>Another common use of <code class="d_inline">opBinaryRight</code> is the <code class="d_inline">in</code> operator. It usually makes more sense to define <code class="d_inline">opBinaryRight</code> for the object that appears on the right-hand side of <code class="d_inline">in</code>. We will see an example of this below.
</p>

<p>The parameter name <code class="d_inline">rhs</code> that appears in the following definitions is short for <i>right-hand side</i>. It denotes the operand that appears on the right-hand side of the operator:
</p>

<pre class="d_code">    x <i>op</i> y
</pre>

<p>For the expression above, the <code class="d_inline">rhs</code> parameter would represent the variable <code class="d_inline">y</code>.
</p>

<h5 class="subsection">Element indexing and slicing operators</h5>

<p>The following operators enable using a type as a collection of elements:
</p>

<table class="full" border="1" cellpadding="4" cellspacing="0"><tr align="center"><th scope="col">Description</th> <th scope="col">Function Name</th> <th scope="col">Sample Usage</th></tr>
<tr align="center"><td>element access</td> <td>opIndex</td> <td>collection[i]</td></tr>
<tr align="center"><td>assignment to element</td> <td>opIndexAssign</td> <td>collection[i] = 7</td></tr>
<tr align="center"><td>unary operation on element</td> <td>opIndexUnary</td> <td>++collection[i]</td></tr>
<tr align="center"><td>operation with assignment on element</td> <td>opIndexOpAssign</td> <td>collection[i] *= 2</td></tr>
<tr align="center"><td>number of elements</td> <td>opDollar</td> <td>collection[$ - 1]</td></tr>
<tr align="center"><td>slice of all elements</td> <td>opSlice</td> <td>collection[]</td></tr>
<tr align="center"><td>slice of some elements</td> <td>opSlice(size_t, size_t)</td> <td>collection[i..j]</td></tr>
</table>

<p>We will cover those operators later below.
</p>

<p>The following operator functions are from the earlier versions of D. They are discouraged:
</p>

<table class="full" border="1" cellpadding="4" cellspacing="0"><tr align="center"><th scope="col">Description</th> <th scope="col">Function Name</th> <th scope="col">Sample Usage</th></tr>
<tr align="center"><td>unary operation on all elements</td> <td>opSliceUnary (discouraged)</td> <td>++collection[]</td></tr>
<tr align="center"><td>unary operation on some elements</td> <td>opSliceUnary (discouraged)</td> <td>++collection[i..j]</td></tr>
<tr align="center"><td>assignment to all elements</td> <td>opSliceAssign (discouraged)</td> <td>collection[] = 42</td></tr>
<tr align="center"><td>assignment to some elements</td> <td>opSliceAssign (discouraged)</td> <td>collection[i..j] = 7</td></tr>
<tr align="center"><td>operation with assignment on all elements</td> <td>opSliceOpAssign (discouraged)</td> <td>collection[] *= 2</td></tr>
<tr align="center"><td>operation with assignment on some elements</td> <td>opSliceOpAssign (discouraged)</td> <td>collection[i..j] *= 2</td></tr>

</table>

<h6>Other operators</h6>

<p>The following operators can be overloaded as well:
</p>

<table class="full" border="1" cellpadding="4" cellspacing="0"><tr align="center"><th scope="col">Description</th> <th scope="col">Function Name</th> <th scope="col">Sample Usage</th></tr>
<tr align="center"><td>function call</td> <td>opCall</td> <td>object(42)</td></tr>
<tr align="center"><td>type conversion</td> <td>opCast</td> <td>to!int(object)</td></tr>
<tr align="center"><td>dispatch for non-existent function</td> <td>opDispatch</td> <td>object.nonExistent()</td></tr>
</table>

<p>These operators will be explained below under their own sections.
</p>

<h5 class="subsection">Defining more than one operator at the same time</h5>

<p>To keep the code samples short, we have used only the <code class="d_inline">++</code>, <code class="d_inline">+</code>, and <code class="d_inline">+=</code> operators above. It is conceivable that when one operator is overloaded for a type, many others would also need to be overloaded. For example, the <code class="d_inline">--</code> and <code class="d_inline">-=</code> operators are also defined for the following <code class="d_inline">Duration</code>:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Duration {
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">ref</span> Duration opUnary(string op)()
            <span class="d_keyword">if</span> (op == <span class="d_string">"++"</span>) {
        <span class="hilite">++</span>minute;
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_keyword">ref</span> Duration opUnary(string op)()
            <span class="d_keyword">if</span> (op == <span class="d_string">"--"</span>) {
        <span class="hilite">--</span>minute;
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_keyword">ref</span> Duration opOpAssign(string op)(<span class="d_keyword">int</span> amount)
            <span class="d_keyword">if</span> (op == <span class="d_string">"+"</span>) {
        minute <span class="hilite">+</span>= amount;
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_keyword">ref</span> Duration opOpAssign(string op)(<span class="d_keyword">int</span> amount)
            <span class="d_keyword">if</span> (op == <span class="d_string">"-"</span>) {
        minute <span class="hilite">-</span>= amount;
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}

<span class="d_keyword">unittest</span> {
    <span class="d_keyword">auto</span> duration = Duration(10);

    ++duration;
    <span class="d_keyword">assert</span>(duration.minute == 11);

    --duration;
    <span class="d_keyword">assert</span>(duration.minute == 10);

    duration += 5;
    <span class="d_keyword">assert</span>(duration.minute == 15);

    duration -= 3;
    <span class="d_keyword">assert</span>(duration.minute == 12);
}

<span class="d_keyword">void</span> main() {
}
</pre>

<p>The operator overloads above have code duplications. The only differences between the similar functions are highlighted. Such code duplications can be reduced and sometimes avoided altogether by <i>string mixins</i>. We will see the <code class="d_inline">mixin</code> keyword in a later chapter as well. I would like to show briefly how this keyword helps with operator overloading.
</p>

<p><code class="d_inline">mixin</code> inserts the specified string as source code right where the <code class="d_inline">mixin</code> statement appears in code. The following struct is the equivalent of the one above:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Duration {
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">ref</span> Duration opUnary(string op)()
            <span class="d_keyword">if</span> ((op == <span class="d_string">"++"</span>) || (op == <span class="d_string">"--"</span>)) {
        <span class="hilite"><span class="d_keyword">mixin</span></span> (op ~ <span class="d_string">"minute;"</span>);
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_keyword">ref</span> Duration opOpAssign(string op)(<span class="d_keyword">int</span> amount)
            <span class="d_keyword">if</span> ((op == <span class="d_string">"+"</span>) || (op == <span class="d_string">"-"</span>)) {
        <span class="hilite"><span class="d_keyword">mixin</span></span> (<span class="d_string">"minute "</span> ~ op ~ <span class="d_string">"= amount;"</span>);
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}
</pre>

<p>If the <code class="d_inline">Duration</code> objects also need to be multiplied and divided by an amount, all that is needed is to add two more conditions to the template constraint:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Duration {
<span class="d_comment">// ...
</span>
    <span class="d_keyword">ref</span> Duration opOpAssign(string op)(<span class="d_keyword">int</span> amount)
        <span class="d_keyword">if</span> ((op == <span class="d_string">"+"</span>) || (op == <span class="d_string">"-"</span>) ||
            <span class="hilite">(op == <span class="d_string">"*"</span>) || (op == <span class="d_string">"/"</span>)</span>) {
        <span class="d_keyword">mixin</span> (<span class="d_string">"minute "</span> ~ op ~ <span class="d_string">"= amount;"</span>);
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
}

<span class="d_keyword">unittest</span> {
    <span class="d_keyword">auto</span> duration = Duration(12);

    duration <span class="hilite">*=</span> 4;
    <span class="d_keyword">assert</span>(duration.minute == 48);

    duration <span class="hilite">/=</span> 2;
    <span class="d_keyword">assert</span>(duration.minute == 24);
}
</pre>

<p>In fact, the template constraints are optional:
</p>

<pre class="d_code">    <span class="d_keyword">ref</span> Duration opOpAssign(string op)(<span class="d_keyword">int</span> amount)
            <span class="d_comment">/* no constraint */</span> {
        <span class="d_keyword">mixin</span> (<span class="d_string">"minute "</span> ~ op ~ <span class="d_string">"= amount;"</span>);
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }
</pre>

<h5 class="subsection"><a id="ix_Operator Overloading.return type, operator" content="return type, operator"></a> Return types of operators</h5>

<p>When overloading an operator, it is advisable to observe the return type of the same operator on fundamental types. This would help with making sense of code and reducing confusions.
</p>

<p>None of the operators on fundamental types return <code class="d_inline">void</code>. This fact should be obvious for some operators. For example, the result of adding two <code class="d_inline">int</code> values as <code class="d_inline">a&nbsp;+&nbsp;b</code> is <code class="d_inline">int</code>:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> a = 1;
    <span class="d_keyword">int</span> b = 2;
    <span class="d_keyword">int</span> c = a + b;  <span class="d_comment">// c gets initialized by the return value
</span>                    <span class="d_comment">// of the + operator
</span></pre>

<p>The return values of some other operators may not be so obvious. For example, even operators like <code class="d_inline">++i</code> have values:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> i = 1;
    writeln(++i);    <span class="d_comment">// prints 2
</span></pre>

<p>The <code class="d_inline">++</code> operator not only increments <code class="d_inline">i</code>, it also produces the new value of <code class="d_inline">i</code>. Further, the value that is produced by <code class="d_inline">++</code> is not just the new value of <code class="d_inline">i</code>, rather <i>the variable <code class="d_inline">i</code> itself</i>. We can see this fact by printing the address of the result of that expression:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> i = 1;
    writeln(<span class="d_string">"The address of i                : "</span>, &amp;i);
    writeln(<span class="d_string">"The address of the result of ++i: "</span>, &amp;(++i));
</pre>

<p>The output contains identical addresses:
</p>

<pre class="shell">The address of i                : 7FFF39BFEE78
The address of the result of ++i: 7FFF39BFEE78
</pre>

<p>I recommend that you observe the following guidelines when overloading operators for your own types:
</p>

<ul>
<li><b>Operators that modify the object</b>

<p>With the exception of <code class="d_inline">opAssign</code>, it is recommended that the operators that modify the object return the object itself. This guideline has been observed above with the <code class="d_inline">TimeOfDay.opOpAssign!<code class="d_inline"><span class="d_string">"+"</span></code></code> and <code class="d_inline">Duration.opUnary!<code class="d_inline"><span class="d_string">"++"</span></code></code>.
</p>

<p>The following two steps achieve returning the object itself:
</p>

<ol>
<li>The return type is the type of the struct, marked by the <code class="d_inline">ref</code> keyword to mean <i>reference</i>.
</li>

<li>The function is exited by <code class="d_inline">return this</code> to mean <i>return this object</i>.
</li>

</ol>

<p>The operators that modify the object are <code class="d_inline">opUnary!<code class="d_inline"><span class="d_string">"++"</span></code></code>, <code class="d_inline">opUnary!<code class="d_inline"><span class="d_string">"--"</span></code></code>, and all of the <code class="d_inline">opOpAssign</code> overloads.
</p>

</li>

<li><b>Logical operators</b>

<p><code class="d_inline">opEquals</code> that represents both <code class="d_inline">==</code> and <code class="d_inline">!=</code> must return <code class="d_inline">bool</code>. Although the <code class="d_inline">in</code> operator normally returns <i>the contained object</i>, it can simply return <code class="d_inline">bool</code> as well.
</p>

</li>

<li><b>Sort operators</b>

<p><code class="d_inline">opCmp</code> that represents <code class="d_inline">&lt;</code>, <code class="d_inline">&lt;=</code>, <code class="d_inline">&gt;</code>, and <code class="d_inline">&gt;=</code> must return <code class="d_inline">int</code>.
</p>

</li>

<li><b>Operators that make a new object</b>

<p>Some operators must make and return a new object:
</p>

<ul>
<li>Unary operators <code class="d_inline">-</code>, <code class="d_inline">+</code>, and <code class="d_inline">~</code>; and the binary operator <code class="d_inline">~</code>.</li>

<li>Arithmetic operators <code class="d_inline">+</code>, <code class="d_inline">-</code>, <code class="d_inline">*</code>, <code class="d_inline">/</code>, <code class="d_inline">%</code>, and <code class="d_inline">^^</code>.</li>

<li>Bitwise operators <code class="d_inline">&amp;</code>, <code class="d_inline">|</code>, <code class="d_inline">^</code>, <code class="d_inline">&lt;&lt;</code>, <code class="d_inline">&gt;&gt;</code>, and <code class="d_inline">&gt;&gt;&gt;</code>.</li>

<li>As has been seen in the previous chapter, <code class="d_inline">opAssign</code> returns a copy of this object by <code class="d_inline">return this</code>.

<p><i><b>Note:</b> As an optimization, sometimes it makes more sense for <code class="d_inline">opAssign</code> to return <code class="d_inline">const ref</code> for large structs. I will not apply this optimization in this book.</i></p>

</li>

</ul>

<p>As an example of an operator that makes a new object, let's define the <code class="d_inline">opBinary!<code class="d_inline"><span class="d_string">"+"</span></code></code> overload for <code class="d_inline">Duration</code>. This operator should add two <code class="d_inline">Duration</code> objects to make and return a new one:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Duration {
    <span class="d_keyword">int</span> minute;

    Duration opBinary(string op)(Duration rhs) <span class="d_keyword">const</span>
            <span class="d_keyword">if</span> (op == <span class="d_string">"+"</span>) {
        <span class="d_keyword">return</span> Duration(minute + rhs.minute);  <span class="d_comment">// new object
</span>    }
}
</pre>

<p>That definition enables adding <code class="d_inline">Duration</code> objects by the <code class="d_inline">+</code> operator:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> travelDuration = Duration(10);
    <span class="d_keyword">auto</span> returnDuration = Duration(11);
    Duration totalDuration;
    <span class="d_comment">// ...
</span>    totalDuration = travelDuration <span class="hilite">+</span> returnDuration;
</pre>

<p>The compiler replaces that expression with the following member function call on the <code class="d_inline">travelDuration</code> object:
</p>

<pre class="d_code">    <span class="d_comment">// the equivalent of the expression above:
</span>    totalDuration =
        travelDuration.opBinary!<span class="d_string">"+"</span>(returnDuration);
</pre>

</li>

<li><code class="d_inline">opDollar</code>

<p>Since it returns the number of elements of the container, the most suitable type for <code class="d_inline">opDollar</code> is <code class="d_inline">size_t</code>. However, the return type can be other types as well (e.g. <code class="d_inline">int</code>).
</p>

</li>

<li><b>Unconstrained operators</b>

<p>The return types of some of the operators depend entirely on the design of the user-defined type: The unary <code class="d_inline">*</code>, <code class="d_inline">opCall</code>, <code class="d_inline">opCast</code>, <code class="d_inline">opDispatch</code>, <code class="d_inline">opSlice</code>, and all <code class="d_inline">opIndex</code> varieties.
</p>

</li>

</ul>

<h5 class="subsection"><a id="ix_Operator Overloading.opEquals" content="opEquals"></a> <code class="d_inline">opEquals()</code> for equality comparisons</h5>

<p>This member function defines the behaviors of the <code class="d_inline">==</code> and the <code class="d_inline">!=</code> operators.
</p>

<p>The return type of <code class="d_inline">opEquals</code> is <code class="d_inline">bool</code>.
</p>

<p>For structs, the parameter of <code class="d_inline">opEquals</code> can be defined as <code class="d_inline">in</code>. However, for speed efficiency <code class="d_inline">opEquals</code> can be defined as a template that takes <code class="d_inline">auto ref const</code> (also note the empty template parentheses below):
</p>

<pre class="d_code">    <span class="d_keyword">bool</span> opEquals<span class="hilite">()</span>(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">const</span> TimeOfDay rhs) <span class="d_keyword">const</span> {
        <span class="d_comment">// ...
</span>    }
</pre>

<p>As we have seen in <a href="lvalue_rvalue.html">the Lvalues and Rvalues chapter</a>, <code class="d_inline">auto ref</code> allows lvalues to be passed by reference and rvalues by copy. However, since rvalues are not copied, rather moved, the signature above is efficient for both lvalues and rvalues.
</p>

<p>To reduce confusion, <code class="d_inline">opEquals</code> and <code class="d_inline">opCmp</code> must work consistently. For two objects that <code class="d_inline">opEquals</code> returns <code class="d_inline">true</code>, <code class="d_inline">opCmp</code> must return zero.
</p>

<p>Once <code class="d_inline">opEquals()</code> is defined for equality, the compiler uses its opposite for inequality:
</p>

<pre class="d_code">    x == y;
    <span class="d_comment">// the equivalent of the previous expression:
</span>    x.opEquals(y);

    x != y;
    <span class="d_comment">// the equivalent of the previous expression:
</span>    !(x.opEquals(y));
</pre>

<p>Normally, it is not necessary to define <code class="d_inline">opEquals()</code> for structs. The compiler generates it for structs automatically. The automatically-generated <code class="d_inline">opEquals</code> compares all of the members individually.
</p>

<p>Sometimes the equality of two objects must be defined differently from this automatic behavior. For example, some of the members may not be significant in this comparison, or the equality may depend on a more complex logic.
</p>

<p>Just as an example, let's define <code class="d_inline">opEquals()</code> in a way that disregards the minute information altogether:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> TimeOfDay {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">bool</span> opEquals(TimeOfDay rhs) <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> hour == rhs.hour;
    }
}
<span class="d_comment">// ...
</span>    <span class="d_keyword">assert</span>(TimeOfDay(20, 10) <span class="hilite">==</span> TimeOfDay(20, 59));
</pre>

<p>Since the equality comparison considers the values of only the <code class="d_inline">hour</code> members, 20:10 and 20:59 end up being equal. (This is just an example; it should be clear that such an equality comparison would cause confusions.)
</p>

<h5 class="subsection"><a id="ix_Operator Overloading.opCmp" content="opCmp"></a> <code class="d_inline">opCmp()</code> for sorting</h5>

<p>Sort operators determine the sort orders of objects. All of the ordering operators <code class="d_inline">&lt;</code>, <code class="d_inline">&lt;=</code>, <code class="d_inline">&gt;</code>, and <code class="d_inline">&gt;=</code> are covered by the <code class="d_inline">opCmp()</code> member function.
</p>

<p>For structs, the parameter of <code class="d_inline">opCmp</code> can be defined as <code class="d_inline">in</code>. However, as with <code class="d_inline">opEquals</code>, it is more efficient to define <code class="d_inline">opCmp</code> as a template that takes <code class="d_inline">auto ref const</code>:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> opCmp<span class="hilite">()</span>(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">const</span> TimeOfDay rhs) <span class="d_keyword">const</span> {
        <span class="d_comment">// ...
</span>    }
</pre>

<p>To reduce confusion, <code class="d_inline">opEquals</code> and <code class="d_inline">opCmp</code> must work consistently. For two objects that <code class="d_inline">opEquals</code> returns <code class="d_inline">true</code>, <code class="d_inline">opCmp</code> must return zero.
</p>

<p>Let's assume that one of these four operators is used as in the following code:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (x <i>op</i> y) {  <span class="d_comment">// ← <i>op</i> <span class="d_keyword">is</span> one of &lt;, &lt;=, &gt;, or &gt;=</span>
</pre>

<p>The compiler converts that expression to the following logical expression and uses the result of the new logical expression:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (x.opCmp(y) <i>op</i> 0) {
</pre>

<p>Let's consider the <code class="d_inline">&lt;=</code> operator:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (x <span class="hilite">&lt;=</span> y) {
</pre>

<p>The compiler generates the following code behind the scenes:
</p>

<pre class="d_code">    <span class="d_keyword">if</span> (x.opCmp(y) <span class="hilite">&lt;=</span> 0) {
</pre>

<p>For the user-defined <code class="d_inline">opCmp()</code> to work correctly, this member function must return a result according to the following rules:
</p>

<ul><li><i>A negative value</i> if the left-hand object is considered to be before the right-hand object</li>
<li><i>A positive value</i> if the left-hand object is considered to be after the right-hand object</li>
<li><i>Zero</i> if the objects are considered to have the same sort order</li>
</ul>

<p>To be able to support those values, the return type of <code class="d_inline">opCmp()</code> must be <code class="d_inline">int</code>, not <code class="d_inline">bool</code>.
</p>

<p>The following is a way of ordering <code class="d_inline">TimeOfDay</code> objects by first comparing the values of the <code class="d_inline">hour</code> members, and then comparing the values of the <code class="d_inline">minute</code> members (only if the <code class="d_inline">hour</code> members are equal):
</p>

<pre class="d_code">    <span class="d_keyword">int</span> opCmp(TimeOfDay rhs) <span class="d_keyword">const</span> {
        <span class="d_comment">/* Note: Subtraction is a bug here if the result can
         * overflow. (See the following warning in text.) */</span>

        <span class="d_keyword">return</span> (hour == rhs.hour
                ? minute - rhs.minute
                : hour - rhs.hour);
    }
</pre>

<p>That definition returns the difference between the <code class="d_inline">minute</code> values when the <code class="d_inline">hour</code> members are the same, and the difference between the <code class="d_inline">hour</code> members otherwise. The return value would be a <i>negative value</i> when the <i>left-hand</i> object comes before in chronological order, a <i>positive value</i> if the <i>right-hand</i> object is before, and <i>zero</i> when they represent exactly the same time of day.
</p>

<p><b>Warning:</b> Using subtraction for the implementation of <code class="d_inline">opCmp</code> is a bug if valid values of a member can cause overflow. For example, the two objects below would be sorted incorrectly as the object with value <code class="d_inline">-2</code> is calculated to be <i>greater</i> than the one with value <code class="d_inline">int.max</code>:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> S {
    <span class="d_keyword">int</span> i;

    <span class="d_keyword">int</span> opCmp(S rhs) <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> i - rhs.i;          <span class="d_comment">// ← <span class="code_note_wrong">BUG</span></span>
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">assert</span>(S(-2) <span class="hilite">&gt;</span> S(<span class="d_keyword">int</span>.max));    <span class="d_comment">// ← <span class="code_note_wrong">wrong sort order</span></span>
}
</pre>

<p>On the other hand, subtraction is acceptable for <code class="d_inline">TimeOfDay</code> because none of the valid values of the members of that <code class="d_inline">struct</code> can cause overflow in subtraction.
</p>

<p><a id="ix_Operator Overloading.cmp, std.algorithm" content="cmp, std.algorithm"></a> <a id="ix_Operator Overloading.lexicographical" content="lexicographical"></a> You can use <code class="d_inline">std.algorithm.cmp</code> for comparing slices (including all string types and ranges). <code class="d_inline">cmp()</code> compares slices lexicographically and produces a negative value, zero, or positive value depending on their  order. That result can directly be used as the return value of <code class="d_inline">opCmp</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.algorithm;

<span class="d_keyword">struct</span> S {
    string name;

    <span class="d_keyword">int</span> opCmp(S rhs) <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> <span class="hilite">cmp</span>(name, rhs.name);
    }
}
</pre>

<p>Once <code class="d_inline">opCmp()</code> is defined, this type can be used with sorting algorithms like <code class="d_inline">std.algorithm.sort</code> as well. As <code class="d_inline">sort()</code> works on the elements, it is the <code class="d_inline">opCmp()</code> operator that gets called behind the scenes to determine their order. The following program constructs 10 objects with random values and sorts them with <code class="d_inline">sort()</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.random;
<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.algorithm;

<span class="d_keyword">struct</span> TimeOfDay {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">int</span> opCmp(TimeOfDay rhs) <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> (hour == rhs.hour
                ? minute - rhs.minute
                : hour - rhs.hour);
    }

    string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"%02s:%02s"</span>, hour, minute);
    }
}

<span class="d_keyword">void</span> main() {
    TimeOfDay[] times;

    <span class="d_keyword">foreach</span> (i; 0 .. 10) {
        times ~= TimeOfDay(uniform(0, 24), uniform(0, 60));
    }

    sort(times);

    writeln(times);
}
</pre>

<p>As expected, the elements are sorted from the earliest time to the latest time:
</p>

<pre class="shell">[03:40, 04:10, 09:06, 10:03, 10:09, 11:04, 13:42, 16:40, 18:03, 21:08]
</pre>

<h5 class="subsection"><a id="ix_Operator Overloading.opCall" content="opCall"></a> <a id="ix_Operator Overloading.()" content="()"></a> <code class="d_inline">opCall()</code> to call objects as functions</h5>

<p>The parentheses around the parameter list when calling functions are operators as well. We have already seen how <code class="d_inline">static opCall()</code> makes it possible to use the name of the <i>type</i> as a function. <code class="d_inline">static opCall()</code> allows creating objects with default values at run time.
</p>

<p>Non-static <code class="d_inline">opCall()</code> on the other hand allows using the <i>objects</i> of user-defined types as functions:
</p>

<pre class="d_code">    Foo foo;
    foo<span class="hilite">()</span>;
</pre>

<p>The object <code class="d_inline">foo</code> above is being called like a function.
</p>

<p>As an example, let's consider a <code class="d_inline">struct</code> that represents a linear equation. This <code class="d_inline">struct</code> will be used for calculating the <i>y</i> values of the following linear equation for specific <i>x</i> values:
</p>

<pre class="mono">    <i>y</i> = <i>a</i><i>x</i> + <i>b</i>
</pre>

<p>The following <code class="d_inline">opCall()</code> simply calculates and returns the value of <i>y</i> according to that equation:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> LinearEquation {
    <span class="d_keyword">double</span> a;
    <span class="d_keyword">double</span> b;

    <span class="d_keyword">double</span> opCall(<span class="d_keyword">double</span> x) <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> a * x + b;
    }
}
</pre>

<p>With that definition, each object of <code class="d_inline">LinearEquation</code> represents a linear equation for specific <i>a</i> and <i>b</i> values. Such an object can be used as a function that calculates the <i>y</i> values:
</p>

<pre class="d_code">    LinearEquation equation = { 1.2, 3.4 };
    <span class="d_comment">// the object is being used like a function:
</span>    <span class="d_keyword">double</span> y = equation(5.6);
</pre>

<p><i><b>Note:</b> Defining <code class="d_inline">opCall()</code> for a <code class="d_inline">struct</code> disables the compiler-generated automatic constructor. That is why the <code class="d_inline">{&nbsp;}</code> syntax is used above instead of the recommended <code class="d_inline">LinearEquation(1.2, 3.4)</code>. When the latter syntax is desired, a <code class="d_inline">static opCall()</code> that takes two <code class="d_inline">double</code> parameters must also be defined.</i>
</p>

<p><code class="d_inline">equation</code> above represents the <i>y&nbsp;=&nbsp;1.2x&nbsp;+&nbsp;3.4</i> linear equation. Using that object as a function executes the <code class="d_inline">opCall()</code> member function.
</p>

<p>This feature can be useful to define and store the <i>a</i> and <i>b</i> values in an object once and to use that object multiple times later on. The following code uses such an object in a loop:
</p>

<pre class="d_code">    LinearEquation equation = { 0.01, 0.4 };

    <span class="d_keyword">for</span> (<span class="d_keyword">double</span> x = 0.0; x &lt;= 1.0; x += 0.125) {
        writefln(<span class="d_string">"%f: %f"</span>, x, equation(x));
    }
</pre>

<p>That object represents the <i>y&nbsp;=&nbsp;0.01x&nbsp;+&nbsp;0.4</i> equation. It is being used for calculating the results for <i>x</i> values in the range from 0.0 to 1.0.
</p>

<h5 class="subsection"><a id="ix_Operator Overloading.opIndex" content="opIndex"></a> <a id="ix_Operator Overloading.opIndexAssign" content="opIndexAssign"></a> <a id="ix_Operator Overloading.opIndexUnary" content="opIndexUnary"></a> <a id="ix_Operator Overloading.opIndexOpAssign" content="opIndexOpAssign"></a> <a id="ix_Operator Overloading.opDollar" content="opDollar"></a> Indexing operators</h5>

<p><code class="d_inline">opIndex</code>, <code class="d_inline">opIndexAssign</code>, <code class="d_inline">opIndexUnary</code>, <code class="d_inline">opIndexOpAssign</code>, and <code class="d_inline">opDollar</code> make it possible to use indexing operators on user-defined types similar to arrays as in <code class="d_inline">object[index]</code>.
</p>

<p>Unlike arrays, these operators support multi-dimensional indexing as well. Multiple index values are specified as a comma-separated list inside the square brackets (e.g. <code class="d_inline">object[index0, index1]</code>). In the following examples we will use these operators only with a single dimension and cover their multi-dimensional uses in <a href="templates_more.html">the More Templates chapter</a>.
</p>

<p>The <code class="d_inline">deque</code> variable in the following examples is an object of <code class="d_inline">struct DoubleEndedQueue</code>, which we will define below; and <code class="d_inline">e</code> is a variable of type <code class="d_inline">int</code>.
</p>

<p><code class="d_inline">opIndex</code> is for element access. The index that is specified inside the brackets becomes the parameter of the operator function:
</p>

<pre class="d_code">    e = deque[3];                    <span class="d_comment">// the element at index 3
</span>    e = deque.opIndex(3);            <span class="d_comment">// the equivalent of the above
</span></pre>

<p><code class="d_inline">opIndexAssign</code> is for assigning to an element. The first parameter is the value that is being assigned and the second parameter is the index of the element:
</p>

<pre class="d_code">    deque[5] = 55;                   <span class="d_comment">// assign 55 to the element at index 5
</span>    deque.opIndexAssign(55, 5);      <span class="d_comment">// the equivalent of the above
</span></pre>

<p><code class="d_inline">opIndexUnary</code> is similar to <code class="d_inline">opUnary</code>. The difference is that the operation is applied to the element at the specified index:
</p>

<pre class="d_code">    ++deque[4];                      <span class="d_comment">// increment the element at index 4
</span>    deque.opIndexUnary!<span class="d_string">"++"</span>(4);      <span class="d_comment">// the equivalent of the above
</span></pre>

<p><code class="d_inline">opIndexOpAssign</code> is similar to <code class="d_inline">opOpAssign</code>. The difference is that the operation is applied to an element:
</p>

<pre class="d_code">    deque[6] += 66;                  <span class="d_comment">// add 66 to the element at index 6
</span>    deque.opIndexOpAssign!<span class="d_string">"+"</span>(66, 6);<span class="d_comment">// the equivalent of the above
</span></pre>

<p><code class="d_inline">opDollar</code> defines the <code class="d_inline">$</code> character that is used during indexing and slicing. It is for returning the number of elements in the container:
</p>

<pre class="d_code">    e = deque[$ - 1];                <span class="d_comment">// the last element
</span>    e = deque[deque.opDollar() - 1]; <span class="d_comment">// the equivalent of the above
</span></pre>

<h6>Indexing operators example</h6>

<p><i>Double-ended queue</i> is a data structure that is similar to arrays but it provides efficient insertion at the head of the collection as well. (In contrast, inserting at the head of an array is a relatively slow operation as it requires moving the existing elements to a newly created array.)
</p>

<p>One way of implementing a double-ended queue is to use two arrays in the background but to use the first one in reverse. The element that is conceptually inserted at the head of the queue is actually appended to the <i>head</i> array. As a result, this operation is as efficient as appending to the end.
</p>

<p>The following <code class="d_inline">struct</code> implements a double-ended queue that overloads the operators that we have seen in this section:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.conv;

<span class="d_keyword">struct</span> DoubleEndedQueue <span class="d_comment">// Also known as Deque
</span>{
<span class="d_keyword">private</span>:

    <span class="d_comment">/* The elements are represented as the chaining of the two
     * member slices. However, 'head' is indexed in reverse so
     * that the first element of the entire collection is
     * head[&dollar;-1], the second one is head[&dollar;-2], etc.:
     *
     * head[&dollar;-1], head[&dollar;-2], ... head[0], tail[0], ... tail[&dollar;-1]
     */</span>
    <span class="d_keyword">int</span>[] head;    <span class="d_comment">// the first group of elements
</span>    <span class="d_keyword">int</span>[] tail;    <span class="d_comment">// the second group of elements
</span>
    <span class="d_comment">/* Determines the actual slice that the specified element
     * resides in and returns it as a reference. */</span>
    <span class="d_keyword">ref</span> <span class="d_keyword">inout</span>(<span class="d_keyword">int</span>) elementAt(size_t index) <span class="d_keyword">inout</span> {
        <span class="d_keyword">return</span> (index &lt; head.length
                ? head[$ - 1 - index]
                : tail[index - head.length]);
    }

<span class="d_keyword">public</span>:

    string toString() <span class="d_keyword">const</span> {
        string result;

        <span class="d_keyword">foreach_reverse</span> (element; head) {
            result ~= format(<span class="d_string">"%s "</span>, to!string(element));
        }

        <span class="d_keyword">foreach</span> (element; tail) {
            result ~= format(<span class="d_string">"%s "</span>, to!string(element));
        }

        <span class="d_keyword">return</span> result;
    }

    <span class="d_comment">/* Note: As we will see in the next chapter, the following
     * is a simpler and more efficient implementation of
     * toString(): */</span>
    <span class="d_keyword">version</span> (none) {
        <span class="d_keyword">void</span> toString(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[]) sink) <span class="d_keyword">const</span> {
            <span class="d_keyword">import</span> std.format;
            <span class="d_keyword">import</span> std.range;

            formattedWrite(
                sink, <span class="d_string">"%(%s %)"</span>, chain(head.retro, tail));
        }
    }

    <span class="d_comment">/* Adds a new element to the head of the collection. */</span>
    <span class="d_keyword">void</span> insertAtHead(<span class="d_keyword">int</span> value) {
        head ~= value;
    }

    <span class="d_comment">/* Adds a new element to the tail of the collection.
     *
     * Sample: deque ~= value
     */</span>
    <span class="d_keyword">ref</span> DoubleEndedQueue opOpAssign(string op)(<span class="d_keyword">int</span> value)
            <span class="d_keyword">if</span> (op == <span class="d_string">"~"</span>) {
        tail ~= value;
        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_comment">/* Returns the specified element.
     *
     * Sample: deque[index]
     */</span>
    <span class="d_keyword">inout</span>(<span class="d_keyword">int</span>) opIndex(size_t index) <span class="d_keyword">inout</span> {
        <span class="d_keyword">return</span> elementAt(index);
    }

    <span class="d_comment">/* Applies a unary operation to the specified element.
     *
     * Sample: ++deque[index]
     */</span>
    <span class="d_keyword">int</span> opIndexUnary(string op)(size_t index) {
        <span class="d_keyword">mixin</span> (<span class="d_string">"return "</span> ~ op ~ <span class="d_string">"elementAt(index);"</span>);
    }

    <span class="d_comment">/* Assigns a value to the specified element.
     *
     * Sample: deque[index] = value
     */</span>
    <span class="d_keyword">int</span> opIndexAssign(<span class="d_keyword">int</span> value, size_t index) {
        <span class="d_keyword">return</span> elementAt(index) = value;
    }

    <span class="d_comment">/* Uses the specified element and a value in a binary
     * operation and assigns the result back to the same
     * element.
     *
     * Sample: deque[index] += value
     */</span>
    <span class="d_keyword">int</span> opIndexOpAssign(string op)(<span class="d_keyword">int</span> value, size_t index) {
        <span class="d_keyword">mixin</span> (<span class="d_string">"return elementAt(index) "</span> ~ op ~ <span class="d_string">"= value;"</span>);
    }

    <span class="d_comment">/* Defines the &dollar; character, which is the length of the
     * collection.
     *
     * Sample: deque[&dollar; - 1]
     */</span>
    size_t opDollar() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> head.length + tail.length;
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> deque = DoubleEndedQueue();

    <span class="d_keyword">foreach</span> (i; 0 .. 10) {
        <span class="d_keyword">if</span> (i % 2) {
            deque.insertAtHead(i);

        } <span class="d_keyword">else</span> {
            deque ~= i;
        }
    }

    writefln(<span class="d_string">"Element at index 3: %s"</span>,
             deque[3]);    <span class="d_comment">// accessing an element
</span>    ++deque[4];            <span class="d_comment">// incrementing an element
</span>    deque[5] = 55;         <span class="d_comment">// assigning to an element
</span>    deque[6] += 66;        <span class="d_comment">// adding to an element
</span>
    (deque ~= 100) ~= 200;

    writeln(deque);
}
</pre>

<p>According to the guidelines above, the return type of <code class="d_inline">opOpAssign</code> is <code class="d_inline">ref</code> so that the <code class="d_inline">~=</code> operator can be chained on the same collection:
</p>

<pre class="d_code">    (deque ~= 100) ~= 200;
</pre>

<p>As a result, both 100 and 200 get appended to the same collection:
</p>

<pre class="shell">Element at index 3: 3
9 7 5 3 2 55 68 4 6 8 100 200 
</pre>

<h5 class="subsection"><a id="ix_Operator Overloading.opSlice" content="opSlice"></a> Slicing operators</h5>

<p><code class="d_inline">opSlice</code> allows slicing the objects of user-defined types with the <code class="d_inline">[]</code> operator.
</p>

<p><a id="ix_Operator Overloading.opSliceUnary" content="opSliceUnary"></a> <a id="ix_Operator Overloading.opSliceAssign" content="opSliceAssign"></a> <a id="ix_Operator Overloading.opSliceOpAssign" content="opSliceOpAssign"></a> In addition to this operator, there are also <code class="d_inline">opSliceUnary</code>, <code class="d_inline">opSliceAssign</code>, and <code class="d_inline">opSliceOpAssign</code> but they are discouraged.
</p>

<p>D supports multi-dimensional slicing. We will see a multi-dimensional example later in <a href="templates_more.html">the More Templates chapter</a>. Although the methods described in that chapter can be used for a single dimension as well, they do not match the indexing operators that are defined above and they involve templates which we have not covered yet. For that reason, we will see the non-templated use of <code class="d_inline">opSlice</code> in this chapter, which works only with a single dimension. (This use of <code class="d_inline">opSlice</code> is discouraged as well.)
</p>

<p><code class="d_inline">opSlice</code> has two distinct forms:
</p>

<ul>
<li>The square brackets can be empty as in <code class="d_inline">deque[]</code> to mean <i>all elements</i>.</li>

<li>The square brackets can contain a number range as in <code class="d_inline">deque[begin..end]</code> to mean <i>the elements in the specified range</i>.</li>

</ul>

<p>The slicing operators are relatively more complex than other operators because they involve two distinct concepts: <i>container</i> and <i>range</i>. We will see these concepts in more detail in later chapters.
</p>

<p>In single-dimensional slicing which does not use templates, <code class="d_inline">opSlice</code> returns an object that represents a specific range of elements of the container. The object that <code class="d_inline">opSlice</code> returns is responsible for defining the operations that are applied on that range elements. For example, behind the scenes the following expression is executed by first calling <code class="d_inline">opSlice</code> to obtain a range object and then applying <code class="d_inline">opOpAssign!<code class="d_inline"><span class="d_string">"*"</span></code></code> on that object:
</p>

<pre class="d_code">    deque[] *= 10;    <span class="d_comment">// multiply all elements by 10
</span>
    <span class="d_comment">// The equivalent of the above:
</span>    {
        <span class="d_keyword">auto</span> range = deque.opSlice();
        range.opOpAssign!<span class="d_string">"*"</span>(10);
    }
</pre>

<p>Accordingly, the <code class="d_inline">opSlice</code> operators of <code class="d_inline">DoubleEndedQueue</code> return a special <code class="d_inline">Range</code> object so that the operations are applied to it:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.exception;

<span class="d_keyword">struct</span> DoubleEndedQueue {
<span class="d_comment">// ...
</span>
    <span class="d_comment">/* Returns a range that represents all of the elements.
     * ('Range' struct is defined below.)
     *
     * Sample: deque[]
     */</span>
    <span class="d_keyword">inout</span>(Range) <span class="hilite">opSlice</span>() <span class="d_keyword">inout</span> {
        <span class="d_keyword">return</span> <span class="d_keyword">inout</span>(Range)(head[], tail[]);
    }

    <span class="d_comment">/* Returns a range that represents some of the elements.
     *
     * Sample: deque[begin .. end]
     */</span>
    <span class="d_keyword">inout</span>(Range) <span class="hilite">opSlice</span>(size_t begin, size_t end) <span class="d_keyword">inout</span> {
        enforce(end &lt;= opDollar());
        enforce(begin &lt;= end);

        <span class="d_comment">/* Determine what parts of 'head' and 'tail'
         * correspond to the specified range: */</span>

        <span class="d_keyword">if</span> (begin &lt; head.length) {
            <span class="d_keyword">if</span> (end &lt; head.length) {
                <span class="d_comment">/* The range is completely inside 'head'. */</span>
                <span class="d_keyword">return</span> <span class="d_keyword">inout</span>(Range)(
                    head[$ - end .. $ - begin],
                    []);

            } <span class="d_keyword">else</span> {
                <span class="d_comment">/* Some part of the range is inside 'head' and
                 * the rest is inside 'tail'. */</span>
                <span class="d_keyword">return</span> <span class="d_keyword">inout</span>(Range)(
                    head[0 .. $ - begin],
                    tail[0 .. end - head.length]);
            }

        } <span class="d_keyword">else</span> {
            <span class="d_comment">/* The range is completely inside 'tail'. */</span>
            <span class="d_keyword">return</span> <span class="d_keyword">inout</span>(Range)(
                [],
                tail[begin - head.length .. end - head.length]);
        }
    }

    <span class="d_comment">/* Represents a range of elements of the collection. This
     * struct is responsible for defining the opUnary,
     * opAssign, and opOpAssign operators. */</span>
    <span class="d_keyword">struct</span> <span class="hilite">Range</span> {
        <span class="d_keyword">int</span>[] headRange;    <span class="d_comment">// elements that are in 'head'
</span>        <span class="d_keyword">int</span>[] tailRange;    <span class="d_comment">// elements that are in 'tail'
</span>
        <span class="d_comment">/* Applies the unary operation to the elements of the
         * range. */</span>
        Range opUnary(string op)() {
            <span class="d_keyword">mixin</span> (op ~ <span class="d_string">"headRange[];"</span>);
            <span class="d_keyword">mixin</span> (op ~ <span class="d_string">"tailRange[];"</span>);
            <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
        }

        <span class="d_comment">/* Assigns the specified value to each element of the
         * range. */</span>
        Range opAssign(<span class="d_keyword">int</span> value) {
            headRange[] = value;
            tailRange[] = value;
            <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
        }

        <span class="d_comment">/* Uses each element and a value in a binary operation
         * and assigns the result back to that element. */</span>
        Range opOpAssign(string op)(<span class="d_keyword">int</span> value) {
            <span class="d_keyword">mixin</span> (<span class="d_string">"headRange[] "</span> ~ op ~ <span class="d_string">"= value;"</span>);
            <span class="d_keyword">mixin</span> (<span class="d_string">"tailRange[] "</span> ~ op ~ <span class="d_string">"= value;"</span>);
            <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
        }
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> deque = DoubleEndedQueue();

    <span class="d_keyword">foreach</span> (i; 0 .. 10) {
        <span class="d_keyword">if</span> (i % 2) {
            deque.insertAtHead(i);

        } <span class="d_keyword">else</span> {
            deque ~= i;
        }
    }

    writeln(deque);
    deque<span class="hilite">[]</span> *= 10;
    deque<span class="hilite">[3 .. 7]</span> = -1;
    writeln(deque);
}
</pre>

<p>The output:
</p>

<pre class="shell">9 7 5 3 1 0 2 4 6 8 
90 70 50 -1 -1 -1 -1 40 60 80 
</pre>

<h5 class="subsection"><a id="ix_Operator Overloading.opCast" content="opCast"></a> <a id="ix_Operator Overloading.type conversion, opCast" content="type conversion, opCast"></a> <code class="d_inline">opCast</code> for type conversions</h5>

<p><code class="d_inline">opCast</code> defines explicit type conversions. It can be overloaded separately for each target type. As you would remember from the earlier chapters, explicit type conversions are performed by the <code class="d_inline">to</code> function and the <code class="d_inline">cast</code> operator.
</p>

<p><code class="d_inline">opCast</code> is a template as well, but it has a different format: The target type is specified by the <code class="d_inline">(T&nbsp;:&nbsp;target_type)</code> syntax:
</p>

<pre class="d_code">    <i>target_type</i> opCast(T : <i>target_type</i>)() {
        <span class="d_comment">// ...
</span>    }
</pre>

<p>This syntax will become clear later after the templates chapter as well.
</p>

<p>Let's change the definition of <code class="d_inline">Duration</code> so that it now has two members: hours and minutes. The operator that converts objects of this type to <code class="d_inline">double</code> can be defined as in the following code:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.conv;

<span class="d_keyword">struct</span> Duration {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">double</span> opCast(T : <span class="d_keyword">double</span>)() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> hour + (to!<span class="d_keyword">double</span>(minute) / 60);
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> duration = Duration(2, 30);
    <span class="d_keyword">double</span> d = to!<span class="d_keyword">double</span>(duration);
    <span class="d_comment">// (could be 'cast(double)duration' as well)
</span>
    writeln(d);
}
</pre>

<p>The compiler replaces the type conversion call above with the following one:
</p>

<pre class="d_code">    <span class="d_keyword">double</span> d = duration.opCast!<span class="d_keyword">double</span>();
</pre>

<p>The <code class="d_inline">double</code> conversion function above produces 2.5 for two hours and thirty minutes:
</p>

<pre class="shell">2.5
</pre>

<p><a id="ix_Operator Overloading.opCast!bool" content="opCast!bool"></a> <a id="ix_Operator Overloading.bool, opCast" content="bool, opCast"></a> Although <code class="d_inline">opCast</code> is for explicit type conversions, its <code class="d_inline">bool</code> specialization is called automatically when the variable is used in a logical expression:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Duration {
<span class="d_comment">// ...
</span>
    <span class="d_keyword">bool</span> opCast(<span class="hilite">T : <span class="d_keyword">bool</span></span>)() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> (hour != 0) || (minute != 0);
    }
}

<span class="d_comment">// ...
</span>
    <span class="d_keyword">if</span> (duration) {               <span class="d_comment">// compiles
</span>        <span class="d_comment">// ...
</span>    }

    <span class="d_keyword">while</span> (duration) {            <span class="d_comment">// compiles
</span>        <span class="d_comment">// ...
</span>    }

    <span class="d_keyword">auto</span> r = duration ? 1 : 2;    <span class="d_comment">// compiles
</span></pre>

<p>Still, the <code class="d_inline">bool</code> specialization of <code class="d_inline">opCast</code> is not for all implicit <code class="d_inline">bool</code> conversions:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">bool</span> b) {
    <span class="d_comment">// ...
</span>}

<span class="d_comment">// ...
</span>
    foo(duration);                <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    <span class="d_keyword">bool</span> b = duration;            <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<pre class="shell">Error: cannot implicitly convert expression (duration) of type Duration to
bool
Error: function deneme.foo (bool b) is not callable using argument types
(Duration)
</pre>

<h5 class="subsection"><a id="ix_Operator Overloading.opDispatch" content="opDispatch"></a> Catch-all operator <code class="d_inline">opDispatch</code></h5>

<p><code class="d_inline">opDispatch</code> gets called whenever a <i>missing</i> member of an object is accessed. All attempts to access non-existent members are dispatched to this function.
</p>

<p>The name of the missing member becomes the template parameter value of <code class="d_inline">opDispatch</code>.
</p>

<p>The following code demonstrates a simple definition:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> Foo {
    <span class="d_keyword">void</span> opDispatch(string name, T)(T parameter) {
        writefln(<span class="d_string">"Foo.opDispatch - name: %s, value: %s"</span>,
                 name, parameter);
    }
}

<span class="d_keyword">void</span> main() {
    Foo foo;
    foo.aNonExistentFunction(42);
    foo.anotherNonExistentFunction(100);
}
</pre>

<p>There are no compiler errors for the calls to non-existent members. Instead, all of those calls are dispatched to <code class="d_inline">opDispatch</code>. The first template parameter is the name of the member. The parameter values that are used when calling the function appear as the parameters of <code class="d_inline">opDispatch</code>:
</p>

<pre class="shell">Foo.opDispatch - name: aNonExistentFunction, value: 42
Foo.opDispatch - name: anotherNonExistentFunction, value: 100
</pre>

<p>The <code class="d_inline">name</code> template parameter can be used inside the function to make decisions on how the call to that specific non-existent function should be handled:
</p>

<pre class="d_code">   <span class="d_keyword">switch</span> (name) {
       <span class="d_comment">// ...
</span>   }
</pre>

<h5 class="subsection"><a id="ix_Operator Overloading.in, operator overloading" content="in, operator overloading"></a> <a id="ix_Operator Overloading.!in" content="!in"></a> Inclusion query by <code class="d_inline">opBinaryRight!"in"</code></h5>

<p>This operator allows defining the behavior of the <code class="d_inline">in</code> operator for user-defined types. <code class="d_inline">in</code> is commonly used with associative arrays to determine whether a value for a specific key exists in the array.
</p>

<p>Different from other operators, this operator is normally overloaded for the case where the object appears on the right-hand side:
</p>

<pre class="d_code">        <span class="d_keyword">if</span> (time <span class="d_keyword">in</span> lunchBreak) {
</pre>

<p>The compiler would use <code class="d_inline">opBinaryRight</code> behind the scenes:
</p>

<pre class="d_code">        <span class="d_comment">// the equivalent of the above:
</span>        <span class="d_keyword">if</span> (lunchBreak.opBinaryRight!<span class="d_string">"in"</span>(time)) {
</pre>

<p>There is also <code class="d_inline">!in</code> to determine whether a value for a specific key <i>does not</i> exist in the array:
</p>

<pre class="d_code">        <span class="d_keyword">if</span> (a !<span class="d_keyword">in</span> b) {
</pre>

<p><code class="d_inline">!in</code> cannot be overloaded because the compiler uses the negative of the result of the <code class="d_inline">in</code> operator instead:
</p>

<pre class="d_code">        <span class="d_keyword">if</span> (!(a <span class="d_keyword">in</span> b)) {    <span class="d_comment">// the equivalent of the above
</span></pre>

<h6>Example of the <code class="d_inline">in</code> operator</h6>

<p>The following program defines a <code class="d_inline">TimeSpan</code> type in addition to <code class="d_inline">Duration</code> and <code class="d_inline">TimeOfDay</code>. The <code class="d_inline">in</code> operator that is defined for <code class="d_inline">TimeSpan</code> determines whether a moment in time is within that time span.
</p>

<p>To keep the code short, the following program defines only the necessary member functions.
</p>

<p>Note how the <code class="d_inline">TimeOfDay</code> object is used seamlessly in the <code class="d_inline">for</code> loop. That loop is a demonstration of how useful operator overloading can be.
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.string;

<span class="d_keyword">struct</span> Duration {
    <span class="d_keyword">int</span> minute;
}

<span class="d_keyword">struct</span> TimeOfDay {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;

    <span class="d_keyword">ref</span> TimeOfDay opOpAssign(string op)(Duration duration)
            <span class="d_keyword">if</span> (op == <span class="d_string">"+"</span>) {
        minute += duration.minute;

        hour += minute / 60;
        minute %= 60;
        hour %= 24;

        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_keyword">int</span> opCmp(TimeOfDay rhs) <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> (hour == rhs.hour
                ? minute - rhs.minute
                : hour - rhs.hour);
    }

    string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"%02s:%02s"</span>, hour, minute);
    }
}

<span class="d_keyword">struct</span> TimeSpan {
    TimeOfDay begin;
    TimeOfDay end;    <span class="d_comment">// end is outside of the span
</span>
    <span class="d_keyword">bool</span> opBinaryRight(string op)(TimeOfDay time) <span class="d_keyword">const</span>
            <span class="d_keyword">if</span> (op == <span class="d_string">"in"</span>) {
        <span class="d_keyword">return</span> (time &gt;= begin) &amp;&amp; (time &lt; end);
    }
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> lunchBreak = TimeSpan(TimeOfDay(12, 00),
                               TimeOfDay(13, 00));

    <span class="d_keyword">for</span> (<span class="d_keyword">auto</span> time = TimeOfDay(11, 30);
         time &lt; TimeOfDay(13, 30);
         time += Duration(15)) {

        <span class="d_keyword">if</span> (time <span class="d_keyword">in</span> lunchBreak) {
            writeln(time, <span class="d_string">" is during the lunch break"</span>);

        } <span class="d_keyword">else</span> {
            writeln(time, <span class="d_string">" is outside of the lunch break"</span>);
        }
    }
}
</pre>

<p>The output:
</p>

<pre class="shell">11:30 is outside of the lunch break
11:45 is outside of the lunch break
12:00 is during the lunch break
12:15 is during the lunch break
12:30 is during the lunch break
12:45 is during the lunch break
13:00 is outside of the lunch break
13:15 is outside of the lunch break
</pre>

<h5 class="subsection">Problem</h5>
    
<p>Define a fraction type that stores its numerator and denominator as members of type <code class="d_inline">long</code>. Such a type may be useful because it does not lose value like <code class="d_inline">float</code>, <code class="d_inline">double</code>, and <code class="d_inline">real</code> do due to their precisions. For example, although the result of multiplying a <code class="d_inline">double</code> value of 1.0/3 by 3 is <i>not</i> 1.0, multiplying a <code class="d_inline">Fraction</code> object that represents the fraction 1/3 by 3 would be exactly 1:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Fraction {
    <span class="d_keyword">long</span> num;  <span class="d_comment">// numerator
</span>    <span class="d_keyword">long</span> den;  <span class="d_comment">// denominator
</span>
    <span class="d_comment">/* As a convenience, the constructor uses the default
     * value of 1 for the denominator. */</span>
    <span class="d_keyword">this</span>(<span class="d_keyword">long</span> num, <span class="d_keyword">long</span> den = 1) {
        enforce(den != 0, <span class="d_string">"The denominator cannot be zero"</span>);

        <span class="d_keyword">this</span>.num = num;
        <span class="d_keyword">this</span>.den = den;

        <span class="d_comment">/* Ensuring that the denominator is always positive
         * will simplify the definitions of some of the
         * operator functions. */</span>
        <span class="d_keyword">if</span> (<span class="d_keyword">this</span>.den &lt; 0) {
            <span class="d_keyword">this</span>.num = -<span class="d_keyword">this</span>.num;
            <span class="d_keyword">this</span>.den = -<span class="d_keyword">this</span>.den;
        }
    }

    <span class="d_comment">/* ... you define the operator overloads ... */</span>
}
</pre>

<p>Define operators as needed for this type to make it a convenient type as close to fundamental types as possible. Ensure that the definition of the type passes all of the following unit tests. The unit tests ensure the following behaviors:
</p>

<ul>
<li>An exception must be thrown when constructing an object with zero denominator. (This is already taken care of by the <code class="d_inline">enforce</code> expression above.)</li>

<li>Producing the negative of the value: For example, the negative of 1/3 should be -1/3 and negative of -2/5 should be 2/5.</li>

<li>Incrementing and decrementing the value by <code class="d_inline">++</code> and <code class="d_inline">--</code>.</li>

<li>Support for four arithmetic operations: Both modifying the value of an object by <code class="d_inline">+=</code>, <code class="d_inline">-=</code>, <code class="d_inline">*=</code>, and <code class="d_inline">/=</code>; and producing the result of using two objects with the <code class="d_inline">+</code>, <code class="d_inline">-</code>, <code class="d_inline">*</code>, and <code class="d_inline">/</code> operators. (Similar to the constructor, dividing by zero should be prevented.)

<p>As a reminder, here are the formulas of arithmetic operations that involve two fractions a/b and c/d:
</p>

<ul><li>Addition: a/b + c/d = (a*d + c*b)/(b*d)</li>
<li>Subtraction: a/b - c/d = (a*d - c*b)/(b*d)</li>
<li>Multiplication: a/b * c/d = (a*c)/(b*d)</li>
<li>Division: (a/b) / (c/d) = (a*d)/(b*c)</li>
</ul>

</li>

<li>The actual (and necessarily lossful) value of the object can be converted to <code class="d_inline">double</code>.</li>

<li>Sort order and equality comparisons are performed by the actual values of the fractions, not by the values of the numerators and denominators. For example, the fractions 1/3 and 20/60 must be considered to be equal.
</li>

</ul>

<pre class="d_code"><span class="d_keyword">unittest</span> {
    <span class="d_comment">/* Must throw when denominator is zero. */</span>
    assertThrown(Fraction(42, 0));

    <span class="d_comment">/* Let's start with 1/3. */</span>
    <span class="d_keyword">auto</span> a = Fraction(1, 3);

    <span class="d_comment">/* -1/3 */</span>
    <span class="d_keyword">assert</span>(-a == Fraction(-1, 3));

    <span class="d_comment">/* 1/3 + 1 == 4/3 */</span>
    ++a;
    <span class="d_keyword">assert</span>(a == Fraction(4, 3));

    <span class="d_comment">/* 4/3 - 1 == 1/3 */</span>
    --a;
    <span class="d_keyword">assert</span>(a == Fraction(1, 3));

    <span class="d_comment">/* 1/3 + 2/3 == 3/3 */</span>
    a += Fraction(2, 3);
    <span class="d_keyword">assert</span>(a == Fraction(1));

    <span class="d_comment">/* 3/3 - 2/3 == 1/3 */</span>
    a -= Fraction(2, 3);
    <span class="d_keyword">assert</span>(a == Fraction(1, 3));

    <span class="d_comment">/* 1/3 * 8 == 8/3 */</span>
    a *= Fraction(8);
    <span class="d_keyword">assert</span>(a == Fraction(8, 3));

    <span class="d_comment">/* 8/3 / 16/9 == 3/2 */</span>
    a /= Fraction(16, 9);
    <span class="d_keyword">assert</span>(a == Fraction(3, 2));

    <span class="d_comment">/* Must produce the equivalent value in type 'double'.
     *
     * Note that although double cannot represent every value
     * precisely, 1.5 is an exception. That is why this test
     * is being applied at this point. */</span>
    <span class="d_keyword">assert</span>(to!<span class="d_keyword">double</span>(a) == 1.5);

    <span class="d_comment">/* 1.5 + 2.5 == 4 */</span>
    <span class="d_keyword">assert</span>(a + Fraction(5, 2) == Fraction(4, 1));

    <span class="d_comment">/* 1.5 - 0.75 == 0.75 */</span>
    <span class="d_keyword">assert</span>(a - Fraction(3, 4) == Fraction(3, 4));

    <span class="d_comment">/* 1.5 * 10 == 15 */</span>
    <span class="d_keyword">assert</span>(a * Fraction(10) == Fraction(15, 1));

    <span class="d_comment">/* 1.5 / 4 == 3/8 */</span>
    <span class="d_keyword">assert</span>(a / Fraction(4) == Fraction(3, 8));

    <span class="d_comment">/* Must throw when dividing by zero. */</span>
    assertThrown(Fraction(42, 1) / Fraction(0));

    <span class="d_comment">/* The one with lower numerator is before. */</span>
    <span class="d_keyword">assert</span>(Fraction(3, 5) &lt; Fraction(4, 5));

    <span class="d_comment">/* The one with larger denominator is before. */</span>
    <span class="d_keyword">assert</span>(Fraction(3, 9) &lt; Fraction(3, 8));
    <span class="d_keyword">assert</span>(Fraction(1, 1_000) &gt; Fraction(1, 10_000));

    <span class="d_comment">/* The one with lower value is before. */</span>
    <span class="d_keyword">assert</span>(Fraction(10, 100) &lt; Fraction(1, 2));

    <span class="d_comment">/* The one with negative value is before. */</span>
    <span class="d_keyword">assert</span>(Fraction(-1, 2) &lt; Fraction(0));
    <span class="d_keyword">assert</span>(Fraction(1, -2) &lt; Fraction(0));

    <span class="d_comment">/* The ones with equal values must be both &lt;= and &gt;=. */</span>
    <span class="d_keyword">assert</span>(Fraction(-1, -2) &lt;= Fraction(1, 2));
    <span class="d_keyword">assert</span>(Fraction(1, 2) &lt;= Fraction(-1, -2));
    <span class="d_keyword">assert</span>(Fraction(3, 7) &lt;= Fraction(9, 21));
    <span class="d_keyword">assert</span>(Fraction(3, 7) &gt;= Fraction(9, 21));

    <span class="d_comment">/* The ones with equal values must be equal. */</span>
    <span class="d_keyword">assert</span>(Fraction(1, 3) == Fraction(20, 60));

    <span class="d_comment">/* The ones with equal values with sign must be equal. */</span>
    <span class="d_keyword">assert</span>(Fraction(-1, 2) == Fraction(1, -2));
    <span class="d_keyword">assert</span>(Fraction(1, 2) == Fraction(-1, -2));
}
</pre>

 <div class="cozum_link_tek"><p><a target="ddili_cozum" href="operator_overloading.cozum.html"><i>... çözüm</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Fri Feb  2 10:24:02 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2022 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Expressions - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Expressions' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.freenode.net/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option selected value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    <div class="head"><h5>Language Reference</h5> <p class="subnav-duplicate"><a href="../spec/spec.html">table of contents</a></p></div>
    <ul>        <li><a href='            ../spec/intro.html'>Introduction</a></li><li><a href='            ../spec/lex.html'>Lexical</a></li><li><a href='            ../spec/grammar.html'>Grammar</a></li><li><a href='            ../spec/module.html'>Modules</a></li><li><a href='            ../spec/declaration.html'>Declarations</a></li><li><a href='            ../spec/type.html'>Types</a></li><li><a href='            ../spec/property.html'>Properties</a></li><li><a href='            ../spec/attribute.html'>Attributes</a></li><li><a href='            ../spec/pragma.html'>Pragmas</a></li><li><a href='            ../spec/expression.html'>Expressions</a></li><li><a href='            ../spec/statement.html'>Statements</a></li><li><a href='            ../spec/arrays.html'>Arrays</a></li><li><a href='            ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='            ../spec/struct.html'>Structs and Unions</a></li><li><a href='            ../spec/class.html'>Classes</a></li><li><a href='            ../spec/interface.html'>Interfaces</a></li><li><a href='            ../spec/enum.html'>Enums</a></li><li><a href='            ../spec/const3.html'>Type Qualifiers</a></li><li><a href='            ../spec/function.html'>Functions</a></li><li><a href='            ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='            ../spec/template.html'>Templates</a></li><li><a href='            ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='            ../spec/contracts.html'>Contract Programming</a></li><li><a href='            ../spec/version.html'>Conditional Compilation</a></li><li><a href='            ../spec/traits.html'>Traits</a></li><li><a href='            ../spec/errors.html'>Error Handling</a></li><li><a href='            ../spec/unittest.html'>Unit Tests</a></li><li><a href='            ../spec/garbage.html'>Garbage Collection</a></li><li><a href='            ../spec/float.html'>Floating Point</a></li><li><a href='            ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='            ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='            ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='            ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='            ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='            ../spec/portability.html'>Portability Guide</a></li><li><a href='            ../spec/entity.html'>Named Character Entities</a></li><li><a href='            ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='            ../spec/abi.html'>Application Binary Interface</a></li><li><a href='            ../spec/simd.html'>Vector Extensions</a></li><li><a href='            ../spec/betterc.html'>Better C</a></li><li><a href='            ../spec/ob.html'>Live Functions
        </a></li>
    </ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BExpressions%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/spec/expression.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Expressions</h1>
        
<style>    body { counter-reset: h1 10; counter-increment: h1 -1; }
    h1 { counter-reset: h2 h3 p; }
    h2 { counter-reset: h3 h4 p; }
    h3 { counter-reset: h4 p; }
    h4 { counter-reset: p; }
    h1::before {
        counter-increment: h1;
        content: counter(h1) ". ";
    }
    h2::before {
        counter-increment: h2;
        content: counter(h1) "." counter(h2) " ";
    }
    h3::before {
        counter-increment: h3;
        content: counter(h1) "." counter(h2) "." counter(h3) " ";
    }
    h4::before {
        counter-increment: h4;
        content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) " ";
    }
    p::before, .spec-boxes::before {
        counter-increment: p;
        content: counter(p) ". ";
    }
    h1::before, h2::before, h3::before, h4::before, p::before, .spec-boxes::before
    {
        color: #999;
        font-size: 80%;
        margin-right: 0.25em;
    }
</style>
        <div class="blankline"></div>
<div class="blankline"></div>
<div class="blankline"></div>
<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#definitions-and-terms">Definitions and Terms</a></li>
    <li><a href="#order-of-evaluation">Order Of Evaluation</a></li>
    <li><a href="#temporary-lifetime">Lifetime of Temporaries</a></li>
    <li><a href="#expression">Expressions</a></li>
    <li><a href="#assign_expressions">Assign Expressions</a><ol>        <li><a href="#simple_assignment_expressions">Simple Assignment Expression</a></li>
        <li><a href="#assignment_operator_expressions">Assignment Operator Expressions</a></li>
    </ol></li>
    <li><a href="#conditional_expressions">Conditional Expressions</a></li>
    <li><a href="#oror_expressions">OrOr Expressions</a></li>
    <li><a href="#andand_expressions">AndAnd Expressions</a></li>
    <li><a href="#bitwise_expressions">Bitwise Expressions</a><ol>        <li><a href="#or_expressions">Or Expressions</a></li>
        <li><a href="#xor_expressions">Xor Expressions</a></li>
        <li><a href="#and_expressions">And Expressions</a></li>
    </ol></li>
    <li><a href="#compare_expressions">Compare Expressions</a></li>
    <li><a href="#equality_expressions">Equality Expressions</a><ol>        <li><a href="#identity_expressions">Identity Expressions</a></li>
    </ol></li>
    <li><a href="#relation_expressions">Relational Expressions</a><ol>        <li><a href="#integer_comparisons">Integer comparisons</a></li>
        <li><a href="#floating-point-comparisons">Floating point comparisons</a></li>
        <li><a href="#class-comparisons">Class comparisons</a></li>
    </ol></li>
    <li><a href="#in_expressions">In Expressions</a></li>
    <li><a href="#shift_expressions">Shift Expressions</a></li>
    <li><a href="#add_expressions">Add Expressions</a></li>
    <li><a href="#cat_expressions">Cat Expressions</a></li>
    <li><a href="#mul_expressions">Mul Expressions</a></li>
    <li><a href="#unary-expression">Unary Expressions</a><ol>        <li><a href="#complement_expressions">Complement Expressions</a></li>
        <li><a href="#new_expressions">New Expressions</a></li>
        <li><a href="#delete_expressions">Delete Expressions</a></li>
        <li><a href="#cast_expressions">Cast Expressions</a></li>
    </ol></li>
    <li><a href="#pow_expressions">Pow Expressions</a></li>
    <li><a href="#postfix_expressions">Postfix Expressions</a></li>
    <li><a href="#index_expressions">Index Expressions</a></li>
    <li><a href="#slice_expressions">Slice Expressions</a></li>
    <li><a href="#primary_expressions">Primary Expressions</a><ol>        <li><a href="#identifier">.Identifier</a></li>
        <li><a href="#this">this</a></li>
        <li><a href="#super">super</a></li>
        <li><a href="#null">null</a></li>
        <li><a href="#true_false">true, false</a></li>
        <li><a href="#character-literal">Character Literals</a></li>
        <li><a href="#string_literals">String Literals</a></li>
        <li><a href="#array_literals">Array Literals</a></li>
        <li><a href="#associative_array_literals">Associative Array Literals</a></li>
        <li><a href="#function_literals">Function Literals</a></li>
        <li><a href="#lambdas">Lambdas</a></li>
        <li><a href="#uniform_construction_syntax">Uniform construction syntax for built-in scalar types</a></li>
        <li><a href="#assert_expressions">Assert Expressions</a></li>
        <li><a href="#mixin_expressions">Mixin Expressions</a></li>
        <li><a href="#import_expressions">Import Expressions</a></li>
        <li><a href="#typeid_expressions">Typeid Expressions</a></li>
        <li><a href="#is_expression">IsExpression</a></li>
    </ol></li>
    <li><a href="#specialkeywords">Special Keywords</a></li>
    <li><a href="#associativity">Associativity and Commutativity</a></li>
</ol>
</div>
<div class="blankline"></div>
<p>An expression is a sequence of operators and operands that specifies an evaluation.
The syntax, order of evaluation, and semantics of expressions are as follows.</p>
<div class="blankline"></div>
    <p>Expressions are used to compute values with a resulting type.
        These values can then be assigned,
        tested, or ignored. Expressions can also have side effects.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="definitions-and-terms" href="#definitions-and-terms">Definitions and Terms</a></h2>
<div class="blankline"></div>
<span class="def-anchor" id=".define-full-expression"></span><div class="quickindex" id="quickindex.define-full-expression"></div><p><b>Definition</b> (&ldquo;Full expression&rdquo;): For any expression
<i>expr</i>, the full expression of <i>expr</i> is defined as follows. If <i>expr</i> parses as a
subexpression of another expression <i>expr<sub>1</sub></i>, then the full expression of <i>expr</i> is the
full expression of <i>expr<sub>1</sub></i>. Otherwise, <i>expr</i> is its own full expression.</p>
<div class="blankline"></div>
<p>Each expression has a unique full expression.</p>
<div class="blankline"></div>
<p>Example: in the statement <span class="d_inlinecode donthyphenate notranslate">return f() + g() * 2;</span>, the full expression of <span class="d_inlinecode donthyphenate notranslate">g() * 2</span> is <span class="d_inlinecode donthyphenate notranslate">f() + g() * 2</span>, but not the
full expression of <span class="d_inlinecode donthyphenate notranslate">f() + g()</span> because the latter is not parsed as a subexpression.</p>
<div class="blankline"></div>
<p>Note: Although the definition is straightforward, a few subtleties exist related to function literals. In the
statement <span class="d_inlinecode donthyphenate notranslate">return (() =&gt; x + f())() * g();</span>, the full expression of <span class="d_inlinecode donthyphenate notranslate">f()</span> is <span class="d_inlinecode donthyphenate notranslate">x + f()</span>, not the expression passed
to <span class="d_inlinecode donthyphenate notranslate">return</span>. This is because the parent of <span class="d_inlinecode donthyphenate notranslate">x + f()</span> has function literal type, not expression type.</p>
<div class="blankline"></div>
<span class="def-anchor" id=".define-lvalue"></span><div class="quickindex" id="quickindex.define-lvalue"></div><p><b>Definition</b> (&ldquo;Lvalue&rdquo;): The following expressions, and no
others, are called lvalue expressions or lvalues:</p>
<ol><li><span class="d_inlinecode donthyphenate notranslate">this</span> inside <span class="d_inlinecode donthyphenate notranslate">struct</span> and <span class="d_inlinecode donthyphenate notranslate">union</span> member functions;</li>
<li>a variable or the result of the <i>DotIdentifier</i> grammatical construct <span class="d_inlinecode donthyphenate notranslate">.</span> (left side may be
missing) when the rightmost side of the dot is a variable,
field (direct or <span class="d_inlinecode donthyphenate notranslate">static</span>), function name, or invocation of a function that returns by reference;</li>
<li>the result of the following expressions:
<ul><li>built-in unary operators <span class="d_inlinecode donthyphenate notranslate">+</span> (when applied to an lvalue), <span class="d_inlinecode donthyphenate notranslate">*</span>, <span class="d_inlinecode donthyphenate notranslate">++</span> (prefix only), <span class="d_inlinecode donthyphenate notranslate">--</span> (prefix only);</li>
<li>built-in indexing operator <span class="d_inlinecode donthyphenate notranslate">[]</span> (but not the slicing operator);</li>
<li>built-in assignment binary operators, i.e. <span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">+=</span>, <span class="d_inlinecode donthyphenate notranslate">*=</span>, <span class="d_inlinecode donthyphenate notranslate">/=</span>, <span class="d_inlinecode donthyphenate notranslate">%=</span>, <span class="d_inlinecode donthyphenate notranslate">&amp;=</span>, <span class="d_inlinecode donthyphenate notranslate">|=</span>, <span class="d_inlinecode donthyphenate notranslate">^=</span>, <span class="d_inlinecode donthyphenate notranslate">~=</span>,
<span class="d_inlinecode donthyphenate notranslate">&lt;&lt;=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;=</span>, and <span class="d_inlinecode donthyphenate notranslate">^^=</span>;</li>
<li>the ternary operator <i>e</i> <span class="d_inlinecode donthyphenate notranslate">?</span> <i>e<sub>1</sub></i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>e<sub>2</sub></i> under the following
circumstances:</li>
<ol>    <li><i>e<sub>1</sub></i> and <i>e<sub>2</sub></i> are lvalues of the same type; OR</li>
    <li>One of <i>e<sub>1</sub></i> and <i>e<sub>2</sub></i> is an lvalue of type <span class="d_inlinecode donthyphenate notranslate">T</span> and the other has
    and <span class="d_inlinecode donthyphenate notranslate">alias this</span> converting it to <span class="d_inlinecode donthyphenate notranslate">ref T</span>;</li></ol>
<li>user-defined operators if and only if the function called as a result of lowering returns
by reference;</li>
<li><span class="d_inlinecode donthyphenate notranslate">mixin</span> expressions if and only if the compilation of the expression resulting from compiling
the argument(s) to <span class="d_inlinecode donthyphenate notranslate">mixin</span> is an lvalue;</li>
<li><span class="d_inlinecode donthyphenate notranslate">cast(U)</span> expressions applied to lvalues of type <span class="d_inlinecode donthyphenate notranslate">T</span> when <span class="d_inlinecode donthyphenate notranslate">T*</span> is implicitly convertible to <span class="d_inlinecode donthyphenate notranslate">U*</span>;</li>
<li><span class="d_inlinecode donthyphenate notranslate">cast()</span> and <span class="d_inlinecode donthyphenate notranslate">cast(</span><i>qualifier list</i><span class="d_inlinecode donthyphenate notranslate">)</span> when applied to an lvalue.</li>
</ul></li></ol>
<div class="blankline"></div>
<span class="def-anchor" id=".define-rvalue"></span><div class="quickindex" id="quickindex.define-rvalue"></div><p><b>Definition</b> (&ldquo;Rvalue&rdquo;): Expressions that are not
lvalues are rvalues.</p>
<div class="blankline"></div>
<p>Note: Rvalues include all literals, special value keywords such as <span class="d_inlinecode donthyphenate notranslate">__FILE__</span> and <span class="d_inlinecode donthyphenate notranslate">__LINE__</span>,
<span class="d_inlinecode donthyphenate notranslate">enum</span> values, and the result of expressions not defined as lvalues above.</p>
<div class="blankline"></div>
<p>The built-in address-of operator (unary <span class="d_inlinecode donthyphenate notranslate">&amp;</span>) may only be applied to lvalues.</p>
<div class="blankline"></div>
<span class="def-anchor" id=".define-smallest-short-circuit"></span><div class="quickindex" id="quickindex.define-smallest-short-circuit"></div><p><b>Definition</b> (&ldquo;Smallest
short-circuit expression&rdquo;): Given an expression <i>expr</i> that is a subexpression of a full
expression <i>fullexpr</i>, the smallest short-circuit expression, if any, is the shortest
subexpression <i>scexpr</i> of <i>fullexpr</i> that is an <a href="#AndAndExpression"><i>AndAndExpression</i></a> (<span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span>) or an
<a href="#OrOrExpression"><i>OrOrExpression</i></a> (<span class="d_inlinecode donthyphenate notranslate">||</span>), such that <i>expr</i> is a subexpression of <i>scexpr</i>.</p>
<div class="blankline"></div>
Example: in the expression <span class="d_inlinecode donthyphenate notranslate">((f() * 2 &amp;&amp; g()) + 1) || h()</span>, the smallest short-circuit expression
of the subexpression <span class="d_inlinecode donthyphenate notranslate">f() * 2</span> is <span class="d_inlinecode donthyphenate notranslate">f() * 2 &amp;&amp; g()</span>. In the expression <span class="d_inlinecode donthyphenate notranslate">(f() &amp;&amp; g()) + h()</span>, the
subexpression <span class="d_inlinecode donthyphenate notranslate">h()</span> has no smallest short-circuit expression.
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="order-of-evaluation" href="#order-of-evaluation">Order Of Evaluation</a></h2>
<div class="blankline"></div>
<p>Built-in prefix unary expressions <span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> are evaluated as if lowered (rewritten) to
assignments as follows: <span class="d_inlinecode donthyphenate notranslate">++expr</span> becomes <span class="d_inlinecode donthyphenate notranslate">((expr) += 1)</span>, and <span class="d_inlinecode donthyphenate notranslate">--expr</span> becomes <span class="d_inlinecode donthyphenate notranslate">((expr) -= 1)</span>.
Therefore, the result of prefix <span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> is the lvalue after the side effect has been
effected.</p>
<div class="blankline"></div>
<p>Built-in postfix unary expressions <span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> are evaluated as if lowered (rewritten) to lambda
invocations as follows: <span class="d_inlinecode donthyphenate notranslate">expr++</span> becomes <span class="d_inlinecode donthyphenate notranslate">(ref T x){auto t = x; ++x; return t;}(expr)</span>, and
<span class="d_inlinecode donthyphenate notranslate">expr--</span> becomes <span class="d_inlinecode donthyphenate notranslate">(ref T x){auto t = x; --x; return t;}(expr)</span>. Therefore, the result of postfix
<span class="d_inlinecode donthyphenate notranslate">++</span> and <span class="d_inlinecode donthyphenate notranslate">--</span> is an rvalue just before the side effect has been effected.</p>
<div class="blankline"></div>
<p>Binary expressions except for <a href="#AssignExpression"><i>AssignExpression</i></a>, <a href="#OrOrExpression"><i>OrOrExpression</i></a>, and
<a href="#AndAndExpression"><i>AndAndExpression</i></a> are evaluated in lexical order (left-to-right). Example:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span> i = 2;
i = ++i * i++ + i;
<span class="d_keyword">assert</span>(i == 3 * 3 + 4);
</pre>

</div>
<div class="blankline"></div>
<p><a href="#OrOrExpression"><i>OrOrExpression</i></a> and <a href="#AndAndExpression"><i>AndAndExpression</i></a> evaluate their left-hand side argument
first. Then, <a href="#OrOrExpression"><i>OrOrExpression</i></a> evaluates its right-hand side if and only if its left-hand
side does not evaluate to nonzero. <a href="#AndAndExpression"><i>AndAndExpression</i></a> evaluates its right-hand side if and
only if its left-hand side evaluates to nonzero.</p>
<div class="blankline"></div>
<p><a href="#ConditionalExpression"><i>ConditionalExpression</i></a> evaluates its left-hand side argument
first. Then, if the result is nonzero, the second operand is evaluated. Otherwise, the third operand
is evaluated.</p>
<div class="blankline"></div>
<p>Calls to functions  with <span class="d_inlinecode donthyphenate notranslate">extern(D)</span> <a href="../spec/attribute.html#linkage">linkage</a> (which is
the default linkage) are evaluated in the following order: first, if necessary, the address of the
function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then,
arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">void</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b, <span class="d_keyword">int</span> c) fun()
{
    writeln(<span class="d_string">"fun() called"</span>);
    <span class="d_keyword">static</span> <span class="d_keyword">void</span> r(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b, <span class="d_keyword">int</span> c) { writeln(<span class="d_string">"callee called"</span>); }
    <span class="d_keyword">return</span> &amp;r;
}
<span class="d_keyword">int</span> f1() { writeln(<span class="d_string">"f1() called"</span>); <span class="d_keyword">return</span> 1; }
<span class="d_keyword">int</span> f2() { writeln(<span class="d_string">"f2() called"</span>); <span class="d_keyword">return</span> 2; }
<span class="d_keyword">int</span> f3(<span class="d_keyword">int</span> x) { writeln(<span class="d_string">"f3() called"</span>); <span class="d_keyword">return</span> x + 3; }
<span class="d_keyword">int</span> f4() { writeln(<span class="d_string">"f4() called"</span>); <span class="d_keyword">return</span> 4; }
<span class="d_comment">// evaluates fun() then f1() then f2() then f3() then f4()
</span><span class="d_comment">// after which control is transferred to the callee
</span>fun()(f1(), f3(f2()), f4());
</pre>

</div>
<div class="blankline"></div>
    <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b>     <ol>    <li>The order of evaluation of the operands of <a href="#AssignExpression"><i>AssignExpression</i></a>.</li>
    <li>The order of evaluation of function arguments for functions with linkage other than <span class="d_inlinecode donthyphenate notranslate">extern (D)</span>.</li>
    </ol></div>


<div class="blankline"></div>
    <div class="spec-boxes best-practice"><b>Best Practices:</b> Even though the order of evaluation is well-defined, writing code that
    depends on it is rarely recommended.</div>


<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="temporary-lifetime" href="#temporary-lifetime">Lifetime of Temporaries</a></h2>
<div class="blankline"></div>
<p>Expressions and statements may create and/or consume rvalues. Such values are called
<i>temporaries</i> and do not have a name or a visible scope. Their lifetime is managed automatically
as defined in this section.</p>
<div class="blankline"></div>
<p>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the
evaluation point, similarly to creation of a usual named value initialized with an expression.</p>
<div class="blankline"></div>
<p>Termination of lifetime of temporaries does not obey the customary scoping rules and is defined
as follows:</p>
<div class="blankline"></div>
<ul><li>If:
<ol><li>the full expression has a smallest short-circuit expression <i>expr</i>; and</li>
<li>the temporary is created on the right-hand side of the <span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> or <span class="d_inlinecode donthyphenate notranslate">||</span> operator; and</li>
<li>the right-hand side is evaluated,</li></ol>
then temporary destructors are evaluated right after the right-hand side
expression has been evaluated and converted to <span class="d_inlinecode donthyphenate notranslate">bool</span>. Evaluation of destructors proceeds in
reverse order of construction.</li>
<div class="blankline"></div>
<li>For all other cases, the temporaries generated for the purpose of invoking functions are
deferred to the end of the full expression. The order of destruction is inverse to the order of
construction.</li></ul>
<div class="blankline"></div>
<p>If a subexpression of an expression throws an exception, all temporaries created up to the
evaluation of that subexpression will be destroyed per the rules above. No destructor calls will
be issued for temporaries not yet constructed.</p>
<div class="blankline"></div>
<p>Note: An intuition behind these rules is that destructors of temporaries are deferred to the end of full
expression and in reverse order of construction, with the exception that the right-hand side of
<span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> and <span class="d_inlinecode donthyphenate notranslate">||</span> are considered their own full expressions even when part of larger expressions.</p>
<div class="blankline"></div>
<p>Note: The ternary expression <i>e<sub>1</sub> ? e<sub>2</sub> : e<sub>3</sub></i> is not
a special case although it evaluates expressions conditionally: <i>e<sub>1</sub></i> and one of
<i>e<sub>2</sub></i> and <i>e<sub>3</sub></i> may create temporaries. Their destructors are inserted
to the end of the full expression in the reverse order of creation.</p>
<div class="blankline"></div>
<p>Example:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> x;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> n) { x = n; writefln(<span class="d_string">"S(%s)"</span>, x); }
    ~<span class="d_keyword">this</span>() { writefln(<span class="d_string">"~S(%s)"</span>, x); }
}
<span class="d_keyword">bool</span> b = (S(1) == S(2) || S(3) != S(4)) &amp;&amp; S(5) == S(6);
</pre>

</div>
<div class="blankline"></div>
The output of the code above is:
<div class="blankline"></div>
<pre class="console notranslate">S(1)
S(2)
S(3)
S(4)
~S(4)
~S(3)
S(5)
S(6)
~S(6)
~S(5)
~S(2)
~S(1)
</pre>
<div class="blankline"></div>
First, <span class="d_inlinecode donthyphenate notranslate">S(1)</span> and <span class="d_inlinecode donthyphenate notranslate">S(2)</span> are evaluated in lexical order. Per the rules, they will be destroyed at
the end of the full expression and in reverse order. The comparison <span class="d_inlinecode donthyphenate notranslate">S(1) == S(2)</span> yields
<span class="d_inlinecode donthyphenate notranslate">false</span>, so the right-hand side of the <span class="d_inlinecode donthyphenate notranslate">||</span> is evaluated causing <span class="d_inlinecode donthyphenate notranslate">S(3)</span> and <span class="d_inlinecode donthyphenate notranslate">S(4)</span> to be evaluated,
also in lexical order. However, their destruction is not deferred to the end of the full
expression. Instead, <span class="d_inlinecode donthyphenate notranslate">S(4)</span> and then <span class="d_inlinecode donthyphenate notranslate">S(3)</span> are destroyed at the end of the <span class="d_inlinecode donthyphenate notranslate">||</span> expression.
Following their destruction, <span class="d_inlinecode donthyphenate notranslate">S(5)</span> and <span class="d_inlinecode donthyphenate notranslate">S(6)</span> are constructed in lexical order. Again they are not
destroyed at the end of the full expression, but right at the end of the <span class="d_inlinecode donthyphenate notranslate">&amp;&amp;</span> expression.
Consequently, the destruction of <span class="d_inlinecode donthyphenate notranslate">S(6)</span> and <span class="d_inlinecode donthyphenate notranslate">S(5)</span> is carried before that of <span class="d_inlinecode donthyphenate notranslate">S(2)</span> and <span class="d_inlinecode donthyphenate notranslate">S(1)</span>.
<div class="blankline"></div>
<h2><span id="Expression"><a class="anchor" title="Permalink to this section" id="expression" href="#expression">Expressions</a></span></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="Expression"><span class="gname">Expression</span></a>:
    <i>CommaExpression</i>
<div class="blankline"></div>
<a id="CommaExpression"><span class="gname">CommaExpression</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>CommaExpression</i>
</pre>
<div class="blankline"></div>
    <p>The left operand of the <span class="d_inlinecode donthyphenate notranslate">,</span> is evaluated, then the right operand
        is evaluated. The type of the expression is the type of the right
        operand, and the result is the result of the right operand.
        Using the result of comma expressions isn't allowed.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="assign_expressions" href="#assign_expressions">Assign Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AssignExpression"><span class="gname">AssignExpression</span></a>:
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">+=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">-=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">*=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">/=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">%=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&amp;=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">|=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">^=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">~=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;=</span> <i>AssignExpression</i>
    <a href="#ConditionalExpression"><i>ConditionalExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">^^=</span> <i>AssignExpression</i>
</pre>
<div class="blankline"></div>
    <p>For all assign expressions, the left operand must be a modifiable
    lvalue. The type of the assign expression is the type of the left
    operand, and the value is the value of the left operand after assignment
    occurs. The resulting expression is a modifiable lvalue.
    </p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b>     If either operand is a reference type and one of the following:
    <ol>    <li>the operands have partially overlapping storage</li>
    <li>the operands' storage overlaps exactly but the types are different</li>
    </ol></div>


<div class="blankline"></div>
    <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b>     If neither operand is a reference type and one of the following:
    <ol>    <li>the operands have partially overlapping storage</li>
    <li>the operands' storage overlaps exactly but the types are different</li>
    </ol></div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="simple_assignment_expressions" href="#simple_assignment_expressions">Simple Assignment Expression</a></h3>
<div class="blankline"></div>
    <p>If the operator is <span class="d_inlinecode donthyphenate notranslate">=</span> then it is simple assignment.
    The right operand is implicitly converted to the type of the
    left operand, and assigned to it.</p>
<div class="blankline"></div>
    <p>If the left and right operands are of the same struct type, and the struct
    type has a <a href="../spec/struct.html#Postblit"><i>Postblit</i></a>, then the copy operation is
    as described in <a href="../spec/struct.html#struct-postblit">Struct Postblit</a>.
    </p>
<div class="blankline"></div>
    <p>If the lvalue is the <span class="d_inlinecode donthyphenate notranslate">.length</span> property of a dynamic array, the behavior is
    as described in <a href="../spec/array.html#resize">Setting Dynamic Array Length</a>.
    </p>
<div class="blankline"></div>
    <p>If the lvalue is a static array or a slice, the behavior is as
    described in <a href="../spec/array.html#array-copying">Array Copying</a> and
    <a href="../spec/array.html#array-setting">Array Setting</a>.
    </p>
<div class="blankline"></div>
    <p>If the lvalue is a user-defined property, the behavior is as
    described in <a href="../spec/function.html#property-functions">Property Functions</a>.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="assignment_operator_expressions" href="#assignment_operator_expressions">Assignment Operator Expressions</a></h3>
<div class="blankline"></div>
    <p>For arguments of built-in types, assignment operator expressions such as</p>
<div class="blankline"></div>
<pre class="d_code notranslate">a op= b
</pre>
<div class="blankline"></div>
        are semantically equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate">a = <span class="d_keyword">cast</span>(<span class="d_keyword">typeof</span>(a))(a op b)
</pre>
<div class="blankline"></div>
    except that
<div class="blankline"></div>
    <ul>        <li>operand <span class="d_inlinecode donthyphenate notranslate">a</span> is only evaluated once,</li>
        <li>overloading <i>op</i> uses a different function than overloading <i>op</i>= does, and</li>
        <li>the left operand of <span class="d_inlinecode donthyphenate notranslate">&gt;&gt;&gt;=</span> does not undergo <a href="../spec/type.html#integer-promotions">Integer Promotions</a> before shifting.</li>
    </ul>
<div class="blankline"></div>
    <p>For user-defined types, assignment operator expressions are overloaded separately from
        the binary operator. Still the left operand must be an lvalue.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="conditional_expressions" href="#conditional_expressions">Conditional Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ConditionalExpression"><span class="gname">ConditionalExpression</span></a>:
    <a href="#OrOrExpression"><i>OrOrExpression</i></a>
    <a href="#OrOrExpression"><i>OrOrExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">?</span> <a href="#Expression"><i>Expression</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>ConditionalExpression</i>
</pre>
<div class="blankline"></div>
    <p>The first expression is converted to <span class="d_inlinecode donthyphenate notranslate">bool</span>, and is evaluated.
    </p>
<div class="blankline"></div>
    <p>If it is <span class="d_inlinecode donthyphenate notranslate">true</span>, then the second expression is evaluated, and
        its result is the result of the conditional expression.
    </p>
<div class="blankline"></div>
    <p>If it is <span class="d_inlinecode donthyphenate notranslate">false</span>, then the third expression is evaluated, and
        its result is the result of the conditional expression.
    </p>
<div class="blankline"></div>
    <p>If either the second or third expressions are of type <span class="d_inlinecode donthyphenate notranslate">void</span>,
        then the resulting type is <span class="d_inlinecode donthyphenate notranslate">void</span>. Otherwise, the second and third
        expressions are implicitly converted to a common type which becomes
        the result type of the conditional expression.
    </p>
<div class="blankline"></div>
    <p><b>Note:</b>
        When a conditional expression is the left operand of
        an <a href="#assign_expressions">assign expression</a>,
        parentheses are required for disambiguation:
    </p>
<pre class="d_code notranslate"><span class="d_keyword">bool</span> test;
<span class="d_keyword">int</span> a, b, c;
...
test ? a = b : c = 2;   <span class="d_comment">// Deprecated
</span>(test ? a = b : c) = 2; <span class="d_comment">// Equivalent
</span></pre>
<div class="blankline"></div>
    <p>This makes the intent clearer, because the first statement can
        easily be misread as the following code:
    </p>
<pre class="d_code notranslate">test ? a = b : (c = 2);
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="oror_expressions" href="#oror_expressions">OrOr Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="OrOrExpression"><span class="gname">OrOrExpression</span></a>:
    <a href="#AndAndExpression"><i>AndAndExpression</i></a>
    <i>OrOrExpression</i> <span class="d_inlinecode donthyphenate notranslate">||</span> <a href="#AndAndExpression"><i>AndAndExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The result type of an <i>OrOrExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span>, unless the right operand
        has type <span class="d_inlinecode donthyphenate notranslate">void</span>, when the result is type <span class="d_inlinecode donthyphenate notranslate">void</span>.
    </p>
<div class="blankline"></div>
    <p>The <i>OrOrExpression</i> evaluates its left operand.
    </p>
<div class="blankline"></div>
    <p>If the left operand, converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>, evaluates to
        <span class="d_inlinecode donthyphenate notranslate">true</span>, then the right operand is not evaluated. If the result type of
        the <i>OrOrExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is <span class="d_inlinecode donthyphenate notranslate">true</span>.
    </p>
<div class="blankline"></div>
    <p>If the left operand is <span class="d_inlinecode donthyphenate notranslate">false</span>, then the right
        operand is evaluated.
        If the result type of
        the <i>OrOrExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is the right operand converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="andand_expressions" href="#andand_expressions">AndAnd Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AndAndExpression"><span class="gname">AndAndExpression</span></a>:
    <a href="#OrExpression"><i>OrExpression</i></a>
    <i>AndAndExpression</i> <span class="d_inlinecode donthyphenate notranslate">&amp;</span><span class="d_inlinecode donthyphenate notranslate">&amp;</span> <a href="#OrExpression"><i>OrExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The result type of an <i>AndAndExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span>, unless the right operand
        has type <span class="d_inlinecode donthyphenate notranslate">void</span>, when the result is type <span class="d_inlinecode donthyphenate notranslate">void</span>.
    </p>
<div class="blankline"></div>
    <p>The <i>AndAndExpression</i> evaluates its left operand.
    </p>
<div class="blankline"></div>
    <p>If the left operand, converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>, evaluates to
        <span class="d_inlinecode donthyphenate notranslate">false</span>, then the right operand is not evaluated. If the result type of
        the <i>AndAndExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is <span class="d_inlinecode donthyphenate notranslate">false</span>.
    </p>
<div class="blankline"></div>
    <p>If the left operand is <span class="d_inlinecode donthyphenate notranslate">true</span>, then the right
        operand is evaluated.
        If the result type of
        the <i>AndAndExpression</i> is <span class="d_inlinecode donthyphenate notranslate">bool</span> then the result of the
        expression is the right operand converted to type <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="bitwise_expressions" href="#bitwise_expressions">Bitwise Expressions</a></h2>
<div class="blankline"></div>
    <p>Bit wise expressions perform a bitwise operation on their operands.
        Their operands must be integral types.
        First, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are done. Then, the bitwise
        operation is done.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="or_expressions" href="#or_expressions">Or Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="OrExpression"><span class="gname">OrExpression</span></a>:
    <a href="#XorExpression"><i>XorExpression</i></a>
    <i>OrExpression</i> <span class="d_inlinecode donthyphenate notranslate">|</span> <a href="#XorExpression"><i>XorExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands are OR'd together.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="xor_expressions" href="#xor_expressions">Xor Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="XorExpression"><span class="gname">XorExpression</span></a>:
    <a href="#AndExpression"><i>AndExpression</i></a>
    <i>XorExpression</i> <span class="d_inlinecode donthyphenate notranslate">^</span> <a href="#AndExpression"><i>AndExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands are XOR'd together.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="and_expressions" href="#and_expressions">And Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AndExpression"><span class="gname">AndExpression</span></a>:
    <a href="#CmpExpression"><i>CmpExpression</i></a>
    <i>AndExpression</i> <span class="d_inlinecode donthyphenate notranslate">&amp;</span> <a href="#CmpExpression"><i>CmpExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands are AND'd together.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="compare_expressions" href="#compare_expressions">Compare Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CmpExpression"><span class="gname">CmpExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#EqualExpression"><i>EqualExpression</i></a>
    <a href="#IdentityExpression"><i>IdentityExpression</i></a>
    <a href="#RelExpression"><i>RelExpression</i></a>
    <a href="#InExpression"><i>InExpression</i></a>
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="equality_expressions" href="#equality_expressions">Equality Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="EqualExpression"><span class="gname">EqualExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">!=</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>Equality expressions compare the two operands for equality (<span class="d_inlinecode donthyphenate notranslate">==</span>)
        or inequality (<span class="d_inlinecode donthyphenate notranslate">!=</span>).
        The type of the result is <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
    <p>Inequality is defined as the logical negation of equality.</p>
<div class="blankline"></div>
    <p>If the operands are integral values, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are applied
        to bring them to a common type before comparison. Equality is defined as the bit patterns
        of the common type match exactly.
    </p>
<div class="blankline"></div>
    <p>If the operands are pointers, equality is defined as the bit patterns of the operands
        match exactly.
    </p>
<div class="blankline"></div>
    <p>For float, double, and real values, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are applied
        to bring them to a common type before comparison.
        The values <span class="d_inlinecode donthyphenate notranslate">-0</span> and <span class="d_inlinecode donthyphenate notranslate">+0</span> are considered equal.
        If either or both operands are NAN, then <span class="d_inlinecode donthyphenate notranslate">==</span> returns false and <span class="d_inlinecode donthyphenate notranslate">!=</span> returns <span class="d_inlinecode donthyphenate notranslate">true</span>.
        Otherwise, the bit patterns of the common type are compared for equality.
    </p>
<div class="blankline"></div>
    <p>For complex numbers, equality is defined as equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate">x.re == y.re &amp;&amp; x.im == y.im
</pre>
    </p>
<div class="blankline"></div>
    <p>For struct objects, equality means the result of the
        <a href="https://dlang.org/spec/operatoroverloading.html#equals"><span class="d_inlinecode donthyphenate notranslate">opEquals()</span> member function</a>.
        If an <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> is not provided, equality is defined as
        the logical product of all equality
        results of the corresponding object fields.
<div class="blankline"></div>
        <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b> The contents of any alignment gaps in the struct object.</div>


<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b> If there are overlapping fields, which happens with unions, the default
        equality will compare each of the overlapping fields.
        An <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> can account for which of the overlapping fields contains valid data.
        An <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> can override the default behavior of floating point NaN values
        always comparing as unequal.
        Be careful using <span class="d_inlinecode donthyphenate notranslate">memcmp()</span> to implement <span class="d_inlinecode donthyphenate notranslate">opEquals()</span> if:
        <ul>        <li>there are any alignment gaps</li>
        <li>if any fields have an <span class="d_inlinecode donthyphenate notranslate">opEquals()</span></li>
        <li>there are any floating point fields that may contain NaN or <span class="d_inlinecode donthyphenate notranslate">-0</span> values</li>
        </ul>
        </div>


    </p>
<div class="blankline"></div>
    <p>For class and struct objects, the expression <span class="d_inlinecode donthyphenate notranslate">(a == b)</span>
        is rewritten as
        <span class="d_inlinecode donthyphenate notranslate">a.opEquals(b)</span>, and <span class="d_inlinecode donthyphenate notranslate">(a != b)</span> is rewritten as
        <span class="d_inlinecode donthyphenate notranslate">!a.opEquals(b)</span>.
    </p>
<div class="blankline"></div>
    <p>For class objects, the <span class="d_inlinecode donthyphenate notranslate">==</span> and <span class="d_inlinecode donthyphenate notranslate">!=</span>
        operators are intended to compare the contents of the objects,
        however an appropriate <span class="d_inlinecode donthyphenate notranslate">opEquals</span> override must be defined for this to work.
        The default <span class="d_inlinecode donthyphenate notranslate">opEquals</span> provided by the root <span class="d_inlinecode donthyphenate notranslate">Object</span> class is
        equivalent to the <span class="d_inlinecode donthyphenate notranslate">is</span> operator.
        Comparing against <span class="d_inlinecode donthyphenate notranslate">null</span> is invalid, as <span class="d_inlinecode donthyphenate notranslate">null</span> has no contents.
        Use the <span class="d_inlinecode donthyphenate notranslate">is</span> and <span class="d_inlinecode donthyphenate notranslate">!is</span> operators instead.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C;
C c;
<span class="d_keyword">if</span> (c == <span class="d_keyword">null</span>)  <span class="d_comment">// error
</span>    ...
<span class="d_keyword">if</span> (c <span class="d_keyword">is</span> <span class="d_keyword">null</span>)  <span class="d_comment">// ok
</span>    ...
</pre>
<div class="blankline"></div>
    <p>For static and dynamic arrays, equality is defined as the
        lengths of the arrays
        matching, and all the elements are equal.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="identity_expressions" href="#identity_expressions">Identity Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="IdentityExpression"><span class="gname">IdentityExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">is</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">!is</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">is</span> compares for identity.
        To compare for nonidentity, use <span class="d_inlinecode donthyphenate notranslate">e1 !is e2</span>.
        The type of the result is <span class="d_inlinecode donthyphenate notranslate">bool</span>. The operands
        undergo the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> to bring them to a common type before
        comparison.
    </p>
<div class="blankline"></div>
    <p>For class objects, identity is defined as the object references
        are for the same object. Null class objects can be compared with
        <span class="d_inlinecode donthyphenate notranslate">is</span>.
    </p>
<div class="blankline"></div>
    <p>For struct objects and floating point values, identity is defined as the
        bits in the operands being identical.
    </p>
<div class="blankline"></div>
    <p>For static and dynamic arrays, identity is defined as referring
        to the same array elements and the same number of elements.
    </p>
<div class="blankline"></div>
    <p>For other operand types, identity is defined as being the same
        as equality.
    </p>
<div class="blankline"></div>
    <p>The identity operator <span class="d_inlinecode donthyphenate notranslate">is</span> cannot be overloaded.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="relation_expressions" href="#relation_expressions">Relational Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="RelExpression"><span class="gname">RelExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&lt;</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">&gt;=</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>First, the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are done on the operands.
        The result type of a relational expression is <span class="d_inlinecode donthyphenate notranslate">bool</span>.
    </p>
<div class="blankline"></div>
    <p>For class objects, the result of Object.opCmp() forms the left
        operand, and 0 forms the right operand. The result of the
        relational expression (o1 op o2) is:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">(o1.opCmp(o2) op 0)
</pre>
<div class="blankline"></div>
    <p>It is an error to compare objects if one is <span class="d_inlinecode donthyphenate notranslate">null</span>.</p>
<div class="blankline"></div>
    <p>For static and dynamic arrays, the result of the relational
        op is the result of the operator applied to the first non-equal
        element of the array. If two arrays compare equal, but are of
        different lengths, the shorter array compares as "less" than the
        longer array.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="integer_comparisons" href="#integer_comparisons">Integer comparisons</a></h3>
<div class="blankline"></div>
    <p>Integer comparisons happen when both operands are integral
        types.
    </p>
<div class="blankline"></div>
    <center><table><caption>Integer comparison operators</caption>        <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Relation</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span></td><td>less</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;</span></td><td>greater</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td>less or equal</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;=</span></td><td>greater or equal</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">==</span></td><td>equal</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">!=</span></td><td>not equal</td></tr>
    </table></center>
<div class="blankline"></div>
    <p>It is an error to have one operand be signed and the other
        unsigned for a <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span> or
        <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">=</span> expression.
        Use casts to make both operands signed or both operands unsigned.
    </p>
<div class="blankline"></div>
<h3><span id="floating_point_comparisons"><a class="anchor" title="Permalink to this section" id="floating-point-comparisons" href="#floating-point-comparisons">Floating point comparisons</a></span></h3>
<div class="blankline"></div>
    <p>If one or both operands are floating point, then a floating
        point comparison is performed.
    </p>
<div class="blankline"></div>
    <p>A relational operator can have <span class="d_inlinecode donthyphenate notranslate">NaN</span> operands.
        If either or both operands is <span class="d_inlinecode donthyphenate notranslate">NaN</span>, the floating point
        comparison operation returns as follows:</p>
<div class="blankline"></div>
        <center><table><caption>Floating point comparison operators</caption>        <tr><th class="donthyphenate"><b>Operator</b></th><th class="donthyphenate"><b>Relation</b></th><th class="donthyphenate"><b>Returns</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span></td><td>less</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;</span></td><td>greater</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td>less or equal</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">&gt;=</span></td><td>greater or equal</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">==</span></td><td>equal</td><td><span class="d_inlinecode donthyphenate notranslate">false</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">!=</span></td><td>unordered, less, or greater</td><td><span class="d_inlinecode donthyphenate notranslate">true</span></td></tr>
        </table></center>
<div class="blankline"></div>
<h3><span id="class_comparisons"><a class="anchor" title="Permalink to this section" id="class-comparisons" href="#class-comparisons">Class comparisons</a></span></h3>
<div class="blankline"></div>
    <p>For class objects, the relational
        operators compare the
        contents of the objects. Therefore, comparing against
        <span class="d_inlinecode donthyphenate notranslate">null</span> is invalid, as <span class="d_inlinecode donthyphenate notranslate">null</span> has no contents.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C;
C c;
<span class="d_keyword">if</span> (c &lt; <span class="d_keyword">null</span>)  <span class="d_comment">// error
</span>    ...
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="in_expressions" href="#in_expressions">In Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="InExpression"><span class="gname">InExpression</span></a>:
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">in</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
    <a href="#ShiftExpression"><i>ShiftExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">!in</span> <a href="#ShiftExpression"><i>ShiftExpression</i></a>
</pre>
<div class="blankline"></div>
<p>An associative array can be tested to see if an element is in the array:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo[string];
...
<span class="d_keyword">if</span> (<span class="d_string">"hello"</span> <span class="d_keyword">in</span> foo)
    ...
</pre>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">in</span> expression has the same precedence as the
        relational expressions <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>,
        etc.
        The return value of the <i>InExpression</i> is <span class="d_inlinecode donthyphenate notranslate">null</span>
        if the element is not in the array;
        if it is in the array it is a pointer to the element.
    </p>
<div class="blankline"></div>
    <p>The <span class="d_inlinecode donthyphenate notranslate">!in</span> expression is the logical negation of the <span class="d_inlinecode donthyphenate notranslate">in</span>
        operation.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="shift_expressions" href="#shift_expressions">Shift Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ShiftExpression"><span class="gname">ShiftExpression</span></a>:
    <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">&lt;</span> <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span> <a href="#AddExpression"><i>AddExpression</i></a>
    <i>ShiftExpression</i> <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span> <a href="#AddExpression"><i>AddExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands must be integral types, and undergo the <a href="../spec/type.html#integer-promotions">Integer Promotions</a>.
        The result type is the type of the left operand after
        the promotions. The result value is the result of shifting the bits
        by the right operand's value.
    </p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">&lt;</span> is a left shift.
        <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span> is a signed right shift.
        <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span> is an unsigned right shift.
    </p>
<div class="blankline"></div>
    <p>It's illegal to shift by the same or more bits than the size of the
        quantity being shifted:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> c;
<span class="d_keyword">auto</span> x = c &lt;&lt; 33;        <span class="d_comment">// error
</span></pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="add_expressions" href="#add_expressions">Add Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AddExpression"><span class="gname">AddExpression</span></a>:
    <a href="#MulExpression"><i>MulExpression</i></a>
    <i>AddExpression</i> <span class="d_inlinecode donthyphenate notranslate">+</span> <a href="#MulExpression"><i>MulExpression</i></a>
    <i>AddExpression</i> <span class="d_inlinecode donthyphenate notranslate">-</span> <a href="#MulExpression"><i>MulExpression</i></a>
    <a href="#CatExpression"><i>CatExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>If the operands are of integral types, they undergo the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>,
        and then are brought to a common type using the
        <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>.
    </p>
<div class="blankline"></div>
    <p>If either operand is a floating point type, the other is implicitly
        converted to floating point and they are brought to a common type
        via the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>.
    </p>
<div class="blankline"></div>
    <p>If the operator is <span class="d_inlinecode donthyphenate notranslate">+</span> or <span class="d_inlinecode donthyphenate notranslate">-</span>, and
        the first operand is a pointer, and the second is an integral type,
        the resulting type is the type of the first operand, and the resulting
        value is the pointer plus (or minus) the second operand multiplied by
        the size of the type pointed to by the first operand.
    </p>
<div class="blankline"></div>
    <p>If the second operand is a pointer, and the first is an integral type,
        and the operator is <span class="d_inlinecode donthyphenate notranslate">+</span>,
        the operands are reversed and the pointer arithmetic just described
        is applied.
    </p>
<div class="blankline"></div>
    <p>If both operands are pointers, and the operator is <span class="d_inlinecode donthyphenate notranslate">+</span>,
        then it is illegal.
    </p>
<div class="blankline"></div>
    <p>If both operands are pointers, and the operator is <span class="d_inlinecode donthyphenate notranslate">-</span>,
        the pointers are subtracted and the
        result is divided by the size of the type pointed to by the
        operands. In this calculation the assumed size of <span class="d_inlinecode donthyphenate notranslate">void</span> is one byte.
        It is an error if the pointers point to different types.
        The type of the result is <span class="d_inlinecode donthyphenate notranslate">ptrdiff_t</span>.
    </p>
<div class="blankline"></div>
    <p>If both operands are of integral types and an overflow or underflow
        occurs in the computation, wrapping will happen. For example,
        <span class="d_inlinecode donthyphenate notranslate">uint.max + 1 == uint.min</span>, <span class="d_inlinecode donthyphenate notranslate">uint.min - 1 == uint.max</span>,
        <span class="d_inlinecode donthyphenate notranslate">int.max + 1 == int.min</span>, and <span class="d_inlinecode donthyphenate notranslate">int.min - 1 == int.max</span>.
    </p>
<div class="blankline"></div>
    <p>Add expressions for floating point operands are not associative.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="cat_expressions" href="#cat_expressions">Cat Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CatExpression"><span class="gname">CatExpression</span></a>:
    <a href="#AddExpression"><i>AddExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">~</span> <a href="#MulExpression"><i>MulExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>A <i>CatExpression</i> concatenates arrays, producing
        a dynamic array with the result. The arrays must be
        arrays of the same element type. If one operand is an array
        and the other is of that array's element type, that element
        is converted to an array of length 1 of that element,
        and then the concatenation is performed.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="mul_expressions" href="#mul_expressions">Mul Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="MulExpression"><span class="gname">MulExpression</span></a>:
    <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="d_inlinecode donthyphenate notranslate">*</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="d_inlinecode donthyphenate notranslate">/</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <i>MulExpression</i> <span class="d_inlinecode donthyphenate notranslate">%</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>The operands must be arithmetic types.
        They undergo the <a href="../spec/type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>.
    </p>
<div class="blankline"></div>
    <p>For integral operands, the <span class="d_inlinecode donthyphenate notranslate">*</span>, <span class="d_inlinecode donthyphenate notranslate">/</span>, and <span class="d_inlinecode donthyphenate notranslate">%</span>
        correspond to multiply, divide, and modulus operations.
        For multiply, overflows are ignored and simply chopped to fit
        into the integral type.
    </p>
<div class="blankline"></div>
    <p>For integral operands of the <span class="d_inlinecode donthyphenate notranslate">/</span> and <span class="d_inlinecode donthyphenate notranslate">%</span> operators,
        the quotient rounds towards zero and the remainder has the
        same sign as the dividend.
    </p>
<div class="blankline"></div>
    <p>The following divide or modulus integral operands:</p>
<div class="blankline"></div>
    <ul>    <li>denominator is 0</li>
    <li>signed <span class="d_inlinecode donthyphenate notranslate">int.min</span> is the numerator and <span class="d_inlinecode donthyphenate notranslate">-1</span> is the denominator</li>
    <li>signed <span class="d_inlinecode donthyphenate notranslate">long.min</span> is the numerator and <span class="d_inlinecode donthyphenate notranslate">-1L</span> is the denominator</li>
    </ul>
<div class="blankline"></div>
    <p>are illegal if encountered during Compile Time Execution.</p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b> is exhibited if they are encountered during run time.
        <a href="https://dlang.org/phobos/core_checkedint.html"><span class="d_inlinecode donthyphenate notranslate">core.checkedint</span></a>
        can be used to check for them and select a defined behavior.
    </div>


<div class="blankline"></div>
    <p>For floating point operands, the * and / operations correspond
        to the IEEE 754 floating point equivalents. % is not the same as
        the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas
        for IEEE 754, remainder(15.0,10.0) == -5.0.
    </p>
<div class="blankline"></div>
    <p>Mul expressions for floating point operands are not associative.
    </p>
<div class="blankline"></div>
<h2><span id="UnaryExpression"><a class="anchor" title="Permalink to this section" id="unary-expression" href="#unary-expression">Unary Expressions</a></span></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="UnaryExpression"><span class="gname">UnaryExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">&amp;</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">++</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">--</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">*</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">-</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">+</span> <i>UnaryExpression</i>
    <span class="d_inlinecode donthyphenate notranslate">!</span> <i>UnaryExpression</i>
    <a href="#ComplementExpression"><i>ComplementExpression</i></a>
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">) .</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">) .</span> <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <a href="#DeleteExpression"><i>DeleteExpression</i></a>
    <a href="#CastExpression"><i>CastExpression</i></a>
    <a href="#PowExpression"><i>PowExpression</i></a>
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="complement_expressions" href="#complement_expressions">Complement Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ComplementExpression"><span class="gname">ComplementExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">~</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p><i>ComplementExpression</i>s work on integral types (except <span class="d_inlinecode donthyphenate notranslate">bool</span>).
        All the bits in the value are complemented.
    </p>
<div class="blankline"></div>
    <p><b>Note:</b> the usual <a href="../spec/type.html#integer-promotions">Integer Promotions</a> are not performed
        prior to the complement operation.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="new_expressions" href="#new_expressions">New Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="NewExpression"><span class="gname">NewExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">new</span> <i>AllocatorArguments</i><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a>
    <a href="#NewExpressionWithArgs"><i>NewExpressionWithArgs</i></a>
<div class="blankline"></div>
<a id="NewExpressionWithArgs"><span class="gname">NewExpressionWithArgs</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">new</span> <i>AllocatorArguments</i><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">]</span>
    <span class="d_inlinecode donthyphenate notranslate">new</span> <i>AllocatorArguments</i><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/class.html#NewAnonClassExpression"><i>NewAnonClassExpression</i></a>
<div class="blankline"></div>
<a id="AllocatorArguments"><span class="gname">AllocatorArguments</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<a id="ArgumentList"><span class="gname">ArgumentList</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>ArgumentList</i>
</pre>
<div class="blankline"></div>
    <p><i>NewExpression</i>s are used to allocate memory on the garbage
        collected heap (default) or using a class or struct specific allocator.
    </p>
<div class="blankline"></div>
    <p>To allocate multidimensional arrays, the declaration reads
        in the same order as the prefix array declaration order.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">char</span>[][] foo;   <span class="d_comment">// dynamic array of strings
</span>...
foo = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[][30]; <span class="d_comment">// allocate array of 30 strings
</span></pre>
<div class="blankline"></div>
    <p>The above allocation can also be written as:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">foo = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[][](30); <span class="d_comment">// allocate array of 30 strings
</span></pre>
<div class="blankline"></div>
    <p>To allocate the nested arrays, multiple arguments can be used:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[][][] bar;
...
bar = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][][](5, 20, 30);
</pre>
<div class="blankline"></div>
    The code above is equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate">bar = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][][5];
<span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> a; bar)
{
    a = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][20];
    <span class="d_keyword">foreach</span> (<span class="d_keyword">ref</span> b; a)
    {
        b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[30];
    }
}
</pre>
<div class="blankline"></div>
    <p>If there is a <span class="d_inlinecode donthyphenate notranslate">new (</span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>,
        then
        those arguments are passed to the class or struct specific
        <a href="../spec/class.html#allocators">allocator function</a> after the size argument.
    </p>
<div class="blankline"></div>
    <p>If a <i>NewExpression</i> is used as an initializer for
        a function local variable with <span class="d_inlinecode donthyphenate notranslate">scope</span> storage class,
        and the <a href="#ArgumentList"><i>ArgumentList</i></a> to <span class="d_inlinecode donthyphenate notranslate">new</span> is empty, then
        the instance is allocated on the stack rather than the heap
        or using the class specific allocator.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="delete_expressions" href="#delete_expressions">Delete Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="DeleteExpression"><span class="gname">DeleteExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">delete</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
    <p>NOTE: <span class="d_inlinecode donthyphenate notranslate">delete</span> has been deprecated.  Instead, please use <a href="../phobos/object.html#.destroy""><span class="d_inlinecode donthyphenate notranslate">destroy</span></a>
    if feasible, or <a href="../phobos/core_memory.html#.__delete"><span class="d_inlinecode donthyphenate notranslate">core.memory.__delete</span></a> as a last resort.</p>
<div class="blankline"></div>
    <p>If the <i>UnaryExpression</i> is a class object reference, and
        there is a destructor for that class, the destructor
        is called for that object instance.
    </p>
<div class="blankline"></div>
    <p>Next, if the <i>UnaryExpression</i> is a class object reference, or
        a pointer to a struct instance, and the class or struct
        has overloaded operator delete, then that operator delete is called
        for that class object instance or struct instance.
    </p>
<div class="blankline"></div>
    <p>Otherwise, the garbage collector is called to immediately free the
        memory allocated for the class instance or struct instance.
    </p>
<div class="blankline"></div>
    <p>If the <i>UnaryExpression</i> is a pointer or a dynamic array,
        the garbage collector is called to immediately release the
        memory.
    </p>
<div class="blankline"></div>
    <p>The pointer, dynamic array, or reference is set to <span class="d_inlinecode donthyphenate notranslate">null</span>
        after the delete is performed.
        Any attempt to reference the data after the deletion via another
        reference to it will result in undefined behavior.
    </p>
<div class="blankline"></div>
    <p>If <i>UnaryExpression</i> is a variable allocated
        on the stack, the class destructor (if any) is called for that
        instance. Neither the garbage collector nor any class deallocator
        is called.
    </p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b>     <ol>    <li>Using <span class="d_inlinecode donthyphenate notranslate">delete</span> to free memory not allocated by the garbage collector.</li>
    <li>Referring to data that has been the operand of <span class="d_inlinecode donthyphenate notranslate">delete</span>.</li>
    </ol></div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="cast_expressions" href="#cast_expressions">Cast Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="CastExpression"><span class="gname">CastExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">cast (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
    <span class="d_inlinecode donthyphenate notranslate">cast (</span> <a href="../spec/declaration.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>A <i>CastExpression</i> converts the <i>UnaryExpression</i>
        to <a href="../spec/declaration.html#Type"><i>Type</i></a>.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">cast</span>(foo) -p; <span class="d_comment">// cast (-p) to type foo
</span>(foo) - p;      <span class="d_comment">// subtract p from foo
</span></pre>
<div class="blankline"></div>
    <p>Any casting of a class reference to a
        derived class reference is done with a runtime check to make sure it
        really is a downcast. <span class="d_inlinecode donthyphenate notranslate">null</span> is the result if it isn't.
    </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A { ... }
<span class="d_keyword">class</span> B : A { ... }

<span class="d_keyword">void</span> test(A a, B b)
{
    B bx = a;         <span class="d_comment">// error, need cast
</span>    B bx = <span class="d_keyword">cast</span>(B) a; <span class="d_comment">// bx is null if a is not a B
</span>    A ax = b;         <span class="d_comment">// no cast needed
</span>    A ax = <span class="d_keyword">cast</span>(A) b; <span class="d_comment">// no runtime check needed for upcast
</span>}
</pre>
<div class="blankline"></div>
    <p>In order to determine if an object <span class="d_inlinecode donthyphenate notranslate">o</span> is an instance of
        a class <span class="d_inlinecode donthyphenate notranslate">B</span> use a cast:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">if</span> (<span class="d_keyword">cast</span>(B) o)
{
    <span class="d_comment">// o is an instance of B
</span>}
<span class="d_keyword">else</span>
{
    <span class="d_comment">// o is not an instance of B
</span>}
</pre>
<div class="blankline"></div>
    <p>Casting a pointer type to and from a class type is done as a type paint
        (i.e. a reinterpret cast).
    </p>
<div class="blankline"></div>
    <p>Casting a dynamic array to another dynamic array is done only if the
        array lengths multiplied by the element sizes match. The cast is done
        as a type paint, with the array length adjusted to match any change in
        element size. If there's not a match, a runtime error is generated.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">int</span> main()
{
    <span class="d_keyword">byte</span>[] a = [1,2,3];
    <span class="d_keyword">auto</span> b = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[])a; <span class="d_comment">// runtime array cast misalignment
</span>
    <span class="d_keyword">int</span>[] c = [1, 2, 3];
    <span class="d_keyword">auto</span> d = <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>[])c; <span class="d_comment">// ok
</span>    <span class="d_comment">// prints:
</span>    <span class="d_comment">// [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]
</span>    writeln(d);
    <span class="d_keyword">return</span> 0;
}
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
    <p>Casting a static array to another static array is done only if the
        array lengths multiplied by the element sizes match; a mismatch
        is illegal.
        The cast is done as a type paint (aka a reinterpret cast).
        The contents of the array are not changed.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> core.stdc.stdio;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">byte</span>[16] b = 3;
    <span class="d_keyword">int</span>[4] ia = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[4]) b;
    <span class="d_keyword">foreach</span> (i; ia)
        printf(<span class="d_string">"%x\n"</span>, i);
    <span class="d_comment">/* prints:
       3030303
       3030303
       3030303
       3030303
     */</span>
}
</pre>
<div class="blankline"></div>
    <p>Casting a floating point literal from one type to another
        changes its type, but internally it is retained at full
        precision for the purposes of constant folding.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">real</span> a = 3.40483L;
    <span class="d_keyword">real</span> b;
    b = 3.40483;     <span class="d_comment">// literal is not truncated to double precision
</span>    <span class="d_keyword">assert</span>(a == b);
    <span class="d_keyword">assert</span>(a == 3.40483);
    <span class="d_keyword">assert</span>(a == 3.40483L);
    <span class="d_keyword">assert</span>(a == 3.40483F);
    <span class="d_keyword">double</span> d = 3.40483; <span class="d_comment">// truncate literal when assigned to variable
</span>    <span class="d_keyword">assert</span>(d != a);     <span class="d_comment">// so it is no longer the same
</span>    <span class="d_keyword">const</span> <span class="d_keyword">double</span> x = 3.40483; <span class="d_comment">// assignment to const is not
</span>    <span class="d_keyword">assert</span>(x == a);     <span class="d_comment">// truncated if the initializer is visible
</span>}
</pre>
<div class="blankline"></div>
    <p>Casting a floating point value to an integral type is the equivalent
        of converting to an integer using truncation.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span> a = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) 0.8f;
    <span class="d_keyword">assert</span>(a == 0);
    <span class="d_keyword">long</span> b = <span class="d_keyword">cast</span>(<span class="d_keyword">long</span>) 1.5;
    <span class="d_keyword">assert</span>(b == 1L);
    <span class="d_keyword">long</span> c = <span class="d_keyword">cast</span>(<span class="d_keyword">long</span>) -1.5;
    <span class="d_keyword">assert</span>(c == -1);
}
</pre>
<div class="blankline"></div>
    <p>Casting a value <i>v</i> to a struct <i>S</i>, when value is not a struct
        of the same type, is equivalent to:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">S(v)
</pre>
<div class="blankline"></div>
    <p>Casting to a <a href="#CastQual"><i>CastQual</i></a> replaces the qualifiers to the type of
        the <a href="#UnaryExpression"><i>UnaryExpression</i></a>.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">shared</span> <span class="d_keyword">int</span> x;
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span>)x) == <span class="d_keyword">const</span> <span class="d_keyword">int</span>));
</pre>
<div class="blankline"></div>
    <p>Casting with no <a href="#Type"><i>Type</i></a> or <a href="#CastQual"><i>CastQual</i></a> removes
        any top level <span class="d_inlinecode donthyphenate notranslate">const</span>, <span class="d_inlinecode donthyphenate notranslate">immutable</span>, <span class="d_inlinecode donthyphenate notranslate">shared</span> or <span class="d_inlinecode donthyphenate notranslate">inout</span>
        type modifiers from the type
        of the <a href="#UnaryExpression"><i>UnaryExpression</i></a>.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">shared</span> <span class="d_keyword">int</span> x;
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(<span class="d_keyword">cast</span>()x) == <span class="d_keyword">int</span>));
</pre>
<div class="blankline"></div>
    <p>Casting an expression to <span class="d_inlinecode donthyphenate notranslate">void</span> type is allowed to mark that
        the result is unused. On <a href="../spec/statement.html#ExpressionStatement"><i>ExpressionStatement</i></a>,
        it could be used properly to avoid "has no effect" error.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">lazy</span> <span class="d_keyword">void</span> exp) {}
<span class="d_keyword">void</span> main()
{
    foo(10);            <span class="d_comment">// NG - has no effect in expression '10'
</span>    foo(<span class="d_keyword">cast</span>(<span class="d_keyword">void</span>)10);  <span class="d_comment">// OK
</span>}
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="pow_expressions" href="#pow_expressions">Pow Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="PowExpression"><span class="gname">PowExpression</span></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a>
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">^^</span> <a href="#UnaryExpression"><i>UnaryExpression</i></a>
</pre>
<div class="blankline"></div>
    <p><i>PowExpression</i> raises its left operand to the power of its
        right operand.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="postfix_expressions" href="#postfix_expressions">Postfix Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="PostfixExpression"><span class="gname">PostfixExpression</span></a>:
    <a href="#PrimaryExpression"><i>PrimaryExpression</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="#NewExpression"><i>NewExpression</i></a>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">++</span>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">--</span>
    <i>PostfixExpression</i> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/declaration.html#TypeCtors"><i>TypeCtors</i></a><sub>opt</sub> <a href="../spec/declaration.html#BasicType"><i>BasicType</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="#IndexExpression"><i>IndexExpression</i></a>
    <a href="#SliceExpression"><i>SliceExpression</i></a>
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="index_expressions" href="#index_expressions">Index Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="IndexExpression"><span class="gname">IndexExpression</span></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="d_inlinecode donthyphenate notranslate">]</span>
</pre>
<div class="blankline"></div>
<p><i>PostfixExpression</i> is evaluated. If <i>PostfixExpression</i> is an
expression of type static array or dynamic array, the symbol &dollar; is set to
be the number of elements in the array. If <i>PostfixExpression</i> is a <i>ValueSeq</i>, the symbol &dollar; is set to be the number of elements
in the sequence. A new declaration scope is created for the evaluation of the
<a href="#ArgumentList"><i>ArgumentList</i></a> and &dollar; appears in that scope only.</p>
<div class="blankline"></div>
    <p>If <i>PostfixExpression</i> is a <i>ValueSeq</i>,
        then the <a href="#ArgumentList"><i>ArgumentList</i></a> must consist of only one argument,
        and that must be statically evaluatable to an integral constant.
        That integral constant <i>n</i> then selects the <i>n</i>th
        expression in the <i>ValueSeq</i>, which is the result
        of the <i>IndexExpression</i>.
        It is an error if <i>n</i> is out of bounds of the <i>ValueSeq</i>.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="slice_expressions" href="#slice_expressions">Slice Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="SliceExpression"><span class="gname">SliceExpression</span></a>:
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">[ ]</span>
    <a href="#PostfixExpression"><i>PostfixExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">[</span> <i>Slice</i> <span class="d_inlinecode donthyphenate notranslate">,</span><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">]</span>
<a id="Slice"><span class="gname">Slice</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>Slice</i>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">..</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">..</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>Slice</i>
</pre>
<div class="blankline"></div>
    <p><i>PostfixExpression</i> is evaluated.
        if <i>PostfixExpression</i> is an expression of type
        static array or dynamic array, the special variable &dollar;
        is declared and set to be the length of the array.
        A new declaration scope is created for the evaluation of the
        <a href="#AssignExpression"><i>AssignExpression</i></a>..<a href="#AssignExpression"><i>AssignExpression</i></a>
        and &dollar; appears in that scope only.
    </p>
<div class="blankline"></div>
    <p>The first <i>AssignExpression</i> is taken to be the inclusive
        lower bound
        of the slice, and the second <i>AssignExpression</i> is the
        exclusive upper bound.
        The result of the expression is a slice of the <i>PostfixExpression</i>
        array.
    </p>
<div class="blankline"></div>
    <p>If the <span class="d_inlinecode donthyphenate notranslate">[ ]</span> form is used, the slice is of the entire
        array.
    </p>
<div class="blankline"></div>
    <p>The type of the slice is a dynamic array of the element
        type of the <i>PostfixExpression</i>.
    </p>
<div class="blankline"></div>
    <p>A <i>SliceExpression</i> is not a modifiable lvalue.</p>
<div class="blankline"></div>
    <p>If the slice bounds can be known at compile time, the slice expression
    is implicitly convertible to an lvalue of static array. For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">arr[a .. b]     <span class="d_comment">// typed T[]
</span></pre>
<div class="blankline"></div>
        If both <span class="d_inlinecode donthyphenate notranslate">a</span> and <span class="d_inlinecode donthyphenate notranslate">b</span> are integers (may be constant-folded),
        the slice expression can be converted to a static array type
        <span class="d_inlinecode donthyphenate notranslate">T[b - a]</span>.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == [2, 3]);
}
<span class="d_keyword">void</span> bar(<span class="d_keyword">ref</span> <span class="d_keyword">int</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == [2, 3]);
    a[0] = 4;
    a[1] = 5;
    <span class="d_keyword">assert</span>(a == [4, 5]);
}
<span class="d_keyword">void</span> baz(<span class="d_keyword">int</span>[3] a) {}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[] arr = [1, 2, 3];

    foo(arr[1 .. 3]);
    <span class="d_keyword">assert</span>(arr == [1, 2, 3]);

    bar(arr[1 .. 3]);
    <span class="d_keyword">assert</span>(arr == [1, 4, 5]);

  <span class="d_comment">//baz(arr[1 .. 3]); // cannot match length
</span>}
</pre>
<div class="blankline"></div>
<p>The following forms of slice expression can be convertible to a static array
type:</p>
<div class="blankline"></div>
        <dl>        <dt><span class="d_inlinecode donthyphenate notranslate">e</span></dt> <dd>An expression that contains no side effects.</dd>
        <dt><span class="d_inlinecode donthyphenate notranslate">a</span>, <span class="d_inlinecode donthyphenate notranslate">b</span></dt> <dd>Integers (that may be constant-folded).</dd>
        </dl>
<div class="blankline"></div>
        <center><table><caption>Computing array lengths during compilation</caption>        <tr><th class="donthyphenate"><b>Form</b></th><th class="donthyphenate"><b>The length calculated at compile time</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">arr[]</span></td><td>The compile time length of <span class="d_inlinecode donthyphenate notranslate">arr</span> if it's known.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">arr[a .. b]</span></td><td>              <span class="d_inlinecode donthyphenate notranslate">b - a</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">arr[e-a .. e]</span></td><td>  <span class="d_inlinecode donthyphenate notranslate">a</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">arr[e .. e+b]</span></td><td>  <span class="d_inlinecode donthyphenate notranslate">b</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">arr[e-a .. e+b]</span></td><td><span class="d_inlinecode donthyphenate notranslate">a + b</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">arr[e+a .. e+b]</span></td><td><span class="d_inlinecode donthyphenate notranslate">b - a</span> <i>if</i> <span class="d_inlinecode donthyphenate notranslate">a &lt;= b</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">arr[e-a .. e-b]</span></td><td><span class="d_inlinecode donthyphenate notranslate">a - b</span> <i>if</i> <span class="d_inlinecode donthyphenate notranslate">a &gt;= b</span></td></tr>
        </table></center>
<div class="blankline"></div>
    <p>If <i>PostfixExpression</i> is a <i>ValueSeq</i>, then
        the result of the slice is a new <i>ValueSeq</i> formed
        from the upper and lower bounds, which must statically evaluate
        to integral constants.
        It is an error if those
        bounds are out of range.
    </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="primary_expressions" href="#primary_expressions">Primary Expressions</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="PrimaryExpression"><span class="gname">PrimaryExpression</span></a>:
    <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/template.html#TemplateInstance"><i>TemplateInstance</i></a>
    <a href="#this"><span class="d_inlinecode donthyphenate notranslate">this</span></a>
    <a href="#super"><span class="d_inlinecode donthyphenate notranslate">super</span></a>
    <a href="#null"><span class="d_inlinecode donthyphenate notranslate">null</span></a>
    <span class="d_inlinecode donthyphenate notranslate">true</span>
    <span class="d_inlinecode donthyphenate notranslate">false</span>
    <span class="d_inlinecode donthyphenate notranslate">$</span>
    <a href="../spec/lex.html#IntegerLiteral"><i>IntegerLiteral</i></a>
    <a href="../spec/lex.html#FloatLiteral"><i>FloatLiteral</i></a>
    <a href="#CharacterLiteral"><i>CharacterLiteral</i></a>
    <a href="#StringLiterals"><i>StringLiterals</i></a>
    <a href="#ArrayLiteral"><i>ArrayLiteral</i></a>
    <a href="#AssocArrayLiteral"><i>AssocArrayLiteral</i></a>
    <a href="#FunctionLiteral"><i>FunctionLiteral</i></a>
    <a href="#AssertExpression"><i>AssertExpression</i></a>
    <a href="#MixinExpression"><i>MixinExpression</i></a>
    <a href="#ImportExpression"><i>ImportExpression</i></a>
    <a href="#NewExpressionWithArgs"><i>NewExpressionWithArgs</i></a>
    <a href="../spec/declaration.html#FundamentalType"><i>FundamentalType</i></a> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <a href="../spec/declaration.html#FundamentalType"><i>FundamentalType</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/declaration.html#TypeCtor"><i>TypeCtor</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span> <span class="d_inlinecode donthyphenate notranslate">.</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a>
    <a href="../spec/declaration.html#TypeCtor"><i>TypeCtor</i></a> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span> <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="../spec/declaration.html#Typeof"><i>Typeof</i></a>
    <a href="#TypeidExpression"><i>TypeidExpression</i></a>
    <a href="#IsExpression"><i>IsExpression</i></a>
    <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="#Expression"><i>Expression</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <a href="#SpecialKeyword"><i>SpecialKeyword</i></a>
    <a href="../spec/traits.html#TraitsExpression"><i>TraitsExpression</i></a>
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="identifier" href="#identifier">.Identifier</a></h3>
<div class="blankline"></div>
    <p><a href="../spec/lex.html#Identifier"><i>Identifier</i></a> is looked up at module scope, rather than the current
        lexically nested scope.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="this" href="#this">this</a></h3>
<div class="blankline"></div>
    <p>Within a non-static member function, <span class="d_inlinecode donthyphenate notranslate">this</span> resolves to
        a reference to the object for which the function was called.
        If the object is an instance of a struct, <span class="d_inlinecode donthyphenate notranslate">this</span> will
        be a pointer to that instance.
        If a member function is called with an explicit reference
        to <span class="d_inlinecode donthyphenate notranslate">typeof(this)</span>, a non-virtual call is made:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'A'; }

    <span class="d_keyword">char</span> foo() { <span class="d_keyword">return</span> <span class="d_keyword">typeof</span>(<span class="d_keyword">this</span>).get(); }
    <span class="d_keyword">char</span> bar() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>.get(); }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'B'; }
}

<span class="d_keyword">void</span> main()
{
    B b = <span class="d_keyword">new</span> B();

    <span class="d_keyword">assert</span>(b.foo() == 'A');
    <span class="d_keyword">assert</span>(b.bar() == 'B');
}
</pre>
<div class="blankline"></div>
    <p>Assignment to <span class="d_inlinecode donthyphenate notranslate">this</span> is not allowed.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="super" href="#super">super</a></h3>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">super</span> is identical to <span class="d_inlinecode donthyphenate notranslate">this</span>, except that it is
        cast to <span class="d_inlinecode donthyphenate notranslate">this</span>'s base class.
        It is an error if there is no base class.
        It is an error to use <span class="d_inlinecode donthyphenate notranslate">super</span> within a struct member function.
        (Only class <span class="d_inlinecode donthyphenate notranslate">Object</span> has no base class.)
        If a member function is called with an explicit reference
        to <span class="d_inlinecode donthyphenate notranslate">super</span>, a non-virtual call is made.
    </p>
<div class="blankline"></div>
    <p>Assignment to <span class="d_inlinecode donthyphenate notranslate">super</span> is not allowed.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="null" href="#null">null</a></h3>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">null</span> represents the null value for
        pointers, pointers to functions, delegates,
        dynamic arrays, associative arrays,
        and class objects.
        If it has not already been cast to a type,
        it is given the singular type <span class="d_inlinecode donthyphenate notranslate">typeof(null)</span> and it is an exact conversion
        to convert it to the null value for pointers, pointers to
        functions, delegates, etc.
        After it is cast to a type, such conversions are implicit,
        but no longer exact.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="true_false" href="#true_false">true, false</a></h3>
<div class="blankline"></div>
    <p>These are of type <span class="d_inlinecode donthyphenate notranslate">bool</span> and when cast to another integral
        type become the values 1 and 0,
        respectively.
    </p>
<div class="blankline"></div>
<h3><span id="CharacterLiteral"><a class="anchor" title="Permalink to this section" id="character-literal" href="#character-literal">Character Literals</a></span></h3>
<div class="blankline"></div>
    <p>Character literals are single characters and resolve to one
        of type <span class="d_inlinecode donthyphenate notranslate">char</span>, <span class="d_inlinecode donthyphenate notranslate">wchar</span>, or <span class="d_inlinecode donthyphenate notranslate">dchar</span>.
        If the literal is a <span class="d_inlinecode donthyphenate notranslate">\u</span> escape sequence, it resolves to type <span class="d_inlinecode donthyphenate notranslate">wchar</span>.
        If the literal is a <span class="d_inlinecode donthyphenate notranslate">\U</span> escape sequence, it resolves to type <span class="d_inlinecode donthyphenate notranslate">dchar</span>.
        Otherwise, it resolves to the type with the smallest size it
        will fit into.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="string_literals" href="#string_literals">String Literals</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="StringLiterals"><span class="gname">StringLiterals</span></a>:
    <a href="../spec/lex.html#StringLiteral"><i>StringLiteral</i></a>
    <i>StringLiterals</i> <a href="../spec/lex.html#StringLiteral"><i>StringLiteral</i></a>
</pre>
<div class="blankline"></div>
    <p>String literals can implicitly convert to any
        of the following types, they have equal weight:
    </p>
<div class="blankline"></div>
    <table>        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(char)*</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(wchar)*</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(dchar)*</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(char)[]</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(wchar)[]</span></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">immutable(dchar)[]</span></td></tr>
    </table>
<div class="blankline"></div>
    <p>By default, a string literal is typed as a dynamic array, but the element
        count is known at compile time. So all string literals can be
        implicitly converted to static array types.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">char</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == <span class="d_string">"bc"</span>);
}
<span class="d_keyword">void</span> bar(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> <span class="d_keyword">char</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == <span class="d_string">"bc"</span>);
}
<span class="d_keyword">void</span> baz(<span class="d_keyword">const</span> <span class="d_keyword">char</span>[3] a) {}

<span class="d_keyword">void</span> main()
{
    string str = <span class="d_string">"abc"</span>;
    foo(str[1 .. 3]);
    bar(str[1 .. 3]);
  <span class="d_comment">//baz(str[1 .. 3]); // cannot match length
</span>}
</pre>
<div class="blankline"></div>
    <p>String literals have a 0 appended to them, which makes
        them easy to pass to C or C++ functions expecting a <span class="d_inlinecode donthyphenate notranslate">const char*</span>
        string.
        The 0 is not included in the <span class="d_inlinecode donthyphenate notranslate">.length</span> property of the
        string literal.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="array_literals" href="#array_literals">Array Literals</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ArrayLiteral"><span class="gname">ArrayLiteral</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#ArgumentList"><i>ArgumentList</i></a><sub>opt</sub> <span class="d_inlinecode donthyphenate notranslate">]</span>
</pre>
<div class="blankline"></div>
    <p>Array literals are a comma-separated list of <a href="#AssignExpression"><i>AssignExpression</i></a>s
        between square brackets <span class="d_inlinecode donthyphenate notranslate">[</span> and <span class="d_inlinecode donthyphenate notranslate">]</span>.
        The <i>AssignExpression</i>s form the elements of a dynamic array,
        the length of the array is the number of elements.
        The common type of the all elements is taken to be the type of
        the array element, and all elements are implicitly converted
        to that type.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a1 = [1,2,3];  <span class="d_comment">// type is int[], with elements 1, 2 and 3
</span><span class="d_keyword">auto</span> a2 = [1u,2,3]; <span class="d_comment">// type is uint[], with elements 1u, 2u, and 3u
</span></pre>
<div class="blankline"></div>
    <p>By default, an array literal is typed as a dynamic array, but the element
        count is known at compile time. So all array literals can be
        implicitly converted to static array types.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">long</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == [2, 3]);
}
<span class="d_keyword">void</span> bar(<span class="d_keyword">ref</span> <span class="d_keyword">long</span>[2] a)
{
    <span class="d_keyword">assert</span>(a == [2, 3]);
    a[0] = 4;
    a[1] = 5;
    <span class="d_keyword">assert</span>(a == [4, 5]);
}
<span class="d_keyword">void</span> baz(<span class="d_keyword">const</span> <span class="d_keyword">char</span>[3] a) {}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">long</span>[] arr = [1, 2, 3];

    foo(arr[1 .. 3]);
    <span class="d_keyword">assert</span>(arr == [1, 2, 3]);

    bar(arr[1 .. 3]);
    <span class="d_keyword">assert</span>(arr == [1, 4, 5]);

  <span class="d_comment">//baz(arr[1 .. 3]); // cannot match length
</span>}
</pre>
<div class="blankline"></div>
    <p>If any of the arguments in the <a href="#ArgumentList"><i>ArgumentList</i></a> are
        a <i>ValueSeq</i>, then the elements of the <i>ValueSeq</i>
        are inserted as arguments in place of the sequence.
    </p>
<div class="blankline"></div>
    <p>Array literals are allocated on the memory managed heap.
        Thus, they can be returned safely from functions:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] foo()
{
    <span class="d_keyword">return</span> [1, 2, 3];
}
</pre>
<div class="blankline"></div>
    <p>When array literals are cast to another array type, each
        element of the array is cast to the new element type.
        When arrays that are not literals are cast, the array is
        reinterpreted as the new type, and the length is recomputed:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    <span class="d_comment">// cast array literal
</span>    <span class="d_keyword">const</span> <span class="d_keyword">short</span>[] ct = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>[]) [<span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1, 1];
    <span class="d_comment">// this is equivalent with:
</span>    <span class="d_comment">// const short[] ct = [cast(short)1, cast(short)1];
</span>    writeln(ct);  <span class="d_comment">// writes [1, 1]
</span>
    <span class="d_comment">// cast other array expression
</span>    <span class="d_comment">// --&gt; normal behavior of CastExpression
</span>    <span class="d_keyword">byte</span>[] arr = [<span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1, <span class="d_keyword">cast</span>(<span class="d_keyword">byte</span>)1];
    <span class="d_keyword">short</span>[] rt = <span class="d_keyword">cast</span>(<span class="d_keyword">short</span>[]) arr;
    writeln(rt);  <span class="d_comment">// writes [257]
</span>}
</pre>
<div class="blankline"></div>
        In other words, casting literal expression will change the literal type.
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="associative_array_literals" href="#associative_array_literals">Associative Array Literals</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AssocArrayLiteral"><span class="gname">AssocArrayLiteral</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">[</span> <a href="#KeyValuePairs"><i>KeyValuePairs</i></a> <span class="d_inlinecode donthyphenate notranslate">]</span>
<div class="blankline"></div>
<a id="KeyValuePairs"><span class="gname">KeyValuePairs</span></a>:
    <a href="#KeyValuePair"><i>KeyValuePair</i></a>
    <a href="#KeyValuePair"><i>KeyValuePair</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <i>KeyValuePairs</i>
<div class="blankline"></div>
<a id="KeyValuePair"><span class="gname">KeyValuePair</span></a>:
    <a href="#KeyExpression"><i>KeyExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#ValueExpression"><i>ValueExpression</i></a>
<div class="blankline"></div>
<a id="KeyExpression"><span class="gname">KeyExpression</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
<div class="blankline"></div>
<a id="ValueExpression"><span class="gname">ValueExpression</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a>
</pre>
<div class="blankline"></div>
    <p>Associative array literals are a comma-separated list of
        <i>key</i><span class="d_inlinecode donthyphenate notranslate">:</span><i>value</i> pairs
        between square brackets <span class="d_inlinecode donthyphenate notranslate">[</span> and <span class="d_inlinecode donthyphenate notranslate">]</span>.
        The list cannot be empty.
        The common type of the all keys is taken to be the key type of
        the associative array, and all keys are implicitly converted
        to that type.
        The common type of the all values is taken to be the value type of
        the associative array, and all values are implicitly converted
        to that type.
        An <i>AssocArrayLiteral</i> cannot be used to statically initialize
        anything.</p>
<div class="blankline"></div>
<pre class="d_code notranslate">[21u:<span class="d_string">"he"</span>, 38:<span class="d_string">"ho"</span>, 2:<span class="d_string">"hi"</span>];  <span class="d_comment">// type is string[uint],
</span>                              <span class="d_comment">// with keys 21u, 38u and 2u
</span>                              <span class="d_comment">// and values "he", "ho", and "hi"
</span></pre>
<div class="blankline"></div>
    <p>If any of the keys or values in the <i>KeyValuePairs</i> are
        a <i>ValueSeq</i>, then the elements of the <i>ValueSeq</i>
        are inserted as arguments in place of the sequence.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="function_literals" href="#function_literals">Function Literals</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="FunctionLiteral"><span class="gname">FunctionLiteral</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">function</span> <span class="d_inlinecode donthyphenate notranslate">ref</span><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterWithAttributes"><i>ParameterWithAttributes</i></a> <sub>opt</sub> <a href="#FunctionLiteralBody"><i>FunctionLiteralBody</i></a>
    <span class="d_inlinecode donthyphenate notranslate">delegate</span> <span class="d_inlinecode donthyphenate notranslate">ref</span><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a> <sub>opt</sub> <a href="#FunctionLiteralBody"><i>FunctionLiteralBody</i></a>
    <span class="d_inlinecode donthyphenate notranslate">ref</span><sub>opt</sub> <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a> <a href="#FunctionLiteralBody"><i>FunctionLiteralBody</i></a>
    <a href="#FunctionLiteralBody"><i>FunctionLiteralBody</i></a>
    <a href="#Lambda"><i>Lambda</i></a>
<div class="blankline"></div>
<a id="ParameterWithAttributes"><span class="gname">ParameterWithAttributes</span></a>:
    <a href="../spec/function.html#Parameters"><i>Parameters</i></a> <a href="../spec/function.html#FunctionAttributes"><i>FunctionAttributes</i></a><sub>opt</sub>
<div class="blankline"></div>
<a id="ParameterWithMemberAttributes"><span class="gname">ParameterWithMemberAttributes</span></a>:
    <a href="../spec/function.html#Parameters"><i>Parameters</i></a> <a href="../spec/function.html#MemberFunctionAttributes"><i>MemberFunctionAttributes</i></a><sub>opt</sub>
<div class="blankline"></div>
<a id="FunctionLiteralBody"><span class="gname">FunctionLiteralBody</span></a>:
    <a href="../spec/statement.html#BlockStatement"><i>BlockStatement</i></a>
    <a href="../spec/function.html#FunctionContracts"><i>FunctionContracts</i></a><sub>opt</sub> <a href="../spec/function.html#BodyStatement"><i>BodyStatement</i></a>
</pre>
<div class="blankline"></div>
    <p><i>FunctionLiteral</i>s enable embedding anonymous functions
        and anonymous delegates directly into expressions.
        <i>Type</i> is the return type of the function or delegate,
        if omitted it is inferred from any <i>ReturnStatement</i>s
        in the <i>FunctionLiteralBody</i>.
        <a href="#ParameterWithAttributes"><i>ParameterWithAttributes</i></a> or <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a>
        can be used to specify the parameters for the function. If these are
        omitted, the function defaults to the empty parameter list <span class="d_inlinecode donthyphenate notranslate">( )</span>.
        The type of a function literal is pointer to function or
        pointer to delegate.
        If the keywords <span class="d_inlinecode donthyphenate notranslate">function</span> or <span class="d_inlinecode donthyphenate notranslate">delegate</span> are omitted,
        it is inferred from whether <i>FunctionLiteralBody</i> is actually
        accessing to the outer context.
    </p>
<div class="blankline"></div>
    <p>For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp; <span class="d_comment">// declare pointer to a function
</span>
<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6; }

    fp = &amp;foo;
}
</pre>
<div class="blankline"></div>
        is exactly equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp;

<span class="d_keyword">void</span> test()
{
    fp = <span class="d_keyword">function</span> <span class="d_keyword">int</span>(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6;} ;
}
</pre>
<div class="blankline"></div>
    <p>Also:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> b = 3;
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; }

    abc(&amp;foo);
}
</pre>
<div class="blankline"></div>
        is exactly equivalent to:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> b = 3;

    abc( <span class="d_keyword">delegate</span> <span class="d_keyword">int</span>(<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; } );
}
</pre>
<div class="blankline"></div>
    <p>and the following where the return type <span class="d_inlinecode donthyphenate notranslate">int</span> and
        <span class="d_inlinecode donthyphenate notranslate">function</span>/<span class="d_inlinecode donthyphenate notranslate">delegate</span> are inferred:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i));
<span class="d_keyword">int</span> def(<span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span> s));

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> b = 3;

    abc( (<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> 6 + b; } );  <span class="d_comment">// inferred to delegate
</span>    def( (<span class="d_keyword">int</span> c) { <span class="d_keyword">return</span> c * 2; } );  <span class="d_comment">// inferred to function
</span>  <span class="d_comment">//def( (int c) { return c * b; } );  // error!
</span>    <span class="d_comment">// Because the FunctionLiteralBody accesses b, then the function literal type
</span>    <span class="d_comment">// is inferred to delegate. But def cannot receive delegate.
</span>}
</pre>
<div class="blankline"></div>
    <p>If the type of a function literal can be uniquely determined from its context,
        the parameter type inference is possible.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span>) fp);

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">int</span>) fp = (n) { <span class="d_keyword">return</span> n * 2; };
    <span class="d_comment">// The type of parameter n is inferred to int.
</span>
    foo((n) { <span class="d_keyword">return</span> n * 2; });
    <span class="d_comment">// The type of parameter n is inferred to int.
</span>}
</pre>
<div class="blankline"></div>
    <p>Anonymous delegates can behave like arbitrary statement literals.
        For example, here an arbitrary statement is executed by a loop:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">double</span> test()
{
    <span class="d_keyword">double</span> d = 7.6;
    <span class="d_keyword">float</span> f = 2.3;

    <span class="d_keyword">void</span> loop(<span class="d_keyword">int</span> k, <span class="d_keyword">int</span> j, <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() statement)
    {
        <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = k; i &lt; j; i++)
        {
            statement();
        }
    }

    loop(5, 100, { d += 1; });
    loop(3, 10,  { f += 3; });

    <span class="d_keyword">return</span> d + f;
}
</pre>
<div class="blankline"></div>
    <p>When comparing with <a href="../spec/function.html#nested">nested functions</a>,
        the <span class="d_inlinecode donthyphenate notranslate">function</span> form is analogous to static
        or non-nested functions, and the <span class="d_inlinecode donthyphenate notranslate">delegate</span> form is
        analogous to non-static nested functions. In other words,
        a delegate literal can access stack variables in its enclosing
        function, a function literal cannot.
    </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="lambdas" href="#lambdas">Lambdas</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="Lambda"><span class="gname">Lambda</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">function</span> <span class="d_inlinecode donthyphenate notranslate">ref</span><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterWithAttributes"><i>ParameterWithAttributes</i></a> <span class="d_inlinecode donthyphenate notranslate">=&gt;</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <span class="d_inlinecode donthyphenate notranslate">delegate</span> <span class="d_inlinecode donthyphenate notranslate">ref</span><sub>opt</sub> <a href="../spec/declaration.html#Type"><i>Type</i></a><sub>opt</sub> <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a> <span class="d_inlinecode donthyphenate notranslate">=&gt;</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <span class="d_inlinecode donthyphenate notranslate">ref</span><sub>opt</sub> <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a> <span class="d_inlinecode donthyphenate notranslate">=&gt;</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
    <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">=&gt;</span> <a href="#AssignExpression"><i>AssignExpression</i></a>
</pre>
<div class="blankline"></div>
    <p><i>Lambda</i>s are a shorthand syntax for <a href="#FunctionLiteral"><i>FunctionLiteral</i></a>s.</p>
<div class="blankline"></div>
    <ol>        <li><p>Just one <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> is rewritten to
             <a href="../spec/function.html#Parameters"><i>Parameters</i></a>:</p>
<div class="blankline"></div>
             <span class="d_inlinecode donthyphenate notranslate">(</span> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
        </li>
        <li><p>The following part <span class="d_inlinecode donthyphenate notranslate">=&gt;</span> <i>AssignExpression</i> is rewritten to
             <a href="#FunctionLiteralBody"><i>FunctionLiteralBody</i></a>:</p>
<div class="blankline"></div>
             <span class="d_inlinecode donthyphenate notranslate">{ return</span> <i>AssignExpression</i> <span class="d_inlinecode donthyphenate notranslate">; }</span>
        </li>
    </ol>
<div class="blankline"></div>
    <p>Example usage:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> i = 3;
    <span class="d_keyword">auto</span> twice  = <span class="d_keyword">function</span> (<span class="d_keyword">int</span> x) =&gt; x * 2;
    <span class="d_keyword">auto</span> square = <span class="d_keyword">delegate</span> (<span class="d_keyword">int</span> x) =&gt; x * x;

    <span class="d_keyword">auto</span> n = 5;
    <span class="d_keyword">auto</span> mul_n = (<span class="d_keyword">int</span> x) =&gt; x * n;

    writeln(twice(i));   <span class="d_comment">// prints 6
</span>    writeln(square(i));  <span class="d_comment">// prints 9
</span>    writeln(mul_n(i));   <span class="d_comment">// prints 15
</span>}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="uniform_construction_syntax" href="#uniform_construction_syntax">Uniform construction syntax for built-in scalar types</a></h3>
<div class="blankline"></div>
    <p>The implicit conversions of built-in scalar types can be explicitly
        represented by using function call syntax. For example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = <span class="d_keyword">short</span>(1);  <span class="d_comment">// implicitly convert an integer literal '1' to short
</span><span class="d_keyword">auto</span> b = <span class="d_keyword">double</span>(a); <span class="d_comment">// implicitly convert a short variable 'a' to double
</span><span class="d_keyword">auto</span> c = <span class="d_keyword">byte</span>(128); <span class="d_comment">// error, 128 cannot be represented in a byte
</span></pre>
<div class="blankline"></div>
    <p>If the argument is omitted, it means default construction of the
        scalar type:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = <span class="d_keyword">ushort</span>();  <span class="d_comment">// same as: ushort.init
</span><span class="d_keyword">auto</span> b = <span class="d_keyword">wchar</span>();   <span class="d_comment">// same as: wchar.init
</span><span class="d_keyword">auto</span> c = <span class="d_keyword">creal</span>();   <span class="d_comment">// same as: creal.init
</span></pre>
<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="assert_expressions" href="#assert_expressions">Assert Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="AssertExpression"><span class="gname">AssertExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">assert (</span> <a href="#AssertArguments"><i>AssertArguments</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<a id="AssertArguments"><span class="gname">AssertArguments</span></a>:
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span><sub>opt</sub>
    <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span><sub>opt</sub>
</pre>
<div class="blankline"></div>
    <p>The first <i>AssignExpression</i> must evaluate to true. If it does not, an <i>Assert Failure</i>
    has occurred and the program enters an <i>Invalid State</i>.
    </p>
<div class="blankline"></div>
    <p>If the first <i>AssignExpression</i> consists entirely of compile time constants,
    and evaluates to false, it is a special case; it
    signifies that it is unreachable code.
    Compile Time Function Execution (CTFE) is not attempted.
    </p>
<div class="blankline"></div>
    <p><i>AssertExpression</i> has different semantics if it is in a
    <a href="../spec/unittest.html"><span class="d_inlinecode donthyphenate notranslate">unittest</span></a> or
    <a href="../spec/contracts.html"><span class="d_inlinecode donthyphenate notranslate">in</span> contract</a>.
    </p>
<div class="blankline"></div>
    <p>The second <i>AssignExpression</i>, if present, must be implicitly
        convertible to type <span class="d_inlinecode donthyphenate notranslate">const(char)[]</span>.
    </p>
<div class="blankline"></div>
    <p>If the first <i>AssignExpression</i> is a reference to a class instance for
    which a <a href="../spec/class.html#invariants">Class Invariant</a> exists, the <i>Class Invariant</i> must hold.
    </p>
<div class="blankline"></div>
    <p>If the first <i>AssignExpression</i> is a pointer to a struct instance for
    which a <i>Struct Invariant</i> exists, the <i>Struct Invariant</i> must hold.
    </p>
<div class="blankline"></div>
    <p>The type of an <i>AssertExpression</i> is <span class="d_inlinecode donthyphenate notranslate">void</span>.
    </p>
<div class="blankline"></div>
    <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b> Once in an <i>Invalid State</i> the behavior of the continuing execution
    of the program is undefined.</div>


<div class="blankline"></div>
    <div class="spec-boxes implementation-defined"><b>Implementation Defined:</b> Whether the first <i>AssertExpression</i> is evaluated
    or not at runtime is typically set with a compiler switch. If it is not evaluated,
    any side effects specified by the <i>AssertExpression</i> may not occur.
    The behavior if the first <i>AssertExpression</i> is evaluated and is false
    is also typically set with a compiler switch and may include these options:
    <ol>        <li>continuing execution</li>
        <li>immediately halting via execution of a special CPU instruction</li>
        <li>aborting the program</li>
        <li>calling the assert failure function in the corresponding C
        runtime library</li>
        <li>throwing the <span class="d_inlinecode donthyphenate notranslate">AssertError</span> exception in the D runtime library</li>
    </ol>
    If the optional second <i>AssignExpression</i> is provided, the implementation may
    evaluate it and print the resulting message upon assert failure:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">assert</span>(0, <span class="d_string">"an"</span> ~ <span class="d_string">" error message"</span>);
}
</pre>
<div class="blankline"></div>
    <p>When compiled and run, it will produce the message:</p>
<div class="blankline"></div>
    <pre class="console notranslate">core.exception.AssertError@test.d(3) an error message</pre>
<div class="blankline"></div>
    <p>The implementation may handle the case of the first <i>AssignExpression</i> evaluating at compile
    time to false differently in that in release mode
    it may simply generate a <span class="d_inlinecode donthyphenate notranslate">HLT</span> instruction or equivalent.
    </p>
    </div>


<div class="blankline"></div>
    <div class="spec-boxes best-practice"><b>Best Practices:</b>     <ol>        <li>Do not have side effects in either <i>AssignExpression</i> that subsequent code
        depends on.</li>
        <li><i>AssertExpressions</i> are intended to detect bugs in the program, do
        not use for detecting input or environmental errors.</li>
        <li>Do not attempt to resume normal execution after an <i>Assert Failure</i>.</li>
    </ol>
    </div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="mixin_expressions" href="#mixin_expressions">Mixin Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="MixinExpression"><span class="gname">MixinExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">mixin (</span> <a href="#ArgumentList"><i>ArgumentList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
</pre>
<div class="blankline"></div>
    <p>Each <a href="#AssignExpression"><i>AssignExpression</i></a> in the <i>ArgumentList</i> is
        evaluated at compile time, and the result must be representable
        as a string.
        The resulting strings are concatenated to form a string.
        The text contents of the string must be compilable as a valid
        <a href="#Expression"><i>Expression</i></a>, and is compiled as such.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(<span class="d_string">"x +"</span>, 1) * 7;  <span class="d_comment">// same as ((x + 1) * 7)
</span>}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="import_expressions" href="#import_expressions">Import Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="ImportExpression"><span class="gname">ImportExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">import (</span> <a href="#AssignExpression"><i>AssignExpression</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
</pre>
<div class="blankline"></div>
    <p>The <i>AssignExpression</i> must evaluate at compile time
        to a constant string.
        The text contents of the string are interpreted as a file
        name. The file is read, and the exact contents of the file
        become a string literal.
    </p>
<div class="blankline"></div>
    <p>Implementations may restrict the file name in order to avoid
        directory traversal security vulnerabilities.
        A possible restriction might be to disallow any path components
        in the file name.
    </p>
<div class="blankline"></div>
    <p>Note that by default an import expression will not compile unless
        you pass one or more paths via the <b>-J</b> switch. This tells the compiler
        where it should look for the files to import. This is a security feature.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
{
    <span class="d_comment">// Prints contents of file foo.txt
</span>    writeln(<span class="d_keyword">import</span>(<span class="d_string">"foo.txt"</span>));
}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="typeid_expressions" href="#typeid_expressions">Typeid Expressions</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="TypeidExpression"><span class="gname">TypeidExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">typeid (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">typeid (</span> <a href="#Expression"><i>Expression</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
</pre>
<div class="blankline"></div>
    <p>If <i>Type</i>, returns an instance of class
        <a href="../phobos/object.html"><span class="d_inlinecode donthyphenate notranslate">TypeInfo</span></a>
        corresponding
        to <i>Type</i>.
    </p>
<div class="blankline"></div>
    <p>If <i>Expression</i>, returns an instance of class
        <a href="../phobos/object.html"><span class="d_inlinecode donthyphenate notranslate">TypeInfo</span></a>
        corresponding
        to the type of the <i>Expression</i>.
        If the type is a class, it returns the <span class="d_inlinecode donthyphenate notranslate">TypeInfo</span>
        of the dynamic type (i.e. the most derived type).
        The <i>Expression</i> is always executed.</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">void</span> main()
{
    writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>));        <span class="d_comment">// int
</span>    <span class="d_keyword">uint</span> i;
    writeln(<span class="d_keyword">typeid</span>(i++));        <span class="d_comment">// uint
</span>    writeln(i);                  <span class="d_comment">// 1
</span>    A a = <span class="d_keyword">new</span> B();
    writeln(<span class="d_keyword">typeid</span>(a));          <span class="d_comment">// B
</span>    writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(a)));  <span class="d_comment">// A
</span>}
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="is_expression" href="#is_expression">IsExpression</a></h3>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="IsExpression"><span class="gname">IsExpression</span></a>:
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">:</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
    <span class="d_inlinecode donthyphenate notranslate">is (</span> <a href="../spec/declaration.html#Type"><i>Type</i></a> <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> <span class="d_inlinecode donthyphenate notranslate">==</span> <a href="#TypeSpecialization"><i>TypeSpecialization</i></a> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
<div class="blankline"></div>
<a id="TypeSpecialization"><span class="gname">TypeSpecialization</span></a>:
    <a href="../spec/declaration.html#Type"><i>Type</i></a>
    <span class="d_inlinecode donthyphenate notranslate">struct</span>
    <span class="d_inlinecode donthyphenate notranslate">union</span>
    <span class="d_inlinecode donthyphenate notranslate">class</span>
    <span class="d_inlinecode donthyphenate notranslate">interface</span>
    <span class="d_inlinecode donthyphenate notranslate">enum</span>
    <span class="d_inlinecode donthyphenate notranslate">__vector</span>
    <span class="d_inlinecode donthyphenate notranslate">function</span>
    <span class="d_inlinecode donthyphenate notranslate">delegate</span>
    <span class="d_inlinecode donthyphenate notranslate">super</span>
    <span class="d_inlinecode donthyphenate notranslate">const</span>
    <span class="d_inlinecode donthyphenate notranslate">immutable</span>
    <span class="d_inlinecode donthyphenate notranslate">inout</span>
    <span class="d_inlinecode donthyphenate notranslate">shared</span>
    <span class="d_inlinecode donthyphenate notranslate">return</span>
    <span class="d_inlinecode donthyphenate notranslate">__parameters</span>
    <span class="d_inlinecode donthyphenate notranslate">module</span>
    <span class="d_inlinecode donthyphenate notranslate">package</span>
</pre>
<div class="blankline"></div>
    <p><i>IsExpression</i>s are evaluated at compile time and are
        used for checking for valid types, comparing types for equivalence,
        determining if one type can be implicitly converted to another,
        and deducing the subtypes of a type.
        The result of an <i>IsExpression</i> is a boolean of value <span class="d_inlinecode donthyphenate notranslate">true</span>
        if the condition is satisfied. If the condition is not satisfied,
        the result is a boolean of value <span class="d_inlinecode donthyphenate notranslate">false</span>.
    </p>
<div class="blankline"></div>
    <p><i>Type</i> is the type being tested. It must be syntactically
        correct, but it need not be semantically correct.
        If it is not semantically correct, the condition is not satisfied.
    </p>
<div class="blankline"></div>
    <p><a href="../spec/lex.html#Identifier"><i>Identifier</i></a> is declared to be an alias of the resulting
        type if the condition is satisfied. The <a href="../spec/lex.html#Identifier"><i>Identifier</i></a> forms
        can only be used if the <i>IsExpression</i> appears in a
        <a href="../spec/version.html#StaticIfCondition"><i>StaticIfCondition</i></a>.
    </p>
<div class="blankline"></div>
    <p><i>TypeSpecialization</i> is the type that <i>Type</i> is being
        compared against.
    </p>
<div class="blankline"></div>
    <p>The forms of the <i>IsExpression</i> are:
    </p>
<div class="blankline"></div>
    <ol><div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
        The condition is satisfied if <span class="d_inlinecode donthyphenate notranslate">Type</span> is semantically
        correct (it must be syntactically correct regardless).
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> <span class="d_keyword">int</span> func(<span class="d_keyword">int</span>);    <span class="d_comment">// func is a alias to a function type
</span><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(func[]))     <span class="d_comment">// not satisfied because arrays of
</span>                        <span class="d_comment">// functions are not allowed
</span>        writeln(<span class="d_string">"satisfied"</span>);
    <span class="d_keyword">else</span>
        writeln(<span class="d_string">"not satisfied"</span>);

    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>([][]))       <span class="d_comment">// error, [][] is not a syntactically valid type
</span>        ...
}
</pre>
        </li>
<div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
        The condition is satisfied if <i>Type</i> is semantically
        correct and it is the same as
        or can be implicitly converted to <i>TypeSpecialization</i>.
        <i>TypeSpecialization</i> is only allowed to be a <i>Type</i>.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">short</span>;
<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar : <span class="d_keyword">int</span>))   <span class="d_comment">// satisfied because short can be
</span>                         <span class="d_comment">// implicitly converted to int
</span>        writeln(<span class="d_string">"satisfied"</span>);
    <span class="d_keyword">else</span>
        writeln(<span class="d_string">"not satisfied"</span>);
}
</pre>
        </li>
<div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
<div class="blankline"></div>
        The condition is satisfied if <i>Type</i> is semantically correct and is
        the same type as <i>TypeSpecialization</i>.
<div class="blankline"></div>
        If <i>TypeSpecialization</i> is one of
<div class="blankline"></div>
                <span class="d_inlinecode donthyphenate notranslate">struct</span>
                <span class="d_inlinecode donthyphenate notranslate">union</span>
                <span class="d_inlinecode donthyphenate notranslate">class</span>
                <span class="d_inlinecode donthyphenate notranslate">interface</span>
                <span class="d_inlinecode donthyphenate notranslate">enum</span>
                <span class="d_inlinecode donthyphenate notranslate">function</span>
                <span class="d_inlinecode donthyphenate notranslate">delegate</span>
                <span class="d_inlinecode donthyphenate notranslate">const</span>
                <span class="d_inlinecode donthyphenate notranslate">immutable</span>
                <span class="d_inlinecode donthyphenate notranslate">shared</span>
                <span class="d_inlinecode donthyphenate notranslate">module</span>
                <span class="d_inlinecode donthyphenate notranslate">package</span>
<div class="blankline"></div>
        then the condition is satisfied if <i>Type</i> is one of those. <a href="../        spec/module.html#package-module">Package modules</a> are considered to be both
        packages and modules.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">short</span>;
<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar == <span class="d_keyword">int</span>))   <span class="d_comment">// not satisfied because short is not
</span>                          <span class="d_comment">// the same type as int
</span>        writeln(<span class="d_string">"satisfied"</span>);
    <span class="d_keyword">else</span>
        writeln(<span class="d_string">"not satisfied"</span>);
}
</pre>
        </li>
<div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
        The condition is satisfied if <i>Type</i> is semantically
        correct. If so, <i>Identifier</i>
        is declared to be an alias of <i>Type</i>.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">short</span>;
<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar T))
        <span class="d_keyword">alias</span> S = T;
    <span class="d_keyword">else</span>
        <span class="d_keyword">alias</span> S = <span class="d_keyword">long</span>;

    writeln(<span class="d_keyword">typeid</span>(S)); <span class="d_comment">// prints "short"
</span>    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar T))      <span class="d_comment">// error, Identifier T form can
</span>                        <span class="d_comment">// only be in StaticIfConditions
</span>        ...
}
</pre>
        </li>
<div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
<div class="blankline"></div>
        The condition is satisfied if <i>Type</i> is the same as
        <i>TypeSpecialization</i>, or if <i>Type</i> is a class and
        <i>TypeSpecialization</i> is a base class or base interface
        of it.
        The <i>Identifier</i> is declared to be either an alias of the
        <i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is
        dependent on <i>Identifier</i>, the deduced type.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">int</span>;
<span class="d_keyword">alias</span> Abc = <span class="d_keyword">long</span>*;
<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar T : <span class="d_keyword">int</span>))
        <span class="d_keyword">alias</span> S = T;
    <span class="d_keyword">else</span>
        <span class="d_keyword">alias</span> S = <span class="d_keyword">long</span>;

    writeln(<span class="d_keyword">typeid</span>(S));  <span class="d_comment">// prints "int"
</span>
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Abc U : U*))
    {
        U u;
        writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(u)));  <span class="d_comment">// prints "long"
</span>    }
}
</pre>
<div class="blankline"></div>
        The way the type of <i>Identifier</i> is determined is analogous
        to the way template parameter types are determined by
        <a href="../spec/template.html#TemplateTypeParameterSpecialization"><i>TemplateTypeParameterSpecialization</i></a>.
        </li>
<div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
<div class="blankline"></div>
<div class="blankline"></div>
        The condition is satisfied if <i>Type</i> is semantically
        correct and is the same as <i>TypeSpecialization</i>.
        The <i>Identifier</i> is declared to be either an alias of the
        <i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is
        dependent on <i>Identifier</i>, the deduced type.
<div class="blankline"></div>
        If <i>TypeSpecialization</i> is one of
               <span class="d_inlinecode donthyphenate notranslate">struct</span>
                <span class="d_inlinecode donthyphenate notranslate">union</span>
                <span class="d_inlinecode donthyphenate notranslate">class</span>
                <span class="d_inlinecode donthyphenate notranslate">interface</span>
                <span class="d_inlinecode donthyphenate notranslate">enum</span>
                <span class="d_inlinecode donthyphenate notranslate">function</span>
                <span class="d_inlinecode donthyphenate notranslate">delegate</span>
           <span class="d_inlinecode donthyphenate notranslate">const</span>
                <span class="d_inlinecode donthyphenate notranslate">immutable</span>
                <span class="d_inlinecode donthyphenate notranslate">shared</span>
<div class="blankline"></div>
        then the condition is satisfied if <i>Type</i> is one of those.
        Furthermore, <i>Identifier</i> is set to be an alias of the type:
<div class="blankline"></div>
        <center><table><caption></caption>        <tr><th class="donthyphenate"><b>keyword</b></th><th class="donthyphenate"><b>alias type for <i>Identifier</i></b></th></tr>
<div class="blankline"></div>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">struct</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">union</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">class</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">interface</span></td><td><i>Type</i></td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">super</span></td><td><i>TypeSeq</i> of base classes and interfaces</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">enum</span></td><td>the base type of the enum</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">function</span></td><td><i>TypeSeq</i> of the function parameter types.
             For C- and D-style variadic functions,
             only the non-variadic parameters are included.
             For typesafe variadic functions, the <span class="d_inlinecode donthyphenate notranslate">...</span> is ignored.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">delegate</span></td><td>the function type of the delegate</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">return</span></td><td>the return type of the function, delegate, or function pointer</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">__parameters</span></td><td>the parameter sequence of a function, delegate, or function pointer.
         This includes the parameter types, names, and default values.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">const</span></td><td><i>Type</i></td></tr>
        <tr><td>        <span class="d_inlinecode donthyphenate notranslate">immutable</span></td><td>        <i>Type</i>
        </td></tr>
        <tr><td>        <span class="d_inlinecode donthyphenate notranslate">shared</span></td><td>        <i>Type</i>
        </td></tr>
<div class="blankline"></div>
        </table></center>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">alias</span> Bar = <span class="d_keyword">short</span>;
<span class="d_keyword">enum</span> E : <span class="d_keyword">byte</span> { Emember }
<span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Bar T == <span class="d_keyword">int</span>))   <span class="d_comment">// not satisfied, short is not int
</span>        <span class="d_keyword">alias</span> S = T;
    <span class="d_keyword">alias</span> U = T;                   <span class="d_comment">// error, T is not defined
</span>
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(E V == <span class="d_keyword">enum</span>))    <span class="d_comment">// satisfied, E is an enum
</span>        V v;                       <span class="d_comment">// v is declared to be a byte
</span>}
</pre>
<div class="blankline"></div>
        </li>
<div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
             <span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
             <span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">:</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span><br>
             <span class="d_inlinecode donthyphenate notranslate">is (</span> <i>Type</i> <i>Identifier</i> <span class="d_inlinecode donthyphenate notranslate">==</span> <i>TypeSpecialization</i> <span class="d_inlinecode donthyphenate notranslate">,</span> <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <span class="d_inlinecode donthyphenate notranslate">)</span>
<div class="blankline"></div>
        More complex types can be pattern matched; the
        <a href="../spec/template.html#TemplateParameterList"><i>TemplateParameterList</i></a> declares symbols based on the
        parts of the pattern that are matched, analogously to the
        way implied template parameters are matched.
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio, std.typecons;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">alias</span> Tup = Tuple!(<span class="d_keyword">int</span>, string);
    <span class="d_keyword">alias</span> AA = <span class="d_keyword">long</span>[string];

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(Tup : Template!Args, <span class="d_keyword">alias</span> Template, Args...))
    {
        writeln(<span class="d_keyword">__traits</span>(isSame, Template, Tuple)); <span class="d_comment">// true
</span>        writeln(<span class="d_keyword">is</span>(Template!(<span class="d_keyword">int</span>, string) == Tup));  <span class="d_comment">// true
</span>        writeln(<span class="d_keyword">typeid</span>(Args[0]));  <span class="d_comment">// int
</span>        writeln(<span class="d_keyword">typeid</span>(Args[1]));  <span class="d_comment">// immutable(char)[]
</span>    }

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(AA T : T[U], U : string))
    {
        writeln(<span class="d_keyword">typeid</span>(T));  <span class="d_comment">// long
</span>        writeln(<span class="d_keyword">typeid</span>(U));  <span class="d_comment">// string
</span>    }

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(AA A : A[B], B : <span class="d_keyword">int</span>))
    {
        <span class="d_keyword">assert</span>(0);  <span class="d_comment">// should not match, as B is not an int
</span>    }

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">int</span>[10] W : W[len], <span class="d_keyword">int</span> len))
    {
        writeln(<span class="d_keyword">typeid</span>(W));  <span class="d_comment">// int
</span>        writeln(len);        <span class="d_comment">// 10
</span>    }

    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(<span class="d_keyword">int</span>[10] X : X[len], <span class="d_keyword">int</span> len : 5))
    {
        <span class="d_keyword">assert</span>(0);  <span class="d_comment">// should not match, len should be 10
</span>    }
}
</pre>
<div class="blankline"></div>
        </li>
<div class="blankline"></div>
    </ol>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="specialkeywords" href="#specialkeywords">Special Keywords</a></h2>
<div class="blankline"></div>
<pre class="bnf notranslate"><a id="SpecialKeyword"><span class="gname">SpecialKeyword</span></a>:
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__FILE__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__FILE_FULL_PATH__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__MODULE__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__LINE__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__FUNCTION__</a></span>
    <span class="d_inlinecode donthyphenate notranslate"><a href="#specialkeywords">__PRETTY_FUNCTION__</a></span>
</pre>
<div class="blankline"></div>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__FILE__</span> and <span class="d_inlinecode donthyphenate notranslate">__LINE__</span> expand to the source
    file name and line number at the point of instantiation. The path of
    the source file is left up to the compiler. </p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__FILE_FULL_PATH__</span> expands to the absolute source
    file name at the point of instantiation.</p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__MODULE__</span> expands to the module name at the point of
    instantiation.</p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__FUNCTION__</span> expands to the fully qualified name of the
    function at the point of instantiation.</p>
<div class="blankline"></div>
    <p><span class="d_inlinecode donthyphenate notranslate">__PRETTY_FUNCTION__</span> is similar to <span class="d_inlinecode donthyphenate notranslate">__FUNCTION__</span>,
    but also expands the function return type, its parameter types,
    and its attributes.</p>
<div class="blankline"></div>
    <p>Example:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">module</span> test;
<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> test(string file = <span class="d_keyword">__FILE__</span>, size_t line = <span class="d_keyword">__LINE__</span>,
        string mod = <span class="d_keyword">__MODULE__</span>, string func = <span class="d_keyword">__FUNCTION__</span>,
        string pretty = <span class="d_keyword">__PRETTY_FUNCTION__</span>,
        string fileFullPath = <span class="d_keyword">__FILE_FULL_PATH__</span>)
{
    writefln(<span class="d_string">"file: '%s', line: '%s', module: '%s',\nfunction: '%s', "</span> ~
        <span class="d_string">"pretty function: '%s',\nfile full path: '%s'"</span>,
        file, line, mod, func, pretty, fileFullPath);
}

<span class="d_keyword">int</span> main(string[] args)
{
    test();
    <span class="d_keyword">return</span> 0;
}
</pre>
<div class="blankline"></div>
    <p>Assuming the file was at /example/test.d, this will output:</p>
<div class="blankline"></div>
<pre class="console notranslate">file: 'test.d', line: '13', module: 'test',
function: 'test.main', pretty function: 'int test.main(string[] args)',
file full path: '/example/test.d'
</pre>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="associativity" href="#associativity">Associativity and Commutativity</a></h2>
<div class="blankline"></div>
    <p>An implementation may rearrange the evaluation of expressions
        according to arithmetic associativity and commutativity rules
        as long as, within that thread of execution, no observable
        difference is possible.
    </p>
<div class="blankline"></div>
    <p>This rule precludes any associative or commutative reordering of
        floating point expressions.
    </p>

<div style="float: left"><i class="fa fa-angle-left" aria-hidden="true"></i> <a href="../spec/pragma.html">Pragmas</a></div>
<div style="float: right"><a href="../spec/statement.html">Statements</a> <i class="fa fa-angle-right" aria-hidden="true"></i></div>
<div style="clear:both"></div>



        <div class="smallprint" id="copyright">Copyright &copy; 1999-2022 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(addVersionSelector);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Structs - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Structs' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BStructs%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/struct.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Structs</h1>
        
        



<p>As has been mentioned several times earlier in the book, fundamental types are not suitable to represent higher-level concepts. For example, although a value of type <code class="d_inline">int</code> is suitable to represent the hour of day, two <code class="d_inline">int</code> variables would be more suitable together to represent a point in time: one for the hour and the other for the minute.
</p>

<p><a id="ix_Structs.user defined type" content="user defined type"></a> Structs are the feature that allow defining new types by combining already existing other types. The new type is defined by the <code class="d_inline">struct</code> keyword. By this definition, structs are <i>user defined types</i>. Most of the content of this chapter is directly applicable to classes as well. Especially the concept of <i>combining existing types to define a new type</i> is exactly the same for them.
</p>

<p>This chapter covers only the basic features of structs. We will see more of structs in the following chapters:
</p>

<ul><li><a href="member_functions.html">Member Functions</a></li>
<li><a href="const_member_functions.html">const ref Parameters and const Member Functions</a></li>
<li><a href="special_functions.html">Constructor and Other Special Functions</a></li>
<li><a href="operator_overloading.html">Operator Overloading</a></li>
<li><a href="encapsulation.html">Encapsulation and Protection Attributes</a></li>
<li><a href="property.html">Properties</a></li>
<li><a href="invariant.html">Contract Programming for Structs and Classes</a></li>
<li><a href="foreach_opapply.html">foreach with Structs and Classes</a></li>
</ul>

<p>To understand how useful structs are, let's take a look at the <code class="d_inline">addDuration()</code> function that we had defined earlier in the <a href="assert.html"><code class="d_inline">assert</code> and <code class="d_inline">enforce</code> chapter</a>. The following definition is from the exercise solution of that chapter:
</p>

<pre class="d_code"><span class="d_keyword">void</span> addDuration(<span class="d_keyword">int</span> startHour, <span class="d_keyword">int</span> startMinute,
                 <span class="d_keyword">int</span> durationHour, <span class="d_keyword">int</span> durationMinute,
                 <span class="d_keyword">out</span> <span class="d_keyword">int</span> resultHour, <span class="d_keyword">out</span> <span class="d_keyword">int</span> resultMinute) {
    resultHour = startHour + durationHour;
    resultMinute = startMinute + durationMinute;
    resultHour += resultMinute / 60;

    resultMinute %= 60;
    resultHour %= 24;
}
</pre>

<p><i><b>Note:</b> I will ignore the <code class="d_inline">in</code>, <code class="d_inline">out</code>, and <code class="d_inline">unittest</code> blocks in this chapter to keep the code samples short.</i>
</p>

<p>Although the function above clearly takes six parameters, when the three pairs of parameters are considered, it is conceptually taking only three bits of information for the starting time, the duration, and the result.
</p>

<h5 class="subsection">Definition</h5>

<p>The <code class="d_inline">struct</code> keyword defines a new type by combining variables that are related in some way:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> TimeOfDay {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;
}
</pre>

<p>The code above defines a new type named <code class="d_inline">TimeOfDay</code>, which consists of two variables named <code class="d_inline">hour</code> and <code class="d_inline">minute</code>. That definition allows the new <code class="d_inline">TimeOfDay</code> type to be used in the program just like any other type. The following code demonstrates how similar its use is to an <code class="d_inline">int</code>'s:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> number;            <span class="d_comment">// a variable
</span>    number = otherNumber;  <span class="d_comment">// taking the value of otherNumber
</span>
    TimeOfDay time;        <span class="d_comment">// an object
</span>    time = otherTime;      <span class="d_comment">// taking the value of otherTime
</span></pre>

<p>The syntax of <code class="d_inline">struct</code> definition is the following:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> <i>TypeName</i> {
    <span class="d_comment">// ... member variables and functions ...
</span>}
</pre>

<p>We will see member functions in later chapters.
</p>

<p>The variables that a struct combines are called its <i>members</i>. According to this definition, <code class="d_inline">TimeOfDay</code> has two members: <code class="d_inline">hour</code> and <code class="d_inline">minute</code>.
</p>

<h6><code class="d_inline">struct</code> defines a type, not a variable</h6>

<p>There is an important distinction here: Especially after the <a href="name_space.html">Name Scope</a> and <a href="lifetimes.html">Lifetimes and Fundamental Operations</a> chapters, the curly brackets of <code class="d_inline">struct</code> definitions may give the wrong impression that the struct members start and end their lives inside that scope. This is not true.
</p>

<p>Member definitions are not variable definitions:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> TimeOfDay {
    <span class="d_keyword">int</span> hour;      <span class="d_comment">// ← Not a variable; will become a part of
</span>                   <span class="d_comment">//   a struct variable used in the program.
</span>
    <span class="d_keyword">int</span> minute;    <span class="d_comment">// ← Not a variable; will become a part of
</span>                   <span class="d_comment">//   a struct variable used in the program.
</span>}
</pre>

<p>The definition of a <code class="d_inline">struct</code> determines the types and the names of the members that the objects of that <code class="d_inline">struct</code> will have. Those member variables will be constructed as parts of <code class="d_inline">TimeOfDay</code> objects that take part in the program:
</p>

<pre class="d_code">    TimeOfDay bedTime;    <span class="d_comment">// This object contains its own hour
</span>                          <span class="d_comment">// and minute member variables.
</span>
    TimeOfDay wakeUpTime; <span class="d_comment">// This object contains its own hour
</span>                          <span class="d_comment">// and minute member variables as
</span>                          <span class="d_comment">// well. The member variables of
</span>                          <span class="d_comment">// this object are not related to
</span>                          <span class="d_comment">// the member variables of the
</span>                          <span class="d_comment">// previous object.
</span></pre>

<p><a id="ix_Structs.object, struct" content="object, struct"></a> Variables of <code class="d_inline">struct</code> and <code class="d_inline">class</code> types are called <i>objects</i>.
</p>

<h6>Coding convenience</h6>

<p>Being able to combine the concepts of hour and minute together as a new type is a great convenience. For example, the function above can be rewritten in a more meaningful way by taking three <code class="d_inline">TimeOfDay</code> parameters instead of the existing six <code class="d_inline">int</code> parameters:
</p>

<pre class="d_code"><span class="d_keyword">void</span> addDuration(TimeOfDay start,
                 TimeOfDay duration,
                 <span class="d_keyword">out</span> TimeOfDay result) {
    <span class="d_comment">// ...
</span>}
</pre>

<p><i><b>Note:</b> It is not normal to add two variables that represent two points in time. For example, it is meaningless to add the lunch time 12:00 to the breakfast time 7:30. It would make more sense to define another type, appropriately called <code class="d_inline">Duration</code>, and to add objects of that type to <code class="d_inline">TimeOfDay</code> objects. Despite this design flaw, I will continue using only <code class="d_inline">TimeOfDay</code> objects in this chapter and introduce <code class="d_inline">Duration</code> in a later chapter.</i>
</p>

<p>As you remember, functions return up-to a single value. That has precisely been the reason why the earlier definition of <code class="d_inline">addDuration()</code> was taking two <code class="d_inline">out</code> parameters: It could not return the hour and minute information as a single value.
</p>

<p>Structs remove this limitation as well: Since multiple values can be combined as a single <code class="d_inline">struct</code> type, functions can return an object of such a <code class="d_inline">struct</code>, effectively returning multiple values at once. <code class="d_inline">addDuration()</code> can now be defined as returning its result:
</p>

<pre class="d_code">TimeOfDay addDuration(TimeOfDay start,
                      TimeOfDay duration) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>As a consequence, <code class="d_inline">addDuration()</code> now becomes a function that produces a value, as opposed to being a function that has side effects. As you would remember from the <a href="functions.html">Functions chapter</a>, producing results is preferred over having side effects.
</p>

<p>Structs can be members of other structs. For example, the following <code class="d_inline">struct</code> has two <code class="d_inline">TimeOfDay</code> members:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Meeting {
    string    topic;
    size_t    attendanceCount;
    TimeOfDay start;
    TimeOfDay end;
}
</pre>

<p><code class="d_inline">Meeting</code> can in turn be a member of another <code class="d_inline">struct</code>. Assuming that there is also the <code class="d_inline">Meal</code> struct:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> DailyPlan {
    Meeting projectMeeting;
    Meal    lunch;
    Meeting budgetMeeting;
}
</pre>

<h5 class="subsection"><a id="ix_Structs.., member" content="., member"></a> Accessing the members</h5>

<p>Struct members are used like any other variable. The only difference is that the actual struct variable and a <i>dot</i> must be specified before the name of the member:
</p>

<pre class="d_code">    start.hour = 10;
</pre>

<p>The line above assigns the value 10 to the <code class="d_inline">hour</code> member of the <code class="d_inline">start</code> object.
</p>

<p>Let's rewrite the <code class="d_inline">addDuration()</code> function with what we have seen so far:
</p>

<pre class="d_code">TimeOfDay addDuration(TimeOfDay start,
                      TimeOfDay duration) {
    TimeOfDay result;

    result.minute = start.minute + duration.minute;
    result.hour = start.hour + duration.hour;
    result.hour += result.minute / 60;

    result.minute %= 60;
    result.hour %= 24;

    <span class="d_keyword">return</span> result;
}
</pre>

<p>Notice that the names of the variables are now much shorter in this version of the function: <code class="d_inline">start</code>, <code class="d_inline">duration</code>, and <code class="d_inline">result</code>. Additionally, instead of using complex names like <code class="d_inline">startHour</code>, it is possible to access struct members through their respective struct variables as in <code class="d_inline">start.hour</code>.
</p>

<p>Here is a code that uses the new <code class="d_inline">addDuration()</code> function. Given the start time and the duration, the following code calculates when a class period at a school would end:
</p>

<pre class="d_code"><span class="d_keyword">void</span> main() {
    TimeOfDay periodStart;
    periodStart.hour = 8;
    periodStart.minute = 30;

    TimeOfDay periodDuration;
    periodDuration.hour = 1;
    periodDuration.minute = 15;

    <span class="d_keyword">immutable</span> periodEnd = addDuration(periodStart,
                                      periodDuration);

    writefln(<span class="d_string">"Period end: %s:%s"</span>,
              periodEnd.hour, periodEnd.minute);
}
</pre>

<p>The output:
</p>

<pre class="shell">Period end: 9:45
</pre>

<p>The <code class="d_inline">main()</code> above has been written only by what we have seen so far. We will make this code even shorter and cleaner soon.
</p>

<h5 class="subsection"><a id="ix_Structs.construction" content="construction"></a> Construction</h5>

<p>The first three lines of <code class="d_inline">main()</code> are about constructing the <code class="d_inline">periodStart</code> object and the next three lines are about constructing the <code class="d_inline">periodDuration</code> object. In each three lines of code first an object is being defined and then its hour and minute values are being set.
</p>

<p>In order for a variable to be used in a safe way, that variable must first be constructed in a consistent state. Because construction is so common, there is a special construction syntax for struct objects:
</p>

<pre class="d_code">    TimeOfDay periodStart = TimeOfDay(8, 30);
    TimeOfDay periodDuration = TimeOfDay(1, 15);
</pre>

<p>The values are automatically assigned to the members in the order that they are specified: Because <code class="d_inline">hour</code> is defined first in the <code class="d_inline">struct</code>, the value 8 is assigned to <code class="d_inline">periodStart.hour</code> and 30 is assigned to <code class="d_inline">periodStart.minute</code>.
</p>

<p>As we have seen in <a href="cast.html">the Type Conversions chapter</a>, the construction syntax can be used for other types as well:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> u = <span class="d_keyword">ubyte</span>(42);    <span class="d_comment">// u is a ubyte
</span>    <span class="d_keyword">auto</span> i = <span class="d_keyword">int</span>(u);       <span class="d_comment">// i is an int
</span></pre>

<h6>Constructing objects as <code class="d_inline">immutable</code></h6>

<p>Being able to construct the object by specifying the values of its members at once makes it possible to define objects as <code class="d_inline">immutable</code>:
</p>

<pre class="d_code">    <span class="d_keyword">immutable</span> periodStart = TimeOfDay(8, 30);
    <span class="d_keyword">immutable</span> periodDuration = TimeOfDay(1, 15);
</pre>

<p>Otherwise it would not be possible to mark an object first as <code class="d_inline">immutable</code> and then modify its members:
</p>

<pre class="d_code">    <span class="hilite"><span class="d_keyword">immutable</span></span> TimeOfDay periodStart;
    periodStart.hour = 8;      <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    periodStart.minute = 30;   <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<h6>Trailing members need not be specified</h6>

<p>There may be fewer values specified than the number of members. In that case, the remaining members are initialized by the <code class="d_inline">.init</code> values of their respective types.
</p>

<p>The following program constructs <code class="d_inline">Test</code> objects each time with one less constructor parameter. The <code class="d_inline">assert</code> checks indicate that the unspecified members are initialized automatically by their <code class="d_inline">.init</code> values. (The reason for needing to call <code class="d_inline">isNaN()</code> is explained after the program):
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.math;

<span class="d_keyword">struct</span> Test {
    <span class="d_keyword">char</span>   c;
    <span class="d_keyword">int</span>    i;
    <span class="d_keyword">double</span> d;
}

<span class="d_keyword">void</span> main() {
    <span class="d_comment">// The initial values of all of the members are specified
</span>    <span class="d_keyword">auto</span> t1 = Test('a', 1, 2.3);
    <span class="d_keyword">assert</span>(t1.c == 'a');
    <span class="d_keyword">assert</span>(t1.i == 1);
    <span class="d_keyword">assert</span>(t1.d == 2.3);

    <span class="d_comment">// Last one is missing
</span>    <span class="d_keyword">auto</span> t2 = Test('a', 1);
    <span class="d_keyword">assert</span>(t2.c == 'a');
    <span class="d_keyword">assert</span>(t2.i == 1);
    <span class="d_keyword">assert</span>(<span class="hilite">isNaN(t2.d)</span>);

    <span class="d_comment">// Last two are missing
</span>    <span class="d_keyword">auto</span> t3 = Test('a');
    <span class="d_keyword">assert</span>(t3.c == 'a');
    <span class="d_keyword">assert</span>(<span class="hilite">t3.i == <span class="d_keyword">int</span>.init</span>);
    <span class="d_keyword">assert</span>(<span class="hilite">isNaN(t3.d)</span>);

    <span class="d_comment">// No initial value specified
</span>    <span class="d_keyword">auto</span> t4 = Test();
    <span class="d_keyword">assert</span>(<span class="hilite">t4.c == <span class="d_keyword">char</span>.init</span>);
    <span class="d_keyword">assert</span>(<span class="hilite">t4.i == <span class="d_keyword">int</span>.init</span>);
    <span class="d_keyword">assert</span>(<span class="hilite">isNaN(t4.d)</span>);

    <span class="d_comment">// The same as above
</span>    Test t5;
    <span class="d_keyword">assert</span>(t5.c == <span class="d_keyword">char</span>.init);
    <span class="d_keyword">assert</span>(t5.i == <span class="d_keyword">int</span>.init);
    <span class="d_keyword">assert</span>(isNaN(t5.d));
}
</pre>

<p>As you would remember from the <a href="floating_point.html">Floating Point Types chapter</a>, the initial value of <code class="d_inline">double</code> is <code class="d_inline">double.nan</code>. Since the <code class="d_inline">.nan</code> value is <i>unordered</i>, it is meaningless to use it in equality comparisons. That is why calling <code class="d_inline">std.math.isNaN</code> is the correct way of determining whether a value equals to <code class="d_inline">.nan</code>.
</p>

<h6><a id="ix_Structs.default value, member" content="default value, member"></a> Specifying default values for members</h6>

<p>It is important that member variables are automatically initialized with known initial values. This prevents the program from continuing with indeterminate values. However, the <code class="d_inline">.init</code> value of their respective types may not be suitable for every type. For example, <code class="d_inline">char.init</code> is not even a valid value.
</p>

<p>The initial values of the members of a struct can be specified when the struct is defined. This is useful for example to initialize floating point members by <code class="d_inline">0.0</code>, instead of the mostly-unusable <code class="d_inline">.nan</code>.
</p>

<p>The default values are specified by the assignment syntax as the members are defined:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Test {
    <span class="d_keyword">char</span>   c <span class="hilite">= 'A'</span>;
    <span class="d_keyword">int</span>    i <span class="hilite">= 11</span>;
    <span class="d_keyword">double</span> d <span class="hilite">= 0.25</span>;
}
</pre>

<p>Please note that the syntax above is not really assignment. The code above merely determines the default values that will be used when objects of that struct are actually constructed later in the program.
</p>

<p>For example, the following <code class="d_inline">Test</code> object is being constructed without any specific values:
</p>

<pre class="d_code">    Test t;  <span class="d_comment">// no value is specified for the members
</span>    writefln(<span class="d_string">"%s,%s,%s"</span>, t.c, t.i, t.d);
</pre>

<p>All of the members are initialized by their default values:
</p>

<pre class="shell">A,11,0.25
</pre>

<h6><a id="ix_Structs.{}, construction" content="{}, construction"></a> <a id="ix_Structs.C-style struct initialization" content="C-style struct initialization"></a> Constructing by the <code class="d_inline">{}</code> syntax</h6>

<p>Struct objects can also be constructed by the following syntax:
</p>

<pre class="d_code">    TimeOfDay periodStart = { 8, 30 };
</pre>

<p>Similar to the earlier syntax, the specified values are assigned to the members in the order that they are specified. The trailing members get their default values.
</p>

<p>This syntax is inherited from the C programming language:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> periodStart = TimeOfDay(8, 30);    <span class="d_comment">// ← regular
</span>    TimeOfDay periodEnd = { 9, 30 };        <span class="d_comment">// ← C-style
</span></pre>

<p><a id="ix_Structs.designated initializer" content="designated initializer"></a> This syntax allows <i>designated initializers</i>. Designated initializers are for specifying the member that an initialization value is associated with. It is even possible to initialize members in a different order than they are defined in the <code class="d_inline">struct</code>:
</p>

<pre class="d_code">    TimeOfDay t = { <span class="hilite">minute:</span> 42, <span class="hilite">hour:</span> 7 };
</pre>

<h5 class="subsection"><a id="ix_Structs.copy, struct" content="copy, struct"></a> <a id="ix_Structs.assignment, struct" content="assignment, struct"></a> Copying and assignment</h5>

<p>Structs are value types. As has been described in the <a href="value_vs_reference.html">Value Types and Reference Types chapter</a>, this means that every <code class="d_inline">struct</code> object has its own value. Objects get their own values when constructed, and their values change when they are assigned new values.
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> yourLunchTime = TimeOfDay(12, 0);
    <span class="d_keyword">auto</span> myLunchTime = yourLunchTime;

    <span class="d_comment">// Only my lunch time becomes 12:05:
</span>    myLunchTime.minute += 5;

    <span class="d_comment">// ... your lunch time is still the same:
</span>    <span class="d_keyword">assert</span>(yourLunchTime.minute == 0);
</pre>

<p>During a copy, all of the members of the source object are automatically copied to the corresponding members of the destination object. Similarly, assignment involves assigning each member of the source to the corresponding member of the destination.
</p>

<p>Struct members that are of reference types need extra attention.
</p>

<h6><a id="ix_Structs.reference type, member" content="reference type, member"></a> Careful with members that are of reference types!</h6>

<p>As you remember, copying or assigning variables of reference types does not change any value, it changes what object is being referenced. As a result, copying or assigning generates one more reference to the right-hand side object. The relevance of this for struct members is that, the members of two separate struct objects would start providing access to the same value.
</p>

<p>To see an example of this, let's have a look at a struct where one of the members is a reference type. This struct is used for keeping the student number and the grades of a student:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Student {
    <span class="d_keyword">int</span> number;
    <span class="d_keyword">int</span>[] grades;
}
</pre>

<p>The following code constructs a second <code class="d_inline">Student</code> object by copying an existing one:
</p>

<pre class="d_code">    <span class="d_comment">// Constructing the first object:
</span>    <span class="d_keyword">auto</span> student1 = Student(1, [ 70, 90, 85 ]);

    <span class="d_comment">// Constructing the second student as a copy of the first
</span>    <span class="d_comment">// one and then changing its number:
</span>    <span class="d_keyword">auto</span> student2 = student1;
    student2.number = 2;

    <span class="d_comment">// WARNING: The grades are now being shared by the two objects!
</span>
    <span class="d_comment">// Changing the grades of the first student ...
</span>    student1.grades[0] += 5;

    <span class="d_comment">// ... affects the second student as well:
</span>    writeln(student2.grades[0]);
</pre>

<p>When <code class="d_inline">student2</code> is constructed, its members get the values of the members of <code class="d_inline">student1</code>. Since <code class="d_inline">int</code> is a value type, the second object gets its own <code class="d_inline">number</code> value.
</p>

<p>The two <code class="d_inline">Student</code> objects also have individual <code class="d_inline">grades</code> members as well. However, since slices are reference types, the actual elements that the two slices share are the same. Consequently, a change made through one of the slices is seen through the other slice.
</p>

<p>The output of the code indicates that the grade of the second student has been increased as well:
</p>

<pre class="shell">75
</pre>

<p>For that reason, a better approach might be to construct the second object by the copies of the grades of the first one:
</p>

<pre class="d_code">    <span class="d_comment">// The second Student is being constructed by the copies
</span>    <span class="d_comment">// of the grades of the first one:
</span>    <span class="d_keyword">auto</span> student2 = Student(2, student1.grades<span class="hilite">.dup</span>);

    <span class="d_comment">// Changing the grades of the first student ...
</span>    student1.grades[0] += 5;

    <span class="d_comment">// ... does not affect the grades of the second student:
</span>    writeln(student2.grades[0]);
</pre>

<p>Since the grades have been copied by <code class="d_inline">.dup</code>, this time the grades of the second student are not affected:
</p>

<pre class="shell">70
</pre>

<p><i>Note: It is possible to have even the reference members copied automatically. We will see how this is done later when covering struct member functions.</i>
</p>

<h5 class="subsection"><a id="ix_Structs.literal, struct" content="literal, struct"></a> Struct literals</h5>

<p>Similar to being able to use integer literal values like 10 in expressions without needing to define a variable, struct objects can be used as literals as well.
</p>

<p>Struct literals are constructed by the object construction syntax.
</p>

<pre class="d_code">    TimeOfDay(8, 30) <span class="d_comment">// ← struct literal value
</span></pre>

<p>Let's first rewrite the <code class="d_inline">main()</code> function above with what we have learned since its last version. The variables are constructed by the construction syntax and are <code class="d_inline">immutable</code> this time:
</p>

<pre class="d_code"><span class="d_keyword">void</span> main() {
    <span class="d_keyword">immutable</span> periodStart = TimeOfDay(8, 30);
    <span class="d_keyword">immutable</span> periodDuration = TimeOfDay(1, 15);

    <span class="d_keyword">immutable</span> periodEnd = addDuration(periodStart,
                                      periodDuration);

    writefln(<span class="d_string">"Period end: %s:%s"</span>,
              periodEnd.hour, periodEnd.minute);
}
</pre>

<p>Note that <code class="d_inline">periodStart</code> and <code class="d_inline">periodDuration</code> need not be defined as named variables in the code above. Those are in fact temporary variables in this simple program, which are used only for calculating the <code class="d_inline">periodEnd</code> variable. They could be passed to <code class="d_inline">addDuration()</code> as literal values instead:
</p>

<pre class="d_code"><span class="d_keyword">void</span> main() {
    <span class="d_keyword">immutable</span> periodEnd = addDuration(TimeOfDay(8, 30),
                                      TimeOfDay(1, 15));

    writefln(<span class="d_string">"Period end: %s:%s"</span>,
              periodEnd.hour, periodEnd.minute);
}
</pre>

<h5 class="subsection"><a id="ix_Structs.static, member" content="static, member"></a> <code class="d_inline">static</code> members</h5>

<p>Although objects mostly need individual copies of the struct's members, sometimes it makes sense for the objects of a particular struct type to share some variables. This may be necessary to maintain e.g. a general information about that struct type.
</p>

<p>As an example, let's imagine a type that assigns a separate identifier for every object that is constructed of that type:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point {
    <span class="d_comment">// The identifier of each object
</span>    size_t id;

    <span class="d_keyword">int</span> line;
    <span class="d_keyword">int</span> column;
}
</pre>

<p>In order to be able to assign different ids to each object, a separate variable is needed to keep the next available id. It would be incremented every time a new object is created. Assume that <code class="d_inline">nextId</code> is to be defined elsewhere and to be available in the following function:
</p>

<pre class="d_code">Point makePoint(<span class="d_keyword">int</span> line, <span class="d_keyword">int</span> column) {
    size_t id = nextId;
    ++nextId;

    <span class="d_keyword">return</span> Point(id, line, column);
}
</pre>

<p>A decision must be made regarding where the common <code class="d_inline">nextId</code> variable is to be defined. <code class="d_inline">static</code> members are useful in such cases.
</p>

<p>Such common information is defined as a <code class="d_inline">static</code> member of the struct. Contrary to the regular members, there is a single variable of each <code class="d_inline">static</code> member for each thread. (Note that most programs consist of a single thread that starts executing the <code class="d_inline">main()</code> function.) That single variable is shared by all of the objects of that struct in that thread:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> Point {
    <span class="d_comment">// The identifier of each object
</span>    size_t id;

    <span class="d_keyword">int</span> line;
    <span class="d_keyword">int</span> column;

    <span class="d_comment">// The id of the next object to construct
</span>    <span class="hilite"><span class="d_keyword">static</span> size_t nextId;</span>
}

Point makePoint(<span class="d_keyword">int</span> line, <span class="d_keyword">int</span> column) {
    size_t id = <span class="hilite">Point.</span>nextId;
    ++<span class="hilite">Point.</span>nextId;

    <span class="d_keyword">return</span> Point(id, line, column);
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> top = makePoint(7, 0);
    <span class="d_keyword">auto</span> middle = makePoint(8, 0);
    <span class="d_keyword">auto</span> bottom =  makePoint(9, 0);

    writeln(top.id);
    writeln(middle.id);
    writeln(bottom.id);
}
</pre>

<p>As <code class="d_inline">nextId</code> is incremented at each object construction, each object gets a unique id:
</p>

<pre class="shell">0
1
2
</pre>

<p>Since <code class="d_inline">static</code> members are owned by the entire type, there need not be an object to access them. As we have seen above, such objects can be accessed by the name of the type, as well as by the name of any object of that struct:
</p>

<pre class="d_code">    ++Point.nextId;
    ++<span class="hilite">bottom</span>.nextId;    <span class="d_comment">// would be the same as above
</span></pre>

<p>When a variable is needed not <i>one per thread</i> but <i>one per program</i>, then those variables must be defined as <code class="d_inline">shared static</code>. We will see the <code class="d_inline">shared</code> keyword in a later chapter.
</p>

<h6><a id="ix_Structs.static this, struct" content="static this, struct"></a> <a id="ix_Structs.static ~this, struct" content="static ~this, struct"></a> <a id="ix_Structs.this, static, struct" content="this, static, struct"></a> <a id="ix_Structs.~this, static, struct" content="~this, static, struct"></a> <code class="d_inline">static&nbsp;this()</code> for initialization and <code class="d_inline">static&nbsp;~this()</code> for finalization</h6>

<p>Instead of explicitly assigning an initial value to <code class="d_inline">nextId</code> above, we relied on its default initial value, zero. We could have used any other value:
</p>

<pre class="d_code">    <span class="d_keyword">static</span> size_t nextId <span class="hilite">= 1000</span>;
</pre>

<p>However, such initialization is possible only when the initial value is known at compile time. Further, some special code may have to be executed before a struct can be used in a thread. Such code is written in <code class="d_inline">static this()</code> scopes.
</p>

<p>For example, the following code reads the initial value from a file if that file exists:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.file;

<span class="d_keyword">struct</span> Point {
<span class="d_comment">// ...
</span>
    <span class="d_keyword">enum</span> nextIdFile = <span class="d_string">"Point_next_id_file"</span>;

    <span class="hilite"><span class="d_keyword">static</span> <span class="d_keyword">this</span>()</span> {
        <span class="d_keyword">if</span> (exists(nextIdFile)) {
            <span class="d_keyword">auto</span> file = File(nextIdFile, <span class="d_string">"r"</span>);
            file.readf(<span class="d_string">" %s"</span>, &amp;nextId);
        }
    }
}
</pre>

<p>The contents of <code class="d_inline">static this()</code> blocks are automatically executed once per thread before the <code class="d_inline">struct</code> type is ever used in that thread. Code that should be executed only once for the entire program (e.g. initializing <code class="d_inline">shared</code> and <code class="d_inline">immutable</code> variables) must be defined in <code class="d_inline">shared static this()</code> and <code class="d_inline">shared static ~this()</code> blocks, which will be covered in <a href="concurrency_shared.html">the Data Sharing Concurrency chapter</a>.
</p>

<p>Similarly, <code class="d_inline">static ~this()</code> is for the final operations of a thread and <code class="d_inline">shared static ~this()</code> is for the final operations of the entire program.
</p>

<p>The following example complements the previous <code class="d_inline">static this()</code> by writing the value of <code class="d_inline">nextId</code> to the same file, effectively persisting the object ids over consecutive executions of the program:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point {
<span class="d_comment">// ...
</span>
    <span class="hilite"><span class="d_keyword">static</span> ~<span class="d_keyword">this</span>()</span> {
        <span class="d_keyword">auto</span> file = File(nextIdFile, <span class="d_string">"w"</span>);
        file.writeln(nextId);
    }
}
</pre>

<p>The program would now initialize <code class="d_inline">nextId</code> from where it was left off. For example, the following would be the output of the program's second execution:
</p>

<pre class="shell">3
4
5
</pre>

<h5 class="subsection">Problemler</h5>
    <ol>
<li>Design a struct named <code class="d_inline">Card</code> to represent a playing card.

<p>This struct can have two members for the suit and the value. It may make sense to use an <code class="d_inline">enum</code> to represent the suit, or you can simply use the characters ♠, ♡, ♢, and ♣.
</p>

<p>An <code class="d_inline">int</code> or a <code class="d_inline">dchar</code> value can be used for the card value. If you decide to use an <code class="d_inline">int</code>, the values 1, 11, 12, and 13 may represent the cards that do not have numbers (ace, jack, queen, and king).
</p>

<p>There are other design choices to make. For example, the card values can be represented by an <code class="d_inline">enum</code> type as well.
</p>

<p>The way objects of this struct will be constructed will depend on the choice of the types of its members. For example, if both members are <code class="d_inline">dchar</code>, then <code class="d_inline">Card</code> objects can be constructed like this:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> card = Card('♣', '2');
</pre>

</li>

<li>Define a function named <code class="d_inline">printCard()</code>, which takes a <code class="d_inline">Card</code> object as a parameter and simply prints it:

<pre class="d_code"><span class="d_keyword">struct</span> Card {
    <span class="d_comment">// ... please define the struct ...
</span>}

<span class="d_keyword">void</span> printCard(Card card) {
    <span class="d_comment">// ... please define the function body ...
</span>}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> card = Card(<span class="d_comment">/* ... */</span>);
    printCard(card);
}
</pre>

<p>For example, the function can print the 2 of clubs as:
</p>

<pre class="shell">♣2
</pre>

<p>The implementation of that function may depend on the choice of the types of the members.
</p>

</li>

<li>Define a function named <code class="d_inline">newDeck()</code> and have it return 52 cards of a deck as a <code class="d_inline">Card</code> slice:

<pre class="d_code">Card[] newDeck()
<span class="d_keyword">out</span> (result) {
    <span class="d_keyword">assert</span>(result.length == 52);

} <span class="d_keyword">do</span> {
    <span class="d_comment">// ... please define the function body ...
</span>}
</pre>

<p>It should be possible to call <code class="d_inline">newDeck()</code> as in the following code:
</p>

<pre class="d_code">    Card[] deck = newDeck();

    <span class="d_keyword">foreach</span> (card; deck) {
        printCard(card);
        write(' ');
    }

    writeln();
</pre>

<p>The output should be similar to the following with 52 distinct cards:
</p>

<pre class="shell">♠2 ♠3 ♠4 ♠5 ♠6 ♠7 ♠8 ♠9 ♠0 ♠J ♠Q ♠K ♠A ♡2 ♡3 ♡4
♡5 ♡6 ♡7 ♡8 ♡9 ♡0 ♡J ♡Q ♡K ♡A ♢2 ♢3 ♢4 ♢5 ♢6 ♢7
♢8 ♢9 ♢0 ♢J ♢Q ♢K ♢A ♣2 ♣3 ♣4 ♣5 ♣6 ♣7 ♣8 ♣9 ♣0
♣J ♣Q ♣K ♣A
</pre>

</li>

<li>Write a function that shuffles the deck. One way is to pick two cards at random by <code class="d_inline">std.random.uniform</code>, to swap those two cards, and to repeat this process a sufficient number of times. The function should take the number of repetition as a parameter:

<pre class="d_code"><span class="d_keyword">void</span> shuffle(Card[] deck, <span class="d_keyword">int</span> repetition) {
    <span class="d_comment">// ... please define the function body ...
</span>}
</pre>

<p>Here is how it should be used:
</p>

<pre class="d_code">    Card[] deck = newDeck();
    shuffle(deck, 1);

    <span class="d_keyword">foreach</span> (card; deck) {
        printCard(card);
        write(' ');
    }

    writeln();
</pre>

<p>The function should swap cards <code class="d_inline">repetition</code> number of times. For example, when called by 1, the output should be similar to the following:
</p>

<pre class="shell">♠2 ♠3 ♠4 ♠5 ♠6 ♠7 ♠8 ♠9 ♠0 ♠J ♠Q ♠K ♠A ♡2 ♡3 ♡4
♡5 ♡6 ♡7 ♡8 <span class="hilite">♣4</span> ♡0 ♡J ♡Q ♡K ♡A ♢2 ♢3 ♢4 ♢5 ♢6 ♢7
♢8 ♢9 ♢0 ♢J ♢Q ♢K ♢A ♣2 ♣3 <span class="hilite">♡9</span> ♣5 ♣6 ♣7 ♣8 ♣9 ♣0
♣J ♣Q ♣K ♣A
</pre>

<p>A higher value for <code class="d_inline">repetition</code> should result in a more shuffled deck:
</p>

<pre class="d_code">    shuffled(deck, <span class="hilite">100</span>);
</pre>

<p>The output:
</p>

<pre class="shell">♠4 ♣7 ♢9 ♢6 ♡2 ♠6 ♣6 ♢A ♣5 ♢8 ♢3 ♡Q ♢J ♣K ♣8 ♣4
♡J ♣Q ♠Q ♠9 ♢0 ♡A ♠A ♡9 ♠7 ♡3 ♢K ♢2 ♡0 ♠J ♢7 ♡7
♠8 ♡4 ♣J ♢4 ♣0 ♡6 ♢5 ♡5 ♡K ♠3 ♢Q ♠2 ♠5 ♣2 ♡8 ♣A
♠K ♣9 ♠0 ♣3
</pre>

<p><i><b>Note:</b> A much better way of shuffling the deck is explained in the solutions.</i>
</p>

</li>

</ol> <div class="cozum_link_cok"><p><a target="ddili_cozum" href="struct.cozum.html"><i>... çözümler</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Apr  1 20:41:04 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

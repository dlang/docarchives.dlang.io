
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Inheritance - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Inheritance' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BInheritance%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/inheritance.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Inheritance</h1>
        
        



<p>Inheritance is defining a more specialized type based on an existing more general base type. The specialized type acquires the members of the base type and as a result can be substituted in place of the base type.
</p>

<p><a id="ix_Inheritance.superclass" content="superclass"></a> <a id="ix_Inheritance.subclass" content="subclass"></a> Inheritance is available for classes, not structs. The class that inherits another class is called the <i>subclass</i>, and the class that gets inherited is called the <i>superclass</i>, also called the <i>base class</i>.
</p>

<p>There are two types of inheritance in D. We will cover <i>implementation inheritance</i> in this chapter and leave <i>interface inheritance</i> to a later chapter.
</p>

<p><a id="ix_Inheritance.:, inheritance" content=":, inheritance"></a> When defining a subclass, the superclass is specified after a colon character:
</p>

<pre class="d_code"><span class="d_keyword">class</span> <i>SubClass</i> : <i>SuperClass</i> {
    <span class="d_comment">// ...
</span>}
</pre>

<p>To see an example of this, let's assume that there is already the following class that represents a clock:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    <span class="d_keyword">int</span> hour;
    <span class="d_keyword">int</span> minute;
    <span class="d_keyword">int</span> second;

    <span class="d_keyword">void</span> adjust(<span class="d_keyword">int</span> hour, <span class="d_keyword">int</span> minute, <span class="d_keyword">int</span> second = 0) {
        <span class="d_keyword">this</span>.hour = hour;
        <span class="d_keyword">this</span>.minute = minute;
        <span class="d_keyword">this</span>.second = second;
    }
}
</pre>

<p>Apparently, the members of that class do not need special values during construction; so there is no constructor. Instead, the members are set by the <code class="d_inline">adjust()</code> member function:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> deskClock = <span class="d_keyword">new</span> Clock;
    deskClock.adjust(20, 30);
    writefln(
        <span class="d_string">"%02s:%02s:%02s"</span>,
        deskClock.hour, deskClock.minute, deskClock.second);
</pre>

<p><i><b>Note:</b> It would be more useful to produce the time string by a <code class="d_inline">toString()</code> function. It will be added later when explaining the <code class="d_inline">override</code> keyword below.</i>
</p>

<p>The output:
</p>

<pre class="shell">20:30:00
</pre>

<p>With only that much functionality, <code class="d_inline">Clock</code> could be a struct as well, and depending on the needs of the program, that could be sufficient.
</p>

<p>However, being a class makes it possible to inherit from <code class="d_inline">Clock</code>.
</p>

<p>To see an example of inheritance, let's consider an <code class="d_inline">AlarmClock</code> that not only includes all of the functionality of <code class="d_inline">Clock</code>, but also provides a way of setting the alarm. Let's first define this type without regard to <code class="d_inline">Clock</code>. If we did that, we would have to include the same three members of <code class="d_inline">Clock</code> and the same <code class="d_inline">adjust()</code> function that adjusted them. <code class="d_inline">AlarmClock</code> would also have other members for its additional functionality:
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock {
    <span class="hilite"><span class="d_keyword">int</span> hour;</span>
    <span class="hilite"><span class="d_keyword">int</span> minute;</span>
    <span class="hilite"><span class="d_keyword">int</span> second;</span>
    <span class="d_keyword">int</span> alarmHour;
    <span class="d_keyword">int</span> alarmMinute;

    <span class="hilite"><span class="d_keyword">void</span> adjust(<span class="d_keyword">int</span> hour, <span class="d_keyword">int</span> minute, <span class="d_keyword">int</span> second = 0) {</span>
        <span class="hilite"><span class="d_keyword">this</span>.hour = hour;</span>
        <span class="hilite"><span class="d_keyword">this</span>.minute = minute;</span>
        <span class="hilite"><span class="d_keyword">this</span>.second = second;</span>
    <span class="hilite">}</span>

    <span class="d_keyword">void</span> adjustAlarm(<span class="d_keyword">int</span> hour, <span class="d_keyword">int</span> minute) {
        alarmHour = hour;
        alarmMinute = minute;
    }
}
</pre>

<p>The members that appear exactly in <code class="d_inline">Clock</code> are highlighted. As can be seen, defining <code class="d_inline">Clock</code> and <code class="d_inline">AlarmClock</code> separately results in code duplication.
</p>

<p>Inheritance is helpful in such cases. Inheriting <code class="d_inline">AlarmClock</code> from <code class="d_inline">Clock</code> simplifies the new class and reduces code duplication:
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock <span class="hilite">: Clock</span> {
    <span class="d_keyword">int</span> alarmHour;
    <span class="d_keyword">int</span> alarmMinute;

    <span class="d_keyword">void</span> adjustAlarm(<span class="d_keyword">int</span> hour, <span class="d_keyword">int</span> minute) {
        alarmHour = hour;
        alarmMinute = minute;
    }
}
</pre>

<p>The new definition of <code class="d_inline">AlarmClock</code> is the equivalent of the previous one. The highlighted part of the new definition corresponds to the highlighted parts of the old definition.
</p>

<p>Because <code class="d_inline">AlarmClock</code> inherits the members of <code class="d_inline">Clock</code>, it can be used just like a <code class="d_inline">Clock</code>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> bedSideClock = <span class="d_keyword">new</span> AlarmClock;
    bedSideClock.<span class="hilite">adjust(20, 30)</span>;
    bedSideClock.adjustAlarm(7, 0);
</pre>

<p>The members that are inherited from the superclass can be accessed as if they were the members of the subclass:
</p>

<pre class="d_code">    writefln(<span class="d_string">"%02s:%02s:%02s ♫%02s:%02s"</span>,
             bedSideClock<span class="hilite">.hour</span>,
             bedSideClock<span class="hilite">.minute</span>,
             bedSideClock<span class="hilite">.second</span>,
             bedSideClock.alarmHour,
             bedSideClock.alarmMinute);
</pre>

<p>The output:
</p>

<pre class="shell">20:30:00 ♫07:00
</pre>

<p><i><b>Note:</b> An <code class="d_inline">AlarmClock.toString</code> function would be more useful in this case. It will be defined later below.</i>
</p>

<p>The inheritance used in this example is <i>implementation inheritance.</i>
</p>

<p>If we imagine the memory as a ribbon going from top to bottom, the placement of the members of <code class="d_inline">AlarmClock</code> in memory can be pictured as in the following illustration:
</p>

<pre class="mono">                            │      .      │
                            │      .      │
the address of the object → ├─────────────┤
                            │<span style="color:gray"><i>(other data)</i></span> │
                            │<span class="hilite">&nbsp;hour        </span>│
                            │<span class="hilite">&nbsp;minute      </span>│
                            │<span class="hilite">&nbsp;second      </span>│
                            │ alarmHour   │
                            │ alarmMinute │
                            ├─────────────┤
                            │      .      │
                            │      .      │
</pre>

<p><a id="ix_Inheritance.vtbl" content="vtbl"></a> The illustration above is just to give an idea on how the members of the superclass and the subclass may be combined together. The actual layout of the members depends on the implementation details of the compiler in use. For example, the part that is marked as <i>other data</i> typically includes the pointer to the <i>virtual function table</i> (vtbl) of that particular class type. The details of the object layout are outside the scope of this book.
</p>

<h5 class="subsection"><a id="ix_Inheritance.is-a" content="is-a"></a> Warning: Inherit only if "is a"</h5>

<p>We have seen that implementation inheritance is about acquiring members. Consider this kind of inheritance only if the subtype can be thought of being a kind of the supertype as in the phrase "alarm clock <i>is a</i> clock."
</p>

<p><a id="ix_Inheritance.has-a" content="has-a"></a> "Is a" is not the only relationship between types; a more common relationship is the "has a" relationship. For example, let's assume that we want to add the concept of a <code class="d_inline">Battery</code> to the <code class="d_inline">Clock</code> class. It would not be appropriate to add <code class="d_inline">Battery</code> to <code class="d_inline">Clock</code> by inheritance because the statement "clock is a battery" is not true:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock : Battery {    <span class="d_comment">// ← <span class="code_note_wrong">WRONG DESIGN</span></span>
    <span class="d_comment">// ...
</span>}
</pre>

<p>A clock is not a battery; it <i>has a</i> battery. When there is such a relationship of containment, the type that is contained must be defined as a member of the type that contains it:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    Battery battery;       <span class="d_comment">// ← Correct design</span>
    <span class="d_comment">// ...
</span>}
</pre>

<h5 class="subsection"><a id="ix_Inheritance.single inheritance" content="single inheritance"></a> <a id="ix_Inheritance.inheritance, single" content="inheritance, single"></a> <a id="ix_Inheritance.hierarchy" content="hierarchy"></a> Inheritance from at most one class</h5>

<p>Classes can only inherit from a single base class (which itself can potentially inherit from another single class). In other words, multiple inheritance is not supported in D.
</p>

<p>For example, assuming that there is also a <code class="d_inline">SoundEmitter</code> class, and even though "alarm clock is a sound emitting object" is also true, it is not possible to inherit <code class="d_inline">AlarmClock</code> both from <code class="d_inline">Clock</code> and <code class="d_inline">SoundEmitter</code>:
</p>

<pre class="d_code"><span class="d_keyword">class</span> SoundEmitter {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> AlarmClock : Clock<span class="hilite">, SoundEmitter</span> {    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    <span class="d_comment">// ...
</span>}
</pre>

<p>On the other hand, there is no limit to the number of <i>interfaces</i> that a class can inherit from. We will see the <code class="d_inline">interface</code> keyword in a later chapter.
</p>

<p>Additionally, there is no limit to how deep the inheritance hierarchy can go:
</p>

<pre class="d_code"><span class="d_keyword">class</span> MusicalInstrument {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> StringInstrument : MusicalInstrument {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> Violin : StringInstrument {
    <span class="d_comment">// ...
</span>}
</pre>

<p>The inheritance hierarchy above defines a relationship from the more general to the more specific: musical instrument, string instrument, and violin.
</p>

<h5 class="subsection">Hierarchy charts</h5>

<p>Types that are related by the "is a" relationship form a <i>class hierarchy</i>.
</p>

<p>According to OOP conventions, class hierarchies are represented by superclasses being on the top and the subclasses being at the bottom. The inheritance relationships are indicated by arrows pointing from the subclasses to the superclasses.
</p>

<p>For example, the following can be a hierarchy of musical instruments:
</p>

<pre class="mono">             MusicalInstrument
                ↗         ↖
    StringInstrument   WindInstrument
         ↗    ↖            ↗    ↖
     Violin  Guitar    Flute   Recorder
</pre>

<h5 class="subsection"><a id="ix_Inheritance.super, member access" content="super, member access"></a> Accessing superclass members</h5>

<p>The <code class="d_inline">super</code> keyword allows referring to members that are inherited from the superclass.
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_comment">// ...
</span>
    <span class="d_keyword">void</span> foo() {
        <span class="d_keyword">super</span>.minute = 10; <span class="d_comment">// The inherited 'minute' member
</span>        minute = 10;       <span class="d_comment">// Same thing if there is no ambiguity
</span>    }
}
</pre>

<p>The <code class="d_inline">super</code> keyword is not always necessary; <code class="d_inline">minute</code> alone has the same meaning in the code above. The <code class="d_inline">super</code> keyword is needed when both the superclass and the subclass have members under the same names. We will see this below when we will need to write <code class="d_inline">super.reset()</code> and <code class="d_inline">super.toString()</code>.
</p>

<p>If multiple classes in an inheritance tree define a symbol with the same name, one can use the specific name of the class in the inheritance tree to disambiguate between the symbols:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Device {
    string <span class="hilite">manufacturer</span>;
}

<span class="d_keyword">class</span> Clock : Device {
    string <span class="hilite">manufacturer</span>;
}

<span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_comment">// ...
</span>
    <span class="d_keyword">void</span> foo() {
        <span class="hilite">Device.</span>manufacturer = <span class="d_string">"Sunny Horology, Inc."</span>;
        <span class="hilite">Clock.</span>manufacturer = <span class="d_string">"Better Watches, Ltd."</span>;
    }
}
</pre>

<h5 class="subsection"><a id="ix_Inheritance.super, construction" content="super, construction"></a> Constructing superclass members</h5>

<p>The other use of the <code class="d_inline">super</code> keyword is to call the constructor of the superclass. This is similar to calling the overloaded constructors of the current class: <code class="d_inline">this</code> when calling constructors of the current class and <code class="d_inline">super</code> when calling constructors of the superclass.
</p>

<p>It is not required to call the superclass constructor explicitly. If the constructor of the subclass makes an explicit call to any overload of <code class="d_inline">super</code>, then that constructor is executed by that call. Otherwise, and if the superclass has a default constructor, it is executed automatically before entering the body of the subclass.
</p>

<p>We have not defined constructors for the <code class="d_inline">Clock</code> and <code class="d_inline">AlarmClock</code> classes yet. For that reason, the members of both of those classes are initialized by the <code class="d_inline">.init</code> values of their respective types, which is 0 for <code class="d_inline">int</code>.
</p>

<p>Let's assume that <code class="d_inline">Clock</code> has the following constructor:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> hour, <span class="d_keyword">int</span> minute, <span class="d_keyword">int</span> second) {
        <span class="d_keyword">this</span>.hour = hour;
        <span class="d_keyword">this</span>.minute = minute;
        <span class="d_keyword">this</span>.second = second;
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>That constructor must be used when constructing <code class="d_inline">Clock</code> objects:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> clock = <span class="d_keyword">new</span> Clock(17, 15, 0);
</pre>

<p>Naturally, the programmers who use the <code class="d_inline">Clock</code> type directly would have to use that syntax. However, when constructing an <code class="d_inline">AlarmClock</code> object, they cannot construct its <code class="d_inline">Clock</code> part separately. Besides, the users of <code class="d_inline">AlarmClock</code> need not even know that it inherits from <code class="d_inline">Clock</code>.
</p>

<p>A user of <code class="d_inline">AlarmClock</code> should simply construct an <code class="d_inline">AlarmClock</code> object and use it in the program without needing to pay attention to its <code class="d_inline">Clock</code> heritage:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> bedSideClock = <span class="d_keyword">new</span> AlarmClock(<span class="d_comment">/* ... */</span>);
    <span class="d_comment">// ... use as an AlarmClock ...
</span></pre>

<p>For that reason, constructing the superclass part is the responsibility of the subclass. The subclass calls the constructor of the superclass with the <code class="d_inline">super()</code> syntax:
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> hour, <span class="d_keyword">int</span> minute, <span class="d_keyword">int</span> second,  <span class="d_comment">// for Clock's members
</span>         <span class="d_keyword">int</span> alarmHour, <span class="d_keyword">int</span> alarmMinute) {  <span class="d_comment">// for AlarmClock's members
</span>        <span class="hilite"><span class="d_keyword">super</span></span>(hour, minute, second);
        <span class="d_keyword">this</span>.alarmHour = alarmHour;
        <span class="d_keyword">this</span>.alarmMinute = alarmMinute;
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>The constructor of <code class="d_inline">AlarmClock</code> takes arguments for both its own members and the members of its superclass. It then uses part of those arguments to construct its superclass part.
</p>

<h5 class="subsection"><a id="ix_Inheritance.override" content="override"></a> Overriding the definitions of member functions</h5>

<p>One of the benefits of inheritance is being able to redefine the member functions of the superclass in the subclass. This is called <i>overriding</i>: The existing definition of the member function of the superclass is overridden by the subclass with the <code class="d_inline">override</code> keyword.
</p>

<p><a id="ix_Inheritance.virtual function" content="virtual function"></a> Overridable functions are called <i>virtual functions</i>. Virtual functions are implemented by the compiler through <i>virtual function pointer tables</i> (vtbl) and <i>vtbl pointers</i>. The details of this mechanism are outside the scope of this book. However, it must be known by every system programmer that virtual function calls are more expensive than regular function calls. Every non-private <code class="d_inline">class</code> member function in D is virtual by default. For that reason, when a superclass function does not need to be overridden at all, it should be defined as <code class="d_inline">final</code> so that it is not virtual. We will see the <code class="d_inline">final</code> keyword later in <a href="interface.html">the Interfaces chapter</a>.
</p>

<p>Let's assume that <code class="d_inline">Clock</code> has a member function that is used for resetting its members all to zero:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Clock {
    <span class="d_keyword">void</span> reset() {
        hour = 0;
        minute = 0;
        second = 0;
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>That function is inherited by <code class="d_inline">AlarmClock</code> and can be called on an <code class="d_inline">AlarmClock</code> object:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> bedSideClock = <span class="d_keyword">new</span> AlarmClock(20, 30, 0, 7, 0);
    <span class="d_comment">// ...
</span>    bedSideClock.reset();
</pre>

<p>However, necessarily ignorant of the members of <code class="d_inline">AlarmClock</code>, <code class="d_inline">Clock.reset</code> can only reset its own members. For that reason, to reset the members of the subclass as well, <code class="d_inline">reset()</code> must be overridden:
</p>

<pre class="d_code"><span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="hilite"><span class="d_keyword">override</span></span> <span class="d_keyword">void</span> reset() {
        <span class="d_keyword">super</span>.reset();
        alarmHour = 0;
        alarmMinute = 0;
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>The subclass resets only its own members and dispatches the rest of the task to <code class="d_inline">Clock</code> by the <code class="d_inline">super.reset()</code> call. Note that writing just <code class="d_inline">reset()</code> would not work as it would call the <code class="d_inline">reset()</code> function of <code class="d_inline">AlarmClock</code> itself. Calling <code class="d_inline">reset()</code> from within itself would cause an infinite recursion.
</p>

<p>The reason that I have delayed the definition of <code class="d_inline">toString()</code> until this point is that it must be defined by the <code class="d_inline">override</code> keyword for classes. As we will see in the next chapter, every class is automatically inherited from a superclass called <code class="d_inline">Object</code> and <code class="d_inline">Object</code> already defines a <code class="d_inline">toString()</code> member function.
</p>

<p>For that reason, the <code class="d_inline">toString()</code> member function for classes must be defined by using the <code class="d_inline">override</code> keyword:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.string;

<span class="d_keyword">class</span> Clock {
    <span class="hilite"><span class="d_keyword">override</span></span> string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"%02s:%02s:%02s"</span>, hour, minute, second);
    }

    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> AlarmClock : Clock {
    <span class="hilite"><span class="d_keyword">override</span></span> string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"%s ♫%02s:%02s"</span>, <span class="d_keyword">super</span>.toString(),
                      alarmHour, alarmMinute);
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>Note that <code class="d_inline">AlarmClock</code> is again dispatching some of the task to <code class="d_inline">Clock</code> by the <code class="d_inline">super.toString()</code> call.
</p>

<p>Those two overrides of <code class="d_inline">toString()</code> allow converting <code class="d_inline">AlarmClock</code> objects to strings:
</p>

<pre class="d_code"><span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> deskClock = <span class="d_keyword">new</span> AlarmClock(10, 15, 0, 6, 45);
    writeln(<span class="hilite">deskClock</span>);
}
</pre>

<p>The output:
</p>

<pre class="shell">10:15:00 ♫06:45
</pre>

<h5 class="subsection"><a id="ix_Inheritance.polymorphism, run-time" content="polymorphism, run-time"></a> <a id="ix_Inheritance.run-time polymorphism" content="run-time polymorphism"></a> Using the subclass in place of the superclass</h5>

<p>Since the superclass is more <i>general</i> and the subclass is more <i>specialized</i>, objects of a subclass can be used in places where an object of the superclass type is required. This is called <i>polymorphism</i>.
</p>

<p>The concepts of general and specialized types can be seen in statements like "this type is of that type": "alarm clock is a clock", "student is a person", "cat is an animal", etc. Accordingly, an alarm clock can be used where a clock is needed, a student can be used where a person is needed, and a cat can be used where an animal is needed.
</p>

<p>When a subclass object is being used as a superclass object, it does not lose its own specialized type. This is similar to the examples in real life: Using an alarm clock simply as a clock does not change the fact that it is an alarm clock; it would still behave like an alarm clock.
</p>

<p>Let's assume that a function takes a <code class="d_inline">Clock</code> object as parameter, which it resets at some point during its execution:
</p>

<pre class="d_code"><span class="d_keyword">void</span> use(Clock clock) {
    <span class="d_comment">// ...
</span>    clock.reset();
    <span class="d_comment">// ...
</span>}
</pre>

<p>Polymorphism makes it possible to send an <code class="d_inline">AlarmClock</code> to such a function:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> deskClock = <span class="d_keyword">new</span> AlarmClock(10, 15, 0, 6, 45);
    writeln(<span class="d_string">"Before: "</span>, deskClock);
    <span class="hilite">use(deskClock)</span>;
    writeln(<span class="d_string">"After : "</span>, deskClock);
</pre>

<p>This is in accordance with the relationship "alarm clock is a clock." As a result, the members of the <code class="d_inline">deskClock</code> object get reset:
</p>

<pre class="shell">Before: 10:15:00 ♫06:45
After : 00:00:00 ♫<span class="hilite">00:00</span>
</pre>

<p>The important observation here is that not only the members of <code class="d_inline">Clock</code> but also the members of <code class="d_inline">AlarmClock</code> have been reset.
</p>

<p>Although <code class="d_inline">use()</code> calls <code class="d_inline">reset()</code> on a <code class="d_inline">Clock</code> object, since the actual object is an <code class="d_inline">AlarmClock</code>, the function that gets called is <code class="d_inline">AlarmClock.reset</code>. According to its definition above, <code class="d_inline">AlarmClock.reset</code> resets the members of both <code class="d_inline">Clock</code> and <code class="d_inline">AlarmClock</code>.
</p>

<p>In other words, although <code class="d_inline">use()</code> uses the object as a <code class="d_inline">Clock</code>, the actual object may be an inherited type that behaves in its own special way.
</p>

<p>Let's add another class to the <code class="d_inline">Clock</code> hierarchy. The <code class="d_inline">reset()</code> function of this type sets its members to random values:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.random;

<span class="d_keyword">class</span> BrokenClock : Clock {
    <span class="d_keyword">this</span>() {
        <span class="d_keyword">super</span>(0, 0, 0);
    }

    <span class="d_keyword">override</span> <span class="d_keyword">void</span> reset() {
        hour = uniform(0, 24);
        minute = uniform(0, 60);
        second = uniform(0, 60);
    }
}
</pre>

<p>When an object of <code class="d_inline">BrokenClock</code> is sent to <code class="d_inline">use()</code>, then the special <code class="d_inline">reset()</code> function of <code class="d_inline">BrokenClock</code> would be called. Again, although it is passed as a <code class="d_inline">Clock</code>, the actual object is still a <code class="d_inline">BrokenClock</code>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> shelfClock = <span class="d_keyword">new</span> BrokenClock;
    use(shelfClock);
    writeln(shelfClock);
</pre>

<p>The output shows random time values as a result of resetting a <code class="d_inline">BrokenClock</code>:
</p>

<pre class="shell">22:46:37
</pre>

<h5 class="subsection">Inheritance is transitive</h5>

<p>Polymorphism is not just limited to two classes. Subclasses of subclasses can also be used in place of any superclass in the hierarchy.
</p>

<p>Let's consider the <code class="d_inline">MusicalInstrument</code> hierarchy:
</p>

<pre class="d_code"><span class="d_keyword">class</span> MusicalInstrument {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> StringInstrument : MusicalInstrument {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> Violin : StringInstrument {
    <span class="d_comment">// ...
</span>}
</pre>

<p>The inheritances above builds the following relationships: "string instrument is a musical instrument" and "violin is a string instrument." Therefore, it is also true that "violin is a musical instrument." Consequently, a <code class="d_inline">Violin</code> object can be used in place of a <code class="d_inline">MusicalInstrument</code>.
</p>

<p>Assuming that all of the supporting code below has also been defined:
</p>

<pre class="d_code"><span class="d_keyword">void</span> playInTune(MusicalInstrument instrument,
                MusicalPiece piece) {
    instrument.tune();
    instrument.play(piece);
}

<span class="d_comment">// ...
</span>
<span class="d_keyword">auto</span> myViolin = <span class="d_keyword">new</span> Violin;
playInTune(myViolin, improvisation);
</pre>

<p>Although <code class="d_inline">playInTune()</code> expects a <code class="d_inline">MusicalInstrument</code>, it is being called with a <code class="d_inline">Violin</code> due to the relationship "violin is a musical instrument."
</p>

<p>Inheritance can be as deep as needed.
</p>

<h5 class="subsection"><a id="ix_Inheritance.abstract" content="abstract"></a> Abstract member functions and abstract classes</h5>

<p>Sometimes there are member functions that are natural to appear in a class interface even though that class cannot provide its definition. When there is no <i>concrete</i> definition of a member function, that function is an <i>abstract</i> member function. A class that has at least one abstract member function is an abstract class.
</p>

<p>For example, the <code class="d_inline">ChessPiece</code> superclass in a hierarchy may have an <code class="d_inline">isValid()</code> member function that determines whether a given move is valid for that chess piece. Since validity of a move depends on the actual type of the chess piece, the <code class="d_inline">ChessPiece</code> general class cannot make this decision itself. The valid moves can only be known by the subclasses like <code class="d_inline">Pawn</code>, <code class="d_inline">King</code>, etc.
</p>

<p>The <code class="d_inline">abstract</code> keyword specifies that the inherited class must implement such a method itself:
</p>

<pre class="d_code"><span class="d_keyword">class</span> ChessPiece {
    <span class="hilite"><span class="d_keyword">abstract</span></span> <span class="d_keyword">bool</span> isValid(Square from, Square to);
}
</pre>

<p>It is not possible to construct objects of abstract classes:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> piece = <span class="d_keyword">new</span> ChessPiece;    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>The subclass would have to override and implement all the abstract functions in order to make the class non-abstract and therefore constructible:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Pawn : ChessPiece {
    <span class="d_keyword">override</span> <span class="d_keyword">bool</span> isValid(Square from, Square to) {
        <span class="d_comment">// ... the implementation of isValid for pawn ...
</span>        <span class="d_keyword">return</span> decision;
    }
}
</pre>

<p>It is now possible to construct objects of <code class="d_inline">Pawn</code>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> piece = <span class="d_keyword">new</span> Pawn;             <span class="d_comment">// compiles
</span></pre>

<p>Note that an abstract function may have an implementation of its own, but it would still require the subclass to provide its own implementation of such a function. For example, the <code class="d_inline">ChessPiece</code>'es implementation may provide some useful checks of its own:
</p>

<pre class="d_code"><span class="d_keyword">class</span> ChessPiece {
    <span class="hilite"><span class="d_keyword">abstract</span></span> <span class="d_keyword">bool</span> isValid(Square from, Square to) {
        <span class="d_comment">// We require the 'to' position to be different than
</span>        <span class="d_comment">// the 'from' position
</span>        <span class="d_keyword">return</span> from != to;
    }
}

<span class="d_keyword">class</span> Pawn : ChessPiece {
    <span class="d_keyword">override</span> <span class="d_keyword">bool</span> isValid(Square from, Square to) {
        <span class="d_comment">// First verify if it is a valid move for any ChessPiece
</span>        <span class="d_keyword">if</span> (!<span class="hilite"><span class="d_keyword">super</span>.isValid</span>(from, to)) {
            <span class="d_keyword">return</span> <span class="d_keyword">false</span>;
        }

        <span class="d_comment">// ... then check if it is valid for the Pawn ...
</span>
        <span class="d_keyword">return</span> decision;
    }
}
</pre>

<p>The <code class="d_inline">ChessPiece</code> class is still abstract even though <code class="d_inline">isValid()</code> was already implemented, but the <code class="d_inline">Pawn</code> class is non-abstract and can be instantiated.
</p>

<h5 class="subsection">Example</h5>

<p>Let's consider a class hierarchy that represents railway vehicles:
</p>

<pre class="mono">           RailwayVehicle
          /      |       \
  Locomotive   Train   RailwayCar { load()?, unload()? }
                          /   \
               PassengerCar   FreightCar
</pre>

<p>The functions that <code class="d_inline">RailwayCar</code> will declare as <code class="d_inline">abstract</code> are indicated by question marks.
</p>

<p>Since my goal is only to present a class hierarchy and point out some of its design decisions, I will not fully implement these classes. Instead of doing actual work, they will simply print messages.
</p>

<p>The most general class of the hierarchy above is <code class="d_inline">RailwayVehicle</code>. In this program, it will only know how to move itself:
</p>

<pre class="d_code"><span class="d_keyword">class</span> RailwayVehicle {
    <span class="d_keyword">void</span> advance(size_t kilometers) {
        writefln(<span class="d_string">"The vehicle is advancing %s kilometers"</span>,
                 kilometers);
    }
}
</pre>

<p>A class that inherits from <code class="d_inline">RailwayVehicle</code> is <code class="d_inline">Locomotive</code>, which does not have any special members yet:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Locomotive : RailwayVehicle {
}
</pre>

<p>We will add a special <code class="d_inline">makeSound()</code> member function to <code class="d_inline">Locomotive</code> later during one of the exercises.
</p>

<p><code class="d_inline">RailwayCar</code> is a <code class="d_inline">RailwayVehicle</code> as well. However, if the hierarchy supports different types of railway cars, then certain behaviors like loading and unloading must be done according to their exact types. For that reason, <code class="d_inline">RailwayCar</code> can only declare these two functions as abstract:
</p>

<pre class="d_code"><span class="d_keyword">class</span> RailwayCar : RailwayVehicle {
    <span class="hilite"><span class="d_keyword">abstract</span></span> <span class="d_keyword">void</span> load();
    <span class="hilite"><span class="d_keyword">abstract</span></span> <span class="d_keyword">void</span> unload();
}
</pre>

<p>Loading and unloading a passenger car is as simple as opening the doors of the car, while loading and unloading a freight car may involve porters and winches. The following subclasses provide definitions for the abstract functions of <code class="d_inline">RailwayCar</code>:
</p>

<pre class="d_code"><span class="d_keyword">class</span> PassengerCar : RailwayCar {
    <span class="d_keyword">override</span> <span class="d_keyword">void</span> load() {
        writeln(<span class="d_string">"The passengers are getting on"</span>);
    }

    <span class="d_keyword">override</span> <span class="d_keyword">void</span> unload() {
        writeln(<span class="d_string">"The passengers are getting off"</span>);
    }
}

<span class="d_keyword">class</span> FreightCar : RailwayCar {
    <span class="d_keyword">override</span> <span class="d_keyword">void</span> load() {
        writeln(<span class="d_string">"The crates are being loaded"</span>);
    }

    <span class="d_keyword">override</span> <span class="d_keyword">void</span> unload() {
        writeln(<span class="d_string">"The crates are being unloaded"</span>);
    }
}
</pre>

<p>Being an abstract class does not preclude the use of <code class="d_inline">RailwayCar</code> in the program. Objects of <code class="d_inline">RailwayCar</code> can not be constructed but <code class="d_inline">RailwayCar</code> can be used as an interface. As the subclasses define the two relationships "passenger car is a railway car" and "freight car is a railway car", the objects of <code class="d_inline">PassengerCar</code> and <code class="d_inline">FreightCar</code> can be used in places of <code class="d_inline">RailwayCar</code>. This will be seen in the <code class="d_inline">Train</code> class below.
</p>

<p>The class that represents a train can consist of a locomotive and an array of railwaycars:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Train : RailwayVehicle {
    Locomotive locomotive;
    RailwayCar[] cars;

    <span class="d_comment">// ...
</span>}
</pre>

<p>I would like to repeat an important point: Although both <code class="d_inline">Locomotive</code> and <code class="d_inline">RailwayCar</code> inherit from <code class="d_inline">RailwayVehicle</code>, it would not be correct to inherit <code class="d_inline">Train</code> from either of them. Inheritance models the "is a" relationship and a train is neither a locomotive nor a passenger car. A train consists of them.
</p>

<p>If we require that every train must have a locomotive, the <code class="d_inline">Train</code> constructor must ensure that it takes a valid <code class="d_inline">Locomotive</code> object. Similarly, if the railway cars are optional, they can be added by a member function:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.exception;
<span class="d_comment">// ...
</span>
<span class="d_keyword">class</span> Train : RailwayVehicle {
    <span class="d_comment">// ...
</span>
    <span class="d_keyword">this</span>(Locomotive locomotive) {
        enforce(locomotive !<span class="d_keyword">is</span> <span class="d_keyword">null</span>,
                <span class="d_string">"Locomotive cannot be null"</span>);
        <span class="d_keyword">this</span>.locomotive = locomotive;
    }

    <span class="d_keyword">void</span> addCar(RailwayCar[] cars...) {
        <span class="d_keyword">this</span>.cars ~= cars;
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>Note that <code class="d_inline">addCar()</code> can validate the <code class="d_inline">RailwayCar</code> objects as well. I am ignoring that validation here.
</p>

<p>We can imagine that the departures and arrivals of trains should also be supported:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Train : RailwayVehicle {
    <span class="d_comment">// ...
</span>
    <span class="d_keyword">void</span> departStation(string station) {
        <span class="d_keyword">foreach</span> (car; cars) {
            car.load();
        }

        writefln(<span class="d_string">"Departing from %s station"</span>, station);
    }

    <span class="d_keyword">void</span> arriveStation(string station) {
        writefln(<span class="d_string">"Arriving at %s station"</span>, station);

        <span class="d_keyword">foreach</span> (car; cars) {
            car.unload();
        }
    }
}
</pre>

<p>The following <code class="d_inline">main()</code> is making use of the <code class="d_inline">RailwayVehicle</code> hierarchy:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_comment">// ...
</span>
<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> locomotive = <span class="d_keyword">new</span> Locomotive;
    <span class="d_keyword">auto</span> train = <span class="d_keyword">new</span> Train(locomotive);

    train.addCar(<span class="d_keyword">new</span> PassengerCar, <span class="d_keyword">new</span> FreightCar);

    train.departStation(<span class="d_string">"Ankara"</span>);
    train.advance(500);
    train.arriveStation(<span class="d_string">"Haydarpaşa"</span>);
}
</pre>

<p>The <code class="d_inline">Train</code> class is being used by functions that are provided by two separate interfaces:
</p>

<ol>
<li>When the <code class="d_inline">advance()</code> function is called, the <code class="d_inline">Train</code> object is being used as a <code class="d_inline">RailwayVehicle</code> because that function is declared by <code class="d_inline">RailwayVehicle</code>.
</li>

<li>When the <code class="d_inline">departStation()</code> and <code class="d_inline">arriveStation()</code> functions are called, <code class="d_inline">train</code> is being used as a <code class="d_inline">Train</code> because those functions are declared by <code class="d_inline">Train</code>.</li>

</ol>

<p>The arrows indicate that <code class="d_inline">load()</code> and <code class="d_inline">unload()</code> functions work according to the actual type of <code class="d_inline">RailwayCar</code>:
</p>

<pre class="shell">The passengers are getting on     <span class="shell_note">← </span>
The crates are being loaded       <span class="shell_note">← </span>
Departing from Ankara station
The vehicle is advancing 500 kilometers
Arriving at Haydarpaşa station
The passengers are getting off    <span class="shell_note">← </span>
The crates are being unloaded     <span class="shell_note">← </span>
</pre>

<h5 class="subsection">Summary</h5>

<ul><li>Inheritance is used for the "is a" relationship.</li>
<li>Every class can inherit from up to one <code class="d_inline">class</code>.</li>
<li><code class="d_inline">super</code> has two uses: Calling the constructor of the superclass and accessing the members of the superclass.</li>
<li><code class="d_inline">override</code> is for redefining member functions of the superclass specially for the subclass.</li>
<li><code class="d_inline">abstract</code> requires that a member function must be overridden.</li>
</ul>

<h5 class="subsection">Problemler</h5>
    <ol>
<li>Let's modify <code class="d_inline">RailwayVehicle</code>. In addition to reporting the distance that it advances, let's have it also make sounds. To keep the output short, let's print the sounds per 100 kilometers:

<pre class="d_code"><span class="d_keyword">class</span> RailwayVehicle {
    <span class="d_keyword">void</span> advance(size_t kilometers) {
        writefln(<span class="d_string">"The vehicle is advancing %s kilometers"</span>,
                 kilometers);

        <span class="d_keyword">foreach</span> (i; 0 .. kilometers / 100) {
            writefln(<span class="d_string">"  %s"</span>, makeSound());
        }
    }

    <span class="d_comment">// ...
</span>}
</pre>

<p>However, <code class="d_inline">makeSound()</code> cannot be defined by <code class="d_inline">RailwayVehicle</code> because vehicles may have different sounds:
</p>

<ul><li>"choo choo" for <code class="d_inline">Locomotive</code></li>
<li>"clack clack" for <code class="d_inline">RailwayCar</code></li>
</ul>

<p><i><b>Note:</b> Leave <code class="d_inline">Train.makeSound</code> to the next exercise.</i>
</p>

<p>Because it must be overridden, <code class="d_inline">makeSound()</code> must be declared as <code class="d_inline">abstract</code> by the superclass:
</p>

<pre class="d_code"><span class="d_keyword">class</span> RailwayVehicle {
    <span class="d_comment">// ...
</span>
    <span class="d_keyword">abstract</span> string makeSound();
}
</pre>

<p>Implement <code class="d_inline">makeSound()</code> for the subclasses and try the code with the following <code class="d_inline">main()</code>:
</p>

<pre class="d_code"><span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> railwayCar1 = <span class="d_keyword">new</span> PassengerCar;
    railwayCar1.advance(100);

    <span class="d_keyword">auto</span> railwayCar2 = <span class="d_keyword">new</span> FreightCar;
    railwayCar2.advance(200);

    <span class="d_keyword">auto</span> locomotive = <span class="d_keyword">new</span> Locomotive;
    locomotive.advance(300);
}
</pre>

<p>Make the program produce the following output:
</p>

<pre class="shell">The vehicle is advancing 100 kilometers
  clack clack
The vehicle is advancing 200 kilometers
  clack clack
  clack clack
The vehicle is advancing 300 kilometers
  choo choo
  choo choo
  choo choo
</pre>

<p>Note that there is no requirement that the sounds of <code class="d_inline">PassengerCar</code> and <code class="d_inline">FreightCar</code> be different. They can share the same implemention from <code class="d_inline">RailwayCar</code>.
</p>

</li>

<li>Think about how <code class="d_inline">makeSound()</code> can be implemented for <code class="d_inline">Train</code>. One idea is that <code class="d_inline">Train.makeSound</code> may return a <code class="d_inline">string</code> that consists of the sounds of the members of <code class="d_inline">Train</code>.
</li>

</ol> <div class="cozum_link_cok"><p><a target="ddili_cozum" href="inheritance.cozum.html"><i>... çözümler</i></a></p></div>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Apr  1 20:41:04 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>

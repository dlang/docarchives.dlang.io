
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>More Templates - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='More Templates' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href="."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li><a href='../calendar.html'>Calendar</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option  value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BMore Templates%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/d.en/templates_more.d">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>More Templates</h1>
        
        



<p>We have seen the power and convenience of templates in <a href="templates.html">the Templates chapter</a>. A single templated definition of an algorithm or a data structure is sufficient to use that definition for multiple types.
</p>

<p>That chapter covered only the most common uses of templates: function, <code class="d_inline">struct</code>, and <code class="d_inline">class</code> templates and their uses  with <i>type</i> template parameters. In this chapter we will see templates in more detail. Before going further, I recommend that you review at least the summary section of that chapter.
</p>

<h5 class="subsection"><a id="ix_More Templates.shortcut syntax, template" content="shortcut syntax, template"></a> The shortcut syntax</h5>

<p>In addition to being powerful, D templates are easy to define and use and they are very readable. Defining a function, <code class="d_inline">struct</code>, or <code class="d_inline">class</code> template is as simple as providing a template parameter list:
</p>

<pre class="d_code">T twice<span class="hilite">(T)</span>(T value) {
    <span class="d_keyword">return</span> 2 * value;
}

<span class="d_keyword">class</span> Fraction<span class="hilite">(T)</span> {
    T numerator;
    T denominator;

    <span class="d_comment">// ...
</span>}
</pre>

<p>Template definitions like the ones above are taking advantage of D's shortcut template syntax.
</p>

<p>In their full syntax, templates are defined by the <code class="d_inline">template</code> keyword. The equivalents of the two template definitions above are the following:
</p>

<pre class="d_code"><span class="d_keyword">template</span> twice<span class="hilite">(T)</span> {
    T twice(T value) {
        <span class="d_keyword">return</span> 2 * value;
    }
}

<span class="d_keyword">template</span> Fraction<span class="hilite">(T)</span> {
    <span class="d_keyword">class</span> Fraction {
        T numerator;
        T denominator;

        <span class="d_comment">// ...
</span>    }
}
</pre>

<p>Although most templates are defined by the shortcut syntax, the compiler always uses the full syntax. We can imagine the compiler applying the following steps to convert a shortcut syntax to its full form behind the scenes:
</p>

<ol><li>Wrap the definition with a template block.</li>
<li>Give the same name to that block.</li>
<li>Move the template parameter list to the template block.</li>
</ol>

<p>The full syntax that is arrived after those steps is called an <i>eponymous template</i>, which the programmer can define explicitly as well. We will see eponymous templates later below.
</p>

<h6><a id="ix_More Templates.name space, template" content="name space, template"></a> Template name space</h6>

<p>It is possible to have more than one definition inside a template block. The following template contains both a function and a <code class="d_inline">struct</code> definition:
</p>

<pre class="d_code"><span class="d_keyword">template</span> MyTemplate(T) {
    T foo(T value) {
        <span class="d_keyword">return</span> value / 3;
    }

    <span class="d_keyword">struct</span> S {
        T member;
    }
}
</pre>

<p>Instantiating the template for a specific type instantiates all of the definitions inside the block. The following code instantiates the template for <code class="d_inline">int</code> and <code class="d_inline">double</code>:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> result = <span class="hilite">MyTemplate!<span class="d_keyword">int</span></span>.foo(42);
    writeln(result);

    <span class="d_keyword">auto</span> s = <span class="hilite">MyTemplate!<span class="d_keyword">double</span></span>.S(5.6);
    writeln(s.member);
</pre>

<p>A specific instantiation of a template introduces a <i>name space</i>. The definitions that are inside an instantiation can be used by that name. However, if these names are too long, it is always possible to use aliases as we have seen in <a href="alias.html">the <code class="d_inline">alias</code> chapter</a>:
</p>

<pre class="d_code">    <span class="d_keyword">alias</span> MyStruct = MyTemplate!<span class="d_keyword">dchar</span>.S;

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> o = <span class="hilite">MyStruct</span>('a');
    writeln(o.member);
</pre>

<h6><a id="ix_More Templates.eponymous template" content="eponymous template"></a> Eponymous templates</h6>

<p>Eponymous templates are <code class="d_inline">template</code> blocks that contain a definition that has the same name as that block. In fact, each shortcut template syntax is the shortcut of an eponymous template.
</p>

<p>As an example, assume that a program needs to qualify types that are larger than 20 bytes as <i>too large</i>. Such a qualification can be achieved by a constant <code class="d_inline">bool</code> value inside a template block:
</p>

<pre class="d_code"><span class="d_keyword">template</span> isTooLarge(T) {
    <span class="d_keyword">enum</span> isTooLarge = T.sizeof &gt; 20;
}
</pre>

<p>Note how the names of both the template block and its only definition are the same. This eponymous template is used by the shortcut syntax instead of the whole <code class="d_inline">isTooLarge!int.isTooLarge</code>:
</p>

<pre class="d_code">    writeln(<span class="hilite">isTooLarge!<span class="d_keyword">int</span></span>);
</pre>

<p>The highlighted part above is the same as the <code class="d_inline">bool</code> value inside the block. Since the size of <code class="d_inline">int</code> is less than 20, the output of the code would be <code class="d_inline">false</code>.
</p>

<p>That eponymous template can be defined by the shortcut syntax as well:
</p>

<pre class="d_code"><span class="d_keyword">enum</span> isTooLarge<span class="hilite">(T)</span> = T.sizeof &gt; 20;
</pre>

<p>A common use of eponymous templates is defining type aliases depending on certain conditions. For example, the following eponymous template picks the larger of two types by setting an alias to it:
</p>

<pre class="d_code"><span class="d_keyword">template</span> LargerOf(A, B) {
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (A.sizeof &lt; B.sizeof) {
        <span class="d_keyword">alias</span> LargerOf = B;

    } <span class="d_keyword">else</span> {
        <span class="d_keyword">alias</span> LargerOf = A;
    }
}
</pre>

<p>Since <code class="d_inline">long</code> is larger than <code class="d_inline">int</code> (8 bytes versus 4 bytes), <code class="d_inline">LargerOf!(int, long)</code> would be the same as the type <code class="d_inline">long</code>. Such templates are especially useful in other templates where the two types are template parameters themselves (or depend on template parameters):
</p>

<pre class="d_code"><span class="d_comment">// ...
</span>
<span class="d_comment">/* The return type of this function is the larger of its two
 * template parameters: Either type A or type B. */</span>
<span class="d_keyword">auto</span> calculate(A, B)(A a, B b) {
    <span class="hilite">LargerOf!(A, B)</span> result;
    <span class="d_comment">// ...
</span>    <span class="d_keyword">return</span> result;
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> f = calculate(1, 2<span class="hilite">L</span>);
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(f) == <span class="hilite"><span class="d_keyword">long</span></span>));
}
</pre>

<h5 class="subsection">Kinds of templates</h5>

<h6>Function, class, and struct templates</h6>

<p>We have already covered function, <code class="d_inline">class</code>, and <code class="d_inline">struct</code> templates in <a href="templates.html">the Templates chapter</a> and we have seen many examples of them since then.
</p>

<h6><a id="ix_More Templates.member function template" content="member function template"></a> Member function templates</h6>

<p><code class="d_inline">struct</code> and <code class="d_inline">class</code> member functions can be templates as well. For example, the following <code class="d_inline">put()</code> member function template would work with any parameter type as long as that type is compatible with the operations inside the template (for this specific template, it should be convertible to <code class="d_inline">string</code>):
</p>

<pre class="d_code"><span class="d_keyword">class</span> Sink {
    string content;

    <span class="d_keyword">void</span> put<span class="hilite">(T)</span>(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">const</span> T value) {
        <span class="d_keyword">import</span> std.conv;
        content ~= value.to!string;
    }
}
</pre>

<p>However, as templates can have potentially infinite number of instantiations, they cannot be <a href="inheritance.html">virtual functions</a> because the compiler cannot know which specific instantiations of a template to include in the interface. (Accordingly, the <code class="d_inline">abstract</code> keyword cannot be used either.)
</p>

<p>For example, although the presence of the <code class="d_inline">put()</code> template in the following subclass may give the impression that it is overriding a function, it actually hides the <code class="d_inline">put</code> name of the superclass (see <i>name hiding</i> in <a href="alias.html">the alias chapter</a>):
</p>

<pre class="d_code"><span class="d_keyword">class</span> Sink {
    string content;

    <span class="d_keyword">void</span> put(T)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">const</span> T value) {
        <span class="d_keyword">import</span> std.conv;
        content ~= value.to!string;
    }
}

<span class="d_keyword">class</span> SpecialSink : Sink {
    <span class="d_comment">/* The following template definition does not override
     * the template instances of the superclass; it hides
     * those names. */</span>
    <span class="d_keyword">void</span> put(T)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">const</span> T value) {
        <span class="d_keyword">import</span> std.string;
        <span class="d_keyword">super</span>.put(format(<span class="d_string">"{%s}"</span>, value));
    }
}

<span class="d_keyword">void</span> fillSink(<span class="hilite">Sink</span> sink) {
    <span class="d_comment">/* The following function calls are not virtual. Because
     * parameter 'sink' is of type 'Sink', the calls will
     * always be dispatched to Sink's 'put' template
     * instances. */</span>

    sink.put(42);
    sink.put(<span class="d_string">"hello"</span>);
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> sink = <span class="d_keyword">new</span> <span class="hilite">SpecialSink</span>();
    fillSink(sink);

    <span class="d_keyword">import</span> std.stdio;
    writeln(sink.content);
}
</pre>

<p>As a result, although the object actually is a <code class="d_inline">SpecialSink</code>, both of the calls inside <code class="d_inline">fillSink()</code> are dispatched to <code class="d_inline">Sink</code> and the content does not contain the curly brackets that <code class="d_inline">SpecialSink.put()</code> inserts:
</p>

<pre class="shell">42hello    <span class="shell_note">← Sink's behavior, not SpecialSink's</span>
</pre>

<h6><a id="ix_More Templates.union template" content="union template"></a> Union templates</h6>

<p>Union templates are similar to struct templates. The shortcut syntax is available for them as well.
</p>

<p>As an example, let's design a more general version of the <code class="d_inline">IpAdress</code> <code class="d_inline">union</code> that we saw in <a href="union.html">the Unions chapter</a>. There, the value of the IPv4 address was kept as a <code class="d_inline">uint</code> member in that earlier version of <code class="d_inline">IpAdress</code>, and the element type of the segment array was <code class="d_inline">ubyte</code>:
</p>

<pre class="d_code"><span class="d_keyword">union</span> IpAddress {
    <span class="d_keyword">uint</span> value;
    <span class="d_keyword">ubyte</span>[4] bytes;
}
</pre>

<p>The <code class="d_inline">bytes</code> array provided easy access to the four segments of the IPv4 address.
</p>

<p>The same concept can be implemented in a more general way as the following <code class="d_inline">union</code> template:
</p>

<pre class="d_code"><span class="d_keyword">union</span> SegmentedValue(<span class="hilite">ActualT, SegmentT</span>) {
    ActualT value;
    SegmentT[<span class="d_comment">/* number of segments */</span>] segments;
}
</pre>

<p>That template would allow specifying the types of the value and its segments freely.
</p>

<p>The number of segments that are needed depends on the types of the actual value and the segments. Since an IPv4 address has four <code class="d_inline">ubyte</code> segments, that value was hard-coded as <code class="d_inline">4</code> in the earlier definition of <code class="d_inline">IpAddress</code>. For the <code class="d_inline">SegmentedValue</code> template, the number of segments must be computed at compile time when the template is instantiated for the two specific types.
</p>

<p>The following eponymous template takes advantage of the <code class="d_inline">.sizeof</code> properties of the two types to calculate the number of segments needed:
</p>

<pre class="d_code"><span class="d_keyword">template</span> segmentCount(ActualT, SegmentT) {
    <span class="d_keyword">enum</span> segmentCount = ((ActualT.sizeof + (SegmentT.sizeof - 1))
                         / SegmentT.sizeof);
}
</pre>

<p>The shortcut syntax may be more readable:
</p>

<pre class="d_code"><span class="d_keyword">enum</span> segmentCount(ActualT, SegmentT) =
    ((ActualT.sizeof + (SegmentT.sizeof - 1))
     / SegmentT.sizeof);
</pre>

<p><i><b>Note:</b> The expression <code class="d_inline">SegmentT.sizeof - 1</code> is for when the sizes of the types cannot be divided evenly. For example, when the actual type is 5 bytes and the segment type is 2 bytes, even though a total of 3 segments are needed, the result of the integer division 5/2 would incorrectly be 2.</i>
</p>

<p>The definition of the union template is now complete:
</p>

<pre class="d_code"><span class="d_keyword">union</span> SegmentedValue(ActualT, SegmentT) {
    ActualT value;
    SegmentT[segmentCount!(ActualT, SegmentT)] segments;
}
</pre>

<p>Instantiation of the template for <code class="d_inline">uint</code> and <code class="d_inline">ubyte</code> would be the equivalent of the earlier definition of <code class="d_inline">IpAddress</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">auto</span> address = SegmentedValue!(<span class="hilite"><span class="d_keyword">uint</span>, <span class="d_keyword">ubyte</span></span>)(0xc0a80102);

    <span class="d_keyword">foreach</span> (octet; address.segments) {
        write(octet, ' ');
    }
}
</pre>

<p>The output of the program is the same as the one in <a href="union.html">the Unions chapter</a>:
</p>

<pre class="shell">2 1 168 192
</pre>

<p>To demonstrate the flexibility of this template, let's imagine that it is required to access the parts of the IPv4 address as two <code class="d_inline">ushort</code> values. It would be as easy as providing <code class="d_inline">ushort</code> as the segment type:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> address = SegmentedValue!(<span class="d_keyword">uint</span>, <span class="hilite"><span class="d_keyword">ushort</span></span>)(0xc0a80102);
</pre>

<p>Although unusual for an IPv4 address, the output of the program would consist of two <code class="d_inline">ushort</code> segment values:
</p>

<pre class="shell">258 49320
</pre>

<h6><a id="ix_More Templates.interface template" content="interface template"></a> Interface templates</h6>

<p>Interface templates provide flexibility on the types that are used on an interface (as well as values such as sizes of fixed-length arrays and other features of an interface).
</p>

<p>Let's define an interface for colored objects where the type of the color is determined by a template parameter:
</p>

<pre class="d_code"><span class="d_keyword">interface</span> ColoredObject(ColorT) {
    <span class="d_keyword">void</span> paint(ColorT color);
}
</pre>

<p>That interface template requires that its subtypes must define the <code class="d_inline">paint()</code> function but it leaves the type of the color flexible.
</p>

<p>A class that represents a frame on a web page may choose to use a color type that is represented by its red, green, and blue components:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> RGB {
    <span class="d_keyword">ubyte</span> red;
    <span class="d_keyword">ubyte</span> green;
    <span class="d_keyword">ubyte</span> blue;
}

<span class="d_keyword">class</span> PageFrame : ColoredObject<span class="hilite">!RGB</span> {
    <span class="d_keyword">void</span> paint(RGB color) {
        <span class="d_comment">// ...
</span>    }
}
</pre>

<p>On the other hand, a class that uses the frequency of light can choose a completely different type to represent color:
</p>

<pre class="d_code"><span class="d_keyword">alias</span> Frequency = <span class="d_keyword">double</span>;

<span class="d_keyword">class</span> Bulb : ColoredObject<span class="hilite">!Frequency</span> {
    <span class="d_keyword">void</span> paint(Frequency color) {
        <span class="d_comment">// ...
</span>    }
}
</pre>

<p>However, as explained in <a href="templates.html">the Templates chapter</a>, "every template instantiation yields a distinct type". Accordingly, the interfaces <code class="d_inline">ColoredObject!RGB</code> and <code class="d_inline">ColoredObject!Frequency</code> are unrelated interfaces, and <code class="d_inline">PageFrame</code> and <code class="d_inline">Bulb</code> are unrelated classes.
</p>

<h5 class="subsection"><a id="ix_More Templates.parameter, template" content="parameter, template"></a> Kinds of template parameters</h5>

<p>The template parameters that we have seen so far have all been <i>type</i> parameters. So far, parameters like <code class="d_inline">T</code> and <code class="d_inline">ColorT</code> all represented types.  For example, <code class="d_inline">T</code> meant <code class="d_inline">int</code>, <code class="d_inline">double</code>, <code class="d_inline">Student</code>, etc. depending on the instantiation of the template.
</p>

<p>There are other kinds of template parameters: value, <code class="d_inline">this</code>, <code class="d_inline">alias</code>, and tuple.
</p>

<h6><a id="ix_More Templates.type template parameter" content="type template parameter"></a> Type template parameters</h6>

<p>This section is only for completeness. All of the templates that we have seen so far had type parameters.
</p>

<h6><a id="ix_More Templates.value template parameter" content="value template parameter"></a> Value template parameters</h6>

<p>Value template parameters allow flexibility on certain values used in the template implementation.
</p>

<p>Since templates are a compile-time feature, the values for the value template parameters must be known at compile time; values that must be calculated at run time cannot be used.
</p>

<p>To see the advantage of value template parameters, let's start with a set of structs representing geometric shapes:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Triangle {
    Point[3] corners;
<span class="d_comment">// ...
</span>}

<span class="d_keyword">struct</span> Rectangle {
    Point[4] corners;
<span class="d_comment">// ...
</span>}

<span class="d_keyword">struct</span> Pentagon {
    Point[5] corners;
<span class="d_comment">// ...
</span>}
</pre>

<p>Let's assume that other member variables and member functions of those types are exactly the same and that the only difference is the <i>value</i> that determines the number of corners.
</p>

<p>Value template parameters help in such cases. The following struct template is sufficient to represent all of the types above and more:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Polygon<span class="hilite">(size_t N)</span> {
    Point[N] corners;
<span class="d_comment">// ...
</span>}
</pre>

<p>The only template parameter of that struct template is a value named <code class="d_inline">N</code> of type <code class="d_inline">size_t</code>. The value <code class="d_inline">N</code> can be used as a compile-time constant anywhere inside the template.
</p>

<p>That template is flexible enough to represent shapes of any sides:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> centagon = Polygon!100();
</pre>

<p>The following aliases correspond to the earlier struct definitions:
</p>

<pre class="d_code"><span class="d_keyword">alias</span> Triangle = Polygon!3;
<span class="d_keyword">alias</span> Rectangle = Polygon!4;
<span class="d_keyword">alias</span> Pentagon = Polygon!5;

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> triangle = Triangle();
    <span class="d_keyword">auto</span> rectangle = Rectangle();
    <span class="d_keyword">auto</span> pentagon = Pentagon();
</pre>

<p>The type of the <i>value</i> template parameter above was <code class="d_inline">size_t</code>. As long as the value can be known at compile time, a value template parameter can be of any type: a fundamental type, a <code class="d_inline">struct</code> type, an array, a string, etc.
</p>

<pre class="d_code"><span class="d_keyword">struct</span> S {
    <span class="d_keyword">int</span> i;
}

<span class="d_comment">// Value template parameter of struct S
</span><span class="d_keyword">void</span> foo(<span class="hilite">S s</span>)() {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">void</span> main() {
    foo!(S(42))();    <span class="d_comment">// Instantiating with literal S(42)
</span>}
</pre>

<p>The following example uses a <code class="d_inline">string</code> template parameter to represent an XML tag to produce a simple XML output:
</p>

<ul><li>First the tag between the <code class="d_inline">&lt;</code>&nbsp;<code class="d_inline">&gt;</code> characters: <code class="d_inline">&lt;tag&gt;</code></li>
<li>Then the value</li>
<li>Finally the tag between the <code class="d_inline">&lt;/</code>&nbsp;<code class="d_inline">&gt;</code> characters: <code class="d_inline">&lt;/tag&gt;</code></li>
</ul>

<p>For example, an XML tag representing <i>location 42</i> would be printed as <code class="d_inline">&lt;location&gt;42&lt;/location&gt;</code>.
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.string;

<span class="d_keyword">class</span> XmlElement<span class="hilite">(string tag)</span> {
    <span class="d_keyword">double</span> value;

    <span class="d_keyword">this</span>(<span class="d_keyword">double</span> value) {
        <span class="d_keyword">this</span>.value = value;
    }

    <span class="d_keyword">override</span> string toString() <span class="d_keyword">const</span> {
        <span class="d_keyword">return</span> format(<span class="d_string">"&lt;%s&gt;%s&lt;/%s&gt;"</span>, tag, value, tag);
    }
}
</pre>

<p>Note that the template parameter is not about a type that is used in the implementation of the template, rather it is about a <code class="d_inline">string</code> <i>value</i>. That value can be used anywhere inside the template as a <code class="d_inline">string</code>.
</p>

<p>The XML elements that a program needs can be defined as aliases as in the following code:
</p>

<pre class="d_code"><span class="d_keyword">alias</span> Location = XmlElement!<span class="d_string">"location"</span>;
<span class="d_keyword">alias</span> Temperature = XmlElement!<span class="d_string">"temperature"</span>;
<span class="d_keyword">alias</span> Weight = XmlElement!<span class="d_string">"weight"</span>;

<span class="d_keyword">void</span> main() {
    Object[] elements;

    elements ~= <span class="d_keyword">new</span> Location(1);
    elements ~= <span class="d_keyword">new</span> Temperature(23);
    elements ~= <span class="d_keyword">new</span> Weight(78);

    writeln(elements);
}
</pre>

<p>The output:
</p>

<pre class="shell">[&lt;location&gt;1&lt;/location&gt;, &lt;temperature&gt;23&lt;/temperature&gt;, &lt;weight&gt;78&lt;/weight&gt;]
</pre>

<p>Value template parameters can have default values as well. For example, the following struct template represents points in a multi-dimensional space where the default number of dimensions is 3:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> Point(T, size_t dimension <span class="hilite">= 3</span>) {
    T[dimension] coordinates;
}
</pre>

<p>That template can be used without specifying the <code class="d_inline">dimension</code> template parameter:
</p>

<pre class="d_code">    Point!<span class="d_keyword">double</span> center;    <span class="d_comment">// a point in 3-dimensional space
</span></pre>

<p>The number of dimensions can still be specified when needed:
</p>

<pre class="d_code">    Point!(<span class="d_keyword">int</span>, 2) point;   <span class="d_comment">// a point on a surface
</span></pre>

<p>We have seen in <a href="parameter_flexibility.html">the Variable Number of Parameters chapter</a> how <i>special keywords</i> work differently depending on whether they appear inside code or as default function arguments.
</p>

<p>Similarly, when used as default template arguments, the special keywords refer to where the template is instantiated at, not where the keywords appear:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> func(T,
          string functionName = <span class="hilite"><span class="d_keyword">__FUNCTION__</span></span>,
          string file = <span class="hilite"><span class="d_keyword">__FILE__</span></span>,
          size_t line = <span class="hilite"><span class="d_keyword">__LINE__</span></span>)(T parameter) {
    writefln(<span class="d_string">"Instantiated at function %s at file %s, line %s."</span>,
             functionName, file, line);
}

<span class="d_keyword">void</span> main() {
    func(42);    <span class="d_comment">// ← <span class="hilite">line 12</span></span>
}
</pre>

<p>Although the special keywords appear in the definition of the template, their values refer to <code class="d_inline">main()</code>, where the template is instantiated at:
</p>

<pre class="shell">Instantiated at function deneme.<span class="hilite">main</span> at file deneme.d, <span class="hilite">line 12</span>.
</pre>

<p>We will use <code class="d_inline">__FUNCTION__</code> below in a multi-dimensional operator overloading example.
</p>

<h6><a id="ix_More Templates.this, template parameter" content="this, template parameter"></a> <code class="d_inline">this</code> template parameters for member functions</h6>

<p>Member functions can be templates as well. Their template parameters have the same meanings as other templates.
</p>

<p>However, unlike other templates, member function template parameters can also be <i><code class="d_inline">this</code> parameters</i>. In that case, the identifier that comes after the <code class="d_inline">this</code> keyword represents the exact type of the <code class="d_inline">this</code> reference of the object. (<i><code class="d_inline">this</code> reference</i> means the object itself, as is commonly written in constructors as <code class="d_inline">this.member&nbsp;=&nbsp;value</code>.)
</p>

<pre class="d_code"><span class="d_keyword">struct</span> MyStruct(T) {
    <span class="d_keyword">void</span> foo(<span class="hilite"><span class="d_keyword">this</span> OwnType</span>)() <span class="d_keyword">const</span> {
        writeln(<span class="d_string">"Type of this object: "</span>, OwnType.stringof);
    }
}
</pre>

<p>The <code class="d_inline">OwnType</code> template parameter is the actual type of the object that the member function is called on:
</p>

<pre class="d_code">    <span class="d_keyword">auto</span> m = MyStruct!<span class="d_keyword">int</span>();
    <span class="d_keyword">auto</span> c = <span class="d_keyword">const</span>(MyStruct!<span class="d_keyword">int</span>)();
    <span class="d_keyword">auto</span> i = <span class="d_keyword">immutable</span>(MyStruct!<span class="d_keyword">int</span>)();

    m.foo();
    c.foo();
    i.foo();
</pre>

<p>The output:
</p>

<pre class="shell">Type of this object: MyStruct!int
Type of this object: const(MyStruct!int)
Type of this object: immutable(MyStruct!int)
</pre>

<p>As you can see, the type includes the corresponding type of <code class="d_inline">T</code> as well as the type qualifiers like <code class="d_inline">const</code> and <code class="d_inline">immutable</code>.
</p>

<p>The <code class="d_inline">struct</code> (or <code class="d_inline">class</code>) need not be a template. <code class="d_inline">this</code> template parameters can appear on member function templates of non-templated types as well.
</p>

<p><code class="d_inline">this</code> template parameters can be useful in <i>template mixins</i> as well, which we will see two chapters later.
</p>

<h6><a id="ix_More Templates.alias, template parameter" content="alias, template parameter"></a> <code class="d_inline">alias</code> template parameters</h6>

<p><code class="d_inline">alias</code> template parameters can correspond to any symbol or expression that is used in the program. The only constraint on such a template argument is that the argument must be compatible with its use inside the template.
</p>

<p><code class="d_inline">filter()</code> and <code class="d_inline">map()</code> use <code class="d_inline">alias</code> template parameters to determine the operations that they execute.
</p>

<p>Let's see a simple example on a <code class="d_inline">struct</code> template that is for modifying an existing variable. The <code class="d_inline">struct</code> template takes the variable as an <code class="d_inline">alias</code> parameter:
</p>

<pre class="d_code"><span class="d_keyword">struct</span> MyStruct(<span class="d_keyword">alias</span> variable) {
    <span class="d_keyword">void</span> set(<span class="d_keyword">int</span> value) {
        variable = value;
    }
}
</pre>

<p>The member function simply assigns its parameter to the variable that the <code class="d_inline">struct</code> template is instantiated with. That variable must be specified during the instantiation of the template:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> x = 1;
    <span class="d_keyword">int</span> y = 2;

    <span class="d_keyword">auto</span> object = MyStruct!<span class="hilite">x</span>();
    object.set(10);
    writeln(<span class="d_string">"x: "</span>, x, <span class="d_string">", y: "</span>, y);
</pre>

<p>In that instantiation, the <code class="d_inline">variable</code> template parameter corresponds to the variable <code class="d_inline">x</code>:
</p>

<pre class="shell">x: <span class="hilite">10</span>, y: 2
</pre>

<p>Conversely, <code class="d_inline">MyStruct!y</code> instantiation of the template would associate <code class="d_inline">variable</code> with <code class="d_inline">y</code>.
</p>

<p>Let's now have an <code class="d_inline">alias</code> parameter that represents a callable entity, similar to <code class="d_inline">filter()</code> and <code class="d_inline">map()</code>:
</p>

<pre class="d_code"><span class="d_keyword">void</span> caller(<span class="d_keyword">alias</span> func)() {
    write(<span class="d_string">"calling: "</span>);
    <span class="hilite">func()</span>;
}
</pre>

<p>As seen by the <code class="d_inline">()</code> parentheses, <code class="d_inline">caller()</code> uses its template parameter as a function. Additionally, since the parentheses are empty, it must be legal to call the function without specifying any arguments.
</p>

<p>Let's have the following two functions that match that description. They can both represent <code class="d_inline">func</code> because they can be called as <code class="d_inline">func()</code> in the template:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo() {
    writeln(<span class="d_string">"foo called."</span>);
}

<span class="d_keyword">void</span> bar() {
    writeln(<span class="d_string">"bar called."</span>);
}
</pre>

<p>Those functions can be used as the <code class="d_inline">alias</code> parameter of <code class="d_inline">caller()</code>:
</p>

<pre class="d_code">    caller!foo();
    caller!bar();
</pre>

<p>The output:
</p>

<pre class="shell">calling: foo called.
calling: bar called.
</pre>

<p>As long as it matches the way it is used in the template, any symbol can be used as an <code class="d_inline">alias</code> parameter. As a counter example, using an <code class="d_inline">int</code> variable with <code class="d_inline">caller()</code> would cause a compilation error:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> variable;
    caller!variable();    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>The compilation error indicates that the variable does not match its use in the template:
</p>

<pre class="shell">Error: <span class="hilite">function expected before ()</span>, not variable of type int
</pre>

<p>Although the mistake is with the <code class="d_inline">caller!variable</code> instantiation, the compilation error necessarily points at <code class="d_inline">func()</code> inside the <code class="d_inline">caller()</code> template because from the point of view of the compiler the error is with trying to call <code class="d_inline">variable</code> as a function. One way of dealing with this issue is to use <i>template constraints</i>, which we will see below.
</p>

<p>If the variable supports the function call syntax perhaps because it has an <code class="d_inline">opCall()</code> overload or it is a function literal, it would still work with the <code class="d_inline">caller()</code> template. The following example demonstrates both of those cases:
</p>

<pre class="d_code"><span class="d_keyword">class</span> C {
    <span class="d_keyword">void</span> opCall() {
        writeln(<span class="d_string">"C.opCall called."</span>);
    }
}

<span class="d_comment">// ...
</span>
    <span class="d_keyword">auto</span> o = <span class="d_keyword">new</span> C();
    caller!o();

    caller!({ writeln(<span class="d_string">"Function literal called."</span>); })();
</pre>

<p>The output:
</p>

<pre class="shell">calling: C.opCall called.
calling: Function literal called.
</pre>

<p><code class="d_inline">alias</code> parameters can be specialized as well. However, they have a different specialization syntax. The specialized type must be specified between the <code class="d_inline">alias</code> keyword and the name of the parameter:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> foo(<span class="d_keyword">alias</span> variable)() {
    writefln(<span class="d_string">"The general definition is using '%s' of type %s."</span>,
             variable.stringof, <span class="d_keyword">typeof</span>(variable).stringof);
}

<span class="d_keyword">void</span> foo(<span class="d_keyword">alias</span> <span class="hilite"><span class="d_keyword">int</span></span> i)() {
    writefln(<span class="d_string">"The int specialization is using '%s'."</span>,
             i.stringof);
}

<span class="d_keyword">void</span> foo(<span class="d_keyword">alias</span> <span class="hilite"><span class="d_keyword">double</span></span> d)() {
    writefln(<span class="d_string">"The double specialization is using '%s'."</span>,
             d.stringof);
}

<span class="d_keyword">void</span> main() {
    string name;
    foo!name();

    <span class="d_keyword">int</span> count;
    foo!count();

    <span class="d_keyword">double</span> length;
    foo!length();
}
</pre>

<p>Also note that <code class="d_inline">alias</code> parameters make the names of the actual variables available inside the template:
</p>

<pre class="shell">The general definition is using 'name' of type string.
The int specialization is using 'count'.
The double specialization is using 'length'.
</pre>

<h6><a id="ix_More Templates.tuple template parameter" content="tuple template parameter"></a> Tuple template parameters</h6>

<p>We have seen in <a href="parameter_flexibility.html">the Variable Number of Parameters chapter</a> that variadic functions can take any number and any type of parameters. For example, <code class="d_inline">writeln()</code> can be called with any number of parameters of any type.
</p>

<p><a id="ix_More Templates...., template parameter" content="..., template parameter"></a> <a id="ix_More Templates.variadic template" content="variadic template"></a> Templates can be variadic as well. A template parameter that consists of a name followed by <code class="d_inline">...</code> allows any number and kind of parameters at that parameter's position. Such parameters appear as a tuple inside the template, which can be used like an <code class="d_inline">AliasSeq</code>.
</p>

<p>Let's see an example of this with a template that simply prints information about every template argument that it is instantiated with:
</p>

<pre class="d_code"><span class="d_keyword">void</span> info(T...)(T args) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>The template parameter <code class="d_inline">T...</code> makes <code class="d_inline">info</code> a <i>variadic template</i>. Both <code class="d_inline">T</code> and <code class="d_inline">args</code> are tuples:
</p>

<ul><li><code class="d_inline">T</code> represents the types of the arguments.</li>
<li><code class="d_inline">args</code> represents the arguments themselves.</li>
</ul>

<p>The following example instantiates that function template with three values of three different types:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_comment">// ...
</span>
<span class="d_keyword">void</span> main() {
    info(<span class="hilite">1, <span class="d_string">"abc"</span>, 2.3</span>);
}
</pre>

<p>The following implementation simply prints information about the arguments by iterating over them in a <code class="d_inline">foreach</code> loop:
</p>

<pre class="d_code"><span class="d_keyword">void</span> info(T...)(T args) {
    <span class="d_comment">// 'args' is being used like a tuple:
</span>    <span class="d_keyword">foreach</span> (i, arg; <span class="hilite">args</span>) {
        writefln(<span class="d_string">"%s: %s argument %s"</span>,
                 i, <span class="d_keyword">typeof</span>(arg).stringof, arg);
    }
}
</pre>

<p><i><b>Note:</b> As seen in the previous chapter, since the arguments are a tuple, the <code class="d_inline">foreach</code> statement above is a</i> compile-time <code class="d_inline">foreach</code>.
</p>

<p>The output:
</p>

<pre class="shell">0: int argument 1
1: string argument abc
2: double argument 2.3
</pre>

<p>Note that instead of obtaining the type of each argument by <code class="d_inline">typeof(arg)</code>, we could have used <code class="d_inline">T[i]</code> as well.
</p>

<p>We know that template arguments can be deduced for function templates. That's why the compiler deduces the types as <code class="d_inline">int</code>, <code class="d_inline">string</code>, and <code class="d_inline">double</code> in the previous program.
</p>

<p>However, it is also possible to specify template parameters explicitly. For example, <code class="d_inline">std.conv.to</code> takes the destination type as an explicit template parameter:
</p>

<pre class="d_code">    to!<span class="hilite">string</span>(42);
</pre>

<p>When template parameters are explicitly specified, they can be a mixture of value, type, and other kinds. That flexibility makes it necessary to be able to determine whether each template parameter is a type or not, so that the body of the template can be coded accordingly. That is achieved by treating the arguments as an <code class="d_inline">AliasSeq</code>.
</p>

<p>Let's see an example of this in a function template that produces <code class="d_inline">struct</code> definitions as source code in text form. Let's have this function return the produced source code as <code class="d_inline">string</code>. This function can first take the name of the <code class="d_inline">struct</code> followed by the types and names of the members specified as pairs:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    writeln(structDefinition!(<span class="d_string">"Student"</span>,
                              string, <span class="d_string">"name"</span>,
                              <span class="d_keyword">int</span>, <span class="d_string">"id"</span>,
                              <span class="d_keyword">int</span>[], <span class="d_string">"grades"</span>)());
}
</pre>

<p>That <code class="d_inline">structDefinition</code> instantiation is expected to produce the following <code class="d_inline">string</code>:
</p>

<pre class="shell">struct Student {
    string name;
    int id;
    int[] grades;
}
</pre>

<p><i><b>Note:</b> Functions that produce source code are used with the <code class="d_inline">mixin</code> keyword, which we will see in <a href="mixin.html">a later chapter</a>.</i>
</p>

<p>The following is an implementation that produces the desired output. Note how the function template makes use of the <code class="d_inline">is</code> expression. Remember that the expression <code class="d_inline">is&nbsp;(arg)</code> produces <code class="d_inline">true</code> when <code class="d_inline">arg</code> is a valid type:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.string;

string structDefinition(string name, <span class="hilite">Members</span>...)() {
    <span class="d_comment">/* Ensure that members are specified as pairs: first the
     * type then the name. */</span>
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>((<span class="hilite">Members</span>.length % 2) == 0,
                  <span class="d_string">"Members must be specified as pairs."</span>);

    <span class="d_comment">/* The first part of the struct definition. */</span>
    string result = <span class="d_string">"struct "</span> ~ name ~ <span class="d_string">"\n{\n"</span>;

    <span class="d_keyword">foreach</span> (i, arg; <span class="hilite">Members</span>) {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (i % 2) {
            <span class="d_comment">/* The odd numbered arguments should be the names
             * of members. Instead of dealing with the names
             * here, we use them as Members[i+1] in the 'else'
             * clause below.
             *
             * Let's at least ensure that the member name is
             * specified as a string. */</span>
            <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(arg) == string),
                          <span class="d_string">"Member name "</span> ~ arg.stringof ~
                          <span class="d_string">" is not a string."</span>);

        } <span class="d_keyword">else</span> {
            <span class="d_comment">/* In this case 'arg' is the type of the
             * member. Ensure that it is indeed a type. */</span>
            <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (arg),
                          arg.stringof ~ <span class="d_string">" is not a type."</span>);

            <span class="d_comment">/* Produce the member definition from its type and
             * its name.
             *
             * Note: We could have written 'arg' below instead
             * of Members[i]. */</span>
            result ~= format(<span class="d_string">"    %s %s;\n"</span>,
                             <span class="hilite">Members[i]</span>.stringof, <span class="hilite">Members[i+1]</span>);
        }
    }

    <span class="d_comment">/* The closing bracket of the struct definition. */</span>
    result ~= <span class="d_string">"}"</span>;

    <span class="d_keyword">return</span> result;
}

<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    writeln(structDefinition!(<span class="d_string">"Student"</span>,
                              string, <span class="d_string">"name"</span>,
                              <span class="d_keyword">int</span>, <span class="d_string">"id"</span>,
                              <span class="d_keyword">int</span>[], <span class="d_string">"grades"</span>)());
}
</pre>

<h5 class="subsection"><a id="ix_More Templates.typeof(this)" content="typeof(this)"></a> <a id="ix_More Templates.typeof(super)" content="typeof(super)"></a> <a id="ix_More Templates.typeof(return)" content="typeof(return)"></a><code class="d_inline">typeof(this)</code>, <code class="d_inline">typeof(super)</code>, and <code class="d_inline">typeof(return)</code></h5>

<p>In some cases, the generic nature of templates makes it difficult to know or spell out certain types in the template code. The following three special <code class="d_inline">typeof</code> varieties are useful in such cases. Although they are introduced in this chapter, they work in non-templated code as well.
</p>

<ul>
<li><code class="d_inline">typeof(this)</code> generates the type of the <code class="d_inline">this</code> reference. It works in any <code class="d_inline">struct</code> or <code class="d_inline">class</code>, even outside of member functions:

<pre class="d_code"><span class="d_keyword">struct</span> List(T) {
    <span class="d_comment">// The type of 'next' is List!int when T is int
</span>    <span class="d_keyword">typeof</span>(<span class="d_keyword">this</span>) *next;
    <span class="d_comment">// ...
</span>}
</pre>

</li>

<li><code class="d_inline">typeof(super)</code> generates the base type of a <code class="d_inline">class</code> (i.e. the type of <code class="d_inline">super</code>).

<pre class="d_code"><span class="d_keyword">class</span> ListImpl(T) {
    <span class="d_comment">// ...
</span>}

<span class="d_keyword">class</span> List(T) : ListImpl!T {
    <span class="d_comment">// The type of 'next' is ListImpl!int when T is int
</span>    <span class="d_keyword">typeof</span>(<span class="d_keyword">super</span>) *next;
    <span class="d_comment">// ...
</span>}
</pre>

</li>

<li><code class="d_inline">typeof(return)</code> generates the return type of a function, inside that function.

<p>For example, instead of defining the <code class="d_inline">calculate()</code> function above as an <code class="d_inline">auto</code> function, we can be more explicit by replacing <code class="d_inline">auto</code> with <code class="d_inline">LargerOf!(A, B)</code> in its definition. (Being more explicit would have the added benefit of obviating at least some part of its function comment.)
</p>

<pre class="d_code"><span class="hilite">LargerOf!(A, B)</span> calculate(A, B)(A a, B b) {
    <span class="d_comment">// ...
</span>}
</pre>

<p><code class="d_inline">typeof(return)</code> prevents having to repeat the return type inside the function body:
</p>

<pre class="d_code">LargerOf!(A, B) calculate(A, B)(A a, B b) {
    <span class="hilite"><span class="d_keyword">typeof</span>(<span class="d_keyword">return</span>)</span> result;    <span class="d_comment">// The type is either A or B
</span>    <span class="d_comment">// ...
</span>    <span class="d_keyword">return</span> result;
}
</pre>

</li>

</ul>

<h5 class="subsection">Template specializations</h5>

<p>We have seen template specializations in <a href="templates.html">the Templates chapter</a>. Like type parameters, other kinds of template parameters can be specialized as well. The following is the general definition of a template and its specialization for 0:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> value)() {
    <span class="d_comment">// ... general definition ...
</span>}

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> value <span class="hilite">: 0</span>)() {
    <span class="d_comment">// ... special definition for zero ...
</span>}
</pre>

<p>We will take advantage of template specializations in the <i>meta programming</i> section below.
</p>

<h5 class="subsection"><a id="ix_More Templates.meta programming" content="meta programming"></a> Meta programming</h5>

<p>As they are about code generation, templates are among the higher level features of D. A template is indeed code that generates code. Writing code that generates code is called <i>meta programming</i>.
</p>

<p>Due to templates being compile-time features, some operations that are normally executed at runtime can be moved to compile time as template instantiations.
</p>

<p>(<i><b>Note:</b> Compile time function execution</i> (CTFE) <i>is another feature that achieves the same goal. We will see CTFE in a later chapter.</i>)
</p>

<p><i>Executing</i> templates at compile time is commonly based on recursive template instantiations.
</p>

<p>To see an example of this, let's first consider a regular function that calculates the sum of numbers from 0 to a specific value. For example, when its argument is 4, this fuction should return the result of 0+1+2+3+4:
</p>

<pre class="d_code"><span class="d_keyword">int</span> sum(<span class="d_keyword">int</span> last) {
    <span class="d_keyword">int</span> result = 0;

    <span class="d_keyword">foreach</span> (value; 0 .. last + 1) {
        result += value;
    }

    <span class="d_keyword">return</span> result;
}
</pre>

<p><a id="ix_More Templates.recursion" content="recursion"></a> That is an iterative implementation of the function. The same function can be implemented by recursion as well:
</p>

<pre class="d_code"><span class="d_keyword">int</span> sum(<span class="d_keyword">int</span> last) {
    <span class="d_keyword">return</span> (last == 0
            ? last
            : last + <span class="hilite">sum</span>(last - 1));
}
</pre>

<p>The recursive function returns the sum of the last value and the previous sum. As you can see, the function terminates the recursion by treating the value 0 specially.
</p>

<p>Functions are normally run-time features. As usual, <code class="d_inline">sum()</code> can be executed at run time:
</p>

<pre class="d_code">    writeln(sum(4));
</pre>

<p>When the result is needed at compile time, one way of achieving the same calculation is by defining a function template. In this case, the parameter must be a template parameter, not a function parameter:
</p>

<pre class="d_code"><span class="d_comment">// WARNING: This code is incorrect.
</span><span class="d_keyword">int</span> sum(<span class="hilite"><span class="d_keyword">int</span> last</span>)() {
    <span class="d_keyword">return</span> (last == 0
            ? last
            : last + sum<span class="hilite">!(last - 1)</span>());
}
</pre>

<p>That function template instantiates itself by <code class="d_inline">last - 1</code> and tries to calculate the sum again by recursion. However, that code is incorrect.
</p>

<p>As the ternary operator would be compiled to be executed at run time, there is no condition check that terminates the recursion at compile time:
</p>

<pre class="d_code">    writeln(sum!4());    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>The compiler detects that the template instances would recurse infinitely and stops at an arbitrary number of recursions:
</p>

<pre class="shell">Error: template instance deneme.sum!(<span class="hilite">-296</span>) recursive expansion
</pre>

<p>Considering the difference between the template argument 4 and -296, the compiler restricts template expansion at 300 by default.
</p>

<p>In meta programming, recursion is terminated by a template specialization. The following specialization for 0 produces the expected result:
</p>

<pre class="d_code"><span class="d_comment">// The general definition
</span><span class="d_keyword">int</span> sum(<span class="d_keyword">int</span> last)() {
    <span class="d_keyword">return</span> last + sum!(last - 1)();
}

<span class="d_comment">// The special definition for zero
</span><span class="d_keyword">int</span> sum(<span class="d_keyword">int</span> last <span class="hilite">: 0</span>)() {
    <span class="d_keyword">return</span> 0;
}
</pre>

<p>The following is a program that tests <code class="d_inline">sum()</code>:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
    writeln(sum!4());
}
</pre>

<p>Now the program compiles successfully and produces the result of 4+3+2+1+0:
</p>

<pre class="shell">10
</pre>

<p>An important point to make here is that the function <code class="d_inline">sum!4()</code> is executed entirely at compile time. The compiled code is the equivalent of calling <code class="d_inline">writeln()</code> with literal <code class="d_inline">10</code>:
</p>

<pre class="d_code">    writeln(10);         <span class="d_comment">// the equivalent of writeln(sum!4())
</span></pre>

<p>As a result, the compiled code is as fast and simple as can be. Although the value 10 is still calculated as the result of 4+3+2+1+0, the entire calculation happens at compile time.
</p>

<p>The previous example demonstrates one of the benefits of meta programming: moving operations from run time to compile time. CTFE obviates some of the idioms of meta programming in D.
</p>

<h5 class="subsection"><a id="ix_More Templates.polymorphism, compile-time" content="polymorphism, compile-time"></a> <a id="ix_More Templates.compile-time polymorphism" content="compile-time polymorphism"></a> Compile-time polymorphism</h5>

<p>In object oriented programming (OOP), polymorphism is achieved by inheritance. For example, if a function takes an interface, it accepts objects of any class that inherits that interface.
</p>

<p>Let's recall an earlier example from a previous chapter:
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">interface</span> SoundEmitter {
    string emitSound();
}

<span class="d_keyword">class</span> Violin : SoundEmitter {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"♩♪♪"</span>;
    }
}

<span class="d_keyword">class</span> Bell : SoundEmitter {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"ding"</span>;
    }
}

<span class="d_keyword">void</span> useSoundEmittingObject(<span class="hilite">SoundEmitter object</span>) {
    <span class="d_comment">// ... some operations ...
</span>    writeln(object.emitSound());
    <span class="d_comment">// ... more operations ...
</span>}

<span class="d_keyword">void</span> main() {
    useSoundEmittingObject(<span class="d_keyword">new</span> Violin);
    useSoundEmittingObject(<span class="d_keyword">new</span> Bell);
}
</pre>

<p><code class="d_inline">useSoundEmittingObject()</code> is benefiting from polymorphism. It takes a <code class="d_inline">SoundEmitter</code> so that it can be used with any type that is derived from that interface.
</p>

<p>Since <i>working with any type</i> is inherent to templates, they can be seen as providing a kind of polymorphism as well. Being a compile-time feature, the polymorphism that templates provide is called <i>compile-time polymorphism</i>. Conversely, OOP's polymorphism is called <i>run-time polymorphism</i>.
</p>

<p>In reality, neither kind of polymorphism allows being used with <i>any type</i> because the types must satisfy certain requirements.
</p>

<p>Run-time polymorphism requires that the type implements a certain interface.
</p>

<p>Compile-time polymorphism requires that the type is compatible with how it is used by the template. As long as the code compiles, the template argument can be used with that template. (<i><b>Note:</b> Optionally, the argument must satisfy template constraints as well. We will see template constraints later below.</i>)
</p>

<p>For example, if <code class="d_inline">useSoundEmittingObject()</code> were implemented as a function template instead of a function, it could be used with any type that supported the <code class="d_inline">object.emitSound()</code> call:
</p>

<pre class="d_code"><span class="d_keyword">void</span> useSoundEmittingObject<span class="hilite">(T)</span>(T object) {
    <span class="d_comment">// ... some operations ...
</span>    writeln(object.emitSound());
    <span class="d_comment">// ... more operations ...
</span>}

<span class="d_keyword">class</span> Car {
    string emitSound() {
        <span class="d_keyword">return</span> <span class="d_string">"honk honk"</span>;
    }
}

<span class="d_comment">// ...
</span>
    useSoundEmittingObject(<span class="d_keyword">new</span> Violin);
    useSoundEmittingObject(<span class="d_keyword">new</span> Bell);
    useSoundEmittingObject(<span class="d_keyword">new</span> Car);
</pre>

<p>Note that although <code class="d_inline">Car</code> has no inheritance relationship with any other type, the code compiles successfully, and the <code class="d_inline">emitSound()</code> member function of each type gets called.
</p>

<p><a id="ix_More Templates.duck typing" content="duck typing"></a> Compile-time polymorphism is also known as <i>duck typing</i>, a humorous term, emphasizing behavior over actual type.
</p>

<h5 class="subsection"><a id="ix_More Templates.code bloat" content="code bloat"></a> Code bloat</h5>

<p>The code generated by the compiler is different for every different argument of a type parameter, of a value parameter, etc.</p>

<p>The reason for that can be seen by considering <code class="d_inline">int</code> and <code class="d_inline">double</code> as type template arguments. Each type would have to be processed by different kinds of CPU registers. For that reason, the same template needs to be compiled differently for different template arguments. In other words, the compiler needs to generate different code for each instantiation of a template.
</p>

<p>For example, if <code class="d_inline">useSoundEmittingObject()</code> were implemented as a template, it would be compiled as many times as the number of different instantiations of it.
</p>

<p>Because it results in larger program size, this effect is called <i>code bloat</i>. Although this is not a problem in most programs, it is an effect of templates that must be known.
</p>

<p>Conversely, non-templated version of <code class="d_inline">useSoundEmittingObject()</code> would not have any code repetition. The compiler would compile that function just once and execute the same code for all types of the <code class="d_inline">SoundEmitter</code> interface. In run-time polymorphism, having the same code behave differently for different types is achieved by function pointers on the background. Although function pointers have a small cost at run time, that cost is not significant in most programs.
</p>

<p>Since both code bloat and run-time polymorphism have effects on program performance, it cannot be known beforehand whether run-time polymorphism or compile-time polymorphism would be a better approach for a specific program.
</p>

<h5 class="subsection"><a id="ix_More Templates.constraint, template" content="constraint, template"></a> <a id="ix_More Templates.template constraint" content="template constraint"></a> Template constraints</h5>

<p>The fact that templates can be instantiated with any argument yet not every argument is compatible with every template brings an inconvenience. If a template argument is not compatible with a particular template, the incompatibility is necessarily detected during the compilation of the template code for that argument. As a result, the compilation error points at a line inside the template implementation.
</p>

<p>Let's see this by using <code class="d_inline">useSoundEmittingObject()</code> with a type that does not support the <code class="d_inline">object.emitSound()</code> call:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Cup {
    <span class="d_comment">// ... does not have emitSound() ...
</span>}

<span class="d_comment">// ...
</span>
    useSoundEmittingObject(<span class="d_keyword">new</span> Cup);   <span class="d_comment">// ← incompatible type
</span></pre>

<p>Although arguably the error is with the code that uses the template with an incompatible type, the compilation error points at a line inside the template:
</p>

<pre class="d_code"><span class="d_keyword">void</span> useSoundEmittingObject(T)(T object) {
    <span class="d_comment">// ... some operations ...
</span>    writeln(object.emitSound());    <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
    <span class="d_comment">// ... more operations ...
</span>}
</pre>

<p>An undesired consequence is that when the template is a part of a third-party library module, the compilation error would appear to be a problem with the library itself.
</p>

<p>Note that this issue does not exist for interfaces: A function that takes an interface can only be called with a type that implements that interface. Attempting to call such a function with any other type is a compilation error at the caller.
</p>

<p><a id="ix_More Templates.if, template constraint" content="if, template constraint"></a> Template contraints are for disallowing incorrect instantiations of templates. They are defined as logical expressions of an <code class="d_inline">if</code> condition right before the template body:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(T)()
        <span class="d_keyword">if</span> (<span class="d_comment">/* ... constraints ... */</span>) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>A template definition is considered by the compiler only if its constraints evaluate to <code class="d_inline">true</code> for a specific instantiation of the template. Otherwise, the template definition is ignored for that use.
</p>

<p>Since templates are a compile-time feature, template constraints must be evaluable at compile time. The <code class="d_inline">is</code> expression that we saw in <a href="is_expr.html">the <code class="d_inline">is</code> Expression chapter</a> is commonly used in template constraints. We will use the <code class="d_inline">is</code> expression in the following examples as well.
</p>

<h6><a id="ix_More Templates.single-element tuple template parameter" content="single-element tuple template parameter"></a> <a id="ix_More Templates.tuple template parameter, single-element" content="tuple template parameter, single-element"></a> Tuple parameter of single element</h6>

<p>Sometimes the single parameter of a template needs to be one of type, value, or <code class="d_inline">alias</code> kinds. That can be achieved by a tuple parameter of length one:
</p>

<pre class="d_code"><span class="d_keyword">template</span> myTemplate(T...)
        <span class="hilite"><span class="d_keyword">if</span> (T.length == 1)</span> {
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="hilite">T[0]</span>)) {
        <span class="d_comment">// The single parameter is a type
</span>        <span class="d_keyword">enum</span> <span class="d_keyword">bool</span> myTemplate = <span class="d_comment">/* ... */</span>;

    } <span class="d_keyword">else</span> {
        <span class="d_comment">// The single parameter is some other kind
</span>        <span class="d_keyword">enum</span> <span class="d_keyword">bool</span> myTemplate = <span class="d_comment">/* ... */</span>;
    }
}
</pre>

<p>Some of the templates of the <code class="d_inline">std.traits</code> module take advantage of this idiom. We will see <code class="d_inline">std.traits</code> in a later chapter.
</p>

<h6><a id="ix_More Templates.named template constraint" content="named template constraint"></a> Named constraints</h6>

<p>Sometimes the constraints are complex, making it hard to understand the requirements of template parameters. This complexity can be handled by an idiom that effectively gives names to constraints. This idiom combines four features of D: anonymous functions, <code class="d_inline">typeof</code>, the <code class="d_inline">is</code> expression, and eponymous templates.
</p>

<p>Let's see this on a function template that has a type parameter. The template uses its function parameter in specific ways:
</p>

<pre class="d_code"><span class="d_keyword">void</span> use(T)(T object) {
    <span class="d_comment">// ...
</span>    object.prepare();
    <span class="d_comment">// ...
</span>    object.fly(42);
    <span class="d_comment">// ...
</span>    object.land();
    <span class="d_comment">// ...
</span>}
</pre>

<p>As is obvious from the implementation of the template, the types that this function can work with must support three specific function calls on the object: <code class="d_inline">prepare()</code>, <code class="d_inline">fly(42)</code>, and <code class="d_inline">land()</code>.
</p>

<p>One way of specifying a template constraint for that type is by the <code class="d_inline">is</code> and <code class="d_inline">typeof</code> expressions for each function call inside the template:
</p>

<pre class="d_code"><span class="d_keyword">void</span> use(T)(T object)
        <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(object.prepare())) &amp;&amp;
            <span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(object.fly(1))) &amp;&amp;
            <span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(object.land()))) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>I will explain that syntax below. For now, accept the whole construct of <code class="d_inline">is&nbsp;(typeof(object.prepare()))</code> to mean <i>whether the type supports the <code class="d_inline">.prepare()</code> call</i>.
</p>

<p>Although such constraints achieve the desired goal, sometimes they are too complex to be readable. Instead, it is possible to give a more descriptive name to the whole constraint:
</p>

<pre class="d_code"><span class="d_keyword">void</span> use(T)(T object)
        <span class="d_keyword">if</span> (canFlyAndLand!T) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>That constraint is more readable because it is now more clear that the template is designed to work with types that <i>can fly and land</i>.
</p>

<p>Such constraints are achieved by an idiom that is implemented similar to the following eponymous template:
</p>

<pre class="d_code"><span class="d_keyword">template</span> canFlyAndLand(T) {
    <span class="d_keyword">enum</span> canFlyAndLand = <span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(
    {
        T object;
        object.prepare();  <span class="d_comment">// should be preparable for flight
</span>        object.fly(1);     <span class="d_comment">// should be flyable for a certain distance
</span>        object.land();     <span class="d_comment">// should be landable
</span>    }()));
}
</pre>

<p>The D features that take part in that idiom and how they interact with each other are explained below:
</p>

<pre class="d_code"><span class="d_keyword">template</span> canFlyAndLand(T) {
    <span class="d_comment">//        (6)        (5)  (4)
</span>    <span class="d_keyword">enum</span> canFlyAndLand = <span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(
    <span class="hilite">{</span> <span class="d_comment">// (1)
</span>        T object;         <span class="d_comment">// (2)
</span>        object.prepare();
        object.fly(1);
        object.land();
 <span class="d_comment">// (3)
</span>    <span class="hilite">}</span>()));
}
</pre>

<ol>
<li><b>Anonymous function:</b> We have seen anonymous functions in <a href="lambda.html">the Function Pointers, Delegates, and Lambdas chapter</a>. The highlighted curly brackets above define an anonymous function.
</li>

<li><b>Function block:</b> The function block uses the type as it is supposed to be used in the actual template. First an object of that type is defined and then that object is used in specific ways. (This code never gets executed; see below.)
</li>

<li><b>Evaluation of the function:</b> The empty parentheses at the end of an anonymous function normally execute that function. However, since that call syntax is within a <code class="d_inline">typeof</code>, it is never executed.
</li>

<li><a id="ix_More Templates.typeof" content="typeof"></a> <b>The <code class="d_inline">typeof</code> expression:</b> <code class="d_inline">typeof</code> produces the type of an expression.

<p>An important fact about <code class="d_inline">typeof</code> is that it never executes the expression. Rather, it produces the type of the expression <i>if</i> that expression would be executed:
</p>

<pre class="d_code">    <span class="d_keyword">int</span> i = 42;
    <span class="d_keyword">typeof</span>(++i) j;    <span class="d_comment">// same as 'int j;'
</span>
    <span class="d_keyword">assert</span>(i == 42);  <span class="d_comment">// ++i has not been executed
</span></pre>

<p>As the previous <code class="d_inline">assert</code> proves, the expression <code class="d_inline">++i</code> has not been executed. <code class="d_inline">typeof</code> has merely produced the type of that expression as <code class="d_inline">int</code>.
</p>

<p>If the expression that <code class="d_inline">typeof</code> receives is not valid, <code class="d_inline">typeof</code> produces no type at all (not even <code class="d_inline">void</code>). So, if the anonymous function inside <code class="d_inline">canFlyAndLand</code> can be compiled successfully for <code class="d_inline">T</code>, <code class="d_inline">typeof</code> produces a valid type. Otherwise, it produces no type at all.
</p>

</li>

<li><b>The <code class="d_inline">is</code> expression:</b> We have seen many different uses of the <code class="d_inline">is</code> expression in <a href="is_expr.html">the <code class="d_inline">is</code> Expression chapter</a>. The <code class="d_inline">is&nbsp;(<i>Type</i>)</code> syntax produces <code class="d_inline">true</code> if <code class="d_inline">Type</code> is valid:

<pre class="d_code">    <span class="d_keyword">int</span> i;
    writeln(<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(i)));                  <span class="d_comment">// true
</span>    writeln(<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(nonexistentSymbol)));  <span class="d_comment">// false
</span></pre>

<p>Although the second <code class="d_inline">typeof</code> above receives a nonexistent symbol, the compiler does not emit a compilation error. Rather, the effect is that the <code class="d_inline">typeof</code> expression does not produce any type, so the <code class="d_inline">is</code> expression produces <code class="d_inline">false</code>:
</p>

<pre class="shell">true
false
</pre>

</li>

<li><b>Eponymous template:</b> As described above, since the <code class="d_inline">canFlyAndLand</code> template contains a definition by the same name, the template instantiation is that definition itself.
</li>

</ol>

<p>In the end, <code class="d_inline">use()</code> gains a more descriptive constraint:
</p>

<pre class="d_code"><span class="d_keyword">void</span> use(T)(T object)
        <span class="d_keyword">if</span> (canFlyAndLand!T) {
    <span class="d_comment">// ...
</span>}
</pre>

<p>Let's try to use that template with two types, one that satisfies the constraint and one that does not satisfy the constraint:
</p>

<pre class="d_code"><span class="d_comment">// A type that does match the template's operations
</span><span class="d_keyword">class</span> ModelAirplane {
    <span class="d_keyword">void</span> prepare() {
    }

    <span class="d_keyword">void</span> fly(<span class="d_keyword">int</span> distance) {
    }

    <span class="d_keyword">void</span> land() {
    }
}

<span class="d_comment">// A type that does not match the template's operations
</span><span class="d_keyword">class</span> Pigeon {
    <span class="d_keyword">void</span> fly(<span class="d_keyword">int</span> distance) {
    }
}

<span class="d_comment">// ...
</span>
    use(<span class="d_keyword">new</span> ModelAirplane);    <span class="d_comment">// ← compiles
</span>    use(<span class="d_keyword">new</span> Pigeon);           <span class="d_comment">// ← <span class="d_hata">derleme HATASI</span></span>
</pre>

<p>Named or not, since the template has a constraint, the compilation error points at the line where the template is used rather than where it is implemented.
</p>

<h5 class="subsection"><a id="ix_More Templates.overloading, operator" content="overloading, operator"></a> <a id="ix_More Templates.multi-dimensional operator overloading" content="multi-dimensional operator overloading"></a> <a id="ix_More Templates.operator overloading, multi-dimensional" content="operator overloading, multi-dimensional"></a> Using templates in multi-dimensional operator overloading</h5>

<p>We have seen in <a href="operator_overloading.html">the Operator Overloading chapter</a> that <code class="d_inline">opDollar</code>, <code class="d_inline">opIndex</code>, and <code class="d_inline">opSlice</code> are for element indexing and slicing. When overloaded for single-dimensional collections, these operators have the following responsibilities:
</p>

<ul>
<li><code class="d_inline">opDollar</code>: Returns the number of elements of the collection.</li>

<li><code class="d_inline">opSlice</code>: Returns an object that represents some or all of the elements of the collection.</li>

<li><code class="d_inline">opIndex</code>: Provides access to an element.</li>

</ul>

<p>Those operator functions have templated versions as well, which have different responsibilities from the non-templated ones above. Note especially that in multi-dimensional operator overloading <code class="d_inline">opIndex</code> assumes the responsibility of <code class="d_inline">opSlice</code>.
</p>

<ul>
<li><a id="ix_More Templates.opDollar template" content="opDollar template"></a> <code class="d_inline">opDollar</code> template: Returns the length of a specific dimension of the collection. The dimension is determined by the template parameter:

<pre class="d_code">    size_t opDollar<span class="hilite">(size_t dimension)</span>() <span class="d_keyword">const</span> {
        <span class="d_comment">// ...
</span>    }
</pre>

</li>

<li><a id="ix_More Templates.opSlice template" content="opSlice template"></a> <code class="d_inline">opSlice</code> template: Returns the range information that specifies the range of elements (e.g. the <code class="d_inline">begin</code> and <code class="d_inline">end</code> values in <code class="d_inline">array[begin..end]</code>). The information can be returned as <code class="d_inline">Tuple!(size_t, size_t)</code> or an equivalent type. The dimension that the range specifies is determined by the template parameter:

<pre class="d_code">    Tuple!(size_t, size_t) opSlice<span class="hilite">(size_t dimension)</span>(size_t begin,
                                                     size_t end) {
        <span class="d_keyword">return</span> tuple(begin, end);
    }
</pre>

</li>

<li><a id="ix_More Templates.opIndex template" content="opIndex template"></a> <code class="d_inline">opIndex</code> template: Returns a range object that represents a part of the collection. The range of elements are determined by the template parameters:

<pre class="d_code">    Range opIndex<span class="hilite">(A...)</span>(A arguments) {
        <span class="d_comment">// ...
</span>    }
</pre>

</li>

</ul>

<p><a id="ix_More Templates.opIndexAssign template" content="opIndexAssign template"></a> <a id="ix_More Templates.opIndexOpAssign template" content="opIndexOpAssign template"></a> <code class="d_inline">opIndexAssign</code> and <code class="d_inline">opIndexOpAssign</code> have templated versions as well, which operate on a range of elements of the collection.
</p>

<p>The user-defined types that define these operators can be used with the multi-dimensional indexing and slicing syntax:
</p>

<pre class="d_code">              <span class="d_comment">// Assigns 42 to the elements specified by the
</span>              <span class="d_comment">// indexing and slicing arguments:
</span>              m[a, b..c, $-1, d..e] = 42;
<span class="d_comment">//              ↑   ↑     ↑    ↑
</span><span class="d_comment">// dimensions:  0   1     2    3
</span></pre>

<p>Such expressions are first converted to the ones that call the operator functions. The conversions are performed by replacing the <code class="d_inline">$</code> characters with calls to <code class="d_inline">opDollar!dimension()</code>, and the index ranges with calls to <code class="d_inline">opSlice!dimension(begin, end)</code>. The length and range information that is returned by those calls is in turn used as arguments when calling e.g. <code class="d_inline">opIndexAssign</code>. Accordingly, the expression above is executed as the following equivalent (the dimension values are highlighted):
</p>

<pre class="d_code">    <span class="d_comment">// The equivalent of the above:
</span>    m.opIndexAssign(
        42,                    <span class="d_comment">// ← value to assign
</span>        a,                     <span class="d_comment">// ← argument for dimension 0
</span>        m.opSlice!<span class="hilite">1</span>(b, c),     <span class="d_comment">// ← argument for dimension 1
</span>        m.opDollar!<span class="hilite">2</span>() - 1,    <span class="d_comment">// ← argument for dimension 2
</span>        m.opSlice!<span class="hilite">3</span>(d, e));    <span class="d_comment">// ← argument for dimension 3
</span></pre>

<p>Consequently, <code class="d_inline">opIndexAssign</code> determines the range of elements from the arguments.
</p>

<h6>Multi-dimensional operator overloading example</h6>

<p>The following <code class="d_inline">Matrix</code> example demonstrates how these operators can be overloaded for a two-dimensional type.
</p>

<p>Note that this code can be implemented in more efficient ways. For example, instead of constructing a <i>single-element sub-matrix</i> even when operating on a single element e.g. by <code class="d_inline">m[i, j]</code>, it could apply the operation directly on that element.
</p>

<p>Additionally, the <code class="d_inline">writeln(__FUNCTION__)</code> expressions inside the functions have nothing to do with the behavior of the code. They merely help expose the functions that get called behind the scenes for different operator usages.
</p>

<p>Also note that the correctness of dimension values are enforced by template constraints.
</p>

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.format;
<span class="d_keyword">import</span> std.string;

<span class="d_comment">/* Works as a two-dimensional int array. */</span>
<span class="d_keyword">struct</span> Matrix {
<span class="d_keyword">private</span>:

    <span class="d_keyword">int</span>[][] rows;

    <span class="d_comment">/* Represents a range of rows or columns. */</span>
    <span class="d_keyword">struct</span> Range {
        size_t begin;
        size_t end;
    }

    <span class="d_comment">/* Returns the sub-matrix that is specified by the row and
     * column ranges. */</span>
    Matrix subMatrix(Range rowRange, Range columnRange) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        <span class="d_keyword">int</span>[][] slices;

        <span class="d_keyword">foreach</span> (row; rows[rowRange.begin .. rowRange.end]) {
            slices ~= row[columnRange.begin .. columnRange.end];
        }

        <span class="d_keyword">return</span> Matrix(slices);
    }

<span class="d_keyword">public</span>:

    <span class="d_keyword">this</span>(size_t height, size_t width) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        rows = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][](height, width);
    }

    <span class="d_keyword">this</span>(<span class="d_keyword">int</span>[][] rows) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        <span class="d_keyword">this</span>.rows = rows;
    }

    <span class="d_keyword">void</span> toString(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[]) sink) <span class="d_keyword">const</span> {
        sink.formattedWrite!<span class="d_string">"%(%(%5s %)\n%)"</span>(rows);
    }

    <span class="d_comment">/* Assigns the specified value to each element of the
     * matrix. */</span>
    Matrix opAssign(<span class="d_keyword">int</span> value) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        <span class="d_keyword">foreach</span> (row; rows) {
            row[] = value;
        }

        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_comment">/* Uses each element and a value in a binary operation
     * and assigns the result back to that element. */</span>
    Matrix opOpAssign(string op)(<span class="d_keyword">int</span> value) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        <span class="d_keyword">foreach</span> (row; rows) {
            <span class="d_keyword">mixin</span> (<span class="d_string">"row[] "</span> ~ op ~ <span class="d_string">"= value;"</span>);
        }

        <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
    }

    <span class="d_comment">/* Returns the length of the specified dimension. */</span>
    size_t opDollar(size_t dimension)() <span class="d_keyword">const</span>
            <span class="d_keyword">if</span> (dimension &lt;= 1) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (dimension == 0) {
            <span class="d_comment">/* The length of dimension 0 is the length of the
             * 'rows' array. */</span>
            <span class="d_keyword">return</span> rows.length;

        } <span class="d_keyword">else</span> {
            <span class="d_comment">/* The length of dimension 1 is the lengths of the
             * elements of 'rows'. */</span>
            <span class="d_keyword">return</span> rows.length ? rows[0].length : 0;
        }
    }

    <span class="d_comment">/* Returns an object that represents the range from
     * 'begin' to 'end'.
     *
     * Note: Although the 'dimension' template parameter is
     * not used here, that information can be useful for other
     * types. */</span>
    Range opSlice(size_t dimension)(size_t begin, size_t end)
            <span class="d_keyword">if</span> (dimension &lt;= 1) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        <span class="d_keyword">return</span> Range(begin, end);
    }

    <span class="d_comment">/* Returns a sub-matrix that is defined by the
     * arguments. */</span>
    Matrix opIndex(A...)(A arguments)
            <span class="d_keyword">if</span> (A.length &lt;= 2) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        <span class="d_comment">/* We start with ranges that represent the entire
         * matrix so that the parameter-less use of opIndex
         * means "all of the elements". */</span>
        Range[2] ranges = [ Range(0, opDollar!0),
                            Range(0, opDollar!1) ];

        <span class="d_keyword">foreach</span> (dimension, a; arguments) {
            <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(a) == Range)) {
                <span class="d_comment">/* This dimension is already specified as a
                 * range like 'matrix[begin..end]', which can
                 * be used as is. */</span>
                ranges[dimension] = a;

            } <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span> (<span class="d_keyword">typeof</span>(a) : size_t)) {
                <span class="d_comment">/* This dimension is specified as a single
                 * index value like 'matrix[i]', which we want
                 * to represent as a single-element range. */</span>
                ranges[dimension] = Range(a, a + 1);

            } <span class="d_keyword">else</span> {
                <span class="d_comment">/* We don't expect other types. */</span>
                <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(
                    <span class="d_keyword">false</span>, format(<span class="d_string">"Invalid index type: %s"</span>,
                                  <span class="d_keyword">typeof</span>(a).stringof));
            }
        }

        <span class="d_comment">/* Return the sub-matrix that is specified by
         * 'arguments'. */</span>
        <span class="d_keyword">return</span> subMatrix(ranges[0], ranges[1]);
    }

    <span class="d_comment">/* Assigns the specified value to each element of the
     * sub-matrix. */</span>
    Matrix opIndexAssign(A...)(<span class="d_keyword">int</span> value, A arguments)
            <span class="d_keyword">if</span> (A.length &lt;= 2) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        Matrix subMatrix = opIndex(arguments);
        <span class="d_keyword">return</span> subMatrix = value;
    }

    <span class="d_comment">/* Uses each element of the sub-matrix and a value in a
     * binary operation and assigns the result back to that
     * element. */</span>
    Matrix opIndexOpAssign(string op, A...)(<span class="d_keyword">int</span> value,
                                            A arguments)
            <span class="d_keyword">if</span> (A.length &lt;= 2) {
        writeln(<span class="d_keyword">__FUNCTION__</span>);

        Matrix subMatrix = opIndex(arguments);
        <span class="d_keyword">mixin</span> (<span class="d_string">"return subMatrix "</span> ~ op ~ <span class="d_string">"= value;"</span>);
    }
}

<span class="d_comment">/* Executes the expression that is specified as a string, and
 * prints the result as well as the new state of the
 * matrix. */</span>
<span class="d_keyword">void</span> execute(string expression)(Matrix m) {
    writefln(<span class="d_string">"\n--- %s ---"</span>, expression);
    <span class="d_keyword">mixin</span> (<span class="d_string">"auto result = "</span> ~ expression ~ <span class="d_string">";"</span>);
    writefln(<span class="d_string">"result:\n%s"</span>, result);
    writefln(<span class="d_string">"m:\n%s"</span>, m);
}

<span class="d_keyword">void</span> main() {
    <span class="d_keyword">enum</span> height = 10;
    <span class="d_keyword">enum</span> width = 8;

    <span class="d_keyword">auto</span> m = Matrix(height, width);

    <span class="d_keyword">int</span> counter = 0;
    <span class="d_keyword">foreach</span> (row; 0 .. height) {
        <span class="d_keyword">foreach</span> (column; 0 .. width) {
            writefln(<span class="d_string">"Initializing %s of %s"</span>,
                     counter + 1, height * width);

            m[row, column] = counter;
            ++counter;
        }
    }

    writeln(m);

    execute!(<span class="d_string">"m[1, 1] = 42"</span>)(m);
    execute!(<span class="d_string">"m[0, 1 .. &dollar;] = 43"</span>)(m);
    execute!(<span class="d_string">"m[0 .. &dollar;, 3] = 44"</span>)(m);
    execute!(<span class="d_string">"m[&dollar;-4 .. &dollar;-1, &dollar;-4 .. &dollar;-1] = 7"</span>)(m);

    execute!(<span class="d_string">"m[1, 1] *= 2"</span>)(m);
    execute!(<span class="d_string">"m[0, 1 .. &dollar;] *= 4"</span>)(m);
    execute!(<span class="d_string">"m[0 .. &dollar;, 0] *= 10"</span>)(m);
    execute!(<span class="d_string">"m[&dollar;-4 .. &dollar;-2, &dollar;-4 .. &dollar;-2] -= 666"</span>)(m);

    execute!(<span class="d_string">"m[1, 1]"</span>)(m);
    execute!(<span class="d_string">"m[2, 0 .. &dollar;]"</span>)(m);
    execute!(<span class="d_string">"m[0 .. &dollar;, 2]"</span>)(m);
    execute!(<span class="d_string">"m[0 .. &dollar; / 2, 0 .. &dollar; / 2]"</span>)(m);

    execute!(<span class="d_string">"++m[1..3, 1..3]"</span>)(m);
    execute!(<span class="d_string">"--m[2..5, 2..5]"</span>)(m);

    execute!(<span class="d_string">"m[]"</span>)(m);
    execute!(<span class="d_string">"m[] = 20"</span>)(m);
    execute!(<span class="d_string">"m[] /= 4"</span>)(m);
    execute!(<span class="d_string">"(m[] += 5) /= 10"</span>)(m);
}
</pre>

<h5 class="subsection">Summary</h5>

<p>The earlier template chapter had the following reminders:
</p>

<ul>
<li>Templates define the code as a pattern, for the compiler to generate instances of it according to the actual uses in the program.</li>

<li>Templates are a compile-time feature.</li>

<li>Specifying template parameter lists is sufficient to make function, struct, and class definitions templates.</li>

<li>Template arguments can be specified explicitly after an exclamation mark. The parentheses are not necessary when there is only one token inside the parentheses.</li>

<li>Each template instantiation yields a different type.</li>

<li>Template arguments can only be deduced for function templates.</li>

<li>Templates can be specialized for the type that is after the <code class="d_inline">:</code> character.</li>

<li>Default template arguments are specified after the <code class="d_inline">=</code> character.</li>

</ul>

<p>This chapter added the following concepts:
</p>

<ul>
<li>Templates can be defined by the full syntax or the shortcut syntax.</li>

<li>The scope of the template is a name space.</li>

<li>A template that contains a definition with the same name as the template is called an eponymous template. The template represents that definition.</li>

<li>Templates can be of functions, classes, structs, unions, and interfaces, and every template body can contain any number of definitions.</li>

<li>Template parameters can be of type, value, <code class="d_inline">this</code>, <code class="d_inline">alias</code>, and tuple kinds.</li>

<li><code class="d_inline">typeof(this)</code>, <code class="d_inline">typeof(super)</code>, and <code class="d_inline">typeof(return)</code> are useful in templates.</li>

<li>Templates can be specialized for particular arguments.</li>

<li>Meta programming is a way of executing operations at compile time.</li>

<li>Templates enable <i>compile-time polymorphism</i>.</li>

<li>Separate code generation for different instantiations can cause <i>code bloat</i>.</li>

<li>Template constraints limit the uses of templates for specific template arguments. They help move compilation errors from the implementations of templates to where the templates are actually used incorrectly.</li>

<li>It is more readable to give names to template constraints.</li>

<li>The templated versions of <code class="d_inline">opDollar</code>, <code class="d_inline">opSlice</code>, <code class="d_inline">opIndex</code>, <code class="d_inline">opIndexAssign</code>, and <code class="d_inline">opIndexOpAssign</code> are for multi-dimensional indexing and slicing.</li>

</ul>


        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on Mon Apr  1 20:41:04 2024
</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>


<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2024 by the D Language Foundation
    All Rights Reserved.
    https://dlang.org/foundation_overview.html
  -->
<head>
<meta charset="utf-8">
<meta name="keywords" content="D programming language">
<meta name="description" content="D Programming Language">
<title>Arrays - D Programming Language</title>

<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/print.css" media="print">
<link rel="shortcut icon" href="../favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0">

</head>
<body id='Arrays' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top"><div class="helper"><div class="helper expand-container">    <div class="logo"><a href=".."><img id="logo" alt="D Logo" src="../images/dlogo.svg"></a></div>
    <a href="../menu.html" title="Menu" class="hamburger expand-toggle"><span>Menu</span></a>
    
<div id="cssmenu"><ul>    <li><a href='https://tour.dlang.org'><span>Learn</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../documentation.html'><span>Documentation</span></a>
      
<ul class='expand-content'>    <li><a href='../spec/spec.html'>Language Reference</a></li>
    <li><a href='../phobos/index.html'>Library Reference</a></li>
    <li><a href='../dmd.html'>Command-line Reference</a></li>
    <li class="menu-divider"><a href='../comparison.html'>Feature Overview</a></li>
    <li><a href='../articles.html'>Articles</a></li>
 </ul></li>
    <li><a href='../download.html'><span>Downloads</span></a></li>
    <li><a href='https://code.dlang.org'><span>Packages</span></a></li>
    <li class='expand-container'><a class='expand-toggle' href='../community.html'><span>Community</span></a>
      
<ul class='expand-content'>    <li><a href='https://dlang.org/blog'>Blog</a></li>
    <li><a href='../orgs-using-d.html'>Orgs using D</a></li>
    <li><a href='https://twitter.com/search?q=%23dlang'>Twitter</a></li>
    <li class="menu-divider"><a href='https://forum.dlang.org'>Forums</a></li>
    <li><a href='irc://irc.libera.chat/d'>IRC</a></li>
    <li><a href='https://discord.gg/bMZk9Q4'>Community Discord</a></li>
    <li><a href='https://wiki.dlang.org'>Wiki</a></li>
    <li class="menu-divider"><a href='https://github.com/dlang'>GitHub</a></li>
    <li><a href='../bugstats.html'>Issues</a></li>
    <li><a href='https://wiki.dlang.org/Get_involved'>Get involved</a></li>
    <li class="menu-divider"><a href='../foundation/contributors.html'>Contributors</a></li>
    <li><a href='../foundation/index.html'>Foundation</a></li>
    <li><a href='..//security.html'>Security Team</a></li>
    <li><a href='../foundation/donate.html'>Donate</a></li>
    <li><a href='../foundation/sponsors.html'>Sponsors</a></li>
 </ul></li>
    <li class='expand-container'><a class='expand-toggle' href='../resources.html'><span>Resources</span></a>
      
<ul class='expand-content'>    <li><a href='https://tour.dlang.org'>Tour</a></li>
    <li><a href='https://wiki.dlang.org/Books'>Books</a></li>
    <li><a href='https://wiki.dlang.org/Tutorials'>Tutorials</a></li>
    <li class="menu-divider"><a href='https://wiki.dlang.org/Development_tools'>Tools</a></li>
    <li><a href='https://wiki.dlang.org/Editors'>Editors</a></li>
    <li><a href='https://wiki.dlang.org/IDEs'>IDEs</a></li>
    <li><a href='https://run.dlang.io'>run.dlang.io</a></li>
    <li><a href='http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li>
    <li class="menu-divider"><a href='../acknowledgements.html'>Acknowledgments</a></li>
    <li><a href='../dstyle.html'>D Style</a></li>
    <li><a href='../spec/glossary.html'>Glossary</a></li>
    <li><a href='../sitemap.html'>Sitemap</a></li>
 </ul></li>
</ul></div>
    <div class="search-container expand-container">        <a href="../search.html" class="expand-toggle" title="Search"><span>Search</span></a>
        
    <div id="search-box">        <form method="get" action="https://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org">
            <input type="hidden" id="sourceid" name="sourceid" value="google-search">
            <span id="search-query"><input id="q" name="q" placeholder="Google Search"></span><span id="search-dropdown"><span class="helper">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire Site</option>
                    <option selected value="dlang.org/spec">Language</option>
                    <option  value="dlang.org/phobos">Library</option>
                    <option  value="forum.dlang.org">Forums</option>
                    
                </select>
            </span></span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    </div>
</div></div></div>

<div class="container">    
<div class="subnav-helper"></div> <div class="subnav">    <div class="head"><h2>Language Reference</h2> <p class="subnav-duplicate"><a href="../spec/spec.html">table of contents</a></p></div>
    <ul>        <li><a href='            ../spec/intro.html'>Introduction</a></li><li><a href='            ../spec/lex.html'>Lexical</a></li><li><a href='            ../spec/istring.html'>Interpolation Expression Sequence</a></li><li><a href='            ../spec/grammar.html'>Grammar</a></li><li><a href='            ../spec/module.html'>Modules</a></li><li><a href='            ../spec/declaration.html'>Declarations</a></li><li><a href='            ../spec/type.html'>Types</a></li><li><a href='            ../spec/property.html'>Properties</a></li><li><a href='            ../spec/attribute.html'>Attributes</a></li><li><a href='            ../spec/pragma.html'>Pragmas</a></li><li><a href='            ../spec/expression.html'>Expressions</a></li><li><a href='            ../spec/statement.html'>Statements</a></li><li><a href='            ../spec/arrays.html'>Arrays</a></li><li><a href='            ../spec/hash-map.html'>Associative Arrays</a></li><li><a href='            ../spec/struct.html'>Structs and Unions</a></li><li><a href='            ../spec/class.html'>Classes</a></li><li><a href='            ../spec/interface.html'>Interfaces</a></li><li><a href='            ../spec/enum.html'>Enums</a></li><li><a href='            ../spec/const3.html'>Type Qualifiers</a></li><li><a href='            ../spec/function.html'>Functions</a></li><li><a href='            ../spec/operatoroverloading.html'>Operator Overloading</a></li><li><a href='            ../spec/template.html'>Templates</a></li><li><a href='            ../spec/template-mixin.html'>Template Mixins</a></li><li><a href='            ../spec/contracts.html'>Contract Programming</a></li><li><a href='            ../spec/version.html'>Conditional Compilation</a></li><li><a href='            ../spec/traits.html'>Traits</a></li><li><a href='            ../spec/errors.html'>Error Handling</a></li><li><a href='            ../spec/unittest.html'>Unit Tests</a></li><li><a href='            ../spec/garbage.html'>Garbage Collection</a></li><li><a href='            ../spec/float.html'>Floating Point</a></li><li><a href='            ../spec/iasm.html'>D x86 Inline Assembler</a></li><li><a href='            ../spec/ddoc.html'>Embedded Documentation</a></li><li><a href='            ../spec/interfaceToC.html'>Interfacing to C</a></li><li><a href='            ../spec/cpp_interface.html'>Interfacing to C++</a></li><li><a href='            ../spec/objc_interface.html'>Interfacing to Objective-C</a></li><li><a href='            ../spec/portability.html'>Portability Guide</a></li><li><a href='            ../spec/entity.html'>Named Character Entities</a></li><li><a href='            ../spec/memory-safe-d.html'>Memory Safety</a></li><li><a href='            ../spec/abi.html'>Application Binary Interface</a></li><li><a href='            ../spec/simd.html'>Vector Extensions</a></li><li><a href='            ../spec/betterc.html'>Better C</a></li><li><a href='            ../spec/importc.html'>ImportC</a></li><li><a href='            ../spec/ob.html'>Live Functions</a></li><li><a href='            ../spec/windows.html'>Windows Programming</a></li><li><a href='            ../spec/glossary.html'>Glossary</a></li><li><a href='            ../spec/legacy.html'>Legacy Code
        </a></li>
    </ul>
</div>
    <div class="hyphenate" id="content">        
<div id="tools"><div >	<div class="tip smallprint">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&amp;component=dlang.org&amp;op_sys=All&amp;priority=P3&amp;product=D&amp;rep_platform=All&amp;short_desc=%5BArrays%5D&amp;version=D2&amp;bug_severity=enhancement">Report a bug</a>
		<div >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</div>
	</div>
	<div class="tip smallprint">		<a href="https://github.com/dlang/dlang.org/edit/master/spec/arrays.dd">Improve this page</a>
		<div >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			a local clone.
		</div>
	</div>
</div></div>
        <h1>Arrays</h1>
        
<style>    body { counter-reset: h1 13; counter-increment: h1 -1; }
    h1 { counter-reset: h2 h3 p; }
    h2 { counter-reset: h3 h4 p; }
    h3 { counter-reset: h4 p; }
    h4 { counter-reset: p; }
    h1::before {
        counter-increment: h1;
        content: counter(h1) ". ";
    }
    .hyphenate h2::before {
        counter-increment: h2;
        content: counter(h1) "." counter(h2) " ";
    }
    h3::before {
        counter-increment: h3;
        content: counter(h1) "." counter(h2) "." counter(h3) " ";
    }
    h4::before {
        counter-increment: h4;
        content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) " ";
    }
    p::before, .spec-boxes::before {
        counter-increment: p;
        content: counter(p) ". ";
    }
    h1::before, h2::before, h3::before, h4::before, p::before, .spec-boxes::before
    {
        color: #999;
        font-size: 80%;
        margin-right: 0.25em;
    }
</style>
        <div class="blankline"></div>
<div class="blankline"></div>
<div class="blankline"></div>
<div class="page-contents quickindex">    <div class="page-contents-header">        <b>Contents</b>
    </div>
    <ol>    <li><a href="#array-kinds">Kinds</a><ol>        <li><a href="#static-arrays">Static Arrays</a></li>
        <li><a href="#dynamic-arrays">Dynamic Arrays</a></li>
        <li><a href="#pointers">Pointer Arrays</a></li>
    </ol></li>
    <li><a href="#declarations">Array Declarations</a></li>
    <li><a href="#literals">Array Literals</a></li>
    <li><a href="#assignment">Array Assignment</a></li>
    <li><a href="#indexing">Indexing</a><ol>        <li><a href="#pointer-arithmetic">Pointer Arithmetic</a></li>
    </ol></li>
    <li><a href="#slicing">Slicing</a></li>
    <li><a href="#array-length">Array Length</a></li>
    <li><a href="#array-copying">Array Copying</a><ol>        <li><a href="#overlapping-copying">Overlapping Copying</a></li>
    </ol></li>
    <li><a href="#array-setting">Array Setting</a></li>
    <li><a href="#array-concatenation">Array Concatenation</a></li>
    <li><a href="#array-appending">Array Appending</a></li>
    <li><a href="#array-operations">Vector Operations</a></li>
    <li><a href="#rectangular-arrays">Rectangular Arrays</a></li>
    <li><a href="#array-properties">Array Properties</a><ol>        <li><a href="#resize">Setting Dynamic Array Length</a></li>
        <li><a href="#capacity-reserve"><span class="d_inlinecode donthyphenate notranslate">capacity</span> and <span class="d_inlinecode donthyphenate notranslate">reserve</span></a></li>
        <li><a href="#func-as-property">Functions as Array Properties</a></li>
    </ol></li>
    <li><a href="#bounds">Array Bounds Checking</a><ol>        <li><a href="#disable-bounds-check">Disabling Array Bounds Checking</a></li>
    </ol></li>
    <li><a href="#array-initialization">Array Initialization</a><ol>        <li><a href="#default-initialization">Default Initialization</a></li>
        <li><a href="#length-initialization">Length Initialization</a></li>
        <li><a href="#void-initialization">Void Initialization</a></li>
        <li><a href="#static-init-static">Static Initialization of Statically Allocated Arrays</a></li>
    </ol></li>
    <li><a href="#special-array">Special Array Types</a><ol>        <li><a href="#strings">Strings</a></li>
        <li><a href="#void_arrays">Void Arrays</a></li>
    </ol></li>
    <li><a href="#implicit-conversions">Implicit Conversions</a></li>
</ol>
</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-kinds" href="#array-kinds">Kinds</a></h2>
<div class="blankline"></div>
    <p>There are four kinds of arrays:</p>
<div class="blankline"></div>
    <center><table><caption>Kinds of Arrays</caption>        <tr><th class="donthyphenate"><b>Syntax</b></th><th class="donthyphenate"><b>Description</b></th></tr>
        <tr><td><i>type</i>[<i>integer</i>]</td><td><a href="#static-arrays">Static arrays</a></td></tr>
        <tr><td><i>type</i>[]</td><td> <a href="#dynamic-arrays">Dynamic arrays</a></td></tr>
        <tr><td><i>type</i>*</td><td><a href="#pointers">Pointer arrays</a></td></tr>
        <tr><td><i>type</i>[<i>type</i>]</td><td><a href="../spec/hash-map.html">Associative arrays</a></td></tr>
    </table></center>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="static-arrays" href="#static-arrays">Static Arrays</a></h3>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] s;
</pre>

</div>
<div class="blankline"></div>
        <p>Static arrays have a length fixed at compile time.
        </p>
<div class="blankline"></div>
        <p>The total size of a static array cannot exceed 16Mb.
        </p>
<div class="blankline"></div>
        <p>A static array with a dimension of 0 is allowed, but no
        space is allocated for it.
        </p>
<div class="blankline"></div>
        <p>Static arrays are value types.
        They are passed to and returned by functions by value.
        </p>
<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b>         <ol>        <li>Use dynamic arrays for larger arrays.</li>
        <li>Static arrays with 0 elements are useful as the last member
        of a variable length struct, or as the degenerate case of
        a template expansion.</li>
        <li>Because static arrays are passed to functions by value,
        a larger array can consume a lot of stack space. Use dynamic arrays
        instead.</li>
        </ol></div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="dynamic-arrays" href="#dynamic-arrays">Dynamic Arrays</a></h3>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a;
</pre>

</div>
<div class="blankline"></div>
        <p>Dynamic arrays consist of a length and a pointer to the array data.
        Multiple dynamic arrays can share all or parts of the array data.
        </p>
<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b>         <ol>        <li>Use dynamic arrays instead of pointer arrays as much as practical.
        Indexing of dynamic arrays are bounds checked, avoiding buffer underflow and
        overflow problems.</li>
        </ol></div>


<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="pointers" href="#pointers">Pointer Arrays</a></h3>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">int</span>* p;
</pre>
<div class="blankline"></div>
        <p>A <a href="../spec/type.html#pointers">pointer</a>
        can manipulate a block of multiple contiguous values in memory.
        Accessing more than one value cannot be
        <a href="../spec/memory-safe-d.html"><span class="d_inlinecode donthyphenate notranslate">@safe</span></a> as it
        requires <a href="#pointer-arithmetic">pointer arithmetic</a>.
        This is supported for interfacing with C and for
        specialized systems work.
        A pointer has no length associated with it, so there is no way for the
        compiler or runtime to do bounds checking, etc., on it.
        </p>
<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b> Most conventional uses for pointers can be replaced with
        dynamic arrays, <span class="d_inlinecode donthyphenate notranslate">ref</span> and <span class="d_inlinecode donthyphenate notranslate">out</span> <a href="../spec/function.html#parameters">parameters</a>,
        and reference types.
        </div>


<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="declarations" href="#declarations">Array Declarations</a></h2>
<div class="blankline"></div>
        <p>Declarations appear before the identifier being
        declared and read right to left, so:
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a;      <span class="d_comment">// dynamic array of ints
</span><span class="d_keyword">int</span>[4][3] b;  <span class="d_comment">// array of 3 arrays of 4 ints each
</span><span class="d_keyword">int</span>[][5] c;   <span class="d_comment">// array of 5 dynamic arrays of ints.
</span><span class="d_keyword">int</span>*[]*[3] d; <span class="d_comment">// array of 3 pointers to dynamic arrays of pointers to ints
</span><span class="d_keyword">int</span>[]* e;     <span class="d_comment">// pointer to dynamic array of ints
</span></pre>

</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="literals" href="#literals">Array Literals</a></h2>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a1 = [1,2,3];  <span class="d_comment">// type is int[], with elements 1, 2, and 3
</span><span class="d_keyword">auto</span> a2 = [1u,2,3]; <span class="d_comment">// type is uint[], with elements 1u, 2u, and 3u
</span><span class="d_keyword">int</span>[2] a3 = [1,2];  <span class="d_comment">// type is int[2], with elements 1, and 2
</span></pre>
    <p><span class="d_inlinecode donthyphenate notranslate">[]</span> is an empty array literal.</p>
<div class="blankline"></div>
    <p>See <a href="../spec/expression.html#array_literals">Array Literals</a>.</p>
<div class="blankline"></div>
<span id="usage"><a class="anchor" title="Permalink to this section" id="" href="#"></a></span>
<h2><a class="anchor" title="Permalink to this section" id="assignment" href="#assignment">Array Assignment</a></h2>
<div class="blankline"></div>
        <p>There are two broad kinds of operations to do on dynamic arrays and
        pointer arrays - those affecting the handle to the array,
        and those affecting the contents of the array. Assignment only affects
        the handle for these types.
        </p>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">.ptr</span> property for static and dynamic arrays will give the address
        of the first element in the array:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>* p;
<span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[] a;

p = s.ptr; <span class="d_comment">// p points to the first element of the array s.
</span>p = a.ptr; <span class="d_comment">// p points to the first element of the array a.
</span>
<span class="d_comment">// error, since the length of the array pointed to by p is unknown
</span><span class="d_comment">//s = p;
</span>
<span class="d_comment">//a = p;   // error, length unknown
</span>a = s;     <span class="d_comment">// a points to the elements of s
</span><span class="d_keyword">assert</span>(a.ptr == s.ptr);

<span class="d_keyword">int</span>[] b;
a = b;     <span class="d_comment">// a points to the same array as b does
</span><span class="d_keyword">assert</span>(a.ptr == b.ptr);
<span class="d_keyword">assert</span>(a == []);
</pre>

</div>
    <div class="spec-boxes note"><b>Note:</b> The two error lines above can be made to copy elements
    using pointer <a href="#slicing">slicing</a>, so that the number of elements
    to copy is then known.</div>
<div class="blankline"></div>
    <p>A static array can be assigned from a dynamic array - the data is copied.
    The lengths must match:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[] a;

<span class="d_comment">//s = [1, 2]; // error
</span>s = [1, 2, 3]; <span class="d_comment">// OK
</span><span class="d_comment">//s = [1, 2, 3, 4]; // error
</span>
a = [4, 5, 6];
s = a; <span class="d_comment">// OK
</span><span class="d_keyword">assert</span>(s.ptr != a.ptr);
a = [1, 2];
<span class="d_comment">//s = a; // RangeError, length mismatch
</span>
a = s;
<span class="d_keyword">assert</span>(a.ptr == s.ptr);
<span class="d_comment">//s = a; // RangeError, overlap
</span></pre>

</div>
    <p>The dynamic array data must not <a href="#overlapping-copying">overlap</a>
    with the static array memory.
    See also <a href="#array-copying">Copying</a>.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="indexing" href="#indexing">Indexing</a></h2>
<div class="blankline"></div>
    <p>Indexing allows access to an element of an array:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">auto</span> a = [1,2,3];
<span class="d_keyword">assert</span>(a[0] == 1);
<span class="d_keyword">assert</span>(a[2] == 3);
a[2] = 4;
<span class="d_keyword">assert</span>(a[2] == 4);
<span class="d_keyword">assert</span>(a == [1,2,4]);
<span class="d_comment">//writeln(a[3]); // runtime error (unless bounds checks turned off)
</span>
<span class="d_keyword">int</span>[2] b = [1,2];
<span class="d_keyword">assert</span>(b[1] == 2);
<span class="d_comment">//writeln(b[2]); // compile-time error, index out of bounds
</span></pre>

</div>
<div class="blankline"></div>
    <p>See also <a href="../spec/expression.html#IndexOperation"><i>IndexOperation</i></a>.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="pointer-arithmetic" href="#pointer-arithmetic">Pointer Arithmetic</a></h3>
<div class="blankline"></div>
    <p>A pointer can also be indexed, but no bounds checks are done.
    Unlike arrays, a pointer value can also be used in certain
    arithmetic expressions to produce another pointer:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [1,2,3];
<span class="d_keyword">int</span>* p = a.ptr;

p[2] = 4;
<span class="d_keyword">assert</span>(a[2] == 4);
writeln(p[3]); <span class="d_comment">// undefined behaviour
</span>
<span class="d_keyword">assert</span>(p == &amp;a[0]);
p++; <span class="d_comment">// point to a[1]
</span><span class="d_keyword">assert</span>(*p == 2);
</pre>

</div>
<div class="blankline"></div>
    <p>See <a href="../spec/expression.html#pointer_arithmetic"><em>AddExpression</em></a> for details.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="slicing" href="#slicing">Slicing</a></h2>
<div class="blankline"></div>
        <p><i>Slicing</i> an array means to specify a subarray of it.
        This is done by supplying two index expressions.
        The elements from the start index up until the end index are selected.
        Any item at the end index is not included.
        </p>
        <p>        An array slice does not copy the data, it is only another
        reference to it. Slicing produces a dynamic array.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] a = [4, 5, 6]; <span class="d_comment">// static array of 3 ints
</span><span class="d_keyword">int</span>[] b;

b = a[1..3]; <span class="d_comment">// a[1..3] is a 2 element dynamic array consisting of
</span>             <span class="d_comment">// a[1] and a[2]
</span><span class="d_keyword">assert</span>(b == [5, 6]);
<span class="d_keyword">assert</span>(b.ptr == a.ptr + 1);

a[2] = 3;
<span class="d_keyword">assert</span>(b == [5, 3]);

b = b[1..2];
<span class="d_keyword">assert</span>(b == [3]);
</pre>

</div>
<div class="blankline"></div>
        <p><i>Expression</i><span class="d_inlinecode donthyphenate notranslate">[]</span> is shorthand for a slice of the entire array.
        </p>
<div class="blankline"></div>
        <p>Slicing
        is not only handy for referring to parts of other arrays,
        but for converting pointers into bounds-checked arrays:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[10] a = [ 1,2,3,4,5,6,7,8,9,10 ];

<span class="d_keyword">int</span>* p = &amp;a[2];
writeln(p[7]);      <span class="d_comment">// 10
</span>writeln(p[8]);      <span class="d_comment">// undefined behaviour
</span>
<span class="d_keyword">int</span>[] b = p[0..8];  <span class="d_comment">// convert pointer elements to dynamic array
</span><span class="d_keyword">assert</span>(b <span class="d_keyword">is</span> a[2..10]);
writeln(b);
writeln(b[7]);      <span class="d_comment">// 10
</span><span class="d_comment">//writeln(b[8]);    // runtime error (unless bounds checks turned off)
</span></pre>

</div>
<div class="blankline"></div>
    <p>See also <a href="../spec/expression.html#SliceOperation"><i>SliceOperation</i></a>.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-length" href="#array-length">Array Length</a></h2>
<div class="blankline"></div>
        <p>When indexing or slicing a static or dynamic array,
        the symbol <span class="d_inlinecode donthyphenate notranslate">$</span> represents the length of the array.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[4] foo;
<span class="d_keyword">int</span>[]  bar = foo;

<span class="d_comment">// These expressions are equivalent:
</span>bar = foo;
bar = foo[];
bar = foo[0 .. 4];
bar = foo[0 .. $];
bar = foo[0 .. foo.length];

<span class="d_keyword">int</span>* p = foo.ptr;
<span class="d_comment">//bar = p[0 .. &dollar;]; // error, '&dollar;' is not defined, since p is not an array
</span>
<span class="d_keyword">int</span> i;
<span class="d_comment">//i = foo[0]+&dollar;; // error, '&dollar;' is not defined, out of scope of [ ]
</span>i = bar[$-1]; <span class="d_comment">// retrieves last element of the array
</span></pre>

</div>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-copying" href="#array-copying">Array Copying</a></h2>
<div class="blankline"></div>
        <p>When the slice operator appears as the left-hand side of an
        assignment expression, it means that the contents of the array are the
        target of the assignment rather than a reference to the array.
        Array copying happens when the left-hand side is a slice, and the
        right-hand side is an array of or pointer to the same type.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] s, t;
<span class="d_keyword">int</span>[] a;

s = t;             <span class="d_comment">// the 3 elements of t are copied into s
</span>s[] = t;           <span class="d_comment">// the 3 elements of t are copied into s
</span>s[] = t[];         <span class="d_comment">// the 3 elements of t are copied into s
</span>s[1..2] = t[0..1]; <span class="d_comment">// same as s[1] = t[0]
</span>s[0..2] = t[1..3]; <span class="d_comment">// same as s[0] = t[1], s[1] = t[2]
</span><span class="d_comment">//s[0..4] = t[0..4]; // error, only 3 elements in s and t
</span><span class="d_comment">//s[0..2] = t;       // error, operands have different lengths
</span>
a = [1, 2];
s[0..2] = a;
<span class="d_keyword">assert</span>(s == [1, 2, 0]);

<span class="d_comment">//a[] = s; // RangeError, lengths don't match
</span>a[0..2] = s[1..3];
<span class="d_keyword">assert</span>(a == [2, 0]);
</pre>

</div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="overlapping-copying" href="#overlapping-copying">Overlapping Copying</a></h3>
<div class="blankline"></div>
        <p>Overlapping copies are an error:</p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[3] s;

    s[0..2] = s[1..3]; <span class="d_comment">// error, overlapping copy
</span>    s[1..3] = s[0..2]; <span class="d_comment">// error, overlapping copy
</span>}
</pre>

</div>
<div class="blankline"></div>
        <p>Disallowing overlapping makes it possible for more aggressive
        parallel code optimizations than possible with the serial
        semantics of C.
        </p>
<div class="blankline"></div>
        <p>If overlapping is required, use
        <a href="../phobos/std_algorithm_mutation.html#.copy"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.mutation.copy</span></a>:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.algorithm;
<span class="d_keyword">int</span>[] s = [1, 2, 3, 4];

copy(s[1..3], s[0..2]);
<span class="d_keyword">assert</span>(s == [2, 3, 3, 4]);
</pre>

</div>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-setting" href="#array-setting">Array Setting</a></h2>
<div class="blankline"></div>
        <p>If a slice operator appears as the left-hand side of an assignment
        expression, and the type of the right-hand side is the same as the
        element type of the left-hand side, then the array contents of the
        left-hand side are set to the right-hand side.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[] a;
<span class="d_keyword">int</span>* p;

s[] = 3;
<span class="d_keyword">assert</span>(s == [3, 3, 3]);

a = s;
a[] = 1;
<span class="d_keyword">assert</span>(s == [1, 1, 1]);

p = s.ptr;
p[0..2] = 2;
<span class="d_keyword">assert</span>(s == [2, 2, 1]);
</pre>

</div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-concatenation" href="#array-concatenation">Array Concatenation</a></h2>
<div class="blankline"></div>
        <p>The binary operator <span class="d_inlinecode donthyphenate notranslate">~</span> is the <i>cat</i> operator. It is used
        to concatenate arrays:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [1, 2];
<span class="d_keyword">assert</span>(a ~ 3 == [1, 2, 3]); <span class="d_comment">// concatenate array with a single value
</span>
<span class="d_keyword">int</span>[] b = a ~ [3, 4];
<span class="d_keyword">assert</span>(b == [1, 2, 3, 4]); <span class="d_comment">// concatenate two arrays
</span></pre>

</div>
<div class="blankline"></div>
        <p>Many languages overload the <span class="d_inlinecode donthyphenate notranslate">+</span> operator for concatenation.
        This confusingly leads to a dilemma - does:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_string">"10"</span> + 3 + 4
</pre>
<div class="blankline"></div>
        <p>produce the number <span class="d_inlinecode donthyphenate notranslate">17</span>, the string <span class="d_inlinecode donthyphenate notranslate">"1034"</span> or the string <span class="d_inlinecode donthyphenate notranslate">"107"</span> as the
        result? It isn't obvious, and the language designers wind up carefully
        writing rules to disambiguate it - rules that get incorrectly
        implemented, overlooked, forgotten, and ignored. It's much better to
        have <span class="d_inlinecode donthyphenate notranslate">+</span> mean addition, and a separate operator to be array
        concatenation.
        </p>
<div class="blankline"></div>
        <p>Concatenation always creates a copy of its operands, even
        if one of the operands is a 0 length array, so:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">auto</span> b = [7];
<span class="d_keyword">auto</span> a = b;      <span class="d_comment">// a refers to b
</span><span class="d_keyword">assert</span>(a <span class="d_keyword">is</span> b);

a = b ~ []; <span class="d_comment">// a refers to a copy of b
</span><span class="d_keyword">assert</span>(a !<span class="d_keyword">is</span> b);
<span class="d_keyword">assert</span>(a == b);
</pre>

</div>
<div class="blankline"></div>
        <p>See also: <a href="../spec/expression.html#identity_expressions"><span class="d_inlinecode donthyphenate notranslate">is</span> operator</a>.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-appending" href="#array-appending">Array Appending</a></h2>
<div class="blankline"></div>
        <p>Similarly, the <span class="d_inlinecode donthyphenate notranslate">~=</span> operator means append, as in:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate">a ~= b; <span class="d_comment">// a becomes the concatenation of a and b
</span></pre>
<div class="blankline"></div>
        <p>Appending does not always create a copy, see <a href="#resize">        setting dynamic array length</a> for details.
        </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-operations" href="#array-operations">Vector Operations</a></h2>
<div class="blankline"></div>
        <p>Many array operations
        can be expressed at a high level rather than as a loop.
        For example, the loop:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate">T[] a, b;
...
<span class="d_keyword">for</span> (size_t i = 0; i &lt; a.length; i++)
    a[i] = b[i] + 4;
</pre>
<div class="blankline"></div>
        <p>assigns to the elements of <span class="d_inlinecode donthyphenate notranslate">a</span> the elements of <span class="d_inlinecode donthyphenate notranslate">b</span>
        with <span class="d_inlinecode donthyphenate notranslate">4</span> added to each. This can also be expressed in
        vector notation as:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate">T[] a, b;
...
a[] = b[] + 4;
</pre>
<div class="blankline"></div>
        <p>A vector operation is indicated by the slice operator appearing
        as the left-hand side of an assignment or an op-assignment expression.
        The right-hand side can be certain combinations of:</p>

<ul><li>An array <a href="../spec/expression.html#SliceOperation"><i>SliceOperation</i></a> of the same length
          and type as the left-hand side</li>
<li>A scalar expression of the same element type as the left-hand side
</li>
</ul>
        <p>The following operations are supported:</p>

<ul><li>Unary: <span class="d_inlinecode donthyphenate notranslate">-</span>, <span class="d_inlinecode donthyphenate notranslate">~</span></li>
<li>Add: <span class="d_inlinecode donthyphenate notranslate">+</span>, <span class="d_inlinecode donthyphenate notranslate">-</span></li>
<li>Mul: <span class="d_inlinecode donthyphenate notranslate">*</span>, <span class="d_inlinecode donthyphenate notranslate">/</span>, <span class="d_inlinecode donthyphenate notranslate">%</span>,</li>
<li>Bitwise: <span class="d_inlinecode donthyphenate notranslate">^</span>, <span class="d_inlinecode donthyphenate notranslate">&amp;</span>, <span class="d_inlinecode donthyphenate notranslate">|</span></li>
<li>Pow: <span class="d_inlinecode donthyphenate notranslate">^^</span>
</li>
</ul>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] a = 0;
<span class="d_keyword">int</span>[] b = [1, 2, 3];

a[] += 10 - (b[] ^^ 2);
<span class="d_keyword">assert</span>(a == [9, 6, 1]);
</pre>

</div>
<div class="blankline"></div>
        <div class="spec-boxes note"><b>Note:</b> In particular, an expression using
        <a href="../spec/expression.html#ConditionalExpression"><i>ConditionalExpression</i></a>,
        <a href="../spec/expression.html#logical_expressions">logical expressions</a>,
        <a href="../spec/expression.html#CmpExpression"><i>CmpExpression</i></a>,
        concatenation <span class="d_inlinecode donthyphenate notranslate">~</span> or a function call is <em>not</em> a vector op.</div>
<div class="blankline"></div>
        <p>The slice on the left and any slices on the right must not overlap.
        All operands are evaluated exactly once, even if the array slice
        has zero elements in it.
        </p>
<div class="blankline"></div>
        <p>If the element type defines matching overloaded operators,
        those methods must be <span class="d_inlinecode donthyphenate notranslate">pure nothrow @nogc</span>.</p>
<div class="blankline"></div>
        <p>The order in which the array elements are computed
        is implementation defined, and may even occur in parallel.
        An application must not depend on this order.
        </p>
<div class="blankline"></div>
        <p><b>Implementation Note:</b> Many vector operations are expected
        to take advantage of any vector math instructions available on
        the target computer.
        </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="rectangular-arrays" href="#rectangular-arrays">Rectangular Arrays</a></h2>
<div class="blankline"></div>
        <p>Experienced FORTRAN numerics programmers know that multidimensional
        "rectangular" arrays for things like matrix operations are much faster than trying to
        access them via pointers to pointers resulting from "array of pointers to array" semantics.
        For example, the D syntax:
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">double</span>[][] matrix;
</pre>

</div>
<div class="blankline"></div>
        <p>declares matrix as an array of pointers to arrays. (Dynamic arrays are implemented as
        pointers to the array data.) Since the arrays can have varying sizes (being dynamically
        sized), this is sometimes called "jagged" arrays. Even worse for optimizing the code, the
        array rows can sometimes point to each other! Fortunately, D static arrays, while using
        the same syntax, are implemented as a fixed rectangular layout in a contiguous block of
        memory:
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio : writeln;

<span class="d_keyword">double</span>[6][3] matrix = 0; <span class="d_comment">// Sets all elements to 0.
</span>
<span class="d_keyword">void</span> main()
{
    writeln(matrix); <span class="d_comment">// [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
</span>}
</pre>

</div>
<div class="blankline"></div>
        <p>Note that dimensions and indices appear in opposite orders. Dimensions in the
        <a href="#declarations">declaration</a> are read right to left whereas indices are read
        left to right:
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio : writeln;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">double</span>[6][3] matrix = 0;
    matrix[2][5] = 3.14; <span class="d_comment">// Assignment to bottom right element.
</span>    writeln(matrix); <span class="d_comment">// [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3.14]]
</span>
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, matrix[5][2])); <span class="d_comment">// Array index out of bounds.
</span>}
</pre>

</div>
<div class="blankline"></div>
<p>More information can be found at <a href="https://wiki.dlang.org/Dense_multidimensional_arrays">Dlang Wiki - Dense Multidimensional Arrays</a>.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-properties" href="#array-properties">Array Properties</a></h2>
<div class="blankline"></div>
        <p>Static array properties are:</p>
<div class="blankline"></div>
    <center><table><caption>Static Array Properties</caption>        <tr><th class="donthyphenate"><b>Property</b></th><th class="donthyphenate"><b>Description</b></th></tr>
        <tr><td> <span class="d_inlinecode donthyphenate notranslate">.init</span></td><td>Returns an array literal with each element of the literal being the <span class="d_inlinecode donthyphenate notranslate">.init</span> property of the array element type.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.sizeof</span></td><td>Returns the array length multiplied by
        the number of bytes per array element.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.length</span></td><td>Returns the number of elements in the array.
        This is a fixed quantity for static arrays. It is of type <span class="d_inlinecode donthyphenate notranslate">size_t</span>.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.ptr</span></td><td>Returns a pointer to the first element of the array.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.dup</span></td><td>Create a dynamic array of the same size and copy the contents of the array into it. The copy will have any immutability or const stripped. If this conversion is invalid the call will not compile.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.idup</span></td><td>Create a dynamic array of the same size and copy the contents of the array into it. The copy is typed as being immutable. If this conversion is invalid the call will not compile.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.tupleof</span></td><td>Returns an <a href="../spec/template.html#homogeneous_sequences">lvalue sequence</a> of each element in the array:
            <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>, <span class="d_keyword">int</span>) { <span class="d_comment">/* ... */</span> }

<span class="d_keyword">int</span>[3] ia = [1, 2, 3];
foo(ia.tupleof); <span class="d_comment">// same as `foo(1, 2, 3);`
</span>
<span class="d_keyword">float</span>[3] fa;
<span class="d_comment">//fa = ia; // error
</span>fa.tupleof = ia.tupleof;
<span class="d_keyword">assert</span>(fa == [1F, 2F, 3F]);
</pre>
            
</div>
            </td></tr>
        </table></center>
<div class="blankline"></div>
        <p>Dynamic array properties are:</p>
<div class="blankline"></div>
    <center><table><caption>Dynamic Array Properties</caption>        <tr><th class="donthyphenate"><b>Property</b></th><th class="donthyphenate"><b>Description</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.init</span></td><td>Returns <span class="d_inlinecode donthyphenate notranslate">null</span>.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.sizeof</span></td><td>Returns the size of the dynamic array reference,
        which is 8 in 32-bit builds and 16 on 64-bit builds.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.length</span></td><td>Get/set number of elements in the
        array. It is of type <span class="d_inlinecode donthyphenate notranslate">size_t</span>.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.capacity</span></td><td>Returns the number of elements that can be appended to the array without reallocating.
            See <a href="#capacity-reserve">here</a> for details.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.ptr</span></td><td>Returns a pointer to the first element of the array.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.dup</span></td><td>Create a dynamic array of the same size and copy the contents of the array into it. The copy will have any immutability or const stripped. If this conversion is invalid the call will not compile.</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">.idup</span></td><td>Create a dynamic array of the same size and copy the contents of the array into it. The copy is typed as being immutable. If this conversion is invalid the call will not compile.</td></tr>
                </table></center>
<div class="blankline"></div>
    <p>Examples:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>* p;
<span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[] a;

p.length; <span class="d_comment">// error, length not known for pointer
</span>s.length; <span class="d_comment">// compile time constant 3
</span>a.length; <span class="d_comment">// runtime value
</span>
p.dup;    <span class="d_comment">// error, length not known
</span>s.dup;    <span class="d_comment">// creates an array of 3 elements, copies
</span>          <span class="d_comment">// elements of s into it
</span>a.dup;    <span class="d_comment">// creates an array of a.length elements, copies
</span>          <span class="d_comment">// elements of a into it
</span></pre>

</div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="resize" href="#resize">Setting Dynamic Array Length</a></h3>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">.length</span> property of a dynamic array can be set
        as the left-hand side of an <span class="d_inlinecode donthyphenate notranslate">=</span> operator:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate">array.length = 7;
</pre>
<div class="blankline"></div>
        <p>This causes the array to be reallocated in place, and the existing
        contents copied over to the new array. If the new array length is
        shorter, the array is not reallocated, and no data is copied.  It is
        equivalent to slicing the array:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">array = array[0..7];
</pre>
<div class="blankline"></div>
        <p>If the new array length is longer, the array is reallocated if necessary,
        preserving the existing elements. The new elements are filled out with the
        default initializer.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="growing" href="#growing">Growing an Array</a></h4>
<div class="blankline"></div>
        <p>To maximize efficiency, the runtime always tries to resize the array
        in place to avoid extra copying. It will do a copy if the new size
        is larger and either:</p>

<ul><li>The array was not <a href="../spec/garbage.html#op_involving_gc">allocated by the GC</a>.</li>
<li>There is no spare <a href="#capacity-reserve">capacity</a> for the array.</li>
<li>Resizing in place would overwrite valid data still accessible in another slice.
</li>
</ul>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">char</span>[] a = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[20];
<span class="d_keyword">char</span>[] b = a[0..10];
<span class="d_keyword">char</span>[] c = a[10..20];
<span class="d_keyword">char</span>[] d = a;

b.length = 15; <span class="d_comment">// always reallocates because extending in place would
</span>               <span class="d_comment">// overwrite other data in a.
</span>b[11] = 'x';   <span class="d_comment">// a[11] and c[1] are not affected
</span><span class="d_keyword">assert</span>(a[11] == <span class="d_keyword">char</span>.init);

d.length = 1;
<span class="d_keyword">assert</span>(d.ptr == a.ptr); <span class="d_comment">// unchanged
</span>
d.length = 20; <span class="d_comment">// also reallocates, because doing this will overwrite a and c
</span><span class="d_keyword">assert</span>(d.ptr != a.ptr);

c.length = 12; <span class="d_comment">// may reallocate in place if space allows, because nothing
</span>               <span class="d_comment">// was allocated after c.
</span>c[5] = 'y';    <span class="d_comment">// may affect contents of a, but not b or d because those
</span>               <span class="d_comment">// were reallocated.
</span>
a.length = 25; <span class="d_comment">// This always reallocates because if c extended in place,
</span>               <span class="d_comment">// then extending a would overwrite c.  If c didn't
</span>               <span class="d_comment">// reallocate in place, it means there was not enough space,
</span>               <span class="d_comment">// which will still be true for a.
</span>a[15] = 'z';   <span class="d_comment">// does not affect c, because either a or c has reallocated.
</span></pre>

</div>
<div class="blankline"></div>
<div class="blankline"></div>
        <p>To guarantee copying behavior, use the <span class="d_inlinecode donthyphenate notranslate">.dup</span> property to ensure
        a unique array that can be resized.
        </p>
<div class="blankline"></div>
        <div class="spec-boxes note"><b>Note:</b> These issues also apply to
        <a href="#array-appending">appending arrays</a> with the <span class="d_inlinecode donthyphenate notranslate">~=</span> operator.
        Concatenation using the <span class="d_inlinecode donthyphenate notranslate">~</span> operator is not affected since it always
        reallocates.
        </div>
<div class="blankline"></div>
        <p>Resizing a dynamic array is a relatively expensive operation.
        So, while the following method of filling an array:
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> fun()
{
    <span class="d_keyword">int</span>[] array;
    <span class="d_keyword">while</span> (1)
    {
        <span class="d_keyword">import</span> core.stdc.stdio : getchar;
        <span class="d_keyword">auto</span> c = getchar;
        <span class="d_keyword">if</span> (!c)
            <span class="d_keyword">break</span>;
        ++array.length;
        array[array.length - 1] = c;
    }
}
</pre>

</div>
<div class="blankline"></div>
        will work, it will be inefficient. A more practical
        approach would be to minimize the number of resizes:
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> fun()
{
    <span class="d_keyword">int</span>[] array;
    array.length = 100;        <span class="d_comment">// guess
</span>    <span class="d_keyword">int</span> i;
    <span class="d_keyword">for</span> (i = 0; ; i++)
    {
        <span class="d_keyword">import</span> core.stdc.stdio : getchar;
        <span class="d_keyword">auto</span> c = getchar;
        <span class="d_keyword">if</span> (!c)
            <span class="d_keyword">break</span>;
        <span class="d_keyword">if</span> (i == array.length)
            array.length *= 2;
        array[i] = c;
    }
    array.length = i;
}
</pre>

</div>
<div class="blankline"></div>
        <p>Base selection of the initial size on expected common
        use cases, which can be determined by instrumenting the code,
        or simply using good judgement.
        For example, when gathering user
        input from the console - it's unlikely to be longer than 80.
        </p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="capacity-reserve" href="#capacity-reserve"><span class="d_inlinecode donthyphenate notranslate">capacity</span> and <span class="d_inlinecode donthyphenate notranslate">reserve</span></a></h3>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">capacity</span> property gives the maximum length a dynamic array
        can grow to without reallocating. If the array does not point to
        GC-allocated memory, the capacity will be zero.
        The spare capacity for an array <em>a</em> is <span class="d_inlinecode donthyphenate notranslate">a.capacity - a.length</span>.</p>
<div class="blankline"></div>
        <p>By default, <span class="d_inlinecode donthyphenate notranslate">capacity</span> will be zero if an element has been stored after the slice.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a;
<span class="d_keyword">assert</span>(a.capacity == 0);
a.length = 3; <span class="d_comment">// may allocate spare capacity too
</span><span class="d_keyword">assert</span>(a.capacity &gt;= 3);
<span class="d_keyword">auto</span> b = a[1..3];
<span class="d_keyword">assert</span>(b.capacity &gt;= 2); <span class="d_comment">// either a or b can append into any spare capacity
</span>b = a[0..2];
<span class="d_keyword">assert</span>(b.capacity == 0);
</pre>
        
</div>
<div class="blankline"></div>
        <div class="spec-boxes rationale"><b>Rationale:</b> This behaviour helps prevent accidental overwriting of
        elements in another slice. It is also necessary to protect immutable
        elements from being overwritten.</div>


<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">reserve</span>
        function expands an array's capacity for use by the
        <a href="#array-appending">append operator</a> or <span class="d_inlinecode donthyphenate notranslate">.length</span> assignment.</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] array;
<span class="d_keyword">const</span> size_t cap = array.reserve(10); <span class="d_comment">// request
</span><span class="d_keyword">assert</span>(cap &gt;= 10); <span class="d_comment">// allocated may be more than request
</span><span class="d_keyword">assert</span>(array.ptr != <span class="d_keyword">null</span>);

<span class="d_keyword">int</span>[] copy = array;
<span class="d_keyword">assert</span>(copy.capacity == cap); <span class="d_comment">// array and copy have same capacity
</span>array ~= [1, 2, 3, 4, 5]; <span class="d_comment">// grow in place
</span><span class="d_keyword">assert</span>(cap == array.capacity); <span class="d_comment">// array memory was not reallocated
</span><span class="d_keyword">assert</span>(copy.ptr == array.ptr);
<span class="d_keyword">assert</span>(copy.capacity == 0);
copy ~= 0; <span class="d_comment">// new allocation
</span><span class="d_keyword">assert</span>(copy.ptr != array.ptr);
</pre>

</div>
        <p>Above, <span class="d_inlinecode donthyphenate notranslate">copy</span>'s length remains zero but it points to the same
        memory allocated by the <span class="d_inlinecode donthyphenate notranslate">reserve</span> call. Because <span class="d_inlinecode donthyphenate notranslate">array</span> is then appended
        to, <span class="d_inlinecode donthyphenate notranslate">copy.ptr + 0</span> no longer points to unused memory - instead that
        is the address of <span class="d_inlinecode donthyphenate notranslate">array[0]</span>. So <span class="d_inlinecode donthyphenate notranslate">copy.capacity</span> will be zero to
        prevent any appending to <span class="d_inlinecode donthyphenate notranslate">copy</span> from overwriting elements in <span class="d_inlinecode donthyphenate notranslate">array</span>.</p>
<div class="blankline"></div>
        <div class="spec-boxes note"><b>Note:</b> The runtime uses the number of appended elements to track the
        start of the spare capacity for the memory allocation.</div>
<div class="blankline"></div>
        <p>When an array with spare capacity has its length reduced, or is
        assigned a slice of itself that ends before the previous last element,
        the capacity will be zero.</p>
<div class="blankline"></div>
        <p>The <span class="d_inlinecode donthyphenate notranslate">@system</span> function <a href="../phobos/object.html#.assumeSafeAppend""><span class="d_inlinecode donthyphenate notranslate">assumeSafeAppend</span></a> allows the
        capacity to be regained, but care must be taken not to overwrite
        immutable elements that may exist in a longer slice.</p>
<div class="blankline"></div>
        <div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] a = [1, 2, 3];
a.length--;
<span class="d_keyword">assert</span>(a.capacity == 0);
a.assumeSafeAppend();
<span class="d_keyword">assert</span>(a.capacity &gt;= 3);
</pre>
        
</div>
<div class="blankline"></div>
        <div class="spec-boxes note"><b>Note:</b> Accessing <span class="d_inlinecode donthyphenate notranslate">.capacity</span> may require the runtime to
        acquire a global lock and perform a cache lookup.</div>
<div class="blankline"></div>
        <div class="spec-boxes best-practice"><b>Best Practices:</b> Avoid intensive use of <span class="d_inlinecode donthyphenate notranslate">.capacity</span> in performance-sensitive code.
        Instead, track the capacity locally when building an array via a unique reference.</div>


<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="func-as-property" href="#func-as-property">Functions as Array Properties</a></h3>
<div class="blankline"></div>
        <p>See <a href="../spec/function.html#pseudo-member">Uniform Function Call Syntax (UFCS)</a>.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="bounds" href="#bounds">Array Bounds Checking</a></h2>
<div class="blankline"></div>
        <p>It is an error to index an array with an index that is less than
        0 or greater than or equal to the array length. If an index is
        out of bounds, an <span class="d_inlinecode donthyphenate notranslate">ArrayIndexError</span> is thrown
        if detected at runtime, and an error is raised if detected at compile
        time. A program may not rely on array bounds checking happening, for
        example, the following program is incorrect:
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">import</span> core.exception;
    <span class="d_keyword">try</span>
    {
        <span class="d_keyword">auto</span> array = [1, 2];
        <span class="d_keyword">for</span> (<span class="d_keyword">auto</span> i = 0; ; i++)
        {
            array[i] = 5;
        }
    }
    <span class="d_keyword">catch</span> (ArrayIndexError)
    {
        <span class="d_comment">// terminate loop
</span>    }
}
</pre>

</div>
<div class="blankline"></div>
        The loop is correctly written:
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> array = [1, 2];
    <span class="d_keyword">for</span> (<span class="d_keyword">auto</span> i = 0; i &lt; array.length; i++)
    {
        array[i] = 5;
    }
}
</pre>

</div>
<div class="blankline"></div>
        <p><b>Implementation Note:</b> Compilers should attempt to detect
        array bounds errors at compile time, for example:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] foo;
<span class="d_keyword">int</span> x = foo[3]; <span class="d_comment">// error, out of bounds
</span></pre>

</div>
<div class="blankline"></div>
        <p>Insertion of array bounds checking code at runtime should be
        turned on and off
        with a compile time switch.
        </p>
<div class="blankline"></div>
        <div class="spec-boxes undefined-behavior"><b>Undefined Behavior:</b> An out of bounds memory access will cause undefined behavior,
            therefore array bounds check is normally enabled in <span class="d_inlinecode donthyphenate notranslate">@safe</span> functions.
            The runtime behavior is part of the language semantics.
        </div>


<div class="blankline"></div>
        <p>See also <a href="../spec/function.html#safe-functions">Safe Functions</a>.</p>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="disable-bounds-check" href="#disable-bounds-check">Disabling Array Bounds Checking</a></h3>
<div class="blankline"></div>
        <p>Insertion of array bounds checking code at runtime may be
            turned off with a compiler switch <a href="../dmd.html#switch-boundscheck"><span class="d_inlinecode donthyphenate notranslate">-boundscheck</span></a>.
        </p>
<div class="blankline"></div>
        <p>If the bounds check in <span class="d_inlinecode donthyphenate notranslate">@system</span> or <span class="d_inlinecode donthyphenate notranslate">@trusted</span> code is disabled,
            the code correctness must still be guaranteed by the code author.
        </p>
<div class="blankline"></div>
        <p>On the other hand, disabling the bounds check in <span class="d_inlinecode donthyphenate notranslate">@safe</span> code will
            break the guaranteed memory safety by compiler. It's not recommended
            unless motivated by speed measurements.
        </p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="array-initialization" href="#array-initialization">Array Initialization</a></h2>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="default-initialization" href="#default-initialization">Default Initialization</a></h3>
<div class="blankline"></div>
        <ul>        <li>Pointers are initialized to <span class="d_inlinecode donthyphenate notranslate">null</span>.</li>
        <li>Static array contents are initialized to the default
        initializer for the array element type.</li>
        <li>Dynamic arrays are initialized to having 0 elements.</li>
        <li>Associative arrays are initialized to having 0 elements.</li>
        </ul>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="length-initialization" href="#length-initialization">Length Initialization</a></h3>
        <p>The <span class="d_inlinecode donthyphenate notranslate">new</span> expression can be used to allocate a dynamic array
        with a specified length by specifying its type and then using the
        <span class="d_inlinecode donthyphenate notranslate">(size)</span> syntax:
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">int</span>[] i = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[](5); <span class="d_comment">//i.length == 5
</span><span class="d_keyword">int</span>[][] j = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[][](10, 5); <span class="d_comment">//j.length == 10, j[0].length == 5
</span></pre>

</div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="void-initialization" href="#void-initialization">Void Initialization</a></h3>
<div class="blankline"></div>
        <p>Void initialization happens when the <i>Initializer</i> for
        an array is <span class="d_inlinecode donthyphenate notranslate">void</span>. What it means is that no initialization
        is done, i.e. the contents of the array will be undefined.
        This is most useful as an efficiency optimization.
        Void initializations are an advanced technique and should only be used
        when profiling indicates that it matters.
        </p>
        <p>To void initialise the <em>elements</em> of a dynamic array use
        <a href="../phobos/std_array.html#.uninitializedArray"><span class="d_inlinecode donthyphenate notranslate">std.array.uninitializedArray</span></a>.
        </p>
<div class="blankline"></div>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="static-init-static" href="#static-init-static">Static Initialization of Statically Allocated Arrays</a></h3>
<div class="blankline"></div>
        <p>Static initalizations are supplied by a list of array
        element values enclosed in <span class="d_inlinecode donthyphenate notranslate">[ ]</span>. The values can be optionally
        preceded by an index and a <span class="d_inlinecode donthyphenate notranslate">:</span>.
        If an index is not supplied, it is set to the previous index
        plus 1, or 0 if it is the first value.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[3] a = [ 1:2, 3 ]; <span class="d_comment">// a[0] = 0, a[1] = 2, a[2] = 3
</span>
<span class="d_keyword">assert</span>(a == [0, 2, 3]);
</pre>

</div>
<div class="blankline"></div>
        <p>This is most handy when the array indices are given by <a href="../spec/enum.html">enums</a>:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">enum</span> Color { red, blue, green }

<span class="d_keyword">int</span>[Color.max + 1] value =
  [ Color.blue :6,
    Color.green:2,
    Color.red  :5 ];

<span class="d_keyword">assert</span>(value == [5, 6, 2]);
</pre>

</div>
<div class="blankline"></div>
        <p>All elements of a static array can be initialized to a specific value with:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">int</span>[4] a = 42; <span class="d_comment">// set all elements of a to 42
</span>
<span class="d_keyword">assert</span>(a == [42, 42, 42, 42]);
</pre>

</div>
<div class="blankline"></div>
        <p>These arrays are statically allocated when they appear in global scope.
        Otherwise, they need to be marked with <span class="d_inlinecode donthyphenate notranslate">const</span> or <span class="d_inlinecode donthyphenate notranslate">static</span>
        storage classes to make them statically allocated arrays.</p>
<div class="blankline"></div>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="special-array" href="#special-array">Special Array Types</a></h2>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="strings" href="#strings">Strings</a></h3>
<div class="blankline"></div>
        <p>A string is an array of <a href="../spec/const3.html#immutable_type">immutable</a>
        (read-only) characters. String literals essentially are
        an easy way to write character array literals.
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate"><span class="d_keyword">char</span>[] arr;
<span class="d_comment">//arr = "abc";          // error, cannot implicitly convert expression `"abc"` of type `string` to `char[]`
</span>arr = <span class="d_string">"abc"</span>.dup;        <span class="d_comment">// ok, allocates mutable copy
</span>
string str1 = <span class="d_string">"abc"</span>;    <span class="d_comment">// ok, same types
</span><span class="d_comment">//str1 = arr;           // error, cannot implicitly convert expression `arr` of type `char[]` to `string`
</span>str1 = arr.idup;        <span class="d_comment">// ok, allocates an immutable copy of elements
</span><span class="d_keyword">assert</span>(str1 == <span class="d_string">"abc"</span>);

string str2 = str1;     <span class="d_comment">// ok, mutable slice of same immutable array contents
</span></pre>

</div>
<div class="blankline"></div>
        <p>The name <span class="d_inlinecode donthyphenate notranslate">string</span> is aliased to <span class="d_inlinecode donthyphenate notranslate">immutable(char)[]</span>.
        The type <span class="d_inlinecode donthyphenate notranslate">immutable(char)[]</span> represents an array of <span class="d_inlinecode donthyphenate notranslate">immutable char</span>s. However, the reference to the string is
        mutable.
        </p>
<pre class="d_code notranslate"><span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)[] s = <span class="d_string">"foo"</span>;
s[0] = 'a';  <span class="d_comment">// error, s[0] is immutable
</span>s = <span class="d_string">"bar"</span>;   <span class="d_comment">// ok, s itself is not immutable
</span></pre>
<div class="blankline"></div>
        <p>If the reference to the string needs to be immutable as well, it can be declared <span class="d_inlinecode donthyphenate notranslate">immutable char[]</span>
        or <span class="d_inlinecode donthyphenate notranslate">immutable string</span>:
        </p>
<pre class="d_code notranslate"><span class="d_keyword">immutable</span> <span class="d_keyword">char</span>[] s = <span class="d_string">"foo"</span>;
s[0] = 'a';  <span class="d_comment">// error, s refers to immutable data
</span>s = <span class="d_string">"bar"</span>;   <span class="d_comment">// error, s is immutable
</span></pre>
<div class="blankline"></div>
        <p>Strings can be copied, compared, concatenated, and appended:</p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate">string s1;
<span class="d_keyword">immutable</span> s2 = <span class="d_string">"ello"</span>;
s1 = s2;
s1 = <span class="d_string">"h"</span> ~ s1;
<span class="d_keyword">if</span> (s1 &gt; <span class="d_string">"farro"</span>)
    s1 ~= <span class="d_string">" there"</span>;

<span class="d_keyword">assert</span>(s1 == <span class="d_string">"hello there"</span>);
</pre>

</div>
<div class="blankline"></div>
        <p>with array semantics. Any generated temporaries get cleaned up
        by the garbage collector (or by using <span class="d_inlinecode donthyphenate notranslate">alloca()</span>).
        Not only that, this works with any
        array not just a special String array.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="string-literal-types" href="#string-literal-types">String Literal Types</a></h4>
<div class="blankline"></div>
        <p>The type of a <a href="../spec/expression.html#string_literals">string literal</a>
        is determined by the semantic phase of compilation. The type is
        determined by implicit conversion rules.
        If there are two equally applicable implicit conversions,
        the result is an error. To
        disambiguate these cases, a cast or a postfix of <span class="d_inlinecode donthyphenate notranslate">c</span>,
        <span class="d_inlinecode donthyphenate notranslate">w</span> or <span class="d_inlinecode donthyphenate notranslate">d</span> can be used:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span>(<span class="d_keyword">wchar</span>)[]) <span class="d_string">"abc"</span> <span class="d_comment">// this is an array of wchar characters
</span><span class="d_string">"abc"w</span>                         <span class="d_comment">// so is this
</span></pre>
<div class="blankline"></div>
        <p>String literals that do not have a postfix character and that
        have not been cast can be implicitly converted between
        <span class="d_inlinecode donthyphenate notranslate">string</span>, <span class="d_inlinecode donthyphenate notranslate">wstring</span>, and <span class="d_inlinecode donthyphenate notranslate">dstring</span> (see below) as necessary.
        </p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> fun()
{
    <span class="d_keyword">char</span> c;
    <span class="d_keyword">wchar</span> w;
    <span class="d_keyword">dchar</span> d;

    c = 'b';     <span class="d_comment">// c is assigned the character 'b'
</span>    w = 'b';     <span class="d_comment">// w is assigned the wchar character 'b'
</span>    <span class="d_comment">//w = 'bc';  // error - only one wchar character at a time
</span>    w = <span class="d_string">"b"</span>[0];  <span class="d_comment">// w is assigned the wchar character 'b'
</span>    w = <span class="d_string">"\r"</span>[0]; <span class="d_comment">// w is assigned the carriage return wchar character
</span>    d = 'd';     <span class="d_comment">// d is assigned the character 'd'
</span>}
</pre>

</div>
<div class="blankline"></div>
<h4><span id="strings_unicode"><a class="anchor" title="Permalink to this section" id="strings-unicode" href="#strings-unicode">Strings and Unicode</a></span></h4>
<div class="blankline"></div>
        <p>String data is encoded as follows:</p>
<div class="blankline"></div>
        <center><table><caption></caption>        <tr><th class="donthyphenate"><b>Alias</b></th><th class="donthyphenate"><b>Type</b></th><th class="donthyphenate"><b>Encoding</b></th></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">string</span></td><td><span class="d_inlinecode donthyphenate notranslate"> immutable(char)[]</span></td><td>UTF-8</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">wstring</span></td><td><span class="d_inlinecode donthyphenate notranslate">immutable(wchar)[]</span></td><td>UTF-16</td></tr>
        <tr><td><span class="d_inlinecode donthyphenate notranslate">dstring</span></td><td><span class="d_inlinecode donthyphenate notranslate">immutable(dchar)[]</span></td><td>UTF-32</td></tr>
        </table></center>
<div class="blankline"></div>
        <p>Note that built-in comparison operators operate on a
        <a href="http://www.unicode.org/glossary/#code_unit">code unit</a> basis.
        The end result for valid strings is the same as that of
        <a href="http://www.unicode.org/glossary/#code_point">code point</a>
        for <a href="http://www.unicode.org/glossary/#code_point">code point</a>
        comparison as long as both strings are in the same
        <a href="http://www.unicode.org/glossary/#normalization_form">normalization form</a>.
        Since normalization is a costly operation not suitable for language
        primitives it's assumed to be enforced by the user.
        </p>
        <p>The standard library lends a hand for comparing strings with mixed encodings
        (by transparently decoding, see <a href="../phobos/std_algorithm.html#.cmp"><span class="d_inlinecode donthyphenate notranslate">std.algorithm.cmp</span></a>),
        <a href="../phobos/std_uni.html#.icmp">case-insensitive comparison</a> and <a href="../phobos/std_uni.html#.normalize">normalization</a>.
        </p>
        <p>Last but not least, a desired string sorting order differs
        by culture and language and is usually nothing like code point
        for code point comparison. The natural order of strings is obtained by applying
        <a href="http://www.unicode.org/reports/tr10/">the Unicode collation algorithm</a>
        that should be implemented in the standard library.
        </p>
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="char-pointers" href="#char-pointers">Character Pointers and C strings</a></h4>
<div class="blankline"></div>
        <p>A pointer to a character can be generated:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate">string str = <span class="d_string">"abcd"</span>;
<span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)* p = &amp;str[3]; <span class="d_comment">// pointer to 4th element
</span><span class="d_keyword">assert</span>(*p == 'd');
p = str.ptr; <span class="d_comment">// pointer to 1st element
</span><span class="d_keyword">assert</span>(*p == 'a');
</pre>

</div>
<div class="blankline"></div>
        <p>Only string <em>literals</em> are zero-terminated in D.
        In general, when transferring a pointer
        to string data to C, append a terminating <span class="d_inlinecode donthyphenate notranslate">'\0'</span>:
        </p>
<div class="blankline"></div>
<div class="runnable-examples">
<pre class="d_code notranslate">string str = <span class="d_string">"ab"</span>;
<span class="d_keyword">assert</span>(str.ptr[2] == '\0'); <span class="d_comment">// OK
</span>str ~= <span class="d_string">"cd"</span>;
<span class="d_comment">// str is no longer zero-terminated
</span>str ~= <span class="d_string">"\0"</span>;
<span class="d_keyword">assert</span>(str[4] == '\0'); <span class="d_comment">// OK
</span>str.length = 2;
<span class="d_comment">// str is no longer correctly zero-terminated
</span><span class="d_keyword">assert</span>(str.ptr[2] != '\0');
</pre>

</div>
<div class="blankline"></div>
        The function <a href="../phobos/std_string.html#.toStringz"><span class="d_inlinecode donthyphenate notranslate">std.string.toStringz</span></a> can also be used.
<div class="blankline"></div>
<h4><a class="anchor" title="Permalink to this section" id="printf" href="#printf">Example: <span class="d_inlinecode donthyphenate notranslate">printf</span></a></h4>
<div class="blankline"></div>
        <p><a href="../phobos/core_stdc_stdio.html#.printf"><span class="d_inlinecode donthyphenate notranslate">core.stdc.stdio.printf</span></a> is a C function and is not part of D. <span class="d_inlinecode donthyphenate notranslate">printf()</span>
        will print C strings, which are 0 terminated. There are two ways
        to use <span class="d_inlinecode donthyphenate notranslate">printf()</span> with D strings. The first is to add a
        terminating 0:
        </p>
<div class="blankline"></div>
<pre class="d_code notranslate">str ~= <span class="d_string">"\0"</span>;
printf(<span class="d_string">"the string is '%s'\n"</span>, str.ptr);
</pre>
<div class="blankline"></div>
        or:
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.string;
printf(<span class="d_string">"the string is '%s'\n"</span>, std.string.toStringz(str));
</pre>
<div class="blankline"></div>
        <p>String literals already have a 0 appended to them, so
        can be used directly:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">printf(<span class="d_string">"the string is '%s'\n"</span>, <span class="d_string">"string literal"</span>.ptr);
</pre>
<div class="blankline"></div>
        <p>So, why does the first string literal to <span class="d_inlinecode donthyphenate notranslate">printf</span> not need
        the <span class="d_inlinecode donthyphenate notranslate">.ptr</span>? The first parameter is prototyped as a <span class="d_inlinecode donthyphenate notranslate">const(char)*</span>, and
        a string literal can be implicitly converted to a <span class="d_inlinecode donthyphenate notranslate">const(char)*</span>.
        The rest of the arguments to <span class="d_inlinecode donthyphenate notranslate">printf</span>, however, are variadic
        (specified by <span class="d_inlinecode donthyphenate notranslate">...</span>),
        and a string literal typed <span class="d_inlinecode donthyphenate notranslate">immutable(char)[]</span> cannot be passed
        to variadic parameters.</p>
<div class="blankline"></div>
        <p>The second way is to use the precision specifier.
        The length comes first, followed by the pointer:</p>
<div class="blankline"></div>
<pre class="d_code notranslate">printf(<span class="d_string">"the string is '%.*s'\n"</span>, <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>)str.length, str.ptr);
</pre>
<div class="blankline"></div>
        <p>The best way is to use <a href="../phobos/std_stdio.html#.writefln"><span class="d_inlinecode donthyphenate notranslate">std.stdio.writefln</span></a>, which can handle
        D strings:</p>
<div class="blankline"></div>
<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
writefln(<span class="d_string">"the string is '%s'"</span>, str);
</pre>
<div class="blankline"></div>
<h3><a class="anchor" title="Permalink to this section" id="void_arrays" href="#void_arrays">Void Arrays</a></h3>
<div class="blankline"></div>
    <p>There is a special type of array which acts as a wildcard that can hold
    arrays of any kind, declared as <span class="d_inlinecode donthyphenate notranslate">void[]</span>. Void arrays are used for
    low-level operations where some kind of array data is being handled, but
    the exact type of the array elements are unimportant. The <span class="d_inlinecode donthyphenate notranslate">.length</span> of a
    void array is the length of the data in bytes, rather than the number of
    elements in its original type. Array indices in indexing and slicing
    operations are interpreted as byte indices.</p>
<div class="blankline"></div>
    <p>Arrays of any type can be implicitly converted to a void array; the
    compiler inserts the appropriate calculations so that the <span class="d_inlinecode donthyphenate notranslate">.length</span> of
    the resulting array's size is in bytes rather than number of elements. Void
    arrays cannot be converted back to the original type without using a cast,
    and it is an error to convert to an array type whose element size does not
    evenly divide the length of the void array.</p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">int</span>[] data1 = [1,2,3];
    <span class="d_keyword">long</span>[] data2;

    <span class="d_keyword">void</span>[] arr = data1;            <span class="d_comment">// OK, int[] implicit converts to void[].
</span>    <span class="d_keyword">assert</span>(data1.length == 3);
    <span class="d_keyword">assert</span>(arr.length == 12);      <span class="d_comment">// length is implicitly converted to bytes.
</span>
    <span class="d_comment">//data1 = arr;                 // Illegal: void[] does not implicitly
</span>                                   <span class="d_comment">// convert to int[].
</span>    <span class="d_keyword">int</span>[] data3 = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[]) arr; <span class="d_comment">// OK, can convert with explicit cast.
</span>    data2 = <span class="d_keyword">cast</span>(<span class="d_keyword">long</span>[]) arr;      <span class="d_comment">// Runtime error: long.sizeof == 8, which
</span>                                   <span class="d_comment">// does not divide arr.length, which is 12
</span>                                   <span class="d_comment">// bytes.
</span>}
</pre>

</div>
<div class="blankline"></div>
    <p>Void arrays can also be static if their length is known at
    compile-time. The length is specified in bytes:</p>
<div class="blankline"></div>
<div class="runnable-examples" data-compile=''>
<pre class="d_code notranslate"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">byte</span>[2] x;
    <span class="d_keyword">int</span>[2] y;

    <span class="d_keyword">void</span>[2] a = x; <span class="d_comment">// OK, lengths match
</span>    <span class="d_keyword">void</span>[2] b = y; <span class="d_comment">// Error: int[2] is 8 bytes long, doesn't fit in 2 bytes.
</span>}
</pre>

</div>
<div class="blankline"></div>
    <p>While it may seem that void arrays are just fancy syntax for
    <span class="d_inlinecode donthyphenate notranslate">ubyte[]</span>, there is a subtle distinction. The garbage collector
    generally will not scan <span class="d_inlinecode donthyphenate notranslate">ubyte[]</span> arrays for pointers, <span class="d_inlinecode donthyphenate notranslate">ubyte[]</span>
    being presumed to contain only pure byte data, not pointers. However, it
    <i>will</i> scan <span class="d_inlinecode donthyphenate notranslate">void[]</span> arrays for pointers, since such an array may
    have been implicitly converted from an array of pointers or an array of
    elements that contain pointers.  Allocating an array that contains pointers
    as <span class="d_inlinecode donthyphenate notranslate">ubyte[]</span> may run the risk of the GC collecting live memory if these
    pointers are the only remaining references to their targets.</p>
<div class="blankline"></div>
<h2><a class="anchor" title="Permalink to this section" id="implicit-conversions" href="#implicit-conversions">Implicit Conversions</a></h2>
<div class="blankline"></div>
        <p>A pointer <span class="d_inlinecode donthyphenate notranslate">T*</span> can be implicitly converted to
        one of the following:</p>
<div class="blankline"></div>
        <ul>        <li><span class="d_inlinecode donthyphenate notranslate">void*</span></li>
        </ul>
<div class="blankline"></div>
        <p>A static array <span class="d_inlinecode donthyphenate notranslate">T[dim]</span> can be implicitly
        converted to
        one of the following (<span class="d_inlinecode donthyphenate notranslate">U</span> is a base class of <span class="d_inlinecode donthyphenate notranslate">T</span>):
        </p>
<div class="blankline"></div>
        <ul>        <li><span class="d_inlinecode donthyphenate notranslate">T[]</span></li>
<div class="blankline"></div>
        <li><span class="d_inlinecode donthyphenate notranslate">const(U)[]</span></li>
        <li><span class="d_inlinecode donthyphenate notranslate">const(U[])</span></li>
        <li><span class="d_inlinecode donthyphenate notranslate">void[]</span></li>
        </ul>
<div class="blankline"></div>
        <p>A dynamic array <span class="d_inlinecode donthyphenate notranslate">T[]</span> can be implicitly converted to one of the
        following (<span class="d_inlinecode donthyphenate notranslate">U</span> is a base class of <span class="d_inlinecode donthyphenate notranslate">T</span>):</p>
<div class="blankline"></div>
        <ul>        <li><span class="d_inlinecode donthyphenate notranslate">const(U)[]</span></li>
        <li><span class="d_inlinecode donthyphenate notranslate">const(U[])</span></li>
        <li><span class="d_inlinecode donthyphenate notranslate">void[]</span></li>
        </ul>
<div class="blankline"></div>
        <p>Array literals can also be implicitly converted to static array
        types. See <a href="../spec/expression.html#array_literals">Array Literals</a>
        for details.</p>
<div class="blankline"></div>
        <p>String literals can also be implicitly converted to static array
        types and character pointer types. See <a href="../spec/expression.html#string_literals">        String Literals</a> for details.</p>
<div class="blankline"></div>

<div style="float: left"><i class="fa fa-angle-left" aria-hidden="true"></i> <a href="../spec/statement.html">Statements</a></div>
<div style="float: right"><a href="../spec/hash-map.html">Associative Arrays</a> <i class="fa fa-angle-right" aria-hidden="true"></i></div>
<div style="clear:both"></div>



        <div class="smallprint" id="copyright">Copyright &copy; 1999-2024 by the <a href="../foundation_overview.html">D Language Foundation</a> | Page generated by
<a href="../spec/ddoc.html">Ddoc</a> on (no date time)</div>
    </div>
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('\x3Cscript src="../js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="../js/dlang.js"></script>
    
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>


<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(addVersionSelector);</script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
</body>
</html>
